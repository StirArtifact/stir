static	O
void	O
add_menu_to_node	function
(	O
char	O
*	O
contents	pointer
,	O
size_t	long
size	long
,	O
NODE	struct
*	O
node	pointer
)	O
;	O
static	O
void	O
insert_text_into_node	function
(	O
NODE	struct
*	O
node	pointer
,	O
long	O
start	int
,	O
char	O
*	O
text	pointer
,	O
int	O
textlen	int
)	O
;	O
static	O
char	O
*	O
dirs_to_add	array
[	O
]	O
=	O
{	O
"dir"	pointer
,	O
"localdir"	pointer
,	O
NULL	O
}	O
;	O
static	O
NODE	struct
*	O
dir_node	pointer
=	O
0	int
;	O
static	O
NODE	struct
*	O
build_dir_node	function
(	O
void	O
)	O
;	O
NODE	struct
*	O
get_dir_node	function
(	O
void	O
)	O
{	O
NODE	struct
*	O
node	pointer
;	O
if	O
(	O
!	O
dir_node	pointer
)	O
dir_node	pointer
=	O
build_dir_node	function
(	O
)	O
;	O
node	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
NODE	struct
)	O
)	O
;	O
*	O
node	pointer
=	O
*	O
dir_node	pointer
;	O
return	O
node	pointer
;	O
}	O
static	O
char	O
*	O
dir_contents	pointer
;	O
static	O
NODE	struct
*	O
build_dir_node	function
(	O
void	O
)	O
{	O
int	O
path_index	int
;	O
char	O
*	O
this_dir	pointer
;	O
NODE	struct
*	O
node	pointer
;	O
node	pointer
=	O
info_create_node	function
(	O
)	O
;	O
node	pointer
->	O
nodename	pointer
=	O
xstrdup	function
(	O
"Top"	pointer
)	O
;	O
node	pointer
->	O
fullpath	pointer
=	O
xstrdup	function
(	O
"dir"	pointer
)	O
;	O
node	pointer
->	O
contents	pointer
=	O
xstrdup	function
(	O
"File: dir,	Node: Top,	This is the top of the INFO tree.\n"	pointer
"\n"	pointer
"This is the Info main menu (aka directory node).\n"	pointer
"A few useful Info commands:\n"	pointer
"\n"	pointer
"  'q' quits;\n"	pointer
"  'H' lists all Info commands;\n"	pointer
"  'h' starts the Info tutorial;\n"	pointer
"  'mTexinfo RET' visits the Texinfo manual, etc.\n"	pointer
)	O
;	O
node	pointer
->	O
nodelen	long
=	O
strlen	function
(	O
node	pointer
->	O
contents	pointer
)	O
;	O
for	O
(	O
this_dir	pointer
=	O
infopath_first	function
(	O
&	O
path_index	int
)	O
;	O
this_dir	pointer
;	O
this_dir	pointer
=	O
infopath_next	function
(	O
&	O
path_index	int
)	O
)	O
{	O
register	O
int	O
da_index	int
;	O
char	O
*	O
from_file	pointer
;	O
if	O
(	O
*	O
this_dir	pointer
==	O
'~'	O
)	O
{	O
char	O
*	O
tilde_expanded_dirname	pointer
;	O
tilde_expanded_dirname	pointer
=	O
tilde_expand_word	function
(	O
this_dir	pointer
)	O
;	O
if	O
(	O
tilde_expanded_dirname	pointer
!=	O
this_dir	pointer
)	O
{	O
this_dir	pointer
=	O
tilde_expanded_dirname	pointer
;	O
}	O
}	O
for	O
(	O
da_index	int
=	O
0	int
;	O
(	O
from_file	pointer
=	O
dirs_to_add	array
[	O
da_index	int
]	O
)	O
;	O
da_index	int
++	O
)	O
{	O
struct	O
stat	struct
finfo	struct
;	O
int	O
statable	int
;	O
int	O
namelen	int
=	O
strlen	function
(	O
from_file	pointer
)	O
;	O
char	O
*	O
fullpath	pointer
=	O
xmalloc	function
(	O
3	int
+	O
strlen	function
(	O
this_dir	pointer
)	O
+	O
namelen	int
)	O
;	O
strcpy	function
(	O
fullpath	pointer
,	O
this_dir	pointer
)	O
;	O
if	O
(	O
!	O
IS_SLASH	O
(	O
fullpath	pointer
[	O
strlen	function
(	O
fullpath	pointer
)	O
-	O
1	int
]	O
)	O
)	O
strcat	function
(	O
fullpath	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
fullpath	pointer
,	O
from_file	pointer
)	O
;	O
statable	int
=	O
(	O
stat	struct
(	O
fullpath	pointer
,	O
&	O
finfo	struct
)	O
==	O
0	int
)	O
;	O
if	O
(	O
statable	int
&&	O
S_ISREG	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
{	O
size_t	long
filesize	long
;	O
int	O
compressed	int
;	O
char	O
*	O
contents	pointer
=	O
filesys_read_info_file	function
(	O
fullpath	pointer
,	O
&	O
filesize	long
,	O
&	O
finfo	struct
,	O
&	O
compressed	int
)	O
;	O
if	O
(	O
contents	pointer
)	O
{	O
add_menu_to_node	function
(	O
contents	pointer
,	O
filesize	long
,	O
node	pointer
)	O
;	O
free	function
(	O
contents	pointer
)	O
;	O
}	O
}	O
free	function
(	O
fullpath	pointer
)	O
;	O
}	O
}	O
node	pointer
->	O
flags	int
|=	O
N_IsDir	int
;	O
dir_contents	pointer
=	O
node	pointer
->	O
contents	pointer
;	O
scan_node_contents	function
(	O
node	pointer
,	O
0	int
,	O
0	int
)	O
;	O
return	O
node	pointer
;	O
}	O
static	O
void	O
add_menu_to_node	function
(	O
char	O
*	O
contents	pointer
,	O
size_t	long
size	long
,	O
NODE	struct
*	O
node	pointer
)	O
{	O
SEARCH_BINDING	struct
contents_binding	struct
,	O
fb_binding	struct
;	O
long	O
contents_offset	long
,	O
fb_offset	long
;	O
contents_binding	struct
.	O
buffer	pointer
=	O
contents	pointer
;	O
contents_binding	struct
.	O
start	int
=	O
0	int
;	O
contents_binding	struct
.	O
end	int
=	O
size	long
;	O
contents_binding	struct
.	O
flags	int
=	O
S_FoldCase	int
|	O
S_SkipDest	int
;	O
fb_binding	struct
.	O
buffer	pointer
=	O
node	pointer
->	O
contents	pointer
;	O
fb_binding	struct
.	O
start	int
=	O
0	int
;	O
fb_binding	struct
.	O
end	int
=	O
node	pointer
->	O
nodelen	long
;	O
fb_binding	struct
.	O
flags	int
=	O
S_FoldCase	int
|	O
S_SkipDest	int
;	O
if	O
(	O
search_forward	function
(	O
INFO_MENU_LABEL	pointer
,	O
&	O
contents_binding	struct
,	O
&	O
contents_offset	long
)	O
!=	O
search_success	int
)	O
return	O
;	O
contents_offset	long
+=	O
skip_whitespace_and_newlines	function
(	O
contents	pointer
+	O
contents_offset	long
)	O
;	O
if	O
(	O
search_forward	function
(	O
INFO_MENU_LABEL	pointer
,	O
&	O
fb_binding	struct
,	O
&	O
fb_offset	long
)	O
!=	O
search_success	int
)	O
{	O
fb_binding	struct
.	O
start	int
=	O
node	pointer
->	O
nodelen	long
;	O
insert_text_into_node	function
(	O
node	pointer
,	O
fb_binding	struct
.	O
start	int
,	O
INFO_MENU_LABEL	pointer
,	O
strlen	function
(	O
INFO_MENU_LABEL	pointer
)	O
)	O
;	O
fb_binding	struct
.	O
buffer	pointer
=	O
node	pointer
->	O
contents	pointer
;	O
fb_binding	struct
.	O
start	int
=	O
0	int
;	O
fb_binding	struct
.	O
end	int
=	O
node	pointer
->	O
nodelen	long
;	O
if	O
(	O
search_forward	function
(	O
INFO_MENU_LABEL	pointer
,	O
&	O
fb_binding	struct
,	O
&	O
fb_offset	long
)	O
!=	O
search_success	int
)	O
abort	function
(	O
)	O
;	O
}	O
fb_binding	struct
.	O
start	int
=	O
fb_offset	long
;	O
fb_offset	long
=	O
find_node_separator	function
(	O
&	O
fb_binding	struct
)	O
;	O
if	O
(	O
fb_offset	long
!=	O
-	O
1	int
)	O
fb_binding	struct
.	O
start	int
=	O
fb_offset	long
;	O
else	O
fb_binding	struct
.	O
start	int
=	O
fb_binding	struct
.	O
end	int
;	O
{	O
int	O
num_found	int
=	O
0	int
;	O
while	O
(	O
(	O
fb_binding	struct
.	O
start	int
>	O
0	int
)	O
&&	O
(	O
whitespace_or_newline	O
(	O
fb_binding	struct
.	O
buffer	pointer
[	O
fb_binding	struct
.	O
start	int
-	O
1	int
]	O
)	O
)	O
)	O
{	O
num_found	int
++	O
;	O
fb_binding	struct
.	O
start	int
--	O
;	O
}	O
if	O
(	O
num_found	int
>=	O
2	int
)	O
{	O
fb_binding	struct
.	O
buffer	pointer
[	O
fb_binding	struct
.	O
start	int
++	O
]	O
=	O
'\n'	O
;	O
fb_binding	struct
.	O
buffer	pointer
[	O
fb_binding	struct
.	O
start	int
++	O
]	O
=	O
'\n'	O
;	O
}	O
else	O
{	O
insert_text_into_node	function
(	O
node	pointer
,	O
fb_binding	struct
.	O
start	int
,	O
"\n\n"	pointer
,	O
2	int
)	O
;	O
fb_binding	struct
.	O
start	int
+=	O
2	int
;	O
}	O
}	O
insert_text_into_node	function
(	O
node	pointer
,	O
fb_binding	struct
.	O
start	int
,	O
contents	pointer
+	O
contents_offset	long
,	O
size	long
-	O
contents_offset	long
)	O
;	O
}	O
static	O
void	O
insert_text_into_node	function
(	O
NODE	struct
*	O
node	pointer
,	O
long	O
start	int
,	O
char	O
*	O
text	pointer
,	O
int	O
textlen	int
)	O
{	O
char	O
*	O
contents	pointer
;	O
long	O
end	int
;	O
end	int
=	O
node	pointer
->	O
nodelen	long
;	O
contents	pointer
=	O
xmalloc	function
(	O
node	pointer
->	O
nodelen	long
+	O
textlen	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
contents	pointer
,	O
node	pointer
->	O
contents	pointer
,	O
start	int
)	O
;	O
memcpy	function
(	O
contents	pointer
+	O
start	int
,	O
text	pointer
,	O
textlen	int
)	O
;	O
memcpy	function
(	O
contents	pointer
+	O
start	int
+	O
textlen	int
,	O
node	pointer
->	O
contents	pointer
+	O
start	int
,	O
end	int
-	O
start	int
+	O
1	int
)	O
;	O
free	function
(	O
node	pointer
->	O
contents	pointer
)	O
;	O
node	pointer
->	O
contents	pointer
=	O
contents	pointer
;	O
node	pointer
->	O
nodelen	long
+=	O
textlen	int
;	O
}	O
REFERENCE	struct
*	O
lookup_dir_entry	function
(	O
char	O
*	O
label	pointer
,	O
int	O
sloppy	int
)	O
{	O
REFERENCE	struct
*	O
entry	pointer
;	O
if	O
(	O
!	O
dir_node	pointer
)	O
dir_node	pointer
=	O
build_dir_node	function
(	O
)	O
;	O
entry	pointer
=	O
info_get_menu_entry_by_label	function
(	O
dir_node	pointer
,	O
label	pointer
,	O
sloppy	int
)	O
;	O
return	O
entry	pointer
;	O
}	O
REFERENCE	struct
*	O
dir_entry_of_infodir	function
(	O
char	O
*	O
label	pointer
,	O
char	O
*	O
searchdir	pointer
)	O
{	O
int	O
da_index	int
;	O
char	O
*	O
dir_filename	pointer
;	O
char	O
*	O
dir_fullpath	pointer
;	O
struct	O
stat	struct
dummy	struct
;	O
char	O
*	O
entry_fullpath	pointer
;	O
NODE	struct
*	O
dir_node	pointer
;	O
REFERENCE	struct
*	O
entry	pointer
;	O
for	O
(	O
da_index	int
=	O
0	int
;	O
(	O
dir_filename	pointer
=	O
dirs_to_add	array
[	O
da_index	int
]	O
)	O
;	O
da_index	int
++	O
)	O
{	O
dir_fullpath	pointer
=	O
info_add_extension	function
(	O
searchdir	pointer
,	O
dir_filename	pointer
,	O
&	O
dummy	struct
)	O
;	O
if	O
(	O
!	O
dir_fullpath	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
IS_ABSOLUTE	O
(	O
dir_fullpath	pointer
)	O
)	O
{	O
char	O
*	O
tmp	pointer
;	O
asprintf	function
(	O
&	O
tmp	pointer
,	O
"./%s"	pointer
,	O
dir_fullpath	pointer
)	O
;	O
free	function
(	O
dir_fullpath	pointer
)	O
;	O
dir_fullpath	pointer
=	O
tmp	pointer
;	O
}	O
dir_node	pointer
=	O
info_get_node	function
(	O
dir_fullpath	pointer
,	O
"Top"	pointer
)	O
;	O
free	function
(	O
dir_fullpath	pointer
)	O
;	O
entry	pointer
=	O
info_get_menu_entry_by_label	function
(	O
dir_node	pointer
,	O
label	pointer
,	O
1	int
)	O
;	O
if	O
(	O
!	O
entry	pointer
||	O
!	O
entry	pointer
->	O
filename	pointer
)	O
{	O
free_history_node	function
(	O
dir_node	pointer
)	O
;	O
continue	O
;	O
}	O
entry	pointer
=	O
info_copy_reference	function
(	O
entry	pointer
)	O
;	O
entry_fullpath	pointer
=	O
info_add_extension	function
(	O
searchdir	pointer
,	O
entry	pointer
->	O
filename	pointer
,	O
&	O
dummy	struct
)	O
;	O
if	O
(	O
entry_fullpath	pointer
)	O
{	O
free	function
(	O
entry	pointer
->	O
filename	pointer
)	O
;	O
entry	pointer
->	O
filename	pointer
=	O
entry_fullpath	pointer
;	O
}	O
free_history_node	function
(	O
dir_node	pointer
)	O
;	O
return	O
entry	pointer
;	O
}	O
return	O
0	int
;	O
}	O
