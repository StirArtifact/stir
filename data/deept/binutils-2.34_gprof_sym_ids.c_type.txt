struct	O
match	struct
{	O
int	O
prev_index	int
;	O
Sym	struct
*	O
prev_match	pointer
;	O
Sym	struct
*	O
first_match	pointer
;	O
Sym	struct
sym	pointer
;	O
}	O
;	O
struct	O
sym_id	struct
{	O
struct	O
sym_id	struct
*	O
next	pointer
;	O
char	O
*	O
spec	pointer
;	O
Table_Id	enum
which_table	enum
;	O
bfd_boolean	int
has_right	int
;	O
struct	O
match	struct
left	struct
,	O
right	struct
;	O
}	O
;	O
static	O
struct	O
sym_id	struct
*	O
id_list	pointer
;	O
static	O
void	O
parse_spec	function
(	O
char	O
*	O
,	O
Sym	struct
*	O
)	O
;	O
static	O
void	O
parse_id	function
(	O
struct	O
sym_id	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
match	struct
(	O
Sym	struct
*	O
,	O
Sym	struct
*	O
)	O
;	O
static	O
void	O
extend_match	function
(	O
struct	O
match	struct
*	O
,	O
Sym	struct
*	O
,	O
Sym_Table	struct
*	O
,	O
bfd_boolean	int
)	O
;	O
Sym_Table	struct
syms	pointer
[	O
NUM_TABLES	int
]	O
;	O
static	O
const	O
char	O
*	O
table_name	array
[	O
]	O
=	O
{	O
"INCL_GRAPH"	pointer
,	O
"EXCL_GRAPH"	pointer
,	O
"INCL_ARCS"	pointer
,	O
"EXCL_ARCS"	pointer
,	O
"INCL_FLAT"	pointer
,	O
"EXCL_FLAT"	pointer
,	O
"INCL_TIME"	pointer
,	O
"EXCL_TIME"	pointer
,	O
"INCL_ANNO"	pointer
,	O
"EXCL_ANNO"	pointer
,	O
"INCL_EXEC"	pointer
,	O
"EXCL_EXEC"	pointer
}	O
;	O
static	O
Sym_Table	struct
right_ids	struct
;	O
static	O
Source_File	struct
non_existent_file	struct
=	O
{	O
0	int
,	O
"<non-existent-file>"	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
;	O
void	O
sym_id_add	function
(	O
const	O
char	O
*	O
spec	pointer
,	O
Table_Id	enum
which_table	enum
)	O
{	O
struct	O
sym_id	struct
*	O
id	int
;	O
int	O
len	long
=	O
strlen	function
(	O
spec	pointer
)	O
;	O
id	int
=	O
(	O
struct	O
sym_id	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
id	int
)	O
+	O
len	long
+	O
1	int
)	O
;	O
memset	function
(	O
id	int
,	O
0	int
,	O
sizeof	O
(	O
*	O
id	int
)	O
)	O
;	O
id	int
->	O
spec	pointer
=	O
(	O
char	O
*	O
)	O
id	int
+	O
sizeof	O
(	O
*	O
id	int
)	O
;	O
strcpy	function
(	O
id	int
->	O
spec	pointer
,	O
spec	pointer
)	O
;	O
id	int
->	O
which_table	enum
=	O
which_table	enum
;	O
id	int
->	O
next	pointer
=	O
id_list	pointer
;	O
id_list	pointer
=	O
id	int
;	O
}	O
static	O
void	O
parse_spec	function
(	O
char	O
*	O
spec	pointer
,	O
Sym	struct
*	O
sym	pointer
)	O
{	O
char	O
*	O
colon	pointer
;	O
sym_init	function
(	O
sym	pointer
)	O
;	O
colon	pointer
=	O
strrchr	function
(	O
spec	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
colon	pointer
)	O
{	O
*	O
colon	pointer
=	O
'\0'	O
;	O
if	O
(	O
colon	pointer
>	O
spec	pointer
)	O
{	O
sym	pointer
->	O
file	pointer
=	O
source_file_lookup_name	function
(	O
spec	pointer
)	O
;	O
if	O
(	O
!	O
sym	pointer
->	O
file	pointer
)	O
sym	pointer
->	O
file	pointer
=	O
&	O
non_existent_file	struct
;	O
}	O
spec	pointer
=	O
colon	pointer
+	O
1	int
;	O
if	O
(	O
strlen	function
(	O
spec	pointer
)	O
)	O
{	O
if	O
(	O
ISDIGIT	O
(	O
spec	pointer
[	O
0	int
]	O
)	O
)	O
sym	pointer
->	O
line_num	int
=	O
atoi	function
(	O
spec	pointer
)	O
;	O
else	O
sym	pointer
->	O
name	pointer
=	O
spec	pointer
;	O
}	O
}	O
else	O
if	O
(	O
strlen	function
(	O
spec	pointer
)	O
)	O
{	O
if	O
(	O
strchr	function
(	O
spec	pointer
,	O
'.'	O
)	O
)	O
{	O
sym	pointer
->	O
file	pointer
=	O
source_file_lookup_name	function
(	O
spec	pointer
)	O
;	O
if	O
(	O
!	O
sym	pointer
->	O
file	pointer
)	O
sym	pointer
->	O
file	pointer
=	O
&	O
non_existent_file	struct
;	O
}	O
else	O
if	O
(	O
ISDIGIT	O
(	O
*	O
spec	pointer
)	O
)	O
{	O
sym	pointer
->	O
line_num	int
=	O
atoi	function
(	O
spec	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strlen	function
(	O
spec	pointer
)	O
)	O
{	O
sym	pointer
->	O
name	pointer
=	O
spec	pointer
;	O
}	O
}	O
}	O
static	O
void	O
parse_id	function
(	O
struct	O
sym_id	struct
*	O
id	int
)	O
{	O
char	O
*	O
slash	pointer
;	O
DBG	O
(	O
IDDEBUG	O
,	O
printf	function
(	O
"[parse_id] %s -> "	pointer
,	O
id	int
->	O
spec	pointer
)	O
)	O
;	O
slash	pointer
=	O
strchr	function
(	O
id	int
->	O
spec	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
slash	pointer
)	O
{	O
parse_spec	function
(	O
slash	pointer
+	O
1	int
,	O
&	O
id	int
->	O
right	struct
.	O
sym	pointer
)	O
;	O
*	O
slash	pointer
=	O
'\0'	O
;	O
id	int
->	O
has_right	int
=	O
TRUE	int
;	O
}	O
parse_spec	function
(	O
id	int
->	O
spec	pointer
,	O
&	O
id	int
->	O
left	struct
.	O
sym	pointer
)	O
;	O
if	O
(	O
debug_level	int
&	O
IDDEBUG	O
)	O
{	O
printf	function
(	O
"%s:"	pointer
,	O
id	int
->	O
left	struct
.	O
sym	pointer
.	O
file	pointer
?	O
id	int
->	O
left	struct
.	O
sym	pointer
.	O
file	pointer
->	O
name	pointer
:	O
"*"	pointer
)	O
;	O
if	O
(	O
id	int
->	O
left	struct
.	O
sym	pointer
.	O
name	pointer
)	O
printf	function
(	O
"%s"	pointer
,	O
id	int
->	O
left	struct
.	O
sym	pointer
.	O
name	pointer
)	O
;	O
else	O
if	O
(	O
id	int
->	O
left	struct
.	O
sym	pointer
.	O
line_num	int
)	O
printf	function
(	O
"%d"	pointer
,	O
id	int
->	O
left	struct
.	O
sym	pointer
.	O
line_num	int
)	O
;	O
else	O
printf	function
(	O
"*"	pointer
)	O
;	O
if	O
(	O
id	int
->	O
has_right	int
)	O
{	O
printf	function
(	O
"/%s:"	pointer
,	O
id	int
->	O
right	struct
.	O
sym	pointer
.	O
file	pointer
?	O
id	int
->	O
right	struct
.	O
sym	pointer
.	O
file	pointer
->	O
name	pointer
:	O
"*"	pointer
)	O
;	O
if	O
(	O
id	int
->	O
right	struct
.	O
sym	pointer
.	O
name	pointer
)	O
printf	function
(	O
"%s"	pointer
,	O
id	int
->	O
right	struct
.	O
sym	pointer
.	O
name	pointer
)	O
;	O
else	O
if	O
(	O
id	int
->	O
right	struct
.	O
sym	pointer
.	O
line_num	int
)	O
printf	function
(	O
"%d"	pointer
,	O
id	int
->	O
right	struct
.	O
sym	pointer
.	O
line_num	int
)	O
;	O
else	O
printf	function
(	O
"*"	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
match	struct
(	O
Sym	struct
*	O
pattern	pointer
,	O
Sym	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
pattern	pointer
->	O
file	pointer
&&	O
pattern	pointer
->	O
file	pointer
!=	O
sym	pointer
->	O
file	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
pattern	pointer
->	O
line_num	int
&&	O
pattern	pointer
->	O
line_num	int
!=	O
sym	pointer
->	O
line_num	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
pattern	pointer
->	O
name	pointer
)	O
{	O
const	O
char	O
*	O
sym_name	pointer
=	O
sym	pointer
->	O
name	pointer
;	O
if	O
(	O
*	O
sym_name	pointer
&&	O
bfd_get_symbol_leading_char	function
(	O
core_bfd	pointer
)	O
==	O
*	O
sym_name	pointer
)	O
sym_name	pointer
++	O
;	O
if	O
(	O
strcmp	function
(	O
pattern	pointer
->	O
name	pointer
,	O
sym_name	pointer
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
extend_match	function
(	O
struct	O
match	struct
*	O
m	pointer
,	O
Sym	struct
*	O
sym	pointer
,	O
Sym_Table	struct
*	O
tab	pointer
,	O
bfd_boolean	int
second_pass	int
)	O
{	O
if	O
(	O
m	pointer
->	O
prev_match	pointer
!=	O
sym	pointer
-	O
1	int
)	O
{	O
if	O
(	O
second_pass	int
)	O
{	O
tab	pointer
->	O
base	int
[	O
tab	pointer
->	O
len	long
]	O
=	O
*	O
sym	pointer
;	O
m	pointer
->	O
prev_index	int
=	O
tab	pointer
->	O
len	long
;	O
tab	pointer
->	O
base	int
[	O
tab	pointer
->	O
len	long
]	O
.	O
next	pointer
=	O
m	pointer
->	O
first_match	pointer
;	O
m	pointer
->	O
first_match	pointer
=	O
&	O
tab	pointer
->	O
base	int
[	O
tab	pointer
->	O
len	long
]	O
;	O
}	O
++	O
tab	pointer
->	O
len	long
;	O
}	O
if	O
(	O
second_pass	int
)	O
tab	pointer
->	O
base	int
[	O
m	pointer
->	O
prev_index	int
]	O
.	O
end_addr	long
=	O
sym	pointer
->	O
end_addr	long
;	O
m	pointer
->	O
prev_match	pointer
=	O
sym	pointer
;	O
}	O
void	O
sym_id_parse	function
(	O
void	O
)	O
{	O
Sym	struct
*	O
sym	pointer
,	O
*	O
left	struct
,	O
*	O
right	struct
;	O
struct	O
sym_id	struct
*	O
id	int
;	O
Sym_Table	struct
*	O
tab	pointer
;	O
for	O
(	O
id	int
=	O
id_list	pointer
;	O
id	int
;	O
id	int
=	O
id	int
->	O
next	pointer
)	O
parse_id	function
(	O
id	int
)	O
;	O
for	O
(	O
sym	pointer
=	O
symtab	struct
.	O
base	int
;	O
sym	pointer
<	O
symtab	struct
.	O
limit	pointer
;	O
++	O
sym	pointer
)	O
{	O
for	O
(	O
id	int
=	O
id_list	pointer
;	O
id	int
;	O
id	int
=	O
id	int
->	O
next	pointer
)	O
{	O
if	O
(	O
match	struct
(	O
&	O
id	int
->	O
left	struct
.	O
sym	pointer
,	O
sym	pointer
)	O
)	O
extend_match	function
(	O
&	O
id	int
->	O
left	struct
,	O
sym	pointer
,	O
&	O
syms	pointer
[	O
id	int
->	O
which_table	enum
]	O
,	O
FALSE	int
)	O
;	O
if	O
(	O
id	int
->	O
has_right	int
&&	O
match	struct
(	O
&	O
id	int
->	O
right	struct
.	O
sym	pointer
,	O
sym	pointer
)	O
)	O
extend_match	function
(	O
&	O
id	int
->	O
right	struct
,	O
sym	pointer
,	O
&	O
right_ids	struct
,	O
FALSE	int
)	O
;	O
}	O
}	O
for	O
(	O
tab	pointer
=	O
syms	pointer
;	O
tab	pointer
<	O
&	O
syms	pointer
[	O
NUM_TABLES	int
]	O
;	O
++	O
tab	pointer
)	O
{	O
if	O
(	O
tab	pointer
->	O
len	long
)	O
{	O
tab	pointer
->	O
base	int
=	O
(	O
Sym	struct
*	O
)	O
xmalloc	function
(	O
tab	pointer
->	O
len	long
*	O
sizeof	O
(	O
Sym	struct
)	O
)	O
;	O
tab	pointer
->	O
limit	pointer
=	O
tab	pointer
->	O
base	int
+	O
tab	pointer
->	O
len	long
;	O
tab	pointer
->	O
len	long
=	O
0	int
;	O
}	O
}	O
if	O
(	O
right_ids	struct
.	O
len	long
)	O
{	O
right_ids	struct
.	O
base	int
=	O
(	O
Sym	struct
*	O
)	O
xmalloc	function
(	O
right_ids	struct
.	O
len	long
*	O
sizeof	O
(	O
Sym	struct
)	O
)	O
;	O
right_ids	struct
.	O
limit	pointer
=	O
right_ids	struct
.	O
base	int
+	O
right_ids	struct
.	O
len	long
;	O
right_ids	struct
.	O
len	long
=	O
0	int
;	O
}	O
for	O
(	O
sym	pointer
=	O
symtab	struct
.	O
base	int
;	O
sym	pointer
<	O
symtab	struct
.	O
limit	pointer
;	O
++	O
sym	pointer
)	O
{	O
for	O
(	O
id	int
=	O
id_list	pointer
;	O
id	int
;	O
id	int
=	O
id	int
->	O
next	pointer
)	O
{	O
if	O
(	O
match	struct
(	O
&	O
id	int
->	O
left	struct
.	O
sym	pointer
,	O
sym	pointer
)	O
)	O
extend_match	function
(	O
&	O
id	int
->	O
left	struct
,	O
sym	pointer
,	O
&	O
syms	pointer
[	O
id	int
->	O
which_table	enum
]	O
,	O
TRUE	int
)	O
;	O
if	O
(	O
id	int
->	O
has_right	int
&&	O
match	struct
(	O
&	O
id	int
->	O
right	struct
.	O
sym	pointer
,	O
sym	pointer
)	O
)	O
extend_match	function
(	O
&	O
id	int
->	O
right	struct
,	O
sym	pointer
,	O
&	O
right_ids	struct
,	O
TRUE	int
)	O
;	O
}	O
}	O
for	O
(	O
id	int
=	O
id_list	pointer
;	O
id	int
;	O
id	int
=	O
id	int
->	O
next	pointer
)	O
{	O
if	O
(	O
id	int
->	O
has_right	int
)	O
{	O
for	O
(	O
left	struct
=	O
id	int
->	O
left	struct
.	O
first_match	pointer
;	O
left	struct
;	O
left	struct
=	O
left	struct
->	O
next	pointer
)	O
{	O
for	O
(	O
right	struct
=	O
id	int
->	O
right	struct
.	O
first_match	pointer
;	O
right	struct
;	O
right	struct
=	O
right	struct
->	O
next	pointer
)	O
{	O
DBG	O
(	O
IDDEBUG	O
,	O
printf	function
(	O
"[sym_id_parse]: arc %s:%s(%lx-%lx) -> %s:%s(%lx-%lx) to %s\n"	pointer
,	O
left	struct
->	O
file	pointer
?	O
left	struct
->	O
file	pointer
->	O
name	pointer
:	O
"*"	pointer
,	O
left	struct
->	O
name	pointer
?	O
left	struct
->	O
name	pointer
:	O
"*"	pointer
,	O
(	O
unsigned	O
long	O
)	O
left	struct
->	O
addr	pointer
,	O
(	O
unsigned	O
long	O
)	O
left	struct
->	O
end_addr	long
,	O
right	struct
->	O
file	pointer
?	O
right	struct
->	O
file	pointer
->	O
name	pointer
:	O
"*"	pointer
,	O
right	struct
->	O
name	pointer
?	O
right	struct
->	O
name	pointer
:	O
"*"	pointer
,	O
(	O
unsigned	O
long	O
)	O
right	struct
->	O
addr	pointer
,	O
(	O
unsigned	O
long	O
)	O
right	struct
->	O
end_addr	long
,	O
table_name	array
[	O
id	int
->	O
which_table	enum
]	O
)	O
)	O
;	O
arc_add	function
(	O
left	struct
,	O
right	struct
,	O
(	O
unsigned	O
long	O
)	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
tab	pointer
=	O
&	O
syms	pointer
[	O
0	int
]	O
;	O
tab	pointer
<	O
&	O
syms	pointer
[	O
NUM_TABLES	int
]	O
;	O
++	O
tab	pointer
)	O
{	O
DBG	O
(	O
IDDEBUG	O
,	O
printf	function
(	O
"[sym_id_parse] syms[%s]:\n"	pointer
,	O
table_name	array
[	O
tab	pointer
-	O
&	O
syms	pointer
[	O
0	int
]	O
]	O
)	O
)	O
;	O
symtab_finalize	function
(	O
tab	pointer
)	O
;	O
}	O
}	O
bfd_boolean	int
sym_id_arc_is_present	function
(	O
Sym_Table	struct
*	O
sym_tab	pointer
,	O
Sym	struct
*	O
from	pointer
,	O
Sym	struct
*	O
to	pointer
)	O
{	O
Sym	struct
*	O
sym	pointer
;	O
for	O
(	O
sym	pointer
=	O
sym_tab	pointer
->	O
base	int
;	O
sym	pointer
<	O
sym_tab	pointer
->	O
limit	pointer
;	O
++	O
sym	pointer
)	O
{	O
if	O
(	O
from	pointer
->	O
addr	pointer
>=	O
sym	pointer
->	O
addr	pointer
&&	O
from	pointer
->	O
addr	pointer
<=	O
sym	pointer
->	O
end_addr	long
&&	O
arc_lookup	function
(	O
sym	pointer
,	O
to	pointer
)	O
)	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
