extern	O
struct	O
display	struct
*	O
display	struct
;	O
extern	O
struct	O
win	struct
*	O
fore	pointer
,	O
*	O
windows	pointer
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
int	O
captionalways	int
;	O
extern	O
struct	O
LayFuncs	struct
BlankLf	struct
;	O
extern	O
int	O
focusminwidth	int
,	O
focusminheight	int
;	O
static	O
void	O
CanvasInitBlank	function
(	O
cv	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
{	O
cv	pointer
->	O
c_blank	struct
.	O
l_cvlist	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_width	int
=	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_height	int
=	O
cv	pointer
->	O
c_ye	int
-	O
cv	pointer
->	O
c_ys	int
+	O
1	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_x	int
=	O
cv	pointer
->	O
c_blank	struct
.	O
l_y	int
=	O
0	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_layfn	pointer
=	O
&	O
BlankLf	struct
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_data	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_next	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_bottom	pointer
=	O
&	O
cv	pointer
->	O
c_blank	struct
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_blocking	int
=	O
0	int
;	O
cv	pointer
->	O
c_layer	pointer
=	O
&	O
cv	pointer
->	O
c_blank	struct
;	O
}	O
static	O
void	O
FreePerp	function
(	O
pcv	pointer
)	O
struct	O
canvas	struct
*	O
pcv	pointer
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
if	O
(	O
!	O
pcv	pointer
->	O
c_slperp	pointer
)	O
return	O
;	O
cv	pointer
=	O
pcv	pointer
->	O
c_slperp	pointer
;	O
cv	pointer
->	O
c_slprev	pointer
=	O
pcv	pointer
->	O
c_slprev	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slprev	pointer
)	O
cv	pointer
->	O
c_slprev	pointer
->	O
c_slnext	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_slback	pointer
=	O
pcv	pointer
->	O
c_slback	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slback	pointer
&&	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
==	O
pcv	pointer
)	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_slorient	int
=	O
pcv	pointer
->	O
c_slorient	int
;	O
cv	pointer
->	O
c_slweight	int
=	O
pcv	pointer
->	O
c_slweight	int
;	O
while	O
(	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
;	O
cv	pointer
->	O
c_slorient	int
=	O
pcv	pointer
->	O
c_slorient	int
;	O
cv	pointer
->	O
c_slback	pointer
=	O
pcv	pointer
->	O
c_slback	pointer
;	O
cv	pointer
->	O
c_slweight	int
=	O
pcv	pointer
->	O
c_slweight	int
;	O
}	O
cv	pointer
->	O
c_slnext	pointer
=	O
pcv	pointer
->	O
c_slnext	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slnext	pointer
)	O
cv	pointer
->	O
c_slnext	pointer
->	O
c_slprev	pointer
=	O
cv	pointer
;	O
LayerCleanupMemory	function
(	O
&	O
pcv	pointer
->	O
c_blank	struct
)	O
;	O
free	function
(	O
pcv	pointer
)	O
;	O
}	O
void	O
FreeCanvas	function
(	O
cv	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
{	O
struct	O
viewport	struct
*	O
vp	pointer
,	O
*	O
nvp	pointer
;	O
struct	O
canvas	struct
*	O
*	O
cvp	pointer
;	O
struct	O
win	struct
*	O
p	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slprev	pointer
)	O
cv	pointer
->	O
c_slprev	pointer
->	O
c_slnext	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slnext	pointer
)	O
cv	pointer
->	O
c_slnext	pointer
->	O
c_slprev	pointer
=	O
cv	pointer
->	O
c_slprev	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slback	pointer
&&	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
==	O
cv	pointer
)	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
?	O
cv	pointer
->	O
c_slnext	pointer
:	O
cv	pointer
->	O
c_slprev	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
{	O
while	O
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
FreeCanvas	function
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
;	O
LayerCleanupMemory	function
(	O
&	O
cv	pointer
->	O
c_blank	struct
)	O
;	O
free	function
(	O
cv	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
display	struct
)	O
{	O
if	O
(	O
D_forecv	O
==	O
cv	pointer
)	O
D_forecv	O
=	O
0	int
;	O
for	O
(	O
cvp	pointer
=	O
&	O
D_cvlist	O
;	O
*	O
cvp	pointer
;	O
cvp	pointer
=	O
&	O
(	O
*	O
cvp	pointer
)	O
->	O
c_next	pointer
)	O
if	O
(	O
*	O
cvp	pointer
==	O
cv	pointer
)	O
{	O
*	O
cvp	pointer
=	O
cv	pointer
->	O
c_next	pointer
;	O
break	O
;	O
}	O
}	O
p	pointer
=	O
cv	pointer
->	O
c_layer	pointer
?	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
:	O
0	int
;	O
SetCanvasWindow	function
(	O
cv	pointer
,	O
0	int
)	O
;	O
if	O
(	O
p	pointer
)	O
WindowChanged	function
(	O
p	pointer
,	O
'u'	O
)	O
;	O
if	O
(	O
flayer	pointer
==	O
cv	pointer
->	O
c_layer	pointer
)	O
flayer	pointer
=	O
0	int
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
nvp	pointer
)	O
{	O
vp	pointer
->	O
v_canvas	pointer
=	O
0	int
;	O
nvp	pointer
=	O
vp	pointer
->	O
v_next	pointer
;	O
vp	pointer
->	O
v_next	pointer
=	O
0	int
;	O
free	function
(	O
vp	pointer
)	O
;	O
}	O
evdeq	function
(	O
&	O
cv	pointer
->	O
c_captev	struct
)	O
;	O
LayerCleanupMemory	function
(	O
&	O
cv	pointer
->	O
c_blank	struct
)	O
;	O
free	function
(	O
cv	pointer
)	O
;	O
}	O
int	O
CountCanvas	function
(	O
cv	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
{	O
int	O
num	int
=	O
0	int
;	O
for	O
(	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
{	O
struct	O
canvas	struct
*	O
cvp	pointer
;	O
int	O
nump	int
=	O
1	int
,	O
n	int
;	O
for	O
(	O
cvp	pointer
=	O
cv	pointer
->	O
c_slperp	pointer
;	O
cvp	pointer
;	O
cvp	pointer
=	O
cvp	pointer
->	O
c_slnext	pointer
)	O
if	O
(	O
cvp	pointer
->	O
c_slperp	pointer
)	O
{	O
n	int
=	O
CountCanvas	function
(	O
cvp	pointer
->	O
c_slperp	pointer
)	O
;	O
if	O
(	O
n	int
>	O
nump	int
)	O
nump	int
=	O
n	int
;	O
}	O
num	int
+=	O
nump	int
;	O
}	O
else	O
num	int
++	O
;	O
}	O
return	O
num	int
;	O
}	O
int	O
CountCanvasPerp	function
(	O
cv	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
{	O
struct	O
canvas	struct
*	O
cvp	pointer
;	O
int	O
num	int
=	O
1	int
,	O
n	int
;	O
for	O
(	O
cvp	pointer
=	O
cv	pointer
->	O
c_slperp	pointer
;	O
cvp	pointer
;	O
cvp	pointer
=	O
cvp	pointer
->	O
c_slnext	pointer
)	O
if	O
(	O
cvp	pointer
->	O
c_slperp	pointer
)	O
{	O
n	int
=	O
CountCanvas	function
(	O
cvp	pointer
->	O
c_slperp	pointer
)	O
;	O
if	O
(	O
n	int
>	O
num	int
)	O
num	int
=	O
n	int
;	O
}	O
return	O
num	int
;	O
}	O
struct	O
canvas	struct
*	O
FindCanvas	function
(	O
x	int
,	O
y	int
)	O
int	O
x	int
,	O
y	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
*	O
mcv	pointer
=	O
0	int
;	O
int	O
m	union
,	O
mm	struct
=	O
0	int
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
if	O
(	O
x	int
>=	O
cv	pointer
->	O
c_xs	int
&&	O
x	int
<=	O
cv	pointer
->	O
c_xe	int
&&	O
y	int
>=	O
cv	pointer
->	O
c_ys	int
&&	O
y	int
<=	O
cv	pointer
->	O
c_ye	int
+	O
1	int
)	O
return	O
cv	pointer
;	O
if	O
(	O
cv	pointer
==	O
D_forecv	O
)	O
continue	O
;	O
m	union
=	O
0	int
;	O
if	O
(	O
x	int
>=	O
D_forecv	O
->	O
c_xs	int
&&	O
x	int
<=	O
D_forecv	O
->	O
c_xe	int
)	O
{	O
if	O
(	O
x	int
<	O
cv	pointer
->	O
c_xs	int
||	O
x	int
>	O
cv	pointer
->	O
c_xe	int
)	O
continue	O
;	O
if	O
(	O
y	int
<	O
D_forecv	O
->	O
c_ys	int
&&	O
y	int
<	O
cv	pointer
->	O
c_ys	int
)	O
continue	O
;	O
if	O
(	O
y	int
>	O
D_forecv	O
->	O
c_ye	int
+	O
1	int
&&	O
y	int
>	O
cv	pointer
->	O
c_ye	int
+	O
1	int
)	O
continue	O
;	O
if	O
(	O
y	int
<	O
cv	pointer
->	O
c_ys	int
)	O
m	union
=	O
cv	pointer
->	O
c_ys	int
-	O
y	int
;	O
if	O
(	O
y	int
>	O
cv	pointer
->	O
c_ye	int
+	O
1	int
)	O
m	union
=	O
y	int
-	O
(	O
cv	pointer
->	O
c_ye	int
+	O
1	int
)	O
;	O
}	O
if	O
(	O
y	int
>=	O
D_forecv	O
->	O
c_ys	int
&&	O
y	int
<=	O
D_forecv	O
->	O
c_ye	int
+	O
1	int
)	O
{	O
if	O
(	O
y	int
<	O
cv	pointer
->	O
c_ys	int
||	O
y	int
>	O
cv	pointer
->	O
c_ye	int
+	O
1	int
)	O
continue	O
;	O
if	O
(	O
x	int
<	O
D_forecv	O
->	O
c_xs	int
&&	O
x	int
<	O
cv	pointer
->	O
c_xs	int
)	O
continue	O
;	O
if	O
(	O
x	int
>	O
D_forecv	O
->	O
c_xe	int
&&	O
x	int
>	O
cv	pointer
->	O
c_xe	int
)	O
continue	O
;	O
if	O
(	O
x	int
<	O
cv	pointer
->	O
c_xs	int
)	O
m	union
=	O
cv	pointer
->	O
c_xs	int
-	O
x	int
;	O
if	O
(	O
x	int
>	O
cv	pointer
->	O
c_xe	int
)	O
m	union
=	O
x	int
-	O
cv	pointer
->	O
c_xe	int
;	O
}	O
if	O
(	O
m	union
&&	O
(	O
!	O
mm	struct
||	O
m	union
<	O
mm	struct
)	O
)	O
{	O
mcv	pointer
=	O
cv	pointer
;	O
mm	struct
=	O
m	union
;	O
}	O
}	O
return	O
mcv	pointer
?	O
mcv	pointer
:	O
D_forecv	O
;	O
}	O
void	O
SetCanvasWindow	function
(	O
cv	pointer
,	O
wi	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
win	struct
*	O
wi	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
0	int
,	O
*	O
*	O
pp	pointer
;	O
struct	O
layer	struct
*	O
l	pointer
;	O
struct	O
canvas	struct
*	O
cvp	pointer
,	O
*	O
*	O
cvpp	pointer
;	O
l	pointer
=	O
cv	pointer
->	O
c_layer	pointer
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
l	pointer
)	O
{	O
for	O
(	O
cvpp	pointer
=	O
&	O
l	pointer
->	O
l_cvlist	pointer
;	O
(	O
cvp	pointer
=	O
*	O
cvpp	pointer
)	O
;	O
cvpp	pointer
=	O
&	O
cvp	pointer
->	O
c_lnext	pointer
)	O
if	O
(	O
cvp	pointer
==	O
cv	pointer
)	O
break	O
;	O
ASSERT	O
(	O
cvp	pointer
)	O
;	O
*	O
cvpp	pointer
=	O
cvp	pointer
->	O
c_lnext	pointer
;	O
p	pointer
=	O
Layer2Window	O
(	O
l	pointer
)	O
;	O
l	pointer
=	O
cv	pointer
->	O
c_layer	pointer
;	O
cv	pointer
->	O
c_layer	pointer
=	O
0	int
;	O
if	O
(	O
p	pointer
&&	O
cv	pointer
==	O
D_forecv	O
)	O
{	O
ReleaseAutoWritelock	function
(	O
display	struct
,	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
w_silence	int
)	O
{	O
SetTimeout	function
(	O
&	O
p	pointer
->	O
w_silenceev	struct
,	O
p	pointer
->	O
w_silencewait	int
*	O
1000	int
)	O
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_silenceev	struct
)	O
;	O
}	O
D_other	O
=	O
fore	pointer
;	O
D_fore	O
=	O
0	int
;	O
}	O
if	O
(	O
l	pointer
->	O
l_cvlist	pointer
==	O
0	int
&&	O
(	O
p	pointer
==	O
0	int
||	O
l	pointer
!=	O
p	pointer
->	O
w_savelayer	pointer
)	O
)	O
KillLayerChain	function
(	O
l	pointer
)	O
;	O
}	O
if	O
(	O
wi	pointer
&&	O
wi	pointer
->	O
w_type	int
!=	O
W_TYPE_GROUP	int
)	O
{	O
l	pointer
=	O
&	O
wi	pointer
->	O
w_layer	struct
;	O
if	O
(	O
wi	pointer
->	O
w_savelayer	pointer
&&	O
(	O
wi	pointer
->	O
w_blocked	int
||	O
wi	pointer
->	O
w_savelayer	pointer
->	O
l_cvlist	pointer
==	O
0	int
)	O
)	O
l	pointer
=	O
wi	pointer
->	O
w_savelayer	pointer
;	O
}	O
else	O
{	O
l	pointer
=	O
&	O
cv	pointer
->	O
c_blank	struct
;	O
if	O
(	O
wi	pointer
)	O
l	pointer
->	O
l_data	pointer
=	O
(	O
char	O
*	O
)	O
wi	pointer
;	O
else	O
l	pointer
->	O
l_data	pointer
=	O
0	int
;	O
}	O
ASSERT	O
(	O
l	pointer
->	O
l_cvlist	pointer
!=	O
cv	pointer
)	O
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
l	pointer
->	O
l_cvlist	pointer
;	O
l	pointer
->	O
l_cvlist	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_layer	pointer
=	O
l	pointer
;	O
cv	pointer
->	O
c_xoff	int
=	O
cv	pointer
->	O
c_xs	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
cv	pointer
->	O
c_ys	int
;	O
RethinkViewportOffsets	function
(	O
cv	pointer
)	O
;	O
if	O
(	O
flayer	pointer
==	O
0	int
)	O
flayer	pointer
=	O
l	pointer
;	O
if	O
(	O
wi	pointer
&&	O
wi	pointer
->	O
w_type	int
==	O
W_TYPE_GROUP	int
)	O
{	O
struct	O
display	struct
*	O
d	int
=	O
display	struct
;	O
struct	O
layer	struct
*	O
oldflayer	pointer
=	O
flayer	pointer
;	O
flayer	pointer
=	O
l	pointer
;	O
display_windows	function
(	O
0	int
,	O
0	int
,	O
wi	pointer
)	O
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
display	struct
=	O
d	int
;	O
}	O
if	O
(	O
wi	pointer
&&	O
D_other	O
==	O
wi	pointer
)	O
D_other	O
=	O
wi	pointer
->	O
w_next	pointer
;	O
if	O
(	O
cv	pointer
==	O
D_forecv	O
)	O
{	O
D_fore	O
=	O
wi	pointer
;	O
fore	pointer
=	O
D_fore	O
;	O
if	O
(	O
wi	pointer
)	O
{	O
ObtainAutoWritelock	function
(	O
display	struct
,	O
wi	pointer
)	O
;	O
if	O
(	O
windows	pointer
!=	O
wi	pointer
)	O
{	O
for	O
(	O
pp	pointer
=	O
&	O
windows	pointer
;	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
;	O
pp	pointer
=	O
&	O
p	pointer
->	O
w_next	pointer
)	O
if	O
(	O
p	pointer
==	O
wi	pointer
)	O
break	O
;	O
ASSERT	O
(	O
p	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
->	O
w_next	pointer
;	O
p	pointer
->	O
w_next	pointer
=	O
windows	pointer
;	O
windows	pointer
=	O
p	pointer
;	O
WListLinkChanged	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
cv_winid_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
ox	int
,	O
oy	int
;	O
struct	O
canvas	struct
*	O
cv	pointer
=	O
(	O
struct	O
canvas	struct
*	O
)	O
data	pointer
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
)	O
{	O
SetTimeout	function
(	O
ev	pointer
,	O
1	int
)	O
;	O
evenq	function
(	O
ev	pointer
)	O
;	O
return	O
;	O
}	O
ox	int
=	O
D_x	O
;	O
oy	int
=	O
D_y	O
;	O
if	O
(	O
cv	pointer
->	O
c_ye	int
+	O
1	int
<	O
D_height	O
)	O
RefreshLine	function
(	O
cv	pointer
->	O
c_ye	int
+	O
1	int
,	O
0	int
,	O
D_width	O
-	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
ox	int
!=	O
-	O
1	int
&&	O
oy	int
!=	O
-	O
1	int
)	O
GotoPos	function
(	O
ox	int
,	O
oy	int
)	O
;	O
}	O
int	O
MakeDefaultCanvas	function
(	O
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
(	O
cv	pointer
=	O
(	O
struct	O
canvas	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
cv	pointer
)	O
)	O
==	O
0	int
)	O
return	O
-	O
1	int
;	O
cv	pointer
->	O
c_xs	int
=	O
0	int
;	O
cv	pointer
->	O
c_xe	int
=	O
D_width	O
-	O
1	int
;	O
cv	pointer
->	O
c_ys	int
=	O
(	O
D_has_hstatus	O
==	O
HSTATUS_FIRSTLINE	int
)	O
;	O
cv	pointer
->	O
c_ye	int
=	O
D_height	O
-	O
1	int
-	O
(	O
D_has_hstatus	O
==	O
HSTATUS_LASTLINE	int
)	O
-	O
captionalways	int
;	O
debug2	O
(	O
"MakeDefaultCanvas 0,0 %d,%d\n"	pointer
,	O
cv	pointer
->	O
c_xe	int
,	O
cv	pointer
->	O
c_ye	int
)	O
;	O
cv	pointer
->	O
c_xoff	int
=	O
0	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
0	int
;	O
cv	pointer
->	O
c_next	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_display	pointer
=	O
display	struct
;	O
cv	pointer
->	O
c_vplist	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_slnext	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_slprev	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_slperp	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_slweight	int
=	O
1	int
;	O
cv	pointer
->	O
c_slback	pointer
=	O
&	O
D_canvas	O
;	O
D_canvas	O
.	O
c_slperp	pointer
=	O
cv	pointer
;	O
D_canvas	O
.	O
c_xs	int
=	O
cv	pointer
->	O
c_xs	int
;	O
D_canvas	O
.	O
c_xe	int
=	O
cv	pointer
->	O
c_xe	int
;	O
D_canvas	O
.	O
c_ys	int
=	O
cv	pointer
->	O
c_ys	int
;	O
D_canvas	O
.	O
c_ye	int
=	O
cv	pointer
->	O
c_ye	int
;	O
cv	pointer
->	O
c_slorient	int
=	O
SLICE_UNKN	int
;	O
cv	pointer
->	O
c_captev	struct
.	O
type	int
=	O
EV_TIMEOUT	int
;	O
cv	pointer
->	O
c_captev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
cv	pointer
;	O
cv	pointer
->	O
c_captev	struct
.	O
handler	pointer
=	O
cv_winid_fn	function
;	O
CanvasInitBlank	function
(	O
cv	pointer
)	O
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
D_cvlist	O
=	O
cv	pointer
;	O
RethinkDisplayViewports	function
(	O
)	O
;	O
D_forecv	O
=	O
cv	pointer
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
canvas	struct
*	O
*	O
CreateCanvasChainRec	function
(	O
cv	pointer
,	O
cvp	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
canvas	struct
*	O
*	O
cvp	pointer
;	O
{	O
for	O
(	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
cvp	pointer
=	O
CreateCanvasChainRec	function
(	O
cv	pointer
->	O
c_slperp	pointer
,	O
cvp	pointer
)	O
;	O
else	O
{	O
*	O
cvp	pointer
=	O
cv	pointer
;	O
cvp	pointer
=	O
&	O
cv	pointer
->	O
c_next	pointer
;	O
}	O
}	O
return	O
cvp	pointer
;	O
}	O
void	O
RecreateCanvasChain	function
(	O
)	O
{	O
struct	O
canvas	struct
*	O
*	O
cvp	pointer
;	O
cvp	pointer
=	O
CreateCanvasChainRec	function
(	O
D_canvas	O
.	O
c_slperp	pointer
,	O
&	O
D_cvlist	O
)	O
;	O
*	O
cvp	pointer
=	O
0	int
;	O
}	O
void	O
EqualizeCanvas	function
(	O
cv	pointer
,	O
gflag	int
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
int	O
gflag	int
;	O
{	O
struct	O
canvas	struct
*	O
cv2	pointer
;	O
for	O
(	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
&&	O
gflag	int
)	O
{	O
cv	pointer
->	O
c_slweight	int
=	O
CountCanvasPerp	function
(	O
cv	pointer
)	O
;	O
for	O
(	O
cv2	pointer
=	O
cv	pointer
->	O
c_slperp	pointer
;	O
cv2	pointer
;	O
cv2	pointer
=	O
cv2	pointer
->	O
c_slnext	pointer
)	O
if	O
(	O
cv2	pointer
->	O
c_slperp	pointer
)	O
EqualizeCanvas	function
(	O
cv2	pointer
->	O
c_slperp	pointer
,	O
gflag	int
)	O
;	O
}	O
else	O
cv	pointer
->	O
c_slweight	int
=	O
1	int
;	O
}	O
}	O
void	O
ResizeCanvas	function
(	O
cv	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
{	O
struct	O
canvas	struct
*	O
cv2	pointer
,	O
*	O
cvn	pointer
,	O
*	O
fcv	pointer
;	O
int	O
nh	int
,	O
i	int
,	O
maxi	int
,	O
hh	int
,	O
m	union
,	O
w	int
,	O
wsum	int
;	O
int	O
need	int
,	O
got	int
;	O
int	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
;	O
int	O
focusmin	int
=	O
0	int
;	O
xs	int
=	O
cv	pointer
->	O
c_xs	int
;	O
ys	int
=	O
cv	pointer
->	O
c_ys	int
;	O
xe	int
=	O
cv	pointer
->	O
c_xe	int
;	O
ye	int
=	O
cv	pointer
->	O
c_ye	int
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slperp	pointer
;	O
debug2	O
(	O
"ResizeCanvas: %d,%d"	pointer
,	O
xs	int
,	O
ys	int
)	O
;	O
debug2	O
(	O
" %d,%d\n"	pointer
,	O
xe	int
,	O
ye	int
)	O
;	O
if	O
(	O
cv	pointer
==	O
0	int
)	O
return	O
;	O
if	O
(	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_UNKN	int
)	O
{	O
ASSERT	O
(	O
!	O
cv	pointer
->	O
c_slnext	pointer
&&	O
!	O
cv	pointer
->	O
c_slperp	pointer
)	O
;	O
cv	pointer
->	O
c_xs	int
=	O
xs	int
;	O
cv	pointer
->	O
c_xe	int
=	O
xe	int
;	O
cv	pointer
->	O
c_ys	int
=	O
ys	int
;	O
cv	pointer
->	O
c_ye	int
=	O
ye	int
;	O
cv	pointer
->	O
c_xoff	int
=	O
cv	pointer
->	O
c_xs	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
cv	pointer
->	O
c_ys	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_width	int
=	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_height	int
=	O
cv	pointer
->	O
c_ye	int
-	O
cv	pointer
->	O
c_ys	int
+	O
1	int
;	O
return	O
;	O
}	O
fcv	pointer
=	O
0	int
;	O
if	O
(	O
focusminwidth	int
||	O
focusminheight	int
)	O
{	O
debug	O
(	O
"searching for focus canvas\n"	pointer
)	O
;	O
cv2	pointer
=	O
D_forecv	O
;	O
while	O
(	O
cv2	pointer
->	O
c_slback	pointer
)	O
{	O
if	O
(	O
cv2	pointer
->	O
c_slback	pointer
==	O
cv	pointer
->	O
c_slback	pointer
)	O
{	O
fcv	pointer
=	O
cv2	pointer
;	O
focusmin	int
=	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
focusminheight	int
:	O
focusminwidth	int
;	O
if	O
(	O
focusmin	int
>	O
0	int
)	O
focusmin	int
--	O
;	O
else	O
if	O
(	O
focusmin	int
<	O
0	int
)	O
focusmin	int
=	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
ye	int
-	O
ys	int
+	O
2	int
:	O
xe	int
-	O
xs	int
+	O
2	int
;	O
debug1	O
(	O
"found, focusmin=%d\n"	pointer
,	O
focusmin	int
)	O
;	O
}	O
cv2	pointer
=	O
cv2	pointer
->	O
c_slback	pointer
;	O
}	O
}	O
if	O
(	O
focusmin	int
)	O
{	O
m	union
=	O
CountCanvas	function
(	O
cv	pointer
)	O
*	O
2	int
;	O
nh	int
=	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
ye	int
-	O
ys	int
+	O
2	int
:	O
xe	int
-	O
xs	int
+	O
2	int
;	O
nh	int
-=	O
m	union
;	O
if	O
(	O
nh	int
<	O
0	int
)	O
nh	int
=	O
0	int
;	O
if	O
(	O
focusmin	int
>	O
nh	int
)	O
focusmin	int
=	O
nh	int
;	O
debug1	O
(	O
"corrected to %d\n"	pointer
,	O
focusmin	int
)	O
;	O
}	O
for	O
(	O
cv2	pointer
=	O
cv	pointer
,	O
wsum	int
=	O
0	int
;	O
cv2	pointer
;	O
cv2	pointer
=	O
cv2	pointer
->	O
c_slnext	pointer
)	O
{	O
debug1	O
(	O
"  weight %d\n"	pointer
,	O
cv2	pointer
->	O
c_slweight	int
)	O
;	O
wsum	int
+=	O
cv2	pointer
->	O
c_slweight	int
;	O
}	O
debug1	O
(	O
"wsum = %d\n"	pointer
,	O
wsum	int
)	O
;	O
if	O
(	O
wsum	int
==	O
0	int
)	O
wsum	int
=	O
1	int
;	O
w	int
=	O
wsum	int
;	O
nh	int
=	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
ye	int
-	O
ys	int
+	O
2	int
:	O
xe	int
-	O
xs	int
+	O
2	int
;	O
for	O
(	O
cv2	pointer
=	O
cv	pointer
,	O
need	int
=	O
got	int
=	O
0	int
;	O
cv2	pointer
;	O
cv2	pointer
=	O
cv2	pointer
->	O
c_slnext	pointer
)	O
{	O
m	union
=	O
cv2	pointer
->	O
c_slperp	pointer
?	O
CountCanvasPerp	function
(	O
cv2	pointer
)	O
*	O
2	int
-	O
1	int
:	O
1	int
;	O
if	O
(	O
cv2	pointer
==	O
fcv	pointer
)	O
m	union
+=	O
focusmin	int
;	O
hh	int
=	O
cv2	pointer
->	O
c_slweight	int
?	O
nh	int
*	O
cv2	pointer
->	O
c_slweight	int
/	O
w	int
:	O
0	int
;	O
w	int
-=	O
cv2	pointer
->	O
c_slweight	int
;	O
nh	int
-=	O
hh	int
;	O
debug2	O
(	O
"  should %d min %d\n"	pointer
,	O
hh	int
,	O
m	union
)	O
;	O
if	O
(	O
hh	int
<=	O
m	union
+	O
1	int
)	O
need	int
+=	O
m	union
+	O
1	int
-	O
hh	int
;	O
else	O
got	int
+=	O
hh	int
-	O
m	union
-	O
1	int
;	O
}	O
debug2	O
(	O
"need: %d, got %d\n"	pointer
,	O
need	int
,	O
got	int
)	O
;	O
if	O
(	O
need	int
>	O
got	int
)	O
need	int
=	O
got	int
;	O
nh	int
=	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
ye	int
-	O
ys	int
+	O
2	int
:	O
xe	int
-	O
xs	int
+	O
2	int
;	O
i	int
=	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
ys	int
:	O
xs	int
;	O
maxi	int
=	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
ye	int
:	O
xe	int
;	O
w	int
=	O
wsum	int
;	O
for	O
(	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cvn	pointer
)	O
{	O
cvn	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
;	O
if	O
(	O
i	int
>	O
maxi	int
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_slprev	pointer
&&	O
!	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slback	pointer
&&	O
!	O
cv	pointer
->	O
c_slprev	pointer
->	O
c_slperp	pointer
&&	O
!	O
cv	pointer
->	O
c_slprev	pointer
->	O
c_slprev	pointer
)	O
{	O
cv	pointer
->	O
c_slprev	pointer
->	O
c_slorient	int
=	O
SLICE_UNKN	int
;	O
if	O
(	O
!	O
captionalways	int
)	O
{	O
cv	pointer
->	O
c_slback	pointer
->	O
c_ye	int
++	O
;	O
cv	pointer
->	O
c_slprev	pointer
->	O
c_ye	int
++	O
;	O
}	O
}	O
SetCanvasWindow	function
(	O
cv	pointer
,	O
0	int
)	O
;	O
FreeCanvas	function
(	O
cv	pointer
)	O
;	O
continue	O
;	O
}	O
m	union
=	O
cv	pointer
->	O
c_slperp	pointer
?	O
CountCanvasPerp	function
(	O
cv	pointer
)	O
*	O
2	int
-	O
1	int
:	O
1	int
;	O
if	O
(	O
cv	pointer
==	O
fcv	pointer
)	O
m	union
+=	O
focusmin	int
;	O
hh	int
=	O
cv	pointer
->	O
c_slweight	int
?	O
nh	int
*	O
cv	pointer
->	O
c_slweight	int
/	O
w	int
:	O
0	int
;	O
w	int
-=	O
cv	pointer
->	O
c_slweight	int
;	O
nh	int
-=	O
hh	int
;	O
debug2	O
(	O
"  should %d min %d\n"	pointer
,	O
hh	int
,	O
m	union
)	O
;	O
if	O
(	O
hh	int
<=	O
m	union
+	O
1	int
)	O
{	O
hh	int
=	O
m	union
+	O
1	int
;	O
debug1	O
(	O
" -> %d\n"	pointer
,	O
hh	int
)	O
;	O
}	O
else	O
{	O
int	O
hx	int
=	O
1	int
;	O
if	O
(	O
got	int
!=	O
0	int
)	O
hx	int
=	O
need	int
*	O
(	O
hh	int
-	O
m	union
-	O
1	int
)	O
/	O
got	int
;	O
else	O
debug	O
(	O
"   got = 0\n"	pointer
)	O
;	O
debug3	O
(	O
" -> %d - %d = %d\n"	pointer
,	O
hh	int
,	O
hx	int
,	O
hh	int
-	O
hx	int
)	O
;	O
got	int
-=	O
(	O
hh	int
-	O
m	union
-	O
1	int
)	O
;	O
hh	int
-=	O
hx	int
;	O
need	int
-=	O
hx	int
;	O
debug2	O
(	O
"   now need=%d got=%d\n"	pointer
,	O
need	int
,	O
got	int
)	O
;	O
}	O
ASSERT	O
(	O
hh	int
>=	O
m	union
+	O
1	int
)	O
;	O
if	O
(	O
i	int
+	O
hh	int
>	O
maxi	int
+	O
2	int
)	O
{	O
hh	int
=	O
maxi	int
+	O
2	int
-	O
i	int
;	O
debug1	O
(	O
"  not enough space, reducing to %d\n"	pointer
,	O
hh	int
)	O
;	O
}	O
if	O
(	O
i	int
+	O
hh	int
==	O
maxi	int
+	O
1	int
)	O
{	O
hh	int
++	O
;	O
debug	O
(	O
"  incrementing as no other canvas will fit\n"	pointer
)	O
;	O
}	O
if	O
(	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
)	O
{	O
cv	pointer
->	O
c_xs	int
=	O
xs	int
;	O
cv	pointer
->	O
c_xe	int
=	O
xe	int
;	O
cv	pointer
->	O
c_ys	int
=	O
i	int
;	O
cv	pointer
->	O
c_ye	int
=	O
i	int
+	O
hh	int
-	O
2	int
;	O
cv	pointer
->	O
c_xoff	int
=	O
xs	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
i	int
;	O
}	O
else	O
{	O
cv	pointer
->	O
c_xs	int
=	O
i	int
;	O
cv	pointer
->	O
c_xe	int
=	O
i	int
+	O
hh	int
-	O
2	int
;	O
cv	pointer
->	O
c_ys	int
=	O
ys	int
;	O
cv	pointer
->	O
c_ye	int
=	O
ye	int
;	O
cv	pointer
->	O
c_xoff	int
=	O
i	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
ys	int
;	O
}	O
cv	pointer
->	O
c_xoff	int
=	O
cv	pointer
->	O
c_xs	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
cv	pointer
->	O
c_ys	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_width	int
=	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_height	int
=	O
cv	pointer
->	O
c_ye	int
-	O
cv	pointer
->	O
c_ys	int
+	O
1	int
;	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
{	O
ResizeCanvas	function
(	O
cv	pointer
)	O
;	O
if	O
(	O
!	O
cv	pointer
->	O
c_slperp	pointer
->	O
c_slnext	pointer
)	O
{	O
debug	O
(	O
"deleting perp node\n"	pointer
)	O
;	O
FreePerp	function
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
;	O
FreePerp	function
(	O
cv	pointer
)	O
;	O
}	O
}	O
i	int
+=	O
hh	int
;	O
}	O
}	O
static	O
struct	O
canvas	struct
*	O
AddPerp	function
(	O
cv	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
{	O
struct	O
canvas	struct
*	O
pcv	pointer
;	O
debug	O
(	O
"Creating new perp node\n"	pointer
)	O
;	O
if	O
(	O
(	O
pcv	pointer
=	O
(	O
struct	O
canvas	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
cv	pointer
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
pcv	pointer
->	O
c_next	pointer
=	O
0	int
;	O
pcv	pointer
->	O
c_display	pointer
=	O
cv	pointer
->	O
c_display	pointer
;	O
pcv	pointer
->	O
c_slnext	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
;	O
pcv	pointer
->	O
c_slprev	pointer
=	O
cv	pointer
->	O
c_slprev	pointer
;	O
pcv	pointer
->	O
c_slperp	pointer
=	O
cv	pointer
;	O
pcv	pointer
->	O
c_slback	pointer
=	O
cv	pointer
->	O
c_slback	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slback	pointer
&&	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
==	O
cv	pointer
)	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
=	O
pcv	pointer
;	O
pcv	pointer
->	O
c_slorient	int
=	O
cv	pointer
->	O
c_slorient	int
;	O
pcv	pointer
->	O
c_xoff	int
=	O
0	int
;	O
pcv	pointer
->	O
c_yoff	int
=	O
0	int
;	O
pcv	pointer
->	O
c_xs	int
=	O
cv	pointer
->	O
c_xs	int
;	O
pcv	pointer
->	O
c_xe	int
=	O
cv	pointer
->	O
c_xe	int
;	O
pcv	pointer
->	O
c_ys	int
=	O
cv	pointer
->	O
c_ys	int
;	O
pcv	pointer
->	O
c_ye	int
=	O
cv	pointer
->	O
c_ye	int
;	O
if	O
(	O
pcv	pointer
->	O
c_slnext	pointer
)	O
pcv	pointer
->	O
c_slnext	pointer
->	O
c_slprev	pointer
=	O
pcv	pointer
;	O
if	O
(	O
pcv	pointer
->	O
c_slprev	pointer
)	O
pcv	pointer
->	O
c_slprev	pointer
->	O
c_slnext	pointer
=	O
pcv	pointer
;	O
pcv	pointer
->	O
c_slweight	int
=	O
cv	pointer
->	O
c_slweight	int
;	O
CanvasInitBlank	function
(	O
pcv	pointer
)	O
;	O
cv	pointer
->	O
c_slweight	int
=	O
1	int
;	O
cv	pointer
->	O
c_slnext	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_slprev	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_slperp	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_slback	pointer
=	O
pcv	pointer
;	O
cv	pointer
->	O
c_slorient	int
=	O
SLICE_UNKN	int
;	O
return	O
pcv	pointer
;	O
}	O
int	O
AddCanvas	function
(	O
orient	int
)	O
int	O
orient	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
int	O
xs	int
,	O
xe	int
,	O
ys	int
,	O
ye	int
;	O
int	O
h	int
,	O
num	int
;	O
cv	pointer
=	O
D_forecv	O
;	O
debug2	O
(	O
"AddCanvas orient %d, forecv is %d\n"	pointer
,	O
orient	int
,	O
cv	pointer
->	O
c_slorient	int
)	O
;	O
if	O
(	O
cv	pointer
->	O
c_slorient	int
!=	O
SLICE_UNKN	int
&&	O
cv	pointer
->	O
c_slorient	int
!=	O
orient	int
)	O
if	O
(	O
!	O
AddPerp	function
(	O
cv	pointer
)	O
)	O
return	O
-	O
1	int
;	O
cv	pointer
=	O
D_forecv	O
;	O
xs	int
=	O
cv	pointer
->	O
c_slback	pointer
->	O
c_xs	int
;	O
xe	int
=	O
cv	pointer
->	O
c_slback	pointer
->	O
c_xe	int
;	O
ys	int
=	O
cv	pointer
->	O
c_slback	pointer
->	O
c_ys	int
;	O
ye	int
=	O
cv	pointer
->	O
c_slback	pointer
->	O
c_ye	int
;	O
if	O
(	O
!	O
captionalways	int
&&	O
cv	pointer
==	O
D_canvas	O
.	O
c_slperp	pointer
&&	O
!	O
cv	pointer
->	O
c_slnext	pointer
)	O
ye	int
--	O
;	O
debug2	O
(	O
"Adding Canvas to slice %d,%d "	pointer
,	O
xs	int
,	O
ys	int
)	O
;	O
debug2	O
(	O
"%d,%d\n"	pointer
,	O
xe	int
,	O
ye	int
)	O
;	O
num	int
=	O
CountCanvas	function
(	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
)	O
+	O
1	int
;	O
debug1	O
(	O
"Num = %d\n"	pointer
,	O
num	int
)	O
;	O
if	O
(	O
orient	int
==	O
SLICE_VERT	O
)	O
h	int
=	O
ye	int
-	O
ys	int
+	O
1	int
;	O
else	O
h	int
=	O
xe	int
-	O
xs	int
+	O
1	int
;	O
h	int
-=	O
2	int
*	O
num	int
-	O
1	int
;	O
if	O
(	O
h	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
cv	pointer
=	O
(	O
struct	O
canvas	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
cv	pointer
)	O
)	O
==	O
0	int
)	O
return	O
-	O
1	int
;	O
D_forecv	O
->	O
c_slback	pointer
->	O
c_ye	int
=	O
ye	int
;	O
D_forecv	O
->	O
c_slorient	int
=	O
orient	int
;	O
cv	pointer
->	O
c_slnext	pointer
=	O
D_forecv	O
->	O
c_slnext	pointer
;	O
cv	pointer
->	O
c_slprev	pointer
=	O
D_forecv	O
;	O
D_forecv	O
->	O
c_slnext	pointer
=	O
cv	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slnext	pointer
)	O
cv	pointer
->	O
c_slnext	pointer
->	O
c_slprev	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_slorient	int
=	O
orient	int
;	O
cv	pointer
->	O
c_slback	pointer
=	O
D_forecv	O
->	O
c_slback	pointer
;	O
cv	pointer
->	O
c_xs	int
=	O
xs	int
;	O
cv	pointer
->	O
c_xe	int
=	O
xe	int
;	O
cv	pointer
->	O
c_ys	int
=	O
ys	int
;	O
cv	pointer
->	O
c_ye	int
=	O
ye	int
;	O
cv	pointer
->	O
c_xoff	int
=	O
0	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
0	int
;	O
cv	pointer
->	O
c_display	pointer
=	O
display	struct
;	O
cv	pointer
->	O
c_vplist	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_captev	struct
.	O
type	int
=	O
EV_TIMEOUT	int
;	O
cv	pointer
->	O
c_captev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
cv	pointer
;	O
cv	pointer
->	O
c_captev	struct
.	O
handler	pointer
=	O
cv_winid_fn	function
;	O
CanvasInitBlank	function
(	O
cv	pointer
)	O
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_next	pointer
=	O
0	int
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slback	pointer
;	O
EqualizeCanvas	function
(	O
cv	pointer
->	O
c_slperp	pointer
,	O
0	int
)	O
;	O
ResizeCanvas	function
(	O
cv	pointer
)	O
;	O
RecreateCanvasChain	function
(	O
)	O
;	O
RethinkDisplayViewports	function
(	O
)	O
;	O
ResizeLayersToCanvases	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
RemCanvas	function
(	O
)	O
{	O
int	O
ye	int
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
debug	O
(	O
"RemCanvas\n"	pointer
)	O
;	O
cv	pointer
=	O
D_forecv	O
;	O
ye	int
=	O
cv	pointer
->	O
c_slback	pointer
->	O
c_ye	int
;	O
if	O
(	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_UNKN	int
)	O
return	O
;	O
while	O
(	O
cv	pointer
->	O
c_slprev	pointer
)	O
cv	pointer
=	O
cv	pointer
->	O
c_slprev	pointer
;	O
if	O
(	O
!	O
cv	pointer
->	O
c_slnext	pointer
)	O
return	O
;	O
if	O
(	O
!	O
cv	pointer
->	O
c_slnext	pointer
->	O
c_slnext	pointer
&&	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slback	pointer
)	O
{	O
cv	pointer
=	O
D_forecv	O
;	O
debug	O
(	O
"deleting perp node\n"	pointer
)	O
;	O
FreePerp	function
(	O
cv	pointer
->	O
c_slprev	pointer
?	O
cv	pointer
->	O
c_slprev	pointer
:	O
cv	pointer
->	O
c_slnext	pointer
)	O
;	O
FreePerp	function
(	O
cv	pointer
->	O
c_slback	pointer
)	O
;	O
}	O
cv	pointer
=	O
D_forecv	O
;	O
D_forecv	O
=	O
cv	pointer
->	O
c_slprev	pointer
;	O
if	O
(	O
!	O
D_forecv	O
)	O
D_forecv	O
=	O
cv	pointer
->	O
c_slnext	pointer
;	O
FreeCanvas	function
(	O
cv	pointer
)	O
;	O
cv	pointer
=	O
D_forecv	O
;	O
while	O
(	O
D_forecv	O
->	O
c_slperp	pointer
)	O
D_forecv	O
=	O
D_forecv	O
->	O
c_slperp	pointer
;	O
if	O
(	O
!	O
cv	pointer
->	O
c_slnext	pointer
&&	O
!	O
cv	pointer
->	O
c_slprev	pointer
&&	O
!	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slback	pointer
&&	O
!	O
cv	pointer
->	O
c_slperp	pointer
)	O
{	O
cv	pointer
->	O
c_slorient	int
=	O
SLICE_UNKN	int
;	O
if	O
(	O
!	O
captionalways	int
)	O
cv	pointer
->	O
c_slback	pointer
->	O
c_ye	int
=	O
++	O
ye	int
;	O
}	O
cv	pointer
=	O
cv	pointer
->	O
c_slback	pointer
;	O
EqualizeCanvas	function
(	O
cv	pointer
->	O
c_slperp	pointer
,	O
0	int
)	O
;	O
ResizeCanvas	function
(	O
cv	pointer
)	O
;	O
D_fore	O
=	O
Layer2Window	O
(	O
D_forecv	O
->	O
c_layer	pointer
)	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
RecreateCanvasChain	function
(	O
)	O
;	O
RethinkDisplayViewports	function
(	O
)	O
;	O
ResizeLayersToCanvases	function
(	O
)	O
;	O
}	O
void	O
OneCanvas	function
(	O
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
=	O
D_forecv	O
,	O
*	O
ocv	pointer
=	O
0	int
;	O
if	O
(	O
cv	pointer
->	O
c_slprev	pointer
)	O
{	O
ocv	pointer
=	O
cv	pointer
->	O
c_slprev	pointer
;	O
cv	pointer
->	O
c_slprev	pointer
->	O
c_slnext	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
;	O
}	O
if	O
(	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
ocv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
;	O
cv	pointer
->	O
c_slnext	pointer
->	O
c_slprev	pointer
=	O
cv	pointer
->	O
c_slprev	pointer
;	O
}	O
if	O
(	O
!	O
ocv	pointer
)	O
return	O
;	O
if	O
(	O
cv	pointer
->	O
c_slback	pointer
&&	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
==	O
cv	pointer
)	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
=	O
ocv	pointer
;	O
cv	pointer
->	O
c_slorient	int
=	O
SLICE_UNKN	int
;	O
while	O
(	O
D_canvas	O
.	O
c_slperp	pointer
)	O
FreeCanvas	function
(	O
D_canvas	O
.	O
c_slperp	pointer
)	O
;	O
cv	pointer
=	O
D_forecv	O
;	O
D_canvas	O
.	O
c_slperp	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_slback	pointer
=	O
&	O
D_canvas	O
;	O
cv	pointer
->	O
c_slnext	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_slprev	pointer
=	O
0	int
;	O
ASSERT	O
(	O
!	O
cv	pointer
->	O
c_slperp	pointer
)	O
;	O
if	O
(	O
!	O
captionalways	int
)	O
D_canvas	O
.	O
c_ye	int
++	O
;	O
ResizeCanvas	function
(	O
&	O
D_canvas	O
)	O
;	O
RecreateCanvasChain	function
(	O
)	O
;	O
RethinkDisplayViewports	function
(	O
)	O
;	O
ResizeLayersToCanvases	function
(	O
)	O
;	O
}	O
void	O
DupLayoutCv	function
(	O
cvf	pointer
,	O
cvt	pointer
,	O
save	int
)	O
struct	O
canvas	struct
*	O
cvf	pointer
,	O
*	O
cvt	pointer
;	O
int	O
save	int
;	O
{	O
while	O
(	O
cvf	pointer
)	O
{	O
cvt	pointer
->	O
c_slorient	int
=	O
cvf	pointer
->	O
c_slorient	int
;	O
cvt	pointer
->	O
c_slweight	int
=	O
cvf	pointer
->	O
c_slweight	int
;	O
if	O
(	O
cvf	pointer
==	O
D_forecv	O
)	O
D_forecv	O
=	O
cvt	pointer
;	O
if	O
(	O
!	O
save	int
)	O
{	O
cvt	pointer
->	O
c_display	pointer
=	O
display	struct
;	O
if	O
(	O
!	O
cvf	pointer
->	O
c_slperp	pointer
)	O
{	O
cvt	pointer
->	O
c_captev	struct
.	O
type	int
=	O
EV_TIMEOUT	int
;	O
cvt	pointer
->	O
c_captev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
cvt	pointer
;	O
cvt	pointer
->	O
c_captev	struct
.	O
handler	pointer
=	O
cv_winid_fn	function
;	O
cvt	pointer
->	O
c_blank	struct
.	O
l_cvlist	pointer
=	O
0	int
;	O
cvt	pointer
->	O
c_blank	struct
.	O
l_layfn	pointer
=	O
&	O
BlankLf	struct
;	O
cvt	pointer
->	O
c_blank	struct
.	O
l_bottom	pointer
=	O
&	O
cvt	pointer
->	O
c_blank	struct
;	O
}	O
cvt	pointer
->	O
c_layer	pointer
=	O
cvf	pointer
->	O
c_layer	pointer
;	O
}	O
else	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
cvf	pointer
->	O
c_layer	pointer
?	O
Layer2Window	O
(	O
cvf	pointer
->	O
c_layer	pointer
)	O
:	O
0	int
;	O
cvt	pointer
->	O
c_layer	pointer
=	O
p	pointer
?	O
&	O
p	pointer
->	O
w_layer	struct
:	O
0	int
;	O
}	O
if	O
(	O
cvf	pointer
->	O
c_slperp	pointer
)	O
{	O
cvt	pointer
->	O
c_slperp	pointer
=	O
(	O
struct	O
canvas	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
canvas	struct
)	O
)	O
;	O
cvt	pointer
->	O
c_slperp	pointer
->	O
c_slback	pointer
=	O
cvt	pointer
;	O
CanvasInitBlank	function
(	O
cvt	pointer
->	O
c_slperp	pointer
)	O
;	O
DupLayoutCv	function
(	O
cvf	pointer
->	O
c_slperp	pointer
,	O
cvt	pointer
->	O
c_slperp	pointer
,	O
save	int
)	O
;	O
}	O
if	O
(	O
cvf	pointer
->	O
c_slnext	pointer
)	O
{	O
cvt	pointer
->	O
c_slnext	pointer
=	O
(	O
struct	O
canvas	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
canvas	struct
)	O
)	O
;	O
cvt	pointer
->	O
c_slnext	pointer
->	O
c_slprev	pointer
=	O
cvt	pointer
;	O
cvt	pointer
->	O
c_slnext	pointer
->	O
c_slback	pointer
=	O
cvt	pointer
->	O
c_slback	pointer
;	O
CanvasInitBlank	function
(	O
cvt	pointer
->	O
c_slnext	pointer
)	O
;	O
}	O
cvf	pointer
=	O
cvf	pointer
->	O
c_slnext	pointer
;	O
cvt	pointer
=	O
cvt	pointer
->	O
c_slnext	pointer
;	O
}	O
}	O
void	O
PutWindowCv	function
(	O
cv	pointer
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
;	O
for	O
(	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
{	O
PutWindowCv	function
(	O
cv	pointer
->	O
c_slperp	pointer
)	O
;	O
continue	O
;	O
}	O
p	pointer
=	O
cv	pointer
->	O
c_layer	pointer
?	O
(	O
struct	O
win	struct
*	O
)	O
cv	pointer
->	O
c_layer	pointer
->	O
l_data	pointer
:	O
0	int
;	O
cv	pointer
->	O
c_layer	pointer
=	O
0	int
;	O
SetCanvasWindow	function
(	O
cv	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
