char	O
*	O
input_line_pointer	pointer
;	O
bfd_boolean	int
input_from_string	int
=	O
FALSE	int
;	O
char	O
lex_type	array
[	O
256	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
LEX_HASH	int
,	O
LEX_DOLLAR	int
,	O
LEX_PCT	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
LEX_QM	int
,	O
LEX_AT	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
LEX_BR	int
,	O
0	int
,	O
LEX_BR	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
LEX_BR	int
,	O
0	int
,	O
LEX_BR	int
,	O
LEX_TILDE	int
,	O
0	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
;	O
char	O
is_end_of_line	array
[	O
256	int
]	O
=	O
{	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
char	O
original_case_string	array
[	O
128	int
]	O
;	O
static	O
char	O
*	O
buffer	pointer
;	O
static	O
char	O
*	O
buffer_limit	pointer
;	O
int	O
target_big_endian	int
=	O
TARGET_BYTES_BIG_ENDIAN	int
;	O
const	O
char	O
*	O
*	O
include_dirs	pointer
;	O
int	O
include_dir_count	int
;	O
int	O
include_dir_maxlen	int
=	O
1	int
;	O
addressT	long
abs_section_offset	long
;	O
symbolS	struct
*	O
line_label	pointer
;	O
symbolS	struct
*	O
mri_common_symbol	pointer
;	O
static	O
int	O
mri_pending_align	int
;	O
static	O
int	O
dwarf_file_string	int
;	O
static	O
unsigned	O
int	O
bundle_align_p2	int
;	O
static	O
fragS	struct
*	O
bundle_lock_frag	pointer
;	O
static	O
frchainS	struct
*	O
bundle_lock_frchain	pointer
;	O
static	O
unsigned	O
int	O
bundle_lock_depth	int
;	O
static	O
void	O
do_s_func	function
(	O
int	O
end_p	int
,	O
const	O
char	O
*	O
default_prefix	char
)	O
;	O
static	O
void	O
s_align	function
(	O
int	O
,	O
int	O
)	O
;	O
static	O
void	O
s_altmacro	function
(	O
int	O
)	O
;	O
static	O
void	O
s_bad_end	function
(	O
int	O
)	O
;	O
static	O
void	O
s_reloc	function
(	O
int	O
)	O
;	O
static	O
int	O
hex_float	function
(	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
segT	pointer
get_known_segmented_expression	function
(	O
expressionS	struct
*	O
expP	pointer
)	O
;	O
static	O
void	O
pobegin	function
(	O
void	O
)	O
;	O
static	O
size_t	long
get_non_macro_line_sb	function
(	O
sb	pointer
*	O
)	O
;	O
static	O
void	O
generate_file_debug	function
(	O
void	O
)	O
;	O
static	O
char	O
*	O
_find_end_of_line	function
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
;	O
void	O
read_begin	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
pobegin	function
(	O
)	O
;	O
obj_read_begin_hook	O
(	O
)	O
;	O
obstack_begin	O
(	O
&	O
notes	struct
,	O
chunksize	int
)	O
;	O
obstack_begin	O
(	O
&	O
cond_obstack	struct
,	O
chunksize	int
)	O
;	O
for	O
(	O
p	pointer
=	O
tc_line_separator_chars	O
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
]	O
=	O
2	int
;	O
if	O
(	O
flag_mri	int
)	O
lex_type	array
[	O
'?'	O
]	O
=	O
3	int
;	O
}	O
static	O
struct	O
hash_control	O
*	O
po_hash	pointer
;	O
static	O
const	O
pseudo_typeS	struct
potable	array
[	O
]	O
=	O
{	O
{	O
"abort"	pointer
,	O
s_abort	function
,	O
0	int
}	O
,	O
{	O
"align"	pointer
,	O
s_align_ptwo	function
,	O
0	int
}	O
,	O
{	O
"altmacro"	pointer
,	O
s_altmacro	function
,	O
1	int
}	O
,	O
{	O
"ascii"	pointer
,	O
stringer	function
,	O
8	int
+	O
0	int
}	O
,	O
{	O
"asciz"	pointer
,	O
stringer	function
,	O
8	int
+	O
1	int
}	O
,	O
{	O
"balign"	pointer
,	O
s_align_bytes	function
,	O
0	int
}	O
,	O
{	O
"balignw"	pointer
,	O
s_align_bytes	function
,	O
-	O
2	int
}	O
,	O
{	O
"balignl"	pointer
,	O
s_align_bytes	function
,	O
-	O
4	int
}	O
,	O
{	O
"bundle_align_mode"	pointer
,	O
s_bundle_align_mode	function
,	O
0	int
}	O
,	O
{	O
"bundle_lock"	pointer
,	O
s_bundle_lock	function
,	O
0	int
}	O
,	O
{	O
"bundle_unlock"	pointer
,	O
s_bundle_unlock	function
,	O
0	int
}	O
,	O
{	O
"byte"	pointer
,	O
cons	function
,	O
1	int
}	O
,	O
{	O
"comm"	pointer
,	O
s_comm	function
,	O
0	int
}	O
,	O
{	O
"common"	pointer
,	O
s_mri_common	function
,	O
0	int
}	O
,	O
{	O
"common.s"	pointer
,	O
s_mri_common	function
,	O
1	int
}	O
,	O
{	O
"data"	pointer
,	O
s_data	function
,	O
0	int
}	O
,	O
{	O
"dc"	pointer
,	O
cons	function
,	O
2	int
}	O
,	O
{	O
"dc.a"	pointer
,	O
cons	function
,	O
0	int
}	O
,	O
{	O
"dc.b"	pointer
,	O
cons	function
,	O
1	int
}	O
,	O
{	O
"dc.d"	pointer
,	O
float_cons	function
,	O
'd'	O
}	O
,	O
{	O
"dc.l"	pointer
,	O
cons	function
,	O
4	int
}	O
,	O
{	O
"dc.s"	pointer
,	O
float_cons	function
,	O
'f'	O
}	O
,	O
{	O
"dc.w"	pointer
,	O
cons	function
,	O
2	int
}	O
,	O
{	O
"dc.x"	pointer
,	O
float_cons	function
,	O
'x'	O
}	O
,	O
{	O
"dcb"	pointer
,	O
s_space	function
,	O
2	int
}	O
,	O
{	O
"dcb.b"	pointer
,	O
s_space	function
,	O
1	int
}	O
,	O
{	O
"dcb.d"	pointer
,	O
s_float_space	function
,	O
'd'	O
}	O
,	O
{	O
"dcb.l"	pointer
,	O
s_space	function
,	O
4	int
}	O
,	O
{	O
"dcb.s"	pointer
,	O
s_float_space	function
,	O
'f'	O
}	O
,	O
{	O
"dcb.w"	pointer
,	O
s_space	function
,	O
2	int
}	O
,	O
{	O
"dcb.x"	pointer
,	O
s_float_space	function
,	O
'x'	O
}	O
,	O
{	O
"ds"	pointer
,	O
s_space	function
,	O
2	int
}	O
,	O
{	O
"ds.b"	pointer
,	O
s_space	function
,	O
1	int
}	O
,	O
{	O
"ds.d"	pointer
,	O
s_space	function
,	O
8	int
}	O
,	O
{	O
"ds.l"	pointer
,	O
s_space	function
,	O
4	int
}	O
,	O
{	O
"ds.p"	pointer
,	O
s_space	function
,	O
12	int
}	O
,	O
{	O
"ds.s"	pointer
,	O
s_space	function
,	O
4	int
}	O
,	O
{	O
"ds.w"	pointer
,	O
s_space	function
,	O
2	int
}	O
,	O
{	O
"ds.x"	pointer
,	O
s_space	function
,	O
12	int
}	O
,	O
{	O
"debug"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"double"	pointer
,	O
float_cons	function
,	O
'd'	O
}	O
,	O
{	O
"eject"	pointer
,	O
listing_eject	function
,	O
0	int
}	O
,	O
{	O
"else"	pointer
,	O
s_else	function
,	O
0	int
}	O
,	O
{	O
"elsec"	pointer
,	O
s_else	function
,	O
0	int
}	O
,	O
{	O
"elseif"	pointer
,	O
s_elseif	function
,	O
(	O
int	O
)	O
O_ne	int
}	O
,	O
{	O
"end"	pointer
,	O
s_end	function
,	O
0	int
}	O
,	O
{	O
"endc"	pointer
,	O
s_endif	function
,	O
0	int
}	O
,	O
{	O
"endfunc"	pointer
,	O
s_func	function
,	O
1	int
}	O
,	O
{	O
"endif"	pointer
,	O
s_endif	function
,	O
0	int
}	O
,	O
{	O
"endm"	pointer
,	O
s_bad_end	function
,	O
0	int
}	O
,	O
{	O
"endr"	pointer
,	O
s_bad_end	function
,	O
1	int
}	O
,	O
{	O
"equ"	pointer
,	O
s_set	function
,	O
0	int
}	O
,	O
{	O
"equiv"	pointer
,	O
s_set	function
,	O
1	int
}	O
,	O
{	O
"eqv"	pointer
,	O
s_set	function
,	O
-	O
1	int
}	O
,	O
{	O
"err"	pointer
,	O
s_err	function
,	O
0	int
}	O
,	O
{	O
"error"	pointer
,	O
s_errwarn	function
,	O
1	int
}	O
,	O
{	O
"exitm"	pointer
,	O
s_mexit	function
,	O
0	int
}	O
,	O
{	O
"extern"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"appfile"	pointer
,	O
s_app_file	function
,	O
1	int
}	O
,	O
{	O
"appline"	pointer
,	O
s_app_line	function
,	O
1	int
}	O
,	O
{	O
"fail"	pointer
,	O
s_fail	function
,	O
0	int
}	O
,	O
{	O
"file"	pointer
,	O
s_app_file	function
,	O
0	int
}	O
,	O
{	O
"fill"	pointer
,	O
s_fill	function
,	O
0	int
}	O
,	O
{	O
"float"	pointer
,	O
float_cons	function
,	O
'f'	O
}	O
,	O
{	O
"format"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"func"	pointer
,	O
s_func	function
,	O
0	int
}	O
,	O
{	O
"global"	pointer
,	O
s_globl	function
,	O
0	int
}	O
,	O
{	O
"globl"	pointer
,	O
s_globl	function
,	O
0	int
}	O
,	O
{	O
"hword"	pointer
,	O
cons	function
,	O
2	int
}	O
,	O
{	O
"if"	pointer
,	O
s_if	function
,	O
(	O
int	O
)	O
O_ne	int
}	O
,	O
{	O
"ifb"	pointer
,	O
s_ifb	function
,	O
1	int
}	O
,	O
{	O
"ifc"	pointer
,	O
s_ifc	function
,	O
0	int
}	O
,	O
{	O
"ifdef"	pointer
,	O
s_ifdef	function
,	O
0	int
}	O
,	O
{	O
"ifeq"	pointer
,	O
s_if	function
,	O
(	O
int	O
)	O
O_eq	int
}	O
,	O
{	O
"ifeqs"	pointer
,	O
s_ifeqs	function
,	O
0	int
}	O
,	O
{	O
"ifge"	pointer
,	O
s_if	function
,	O
(	O
int	O
)	O
O_ge	int
}	O
,	O
{	O
"ifgt"	pointer
,	O
s_if	function
,	O
(	O
int	O
)	O
O_gt	int
}	O
,	O
{	O
"ifle"	pointer
,	O
s_if	function
,	O
(	O
int	O
)	O
O_le	int
}	O
,	O
{	O
"iflt"	pointer
,	O
s_if	function
,	O
(	O
int	O
)	O
O_lt	int
}	O
,	O
{	O
"ifnb"	pointer
,	O
s_ifb	function
,	O
0	int
}	O
,	O
{	O
"ifnc"	pointer
,	O
s_ifc	function
,	O
1	int
}	O
,	O
{	O
"ifndef"	pointer
,	O
s_ifdef	function
,	O
1	int
}	O
,	O
{	O
"ifne"	pointer
,	O
s_if	function
,	O
(	O
int	O
)	O
O_ne	int
}	O
,	O
{	O
"ifnes"	pointer
,	O
s_ifeqs	function
,	O
1	int
}	O
,	O
{	O
"ifnotdef"	pointer
,	O
s_ifdef	function
,	O
1	int
}	O
,	O
{	O
"incbin"	pointer
,	O
s_incbin	function
,	O
0	int
}	O
,	O
{	O
"include"	pointer
,	O
s_include	function
,	O
0	int
}	O
,	O
{	O
"int"	pointer
,	O
cons	function
,	O
4	int
}	O
,	O
{	O
"irp"	pointer
,	O
s_irp	function
,	O
0	int
}	O
,	O
{	O
"irep"	pointer
,	O
s_irp	function
,	O
0	int
}	O
,	O
{	O
"irpc"	pointer
,	O
s_irp	function
,	O
1	int
}	O
,	O
{	O
"irepc"	pointer
,	O
s_irp	function
,	O
1	int
}	O
,	O
{	O
"lcomm"	pointer
,	O
s_lcomm	function
,	O
0	int
}	O
,	O
{	O
"lflags"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"linefile"	pointer
,	O
s_app_line	function
,	O
0	int
}	O
,	O
{	O
"linkonce"	pointer
,	O
s_linkonce	function
,	O
0	int
}	O
,	O
{	O
"list"	pointer
,	O
listing_list	function
,	O
1	int
}	O
,	O
{	O
"llen"	pointer
,	O
listing_psize	function
,	O
1	int
}	O
,	O
{	O
"long"	pointer
,	O
cons	function
,	O
4	int
}	O
,	O
{	O
"lsym"	pointer
,	O
s_lsym	function
,	O
0	int
}	O
,	O
{	O
"macro"	pointer
,	O
s_macro	function
,	O
0	int
}	O
,	O
{	O
"mexit"	pointer
,	O
s_mexit	function
,	O
0	int
}	O
,	O
{	O
"mri"	pointer
,	O
s_mri	function
,	O
0	int
}	O
,	O
{	O
".mri"	pointer
,	O
s_mri	function
,	O
0	int
}	O
,	O
{	O
"name"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"noaltmacro"	pointer
,	O
s_altmacro	function
,	O
0	int
}	O
,	O
{	O
"noformat"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"nolist"	pointer
,	O
listing_list	function
,	O
0	int
}	O
,	O
{	O
"nopage"	pointer
,	O
listing_nopage	function
,	O
0	int
}	O
,	O
{	O
"nops"	pointer
,	O
s_nops	function
,	O
0	int
}	O
,	O
{	O
"octa"	pointer
,	O
cons	function
,	O
16	int
}	O
,	O
{	O
"offset"	pointer
,	O
s_struct	function
,	O
0	int
}	O
,	O
{	O
"org"	pointer
,	O
s_org	function
,	O
0	int
}	O
,	O
{	O
"p2align"	pointer
,	O
s_align_ptwo	function
,	O
0	int
}	O
,	O
{	O
"p2alignw"	pointer
,	O
s_align_ptwo	function
,	O
-	O
2	int
}	O
,	O
{	O
"p2alignl"	pointer
,	O
s_align_ptwo	function
,	O
-	O
4	int
}	O
,	O
{	O
"page"	pointer
,	O
listing_eject	function
,	O
0	int
}	O
,	O
{	O
"plen"	pointer
,	O
listing_psize	function
,	O
0	int
}	O
,	O
{	O
"print"	pointer
,	O
s_print	function
,	O
0	int
}	O
,	O
{	O
"psize"	pointer
,	O
listing_psize	function
,	O
0	int
}	O
,	O
{	O
"purgem"	pointer
,	O
s_purgem	function
,	O
0	int
}	O
,	O
{	O
"quad"	pointer
,	O
cons	function
,	O
8	int
}	O
,	O
{	O
"reloc"	pointer
,	O
s_reloc	function
,	O
0	int
}	O
,	O
{	O
"rep"	pointer
,	O
s_rept	function
,	O
0	int
}	O
,	O
{	O
"rept"	pointer
,	O
s_rept	function
,	O
0	int
}	O
,	O
{	O
"rva"	pointer
,	O
s_rva	function
,	O
4	int
}	O
,	O
{	O
"sbttl"	pointer
,	O
listing_title	function
,	O
1	int
}	O
,	O
{	O
"set"	pointer
,	O
s_set	function
,	O
0	int
}	O
,	O
{	O
"short"	pointer
,	O
cons	function
,	O
2	int
}	O
,	O
{	O
"single"	pointer
,	O
float_cons	function
,	O
'f'	O
}	O
,	O
{	O
"space"	pointer
,	O
s_space	function
,	O
0	int
}	O
,	O
{	O
"skip"	pointer
,	O
s_space	function
,	O
0	int
}	O
,	O
{	O
"sleb128"	pointer
,	O
s_leb128	function
,	O
1	int
}	O
,	O
{	O
"spc"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"stabd"	pointer
,	O
s_stab	function
,	O
'd'	O
}	O
,	O
{	O
"stabn"	pointer
,	O
s_stab	function
,	O
'n'	O
}	O
,	O
{	O
"stabs"	pointer
,	O
s_stab	function
,	O
's'	O
}	O
,	O
{	O
"string"	pointer
,	O
stringer	function
,	O
8	int
+	O
1	int
}	O
,	O
{	O
"string8"	pointer
,	O
stringer	function
,	O
8	int
+	O
1	int
}	O
,	O
{	O
"string16"	pointer
,	O
stringer	function
,	O
16	int
+	O
1	int
}	O
,	O
{	O
"string32"	pointer
,	O
stringer	function
,	O
32	int
+	O
1	int
}	O
,	O
{	O
"string64"	pointer
,	O
stringer	function
,	O
64	int
+	O
1	int
}	O
,	O
{	O
"struct"	pointer
,	O
s_struct	function
,	O
0	int
}	O
,	O
{	O
"text"	pointer
,	O
s_text	function
,	O
0	int
}	O
,	O
{	O
"this_GCC_requires_the_GNU_assembler"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"this_gcc_requires_the_gnu_assembler"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"title"	pointer
,	O
listing_title	function
,	O
0	int
}	O
,	O
{	O
"ttl"	pointer
,	O
listing_title	function
,	O
0	int
}	O
,	O
{	O
"uleb128"	pointer
,	O
s_leb128	function
,	O
0	int
}	O
,	O
{	O
"xcom"	pointer
,	O
s_comm	function
,	O
0	int
}	O
,	O
{	O
"xdef"	pointer
,	O
s_globl	function
,	O
0	int
}	O
,	O
{	O
"xref"	pointer
,	O
s_ignore	function
,	O
0	int
}	O
,	O
{	O
"xstabs"	pointer
,	O
s_xstab	function
,	O
's'	O
}	O
,	O
{	O
"warning"	pointer
,	O
s_errwarn	function
,	O
0	int
}	O
,	O
{	O
"weakref"	pointer
,	O
s_weakref	function
,	O
0	int
}	O
,	O
{	O
"word"	pointer
,	O
cons	function
,	O
2	int
}	O
,	O
{	O
"zero"	pointer
,	O
s_space	function
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
offsetT	long
get_absolute_expr	function
(	O
expressionS	struct
*	O
exp	pointer
)	O
{	O
expression_and_evaluate	O
(	O
exp	pointer
)	O
;	O
if	O
(	O
exp	pointer
->	O
X_op	enum
!=	O
O_constant	int
)	O
{	O
if	O
(	O
exp	pointer
->	O
X_op	enum
!=	O
O_absent	int
)	O
as_bad	function
(	O
_	O
(	O
"bad or irreducible absolute expression"	pointer
)	O
)	O
;	O
exp	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
return	O
exp	pointer
->	O
X_add_number	long
;	O
}	O
offsetT	long
get_absolute_expression	function
(	O
void	O
)	O
{	O
expressionS	struct
exp	pointer
;	O
return	O
get_absolute_expr	function
(	O
&	O
exp	pointer
)	O
;	O
}	O
static	O
int	O
pop_override_ok	int
=	O
0	int
;	O
static	O
const	O
char	O
*	O
pop_table_name	pointer
;	O
void	O
pop_insert	function
(	O
const	O
pseudo_typeS	struct
*	O
table	pointer
)	O
{	O
const	O
char	O
*	O
errtxt	pointer
;	O
const	O
pseudo_typeS	struct
*	O
pop	pointer
;	O
for	O
(	O
pop	pointer
=	O
table	pointer
;	O
pop	pointer
->	O
poc_name	pointer
;	O
pop	pointer
++	O
)	O
{	O
errtxt	pointer
=	O
hash_insert	function
(	O
po_hash	pointer
,	O
pop	pointer
->	O
poc_name	pointer
,	O
(	O
char	O
*	O
)	O
pop	pointer
)	O
;	O
if	O
(	O
errtxt	pointer
&&	O
(	O
!	O
pop_override_ok	int
||	O
strcmp	function
(	O
errtxt	pointer
,	O
"exists"	pointer
)	O
)	O
)	O
as_fatal	function
(	O
_	O
(	O
"error constructing %s pseudo-op table: %s"	pointer
)	O
,	O
pop_table_name	pointer
,	O
errtxt	pointer
)	O
;	O
}	O
}	O
static	O
void	O
pobegin	function
(	O
void	O
)	O
{	O
po_hash	pointer
=	O
hash_new	function
(	O
)	O
;	O
pop_table_name	pointer
=	O
"md"	pointer
;	O
md_pop_insert	O
(	O
)	O
;	O
pop_table_name	pointer
=	O
"obj"	pointer
;	O
pop_override_ok	int
=	O
1	int
;	O
obj_pop_insert	O
(	O
)	O
;	O
pop_table_name	pointer
=	O
"standard"	pointer
;	O
pop_insert	function
(	O
potable	array
)	O
;	O
pop_table_name	pointer
=	O
"cfi"	pointer
;	O
pop_override_ok	int
=	O
1	int
;	O
cfi_pop_insert	O
(	O
)	O
;	O
}	O
static	O
char	O
*	O
scrub_string	pointer
;	O
static	O
char	O
*	O
scrub_string_end	pointer
;	O
static	O
size_t	long
scrub_from_string	function
(	O
char	O
*	O
buf	pointer
,	O
size_t	long
buflen	long
)	O
{	O
size_t	long
copy	int
;	O
copy	int
=	O
scrub_string_end	pointer
-	O
scrub_string	pointer
;	O
if	O
(	O
copy	int
>	O
buflen	long
)	O
copy	int
=	O
buflen	long
;	O
memcpy	function
(	O
buf	pointer
,	O
scrub_string	pointer
,	O
copy	int
)	O
;	O
scrub_string	pointer
+=	O
copy	int
;	O
return	O
copy	int
;	O
}	O
static	O
int	O
try_macro	function
(	O
char	O
term	char
,	O
const	O
char	O
*	O
line	int
)	O
{	O
sb	pointer
out	pointer
;	O
const	O
char	O
*	O
err	pointer
;	O
macro_entry	struct
*	O
macro	pointer
;	O
if	O
(	O
check_macro	function
(	O
line	int
,	O
&	O
out	pointer
,	O
&	O
err	pointer
,	O
&	O
macro	pointer
)	O
)	O
{	O
if	O
(	O
err	pointer
!=	O
NULL	O
)	O
as_bad	function
(	O
"%s"	pointer
,	O
err	pointer
)	O
;	O
*	O
input_line_pointer	pointer
++	O
=	O
term	char
;	O
input_scrub_include_sb	function
(	O
&	O
out	pointer
,	O
input_line_pointer	pointer
,	O
1	int
)	O
;	O
sb_kill	function
(	O
&	O
out	pointer
)	O
;	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
fragS	struct
*	O
start_bundle	function
(	O
void	O
)	O
{	O
fragS	struct
*	O
frag	struct
=	O
frag_now	pointer
;	O
frag_align_code	function
(	O
0	int
,	O
0	int
)	O
;	O
while	O
(	O
frag	struct
->	O
fr_type	enum
!=	O
rs_align_code	int
)	O
frag	struct
=	O
frag	struct
->	O
fr_next	pointer
;	O
gas_assert	O
(	O
frag	struct
!=	O
frag_now	pointer
)	O
;	O
return	O
frag	struct
;	O
}	O
static	O
unsigned	O
int	O
pending_bundle_size	function
(	O
fragS	struct
*	O
frag	struct
)	O
{	O
unsigned	O
int	O
offset	long
=	O
frag	struct
->	O
fr_fix	long
;	O
unsigned	O
int	O
size	int
=	O
0	int
;	O
gas_assert	O
(	O
frag	struct
!=	O
frag_now	pointer
)	O
;	O
gas_assert	O
(	O
frag	struct
->	O
fr_type	enum
==	O
rs_align_code	int
)	O
;	O
while	O
(	O
frag	struct
!=	O
frag_now	pointer
)	O
{	O
if	O
(	O
frag	struct
==	O
NULL	O
)	O
return	O
0	int
;	O
size	int
+=	O
frag	struct
->	O
fr_fix	long
;	O
if	O
(	O
frag	struct
->	O
fr_type	enum
==	O
rs_machine_dependent	int
)	O
size	int
+=	O
md_frag_max_var	O
(	O
frag	struct
)	O
;	O
frag	struct
=	O
frag	struct
->	O
fr_next	pointer
;	O
}	O
gas_assert	O
(	O
frag	struct
==	O
frag_now	pointer
)	O
;	O
size	int
+=	O
frag_now_fix	function
(	O
)	O
;	O
if	O
(	O
frag	struct
->	O
fr_type	enum
==	O
rs_machine_dependent	int
)	O
size	int
+=	O
md_frag_max_var	O
(	O
frag	struct
)	O
;	O
gas_assert	O
(	O
size	int
>=	O
offset	long
)	O
;	O
return	O
size	int
-	O
offset	long
;	O
}	O
static	O
void	O
finish_bundle	function
(	O
fragS	struct
*	O
frag	struct
,	O
unsigned	O
int	O
size	int
)	O
{	O
gas_assert	O
(	O
bundle_align_p2	int
>	O
0	int
)	O
;	O
gas_assert	O
(	O
frag	struct
->	O
fr_type	enum
==	O
rs_align_code	int
)	O
;	O
if	O
(	O
size	int
>	O
1	int
)	O
{	O
frag	struct
->	O
fr_offset	long
=	O
bundle_align_p2	int
;	O
frag	struct
->	O
fr_subtype	int
=	O
size	int
-	O
1	int
;	O
}	O
if	O
(	O
bundle_align_p2	int
>	O
OCTETS_PER_BYTE_POWER	int
)	O
record_alignment	function
(	O
now_seg	pointer
,	O
bundle_align_p2	int
-	O
OCTETS_PER_BYTE_POWER	int
)	O
;	O
}	O
static	O
void	O
assemble_one	function
(	O
char	O
*	O
line	int
)	O
{	O
fragS	struct
*	O
insn_start_frag	pointer
=	O
NULL	O
;	O
if	O
(	O
bundle_lock_frchain	pointer
!=	O
NULL	O
&&	O
bundle_lock_frchain	pointer
!=	O
frchain_now	pointer
)	O
{	O
as_bad	function
(	O
_	O
(	O
"cannot change section or subsection inside .bundle_lock"	pointer
)	O
)	O
;	O
bundle_lock_frchain	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
bundle_lock_frchain	pointer
==	O
NULL	O
&&	O
bundle_align_p2	int
>	O
0	int
)	O
insn_start_frag	pointer
=	O
start_bundle	function
(	O
)	O
;	O
md_assemble	function
(	O
line	int
)	O
;	O
if	O
(	O
bundle_lock_frchain	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
bundle_size	int
=	O
pending_bundle_size	function
(	O
bundle_lock_frag	pointer
)	O
;	O
if	O
(	O
bundle_size	int
>	O
1U	int
<<	O
bundle_align_p2	int
)	O
as_bad	function
(	O
_	O
(	O
".bundle_lock sequence at %u bytes, "	pointer
"but .bundle_align_mode limit is %u bytes"	pointer
)	O
,	O
bundle_size	int
,	O
1U	int
<<	O
bundle_align_p2	int
)	O
;	O
}	O
else	O
if	O
(	O
bundle_align_p2	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
insn_size	int
=	O
pending_bundle_size	function
(	O
insn_start_frag	pointer
)	O
;	O
if	O
(	O
insn_size	int
>	O
1U	int
<<	O
bundle_align_p2	int
)	O
as_bad	function
(	O
_	O
(	O
"single instruction is %u bytes long, "	pointer
"but .bundle_align_mode limit is %u bytes"	pointer
)	O
,	O
insn_size	int
,	O
1U	int
<<	O
bundle_align_p2	int
)	O
;	O
finish_bundle	function
(	O
insn_start_frag	pointer
,	O
insn_size	int
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
in_bss	function
(	O
void	O
)	O
{	O
flagword	int
flags	int
=	O
bfd_section_flags	function
(	O
now_seg	pointer
)	O
;	O
return	O
(	O
flags	int
&	O
SEC_ALLOC	int
)	O
&&	O
!	O
(	O
flags	int
&	O
(	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
)	O
;	O
}	O
void	O
do_align	function
(	O
unsigned	O
int	O
n	int
,	O
char	O
*	O
fill	pointer
,	O
unsigned	O
int	O
len	long
,	O
unsigned	O
int	O
max	int
)	O
{	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
||	O
in_bss	function
(	O
)	O
)	O
{	O
if	O
(	O
fill	pointer
!=	O
NULL	O
)	O
while	O
(	O
len	long
--	O
>	O
0	int
)	O
if	O
(	O
*	O
fill	pointer
++	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
as_warn	function
(	O
_	O
(	O
"ignoring fill value in absolute section"	pointer
)	O
)	O
;	O
else	O
as_warn	function
(	O
_	O
(	O
"ignoring fill value in section `%s'"	pointer
)	O
,	O
segment_name	O
(	O
now_seg	pointer
)	O
)	O
;	O
break	O
;	O
}	O
fill	pointer
=	O
NULL	O
;	O
len	long
=	O
0	int
;	O
}	O
md_do_align	O
(	O
n	int
,	O
fill	pointer
,	O
len	long
,	O
max	int
,	O
just_record_alignment	O
)	O
;	O
if	O
(	O
(	O
n	int
>	O
OCTETS_PER_BYTE_POWER	int
)	O
&&	O
!	O
need_pass_2	int
)	O
{	O
if	O
(	O
fill	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
subseg_text_p	function
(	O
now_seg	pointer
)	O
)	O
frag_align_code	function
(	O
n	int
,	O
max	int
)	O
;	O
else	O
frag_align	function
(	O
n	int
,	O
0	int
,	O
max	int
)	O
;	O
}	O
else	O
if	O
(	O
len	long
<=	O
1	int
)	O
frag_align	function
(	O
n	int
,	O
*	O
fill	pointer
,	O
max	int
)	O
;	O
else	O
frag_align_pattern	function
(	O
n	int
,	O
fill	pointer
,	O
len	long
,	O
max	int
)	O
;	O
}	O
just_record_alignment	O
:	O
ATTRIBUTE_UNUSED_LABEL	O
if	O
(	O
n	int
>	O
OCTETS_PER_BYTE_POWER	int
)	O
record_alignment	function
(	O
now_seg	pointer
,	O
n	int
-	O
OCTETS_PER_BYTE_POWER	int
)	O
;	O
}	O
void	O
read_a_source_file	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
char	O
nul_char	char
;	O
char	O
next_char	char
;	O
char	O
*	O
s	pointer
;	O
int	O
temp	union
;	O
pseudo_typeS	struct
*	O
pop	pointer
;	O
buffer	pointer
=	O
input_scrub_new_file	function
(	O
name	pointer
)	O
;	O
listing_file	function
(	O
name	pointer
)	O
;	O
listing_newline	function
(	O
NULL	O
)	O
;	O
register_dependency	function
(	O
name	pointer
)	O
;	O
generate_file_debug	function
(	O
)	O
;	O
while	O
(	O
(	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
static	O
char	O
*	O
last_eol	pointer
;	O
last_eol	pointer
=	O
NULL	O
;	O
while	O
(	O
input_line_pointer	pointer
<	O
buffer_limit	pointer
)	O
{	O
bfd_boolean	int
was_new_line	int
;	O
was_new_line	int
=	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	pointer
[	O
-	O
1	int
]	O
]	O
;	O
if	O
(	O
was_new_line	int
)	O
{	O
symbol_set_value_now	function
(	O
&	O
dot_symbol	struct
)	O
;	O
if	O
(	O
input_line_pointer	pointer
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
bump_line_counters	function
(	O
)	O
;	O
}	O
if	O
(	O
listing	int
)	O
{	O
if	O
(	O
(	O
listing	int
&	O
LISTING_MACEXP	int
)	O
&&	O
macro_nest	int
>	O
0	int
)	O
{	O
s	pointer
=	O
find_end_of_line	function
(	O
input_line_pointer	pointer
,	O
flag_m68k_mri	int
)	O
;	O
if	O
(	O
s	pointer
!=	O
last_eol	pointer
)	O
{	O
char	O
*	O
copy	int
;	O
int	O
len	long
;	O
last_eol	pointer
=	O
s	pointer
;	O
len	long
=	O
s	pointer
-	O
input_line_pointer	pointer
;	O
copy	int
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
+	O
macro_nest	int
+	O
2	int
)	O
;	O
memset	function
(	O
copy	int
,	O
'>'	O
,	O
macro_nest	int
)	O
;	O
copy	int
[	O
macro_nest	int
]	O
=	O
' '	O
;	O
memcpy	function
(	O
copy	int
+	O
macro_nest	int
+	O
1	int
,	O
input_line_pointer	pointer
,	O
len	long
)	O
;	O
copy	int
[	O
macro_nest	int
+	O
1	int
+	O
len	long
]	O
=	O
'\0'	O
;	O
listing_newline	function
(	O
copy	int
)	O
;	O
}	O
}	O
else	O
listing_newline	function
(	O
NULL	O
)	O
;	O
}	O
if	O
(	O
was_new_line	int
)	O
{	O
line_label	pointer
=	O
NULL	O
;	O
if	O
(	O
LABELS_WITHOUT_COLONS	int
||	O
flag_m68k_mri	int
)	O
{	O
next_char	char
=	O
*	O
input_line_pointer	pointer
;	O
if	O
(	O
is_name_beginner	O
(	O
next_char	char
)	O
||	O
next_char	char
==	O
'"'	O
)	O
{	O
char	O
*	O
line_start	pointer
;	O
int	O
mri_line_macro	int
;	O
HANDLE_CONDITIONAL_ASSEMBLY	O
(	O
0	int
)	O
;	O
nul_char	char
=	O
get_symbol_name	function
(	O
&	O
line_start	pointer
)	O
;	O
next_char	char
=	O
(	O
nul_char	char
==	O
'"'	O
?	O
input_line_pointer	pointer
[	O
1	int
]	O
:	O
nul_char	char
)	O
;	O
mri_line_macro	int
=	O
0	int
;	O
if	O
(	O
flag_m68k_mri	int
)	O
{	O
char	O
*	O
rest	pointer
=	O
input_line_pointer	pointer
+	O
1	int
;	O
if	O
(	O
*	O
rest	pointer
==	O
':'	O
)	O
++	O
rest	pointer
;	O
if	O
(	O
*	O
rest	pointer
==	O
' '	O
||	O
*	O
rest	pointer
==	O
'\t'	O
)	O
++	O
rest	pointer
;	O
if	O
(	O
(	O
strncasecmp	function
(	O
rest	pointer
,	O
"EQU"	pointer
,	O
3	int
)	O
==	O
0	int
||	O
strncasecmp	function
(	O
rest	pointer
,	O
"SET"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
&&	O
(	O
rest	pointer
[	O
3	int
]	O
==	O
' '	O
||	O
rest	pointer
[	O
3	int
]	O
==	O
'\t'	O
)	O
)	O
{	O
input_line_pointer	pointer
=	O
rest	pointer
+	O
3	int
;	O
equals	function
(	O
line_start	pointer
,	O
strncasecmp	function
(	O
rest	pointer
,	O
"SET"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
strncasecmp	function
(	O
rest	pointer
,	O
"MACRO"	pointer
,	O
5	int
)	O
==	O
0	int
&&	O
(	O
rest	pointer
[	O
5	int
]	O
==	O
' '	O
||	O
rest	pointer
[	O
5	int
]	O
==	O
'\t'	O
||	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
rest	pointer
[	O
5	int
]	O
]	O
)	O
)	O
mri_line_macro	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
mri_line_macro	int
)	O
line_label	pointer
=	O
colon	function
(	O
line_start	pointer
)	O
;	O
else	O
line_label	pointer
=	O
symbol_create	function
(	O
line_start	pointer
,	O
absolute_section	O
,	O
(	O
valueT	long
)	O
0	int
,	O
&	O
zero_address_frag	struct
)	O
;	O
next_char	char
=	O
restore_line_pointer	function
(	O
nul_char	char
)	O
;	O
if	O
(	O
next_char	char
==	O
':'	O
)	O
input_line_pointer	pointer
++	O
;	O
}	O
}	O
}	O
do	O
nul_char	char
=	O
next_char	char
=	O
*	O
input_line_pointer	pointer
++	O
;	O
while	O
(	O
next_char	char
==	O
'\t'	O
||	O
next_char	char
==	O
' '	O
||	O
next_char	char
==	O
'\f'	O
)	O
;	O
if	O
(	O
is_name_beginner	O
(	O
next_char	char
)	O
||	O
next_char	char
==	O
'"'	O
)	O
{	O
char	O
*	O
rest	pointer
;	O
HANDLE_CONDITIONAL_ASSEMBLY	O
(	O
1	int
)	O
;	O
--	O
input_line_pointer	pointer
;	O
nul_char	char
=	O
get_symbol_name	function
(	O
&	O
s	pointer
)	O
;	O
next_char	char
=	O
(	O
nul_char	char
==	O
'"'	O
?	O
input_line_pointer	pointer
[	O
1	int
]	O
:	O
nul_char	char
)	O
;	O
rest	pointer
=	O
input_line_pointer	pointer
+	O
(	O
nul_char	char
==	O
'"'	O
?	O
2	int
:	O
1	int
)	O
;	O
if	O
(	O
TC_START_LABEL	O
(	O
s	pointer
,	O
nul_char	char
,	O
next_char	char
)	O
)	O
{	O
if	O
(	O
flag_m68k_mri	int
)	O
{	O
if	O
(	O
*	O
rest	pointer
==	O
':'	O
)	O
++	O
rest	pointer
;	O
if	O
(	O
*	O
rest	pointer
==	O
' '	O
||	O
*	O
rest	pointer
==	O
'\t'	O
)	O
++	O
rest	pointer
;	O
if	O
(	O
(	O
strncasecmp	function
(	O
rest	pointer
,	O
"EQU"	pointer
,	O
3	int
)	O
==	O
0	int
||	O
strncasecmp	function
(	O
rest	pointer
,	O
"SET"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
&&	O
(	O
rest	pointer
[	O
3	int
]	O
==	O
' '	O
||	O
rest	pointer
[	O
3	int
]	O
==	O
'\t'	O
)	O
)	O
{	O
input_line_pointer	pointer
=	O
rest	pointer
+	O
3	int
;	O
equals	function
(	O
s	pointer
,	O
1	int
)	O
;	O
continue	O
;	O
}	O
}	O
line_label	pointer
=	O
colon	function
(	O
s	pointer
)	O
;	O
restore_line_pointer	function
(	O
nul_char	char
)	O
;	O
++	O
input_line_pointer	pointer
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
next_char	char
==	O
'='	O
&&	O
*	O
rest	pointer
==	O
'='	O
)	O
||	O
(	O
(	O
next_char	char
==	O
' '	O
||	O
next_char	char
==	O
'\t'	O
)	O
&&	O
rest	pointer
[	O
0	int
]	O
==	O
'='	O
&&	O
rest	pointer
[	O
1	int
]	O
==	O
'='	O
)	O
)	O
{	O
equals	function
(	O
s	pointer
,	O
-	O
1	int
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
next_char	char
==	O
'='	O
||	O
(	O
(	O
next_char	char
==	O
' '	O
||	O
next_char	char
==	O
'\t'	O
)	O
&&	O
*	O
rest	pointer
==	O
'='	O
)	O
)	O
)	O
{	O
equals	function
(	O
s	pointer
,	O
1	int
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
else	O
{	O
pop	pointer
=	O
NULL	O
;	O
{	O
char	O
*	O
s2	pointer
=	O
s	pointer
;	O
strncpy	function
(	O
original_case_string	array
,	O
s2	pointer
,	O
sizeof	O
(	O
original_case_string	array
)	O
)	O
;	O
original_case_string	array
[	O
sizeof	O
(	O
original_case_string	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
while	O
(	O
*	O
s2	pointer
)	O
{	O
*	O
s2	pointer
=	O
TOLOWER	O
(	O
*	O
s2	pointer
)	O
;	O
s2	pointer
++	O
;	O
}	O
}	O
if	O
(	O
NO_PSEUDO_DOT	int
||	O
flag_m68k_mri	int
)	O
{	O
pop	pointer
=	O
(	O
pseudo_typeS	struct
*	O
)	O
hash_find	function
(	O
po_hash	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
pop	pointer
!=	O
NULL	O
&&	O
pop	pointer
->	O
poc_handler	pointer
==	O
NULL	O
)	O
pop	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
pop	pointer
!=	O
NULL	O
||	O
(	O
!	O
flag_m68k_mri	int
&&	O
*	O
s	pointer
==	O
'.'	O
)	O
)	O
{	O
if	O
(	O
pop	pointer
==	O
NULL	O
)	O
pop	pointer
=	O
(	O
pseudo_typeS	struct
*	O
)	O
hash_find	function
(	O
po_hash	pointer
,	O
s	pointer
+	O
1	int
)	O
;	O
if	O
(	O
pop	pointer
&&	O
!	O
pop	pointer
->	O
poc_handler	pointer
)	O
pop	pointer
=	O
NULL	O
;	O
if	O
(	O
mri_pending_align	int
&&	O
(	O
pop	pointer
==	O
NULL	O
||	O
!	O
(	O
(	O
pop	pointer
->	O
poc_handler	pointer
==	O
cons	function
&&	O
pop	pointer
->	O
poc_val	int
==	O
1	int
)	O
||	O
(	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_space	function
&&	O
pop	pointer
->	O
poc_val	int
==	O
1	int
)	O
||	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_if	function
||	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_ifdef	function
||	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_ifc	function
||	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_ifeqs	function
||	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_else	function
||	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_endif	function
||	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_globl	function
||	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_ignore	function
)	O
)	O
)	O
{	O
do_align	function
(	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
mri_pending_align	int
=	O
0	int
;	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
{	O
symbol_set_frag	function
(	O
line_label	pointer
,	O
frag_now	pointer
)	O
;	O
S_SET_VALUE	function
(	O
line_label	pointer
,	O
frag_now_fix	function
(	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
pop	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
end	pointer
=	O
input_line_pointer	pointer
;	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
nul_char	char
)	O
;	O
s_ignore	function
(	O
0	int
)	O
;	O
nul_char	char
=	O
next_char	char
=	O
*	O
--	O
input_line_pointer	pointer
;	O
*	O
input_line_pointer	pointer
=	O
'\0'	O
;	O
if	O
(	O
!	O
macro_defined	int
||	O
!	O
try_macro	function
(	O
next_char	char
,	O
s	pointer
)	O
)	O
{	O
*	O
end	pointer
=	O
'\0'	O
;	O
as_bad	function
(	O
_	O
(	O
"unknown pseudo-op: `%s'"	pointer
)	O
,	O
s	pointer
)	O
;	O
*	O
input_line_pointer	pointer
++	O
=	O
nul_char	char
;	O
}	O
continue	O
;	O
}	O
next_char	char
=	O
restore_line_pointer	function
(	O
nul_char	char
)	O
;	O
if	O
(	O
next_char	char
==	O
' '	O
||	O
next_char	char
==	O
'\t'	O
)	O
input_line_pointer	pointer
++	O
;	O
(	O
*	O
pop	pointer
->	O
poc_handler	pointer
)	O
(	O
pop	pointer
->	O
poc_val	int
)	O
;	O
if	O
(	O
pop	pointer
->	O
poc_handler	pointer
==	O
s_end	function
)	O
goto	O
quit	O
;	O
}	O
else	O
{	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
nul_char	char
)	O
;	O
input_line_pointer	pointer
=	O
_find_end_of_line	function
(	O
input_line_pointer	pointer
,	O
flag_m68k_mri	int
,	O
1	int
,	O
0	int
)	O
;	O
next_char	char
=	O
nul_char	char
=	O
*	O
input_line_pointer	pointer
;	O
*	O
input_line_pointer	pointer
=	O
'\0'	O
;	O
generate_lineno_debug	function
(	O
)	O
;	O
if	O
(	O
macro_defined	int
&&	O
try_macro	function
(	O
next_char	char
,	O
s	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
mri_pending_align	int
)	O
{	O
do_align	function
(	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
mri_pending_align	int
=	O
0	int
;	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
{	O
symbol_set_frag	function
(	O
line_label	pointer
,	O
frag_now	pointer
)	O
;	O
S_SET_VALUE	function
(	O
line_label	pointer
,	O
frag_now_fix	function
(	O
)	O
)	O
;	O
}	O
}	O
assemble_one	function
(	O
s	pointer
)	O
;	O
if	O
(	O
input_line_pointer	pointer
==	O
NULL	O
)	O
as_fatal	function
(	O
_	O
(	O
"unable to continue with assembly."	pointer
)	O
)	O
;	O
*	O
input_line_pointer	pointer
++	O
=	O
nul_char	char
;	O
}	O
}	O
continue	O
;	O
}	O
if	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
next_char	char
]	O
)	O
continue	O
;	O
if	O
(	O
(	O
LOCAL_LABELS_DOLLAR	int
||	O
LOCAL_LABELS_FB	int
)	O
&&	O
ISDIGIT	O
(	O
next_char	char
)	O
)	O
{	O
char	O
*	O
backup	pointer
=	O
input_line_pointer	pointer
;	O
HANDLE_CONDITIONAL_ASSEMBLY	O
(	O
1	int
)	O
;	O
temp	union
=	O
next_char	char
-	O
'0'	O
;	O
if	O
(	O
nul_char	char
==	O
'"'	O
)	O
++	O
input_line_pointer	pointer
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
input_line_pointer	pointer
)	O
)	O
{	O
temp	union
=	O
(	O
temp	union
*	O
10	int
)	O
+	O
*	O
input_line_pointer	pointer
-	O
'0'	O
;	O
++	O
input_line_pointer	pointer
;	O
}	O
if	O
(	O
LOCAL_LABELS_DOLLAR	int
&&	O
*	O
input_line_pointer	pointer
==	O
'$'	O
&&	O
*	O
(	O
input_line_pointer	pointer
+	O
1	int
)	O
==	O
':'	O
)	O
{	O
input_line_pointer	pointer
+=	O
2	int
;	O
if	O
(	O
dollar_label_defined	function
(	O
temp	union
)	O
)	O
{	O
as_fatal	function
(	O
_	O
(	O
"label \"%d$\" redefined"	pointer
)	O
,	O
temp	union
)	O
;	O
}	O
define_dollar_label	function
(	O
temp	union
)	O
;	O
colon	function
(	O
dollar_label_name	function
(	O
temp	union
,	O
0	int
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
LOCAL_LABELS_FB	int
&&	O
*	O
input_line_pointer	pointer
++	O
==	O
':'	O
)	O
{	O
fb_label_instance_inc	function
(	O
temp	union
)	O
;	O
colon	function
(	O
fb_label_name	function
(	O
temp	union
,	O
0	int
)	O
)	O
;	O
continue	O
;	O
}	O
input_line_pointer	pointer
=	O
backup	pointer
;	O
}	O
if	O
(	O
next_char	char
&&	O
strchr	function
(	O
line_comment_chars	array
,	O
next_char	char
)	O
)	O
{	O
sb	pointer
sbuf	struct
;	O
char	O
*	O
ends	pointer
;	O
char	O
*	O
new_buf	pointer
;	O
char	O
*	O
new_tmp	pointer
;	O
unsigned	O
int	O
new_length	int
;	O
char	O
*	O
tmp_buf	pointer
=	O
0	int
;	O
s	pointer
=	O
input_line_pointer	pointer
;	O
if	O
(	O
strncmp	function
(	O
s	pointer
,	O
"APP\n"	pointer
,	O
4	int
)	O
)	O
{	O
ignore_rest_of_line	function
(	O
)	O
;	O
continue	O
;	O
}	O
bump_line_counters	function
(	O
)	O
;	O
s	pointer
+=	O
4	int
;	O
ends	pointer
=	O
strstr	function
(	O
s	pointer
,	O
"#NO_APP\n"	pointer
)	O
;	O
if	O
(	O
!	O
ends	pointer
)	O
{	O
unsigned	O
int	O
tmp_len	int
;	O
unsigned	O
int	O
num	int
;	O
tmp_len	int
=	O
buffer_limit	pointer
-	O
s	pointer
;	O
tmp_buf	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
tmp_len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
tmp_buf	pointer
,	O
s	pointer
,	O
tmp_len	int
)	O
;	O
do	O
{	O
new_tmp	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
buffer	pointer
)	O
;	O
if	O
(	O
!	O
new_tmp	pointer
)	O
break	O
;	O
else	O
buffer_limit	pointer
=	O
new_tmp	pointer
;	O
input_line_pointer	pointer
=	O
buffer	pointer
;	O
ends	pointer
=	O
strstr	function
(	O
buffer	pointer
,	O
"#NO_APP\n"	pointer
)	O
;	O
if	O
(	O
ends	pointer
)	O
num	int
=	O
ends	pointer
-	O
buffer	pointer
;	O
else	O
num	int
=	O
buffer_limit	pointer
-	O
buffer	pointer
;	O
tmp_buf	pointer
=	O
XRESIZEVEC	O
(	O
char	O
,	O
tmp_buf	pointer
,	O
tmp_len	int
+	O
num	int
)	O
;	O
memcpy	function
(	O
tmp_buf	pointer
+	O
tmp_len	int
,	O
buffer	pointer
,	O
num	int
)	O
;	O
tmp_len	int
+=	O
num	int
;	O
}	O
while	O
(	O
!	O
ends	pointer
)	O
;	O
input_line_pointer	pointer
=	O
ends	pointer
?	O
ends	pointer
+	O
8	int
:	O
NULL	O
;	O
s	pointer
=	O
tmp_buf	pointer
;	O
ends	pointer
=	O
s	pointer
+	O
tmp_len	int
;	O
}	O
else	O
{	O
input_line_pointer	pointer
=	O
ends	pointer
+	O
8	int
;	O
}	O
scrub_string	pointer
=	O
s	pointer
;	O
scrub_string_end	pointer
=	O
ends	pointer
;	O
new_length	int
=	O
ends	pointer
-	O
s	pointer
;	O
new_buf	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
new_length	int
)	O
;	O
new_tmp	pointer
=	O
new_buf	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
space	long
;	O
size_t	long
size	int
;	O
space	long
=	O
(	O
new_buf	pointer
+	O
new_length	int
)	O
-	O
new_tmp	pointer
;	O
size	int
=	O
do_scrub_chars	function
(	O
scrub_from_string	function
,	O
new_tmp	pointer
,	O
space	long
)	O
;	O
if	O
(	O
size	int
<	O
space	long
)	O
{	O
new_tmp	pointer
[	O
size	int
]	O
=	O
0	int
;	O
break	O
;	O
}	O
new_buf	pointer
=	O
XRESIZEVEC	O
(	O
char	O
,	O
new_buf	pointer
,	O
new_length	int
+	O
100	int
)	O
;	O
new_tmp	pointer
=	O
new_buf	pointer
+	O
new_length	int
;	O
new_length	int
+=	O
100	int
;	O
}	O
if	O
(	O
tmp_buf	pointer
)	O
free	function
(	O
tmp_buf	pointer
)	O
;	O
new_length	int
=	O
strlen	function
(	O
new_buf	pointer
)	O
;	O
sb_build	function
(	O
&	O
sbuf	struct
,	O
new_length	int
)	O
;	O
sb_add_buffer	function
(	O
&	O
sbuf	struct
,	O
new_buf	pointer
,	O
new_length	int
)	O
;	O
input_scrub_include_sb	function
(	O
&	O
sbuf	struct
,	O
input_line_pointer	pointer
,	O
0	int
)	O
;	O
sb_kill	function
(	O
&	O
sbuf	struct
)	O
;	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
free	function
(	O
new_buf	pointer
)	O
;	O
continue	O
;	O
}	O
HANDLE_CONDITIONAL_ASSEMBLY	O
(	O
1	int
)	O
;	O
input_line_pointer	pointer
--	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
}	O
quit	O
:	O
symbol_set_value_now	function
(	O
&	O
dot_symbol	struct
)	O
;	O
if	O
(	O
bundle_lock_frag	pointer
!=	O
NULL	O
)	O
{	O
as_bad_where	function
(	O
bundle_lock_frag	pointer
->	O
fr_file	pointer
,	O
bundle_lock_frag	pointer
->	O
fr_line	int
,	O
_	O
(	O
".bundle_lock with no matching .bundle_unlock"	pointer
)	O
)	O
;	O
bundle_lock_frag	pointer
=	O
NULL	O
;	O
bundle_lock_frchain	pointer
=	O
NULL	O
;	O
bundle_lock_depth	int
=	O
0	int
;	O
}	O
md_cleanup	O
(	O
)	O
;	O
input_scrub_close	function
(	O
)	O
;	O
}	O
static	O
void	O
convert_to_bignum	function
(	O
expressionS	struct
*	O
exp	pointer
,	O
int	O
sign	char
)	O
{	O
valueT	long
value	long
;	O
unsigned	O
int	O
i	pointer
;	O
value	long
=	O
exp	pointer
->	O
X_add_number	long
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
sizeof	O
(	O
exp	pointer
->	O
X_add_number	long
)	O
/	O
CHARS_PER_LITTLENUM	O
;	O
i	pointer
++	O
)	O
{	O
generic_bignum	array
[	O
i	pointer
]	O
=	O
value	long
&	O
LITTLENUM_MASK	O
;	O
value	long
>>=	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
}	O
if	O
(	O
(	O
exp	pointer
->	O
X_add_number	long
<	O
0	int
)	O
==	O
!	O
sign	char
)	O
generic_bignum	array
[	O
i	pointer
++	O
]	O
=	O
sign	char
?	O
LITTLENUM_MASK	O
:	O
0	int
;	O
exp	pointer
->	O
X_op	enum
=	O
O_big	int
;	O
exp	pointer
->	O
X_add_number	long
=	O
i	pointer
;	O
}	O
char	O
*	O
mri_comment_field	function
(	O
char	O
*	O
stopcp	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
input_line_pointer	pointer
;	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
]	O
;	O
s	pointer
++	O
)	O
;	O
*	O
stopcp	pointer
=	O
*	O
s	pointer
;	O
*	O
s	pointer
=	O
'\0'	O
;	O
return	O
s	pointer
;	O
}	O
void	O
mri_comment_end	function
(	O
char	O
*	O
stop	pointer
,	O
int	O
stopc	int
)	O
{	O
know	O
(	O
flag_mri	int
)	O
;	O
input_line_pointer	pointer
=	O
stop	pointer
;	O
*	O
stop	pointer
=	O
stopc	int
;	O
while	O
(	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
++	O
input_line_pointer	pointer
;	O
}	O
void	O
s_abort	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
as_fatal	function
(	O
_	O
(	O
".abort detected.  Abandoning ship."	pointer
)	O
)	O
;	O
}	O
static	O
void	O
s_align	function
(	O
signed	O
int	O
arg	pointer
,	O
int	O
bytes_p	int
)	O
{	O
unsigned	O
int	O
align_limit	int
=	O
TC_ALIGN_LIMIT	O
;	O
unsigned	O
int	O
align	int
;	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
offsetT	long
fill	pointer
=	O
0	int
;	O
unsigned	O
int	O
max	int
;	O
int	O
fill_p	int
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
if	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
{	O
if	O
(	O
arg	pointer
<	O
0	int
)	O
align	int
=	O
0	int
;	O
else	O
align	int
=	O
arg	pointer
;	O
}	O
else	O
{	O
align	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
if	O
(	O
bytes_p	int
)	O
{	O
if	O
(	O
align	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
(	O
align	int
&	O
1	int
)	O
==	O
0	int
;	O
align	int
>>=	O
1	int
,	O
++	O
i	pointer
)	O
;	O
if	O
(	O
align	int
!=	O
1	int
)	O
as_bad	function
(	O
_	O
(	O
"alignment not a power of 2"	pointer
)	O
)	O
;	O
align	int
=	O
i	pointer
;	O
}	O
}	O
if	O
(	O
align	int
>	O
align_limit	int
)	O
{	O
align	int
=	O
align_limit	int
;	O
as_warn	function
(	O
_	O
(	O
"alignment too large: %u assumed"	pointer
)	O
,	O
align	int
)	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
fill_p	int
=	O
0	int
;	O
max	int
=	O
0	int
;	O
}	O
else	O
{	O
++	O
input_line_pointer	pointer
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
fill_p	int
=	O
0	int
;	O
else	O
{	O
fill	pointer
=	O
get_absolute_expression	function
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
fill_p	int
=	O
1	int
;	O
}	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
max	int
=	O
0	int
;	O
else	O
{	O
++	O
input_line_pointer	pointer
;	O
max	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
fill_p	int
)	O
{	O
if	O
(	O
arg	pointer
<	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
"expected fill pattern missing"	pointer
)	O
)	O
;	O
do_align	function
(	O
align	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
max	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
int	O
fill_len	int
;	O
if	O
(	O
arg	pointer
>=	O
0	int
)	O
fill_len	int
=	O
1	int
;	O
else	O
fill_len	int
=	O
-	O
arg	pointer
;	O
if	O
(	O
fill_len	int
<=	O
1	int
)	O
{	O
char	O
fill_char	char
=	O
0	int
;	O
fill_char	char
=	O
fill	pointer
;	O
do_align	function
(	O
align	int
,	O
&	O
fill_char	char
,	O
fill_len	int
,	O
max	int
)	O
;	O
}	O
else	O
{	O
char	O
ab	array
[	O
16	int
]	O
;	O
if	O
(	O
(	O
size_t	long
)	O
fill_len	int
>	O
sizeof	O
ab	array
)	O
{	O
as_warn	function
(	O
_	O
(	O
"fill pattern too long, truncating to %u"	pointer
)	O
,	O
(	O
unsigned	O
)	O
sizeof	O
ab	array
)	O
;	O
fill_len	int
=	O
sizeof	O
ab	array
;	O
}	O
md_number_to_chars	O
(	O
ab	array
,	O
fill	pointer
,	O
fill_len	int
)	O
;	O
do_align	function
(	O
align	int
,	O
ab	array
,	O
fill_len	int
,	O
max	int
)	O
;	O
}	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
s_align_bytes	function
(	O
int	O
arg	pointer
)	O
{	O
s_align	function
(	O
arg	pointer
,	O
1	int
)	O
;	O
}	O
void	O
s_align_ptwo	function
(	O
int	O
arg	pointer
)	O
{	O
s_align	function
(	O
arg	pointer
,	O
0	int
)	O
;	O
}	O
static	O
void	O
s_altmacro	function
(	O
int	O
on	int
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
macro_set_alternate	function
(	O
on	int
)	O
;	O
}	O
char	O
*	O
read_symbol_name	function
(	O
void	O
)	O
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
start	pointer
;	O
char	O
c	struct
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
c	struct
==	O
'"'	O
)	O
{	O
ptrdiff_t	long
len	long
=	O
SYM_NAME_CHUNK_LEN	int
;	O
char	O
*	O
name_end	pointer
;	O
unsigned	O
int	O
C	int
;	O
start	pointer
=	O
name	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
+	O
1	int
)	O
;	O
name_end	pointer
=	O
name	pointer
+	O
SYM_NAME_CHUNK_LEN	int
;	O
while	O
(	O
is_a_char	O
(	O
C	int
=	O
next_char_of_string	function
(	O
)	O
)	O
)	O
{	O
if	O
(	O
name	pointer
>=	O
name_end	pointer
)	O
{	O
ptrdiff_t	long
sofar	long
;	O
sofar	long
=	O
name	pointer
-	O
start	pointer
;	O
len	long
+=	O
SYM_NAME_CHUNK_LEN	int
;	O
start	pointer
=	O
XRESIZEVEC	O
(	O
char	O
,	O
start	pointer
,	O
len	long
+	O
1	int
)	O
;	O
name_end	pointer
=	O
start	pointer
+	O
len	long
;	O
name	pointer
=	O
start	pointer
+	O
sofar	long
;	O
}	O
*	O
name	pointer
++	O
=	O
(	O
char	O
)	O
C	int
;	O
}	O
*	O
name	pointer
=	O
0	int
;	O
if	O
(	O
mbstowcs	function
(	O
NULL	O
,	O
name	pointer
,	O
len	long
)	O
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
as_warn	function
(	O
_	O
(	O
"symbol name not recognised in the current locale"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
is_name_beginner	O
(	O
c	struct
)	O
||	O
(	O
input_from_string	int
&&	O
c	struct
==	O
FAKE_LABEL_CHAR	char
)	O
)	O
{	O
ptrdiff_t	long
len	long
;	O
name	pointer
=	O
input_line_pointer	pointer
-	O
1	int
;	O
while	O
(	O
is_part_of_name	O
(	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
)	O
||	O
(	O
input_from_string	int
&&	O
c	struct
==	O
FAKE_LABEL_CHAR	char
)	O
)	O
;	O
len	long
=	O
(	O
input_line_pointer	pointer
-	O
name	pointer
)	O
-	O
1	int
;	O
start	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
start	pointer
,	O
name	pointer
,	O
len	long
)	O
;	O
start	pointer
[	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
!	O
is_name_ender	O
(	O
c	struct
)	O
)	O
--	O
input_line_pointer	pointer
;	O
}	O
else	O
name	pointer
=	O
start	pointer
=	O
NULL	O
;	O
if	O
(	O
name	pointer
==	O
start	pointer
)	O
{	O
as_bad	function
(	O
_	O
(	O
"expected symbol name"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
return	O
start	pointer
;	O
}	O
symbolS	struct
*	O
s_comm_internal	function
(	O
int	O
param	int
,	O
symbolS	struct
*	O
(	O
*	O
comm_parse_extra	pointer
)	O
(	O
int	O
,	O
symbolS	struct
*	O
,	O
addressT	long
)	O
)	O
{	O
char	O
*	O
name	pointer
;	O
offsetT	long
temp	union
,	O
size	int
;	O
symbolS	struct
*	O
symbolP	pointer
=	O
NULL	O
;	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
expressionS	struct
exp	pointer
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
if	O
(	O
(	O
name	pointer
=	O
read_symbol_name	function
(	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
out	pointer
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
input_line_pointer	pointer
++	O
;	O
temp	union
=	O
get_absolute_expr	function
(	O
&	O
exp	pointer
)	O
;	O
size	int
=	O
temp	union
;	O
size	int
&=	O
(	O
(	O
addressT	long
)	O
2	int
<<	O
(	O
stdoutput	pointer
->	O
arch_info	pointer
->	O
bits_per_address	int
-	O
1	int
)	O
)	O
-	O
1	int
;	O
if	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_absent	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"missing size expression"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
goto	O
out	pointer
;	O
}	O
else	O
if	O
(	O
temp	union
!=	O
size	int
||	O
!	O
exp	pointer
.	O
X_unsigned	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"size (%ld) out of range, ignored"	pointer
)	O
,	O
(	O
long	O
)	O
temp	union
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
goto	O
out	pointer
;	O
}	O
symbolP	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
if	O
(	O
(	O
S_IS_DEFINED	function
(	O
symbolP	pointer
)	O
||	O
symbol_equated_p	function
(	O
symbolP	pointer
)	O
)	O
&&	O
!	O
S_IS_COMMON	function
(	O
symbolP	pointer
)	O
)	O
{	O
if	O
(	O
!	O
S_IS_VOLATILE	function
(	O
symbolP	pointer
)	O
)	O
{	O
symbolP	pointer
=	O
NULL	O
;	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined"	pointer
)	O
,	O
name	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
goto	O
out	pointer
;	O
}	O
symbolP	pointer
=	O
symbol_clone	function
(	O
symbolP	pointer
,	O
1	int
)	O
;	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
undefined_section	O
)	O
;	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
0	int
)	O
;	O
symbol_set_frag	function
(	O
symbolP	pointer
,	O
&	O
zero_address_frag	struct
)	O
;	O
S_CLEAR_VOLATILE	function
(	O
symbolP	pointer
)	O
;	O
}	O
size	int
=	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
;	O
if	O
(	O
size	int
==	O
0	int
)	O
size	int
=	O
temp	union
;	O
else	O
if	O
(	O
size	int
!=	O
temp	union
)	O
as_warn	function
(	O
_	O
(	O
"size of \"%s\" is already %ld; not changing to %ld"	pointer
)	O
,	O
name	pointer
,	O
(	O
long	O
)	O
size	int
,	O
(	O
long	O
)	O
temp	union
)	O
;	O
if	O
(	O
comm_parse_extra	pointer
!=	O
NULL	O
)	O
symbolP	pointer
=	O
(	O
*	O
comm_parse_extra	pointer
)	O
(	O
param	int
,	O
symbolP	pointer
,	O
size	int
)	O
;	O
else	O
{	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
(	O
valueT	long
)	O
size	int
)	O
;	O
S_SET_EXTERNAL	function
(	O
symbolP	pointer
)	O
;	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
bfd_com_section_ptr	O
)	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
out	pointer
:	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
free	function
(	O
name	pointer
)	O
;	O
return	O
symbolP	pointer
;	O
}	O
void	O
s_comm	function
(	O
int	O
ignore	int
)	O
{	O
s_comm_internal	function
(	O
ignore	int
,	O
NULL	O
)	O
;	O
}	O
void	O
s_mri_common	function
(	O
int	O
small	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	pointer
;	O
char	O
c	struct
;	O
char	O
*	O
alc	pointer
=	O
NULL	O
;	O
symbolS	struct
*	O
sym	pointer
;	O
offsetT	long
align	int
;	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
if	O
(	O
!	O
flag_mri	int
)	O
{	O
s_comm	function
(	O
0	int
)	O
;	O
return	O
;	O
}	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
name	pointer
=	O
input_line_pointer	pointer
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
name	pointer
)	O
)	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
name	pointer
)	O
;	O
else	O
{	O
do	O
{	O
++	O
input_line_pointer	pointer
;	O
}	O
while	O
(	O
ISDIGIT	O
(	O
*	O
input_line_pointer	pointer
)	O
)	O
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
;	O
*	O
input_line_pointer	pointer
=	O
'\0'	O
;	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
{	O
alc	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
strlen	function
(	O
S_GET_NAME	function
(	O
line_label	pointer
)	O
)	O
+	O
(	O
input_line_pointer	pointer
-	O
name	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
alc	pointer
,	O
"%s%s"	pointer
,	O
name	pointer
,	O
S_GET_NAME	function
(	O
line_label	pointer
)	O
)	O
;	O
name	pointer
=	O
alc	pointer
;	O
}	O
}	O
sym	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
c	struct
=	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
if	O
(	O
alc	pointer
!=	O
NULL	O
)	O
free	function
(	O
alc	pointer
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
align	int
=	O
0	int
;	O
else	O
{	O
++	O
input_line_pointer	pointer
;	O
align	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
}	O
if	O
(	O
S_IS_DEFINED	function
(	O
sym	pointer
)	O
&&	O
!	O
S_IS_COMMON	function
(	O
sym	pointer
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined"	pointer
)	O
,	O
S_GET_NAME	function
(	O
sym	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
return	O
;	O
}	O
S_SET_EXTERNAL	function
(	O
sym	pointer
)	O
;	O
S_SET_SEGMENT	function
(	O
sym	pointer
,	O
bfd_com_section_ptr	O
)	O
;	O
mri_common_symbol	pointer
=	O
sym	pointer
;	O
if	O
(	O
align	int
!=	O
0	int
)	O
S_SET_ALIGN	O
(	O
sym	pointer
,	O
align	int
)	O
;	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
{	O
expressionS	struct
exp	pointer
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
sym	pointer
;	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
symbol_set_value_expression	function
(	O
line_label	pointer
,	O
&	O
exp	pointer
)	O
;	O
symbol_set_frag	function
(	O
line_label	pointer
,	O
&	O
zero_address_frag	struct
)	O
;	O
S_SET_SEGMENT	function
(	O
line_label	pointer
,	O
expr_section	pointer
)	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
input_line_pointer	pointer
+=	O
2	int
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
input_line_pointer	pointer
+=	O
2	int
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
s_data	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
segT	pointer
section	pointer
;	O
int	O
temp	union
;	O
temp	union
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
flag_readonly_data_in_text	char
)	O
{	O
section	pointer
=	O
text_section	pointer
;	O
temp	union
+=	O
1000	int
;	O
}	O
else	O
section	pointer
=	O
data_section	pointer
;	O
subseg_set	function
(	O
section	pointer
,	O
(	O
subsegT	int
)	O
temp	union
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_app_file_string	function
(	O
char	O
*	O
file	pointer
,	O
int	O
appfile	int
ATTRIBUTE_UNUSED	O
)	O
{	O
register_dependency	function
(	O
file	pointer
)	O
;	O
obj_app_file	O
(	O
file	pointer
,	O
appfile	int
)	O
;	O
}	O
void	O
s_app_file	function
(	O
int	O
appfile	int
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
length	char
;	O
if	O
(	O
(	O
s	pointer
=	O
demand_copy_string	function
(	O
&	O
length	char
)	O
)	O
!=	O
0	int
)	O
{	O
int	O
may_omit	int
=	O
(	O
!	O
new_logical_line_flags	function
(	O
s	pointer
,	O
-	O
1	int
,	O
1	int
)	O
&&	O
appfile	int
)	O
;	O
if	O
(	O
flag_m68k_mri	int
&&	O
*	O
input_line_pointer	pointer
==	O
'\''	O
&&	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	pointer
[	O
1	int
]	O
]	O
)	O
++	O
input_line_pointer	pointer
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
!	O
may_omit	int
)	O
s_app_file_string	function
(	O
s	pointer
,	O
appfile	int
)	O
;	O
}	O
}	O
static	O
int	O
get_linefile_number	function
(	O
int	O
*	O
flag	pointer
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
<	O
'0'	O
||	O
*	O
input_line_pointer	pointer
>	O
'9'	O
)	O
return	O
0	int
;	O
*	O
flag	pointer
=	O
get_absolute_expression	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
s_app_line	function
(	O
int	O
appline	int
)	O
{	O
char	O
*	O
file	pointer
=	O
NULL	O
;	O
int	O
l	long
;	O
if	O
(	O
appline	int
)	O
l	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
else	O
if	O
(	O
!	O
get_linefile_number	function
(	O
&	O
l	long
)	O
)	O
{	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
l	long
--	O
;	O
if	O
(	O
l	long
<	O
-	O
1	int
)	O
as_warn	function
(	O
_	O
(	O
"line numbers must be positive; line number %d rejected"	pointer
)	O
,	O
l	long
+	O
1	int
)	O
;	O
else	O
{	O
int	O
flags	int
=	O
0	int
;	O
int	O
length	char
=	O
0	int
;	O
if	O
(	O
!	O
appline	int
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'"'	O
)	O
file	pointer
=	O
demand_copy_string	function
(	O
&	O
length	char
)	O
;	O
if	O
(	O
file	pointer
)	O
{	O
int	O
this_flag	int
;	O
while	O
(	O
get_linefile_number	function
(	O
&	O
this_flag	int
)	O
)	O
switch	O
(	O
this_flag	int
)	O
{	O
case	O
1	int
:	O
case	O
2	int
:	O
if	O
(	O
flags	int
&&	O
flags	int
!=	O
(	O
1	int
<<	O
this_flag	int
)	O
)	O
as_warn	function
(	O
_	O
(	O
"incompatible flag %i in line directive"	pointer
)	O
,	O
this_flag	int
)	O
;	O
else	O
flags	int
|=	O
1	int
<<	O
this_flag	int
;	O
break	O
;	O
case	O
3	int
:	O
case	O
4	int
:	O
break	O
;	O
default	O
:	O
as_warn	function
(	O
_	O
(	O
"unsupported flag %i in line directive"	pointer
)	O
,	O
this_flag	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
file	pointer
=	O
0	int
;	O
}	O
}	O
if	O
(	O
appline	int
||	O
file	pointer
)	O
{	O
new_logical_line_flags	function
(	O
file	pointer
,	O
l	long
,	O
flags	int
)	O
;	O
}	O
}	O
if	O
(	O
appline	int
||	O
file	pointer
)	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
else	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_end	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
flag_mri	int
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
&&	O
*	O
input_line_pointer	pointer
!=	O
'*'	O
&&	O
*	O
input_line_pointer	pointer
!=	O
'!'	O
)	O
as_warn	function
(	O
_	O
(	O
"start address not supported"	pointer
)	O
)	O
;	O
}	O
}	O
void	O
s_err	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".err encountered"	pointer
)	O
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_errwarn	function
(	O
int	O
err	pointer
)	O
{	O
int	O
len	long
;	O
const	O
char	O
*	O
msg	pointer
=	O
(	O
err	pointer
?	O
_	O
(	O
".error directive invoked in source file"	pointer
)	O
:	O
_	O
(	O
".warning directive invoked in source file"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
is_it_end_of_statement	function
(	O
)	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
'\"'	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"%s argument must be a string"	pointer
)	O
,	O
err	pointer
?	O
".error"	pointer
:	O
".warning"	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
msg	pointer
=	O
demand_copy_C_string	function
(	O
&	O
len	long
)	O
;	O
if	O
(	O
msg	pointer
==	O
NULL	O
)	O
return	O
;	O
}	O
if	O
(	O
err	pointer
)	O
as_bad	function
(	O
"%s"	pointer
,	O
msg	pointer
)	O
;	O
else	O
as_warn	function
(	O
"%s"	pointer
,	O
msg	pointer
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_fail	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
offsetT	long
temp	union
;	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
temp	union
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
temp	union
>=	O
500	int
)	O
as_warn	function
(	O
_	O
(	O
".fail %ld encountered"	pointer
)	O
,	O
(	O
long	O
)	O
temp	union
)	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
".fail %ld encountered"	pointer
)	O
,	O
(	O
long	O
)	O
temp	union
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
s_fill	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
expressionS	struct
rep_exp	struct
;	O
long	O
size	int
=	O
1	int
;	O
long	O
fill	pointer
=	O
0	int
;	O
char	O
*	O
p	pointer
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
expression	O
(	O
&	O
rep_exp	struct
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
input_line_pointer	pointer
++	O
;	O
size	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
input_line_pointer	pointer
++	O
;	O
fill	pointer
=	O
get_absolute_expression	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
size	int
>	O
BSD_FILL_SIZE_CROCK_8	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
".fill size clamped to %d"	pointer
)	O
,	O
BSD_FILL_SIZE_CROCK_8	O
)	O
;	O
size	int
=	O
BSD_FILL_SIZE_CROCK_8	O
;	O
}	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"size negative; .fill ignored"	pointer
)	O
)	O
;	O
size	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
rep_exp	struct
.	O
X_op	enum
==	O
O_constant	int
&&	O
rep_exp	struct
.	O
X_add_number	long
<=	O
0	int
)	O
{	O
if	O
(	O
rep_exp	struct
.	O
X_add_number	long
<	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
"repeat < 0; .fill ignored"	pointer
)	O
)	O
;	O
size	int
=	O
0	int
;	O
}	O
if	O
(	O
size	int
&&	O
!	O
need_pass_2	int
)	O
{	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
if	O
(	O
rep_exp	struct
.	O
X_op	enum
!=	O
O_constant	int
)	O
as_bad	function
(	O
_	O
(	O
"non-constant fill count for absolute section"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
fill	pointer
&&	O
rep_exp	struct
.	O
X_add_number	long
!=	O
0	int
)	O
as_bad	function
(	O
_	O
(	O
"attempt to fill absolute section with non-zero value"	pointer
)	O
)	O
;	O
abs_section_offset	long
+=	O
rep_exp	struct
.	O
X_add_number	long
*	O
size	int
;	O
}	O
else	O
if	O
(	O
fill	pointer
&&	O
(	O
rep_exp	struct
.	O
X_op	enum
!=	O
O_constant	int
||	O
rep_exp	struct
.	O
X_add_number	long
!=	O
0	int
)	O
&&	O
in_bss	function
(	O
)	O
)	O
as_bad	function
(	O
_	O
(	O
"attempt to fill section `%s' with non-zero value"	pointer
)	O
,	O
segment_name	O
(	O
now_seg	pointer
)	O
)	O
;	O
if	O
(	O
rep_exp	struct
.	O
X_op	enum
==	O
O_constant	int
)	O
{	O
p	pointer
=	O
frag_var	function
(	O
rs_fill	int
,	O
(	O
int	O
)	O
size	int
,	O
(	O
int	O
)	O
size	int
,	O
(	O
relax_substateT	int
)	O
0	int
,	O
(	O
symbolS	struct
*	O
)	O
0	int
,	O
(	O
offsetT	long
)	O
rep_exp	struct
.	O
X_add_number	long
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
else	O
{	O
symbolS	struct
*	O
rep_sym	pointer
;	O
rep_sym	pointer
=	O
make_expr_symbol	function
(	O
&	O
rep_exp	struct
)	O
;	O
if	O
(	O
size	int
!=	O
1	int
)	O
{	O
expressionS	struct
size_exp	struct
;	O
size_exp	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
size_exp	struct
.	O
X_add_number	long
=	O
size	int
;	O
rep_exp	struct
.	O
X_op	enum
=	O
O_multiply	int
;	O
rep_exp	struct
.	O
X_add_symbol	pointer
=	O
rep_sym	pointer
;	O
rep_exp	struct
.	O
X_op_symbol	pointer
=	O
make_expr_symbol	function
(	O
&	O
size_exp	struct
)	O
;	O
rep_exp	struct
.	O
X_add_number	long
=	O
0	int
;	O
rep_sym	pointer
=	O
make_expr_symbol	function
(	O
&	O
rep_exp	struct
)	O
;	O
}	O
p	pointer
=	O
frag_var	function
(	O
rs_space	int
,	O
(	O
int	O
)	O
size	int
,	O
(	O
int	O
)	O
size	int
,	O
(	O
relax_substateT	int
)	O
0	int
,	O
rep_sym	pointer
,	O
(	O
offsetT	long
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
(	O
unsigned	O
int	O
)	O
size	int
)	O
;	O
md_number_to_chars	O
(	O
p	pointer
,	O
(	O
valueT	long
)	O
fill	pointer
,	O
(	O
size	int
>	O
BSD_FILL_SIZE_CROCK_4	O
?	O
BSD_FILL_SIZE_CROCK_4	O
:	O
(	O
int	O
)	O
size	int
)	O
)	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_globl	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
c	struct
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
do	O
{	O
if	O
(	O
(	O
name	pointer
=	O
read_symbol_name	function
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
symbolP	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
S_SET_EXTERNAL	function
(	O
symbolP	pointer
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
;	O
if	O
(	O
c	struct
==	O
','	O
)	O
{	O
input_line_pointer	pointer
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
c	struct
=	O
'\n'	O
;	O
}	O
free	function
(	O
name	pointer
)	O
;	O
}	O
while	O
(	O
c	struct
==	O
','	O
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
s_irp	function
(	O
int	O
irpc	int
)	O
{	O
char	O
*	O
eol	pointer
;	O
const	O
char	O
*	O
file	pointer
;	O
unsigned	O
int	O
line	int
;	O
sb	pointer
s	pointer
;	O
const	O
char	O
*	O
err	pointer
;	O
sb	pointer
out	pointer
;	O
file	pointer
=	O
as_where	function
(	O
&	O
line	int
)	O
;	O
eol	pointer
=	O
find_end_of_line	function
(	O
input_line_pointer	pointer
,	O
0	int
)	O
;	O
sb_build	function
(	O
&	O
s	pointer
,	O
eol	pointer
-	O
input_line_pointer	pointer
)	O
;	O
sb_add_buffer	function
(	O
&	O
s	pointer
,	O
input_line_pointer	pointer
,	O
eol	pointer
-	O
input_line_pointer	pointer
)	O
;	O
input_line_pointer	pointer
=	O
eol	pointer
;	O
sb_new	function
(	O
&	O
out	pointer
)	O
;	O
err	pointer
=	O
expand_irp	function
(	O
irpc	int
,	O
0	int
,	O
&	O
s	pointer
,	O
&	O
out	pointer
,	O
get_non_macro_line_sb	function
)	O
;	O
if	O
(	O
err	pointer
!=	O
NULL	O
)	O
as_bad_where	function
(	O
file	pointer
,	O
line	int
,	O
"%s"	pointer
,	O
err	pointer
)	O
;	O
sb_kill	function
(	O
&	O
s	pointer
)	O
;	O
input_scrub_include_sb	function
(	O
&	O
out	pointer
,	O
input_line_pointer	pointer
,	O
1	int
)	O
;	O
sb_kill	function
(	O
&	O
out	pointer
)	O
;	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
}	O
void	O
s_linkonce	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
enum	O
linkonce_type	enum
type	char
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
type	char
=	O
LINKONCE_DISCARD	int
;	O
if	O
(	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
{	O
char	O
*	O
s	pointer
;	O
char	O
c	struct
;	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
s	pointer
)	O
;	O
if	O
(	O
strcasecmp	function
(	O
s	pointer
,	O
"discard"	pointer
)	O
==	O
0	int
)	O
type	char
=	O
LINKONCE_DISCARD	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
s	pointer
,	O
"one_only"	pointer
)	O
==	O
0	int
)	O
type	char
=	O
LINKONCE_ONE_ONLY	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
s	pointer
,	O
"same_size"	pointer
)	O
==	O
0	int
)	O
type	char
=	O
LINKONCE_SAME_SIZE	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
s	pointer
,	O
"same_contents"	pointer
)	O
==	O
0	int
)	O
type	char
=	O
LINKONCE_SAME_CONTENTS	int
;	O
else	O
as_warn	function
(	O
_	O
(	O
"unrecognized .linkonce type `%s'"	pointer
)	O
,	O
s	pointer
)	O
;	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
}	O
{	O
flagword	int
flags	int
;	O
if	O
(	O
(	O
bfd_applicable_section_flags	function
(	O
stdoutput	pointer
)	O
&	O
SEC_LINK_ONCE	int
)	O
==	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
".linkonce is not supported for this object file format"	pointer
)	O
)	O
;	O
flags	int
=	O
bfd_section_flags	function
(	O
now_seg	pointer
)	O
;	O
flags	int
|=	O
SEC_LINK_ONCE	int
;	O
switch	O
(	O
type	char
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
LINKONCE_DISCARD	int
:	O
flags	int
|=	O
SEC_LINK_DUPLICATES_DISCARD	int
;	O
break	O
;	O
case	O
LINKONCE_ONE_ONLY	int
:	O
flags	int
|=	O
SEC_LINK_DUPLICATES_ONE_ONLY	int
;	O
break	O
;	O
case	O
LINKONCE_SAME_SIZE	int
:	O
flags	int
|=	O
SEC_LINK_DUPLICATES_SAME_SIZE	int
;	O
break	O
;	O
case	O
LINKONCE_SAME_CONTENTS	int
:	O
flags	int
|=	O
SEC_LINK_DUPLICATES_SAME_CONTENTS	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
bfd_set_section_flags	function
(	O
now_seg	pointer
,	O
flags	int
)	O
)	O
as_bad	function
(	O
_	O
(	O
"bfd_set_section_flags: %s"	pointer
)	O
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
bss_alloc	function
(	O
symbolS	struct
*	O
symbolP	pointer
,	O
addressT	long
size	int
,	O
unsigned	O
int	O
align	int
)	O
{	O
char	O
*	O
pfrag	pointer
;	O
segT	pointer
current_seg	pointer
=	O
now_seg	pointer
;	O
subsegT	int
current_subseg	int
=	O
now_subseg	int
;	O
segT	pointer
bss_seg	pointer
=	O
bss_section	pointer
;	O
subseg_set	function
(	O
bss_seg	pointer
,	O
1	int
)	O
;	O
if	O
(	O
align	int
>	O
OCTETS_PER_BYTE_POWER	int
)	O
{	O
record_alignment	function
(	O
bss_seg	pointer
,	O
align	int
)	O
;	O
frag_align	function
(	O
align	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
==	O
bss_seg	pointer
)	O
symbol_get_frag	function
(	O
symbolP	pointer
)	O
->	O
fr_symbol	pointer
=	O
NULL	O
;	O
symbol_set_frag	function
(	O
symbolP	pointer
,	O
frag_now	pointer
)	O
;	O
pfrag	pointer
=	O
frag_var	function
(	O
rs_org	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
symbolP	pointer
,	O
size	int
,	O
NULL	O
)	O
;	O
*	O
pfrag	pointer
=	O
0	int
;	O
S_SET_SIZE	O
(	O
symbolP	pointer
,	O
size	int
)	O
;	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
bss_seg	pointer
)	O
;	O
subseg_set	function
(	O
current_seg	pointer
,	O
current_subseg	int
)	O
;	O
}	O
offsetT	long
parse_align	function
(	O
int	O
align_bytes	int
)	O
{	O
expressionS	struct
exp	pointer
;	O
addressT	long
align	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
no_align	O
:	O
as_bad	function
(	O
_	O
(	O
"expected alignment after size"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
input_line_pointer	pointer
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
align	int
=	O
get_absolute_expr	function
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_absent	int
)	O
goto	O
no_align	O
;	O
if	O
(	O
!	O
exp	pointer
.	O
X_unsigned	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"alignment negative; 0 assumed"	pointer
)	O
)	O
;	O
align	int
=	O
0	int
;	O
}	O
if	O
(	O
align_bytes	int
&&	O
align	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
alignp2	int
=	O
0	int
;	O
while	O
(	O
(	O
align	int
&	O
1	int
)	O
==	O
0	int
)	O
align	int
>>=	O
1	int
,	O
++	O
alignp2	int
;	O
if	O
(	O
align	int
!=	O
1	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"alignment not a power of 2"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
align	int
=	O
alignp2	int
;	O
}	O
return	O
align	int
;	O
}	O
symbolS	struct
*	O
s_lcomm_internal	function
(	O
int	O
needs_align	int
,	O
symbolS	struct
*	O
symbolP	pointer
,	O
addressT	long
size	int
)	O
{	O
addressT	long
align	int
=	O
0	int
;	O
if	O
(	O
needs_align	int
)	O
{	O
align	int
=	O
parse_align	function
(	O
needs_align	int
-	O
1	int
)	O
;	O
if	O
(	O
align	int
==	O
(	O
addressT	long
)	O
-	O
1	int
)	O
return	O
NULL	O
;	O
}	O
else	O
TC_IMPLICIT_LCOMM_ALIGNMENT	O
(	O
size	int
,	O
align	int
)	O
;	O
bss_alloc	function
(	O
symbolP	pointer
,	O
size	int
,	O
align	int
)	O
;	O
return	O
symbolP	pointer
;	O
}	O
void	O
s_lcomm	function
(	O
int	O
needs_align	int
)	O
{	O
s_comm_internal	function
(	O
needs_align	int
,	O
s_lcomm_internal	function
)	O
;	O
}	O
void	O
s_lcomm_bytes	function
(	O
int	O
needs_align	int
)	O
{	O
s_comm_internal	function
(	O
needs_align	int
*	O
2	int
,	O
s_lcomm_internal	function
)	O
;	O
}	O
void	O
s_lsym	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	pointer
;	O
expressionS	struct
exp	pointer
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
if	O
(	O
(	O
name	pointer
=	O
read_symbol_name	function
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"expected comma after \"%s\""	pointer
)	O
,	O
name	pointer
)	O
;	O
goto	O
err_out	O
;	O
}	O
input_line_pointer	pointer
++	O
;	O
expression_and_evaluate	O
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
exp	pointer
.	O
X_op	enum
!=	O
O_constant	int
&&	O
exp	pointer
.	O
X_op	enum
!=	O
O_register	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"bad expression"	pointer
)	O
)	O
;	O
goto	O
err_out	O
;	O
}	O
symbolP	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
if	O
(	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
==	O
undefined_section	O
)	O
{	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_constant	int
?	O
absolute_section	O
:	O
reg_section	pointer
)	O
)	O
;	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
(	O
valueT	long
)	O
exp	pointer
.	O
X_add_number	long
)	O
;	O
}	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined"	pointer
)	O
,	O
name	pointer
)	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
;	O
err_out	O
:	O
ignore_rest_of_line	function
(	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
;	O
}	O
static	O
int	O
get_line_sb	function
(	O
sb	pointer
*	O
line	int
,	O
int	O
in_macro	int
)	O
{	O
char	O
*	O
eol	pointer
;	O
if	O
(	O
input_line_pointer	pointer
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
bump_line_counters	function
(	O
)	O
;	O
if	O
(	O
input_line_pointer	pointer
>=	O
buffer_limit	pointer
)	O
{	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
if	O
(	O
buffer_limit	pointer
==	O
0	int
)	O
return	O
0	int
;	O
}	O
eol	pointer
=	O
_find_end_of_line	function
(	O
input_line_pointer	pointer
,	O
flag_m68k_mri	int
,	O
0	int
,	O
in_macro	int
)	O
;	O
sb_add_buffer	function
(	O
line	int
,	O
input_line_pointer	pointer
,	O
eol	pointer
-	O
input_line_pointer	pointer
)	O
;	O
input_line_pointer	pointer
=	O
eol	pointer
;	O
return	O
*	O
input_line_pointer	pointer
++	O
;	O
}	O
static	O
size_t	long
get_non_macro_line_sb	function
(	O
sb	pointer
*	O
line	int
)	O
{	O
return	O
get_line_sb	function
(	O
line	int
,	O
0	int
)	O
;	O
}	O
static	O
size_t	long
get_macro_line_sb	function
(	O
sb	pointer
*	O
line	int
)	O
{	O
return	O
get_line_sb	function
(	O
line	int
,	O
1	int
)	O
;	O
}	O
void	O
s_macro	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
eol	pointer
;	O
const	O
char	O
*	O
file	pointer
;	O
unsigned	O
int	O
line	int
;	O
sb	pointer
s	pointer
;	O
const	O
char	O
*	O
err	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
file	pointer
=	O
as_where	function
(	O
&	O
line	int
)	O
;	O
eol	pointer
=	O
find_end_of_line	function
(	O
input_line_pointer	pointer
,	O
0	int
)	O
;	O
sb_build	function
(	O
&	O
s	pointer
,	O
eol	pointer
-	O
input_line_pointer	pointer
)	O
;	O
sb_add_buffer	function
(	O
&	O
s	pointer
,	O
input_line_pointer	pointer
,	O
eol	pointer
-	O
input_line_pointer	pointer
)	O
;	O
input_line_pointer	pointer
=	O
eol	pointer
;	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
{	O
sb	pointer
label	long
;	O
size_t	long
len	long
;	O
name	pointer
=	O
S_GET_NAME	function
(	O
line_label	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
sb_build	function
(	O
&	O
label	long
,	O
len	long
)	O
;	O
sb_add_buffer	function
(	O
&	O
label	long
,	O
name	pointer
,	O
len	long
)	O
;	O
err	pointer
=	O
define_macro	function
(	O
0	int
,	O
&	O
s	pointer
,	O
&	O
label	long
,	O
get_macro_line_sb	function
,	O
file	pointer
,	O
line	int
,	O
&	O
name	pointer
)	O
;	O
sb_kill	function
(	O
&	O
label	long
)	O
;	O
}	O
else	O
err	pointer
=	O
define_macro	function
(	O
0	int
,	O
&	O
s	pointer
,	O
NULL	O
,	O
get_macro_line_sb	function
,	O
file	pointer
,	O
line	int
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
err	pointer
!=	O
NULL	O
)	O
as_bad_where	function
(	O
file	pointer
,	O
line	int
,	O
err	pointer
,	O
name	pointer
)	O
;	O
else	O
{	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
{	O
S_SET_SEGMENT	function
(	O
line_label	pointer
,	O
absolute_section	O
)	O
;	O
S_SET_VALUE	function
(	O
line_label	pointer
,	O
0	int
)	O
;	O
symbol_set_frag	function
(	O
line_label	pointer
,	O
&	O
zero_address_frag	struct
)	O
;	O
}	O
if	O
(	O
(	O
(	O
NO_PSEUDO_DOT	int
||	O
flag_m68k_mri	int
)	O
&&	O
hash_find	function
(	O
po_hash	pointer
,	O
name	pointer
)	O
!=	O
NULL	O
)	O
||	O
(	O
!	O
flag_m68k_mri	int
&&	O
*	O
name	pointer
==	O
'.'	O
&&	O
hash_find	function
(	O
po_hash	pointer
,	O
name	pointer
+	O
1	int
)	O
!=	O
NULL	O
)	O
)	O
as_warn_where	function
(	O
file	pointer
,	O
line	int
,	O
_	O
(	O
"attempt to redefine pseudo-op `%s' ignored"	pointer
)	O
,	O
name	pointer
)	O
;	O
}	O
sb_kill	function
(	O
&	O
s	pointer
)	O
;	O
}	O
void	O
s_mexit	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
macro_nest	int
)	O
{	O
cond_exit_macro	function
(	O
macro_nest	int
)	O
;	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
}	O
else	O
as_warn	function
(	O
_	O
(	O
"ignoring macro exit outside a macro definition."	pointer
)	O
)	O
;	O
}	O
void	O
s_mri	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
on	int
;	O
on	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
on	int
!=	O
0	int
)	O
{	O
flag_mri	int
=	O
1	int
;	O
macro_mri_mode	function
(	O
1	int
)	O
;	O
}	O
else	O
{	O
flag_mri	int
=	O
0	int
;	O
macro_mri_mode	function
(	O
0	int
)	O
;	O
}	O
expr_set_precedence	function
(	O
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
do_org	function
(	O
segT	pointer
segment	pointer
,	O
expressionS	struct
*	O
exp	pointer
,	O
int	O
fill	pointer
)	O
{	O
if	O
(	O
segment	pointer
!=	O
now_seg	pointer
&&	O
segment	pointer
!=	O
absolute_section	O
&&	O
segment	pointer
!=	O
expr_section	pointer
)	O
as_bad	function
(	O
_	O
(	O
"invalid segment \"%s\""	pointer
)	O
,	O
segment_name	O
(	O
segment	pointer
)	O
)	O
;	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
if	O
(	O
fill	pointer
!=	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
"ignoring fill value in absolute section"	pointer
)	O
)	O
;	O
if	O
(	O
exp	pointer
->	O
X_op	enum
!=	O
O_constant	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"only constant offsets supported in absolute section"	pointer
)	O
)	O
;	O
exp	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
abs_section_offset	long
=	O
exp	pointer
->	O
X_add_number	long
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
symbolS	struct
*	O
sym	pointer
=	O
exp	pointer
->	O
X_add_symbol	pointer
;	O
offsetT	long
off	long
=	O
exp	pointer
->	O
X_add_number	long
*	O
OCTETS_PER_BYTE	O
;	O
if	O
(	O
fill	pointer
&&	O
in_bss	function
(	O
)	O
)	O
as_warn	function
(	O
_	O
(	O
"ignoring fill value in section `%s'"	pointer
)	O
,	O
segment_name	O
(	O
now_seg	pointer
)	O
)	O
;	O
if	O
(	O
exp	pointer
->	O
X_op	enum
!=	O
O_constant	int
&&	O
exp	pointer
->	O
X_op	enum
!=	O
O_symbol	int
)	O
{	O
sym	pointer
=	O
make_expr_symbol	function
(	O
exp	pointer
)	O
;	O
off	long
=	O
0	int
;	O
}	O
p	pointer
=	O
frag_var	function
(	O
rs_org	int
,	O
1	int
,	O
1	int
,	O
(	O
relax_substateT	int
)	O
0	int
,	O
sym	pointer
,	O
off	long
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
*	O
p	pointer
=	O
fill	pointer
;	O
}	O
}	O
void	O
s_org	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
segT	pointer
segment	pointer
;	O
expressionS	struct
exp	pointer
;	O
long	O
temp_fill	long
;	O
if	O
(	O
flag_m68k_mri	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"MRI style ORG pseudo-op not supported"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
segment	pointer
=	O
get_known_segmented_expression	function
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
input_line_pointer	pointer
++	O
;	O
temp_fill	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
}	O
else	O
temp_fill	long
=	O
0	int
;	O
if	O
(	O
!	O
need_pass_2	int
)	O
do_org	function
(	O
segment	pointer
,	O
&	O
exp	pointer
,	O
temp_fill	long
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_mri_sect	function
(	O
char	O
*	O
type	char
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	function
(	O
"MRI mode not supported for this target"	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_print	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
len	long
;	O
s	pointer
=	O
demand_copy_C_string	function
(	O
&	O
len	long
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
printf	function
(	O
"%s\n"	pointer
,	O
s	pointer
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_purgem	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
is_it_end_of_statement	function
(	O
)	O
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
do	O
{	O
char	O
*	O
name	pointer
;	O
char	O
c	struct
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
name	pointer
)	O
;	O
delete_macro	function
(	O
name	pointer
)	O
;	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
}	O
while	O
(	O
*	O
input_line_pointer	pointer
++	O
==	O
','	O
)	O
;	O
--	O
input_line_pointer	pointer
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
s_bad_end	function
(	O
int	O
endr	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
".end%c encountered without preceding %s"	pointer
)	O
,	O
endr	int
?	O
'r'	O
:	O
'm'	O
,	O
endr	int
?	O
".rept, .irp, or .irpc"	pointer
:	O
".macro"	pointer
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_rept	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
size_t	long
count	int
;	O
count	int
=	O
(	O
size_t	long
)	O
get_absolute_expression	function
(	O
)	O
;	O
do_repeat	function
(	O
count	int
,	O
"REPT"	pointer
,	O
"ENDR"	pointer
)	O
;	O
}	O
void	O
do_repeat	function
(	O
size_t	long
count	int
,	O
const	O
char	O
*	O
start	pointer
,	O
const	O
char	O
*	O
end	pointer
)	O
{	O
sb	pointer
one	struct
;	O
sb	pointer
many	struct
;	O
if	O
(	O
(	O
(	O
ssize_t	long
)	O
count	int
)	O
<	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"negative count for %s - ignored"	pointer
)	O
,	O
start	pointer
)	O
;	O
count	int
=	O
0	int
;	O
}	O
sb_new	function
(	O
&	O
one	struct
)	O
;	O
if	O
(	O
!	O
buffer_and_nest	function
(	O
start	pointer
,	O
end	pointer
,	O
&	O
one	struct
,	O
get_non_macro_line_sb	function
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"%s without %s"	pointer
)	O
,	O
start	pointer
,	O
end	pointer
)	O
;	O
return	O
;	O
}	O
sb_build	function
(	O
&	O
many	struct
,	O
count	int
*	O
one	struct
.	O
len	long
)	O
;	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
sb_add_sb	function
(	O
&	O
many	struct
,	O
&	O
one	struct
)	O
;	O
sb_kill	function
(	O
&	O
one	struct
)	O
;	O
input_scrub_include_sb	function
(	O
&	O
many	struct
,	O
input_line_pointer	pointer
,	O
1	int
)	O
;	O
sb_kill	function
(	O
&	O
many	struct
)	O
;	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
}	O
void	O
do_repeat_with_expander	function
(	O
size_t	long
count	int
,	O
const	O
char	O
*	O
start	pointer
,	O
const	O
char	O
*	O
end	pointer
,	O
const	O
char	O
*	O
expander	pointer
)	O
{	O
sb	pointer
one	struct
;	O
sb	pointer
many	struct
;	O
if	O
(	O
(	O
(	O
ssize_t	long
)	O
count	int
)	O
<	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"negative count for %s - ignored"	pointer
)	O
,	O
start	pointer
)	O
;	O
count	int
=	O
0	int
;	O
}	O
sb_new	function
(	O
&	O
one	struct
)	O
;	O
if	O
(	O
!	O
buffer_and_nest	function
(	O
start	pointer
,	O
end	pointer
,	O
&	O
one	struct
,	O
get_non_macro_line_sb	function
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"%s without %s"	pointer
)	O
,	O
start	pointer
,	O
end	pointer
)	O
;	O
return	O
;	O
}	O
sb_new	function
(	O
&	O
many	struct
)	O
;	O
if	O
(	O
expander	pointer
!=	O
NULL	O
&&	O
strstr	function
(	O
one	struct
.	O
ptr	pointer
,	O
expander	pointer
)	O
!=	O
NULL	O
)	O
{	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
{	O
int	O
len	long
;	O
char	O
*	O
sub	struct
;	O
sb	pointer
processed	struct
;	O
sb_build	function
(	O
&	O
processed	struct
,	O
one	struct
.	O
len	long
)	O
;	O
sb_add_sb	function
(	O
&	O
processed	struct
,	O
&	O
one	struct
)	O
;	O
sub	struct
=	O
strstr	function
(	O
processed	struct
.	O
ptr	pointer
,	O
expander	pointer
)	O
;	O
len	long
=	O
sprintf	function
(	O
sub	struct
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
count	int
)	O
;	O
gas_assert	O
(	O
len	long
<	O
8	int
)	O
;	O
memmove	function
(	O
sub	struct
+	O
len	long
,	O
sub	struct
+	O
8	int
,	O
processed	struct
.	O
ptr	pointer
+	O
processed	struct
.	O
len	long
-	O
(	O
sub	struct
+	O
8	int
)	O
)	O
;	O
processed	struct
.	O
len	long
-=	O
(	O
8	int
-	O
len	long
)	O
;	O
sb_add_sb	function
(	O
&	O
many	struct
,	O
&	O
processed	struct
)	O
;	O
sb_kill	function
(	O
&	O
processed	struct
)	O
;	O
}	O
}	O
else	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
sb_add_sb	function
(	O
&	O
many	struct
,	O
&	O
one	struct
)	O
;	O
sb_kill	function
(	O
&	O
one	struct
)	O
;	O
input_scrub_include_sb	function
(	O
&	O
many	struct
,	O
input_line_pointer	pointer
,	O
1	int
)	O
;	O
sb_kill	function
(	O
&	O
many	struct
)	O
;	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
}	O
void	O
end_repeat	function
(	O
int	O
extra	pointer
)	O
{	O
cond_exit_macro	function
(	O
macro_nest	int
)	O
;	O
while	O
(	O
extra	pointer
--	O
>=	O
0	int
)	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
}	O
static	O
void	O
assign_symbol	function
(	O
char	O
*	O
name	pointer
,	O
int	O
mode	pointer
)	O
{	O
symbolS	struct
*	O
symbolP	pointer
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
segT	pointer
segment	pointer
;	O
expressionS	struct
exp	pointer
;	O
segment	pointer
=	O
get_known_segmented_expression	function
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
!	O
need_pass_2	int
)	O
do_org	function
(	O
segment	pointer
,	O
&	O
exp	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
symbolP	pointer
=	O
symbol_find	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
&&	O
(	O
symbolP	pointer
=	O
md_undefined_symbol	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
symbolP	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
if	O
(	O
listing	int
&	O
LISTING_SYMBOLS	int
)	O
{	O
extern	O
struct	O
list_info_struct	O
*	O
listing_tail	pointer
;	O
fragS	struct
*	O
dummy_frag	pointer
=	O
XCNEW	O
(	O
fragS	struct
)	O
;	O
dummy_frag	pointer
->	O
line	int
=	O
listing_tail	pointer
;	O
dummy_frag	pointer
->	O
fr_symbol	pointer
=	O
symbolP	pointer
;	O
symbol_set_frag	function
(	O
symbolP	pointer
,	O
dummy_frag	pointer
)	O
;	O
}	O
}	O
if	O
(	O
S_IS_DEFINED	function
(	O
symbolP	pointer
)	O
||	O
symbol_equated_p	function
(	O
symbolP	pointer
)	O
)	O
{	O
if	O
(	O
(	O
mode	pointer
!=	O
0	int
||	O
!	O
S_IS_VOLATILE	function
(	O
symbolP	pointer
)	O
)	O
&&	O
!	O
S_CAN_BE_REDEFINED	function
(	O
symbolP	pointer
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined"	pointer
)	O
,	O
name	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
input_line_pointer	pointer
--	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
S_IS_VOLATILE	function
(	O
symbolP	pointer
)	O
)	O
symbolP	pointer
=	O
symbol_clone	function
(	O
symbolP	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
mode	pointer
==	O
0	int
)	O
S_SET_VOLATILE	function
(	O
symbolP	pointer
)	O
;	O
else	O
if	O
(	O
mode	pointer
<	O
0	int
)	O
S_SET_FORWARD_REF	function
(	O
symbolP	pointer
)	O
;	O
pseudo_set	function
(	O
symbolP	pointer
)	O
;	O
}	O
void	O
s_set	function
(	O
int	O
equiv	int
)	O
{	O
char	O
*	O
name	pointer
;	O
if	O
(	O
(	O
name	pointer
=	O
read_symbol_name	function
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"expected comma after \"%s\""	pointer
)	O
,	O
name	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
;	O
}	O
input_line_pointer	pointer
++	O
;	O
assign_symbol	function
(	O
name	pointer
,	O
equiv	int
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
void	O
s_space	function
(	O
int	O
mult	int
)	O
{	O
expressionS	struct
exp	pointer
;	O
expressionS	struct
val	int
;	O
char	O
*	O
p	pointer
=	O
0	int
;	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
int	O
bytes	int
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
if	O
(	O
flag_m68k_mri	int
&&	O
mult	int
>	O
1	int
)	O
{	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
abs_section_offset	long
+=	O
abs_section_offset	long
&	O
1	int
;	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
S_SET_VALUE	function
(	O
line_label	pointer
,	O
abs_section_offset	long
)	O
;	O
}	O
else	O
if	O
(	O
mri_common_symbol	pointer
!=	O
NULL	O
)	O
{	O
valueT	long
mri_val	long
;	O
mri_val	long
=	O
S_GET_VALUE	function
(	O
mri_common_symbol	pointer
)	O
;	O
if	O
(	O
(	O
mri_val	long
&	O
1	int
)	O
!=	O
0	int
)	O
{	O
S_SET_VALUE	function
(	O
mri_common_symbol	pointer
,	O
mri_val	long
+	O
1	int
)	O
;	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
{	O
expressionS	struct
*	O
symexp	pointer
;	O
symexp	pointer
=	O
symbol_get_value_expression	function
(	O
line_label	pointer
)	O
;	O
know	O
(	O
symexp	pointer
->	O
X_op	enum
==	O
O_symbol	int
)	O
;	O
know	O
(	O
symexp	pointer
->	O
X_add_symbol	pointer
==	O
mri_common_symbol	pointer
)	O
;	O
symexp	pointer
->	O
X_add_number	long
+=	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
do_align	function
(	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
line_label	pointer
!=	O
NULL	O
)	O
{	O
symbol_set_frag	function
(	O
line_label	pointer
,	O
frag_now	pointer
)	O
;	O
S_SET_VALUE	function
(	O
line_label	pointer
,	O
frag_now_fix	function
(	O
)	O
)	O
;	O
}	O
}	O
}	O
bytes	int
=	O
mult	int
;	O
expression	O
(	O
&	O
exp	pointer
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
++	O
input_line_pointer	pointer
;	O
expression	O
(	O
&	O
val	int
)	O
;	O
}	O
else	O
{	O
val	int
.	O
X_op	enum
=	O
O_constant	int
;	O
val	int
.	O
X_add_number	long
=	O
0	int
;	O
}	O
if	O
(	O
(	O
val	int
.	O
X_op	enum
!=	O
O_constant	int
||	O
val	int
.	O
X_add_number	long
<	O
-	O
0x80	int
||	O
val	int
.	O
X_add_number	long
>	O
0xff	int
||	O
(	O
mult	int
!=	O
0	int
&&	O
mult	int
!=	O
1	int
&&	O
val	int
.	O
X_add_number	long
!=	O
0	int
)	O
)	O
&&	O
(	O
now_seg	pointer
!=	O
absolute_section	O
&&	O
!	O
in_bss	function
(	O
)	O
)	O
)	O
{	O
resolve_expression	function
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
exp	pointer
.	O
X_op	enum
!=	O
O_constant	int
)	O
as_bad	function
(	O
_	O
(	O
"unsupported variable size or fill value"	pointer
)	O
)	O
;	O
else	O
{	O
offsetT	long
i	pointer
;	O
if	O
(	O
exp	pointer
.	O
X_add_number	long
<	O
0	int
||	O
exp	pointer
.	O
X_add_number	long
>	O
(	O
1	int
<<	O
10	int
)	O
)	O
as_bad	function
(	O
_	O
(	O
"size value for space directive too large: %lx"	pointer
)	O
,	O
(	O
long	O
)	O
exp	pointer
.	O
X_add_number	long
)	O
;	O
else	O
{	O
if	O
(	O
mult	int
==	O
0	int
)	O
mult	int
=	O
1	int
;	O
bytes	int
=	O
mult	int
*	O
exp	pointer
.	O
X_add_number	long
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
exp	pointer
.	O
X_add_number	long
;	O
i	pointer
++	O
)	O
emit_expr	function
(	O
&	O
val	int
,	O
mult	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
||	O
mri_common_symbol	pointer
!=	O
NULL	O
)	O
resolve_expression	function
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_constant	int
)	O
{	O
offsetT	long
repeat	long
;	O
repeat	long
=	O
exp	pointer
.	O
X_add_number	long
;	O
if	O
(	O
mult	int
)	O
repeat	long
*=	O
mult	int
;	O
bytes	int
=	O
repeat	long
;	O
if	O
(	O
repeat	long
<=	O
0	int
)	O
{	O
if	O
(	O
!	O
flag_mri	int
)	O
as_warn	function
(	O
_	O
(	O
".space repeat count is zero, ignored"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
repeat	long
<	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
".space repeat count is negative, ignored"	pointer
)	O
)	O
;	O
goto	O
getout	O
;	O
}	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
if	O
(	O
val	int
.	O
X_op	enum
!=	O
O_constant	int
||	O
val	int
.	O
X_add_number	long
!=	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
"ignoring fill value in absolute section"	pointer
)	O
)	O
;	O
abs_section_offset	long
+=	O
repeat	long
;	O
goto	O
getout	O
;	O
}	O
if	O
(	O
mri_common_symbol	pointer
!=	O
NULL	O
)	O
{	O
S_SET_VALUE	function
(	O
mri_common_symbol	pointer
,	O
S_GET_VALUE	function
(	O
mri_common_symbol	pointer
)	O
+	O
repeat	long
)	O
;	O
goto	O
getout	O
;	O
}	O
if	O
(	O
!	O
need_pass_2	int
)	O
p	pointer
=	O
frag_var	function
(	O
rs_fill	int
,	O
1	int
,	O
1	int
,	O
(	O
relax_substateT	int
)	O
0	int
,	O
(	O
symbolS	struct
*	O
)	O
0	int
,	O
(	O
offsetT	long
)	O
repeat	long
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"space allocation too complex in absolute section"	pointer
)	O
)	O
;	O
subseg_set	function
(	O
text_section	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
mri_common_symbol	pointer
!=	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"space allocation too complex in common section"	pointer
)	O
)	O
;	O
mri_common_symbol	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
need_pass_2	int
)	O
p	pointer
=	O
frag_var	function
(	O
rs_space	int
,	O
1	int
,	O
1	int
,	O
(	O
relax_substateT	int
)	O
0	int
,	O
make_expr_symbol	function
(	O
&	O
exp	pointer
)	O
,	O
(	O
offsetT	long
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
val	int
.	O
X_op	enum
!=	O
O_constant	int
||	O
val	int
.	O
X_add_number	long
!=	O
0	int
)	O
&&	O
in_bss	function
(	O
)	O
)	O
as_warn	function
(	O
_	O
(	O
"ignoring fill value in section `%s'"	pointer
)	O
,	O
segment_name	O
(	O
now_seg	pointer
)	O
)	O
;	O
else	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
val	int
.	O
X_add_number	long
;	O
}	O
getout	O
:	O
if	O
(	O
flag_mri	int
&&	O
(	O
bytes	int
&	O
1	int
)	O
!=	O
0	int
)	O
mri_pending_align	int
=	O
1	int
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
s_nops	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
expressionS	struct
exp	pointer
;	O
expressionS	struct
val	int
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
expression	O
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
++	O
input_line_pointer	pointer
;	O
expression	O
(	O
&	O
val	int
)	O
;	O
}	O
else	O
{	O
val	int
.	O
X_op	enum
=	O
O_constant	int
;	O
val	int
.	O
X_add_number	long
=	O
0	int
;	O
}	O
if	O
(	O
val	int
.	O
X_op	enum
==	O
O_constant	int
)	O
{	O
if	O
(	O
val	int
.	O
X_add_number	long
<	O
0	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"negative nop control byte, ignored"	pointer
)	O
)	O
;	O
val	int
.	O
X_add_number	long
=	O
0	int
;	O
}	O
if	O
(	O
!	O
need_pass_2	int
)	O
{	O
char	O
*	O
p	pointer
;	O
symbolS	struct
*	O
sym	pointer
=	O
make_expr_symbol	function
(	O
&	O
exp	pointer
)	O
;	O
p	pointer
=	O
frag_var	function
(	O
rs_space_nop	int
,	O
1	int
,	O
1	int
,	O
(	O
relax_substateT	int
)	O
0	int
,	O
sym	pointer
,	O
(	O
offsetT	long
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
*	O
p	pointer
=	O
val	int
.	O
X_add_number	long
;	O
}	O
}	O
else	O
as_bad	function
(	O
_	O
(	O
"unsupported variable nop control in .nops directive"	pointer
)	O
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_float_space	function
(	O
int	O
float_type	int
)	O
{	O
offsetT	long
count	int
;	O
int	O
flen	int
;	O
char	O
temp	union
[	O
MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT	O
]	O
;	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
count	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"missing value"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
return	O
;	O
}	O
++	O
input_line_pointer	pointer
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
input_line_pointer	pointer
[	O
0	int
]	O
==	O
'0'	O
&&	O
ISALPHA	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
)	O
)	O
input_line_pointer	pointer
+=	O
2	int
;	O
if	O
(	O
input_line_pointer	pointer
[	O
0	int
]	O
==	O
':'	O
)	O
{	O
flen	int
=	O
hex_float	function
(	O
float_type	int
,	O
temp	union
)	O
;	O
if	O
(	O
flen	int
<	O
0	int
)	O
{	O
ignore_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
const	O
char	O
*	O
err	pointer
;	O
err	pointer
=	O
md_atof	function
(	O
float_type	int
,	O
temp	union
,	O
&	O
flen	int
)	O
;	O
know	O
(	O
flen	int
<=	O
MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT	O
)	O
;	O
know	O
(	O
err	pointer
!=	O
NULL	O
||	O
flen	int
>	O
0	int
)	O
;	O
if	O
(	O
err	pointer
)	O
{	O
as_bad	function
(	O
_	O
(	O
"bad floating literal: %s"	pointer
)	O
,	O
err	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
return	O
;	O
}	O
}	O
while	O
(	O
--	O
count	int
>=	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
frag_more	function
(	O
flen	int
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
temp	union
,	O
(	O
unsigned	O
int	O
)	O
flen	int
)	O
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
s_struct	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
abs_section_offset	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
IS_ELF	int
)	O
obj_elf_section_change_hook	function
(	O
)	O
;	O
subseg_set	function
(	O
absolute_section	O
,	O
0	int
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
s_text	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
temp	union
;	O
temp	union
=	O
get_absolute_expression	function
(	O
)	O
;	O
subseg_set	function
(	O
text_section	pointer
,	O
(	O
subsegT	int
)	O
temp	union
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_weakref	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	pointer
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
symbolS	struct
*	O
symbolP2	pointer
;	O
expressionS	struct
exp	pointer
;	O
if	O
(	O
(	O
name	pointer
=	O
read_symbol_name	function
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
symbolP	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
if	O
(	O
S_IS_DEFINED	function
(	O
symbolP	pointer
)	O
||	O
symbol_equated_p	function
(	O
symbolP	pointer
)	O
)	O
{	O
if	O
(	O
!	O
S_IS_VOLATILE	function
(	O
symbolP	pointer
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"symbol `%s' is already defined"	pointer
)	O
,	O
name	pointer
)	O
;	O
goto	O
err_out	O
;	O
}	O
symbolP	pointer
=	O
symbol_clone	function
(	O
symbolP	pointer
,	O
1	int
)	O
;	O
S_CLEAR_VOLATILE	function
(	O
symbolP	pointer
)	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"expected comma after \"%s\""	pointer
)	O
,	O
name	pointer
)	O
;	O
goto	O
err_out	O
;	O
}	O
input_line_pointer	pointer
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
(	O
name	pointer
=	O
read_symbol_name	function
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
(	O
symbolP2	pointer
=	O
symbol_find_noref	function
(	O
name	pointer
,	O
1	int
)	O
)	O
==	O
NULL	O
&&	O
(	O
symbolP2	pointer
=	O
md_undefined_symbol	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
symbolP2	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
S_SET_WEAKREFD	function
(	O
symbolP2	pointer
)	O
;	O
}	O
else	O
{	O
symbolS	struct
*	O
symp	pointer
=	O
symbolP2	pointer
;	O
while	O
(	O
S_IS_WEAKREFR	function
(	O
symp	pointer
)	O
&&	O
symp	pointer
!=	O
symbolP	pointer
)	O
{	O
expressionS	struct
*	O
expP	pointer
=	O
symbol_get_value_expression	function
(	O
symp	pointer
)	O
;	O
gas_assert	O
(	O
expP	pointer
->	O
X_op	enum
==	O
O_symbol	int
&&	O
expP	pointer
->	O
X_add_number	long
==	O
0	int
)	O
;	O
symp	pointer
=	O
expP	pointer
->	O
X_add_symbol	pointer
;	O
}	O
if	O
(	O
symp	pointer
==	O
symbolP	pointer
)	O
{	O
char	O
*	O
loop	pointer
;	O
loop	pointer
=	O
concat	function
(	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
,	O
" => "	pointer
,	O
S_GET_NAME	function
(	O
symbolP2	pointer
)	O
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
symp	pointer
=	O
symbolP2	pointer
;	O
while	O
(	O
symp	pointer
!=	O
symbolP	pointer
)	O
{	O
char	O
*	O
old_loop	pointer
=	O
loop	pointer
;	O
symp	pointer
=	O
symbol_get_value_expression	function
(	O
symp	pointer
)	O
->	O
X_add_symbol	pointer
;	O
loop	pointer
=	O
concat	function
(	O
loop	pointer
,	O
" => "	pointer
,	O
S_GET_NAME	function
(	O
symp	pointer
)	O
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
free	function
(	O
old_loop	pointer
)	O
;	O
}	O
as_bad	function
(	O
_	O
(	O
"%s: would close weakref loop: %s"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
,	O
loop	pointer
)	O
;	O
free	function
(	O
loop	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
}	O
memset	function
(	O
&	O
exp	pointer
,	O
0	int
,	O
sizeof	O
(	O
exp	pointer
)	O
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
symbolP2	pointer
;	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
undefined_section	O
)	O
;	O
symbol_set_value_expression	function
(	O
symbolP	pointer
,	O
&	O
exp	pointer
)	O
;	O
symbol_set_frag	function
(	O
symbolP	pointer
,	O
&	O
zero_address_frag	struct
)	O
;	O
S_SET_WEAKREFR	function
(	O
symbolP	pointer
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
;	O
err_out	O
:	O
ignore_rest_of_line	function
(	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
;	O
}	O
void	O
demand_empty_rest_of_line	function
(	O
void	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
input_line_pointer	pointer
++	O
;	O
else	O
{	O
if	O
(	O
ISPRINT	O
(	O
*	O
input_line_pointer	pointer
)	O
)	O
as_bad	function
(	O
_	O
(	O
"junk at end of line, first unrecognized character is `%c'"	pointer
)	O
,	O
*	O
input_line_pointer	pointer
)	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
"junk at end of line, first unrecognized character valued 0x%x"	pointer
)	O
,	O
*	O
input_line_pointer	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
know	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	pointer
[	O
-	O
1	int
]	O
]	O
)	O
;	O
}	O
void	O
ignore_rest_of_line	function
(	O
void	O
)	O
{	O
while	O
(	O
input_line_pointer	pointer
<	O
buffer_limit	pointer
&&	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
input_line_pointer	pointer
++	O
;	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
input_line_pointer	pointer
<=	O
buffer_limit	pointer
)	O
know	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	pointer
[	O
-	O
1	int
]	O
]	O
)	O
;	O
}	O
static	O
void	O
set_zero_frag	function
(	O
symbolS	struct
*	O
symbolP	pointer
)	O
{	O
if	O
(	O
symbol_get_frag	function
(	O
symbolP	pointer
)	O
->	O
fr_type	enum
!=	O
rs_dummy	int
)	O
symbol_set_frag	function
(	O
symbolP	pointer
,	O
&	O
zero_address_frag	struct
)	O
;	O
}	O
void	O
pseudo_set	function
(	O
symbolS	struct
*	O
symbolP	pointer
)	O
{	O
expressionS	struct
exp	pointer
;	O
segT	pointer
seg	pointer
;	O
know	O
(	O
symbolP	pointer
)	O
;	O
if	O
(	O
!	O
S_IS_FORWARD_REF	function
(	O
symbolP	pointer
)	O
)	O
(	O
void	O
)	O
expression	O
(	O
&	O
exp	pointer
)	O
;	O
else	O
(	O
void	O
)	O
deferred_expression	O
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_illegal	int
)	O
as_bad	function
(	O
_	O
(	O
"illegal expression"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_absent	int
)	O
as_bad	function
(	O
_	O
(	O
"missing expression"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_big	int
)	O
{	O
if	O
(	O
exp	pointer
.	O
X_add_number	long
>	O
0	int
)	O
as_bad	function
(	O
_	O
(	O
"bignum invalid"	pointer
)	O
)	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
"floating point number invalid"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_subtract	int
&&	O
!	O
S_IS_FORWARD_REF	function
(	O
symbolP	pointer
)	O
&&	O
SEG_NORMAL	O
(	O
S_GET_SEGMENT	function
(	O
exp	pointer
.	O
X_add_symbol	pointer
)	O
)	O
&&	O
(	O
symbol_get_frag	function
(	O
exp	pointer
.	O
X_add_symbol	pointer
)	O
==	O
symbol_get_frag	function
(	O
exp	pointer
.	O
X_op_symbol	pointer
)	O
)	O
)	O
{	O
exp	pointer
.	O
X_op	enum
=	O
O_constant	int
;	O
exp	pointer
.	O
X_add_number	long
=	O
(	O
S_GET_VALUE	function
(	O
exp	pointer
.	O
X_add_symbol	pointer
)	O
-	O
S_GET_VALUE	function
(	O
exp	pointer
.	O
X_op_symbol	pointer
)	O
)	O
;	O
}	O
if	O
(	O
symbol_section_p	function
(	O
symbolP	pointer
)	O
)	O
{	O
as_bad	function
(	O
"attempt to set value of section symbol"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
exp	pointer
.	O
X_op	enum
)	O
{	O
case	O
O_illegal	int
:	O
case	O
O_absent	int
:	O
case	O
O_big	int
:	O
exp	pointer
.	O
X_add_number	long
=	O
0	int
;	O
case	O
O_constant	int
:	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
absolute_section	O
)	O
;	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
(	O
valueT	long
)	O
exp	pointer
.	O
X_add_number	long
)	O
;	O
set_zero_frag	function
(	O
symbolP	pointer
)	O
;	O
break	O
;	O
case	O
O_register	int
:	O
if	O
(	O
S_IS_EXTERNAL	function
(	O
symbolP	pointer
)	O
)	O
{	O
as_bad	function
(	O
"can't equate global symbol `%s' with register name"	pointer
,	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
)	O
;	O
return	O
;	O
}	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
reg_section	pointer
)	O
;	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
(	O
valueT	long
)	O
exp	pointer
.	O
X_add_number	long
)	O
;	O
set_zero_frag	function
(	O
symbolP	pointer
)	O
;	O
symbol_get_value_expression	function
(	O
symbolP	pointer
)	O
->	O
X_op	enum
=	O
O_register	int
;	O
break	O
;	O
case	O
O_symbol	int
:	O
seg	pointer
=	O
S_GET_SEGMENT	function
(	O
exp	pointer
.	O
X_add_symbol	pointer
)	O
;	O
if	O
(	O
symbolP	pointer
==	O
exp	pointer
.	O
X_add_symbol	pointer
&&	O
(	O
seg	pointer
!=	O
undefined_section	O
||	O
!	O
symbol_constant_p	function
(	O
symbolP	pointer
)	O
)	O
)	O
{	O
*	O
symbol_X_add_number	function
(	O
symbolP	pointer
)	O
+=	O
exp	pointer
.	O
X_add_number	long
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
S_IS_FORWARD_REF	function
(	O
symbolP	pointer
)	O
&&	O
seg	pointer
!=	O
undefined_section	O
)	O
{	O
symbolS	struct
*	O
s	pointer
=	O
exp	pointer
.	O
X_add_symbol	pointer
;	O
if	O
(	O
S_IS_COMMON	function
(	O
s	pointer
)	O
)	O
as_bad	function
(	O
_	O
(	O
"`%s' can't be equated to common symbol `%s'"	pointer
)	O
,	O
S_GET_NAME	function
(	O
symbolP	pointer
)	O
,	O
S_GET_NAME	function
(	O
s	pointer
)	O
)	O
;	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
seg	pointer
)	O
;	O
S_SET_VALUE	function
(	O
symbolP	pointer
,	O
exp	pointer
.	O
X_add_number	long
+	O
S_GET_VALUE	function
(	O
s	pointer
)	O
)	O
;	O
symbol_set_frag	function
(	O
symbolP	pointer
,	O
symbol_get_frag	function
(	O
s	pointer
)	O
)	O
;	O
copy_symbol_attributes	function
(	O
symbolP	pointer
,	O
s	pointer
)	O
;	O
break	O
;	O
}	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
undefined_section	O
)	O
;	O
symbol_set_value_expression	function
(	O
symbolP	pointer
,	O
&	O
exp	pointer
)	O
;	O
copy_symbol_attributes	function
(	O
symbolP	pointer
,	O
exp	pointer
.	O
X_add_symbol	pointer
)	O
;	O
set_zero_frag	function
(	O
symbolP	pointer
)	O
;	O
break	O
;	O
default	O
:	O
S_SET_SEGMENT	function
(	O
symbolP	pointer
,	O
expr_section	pointer
)	O
;	O
symbol_set_value_expression	function
(	O
symbolP	pointer
,	O
&	O
exp	pointer
)	O
;	O
set_zero_frag	function
(	O
symbolP	pointer
)	O
;	O
break	O
;	O
}	O
}	O
void	O
do_parse_cons_expression	function
(	O
expressionS	struct
*	O
exp	pointer
,	O
int	O
nbytes	long
ATTRIBUTE_UNUSED	O
)	O
{	O
(	O
void	O
)	O
TC_PARSE_CONS_EXPRESSION	O
(	O
exp	pointer
,	O
nbytes	long
)	O
;	O
}	O
static	O
void	O
cons_worker	function
(	O
int	O
nbytes	long
,	O
int	O
rva	int
)	O
{	O
int	O
c	struct
;	O
expressionS	struct
exp	pointer
;	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
if	O
(	O
is_it_end_of_statement	function
(	O
)	O
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
nbytes	long
==	O
0	int
)	O
nbytes	long
=	O
TC_ADDRESS_BYTES	O
(	O
)	O
;	O
md_cons_align	O
(	O
nbytes	long
)	O
;	O
c	struct
=	O
0	int
;	O
do	O
{	O
TC_PARSE_CONS_RETURN_TYPE	O
ret	pointer
=	O
TC_PARSE_CONS_RETURN_NONE	O
;	O
{	O
ret	pointer
=	O
TC_PARSE_CONS_EXPRESSION	O
(	O
&	O
exp	pointer
,	O
(	O
unsigned	O
int	O
)	O
nbytes	long
)	O
;	O
}	O
if	O
(	O
rva	int
)	O
{	O
if	O
(	O
exp	pointer
.	O
X_op	enum
==	O
O_symbol	int
)	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol_rva	int
;	O
else	O
as_fatal	function
(	O
_	O
(	O
"rva without symbol"	pointer
)	O
)	O
;	O
}	O
emit_expr_with_reloc	function
(	O
&	O
exp	pointer
,	O
(	O
unsigned	O
int	O
)	O
nbytes	long
,	O
ret	pointer
)	O
;	O
++	O
c	struct
;	O
}	O
while	O
(	O
*	O
input_line_pointer	pointer
++	O
==	O
','	O
)	O
;	O
if	O
(	O
flag_mri	int
&&	O
nbytes	long
==	O
1	int
&&	O
(	O
c	struct
&	O
1	int
)	O
!=	O
0	int
)	O
mri_pending_align	int
=	O
1	int
;	O
input_line_pointer	pointer
--	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
cons	function
(	O
int	O
size	int
)	O
{	O
cons_worker	function
(	O
size	int
,	O
0	int
)	O
;	O
}	O
void	O
s_rva	function
(	O
int	O
size	int
)	O
{	O
cons_worker	function
(	O
size	int
,	O
1	int
)	O
;	O
}	O
static	O
void	O
s_reloc	function
(	O
int	O
ignore	int
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
expressionS	struct
exp	pointer
;	O
char	O
*	O
r_name	pointer
;	O
int	O
c	struct
;	O
struct	O
reloc_list	struct
*	O
reloc	enum
;	O
struct	O
_bfd_rel	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
bfd_reloc_code_real_type	enum
code	int
;	O
}	O
;	O
static	O
struct	O
_bfd_rel	struct
bfd_relocs	array
[	O
]	O
=	O
{	O
{	O
"NONE"	pointer
,	O
BFD_RELOC_NONE	int
}	O
,	O
{	O
"8"	pointer
,	O
BFD_RELOC_8	int
}	O
,	O
{	O
"16"	pointer
,	O
BFD_RELOC_16	int
}	O
,	O
{	O
"32"	pointer
,	O
BFD_RELOC_32	int
}	O
,	O
{	O
"64"	pointer
,	O
BFD_RELOC_64	int
}	O
}	O
;	O
reloc	enum
=	O
XNEW	O
(	O
struct	O
reloc_list	struct
)	O
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
expression	O
(	O
&	O
exp	pointer
)	O
;	O
switch	O
(	O
exp	pointer
.	O
X_op	enum
)	O
{	O
case	O
O_illegal	int
:	O
case	O
O_absent	int
:	O
case	O
O_big	int
:	O
case	O
O_register	int
:	O
as_bad	function
(	O
_	O
(	O
"missing or bad offset expression"	pointer
)	O
)	O
;	O
goto	O
err_out	O
;	O
case	O
O_constant	int
:	O
exp	pointer
.	O
X_add_symbol	pointer
=	O
section_symbol	function
(	O
now_seg	pointer
)	O
;	O
exp	pointer
.	O
X_op	enum
=	O
O_symbol	int
;	O
case	O
O_symbol	int
:	O
if	O
(	O
exp	pointer
.	O
X_add_number	long
==	O
0	int
)	O
{	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
offset_sym	pointer
=	O
exp	pointer
.	O
X_add_symbol	pointer
;	O
break	O
;	O
}	O
default	O
:	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
offset_sym	pointer
=	O
make_expr_symbol	function
(	O
&	O
exp	pointer
)	O
;	O
break	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"missing reloc type"	pointer
)	O
)	O
;	O
goto	O
err_out	O
;	O
}	O
++	O
input_line_pointer	pointer
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
r_name	pointer
)	O
;	O
if	O
(	O
strncasecmp	function
(	O
r_name	pointer
,	O
"BFD_RELOC_"	pointer
,	O
10	int
)	O
==	O
0	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
howto	pointer
=	O
NULL	O
,	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
bfd_relocs	array
)	O
;	O
i	pointer
++	O
)	O
if	O
(	O
strcasecmp	function
(	O
r_name	pointer
+	O
10	int
,	O
bfd_relocs	array
[	O
i	pointer
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
{	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
stdoutput	pointer
,	O
bfd_relocs	array
[	O
i	pointer
]	O
.	O
code	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
howto	pointer
=	O
bfd_reloc_name_lookup	function
(	O
stdoutput	pointer
,	O
r_name	pointer
)	O
;	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
if	O
(	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
howto	pointer
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"unrecognized reloc type"	pointer
)	O
)	O
;	O
goto	O
err_out	O
;	O
}	O
exp	pointer
.	O
X_op	enum
=	O
O_absent	int
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
++	O
input_line_pointer	pointer
;	O
expression	O
(	O
&	O
exp	pointer
)	O
;	O
}	O
switch	O
(	O
exp	pointer
.	O
X_op	enum
)	O
{	O
case	O
O_illegal	int
:	O
case	O
O_big	int
:	O
case	O
O_register	int
:	O
as_bad	function
(	O
_	O
(	O
"bad reloc expression"	pointer
)	O
)	O
;	O
err_out	O
:	O
ignore_rest_of_line	function
(	O
)	O
;	O
free	function
(	O
reloc	enum
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
return	O
;	O
case	O
O_absent	int
:	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
sym	pointer
=	O
NULL	O
;	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
addend	long
=	O
0	int
;	O
break	O
;	O
case	O
O_constant	int
:	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
sym	pointer
=	O
NULL	O
;	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
addend	long
=	O
exp	pointer
.	O
X_add_number	long
;	O
break	O
;	O
case	O
O_symbol	int
:	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
sym	pointer
=	O
exp	pointer
.	O
X_add_symbol	pointer
;	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
addend	long
=	O
exp	pointer
.	O
X_add_number	long
;	O
break	O
;	O
default	O
:	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
sym	pointer
=	O
make_expr_symbol	function
(	O
&	O
exp	pointer
)	O
;	O
reloc	enum
->	O
u	union
.	O
a	pointer
.	O
addend	long
=	O
0	int
;	O
break	O
;	O
}	O
reloc	enum
->	O
file	pointer
=	O
as_where	function
(	O
&	O
reloc	enum
->	O
line	int
)	O
;	O
reloc	enum
->	O
next	pointer
=	O
reloc_list	struct
;	O
reloc_list	struct
=	O
reloc	enum
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
flag_mri	int
)	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
void	O
emit_expr	function
(	O
expressionS	struct
*	O
exp	pointer
,	O
unsigned	O
int	O
nbytes	long
)	O
{	O
emit_expr_with_reloc	function
(	O
exp	pointer
,	O
nbytes	long
,	O
TC_PARSE_CONS_RETURN_NONE	O
)	O
;	O
}	O
void	O
emit_expr_with_reloc	function
(	O
expressionS	struct
*	O
exp	pointer
,	O
unsigned	O
int	O
nbytes	long
,	O
TC_PARSE_CONS_RETURN_TYPE	O
reloc	enum
)	O
{	O
operatorT	enum
op	int
;	O
char	O
*	O
p	pointer
;	O
valueT	long
extra_digit	long
=	O
0	int
;	O
if	O
(	O
need_pass_2	int
)	O
return	O
;	O
frag_grow	function
(	O
nbytes	long
)	O
;	O
dot_value	long
=	O
frag_now_fix	function
(	O
)	O
;	O
dot_frag	pointer
=	O
frag_now	pointer
;	O
{	O
static	O
int	O
dwarf_line	int
=	O
-	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
segment_name	O
(	O
now_seg	pointer
)	O
,	O
".line"	pointer
)	O
!=	O
0	int
)	O
dwarf_line	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
dwarf_line	int
>=	O
0	int
&&	O
nbytes	long
==	O
2	int
&&	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
&&	O
(	O
exp	pointer
->	O
X_add_number	long
==	O
-	O
1	int
||	O
exp	pointer
->	O
X_add_number	long
==	O
0xffff	int
)	O
)	O
listing_source_line	function
(	O
(	O
unsigned	O
int	O
)	O
dwarf_line	int
)	O
;	O
else	O
if	O
(	O
nbytes	long
==	O
4	int
&&	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
&&	O
exp	pointer
->	O
X_add_number	long
>=	O
0	int
)	O
dwarf_line	int
=	O
exp	pointer
->	O
X_add_number	long
;	O
else	O
dwarf_line	int
=	O
-	O
1	int
;	O
}	O
{	O
static	O
int	O
dwarf_file	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
segment_name	O
(	O
now_seg	pointer
)	O
,	O
".debug"	pointer
)	O
!=	O
0	int
)	O
dwarf_file	int
=	O
0	int
;	O
else	O
if	O
(	O
dwarf_file	int
==	O
0	int
&&	O
nbytes	long
==	O
2	int
&&	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
&&	O
exp	pointer
->	O
X_add_number	long
==	O
0x11	int
)	O
dwarf_file	int
=	O
1	int
;	O
else	O
if	O
(	O
dwarf_file	int
==	O
1	int
&&	O
nbytes	long
==	O
2	int
&&	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
&&	O
exp	pointer
->	O
X_add_number	long
==	O
0x12	int
)	O
dwarf_file	int
=	O
2	int
;	O
else	O
if	O
(	O
dwarf_file	int
==	O
2	int
&&	O
nbytes	long
==	O
4	int
)	O
dwarf_file	int
=	O
3	int
;	O
else	O
if	O
(	O
dwarf_file	int
==	O
3	int
&&	O
nbytes	long
==	O
2	int
&&	O
exp	pointer
->	O
X_op	enum
==	O
O_constant	int
&&	O
exp	pointer
->	O
X_add_number	long
==	O
0x38	int
)	O
dwarf_file	int
=	O
4	int
;	O
else	O
dwarf_file	int
=	O
0	int
;	O
if	O
(	O
dwarf_file	int
==	O
4	int
)	O
dwarf_file_string	int
=	O
1	int
;	O
else	O
dwarf_file_string	int
=	O
0	int
;	O
}	O
if	O
(	O
check_eh_frame	function
(	O
exp	pointer
,	O
&	O
nbytes	long
)	O
)	O
return	O
;	O
op	int
=	O
exp	pointer
->	O
X_op	enum
;	O
if	O
(	O
op	int
==	O
O_uminus	int
&&	O
exp	pointer
->	O
X_add_number	long
==	O
0	int
&&	O
symbol_get_value_expression	function
(	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
->	O
X_op	enum
==	O
O_big	int
&&	O
symbol_get_value_expression	function
(	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
->	O
X_add_number	long
>	O
0	int
)	O
{	O
int	O
i	pointer
;	O
unsigned	O
long	O
carry	long
;	O
exp	pointer
=	O
symbol_get_value_expression	function
(	O
exp	pointer
->	O
X_add_symbol	pointer
)	O
;	O
carry	long
=	O
1	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
exp	pointer
->	O
X_add_number	long
;	O
i	pointer
++	O
)	O
{	O
unsigned	O
long	O
next	pointer
;	O
next	pointer
=	O
(	O
(	O
(	O
~	O
(	O
generic_bignum	array
[	O
i	pointer
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
&	O
LITTLENUM_MASK	O
)	O
+	O
carry	long
)	O
;	O
generic_bignum	array
[	O
i	pointer
]	O
=	O
next	pointer
&	O
LITTLENUM_MASK	O
;	O
carry	long
=	O
next	pointer
>>	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
}	O
extra_digit	long
=	O
(	O
valueT	long
)	O
-	O
1	int
;	O
op	int
=	O
O_big	int
;	O
}	O
if	O
(	O
op	int
==	O
O_absent	int
||	O
op	int
==	O
O_illegal	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"zero assumed for missing expression"	pointer
)	O
)	O
;	O
exp	pointer
->	O
X_add_number	long
=	O
0	int
;	O
op	int
=	O
O_constant	int
;	O
}	O
else	O
if	O
(	O
op	int
==	O
O_big	int
&&	O
exp	pointer
->	O
X_add_number	long
<=	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"floating point number invalid"	pointer
)	O
)	O
;	O
exp	pointer
->	O
X_add_number	long
=	O
0	int
;	O
op	int
=	O
O_constant	int
;	O
}	O
else	O
if	O
(	O
op	int
==	O
O_register	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"register value used as expression"	pointer
)	O
)	O
;	O
op	int
=	O
O_constant	int
;	O
}	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
if	O
(	O
op	int
!=	O
O_constant	int
||	O
exp	pointer
->	O
X_add_number	long
!=	O
0	int
)	O
as_bad	function
(	O
_	O
(	O
"attempt to store value in absolute section"	pointer
)	O
)	O
;	O
abs_section_offset	long
+=	O
nbytes	long
;	O
return	O
;	O
}	O
if	O
(	O
(	O
op	int
!=	O
O_constant	int
||	O
exp	pointer
->	O
X_add_number	long
!=	O
0	int
)	O
&&	O
in_bss	function
(	O
)	O
)	O
as_bad	function
(	O
_	O
(	O
"attempt to store non-zero value in section `%s'"	pointer
)	O
,	O
segment_name	O
(	O
now_seg	pointer
)	O
)	O
;	O
p	pointer
=	O
frag_more	function
(	O
(	O
int	O
)	O
nbytes	long
)	O
;	O
if	O
(	O
reloc	enum
!=	O
TC_PARSE_CONS_RETURN_NONE	O
)	O
{	O
emit_expr_fix	function
(	O
exp	pointer
,	O
nbytes	long
,	O
frag_now	pointer
,	O
p	pointer
,	O
reloc	enum
)	O
;	O
return	O
;	O
}	O
if	O
(	O
op	int
==	O
O_constant	int
&&	O
nbytes	long
>	O
sizeof	O
(	O
valueT	long
)	O
)	O
{	O
extra_digit	long
=	O
exp	pointer
->	O
X_unsigned	int
?	O
0	int
:	O
-	O
1	int
;	O
convert_to_bignum	function
(	O
exp	pointer
,	O
!	O
exp	pointer
->	O
X_unsigned	int
)	O
;	O
op	int
=	O
O_big	int
;	O
}	O
if	O
(	O
op	int
==	O
O_constant	int
)	O
{	O
valueT	long
get	pointer
;	O
valueT	long
use	long
;	O
valueT	long
mask	int
;	O
valueT	long
hibit	long
;	O
valueT	long
unmask	long
;	O
if	O
(	O
nbytes	long
>=	O
sizeof	O
(	O
valueT	long
)	O
)	O
{	O
mask	int
=	O
0	int
;	O
if	O
(	O
nbytes	long
>	O
sizeof	O
(	O
valueT	long
)	O
)	O
hibit	long
=	O
0	int
;	O
else	O
hibit	long
=	O
(	O
valueT	long
)	O
1	int
<<	O
(	O
nbytes	long
*	O
BITS_PER_CHAR	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
mask	int
=	O
~	O
(	O
valueT	long
)	O
0	int
<<	O
(	O
BITS_PER_CHAR	O
*	O
nbytes	long
)	O
;	O
hibit	long
=	O
(	O
valueT	long
)	O
1	int
<<	O
(	O
nbytes	long
*	O
BITS_PER_CHAR	O
-	O
1	int
)	O
;	O
}	O
unmask	long
=	O
~	O
mask	int
;	O
get	pointer
=	O
exp	pointer
->	O
X_add_number	long
;	O
use	long
=	O
get	pointer
&	O
unmask	long
;	O
if	O
(	O
(	O
get	pointer
&	O
mask	int
)	O
!=	O
0	int
&&	O
(	O
(	O
get	pointer
&	O
mask	int
)	O
!=	O
mask	int
||	O
(	O
get	pointer
&	O
hibit	long
)	O
==	O
0	int
)	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"value 0x%lx truncated to 0x%lx"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
get	pointer
,	O
(	O
unsigned	O
long	O
)	O
use	long
)	O
;	O
}	O
md_number_to_chars	O
(	O
p	pointer
,	O
use	long
,	O
(	O
int	O
)	O
nbytes	long
)	O
;	O
}	O
else	O
if	O
(	O
op	int
==	O
O_big	int
)	O
{	O
unsigned	O
int	O
size	int
;	O
LITTLENUM_TYPE	short
*	O
nums	pointer
;	O
size	int
=	O
exp	pointer
->	O
X_add_number	long
*	O
CHARS_PER_LITTLENUM	O
;	O
if	O
(	O
nbytes	long
<	O
size	int
)	O
{	O
int	O
i	pointer
=	O
nbytes	long
/	O
CHARS_PER_LITTLENUM	O
;	O
if	O
(	O
i	pointer
!=	O
0	int
)	O
{	O
LITTLENUM_TYPE	short
sign	char
=	O
0	int
;	O
if	O
(	O
(	O
generic_bignum	array
[	O
--	O
i	pointer
]	O
&	O
(	O
1	int
<<	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
-	O
1	int
)	O
)	O
)	O
!=	O
0	int
)	O
sign	char
=	O
~	O
(	O
LITTLENUM_TYPE	short
)	O
0	int
;	O
while	O
(	O
++	O
i	pointer
<	O
exp	pointer
->	O
X_add_number	long
)	O
if	O
(	O
generic_bignum	array
[	O
i	pointer
]	O
!=	O
sign	char
)	O
break	O
;	O
}	O
else	O
if	O
(	O
nbytes	long
==	O
1	int
)	O
{	O
LITTLENUM_TYPE	short
sign	char
=	O
(	O
generic_bignum	array
[	O
0	int
]	O
&	O
(	O
1	int
<<	O
7	int
)	O
)	O
?	O
-	O
1	int
:	O
0	int
;	O
LITTLENUM_TYPE	short
himask	short
=	O
LITTLENUM_MASK	O
&	O
~	O
0xFF	int
;	O
if	O
(	O
(	O
generic_bignum	array
[	O
0	int
]	O
&	O
himask	short
)	O
==	O
(	O
sign	char
&	O
himask	short
)	O
)	O
{	O
while	O
(	O
++	O
i	pointer
<	O
exp	pointer
->	O
X_add_number	long
)	O
if	O
(	O
generic_bignum	array
[	O
i	pointer
]	O
!=	O
sign	char
)	O
break	O
;	O
}	O
}	O
if	O
(	O
i	pointer
<	O
exp	pointer
->	O
X_add_number	long
)	O
as_warn	function
(	O
ngettext	function
(	O
"bignum truncated to %d byte"	pointer
,	O
"bignum truncated to %d bytes"	pointer
,	O
nbytes	long
)	O
,	O
nbytes	long
)	O
;	O
size	int
=	O
nbytes	long
;	O
}	O
if	O
(	O
nbytes	long
==	O
1	int
)	O
{	O
md_number_to_chars	O
(	O
p	pointer
,	O
(	O
valueT	long
)	O
generic_bignum	array
[	O
0	int
]	O
,	O
1	int
)	O
;	O
return	O
;	O
}	O
know	O
(	O
nbytes	long
%	O
CHARS_PER_LITTLENUM	O
==	O
0	int
)	O
;	O
if	O
(	O
target_big_endian	int
)	O
{	O
while	O
(	O
nbytes	long
>	O
size	int
)	O
{	O
md_number_to_chars	O
(	O
p	pointer
,	O
extra_digit	long
,	O
CHARS_PER_LITTLENUM	O
)	O
;	O
nbytes	long
-=	O
CHARS_PER_LITTLENUM	O
;	O
p	pointer
+=	O
CHARS_PER_LITTLENUM	O
;	O
}	O
nums	pointer
=	O
generic_bignum	array
+	O
size	int
/	O
CHARS_PER_LITTLENUM	O
;	O
while	O
(	O
size	int
>=	O
CHARS_PER_LITTLENUM	O
)	O
{	O
--	O
nums	pointer
;	O
md_number_to_chars	O
(	O
p	pointer
,	O
(	O
valueT	long
)	O
*	O
nums	pointer
,	O
CHARS_PER_LITTLENUM	O
)	O
;	O
size	int
-=	O
CHARS_PER_LITTLENUM	O
;	O
p	pointer
+=	O
CHARS_PER_LITTLENUM	O
;	O
}	O
}	O
else	O
{	O
nums	pointer
=	O
generic_bignum	array
;	O
while	O
(	O
size	int
>=	O
CHARS_PER_LITTLENUM	O
)	O
{	O
md_number_to_chars	O
(	O
p	pointer
,	O
(	O
valueT	long
)	O
*	O
nums	pointer
,	O
CHARS_PER_LITTLENUM	O
)	O
;	O
++	O
nums	pointer
;	O
size	int
-=	O
CHARS_PER_LITTLENUM	O
;	O
p	pointer
+=	O
CHARS_PER_LITTLENUM	O
;	O
nbytes	long
-=	O
CHARS_PER_LITTLENUM	O
;	O
}	O
while	O
(	O
nbytes	long
>=	O
CHARS_PER_LITTLENUM	O
)	O
{	O
md_number_to_chars	O
(	O
p	pointer
,	O
extra_digit	long
,	O
CHARS_PER_LITTLENUM	O
)	O
;	O
nbytes	long
-=	O
CHARS_PER_LITTLENUM	O
;	O
p	pointer
+=	O
CHARS_PER_LITTLENUM	O
;	O
}	O
}	O
}	O
else	O
emit_expr_fix	function
(	O
exp	pointer
,	O
nbytes	long
,	O
frag_now	pointer
,	O
p	pointer
,	O
TC_PARSE_CONS_RETURN_NONE	O
)	O
;	O
}	O
void	O
emit_expr_fix	function
(	O
expressionS	struct
*	O
exp	pointer
,	O
unsigned	O
int	O
nbytes	long
,	O
fragS	struct
*	O
frag	struct
,	O
char	O
*	O
p	pointer
,	O
TC_PARSE_CONS_RETURN_TYPE	O
r	struct
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
offset	long
=	O
0	int
;	O
unsigned	O
int	O
size	int
=	O
nbytes	long
;	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
size	int
)	O
;	O
TC_CONS_FIX_NEW	O
(	O
frag	struct
,	O
p	pointer
-	O
frag	struct
->	O
fr_literal	array
+	O
offset	long
,	O
size	int
,	O
exp	pointer
,	O
r	struct
)	O
;	O
}	O
static	O
int	O
hex_float	function
(	O
int	O
float_type	int
,	O
char	O
*	O
bytes	int
)	O
{	O
int	O
length	char
;	O
int	O
i	pointer
;	O
switch	O
(	O
float_type	int
)	O
{	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
length	char
=	O
4	int
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
case	O
'r'	O
:	O
case	O
'R'	O
:	O
length	char
=	O
8	int
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
length	char
=	O
12	int
;	O
break	O
;	O
case	O
'p'	O
:	O
case	O
'P'	O
:	O
length	char
=	O
12	int
;	O
break	O
;	O
default	O
:	O
as_bad	function
(	O
_	O
(	O
"unknown floating type type '%c'"	pointer
)	O
,	O
float_type	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
i	pointer
=	O
0	int
;	O
while	O
(	O
hex_p	O
(	O
*	O
input_line_pointer	pointer
)	O
||	O
*	O
input_line_pointer	pointer
==	O
'_'	O
)	O
{	O
int	O
d	int
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'_'	O
)	O
{	O
++	O
input_line_pointer	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
i	pointer
>=	O
length	char
)	O
{	O
as_warn	function
(	O
_	O
(	O
"floating point constant too large"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
d	int
=	O
hex_value	O
(	O
*	O
input_line_pointer	pointer
)	O
<<	O
4	int
;	O
++	O
input_line_pointer	pointer
;	O
while	O
(	O
*	O
input_line_pointer	pointer
==	O
'_'	O
)	O
++	O
input_line_pointer	pointer
;	O
if	O
(	O
hex_p	O
(	O
*	O
input_line_pointer	pointer
)	O
)	O
{	O
d	int
+=	O
hex_value	O
(	O
*	O
input_line_pointer	pointer
)	O
;	O
++	O
input_line_pointer	pointer
;	O
}	O
if	O
(	O
target_big_endian	int
)	O
bytes	int
[	O
i	pointer
]	O
=	O
d	int
;	O
else	O
bytes	int
[	O
length	char
-	O
i	pointer
-	O
1	int
]	O
=	O
d	int
;	O
++	O
i	pointer
;	O
}	O
if	O
(	O
i	pointer
<	O
length	char
)	O
{	O
if	O
(	O
target_big_endian	int
)	O
memset	function
(	O
bytes	int
+	O
i	pointer
,	O
0	int
,	O
length	char
-	O
i	pointer
)	O
;	O
else	O
memset	function
(	O
bytes	int
,	O
0	int
,	O
length	char
-	O
i	pointer
)	O
;	O
}	O
return	O
length	char
;	O
}	O
void	O
float_cons	function
(	O
int	O
float_type	int
)	O
{	O
char	O
*	O
p	pointer
;	O
int	O
length	char
;	O
const	O
char	O
*	O
err	pointer
;	O
char	O
temp	union
[	O
MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT	O
]	O
;	O
if	O
(	O
is_it_end_of_statement	function
(	O
)	O
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"attempt to store float in absolute section"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
in_bss	function
(	O
)	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"attempt to store float in section `%s'"	pointer
)	O
,	O
segment_name	O
(	O
now_seg	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
md_cons_align	O
(	O
1	int
)	O
;	O
do	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
input_line_pointer	pointer
[	O
0	int
]	O
==	O
'0'	O
&&	O
ISALPHA	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
)	O
)	O
input_line_pointer	pointer
+=	O
2	int
;	O
if	O
(	O
input_line_pointer	pointer
[	O
0	int
]	O
==	O
':'	O
)	O
{	O
++	O
input_line_pointer	pointer
;	O
length	char
=	O
hex_float	function
(	O
float_type	int
,	O
temp	union
)	O
;	O
if	O
(	O
length	char
<	O
0	int
)	O
{	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
err	pointer
=	O
md_atof	function
(	O
float_type	int
,	O
temp	union
,	O
&	O
length	char
)	O
;	O
know	O
(	O
length	char
<=	O
MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT	O
)	O
;	O
know	O
(	O
err	pointer
!=	O
NULL	O
||	O
length	char
>	O
0	int
)	O
;	O
if	O
(	O
err	pointer
)	O
{	O
as_bad	function
(	O
_	O
(	O
"bad floating literal: %s"	pointer
)	O
,	O
err	pointer
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
!	O
need_pass_2	int
)	O
{	O
int	O
count	int
;	O
count	int
=	O
1	int
;	O
while	O
(	O
--	O
count	int
>=	O
0	int
)	O
{	O
p	pointer
=	O
frag_more	function
(	O
length	char
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
temp	union
,	O
(	O
unsigned	O
int	O
)	O
length	char
)	O
;	O
}	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
while	O
(	O
*	O
input_line_pointer	pointer
++	O
==	O
','	O
)	O
;	O
--	O
input_line_pointer	pointer
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
sizeof_sleb128	function
(	O
offsetT	long
value	long
)	O
{	O
int	O
size	int
=	O
0	int
;	O
unsigned	O
byte	int
;	O
do	O
{	O
byte	int
=	O
(	O
value	long
&	O
0x7f	int
)	O
;	O
value	long
=	O
(	O
value	long
>>	O
7	int
)	O
|	O
~	O
(	O
-	O
(	O
offsetT	long
)	O
1	int
>>	O
7	int
)	O
;	O
size	int
+=	O
1	int
;	O
}	O
while	O
(	O
!	O
(	O
(	O
(	O
value	long
==	O
0	int
)	O
&&	O
(	O
(	O
byte	int
&	O
0x40	int
)	O
==	O
0	int
)	O
)	O
||	O
(	O
(	O
value	long
==	O
-	O
1	int
)	O
&&	O
(	O
(	O
byte	int
&	O
0x40	int
)	O
!=	O
0	int
)	O
)	O
)	O
)	O
;	O
return	O
size	int
;	O
}	O
static	O
inline	O
unsigned	O
int	O
sizeof_uleb128	function
(	O
valueT	long
value	long
)	O
{	O
int	O
size	int
=	O
0	int
;	O
do	O
{	O
value	long
>>=	O
7	int
;	O
size	int
+=	O
1	int
;	O
}	O
while	O
(	O
value	long
!=	O
0	int
)	O
;	O
return	O
size	int
;	O
}	O
unsigned	O
int	O
sizeof_leb128	function
(	O
valueT	long
value	long
,	O
int	O
sign	char
)	O
{	O
if	O
(	O
sign	char
)	O
return	O
sizeof_sleb128	function
(	O
(	O
offsetT	long
)	O
value	long
)	O
;	O
else	O
return	O
sizeof_uleb128	function
(	O
value	long
)	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
output_sleb128	function
(	O
char	O
*	O
p	pointer
,	O
offsetT	long
value	long
)	O
{	O
char	O
*	O
orig	pointer
=	O
p	pointer
;	O
int	O
more	int
;	O
do	O
{	O
unsigned	O
byte	int
=	O
(	O
value	long
&	O
0x7f	int
)	O
;	O
value	long
=	O
(	O
value	long
>>	O
7	int
)	O
|	O
~	O
(	O
-	O
(	O
offsetT	long
)	O
1	int
>>	O
7	int
)	O
;	O
more	int
=	O
!	O
(	O
(	O
(	O
(	O
value	long
==	O
0	int
)	O
&&	O
(	O
(	O
byte	int
&	O
0x40	int
)	O
==	O
0	int
)	O
)	O
||	O
(	O
(	O
value	long
==	O
-	O
1	int
)	O
&&	O
(	O
(	O
byte	int
&	O
0x40	int
)	O
!=	O
0	int
)	O
)	O
)	O
)	O
;	O
if	O
(	O
more	int
)	O
byte	int
|=	O
0x80	int
;	O
*	O
p	pointer
++	O
=	O
byte	int
;	O
}	O
while	O
(	O
more	int
)	O
;	O
return	O
p	pointer
-	O
orig	pointer
;	O
}	O
static	O
inline	O
unsigned	O
int	O
output_uleb128	function
(	O
char	O
*	O
p	pointer
,	O
valueT	long
value	long
)	O
{	O
char	O
*	O
orig	pointer
=	O
p	pointer
;	O
do	O
{	O
unsigned	O
byte	int
=	O
(	O
value	long
&	O
0x7f	int
)	O
;	O
value	long
>>=	O
7	int
;	O
if	O
(	O
value	long
!=	O
0	int
)	O
byte	int
|=	O
0x80	int
;	O
*	O
p	pointer
++	O
=	O
byte	int
;	O
}	O
while	O
(	O
value	long
!=	O
0	int
)	O
;	O
return	O
p	pointer
-	O
orig	pointer
;	O
}	O
unsigned	O
int	O
output_leb128	function
(	O
char	O
*	O
p	pointer
,	O
valueT	long
value	long
,	O
int	O
sign	char
)	O
{	O
if	O
(	O
sign	char
)	O
return	O
output_sleb128	function
(	O
p	pointer
,	O
(	O
offsetT	long
)	O
value	long
)	O
;	O
else	O
return	O
output_uleb128	function
(	O
p	pointer
,	O
value	long
)	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
output_big_sleb128	function
(	O
char	O
*	O
p	pointer
,	O
LITTLENUM_TYPE	short
*	O
bignum	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
char	O
*	O
orig	pointer
=	O
p	pointer
;	O
valueT	long
val	int
=	O
0	int
;	O
int	O
loaded	pointer
=	O
0	int
;	O
unsigned	O
byte	int
;	O
while	O
(	O
size	int
>	O
1	int
&&	O
bignum	pointer
[	O
size	int
-	O
1	int
]	O
==	O
LITTLENUM_MASK	O
&&	O
bignum	pointer
[	O
size	int
-	O
2	int
]	O
>	O
LITTLENUM_MASK	O
/	O
2	int
)	O
size	int
--	O
;	O
do	O
{	O
val	int
|=	O
(	O
*	O
bignum	pointer
<<	O
loaded	pointer
)	O
;	O
loaded	pointer
+=	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
size	int
--	O
;	O
bignum	pointer
++	O
;	O
do	O
{	O
byte	int
=	O
val	int
&	O
0x7f	int
;	O
loaded	pointer
-=	O
7	int
;	O
val	int
>>=	O
7	int
;	O
if	O
(	O
size	int
>	O
0	int
||	O
val	int
!=	O
(	O
(	O
byte	int
&	O
0x40	int
)	O
==	O
0	int
?	O
0	int
:	O
(	O
(	O
valueT	long
)	O
1	int
<<	O
loaded	pointer
)	O
-	O
1	int
)	O
)	O
byte	int
|=	O
0x80	int
;	O
if	O
(	O
orig	pointer
)	O
*	O
p	pointer
=	O
byte	int
;	O
p	pointer
++	O
;	O
}	O
while	O
(	O
(	O
byte	int
&	O
0x80	int
)	O
!=	O
0	int
&&	O
loaded	pointer
>=	O
7	int
)	O
;	O
}	O
while	O
(	O
size	int
>	O
0	int
)	O
;	O
if	O
(	O
(	O
byte	int
&	O
0x80	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
val	int
&	O
(	O
1	int
<<	O
(	O
loaded	pointer
-	O
1	int
)	O
)	O
)	O
val	int
|=	O
~	O
0U	int
<<	O
loaded	pointer
;	O
if	O
(	O
orig	pointer
)	O
*	O
p	pointer
=	O
val	int
&	O
0x7f	int
;	O
p	pointer
++	O
;	O
}	O
return	O
p	pointer
-	O
orig	pointer
;	O
}	O
static	O
inline	O
unsigned	O
int	O
output_big_uleb128	function
(	O
char	O
*	O
p	pointer
,	O
LITTLENUM_TYPE	short
*	O
bignum	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
char	O
*	O
orig	pointer
=	O
p	pointer
;	O
valueT	long
val	int
=	O
0	int
;	O
int	O
loaded	pointer
=	O
0	int
;	O
unsigned	O
byte	int
;	O
while	O
(	O
size	int
>	O
0	int
&&	O
bignum	pointer
[	O
size	int
-	O
1	int
]	O
==	O
0	int
)	O
size	int
--	O
;	O
do	O
{	O
if	O
(	O
loaded	pointer
<	O
7	int
&&	O
size	int
>	O
0	int
)	O
{	O
val	int
|=	O
(	O
*	O
bignum	pointer
<<	O
loaded	pointer
)	O
;	O
loaded	pointer
+=	O
8	int
*	O
CHARS_PER_LITTLENUM	O
;	O
size	int
--	O
;	O
bignum	pointer
++	O
;	O
}	O
byte	int
=	O
val	int
&	O
0x7f	int
;	O
loaded	pointer
-=	O
7	int
;	O
val	int
>>=	O
7	int
;	O
if	O
(	O
size	int
>	O
0	int
||	O
val	int
)	O
byte	int
|=	O
0x80	int
;	O
if	O
(	O
orig	pointer
)	O
*	O
p	pointer
=	O
byte	int
;	O
p	pointer
++	O
;	O
}	O
while	O
(	O
byte	int
&	O
0x80	int
)	O
;	O
return	O
p	pointer
-	O
orig	pointer
;	O
}	O
static	O
unsigned	O
int	O
output_big_leb128	function
(	O
char	O
*	O
p	pointer
,	O
LITTLENUM_TYPE	short
*	O
bignum	pointer
,	O
unsigned	O
int	O
size	int
,	O
int	O
sign	char
)	O
{	O
if	O
(	O
sign	char
)	O
return	O
output_big_sleb128	function
(	O
p	pointer
,	O
bignum	pointer
,	O
size	int
)	O
;	O
else	O
return	O
output_big_uleb128	function
(	O
p	pointer
,	O
bignum	pointer
,	O
size	int
)	O
;	O
}	O
static	O
void	O
emit_leb128_expr	function
(	O
expressionS	struct
*	O
exp	pointer
,	O
int	O
sign	char
)	O
{	O
operatorT	enum
op	int
=	O
exp	pointer
->	O
X_op	enum
;	O
unsigned	O
int	O
nbytes	long
;	O
if	O
(	O
op	int
==	O
O_absent	int
||	O
op	int
==	O
O_illegal	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"zero assumed for missing expression"	pointer
)	O
)	O
;	O
exp	pointer
->	O
X_add_number	long
=	O
0	int
;	O
op	int
=	O
O_constant	int
;	O
}	O
else	O
if	O
(	O
op	int
==	O
O_big	int
&&	O
exp	pointer
->	O
X_add_number	long
<=	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"floating point number invalid"	pointer
)	O
)	O
;	O
exp	pointer
->	O
X_add_number	long
=	O
0	int
;	O
op	int
=	O
O_constant	int
;	O
}	O
else	O
if	O
(	O
op	int
==	O
O_register	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"register value used as expression"	pointer
)	O
)	O
;	O
op	int
=	O
O_constant	int
;	O
}	O
else	O
if	O
(	O
op	int
==	O
O_constant	int
&&	O
sign	char
&&	O
(	O
exp	pointer
->	O
X_add_number	long
<	O
0	int
)	O
==	O
!	O
exp	pointer
->	O
X_extrabit	int
)	O
{	O
convert_to_bignum	function
(	O
exp	pointer
,	O
exp	pointer
->	O
X_extrabit	int
)	O
;	O
op	int
=	O
O_big	int
;	O
}	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
if	O
(	O
op	int
!=	O
O_constant	int
||	O
exp	pointer
->	O
X_add_number	long
!=	O
0	int
)	O
as_bad	function
(	O
_	O
(	O
"attempt to store value in absolute section"	pointer
)	O
)	O
;	O
abs_section_offset	long
++	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
op	int
!=	O
O_constant	int
||	O
exp	pointer
->	O
X_add_number	long
!=	O
0	int
)	O
&&	O
in_bss	function
(	O
)	O
)	O
as_bad	function
(	O
_	O
(	O
"attempt to store non-zero value in section `%s'"	pointer
)	O
,	O
segment_name	O
(	O
now_seg	pointer
)	O
)	O
;	O
nbytes	long
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
if	O
(	O
check_eh_frame	function
(	O
exp	pointer
,	O
&	O
nbytes	long
)	O
)	O
abort	function
(	O
)	O
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
if	O
(	O
op	int
==	O
O_constant	int
)	O
{	O
valueT	long
value	long
=	O
exp	pointer
->	O
X_add_number	long
;	O
unsigned	O
int	O
size	int
;	O
char	O
*	O
p	pointer
;	O
size	int
=	O
sizeof_leb128	function
(	O
value	long
,	O
sign	char
)	O
;	O
p	pointer
=	O
frag_more	function
(	O
size	int
)	O
;	O
if	O
(	O
output_leb128	function
(	O
p	pointer
,	O
value	long
,	O
sign	char
)	O
>	O
size	int
)	O
abort	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
op	int
==	O
O_big	int
)	O
{	O
int	O
nbr_digits	int
=	O
exp	pointer
->	O
X_add_number	long
;	O
unsigned	O
int	O
size	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
exp	pointer
->	O
X_unsigned	int
&&	O
nbr_digits	int
<	O
SIZE_OF_LARGE_NUMBER	O
&&	O
generic_bignum	array
[	O
nbr_digits	int
-	O
1	int
]	O
==	O
LITTLENUM_MASK	O
)	O
generic_bignum	array
[	O
nbr_digits	int
++	O
]	O
=	O
0	int
;	O
size	int
=	O
output_big_leb128	function
(	O
NULL	O
,	O
generic_bignum	array
,	O
nbr_digits	int
,	O
sign	char
)	O
;	O
p	pointer
=	O
frag_more	function
(	O
size	int
)	O
;	O
if	O
(	O
output_big_leb128	function
(	O
p	pointer
,	O
generic_bignum	array
,	O
nbr_digits	int
,	O
sign	char
)	O
>	O
size	int
)	O
abort	function
(	O
)	O
;	O
}	O
else	O
{	O
frag_var	function
(	O
rs_leb128	int
,	O
sizeof_uleb128	function
(	O
~	O
(	O
valueT	long
)	O
0	int
)	O
,	O
0	int
,	O
sign	char
,	O
make_expr_symbol	function
(	O
exp	pointer
)	O
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
}	O
void	O
s_leb128	function
(	O
int	O
sign	char
)	O
{	O
expressionS	struct
exp	pointer
;	O
do	O
{	O
expression	O
(	O
&	O
exp	pointer
)	O
;	O
emit_leb128_expr	function
(	O
&	O
exp	pointer
,	O
sign	char
)	O
;	O
}	O
while	O
(	O
*	O
input_line_pointer	pointer
++	O
==	O
','	O
)	O
;	O
input_line_pointer	pointer
--	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
static	O
void	O
stringer_append_char	function
(	O
int	O
c	struct
,	O
int	O
bitsize	int
)	O
{	O
if	O
(	O
c	struct
&&	O
in_bss	function
(	O
)	O
)	O
as_bad	function
(	O
_	O
(	O
"attempt to store non-empty string in section `%s'"	pointer
)	O
,	O
segment_name	O
(	O
now_seg	pointer
)	O
)	O
;	O
if	O
(	O
!	O
target_big_endian	int
)	O
FRAG_APPEND_1_CHAR	O
(	O
c	struct
)	O
;	O
switch	O
(	O
bitsize	int
)	O
{	O
case	O
64	int
:	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
case	O
32	int
:	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
case	O
16	int
:	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
case	O
8	int
:	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
target_big_endian	int
)	O
FRAG_APPEND_1_CHAR	O
(	O
c	struct
)	O
;	O
}	O
void	O
stringer	function
(	O
int	O
bits_appendzero	int
)	O
{	O
const	O
int	O
bitsize	int
=	O
bits_appendzero	int
&	O
~	O
7	int
;	O
const	O
int	O
append_zero	int
=	O
bits_appendzero	int
&	O
1	int
;	O
unsigned	O
int	O
c	struct
;	O
char	O
*	O
start	pointer
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"strings must be placed into a section"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
is_it_end_of_statement	function
(	O
)	O
)	O
{	O
c	struct
=	O
0	int
;	O
++	O
input_line_pointer	pointer
;	O
}	O
else	O
{	O
c	struct
=	O
','	O
;	O
}	O
while	O
(	O
c	struct
==	O
','	O
||	O
c	struct
==	O
'<'	O
||	O
c	struct
==	O
'"'	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
switch	O
(	O
*	O
input_line_pointer	pointer
)	O
{	O
case	O
'\"'	O
:	O
++	O
input_line_pointer	pointer
;	O
start	pointer
=	O
input_line_pointer	pointer
;	O
while	O
(	O
is_a_char	O
(	O
c	struct
=	O
next_char_of_string	function
(	O
)	O
)	O
)	O
stringer_append_char	function
(	O
c	struct
,	O
bitsize	int
)	O
;	O
if	O
(	O
append_zero	int
)	O
stringer_append_char	function
(	O
0	int
,	O
bitsize	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
segment_name	O
(	O
now_seg	pointer
)	O
,	O
".debug"	pointer
)	O
!=	O
0	int
)	O
dwarf_file_string	int
=	O
0	int
;	O
else	O
if	O
(	O
dwarf_file_string	int
)	O
{	O
c	struct
=	O
input_line_pointer	pointer
[	O
-	O
1	int
]	O
;	O
input_line_pointer	pointer
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
listing_source_file	function
(	O
start	pointer
)	O
;	O
input_line_pointer	pointer
[	O
-	O
1	int
]	O
=	O
c	struct
;	O
}	O
break	O
;	O
case	O
'<'	O
:	O
input_line_pointer	pointer
++	O
;	O
c	struct
=	O
get_single_number	function
(	O
)	O
;	O
stringer_append_char	function
(	O
c	struct
,	O
bitsize	int
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
'>'	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"expected <nn>"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
input_line_pointer	pointer
++	O
;	O
break	O
;	O
case	O
','	O
:	O
input_line_pointer	pointer
++	O
;	O
break	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
unsigned	O
int	O
next_char_of_string	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
c	struct
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
&	O
CHAR_MASK	O
;	O
switch	O
(	O
c	struct
)	O
{	O
case	O
0	int
:	O
--	O
input_line_pointer	pointer
;	O
c	struct
=	O
NOT_A_CHAR	O
;	O
break	O
;	O
case	O
'\"'	O
:	O
c	struct
=	O
NOT_A_CHAR	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
as_warn	function
(	O
_	O
(	O
"unterminated string; newline inserted"	pointer
)	O
)	O
;	O
bump_line_counters	function
(	O
)	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
!	O
TC_STRING_ESCAPES	int
)	O
break	O
;	O
switch	O
(	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
&	O
CHAR_MASK	O
)	O
{	O
case	O
'b'	O
:	O
c	struct
=	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
c	struct
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
c	struct
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
c	struct
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
c	struct
=	O
'\t'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
c	struct
=	O
'\013'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
case	O
'"'	O
:	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
{	O
long	O
number	long
;	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
number	long
=	O
0	int
;	O
ISDIGIT	O
(	O
c	struct
)	O
&&	O
i	pointer
<	O
3	int
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
,	O
i	pointer
++	O
)	O
{	O
number	long
=	O
number	long
*	O
8	int
+	O
c	struct
-	O
'0'	O
;	O
}	O
c	struct
=	O
number	long
&	O
CHAR_MASK	O
;	O
}	O
--	O
input_line_pointer	pointer
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
{	O
long	O
number	long
;	O
number	long
=	O
0	int
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
while	O
(	O
ISXDIGIT	O
(	O
c	struct
)	O
)	O
{	O
if	O
(	O
ISDIGIT	O
(	O
c	struct
)	O
)	O
number	long
=	O
number	long
*	O
16	int
+	O
c	struct
-	O
'0'	O
;	O
else	O
if	O
(	O
ISUPPER	O
(	O
c	struct
)	O
)	O
number	long
=	O
number	long
*	O
16	int
+	O
c	struct
-	O
'A'	O
+	O
10	int
;	O
else	O
number	long
=	O
number	long
*	O
16	int
+	O
c	struct
-	O
'a'	O
+	O
10	int
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
}	O
c	struct
=	O
number	long
&	O
CHAR_MASK	O
;	O
--	O
input_line_pointer	pointer
;	O
}	O
break	O
;	O
case	O
'\n'	O
:	O
as_warn	function
(	O
_	O
(	O
"unterminated string; newline inserted"	pointer
)	O
)	O
;	O
c	struct
=	O
'\n'	O
;	O
bump_line_counters	function
(	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
--	O
input_line_pointer	pointer
;	O
c	struct
=	O
NOT_A_CHAR	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
c	struct
)	O
;	O
}	O
static	O
segT	pointer
get_segmented_expression	function
(	O
expressionS	struct
*	O
expP	pointer
)	O
{	O
segT	pointer
retval	pointer
;	O
retval	pointer
=	O
expression	O
(	O
expP	pointer
)	O
;	O
if	O
(	O
expP	pointer
->	O
X_op	enum
==	O
O_illegal	int
||	O
expP	pointer
->	O
X_op	enum
==	O
O_absent	int
||	O
expP	pointer
->	O
X_op	enum
==	O
O_big	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"expected address expression"	pointer
)	O
)	O
;	O
expP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
retval	pointer
=	O
absolute_section	O
;	O
}	O
return	O
retval	pointer
;	O
}	O
static	O
segT	pointer
get_known_segmented_expression	function
(	O
expressionS	struct
*	O
expP	pointer
)	O
{	O
segT	pointer
retval	pointer
=	O
get_segmented_expression	function
(	O
expP	pointer
)	O
;	O
if	O
(	O
retval	pointer
==	O
undefined_section	O
)	O
{	O
if	O
(	O
expP	pointer
->	O
X_add_symbol	pointer
!=	O
NULL	O
&&	O
S_GET_SEGMENT	function
(	O
expP	pointer
->	O
X_add_symbol	pointer
)	O
!=	O
expr_section	pointer
)	O
as_warn	function
(	O
_	O
(	O
"symbol \"%s\" undefined; zero assumed"	pointer
)	O
,	O
S_GET_NAME	function
(	O
expP	pointer
->	O
X_add_symbol	pointer
)	O
)	O
;	O
else	O
as_warn	function
(	O
_	O
(	O
"some symbol undefined; zero assumed"	pointer
)	O
)	O
;	O
retval	pointer
=	O
absolute_section	O
;	O
expP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
return	O
retval	pointer
;	O
}	O
char	O
get_absolute_expression_and_terminator	function
(	O
long	O
*	O
val_pointer	pointer
)	O
{	O
*	O
val_pointer	pointer
=	O
(	O
long	O
)	O
get_absolute_expression	function
(	O
)	O
;	O
return	O
(	O
*	O
input_line_pointer	pointer
++	O
)	O
;	O
}	O
char	O
*	O
demand_copy_C_string	function
(	O
int	O
*	O
len_pointer	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
s	pointer
=	O
demand_copy_string	function
(	O
len_pointer	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
int	O
len	long
;	O
for	O
(	O
len	long
=	O
*	O
len_pointer	pointer
;	O
len	long
>	O
0	int
;	O
len	long
--	O
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
0	int
)	O
{	O
s	pointer
=	O
0	int
;	O
len	long
=	O
1	int
;	O
*	O
len_pointer	pointer
=	O
0	int
;	O
as_bad	function
(	O
_	O
(	O
"this string may not contain \'\\0\'"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
return	O
s	pointer
;	O
}	O
char	O
*	O
demand_copy_string	function
(	O
int	O
*	O
lenP	pointer
)	O
{	O
unsigned	O
int	O
c	struct
;	O
int	O
len	long
;	O
char	O
*	O
retval	pointer
;	O
len	long
=	O
0	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'\"'	O
)	O
{	O
input_line_pointer	pointer
++	O
;	O
while	O
(	O
is_a_char	O
(	O
c	struct
=	O
next_char_of_string	function
(	O
)	O
)	O
)	O
{	O
obstack_1grow	O
(	O
&	O
notes	struct
,	O
c	struct
)	O
;	O
len	long
++	O
;	O
}	O
obstack_1grow	O
(	O
&	O
notes	struct
,	O
'\0'	O
)	O
;	O
retval	pointer
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
notes	struct
)	O
;	O
}	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"missing string"	pointer
)	O
)	O
;	O
retval	pointer
=	O
NULL	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
*	O
lenP	pointer
=	O
len	long
;	O
return	O
(	O
retval	pointer
)	O
;	O
}	O
int	O
is_it_end_of_statement	function
(	O
void	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
return	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
;	O
}	O
void	O
equals	function
(	O
char	O
*	O
sym_name	pointer
,	O
int	O
reassign	int
)	O
{	O
char	O
*	O
stop	pointer
=	O
NULL	O
;	O
char	O
stopc	int
=	O
0	int
;	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'='	O
)	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
reassign	int
<	O
0	int
&&	O
*	O
input_line_pointer	pointer
==	O
'='	O
)	O
input_line_pointer	pointer
++	O
;	O
while	O
(	O
*	O
input_line_pointer	pointer
==	O
' '	O
||	O
*	O
input_line_pointer	pointer
==	O
'\t'	O
)	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
flag_mri	int
)	O
stop	pointer
=	O
mri_comment_field	function
(	O
&	O
stopc	int
)	O
;	O
assign_symbol	function
(	O
sym_name	pointer
,	O
reassign	int
>=	O
0	int
?	O
!	O
reassign	int
:	O
reassign	int
)	O
;	O
if	O
(	O
flag_mri	int
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
mri_comment_end	function
(	O
stop	pointer
,	O
stopc	int
)	O
;	O
}	O
}	O
void	O
s_incbin	function
(	O
int	O
x	int
ATTRIBUTE_UNUSED	O
)	O
{	O
FILE	struct
*	O
binfile	pointer
;	O
char	O
*	O
path	pointer
;	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
binfrag	pointer
;	O
long	O
skip	long
=	O
0	int
;	O
long	O
count	int
=	O
0	int
;	O
long	O
bytes	int
;	O
int	O
len	long
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
filename	pointer
=	O
demand_copy_string	function
(	O
&	O
len	long
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
return	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
++	O
input_line_pointer	pointer
;	O
skip	long
=	O
get_absolute_expression	function
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
','	O
)	O
{	O
++	O
input_line_pointer	pointer
;	O
count	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
".incbin count zero, ignoring `%s'"	pointer
)	O
,	O
filename	pointer
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
binfile	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
FOPEN_RB	pointer
)	O
;	O
if	O
(	O
binfile	pointer
==	O
NULL	O
)	O
{	O
int	O
i	pointer
;	O
path	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
(	O
unsigned	O
long	O
)	O
len	long
+	O
include_dir_maxlen	int
+	O
5	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
include_dir_count	int
;	O
i	pointer
++	O
)	O
{	O
sprintf	function
(	O
path	pointer
,	O
"%s/%s"	pointer
,	O
include_dirs	pointer
[	O
i	pointer
]	O
,	O
filename	pointer
)	O
;	O
binfile	pointer
=	O
fopen	function
(	O
path	pointer
,	O
FOPEN_RB	pointer
)	O
;	O
if	O
(	O
binfile	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
binfile	pointer
==	O
NULL	O
)	O
as_bad	function
(	O
_	O
(	O
"file not found: %s"	pointer
)	O
,	O
filename	pointer
)	O
;	O
}	O
else	O
path	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
binfile	pointer
)	O
{	O
long	O
file_len	long
;	O
register_dependency	function
(	O
path	pointer
)	O
;	O
if	O
(	O
fseek	function
(	O
binfile	pointer
,	O
0	int
,	O
SEEK_END	int
)	O
!=	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"seek to end of .incbin file failed `%s'"	pointer
)	O
,	O
path	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
file_len	long
=	O
ftell	function
(	O
binfile	pointer
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
count	int
=	O
file_len	long
-	O
skip	long
;	O
if	O
(	O
skip	long
<	O
0	int
||	O
count	int
<	O
0	int
||	O
file_len	long
<	O
0	int
||	O
skip	long
+	O
count	int
>	O
file_len	long
)	O
{	O
as_bad	function
(	O
_	O
(	O
"skip (%ld) or count (%ld) invalid for file size (%ld)"	pointer
)	O
,	O
skip	long
,	O
count	int
,	O
file_len	long
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
fseek	function
(	O
binfile	pointer
,	O
skip	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"could not skip to %ld in file `%s'"	pointer
)	O
,	O
skip	long
,	O
path	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
binfrag	pointer
=	O
frag_more	function
(	O
count	int
)	O
;	O
bytes	int
=	O
fread	function
(	O
binfrag	pointer
,	O
1	int
,	O
count	int
,	O
binfile	pointer
)	O
;	O
if	O
(	O
bytes	int
<	O
count	int
)	O
as_warn	function
(	O
_	O
(	O
"truncated file `%s', %ld of %ld bytes read"	pointer
)	O
,	O
path	pointer
,	O
bytes	int
,	O
count	int
)	O
;	O
}	O
done	O
:	O
if	O
(	O
binfile	pointer
!=	O
NULL	O
)	O
fclose	function
(	O
binfile	pointer
)	O
;	O
if	O
(	O
path	pointer
)	O
free	function
(	O
path	pointer
)	O
;	O
}	O
void	O
s_include	function
(	O
int	O
arg	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
filename	pointer
;	O
int	O
i	pointer
;	O
FILE	struct
*	O
try_file	pointer
;	O
char	O
*	O
path	pointer
;	O
if	O
(	O
!	O
flag_m68k_mri	int
)	O
{	O
filename	pointer
=	O
demand_copy_string	function
(	O
&	O
i	pointer
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
return	O
;	O
}	O
}	O
else	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
i	pointer
=	O
0	int
;	O
while	O
(	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
&&	O
*	O
input_line_pointer	pointer
!=	O
' '	O
&&	O
*	O
input_line_pointer	pointer
!=	O
'\t'	O
)	O
{	O
obstack_1grow	O
(	O
&	O
notes	struct
,	O
*	O
input_line_pointer	pointer
)	O
;	O
++	O
input_line_pointer	pointer
;	O
++	O
i	pointer
;	O
}	O
obstack_1grow	O
(	O
&	O
notes	struct
,	O
'\0'	O
)	O
;	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
notes	struct
)	O
;	O
while	O
(	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
++	O
input_line_pointer	pointer
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
path	pointer
=	O
XNEWVEC	O
(	O
char	O
,	O
(	O
unsigned	O
long	O
)	O
i	pointer
+	O
include_dir_maxlen	int
+	O
5	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
include_dir_count	int
;	O
i	pointer
++	O
)	O
{	O
strcpy	function
(	O
path	pointer
,	O
include_dirs	pointer
[	O
i	pointer
]	O
)	O
;	O
strcat	function
(	O
path	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
path	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
try_file	pointer
=	O
fopen	function
(	O
path	pointer
,	O
FOPEN_RT	pointer
)	O
)	O
)	O
{	O
fclose	function
(	O
try_file	pointer
)	O
;	O
goto	O
gotit	O
;	O
}	O
}	O
free	function
(	O
path	pointer
)	O
;	O
path	pointer
=	O
filename	pointer
;	O
gotit	O
:	O
register_dependency	function
(	O
path	pointer
)	O
;	O
input_scrub_insert_file	function
(	O
path	pointer
)	O
;	O
}	O
void	O
add_include_dir	function
(	O
char	O
*	O
path	pointer
)	O
{	O
int	O
i	pointer
;	O
if	O
(	O
include_dir_count	int
==	O
0	int
)	O
{	O
include_dirs	pointer
=	O
XNEWVEC	O
(	O
const	O
char	O
*	O
,	O
2	int
)	O
;	O
include_dirs	pointer
[	O
0	int
]	O
=	O
"."	pointer
;	O
include_dir_count	int
=	O
2	int
;	O
}	O
else	O
{	O
include_dir_count	int
++	O
;	O
include_dirs	pointer
=	O
XRESIZEVEC	O
(	O
const	O
char	O
*	O
,	O
include_dirs	pointer
,	O
include_dir_count	int
)	O
;	O
}	O
include_dirs	pointer
[	O
include_dir_count	int
-	O
1	int
]	O
=	O
path	pointer
;	O
i	pointer
=	O
strlen	function
(	O
path	pointer
)	O
;	O
if	O
(	O
i	pointer
>	O
include_dir_maxlen	int
)	O
include_dir_maxlen	int
=	O
i	pointer
;	O
}	O
static	O
void	O
generate_file_debug	function
(	O
void	O
)	O
{	O
if	O
(	O
debug_type	enum
==	O
DEBUG_STABS	int
)	O
stabs_generate_asm_file	function
(	O
)	O
;	O
}	O
void	O
generate_lineno_debug	function
(	O
void	O
)	O
{	O
switch	O
(	O
debug_type	enum
)	O
{	O
case	O
DEBUG_UNSPECIFIED	int
:	O
case	O
DEBUG_NONE	int
:	O
case	O
DEBUG_DWARF	int
:	O
break	O
;	O
case	O
DEBUG_STABS	int
:	O
stabs_generate_asm_lineno	function
(	O
)	O
;	O
break	O
;	O
case	O
DEBUG_ECOFF	int
:	O
ecoff_generate_asm_lineno	function
(	O
)	O
;	O
break	O
;	O
case	O
DEBUG_DWARF2	int
:	O
break	O
;	O
}	O
}	O
void	O
s_func	function
(	O
int	O
end_p	int
)	O
{	O
do_s_func	function
(	O
end_p	int
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
do_s_func	function
(	O
int	O
end_p	int
,	O
const	O
char	O
*	O
default_prefix	char
)	O
{	O
static	O
char	O
*	O
current_name	pointer
;	O
static	O
char	O
*	O
current_label	pointer
;	O
if	O
(	O
end_p	int
)	O
{	O
if	O
(	O
current_name	pointer
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"missing .func"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
debug_type	enum
==	O
DEBUG_STABS	int
)	O
stabs_generate_asm_endfunc	function
(	O
current_name	pointer
,	O
current_label	pointer
)	O
;	O
current_name	pointer
=	O
current_label	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
char	O
*	O
name	pointer
,	O
*	O
label	long
;	O
char	O
delim1	char
,	O
delim2	char
;	O
if	O
(	O
current_name	pointer
!=	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".endfunc missing for previous .func"	pointer
)	O
)	O
;	O
ignore_rest_of_line	function
(	O
)	O
;	O
return	O
;	O
}	O
delim1	char
=	O
get_symbol_name	function
(	O
&	O
name	pointer
)	O
;	O
name	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
*	O
input_line_pointer	pointer
=	O
delim1	char
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
','	O
)	O
{	O
if	O
(	O
default_prefix	char
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
label	long
,	O
"%s%s"	pointer
,	O
default_prefix	char
,	O
name	pointer
)	O
==	O
-	O
1	int
)	O
as_fatal	function
(	O
"%s"	pointer
,	O
xstrerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
char	O
leading_char	char
=	O
bfd_get_symbol_leading_char	function
(	O
stdoutput	pointer
)	O
;	O
if	O
(	O
leading_char	char
)	O
{	O
if	O
(	O
asprintf	function
(	O
&	O
label	long
,	O
"%c%s"	pointer
,	O
leading_char	char
,	O
name	pointer
)	O
==	O
-	O
1	int
)	O
as_fatal	function
(	O
"%s"	pointer
,	O
xstrerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
label	long
=	O
name	pointer
;	O
}	O
}	O
else	O
{	O
++	O
input_line_pointer	pointer
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
delim2	char
=	O
get_symbol_name	function
(	O
&	O
label	long
)	O
;	O
label	long
=	O
xstrdup	function
(	O
label	long
)	O
;	O
restore_line_pointer	function
(	O
delim2	char
)	O
;	O
}	O
if	O
(	O
debug_type	enum
==	O
DEBUG_STABS	int
)	O
stabs_generate_asm_func	function
(	O
name	pointer
,	O
label	long
)	O
;	O
current_name	pointer
=	O
name	pointer
;	O
current_label	pointer
=	O
label	long
;	O
}	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
s_bundle_align_mode	function
(	O
int	O
arg	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
int	O
align	int
=	O
get_absolute_expression	function
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
align	int
>	O
(	O
unsigned	O
int	O
)	O
TC_ALIGN_LIMIT	O
)	O
as_fatal	function
(	O
_	O
(	O
".bundle_align_mode alignment too large (maximum %u)"	pointer
)	O
,	O
(	O
unsigned	O
int	O
)	O
TC_ALIGN_LIMIT	O
)	O
;	O
if	O
(	O
bundle_lock_frag	pointer
!=	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"cannot change .bundle_align_mode inside .bundle_lock"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
bundle_align_p2	int
=	O
align	int
;	O
}	O
void	O
s_bundle_lock	function
(	O
int	O
arg	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
bundle_align_p2	int
==	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
".bundle_lock is meaningless without .bundle_align_mode"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
bundle_lock_depth	int
==	O
0	int
)	O
{	O
bundle_lock_frchain	pointer
=	O
frchain_now	pointer
;	O
bundle_lock_frag	pointer
=	O
start_bundle	function
(	O
)	O
;	O
}	O
++	O
bundle_lock_depth	int
;	O
}	O
void	O
s_bundle_unlock	function
(	O
int	O
arg	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
int	O
size	int
;	O
demand_empty_rest_of_line	function
(	O
)	O
;	O
if	O
(	O
bundle_lock_frag	pointer
==	O
NULL	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
".bundle_unlock without preceding .bundle_lock"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
gas_assert	O
(	O
bundle_align_p2	int
>	O
0	int
)	O
;	O
gas_assert	O
(	O
bundle_lock_depth	int
>	O
0	int
)	O
;	O
if	O
(	O
--	O
bundle_lock_depth	int
>	O
0	int
)	O
return	O
;	O
size	int
=	O
pending_bundle_size	function
(	O
bundle_lock_frag	pointer
)	O
;	O
if	O
(	O
size	int
>	O
1U	int
<<	O
bundle_align_p2	int
)	O
as_bad	function
(	O
_	O
(	O
".bundle_lock sequence is %u bytes, "	pointer
"but bundle size is only %u bytes"	pointer
)	O
,	O
size	int
,	O
1u	int
<<	O
bundle_align_p2	int
)	O
;	O
else	O
finish_bundle	function
(	O
bundle_lock_frag	pointer
,	O
size	int
)	O
;	O
bundle_lock_frag	pointer
=	O
NULL	O
;	O
bundle_lock_frchain	pointer
=	O
NULL	O
;	O
}	O
void	O
s_ignore	function
(	O
int	O
arg	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
ignore_rest_of_line	function
(	O
)	O
;	O
}	O
void	O
read_print_statistics	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
hash_print_statistics	function
(	O
file	pointer
,	O
"pseudo-op table"	pointer
,	O
po_hash	pointer
)	O
;	O
}	O
void	O
input_scrub_insert_line	function
(	O
const	O
char	O
*	O
line	int
)	O
{	O
sb	pointer
newline	struct
;	O
size_t	long
len	long
=	O
strlen	function
(	O
line	int
)	O
;	O
sb_build	function
(	O
&	O
newline	struct
,	O
len	long
)	O
;	O
sb_add_buffer	function
(	O
&	O
newline	struct
,	O
line	int
,	O
len	long
)	O
;	O
input_scrub_include_sb	function
(	O
&	O
newline	struct
,	O
input_line_pointer	pointer
,	O
0	int
)	O
;	O
sb_kill	function
(	O
&	O
newline	struct
)	O
;	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
}	O
void	O
input_scrub_insert_file	function
(	O
char	O
*	O
path	pointer
)	O
{	O
input_scrub_include_file	function
(	O
path	pointer
,	O
input_line_pointer	pointer
)	O
;	O
buffer_limit	pointer
=	O
input_scrub_next_buffer	function
(	O
&	O
input_line_pointer	pointer
)	O
;	O
}	O
static	O
char	O
*	O
_find_end_of_line	function
(	O
char	O
*	O
s	pointer
,	O
int	O
mri_string	int
,	O
int	O
insn	int
ATTRIBUTE_UNUSED	O
,	O
int	O
in_macro	int
)	O
{	O
char	O
inquote	char
=	O
'\0'	O
;	O
int	O
inescape	int
=	O
0	int
;	O
while	O
(	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
]	O
||	O
(	O
inquote	char
&&	O
!	O
ISCNTRL	O
(	O
*	O
s	pointer
)	O
)	O
||	O
(	O
inquote	char
==	O
'\''	O
&&	O
flag_mri	int
)	O
||	O
(	O
in_macro	int
&&	O
inescape	int
&&	O
*	O
s	pointer
==	O
'@'	O
)	O
)	O
{	O
if	O
(	O
mri_string	int
&&	O
*	O
s	pointer
==	O
'\''	O
)	O
inquote	char
^=	O
*	O
s	pointer
;	O
else	O
if	O
(	O
inescape	int
)	O
inescape	int
=	O
0	int
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'\\'	O
)	O
inescape	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
inquote	char
?	O
*	O
s	pointer
==	O
'"'	O
:	O
*	O
s	pointer
==	O
inquote	char
)	O
inquote	char
^=	O
*	O
s	pointer
;	O
++	O
s	pointer
;	O
}	O
if	O
(	O
inquote	char
)	O
as_warn	function
(	O
_	O
(	O
"missing closing `%c'"	pointer
)	O
,	O
inquote	char
)	O
;	O
if	O
(	O
inescape	int
&&	O
!	O
ignore_input	function
(	O
)	O
)	O
as_warn	function
(	O
_	O
(	O
"stray `\\'"	pointer
)	O
)	O
;	O
return	O
s	pointer
;	O
}	O
char	O
*	O
find_end_of_line	function
(	O
char	O
*	O
s	pointer
,	O
int	O
mri_string	int
)	O
{	O
return	O
_find_end_of_line	function
(	O
s	pointer
,	O
mri_string	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
static	O
char	O
*	O
saved_ilp	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
saved_limit	pointer
;	O
void	O
temp_ilp	function
(	O
char	O
*	O
buf	pointer
)	O
{	O
gas_assert	O
(	O
saved_ilp	pointer
==	O
NULL	O
)	O
;	O
gas_assert	O
(	O
buf	pointer
!=	O
NULL	O
)	O
;	O
saved_ilp	pointer
=	O
input_line_pointer	pointer
;	O
saved_limit	pointer
=	O
buffer_limit	pointer
;	O
if	O
(	O
saved_ilp	pointer
==	O
NULL	O
)	O
saved_limit	pointer
=	O
saved_ilp	pointer
=	O
(	O
char	O
*	O
)	O
""	pointer
;	O
input_line_pointer	pointer
=	O
buf	pointer
;	O
buffer_limit	pointer
=	O
buf	pointer
+	O
strlen	function
(	O
buf	pointer
)	O
;	O
input_from_string	int
=	O
TRUE	int
;	O
}	O
void	O
restore_ilp	function
(	O
void	O
)	O
{	O
gas_assert	O
(	O
saved_ilp	pointer
!=	O
NULL	O
)	O
;	O
input_line_pointer	pointer
=	O
saved_ilp	pointer
;	O
buffer_limit	pointer
=	O
saved_limit	pointer
;	O
input_from_string	int
=	O
FALSE	int
;	O
saved_ilp	pointer
=	O
NULL	O
;	O
}	O
