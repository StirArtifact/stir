static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: txn.c,v 1.4 2014/04/17 20:27:41 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__txn_begin	function
__P	O
(	O
(	O
DB_TXN	struct
*	O
)	O
)	O
;	O
static	O
int	O
__txn_check_running	function
__P	O
(	O
(	O
const	O
DB_TXN	struct
*	O
,	O
TXN_DETAIL	struct
*	O
*	O
)	O
)	O
;	O
static	O
int	O
__txn_count	function
__P	O
(	O
(	O
DB_TXN	struct
*	O
)	O
)	O
;	O
static	O
void	O
__txn_freekids	function
__P	O
(	O
(	O
DB_TXN	struct
*	O
)	O
)	O
;	O
static	O
void	O
__txn_lsn	function
__P	O
(	O
(	O
DB_TXN	struct
*	O
,	O
DB_LSN	struct
*	O
*	O
)	O
)	O
;	O
static	O
int	O
__txn_makefamily	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
int	O
*	O
,	O
DB_LSN	struct
*	O
*	O
)	O
)	O
;	O
static	O
int	O
__txn_undo	function
__P	O
(	O
(	O
DB_TXN	struct
*	O
)	O
)	O
;	O
int	O
CDB_txn_begin	function
(	O
dbenv	pointer
,	O
parent	pointer
,	O
txnpp	pointer
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_TXN	struct
*	O
parent	pointer
,	O
*	O
*	O
txnpp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_TXN	struct
*	O
txn	pointer
;	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
tx_handle	pointer
,	O
DB_INIT_TXN	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"CDB_txn_begin"	pointer
,	O
flags	int
,	O
DB_TXN_NOWAIT	int
|	O
DB_TXN_NOSYNC	int
|	O
DB_TXN_SYNC	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fcchk	function
(	O
dbenv	pointer
,	O
"CDB_txn_begin"	pointer
,	O
flags	int
,	O
DB_TXN_NOSYNC	int
,	O
DB_TXN_SYNC	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
DB_TXN	struct
)	O
,	O
&	O
txn	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
txn	pointer
->	O
mgrp	pointer
=	O
dbenv	pointer
->	O
tx_handle	pointer
;	O
txn	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
TAILQ_INIT	O
(	O
&	O
txn	pointer
->	O
kids	struct
)	O
;	O
txn	pointer
->	O
flags	int
=	O
TXN_MALLOC	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_TXN_NOSYNC	int
)	O
)	O
F_SET	O
(	O
txn	pointer
,	O
TXN_NOSYNC	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_TXN_SYNC	int
)	O
)	O
F_SET	O
(	O
txn	pointer
,	O
TXN_SYNC	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_TXN_NOWAIT	int
)	O
)	O
F_SET	O
(	O
txn	pointer
,	O
TXN_NOWAIT	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__txn_begin	function
(	O
txn	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___os_free	function
(	O
txn	pointer
,	O
sizeof	O
(	O
DB_TXN	struct
)	O
)	O
;	O
txn	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
txn	pointer
!=	O
NULL	O
&&	O
parent	pointer
!=	O
NULL	O
)	O
TAILQ_INSERT_HEAD	O
(	O
&	O
parent	pointer
->	O
kids	struct
,	O
txn	pointer
,	O
klinks	struct
)	O
;	O
*	O
txnpp	pointer
=	O
txn	pointer
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___txn_xa_begin	function
(	O
dbenv	pointer
,	O
txn	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
{	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
memset	function
(	O
txn	pointer
,	O
0	int
,	O
sizeof	O
(	O
DB_TXN	struct
)	O
)	O
;	O
txn	pointer
->	O
mgrp	pointer
=	O
dbenv	pointer
->	O
tx_handle	pointer
;	O
return	O
(	O
__txn_begin	function
(	O
txn	pointer
)	O
)	O
;	O
}	O
static	O
int	O
__txn_begin	function
(	O
txn	pointer
)	O
DB_TXN	struct
*	O
txn	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LSN	struct
begin_lsn	struct
;	O
DB_TXNMGR	struct
*	O
mgr	pointer
;	O
DB_TXNREGION	struct
*	O
region	pointer
;	O
TXN_DETAIL	struct
*	O
td	pointer
;	O
size_t	long
off	long
;	O
u_int32_t	int
id	int
;	O
int	O
ret	int
;	O
mgr	pointer
=	O
txn	pointer
->	O
mgrp	pointer
;	O
dbenv	pointer
=	O
mgr	pointer
->	O
dbenv	pointer
;	O
region	pointer
=	O
mgr	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB_log_put	function
(	O
dbenv	pointer
,	O
&	O
begin_lsn	struct
,	O
NULL	O
,	O
DB_CURLSN	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err2	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
region	pointer
->	O
last_txnid	int
==	O
TXN_INVALID	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_txn_begin: %s  %s"	pointer
,	O
"Transaction ID wrapping."	pointer
,	O
"Snapshot your database and start a new log."	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err1	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
mgr	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
sizeof	O
(	O
TXN_DETAIL	struct
)	O
,	O
0	int
,	O
&	O
td	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Unable to allocate memory for transaction detail"	pointer
)	O
;	O
goto	O
err1	O
;	O
}	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
region	pointer
->	O
active_txn	struct
,	O
td	pointer
,	O
links	struct
,	O
__txn_detail	struct
)	O
;	O
id	int
=	O
++	O
region	pointer
->	O
last_txnid	int
;	O
++	O
region	pointer
->	O
nbegins	int
;	O
if	O
(	O
++	O
region	pointer
->	O
nactive	int
>	O
region	pointer
->	O
maxnactive	int
)	O
region	pointer
->	O
maxnactive	int
=	O
region	pointer
->	O
nactive	int
;	O
td	pointer
->	O
txnid	int
=	O
id	int
;	O
td	pointer
->	O
begin_lsn	struct
=	O
begin_lsn	struct
;	O
ZERO_LSN	O
(	O
td	pointer
->	O
last_lsn	struct
)	O
;	O
td	pointer
->	O
status	int
=	O
TXN_RUNNING	int
;	O
if	O
(	O
txn	pointer
->	O
parent	pointer
!=	O
NULL	O
)	O
td	pointer
->	O
parent	pointer
=	O
txn	pointer
->	O
parent	pointer
->	O
off	long
;	O
else	O
td	pointer
->	O
parent	pointer
=	O
INVALID_ROFF	int
;	O
off	long
=	O
R_OFFSET	O
(	O
&	O
mgr	pointer
->	O
reginfo	pointer
,	O
td	pointer
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
ZERO_LSN	O
(	O
txn	pointer
->	O
last_lsn	struct
)	O
;	O
txn	pointer
->	O
txnid	int
=	O
id	int
;	O
txn	pointer
->	O
off	long
=	O
off	long
;	O
if	O
(	O
txn	pointer
->	O
parent	pointer
!=	O
NULL	O
&&	O
LOCKING_ON	O
(	O
dbenv	pointer
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___lock_addfamilylocker	function
(	O
dbenv	pointer
,	O
txn	pointer
->	O
parent	pointer
->	O
txnid	int
,	O
txn	pointer
->	O
txnid	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err2	O
;	O
if	O
(	O
F_ISSET	O
(	O
txn	pointer
,	O
TXN_MALLOC	int
)	O
)	O
{	O
MUTEX_THREAD_LOCK	O
(	O
mgr	pointer
->	O
mutexp	pointer
)	O
;	O
TAILQ_INSERT_TAIL	O
(	O
&	O
mgr	pointer
->	O
txn_chain	struct
,	O
txn	pointer
,	O
links	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
mgr	pointer
->	O
mutexp	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
err1	O
:	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
err2	O
:	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_txn_commit	function
(	O
txnp	pointer
,	O
flags	int
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_TXN	struct
*	O
kids	struct
;	O
DB_TXNMGR	struct
*	O
mgr	pointer
;	O
int	O
ret	int
;	O
mgr	pointer
=	O
txnp	pointer
->	O
mgrp	pointer
;	O
dbenv	pointer
=	O
mgr	pointer
->	O
dbenv	pointer
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"CDB_txn_commit"	pointer
,	O
flags	int
,	O
DB_TXN_NOSYNC	int
|	O
DB_TXN_SYNC	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fcchk	function
(	O
dbenv	pointer
,	O
"CDB_txn_commit"	pointer
,	O
flags	int
,	O
DB_TXN_NOSYNC	int
,	O
DB_TXN_SYNC	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__txn_check_running	function
(	O
txnp	pointer
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_TXN_NOSYNC	int
)	O
)	O
{	O
F_CLR	O
(	O
txnp	pointer
,	O
TXN_SYNC	int
)	O
;	O
F_SET	O
(	O
txnp	pointer
,	O
TXN_NOSYNC	int
)	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_TXN_SYNC	int
)	O
)	O
{	O
F_CLR	O
(	O
txnp	pointer
,	O
TXN_NOSYNC	int
)	O
;	O
F_SET	O
(	O
txnp	pointer
,	O
TXN_SYNC	int
)	O
;	O
}	O
for	O
(	O
kids	struct
=	O
TAILQ_FIRST	O
(	O
&	O
txnp	pointer
->	O
kids	struct
)	O
;	O
kids	struct
!=	O
NULL	O
;	O
kids	struct
=	O
TAILQ_NEXT	O
(	O
kids	struct
,	O
klinks	struct
)	O
)	O
if	O
(	O
!	O
F_ISSET	O
(	O
kids	struct
,	O
TXN_CHILDCOMMIT	int
)	O
&&	O
(	O
ret	int
=	O
CDB_txn_commit	function
(	O
kids	struct
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
F_ISSET	O
(	O
txnp	pointer
,	O
TXN_MUSTFLUSH	int
)	O
||	O
!	O
IS_ZERO_LSN	O
(	O
txnp	pointer
->	O
last_lsn	struct
)	O
)	O
)	O
{	O
if	O
(	O
txnp	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
ret	int
=	O
CDB___txn_regop_log	function
(	O
dbenv	pointer
,	O
txnp	pointer
,	O
&	O
txnp	pointer
->	O
last_lsn	struct
,	O
(	O
F_ISSET	O
(	O
mgr	pointer
->	O
dbenv	pointer
,	O
DB_ENV_TXN_NOSYNC	int
)	O
&&	O
!	O
F_ISSET	O
(	O
txnp	pointer
,	O
TXN_SYNC	int
)	O
)	O
||	O
F_ISSET	O
(	O
txnp	pointer
,	O
TXN_NOSYNC	int
)	O
?	O
0	int
:	O
DB_FLUSH	int
,	O
TXN_COMMIT	int
,	O
(	O
int32_t	int
)	O
time	struct
(	O
NULL	O
)	O
)	O
;	O
else	O
{	O
F_SET	O
(	O
txnp	pointer
->	O
parent	pointer
,	O
TXN_MUSTFLUSH	int
)	O
;	O
ret	int
=	O
CDB___txn_child_log	function
(	O
dbenv	pointer
,	O
txnp	pointer
,	O
&	O
txnp	pointer
->	O
last_lsn	struct
,	O
0	int
,	O
TXN_COMMIT	int
,	O
txnp	pointer
->	O
parent	pointer
->	O
txnid	int
)	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
txnp	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
__txn_freekids	function
(	O
txnp	pointer
)	O
;	O
return	O
(	O
CDB___txn_end	function
(	O
txnp	pointer
,	O
1	int
)	O
)	O
;	O
}	O
int	O
CDB_txn_abort	function
(	O
txnp	pointer
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
{	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
txnp	pointer
->	O
mgrp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__txn_check_running	function
(	O
txnp	pointer
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__txn_undo	function
(	O
txnp	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
return	O
(	O
ret	int
)	O
;	O
}	O
return	O
(	O
CDB___txn_end	function
(	O
txnp	pointer
,	O
0	int
)	O
)	O
;	O
}	O
int	O
CDB_txn_prepare	function
(	O
txnp	pointer
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
{	O
DBT	struct
xid	array
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
TXN_DETAIL	struct
*	O
td	pointer
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
txnp	pointer
->	O
mgrp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__txn_check_running	function
(	O
txnp	pointer
,	O
&	O
td	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memset	function
(	O
&	O
xid	array
,	O
0	int
,	O
sizeof	O
(	O
xid	array
)	O
)	O
;	O
xid	array
.	O
data	pointer
=	O
td	pointer
->	O
xid	array
;	O
xid	array
.	O
size	int
=	O
sizeof	O
(	O
td	pointer
->	O
xid	array
)	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB___txn_xa_regop_log	function
(	O
dbenv	pointer
,	O
txnp	pointer
,	O
&	O
txnp	pointer
->	O
last_lsn	struct
,	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_TXN_NOSYNC	int
)	O
&&	O
!	O
F_ISSET	O
(	O
txnp	pointer
,	O
TXN_SYNC	int
)	O
)	O
||	O
F_ISSET	O
(	O
txnp	pointer
,	O
TXN_NOSYNC	int
)	O
?	O
0	int
:	O
DB_FLUSH	int
,	O
TXN_PREPARE	int
,	O
&	O
xid	array
,	O
td	pointer
->	O
format	int
,	O
td	pointer
->	O
gtrid	int
,	O
td	pointer
->	O
bqual	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_txn_prepare: log_write failed %s\n"	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
MUTEX_THREAD_LOCK	O
(	O
txnp	pointer
->	O
mgrp	pointer
->	O
mutexp	pointer
)	O
;	O
td	pointer
->	O
status	int
=	O
TXN_PREPARED	int
;	O
MUTEX_THREAD_UNLOCK	O
(	O
txnp	pointer
->	O
mgrp	pointer
->	O
mutexp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
u_int32_t	int
CDB_txn_id	function
(	O
txnp	pointer
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
{	O
return	O
(	O
txnp	pointer
->	O
txnid	int
)	O
;	O
}	O
static	O
int	O
__txn_check_running	function
(	O
txnp	pointer
,	O
tdp	pointer
)	O
const	O
DB_TXN	struct
*	O
txnp	pointer
;	O
TXN_DETAIL	struct
*	O
*	O
tdp	pointer
;	O
{	O
DB_TXNMGR	struct
*	O
mgrp	pointer
;	O
TXN_DETAIL	struct
*	O
tp	pointer
;	O
tp	pointer
=	O
NULL	O
;	O
mgrp	pointer
=	O
txnp	pointer
->	O
mgrp	pointer
;	O
if	O
(	O
txnp	pointer
!=	O
NULL	O
&&	O
mgrp	pointer
!=	O
NULL	O
&&	O
mgrp	pointer
->	O
reginfo	pointer
.	O
primary	int
!=	O
NULL	O
)	O
{	O
tp	pointer
=	O
(	O
TXN_DETAIL	struct
*	O
)	O
R_ADDR	O
(	O
&	O
mgrp	pointer
->	O
reginfo	pointer
,	O
txnp	pointer
->	O
off	long
)	O
;	O
if	O
(	O
tp	pointer
->	O
status	int
!=	O
TXN_RUNNING	int
&&	O
tp	pointer
->	O
status	int
!=	O
TXN_PREPARED	int
&&	O
tp	pointer
->	O
status	int
!=	O
TXN_COMMITTED	int
)	O
tp	pointer
=	O
NULL	O
;	O
if	O
(	O
tdp	pointer
!=	O
NULL	O
)	O
*	O
tdp	pointer
=	O
tp	pointer
;	O
}	O
return	O
(	O
tp	pointer
==	O
NULL	O
?	O
EINVAL	int
:	O
0	int
)	O
;	O
}	O
int	O
CDB___txn_end	function
(	O
txnp	pointer
,	O
is_commit	int
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
int	O
is_commit	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCKREQ	struct
request	struct
;	O
DB_TXN	struct
*	O
kids	struct
;	O
DB_TXNMGR	struct
*	O
mgr	pointer
;	O
DB_TXNREGION	struct
*	O
region	pointer
;	O
TXN_DETAIL	struct
*	O
tp	pointer
;	O
int	O
ret	int
;	O
mgr	pointer
=	O
txnp	pointer
->	O
mgrp	pointer
;	O
dbenv	pointer
=	O
mgr	pointer
->	O
dbenv	pointer
;	O
region	pointer
=	O
mgr	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
if	O
(	O
!	O
is_commit	int
)	O
{	O
while	O
(	O
(	O
kids	struct
=	O
TAILQ_FIRST	O
(	O
&	O
txnp	pointer
->	O
kids	struct
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___txn_end	function
(	O
kids	struct
,	O
is_commit	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
DB_RUNRECOVERY	O
)	O
;	O
}	O
request	struct
.	O
op	enum
=	O
txnp	pointer
->	O
parent	pointer
==	O
NULL	O
||	O
is_commit	int
==	O
0	int
?	O
DB_LOCK_PUT_ALL	int
:	O
DB_LOCK_INHERIT	int
;	O
if	O
(	O
LOCKING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
ret	int
=	O
CDB_lock_vec	function
(	O
dbenv	pointer
,	O
txnp	pointer
->	O
txnid	int
,	O
0	int
,	O
&	O
request	struct
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
&&	O
(	O
ret	int
!=	O
DB_LOCK_DEADLOCK	O
||	O
is_commit	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: release locks failed %s"	pointer
,	O
is_commit	int
?	O
"CDB_txn_commit"	pointer
:	O
"CDB_txn_abort"	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
tp	pointer
=	O
(	O
TXN_DETAIL	struct
*	O
)	O
R_ADDR	O
(	O
&	O
mgr	pointer
->	O
reginfo	pointer
,	O
txnp	pointer
->	O
off	long
)	O
;	O
if	O
(	O
txnp	pointer
->	O
parent	pointer
==	O
NULL	O
||	O
!	O
is_commit	int
)	O
{	O
SH_TAILQ_REMOVE	O
(	O
&	O
region	pointer
->	O
active_txn	struct
,	O
tp	pointer
,	O
links	struct
,	O
__txn_detail	struct
)	O
;	O
CDB___db_shalloc_free	function
(	O
mgr	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
tp	pointer
)	O
;	O
}	O
else	O
{	O
tp	pointer
->	O
status	int
=	O
TXN_COMMITTED	int
;	O
F_SET	O
(	O
txnp	pointer
,	O
TXN_CHILDCOMMIT	int
)	O
;	O
}	O
if	O
(	O
is_commit	int
)	O
region	pointer
->	O
ncommits	int
++	O
;	O
else	O
region	pointer
->	O
naborts	int
++	O
;	O
--	O
region	pointer
->	O
nactive	int
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
txnp	pointer
->	O
parent	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
LOCKING_ON	O
(	O
dbenv	pointer
)	O
)	O
CDB___lock_freefamilylocker	function
(	O
dbenv	pointer
->	O
lk_handle	pointer
,	O
txnp	pointer
->	O
txnid	int
)	O
;	O
if	O
(	O
!	O
is_commit	int
)	O
TAILQ_REMOVE	O
(	O
&	O
txnp	pointer
->	O
parent	pointer
->	O
kids	struct
,	O
txnp	pointer
,	O
klinks	struct
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
txnp	pointer
,	O
TXN_MALLOC	int
)	O
&&	O
(	O
txnp	pointer
->	O
parent	pointer
==	O
NULL	O
||	O
!	O
is_commit	int
)	O
)	O
{	O
MUTEX_THREAD_LOCK	O
(	O
mgr	pointer
->	O
mutexp	pointer
)	O
;	O
TAILQ_REMOVE	O
(	O
&	O
mgr	pointer
->	O
txn_chain	struct
,	O
txnp	pointer
,	O
links	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
mgr	pointer
->	O
mutexp	pointer
)	O
;	O
CDB___os_free	function
(	O
txnp	pointer
,	O
sizeof	O
(	O
*	O
txnp	pointer
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__txn_undo	function
(	O
txnp	pointer
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
{	O
DBT	struct
rdbt	struct
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LSN	struct
*	O
lsn_array	pointer
,	O
*	O
key_lsnp	pointer
;	O
DB_TXNMGR	struct
*	O
mgr	pointer
;	O
int	O
ntxns	int
,	O
ret	int
,	O
threaded	int
;	O
mgr	pointer
=	O
txnp	pointer
->	O
mgrp	pointer
;	O
dbenv	pointer
=	O
mgr	pointer
->	O
dbenv	pointer
;	O
lsn_array	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
)	O
return	O
(	O
0	int
)	O
;	O
memset	function
(	O
&	O
rdbt	struct
,	O
0	int
,	O
sizeof	O
(	O
rdbt	struct
)	O
)	O
;	O
threaded	int
=	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
threaded	int
)	O
F_SET	O
(	O
&	O
rdbt	struct
,	O
DB_DBT_MALLOC	int
)	O
;	O
key_lsnp	pointer
=	O
&	O
txnp	pointer
->	O
last_lsn	struct
;	O
if	O
(	O
TAILQ_FIRST	O
(	O
&	O
txnp	pointer
->	O
kids	struct
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__txn_makefamily	function
(	O
dbenv	pointer
,	O
txnp	pointer
,	O
&	O
ntxns	int
,	O
&	O
lsn_array	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
key_lsnp	pointer
=	O
&	O
lsn_array	pointer
[	O
0	int
]	O
;	O
}	O
for	O
(	O
ret	int
=	O
0	int
;	O
ret	int
==	O
0	int
&&	O
!	O
IS_ZERO_LSN	O
(	O
*	O
key_lsnp	pointer
)	O
;	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_log_get	function
(	O
dbenv	pointer
,	O
key_lsnp	pointer
,	O
&	O
rdbt	struct
,	O
DB_SET	int
)	O
)	O
==	O
0	int
)	O
{	O
ret	int
=	O
mgr	pointer
->	O
recover	pointer
(	O
dbenv	pointer
,	O
&	O
rdbt	struct
,	O
key_lsnp	pointer
,	O
DB_TXN_ABORT	int
,	O
NULL	O
)	O
;	O
if	O
(	O
threaded	int
&&	O
rdbt	struct
.	O
data	pointer
!=	O
NULL	O
)	O
{	O
CDB___os_free	function
(	O
rdbt	struct
.	O
data	pointer
,	O
rdbt	struct
.	O
size	int
)	O
;	O
rdbt	struct
.	O
data	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
lsn_array	pointer
!=	O
NULL	O
)	O
TXN_BUBBLE	O
(	O
lsn_array	pointer
,	O
ntxns	int
)	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
txnp	pointer
->	O
mgrp	pointer
->	O
dbenv	pointer
,	O
"CDB_txn_abort: Log undo failed for LSN: %lu %lu: %s"	pointer
,	O
(	O
u_long	long
)	O
key_lsnp	pointer
->	O
file	int
,	O
(	O
u_long	long
)	O
key_lsnp	pointer
->	O
offset	long
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_txn_checkpoint	function
(	O
dbenv	pointer
,	O
kbytes	int
,	O
minutes	int
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
kbytes	int
,	O
minutes	int
,	O
flags	int
;	O
{	O
DB_LOG	struct
*	O
dblp	pointer
;	O
DB_LSN	struct
ckp_lsn	struct
,	O
sync_lsn	struct
,	O
last_ckp	struct
;	O
DB_TXNMGR	struct
*	O
mgr	pointer
;	O
DB_TXNREGION	struct
*	O
region	pointer
;	O
LOG	struct
*	O
lp	pointer
;	O
TXN_DETAIL	struct
*	O
txnp	pointer
;	O
time_t	long
last_ckp_time	long
,	O
now	long
;	O
u_int32_t	int
bytes	long
,	O
mbytes	int
;	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
tx_handle	pointer
,	O
DB_INIT_TXN	int
)	O
;	O
mgr	pointer
=	O
dbenv	pointer
->	O
tx_handle	pointer
;	O
region	pointer
=	O
mgr	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
dblp	pointer
=	O
dbenv	pointer
->	O
lg_handle	pointer
;	O
lp	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
ZERO_LSN	O
(	O
ckp_lsn	struct
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_FORCE	int
)	O
)	O
goto	O
do_ckp	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
mbytes	int
=	O
lp	pointer
->	O
stat	pointer
.	O
st_wc_mbytes	int
;	O
bytes	long
=	O
lp	pointer
->	O
stat	pointer
.	O
st_wc_bytes	int
;	O
ckp_lsn	struct
=	O
lp	pointer
->	O
lsn	struct
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
bytes	long
==	O
0	int
&&	O
mbytes	int
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
kbytes	int
!=	O
0	int
&&	O
mbytes	int
*	O
1024	int
+	O
bytes	long
/	O
1024	int
>=	O
(	O
u_int32_t	int
)	O
kbytes	int
)	O
goto	O
do_ckp	O
;	O
if	O
(	O
minutes	int
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
time	struct
(	O
&	O
now	long
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
last_ckp_time	long
=	O
region	pointer
->	O
time_ckp	long
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
now	long
-	O
last_ckp_time	long
>=	O
(	O
time_t	long
)	O
(	O
minutes	int
*	O
60	int
)	O
)	O
goto	O
do_ckp	O
;	O
}	O
if	O
(	O
minutes	int
!=	O
0	int
||	O
kbytes	int
!=	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
do_ckp	O
:	O
if	O
(	O
IS_ZERO_LSN	O
(	O
ckp_lsn	struct
)	O
)	O
{	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
ckp_lsn	struct
=	O
lp	pointer
->	O
lsn	struct
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
}	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
IS_ZERO_LSN	O
(	O
region	pointer
->	O
pending_ckp	struct
)	O
)	O
{	O
for	O
(	O
txnp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
region	pointer
->	O
active_txn	struct
,	O
__txn_detail	struct
)	O
;	O
txnp	pointer
!=	O
NULL	O
;	O
txnp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
txnp	pointer
,	O
links	struct
,	O
__txn_detail	struct
)	O
)	O
{	O
if	O
(	O
!	O
IS_ZERO_LSN	O
(	O
txnp	pointer
->	O
begin_lsn	struct
)	O
&&	O
CDB_log_compare	function
(	O
&	O
txnp	pointer
->	O
begin_lsn	struct
,	O
&	O
ckp_lsn	struct
)	O
<	O
0	int
)	O
ckp_lsn	struct
=	O
txnp	pointer
->	O
begin_lsn	struct
;	O
}	O
region	pointer
->	O
pending_ckp	struct
=	O
ckp_lsn	struct
;	O
}	O
else	O
ckp_lsn	struct
=	O
region	pointer
->	O
pending_ckp	struct
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
sync_lsn	struct
=	O
ckp_lsn	struct
;	O
if	O
(	O
MPOOL_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB_memp_sync	function
(	O
dbenv	pointer
,	O
&	O
sync_lsn	struct
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
>	O
0	int
)	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_txn_checkpoint: system failure in CDB_memp_sync %s\n"	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
last_ckp	struct
=	O
region	pointer
->	O
last_ckp	struct
;	O
ZERO_LSN	O
(	O
region	pointer
->	O
pending_ckp	struct
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___txn_ckp_log	function
(	O
dbenv	pointer
,	O
NULL	O
,	O
&	O
ckp_lsn	struct
,	O
DB_CHECKPOINT	int
,	O
&	O
ckp_lsn	struct
,	O
&	O
last_ckp	struct
,	O
(	O
int32_t	int
)	O
time	struct
(	O
NULL	O
)	O
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_txn_checkpoint: log failed at LSN [%ld %ld] %s\n"	pointer
,	O
(	O
long	O
)	O
ckp_lsn	struct
.	O
file	int
,	O
(	O
long	O
)	O
ckp_lsn	struct
.	O
offset	long
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
region	pointer
->	O
last_ckp	struct
=	O
ckp_lsn	struct
;	O
(	O
void	O
)	O
time	struct
(	O
&	O
region	pointer
->	O
time_ckp	long
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
__txn_freekids	function
(	O
txnp	pointer
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
{	O
DB_TXN	struct
*	O
kids	struct
;	O
DB_TXNMGR	struct
*	O
mgr	pointer
;	O
DB_TXNREGION	struct
*	O
region	pointer
;	O
TXN_DETAIL	struct
*	O
tp	pointer
;	O
mgr	pointer
=	O
txnp	pointer
->	O
mgrp	pointer
;	O
region	pointer
=	O
mgr	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
for	O
(	O
kids	struct
=	O
TAILQ_FIRST	O
(	O
&	O
txnp	pointer
->	O
kids	struct
)	O
;	O
kids	struct
!=	O
NULL	O
;	O
kids	struct
=	O
TAILQ_FIRST	O
(	O
&	O
txnp	pointer
->	O
kids	struct
)	O
)	O
{	O
__txn_freekids	function
(	O
kids	struct
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
tp	pointer
=	O
(	O
TXN_DETAIL	struct
*	O
)	O
R_ADDR	O
(	O
&	O
mgr	pointer
->	O
reginfo	pointer
,	O
kids	struct
->	O
off	long
)	O
;	O
SH_TAILQ_REMOVE	O
(	O
&	O
region	pointer
->	O
active_txn	struct
,	O
tp	pointer
,	O
links	struct
,	O
__txn_detail	struct
)	O
;	O
CDB___db_shalloc_free	function
(	O
mgr	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
tp	pointer
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
mgr	pointer
->	O
reginfo	pointer
)	O
;	O
TAILQ_REMOVE	O
(	O
&	O
txnp	pointer
->	O
kids	struct
,	O
kids	struct
,	O
klinks	struct
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
txnp	pointer
,	O
TXN_MALLOC	int
)	O
)	O
{	O
MUTEX_THREAD_LOCK	O
(	O
mgr	pointer
->	O
mutexp	pointer
)	O
;	O
TAILQ_REMOVE	O
(	O
&	O
mgr	pointer
->	O
txn_chain	struct
,	O
kids	struct
,	O
links	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
mgr	pointer
->	O
mutexp	pointer
)	O
;	O
CDB___os_free	function
(	O
kids	struct
,	O
sizeof	O
(	O
*	O
kids	struct
)	O
)	O
;	O
}	O
}	O
}	O
static	O
int	O
__txn_makefamily	function
(	O
dbenv	pointer
,	O
txnp	pointer
,	O
np	pointer
,	O
arrayp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_TXN	struct
*	O
txnp	pointer
;	O
int	O
*	O
np	pointer
;	O
DB_LSN	struct
*	O
*	O
arrayp	pointer
;	O
{	O
DB_LSN	struct
*	O
ap	array
,	O
*	O
tmpp	pointer
;	O
int	O
i	int
,	O
ret	int
;	O
*	O
np	pointer
=	O
__txn_count	function
(	O
txnp	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
*	O
np	pointer
*	O
sizeof	O
(	O
DB_LSN	struct
)	O
,	O
NULL	O
,	O
arrayp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
tmpp	pointer
=	O
*	O
arrayp	pointer
;	O
__txn_lsn	function
(	O
txnp	pointer
,	O
&	O
tmpp	pointer
)	O
;	O
ap	array
=	O
*	O
arrayp	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
np	pointer
;	O
i	int
++	O
)	O
TXN_BUBBLE	O
(	O
ap	array
,	O
*	O
np	pointer
-	O
i	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__txn_count	function
(	O
txnp	pointer
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
{	O
DB_TXN	struct
*	O
kids	struct
;	O
int	O
n	int
;	O
n	int
=	O
1	int
;	O
for	O
(	O
kids	struct
=	O
TAILQ_FIRST	O
(	O
&	O
txnp	pointer
->	O
kids	struct
)	O
;	O
kids	struct
!=	O
NULL	O
;	O
kids	struct
=	O
TAILQ_NEXT	O
(	O
kids	struct
,	O
klinks	struct
)	O
)	O
n	int
+=	O
__txn_count	function
(	O
kids	struct
)	O
;	O
return	O
(	O
n	int
)	O
;	O
}	O
static	O
void	O
__txn_lsn	function
(	O
txnp	pointer
,	O
array	pointer
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
DB_LSN	struct
*	O
*	O
array	pointer
;	O
{	O
DB_LSN	struct
*	O
lsn	struct
;	O
DB_TXN	struct
*	O
kids	struct
;	O
lsn	struct
=	O
*	O
array	pointer
;	O
lsn	struct
[	O
0	int
]	O
=	O
txnp	pointer
->	O
last_lsn	struct
;	O
*	O
array	pointer
=	O
&	O
lsn	struct
[	O
1	int
]	O
;	O
for	O
(	O
kids	struct
=	O
TAILQ_FIRST	O
(	O
&	O
txnp	pointer
->	O
kids	struct
)	O
;	O
kids	struct
!=	O
NULL	O
;	O
kids	struct
=	O
TAILQ_NEXT	O
(	O
kids	struct
,	O
klinks	struct
)	O
)	O
__txn_lsn	function
(	O
kids	struct
,	O
array	pointer
)	O
;	O
}	O
int	O
CDB___txn_activekids	function
(	O
txnp	pointer
)	O
DB_TXN	struct
*	O
txnp	pointer
;	O
{	O
DB_TXN	struct
*	O
kids	struct
;	O
for	O
(	O
kids	struct
=	O
TAILQ_FIRST	O
(	O
&	O
txnp	pointer
->	O
kids	struct
)	O
;	O
kids	struct
!=	O
NULL	O
;	O
kids	struct
=	O
TAILQ_NEXT	O
(	O
kids	struct
,	O
klinks	struct
)	O
)	O
if	O
(	O
!	O
F_ISSET	O
(	O
kids	struct
,	O
TXN_CHILDCOMMIT	int
)	O
)	O
return	O
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
