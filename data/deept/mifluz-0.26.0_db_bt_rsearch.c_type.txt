static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: bt_rsearch.c,v 1.3 2000/06/28 16:47:00 loic Exp $"	pointer
;	O
int	O
CDB___bam_rsearch	function
(	O
dbc	pointer
,	O
recnop	pointer
,	O
flags	int
,	O
stop	int
,	O
exactp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
*	O
recnop	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
stop	int
,	O
*	O
exactp	pointer
;	O
{	O
BINTERNAL	struct
*	O
bi	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
lock	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
RINTERNAL	struct
*	O
ri	pointer
;	O
db_indx_t	short
adjust	int
,	O
deloffset	short
,	O
indx	short
,	O
top	short
;	O
db_lockmode_t	enum
lock_mode	enum
;	O
db_pgno_t	int
pg	struct
;	O
db_recno_t	int
recno	int
,	O
t_recno	int
,	O
total	int
;	O
int	O
ret	int
,	O
stack	array
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
BT_STK_CLR	O
(	O
cp	pointer
)	O
;	O
pg	struct
=	O
cp	pointer
->	O
root	int
;	O
stack	array
=	O
LF_ISSET	O
(	O
S_STACK	int
)	O
;	O
lock_mode	enum
=	O
stack	array
?	O
DB_LOCK_WRITE	int
:	O
DB_LOCK_READ	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
!	O
stack	array
&&	O
(	O
(	O
LF_ISSET	O
(	O
S_PARENT	int
)	O
&&	O
(	O
u_int8_t	char
)	O
(	O
stop	int
+	O
1	int
)	O
>=	O
h	pointer
->	O
level	char
)	O
||	O
(	O
LF_ISSET	O
(	O
S_WRITE	int
)	O
&&	O
h	pointer
->	O
level	char
==	O
LEAFLEVEL	int
)	O
)	O
)	O
{	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
stack	array
=	O
1	int
;	O
}	O
total	int
=	O
RE_NREC	O
(	O
h	pointer
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
S_APPEND	int
)	O
)	O
{	O
*	O
exactp	pointer
=	O
0	int
;	O
*	O
recnop	pointer
=	O
recno	int
=	O
total	int
+	O
1	int
;	O
}	O
else	O
{	O
recno	int
=	O
*	O
recnop	pointer
;	O
if	O
(	O
recno	int
<=	O
total	int
)	O
*	O
exactp	pointer
=	O
1	int
;	O
else	O
{	O
*	O
exactp	pointer
=	O
0	int
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
S_PAST_EOF	int
)	O
||	O
recno	int
>	O
total	int
+	O
1	int
)	O
{	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
total	int
=	O
0	int
;	O
;	O
)	O
{	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
recno	int
-=	O
total	int
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
)	O
{	O
adjust	int
=	O
P_INDX	int
;	O
deloffset	short
=	O
O_INDX	int
;	O
}	O
else	O
{	O
adjust	int
=	O
O_INDX	int
;	O
deloffset	short
=	O
0	int
;	O
}	O
for	O
(	O
t_recno	int
=	O
0	int
,	O
indx	short
=	O
0	int
;	O
;	O
indx	short
+=	O
adjust	int
)	O
{	O
if	O
(	O
indx	short
>=	O
NUM_ENT	O
(	O
h	pointer
)	O
)	O
{	O
*	O
exactp	pointer
=	O
0	int
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
S_PAST_EOF	int
)	O
||	O
recno	int
>	O
t_recno	int
+	O
1	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
!	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
deloffset	short
)	O
->	O
type	enum
)	O
&&	O
++	O
t_recno	int
==	O
recno	int
)	O
break	O
;	O
}	O
BT_STK_ENTER	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
lock	struct
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
return	O
(	O
0	int
)	O
;	O
case	O
P_IBTREE	int
:	O
for	O
(	O
indx	short
=	O
0	int
,	O
top	short
=	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
;	O
)	O
{	O
bi	pointer
=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
indx	short
)	O
;	O
if	O
(	O
++	O
indx	short
==	O
top	short
||	O
total	int
+	O
bi	pointer
->	O
nrecs	int
>=	O
recno	int
)	O
break	O
;	O
total	int
+=	O
bi	pointer
->	O
nrecs	int
;	O
}	O
pg	struct
=	O
bi	pointer
->	O
pgno	int
;	O
break	O
;	O
case	O
P_LRECNO	int
:	O
recno	int
-=	O
total	int
;	O
--	O
recno	int
;	O
BT_STK_ENTER	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
recno	int
,	O
lock	struct
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
return	O
(	O
0	int
)	O
;	O
case	O
P_IRECNO	int
:	O
for	O
(	O
indx	short
=	O
0	int
,	O
top	short
=	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
;	O
)	O
{	O
ri	pointer
=	O
GET_RINTERNAL	O
(	O
h	pointer
,	O
indx	short
)	O
;	O
if	O
(	O
++	O
indx	short
==	O
top	short
||	O
total	int
+	O
ri	pointer
->	O
nrecs	int
>=	O
recno	int
)	O
break	O
;	O
total	int
+=	O
ri	pointer
->	O
nrecs	int
;	O
}	O
pg	struct
=	O
ri	pointer
->	O
pgno	int
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
h	pointer
->	O
pgno	int
)	O
)	O
;	O
}	O
--	O
indx	short
;	O
if	O
(	O
stack	array
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
S_PARENT	int
)	O
&&	O
stop	int
==	O
h	pointer
->	O
level	char
)	O
{	O
BT_STK_ENTER	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
lock	struct
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
BT_STK_PUSH	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
lock	struct
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
{	O
if	O
(	O
(	O
LF_ISSET	O
(	O
S_PARENT	int
)	O
&&	O
(	O
u_int8_t	char
)	O
(	O
stop	int
+	O
1	int
)	O
>=	O
(	O
u_int8_t	char
)	O
(	O
h	pointer
->	O
level	char
-	O
1	int
)	O
)	O
||	O
(	O
h	pointer
->	O
level	char
-	O
1	int
)	O
==	O
LEAFLEVEL	int
)	O
stack	array
=	O
1	int
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
lock_mode	enum
=	O
stack	array
&&	O
LF_ISSET	O
(	O
S_WRITE	int
)	O
?	O
DB_LOCK_WRITE	int
:	O
DB_LOCK_READ	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
LCK_COUPLE	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
{	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
BT_STK_POP	O
(	O
cp	pointer
)	O
;	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_adjust	function
(	O
dbc	pointer
,	O
adjust	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
int32_t	int
adjust	int
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
EPG	struct
*	O
epg	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
root_pgno	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
root_pgno	int
=	O
cp	pointer
->	O
root	int
;	O
for	O
(	O
epg	pointer
=	O
cp	pointer
->	O
sp	pointer
;	O
epg	pointer
<=	O
cp	pointer
->	O
csp	pointer
;	O
++	O
epg	pointer
)	O
{	O
h	pointer
=	O
epg	pointer
->	O
page	pointer
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
||	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IRECNO	int
)	O
{	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB___bam_cadjust_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
h	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
h	pointer
)	O
,	O
&	O
LSN	O
(	O
h	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
epg	pointer
->	O
indx	short
,	O
adjust	int
,	O
PGNO	O
(	O
h	pointer
)	O
==	O
root_pgno	int
?	O
CAD_UPDATEROOT	int
:	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
)	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
epg	pointer
->	O
indx	short
)	O
->	O
nrecs	int
+=	O
adjust	int
;	O
else	O
GET_RINTERNAL	O
(	O
h	pointer
,	O
epg	pointer
->	O
indx	short
)	O
->	O
nrecs	int
+=	O
adjust	int
;	O
if	O
(	O
PGNO	O
(	O
h	pointer
)	O
==	O
root_pgno	int
)	O
RE_NREC_ADJ	O
(	O
h	pointer
,	O
adjust	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fset	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___bam_nrecs	function
(	O
dbc	pointer
,	O
rep	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
*	O
rep	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
lock	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
pgno	int
=	O
dbc	pointer
->	O
internal	pointer
->	O
root	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pgno	int
,	O
DB_LOCK_READ	int
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
*	O
rep	pointer
=	O
RE_NREC	O
(	O
h	pointer
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
db_recno_t	int
CDB___bam_total	function
(	O
h	pointer
)	O
PAGE	struct
*	O
h	pointer
;	O
{	O
db_recno_t	int
nrecs	int
;	O
db_indx_t	short
indx	short
,	O
top	short
;	O
nrecs	int
=	O
0	int
;	O
top	short
=	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_LBTREE	int
:	O
for	O
(	O
indx	short
=	O
0	int
;	O
indx	short
<	O
top	short
;	O
indx	short
+=	O
P_INDX	int
)	O
if	O
(	O
!	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
O_INDX	int
)	O
->	O
type	enum
)	O
)	O
++	O
nrecs	int
;	O
break	O
;	O
case	O
P_LDUP	int
:	O
for	O
(	O
indx	short
=	O
0	int
;	O
indx	short
<	O
top	short
;	O
indx	short
+=	O
O_INDX	int
)	O
if	O
(	O
!	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
)	O
->	O
type	enum
)	O
)	O
++	O
nrecs	int
;	O
break	O
;	O
case	O
P_IBTREE	int
:	O
for	O
(	O
indx	short
=	O
0	int
;	O
indx	short
<	O
top	short
;	O
indx	short
+=	O
O_INDX	int
)	O
nrecs	int
+=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
indx	short
)	O
->	O
nrecs	int
;	O
break	O
;	O
case	O
P_LRECNO	int
:	O
nrecs	int
=	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
break	O
;	O
case	O
P_IRECNO	int
:	O
for	O
(	O
indx	short
=	O
0	int
;	O
indx	short
<	O
top	short
;	O
indx	short
+=	O
O_INDX	int
)	O
nrecs	int
+=	O
GET_RINTERNAL	O
(	O
h	pointer
,	O
indx	short
)	O
->	O
nrecs	int
;	O
break	O
;	O
}	O
return	O
(	O
nrecs	int
)	O
;	O
}	O
