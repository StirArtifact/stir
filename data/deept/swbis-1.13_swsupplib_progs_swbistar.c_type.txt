static	O
int	O
HN	int
=	O
0	int
;	O
static	O
void	O
usage	function
(	O
char	O
*	O
name	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : A testing and administrative tool of the swbis project.\n"	pointer
,	O
name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s [options] [directory [directory..]]\n"	pointer
,	O
name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Writes a tar archive to stdout.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Default format is identical to GNU tar cf - -b1 --posix\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"         for filenames <= 99 chars.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Option '-L' extends identicalness to filenames >99 chars.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Option `-a' produces an archive identical to ''pax -w -d -b 512 | ./swbistar -X''\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Options:\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  --help  Show this help.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -X, --pax-rdev-filter  reads tar archive on stdin and normalizes\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                         st_rdev values of non-device files to zero.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -I,--tar2tar tar to tar filter with decoding and re-writing.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -G,--tarheaderflags N  See taru/taru.h for values.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_BE_LIKE_PAX = %d\n"	pointer
,	O
TARU_TAR_BE_LIKE_PAX	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_NUMERIC_UIDS = %d\n"	pointer
,	O
TARU_TAR_NUMERIC_UIDS	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_GNU_LONG_LINKS = %d\n"	pointer
,	O
TARU_TAR_GNU_LONG_LINKS	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_GNU_GNUTAR = %d\n"	pointer
,	O
TARU_TAR_GNU_GNUTAR	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_GNU_BLOCKSIZE_B1 = %d\n"	pointer
,	O
TARU_TAR_GNU_BLOCKSIZE_B1	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_BE_LIKE_STAR = %d\n"	pointer
,	O
TARU_TAR_BE_LIKE_STAR	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_FRAGILE_FORMAT = %d\n"	pointer
,	O
TARU_TAR_FRAGILE_FORMAT	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_PAXEXTHDR = %d\n"	pointer
,	O
TARU_TAR_PAXEXTHDR	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     TARU_TAR_PAXEXTHDR_MD = %d\n"	pointer
,	O
TARU_TAR_PAXEXTHDR_MD	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -D,--debug-dump  An ascii dump of the the tar headers.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -F,--file-list-only  Write the file list to stdout.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -L,--gnu-long-links  Store long file names like GNU tar. (non-POSIX).\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -H,--format  {ustar|gnutar|newc|crc|odc|ustar.star} ustar is the default.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                ustar  IEEE Std 1003.1  Posix format. same as GNU tar 1.15.1\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                ustar0  IEEE Std 1003.1  same as GNU tar 1.13.25 --posix -b1\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                        for short path names.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                gnutar GNU tar 1.13.17 default format using -b1 option.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                oldgnu   same as GNU tar 1.13.25\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                ustar.star  Identical to star 1.5a04 using -b=1 -H=ustar.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"                gnu   same as GNU tar 1.15.1\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     --owner=NAME  Same as tar GNU tar option.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"     --group=NAME  Same as tar GNU tar option.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -x,--numeric-owner  Same as tar GNU tar option.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"  -a,--be-like-pax   Writes a format identical to pax v3.0.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"--oldgnu-namesize  mimics 1.13.25 name size split.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"--gnu-namesize  mimics 1.15.1 name size split.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Copyright (C) 2003 Jim Lowe\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Report bugs to jhlowe@acm.org\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"This program is distributed under the GNU GPL Software License.\n"	pointer
)	O
;	O
}	O
static	O
unsigned	O
long	O
mychecksum	function
(	O
void	O
*	O
tar_hdr	pointer
,	O
int	O
len	long
)	O
{	O
unsigned	O
long	O
sum	long
=	O
0	int
;	O
char	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
tar_hdr	pointer
;	O
char	O
*	O
q	pointer
=	O
p	pointer
+	O
len	long
;	O
while	O
(	O
p	pointer
<	O
q	pointer
)	O
sum	long
+=	O
*	O
p	pointer
++	O
&	O
0xff	int
;	O
return	O
sum	long
;	O
}	O
static	O
void	O
tr_char	function
(	O
void	O
*	O
src	pointer
,	O
int	O
len	long
,	O
int	O
new	int
,	O
int	O
old	int
)	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
*	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
src	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
int	O
)	O
(	O
*	O
p	pointer
)	O
==	O
old	int
)	O
*	O
(	O
p	pointer
)	O
=	O
(	O
unsigned	O
char	O
)	O
new	int
;	O
p	pointer
++	O
;	O
}	O
}	O
static	O
void	O
write_field	function
(	O
struct	O
new_cpio_header	struct
*	O
hdr	pointer
,	O
int	O
verbose	int
,	O
STROB	struct
*	O
wf	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
paxheader_annotation	pointer
,	O
char	O
*	O
annotation_prefix	pointer
,	O
unsigned	O
char	O
*	O
tarheader	pointer
,	O
int	O
thboffset	int
,	O
int	O
buflen	int
,	O
char	O
*	O
fieldname	pointer
)	O
{	O
char	O
*	O
unctimeme	pointer
;	O
unsigned	O
int	O
uitmp	int
;	O
unsigned	O
char	O
*	O
buf	pointer
=	O
tarheader	pointer
+	O
thboffset	int
;	O
int	O
ap_len	int
=	O
strlen	function
(	O
annotation_prefix	pointer
)	O
;	O
int	O
paxap_len	int
=	O
strlen	function
(	O
paxheader_annotation	pointer
)	O
;	O
if	O
(	O
verbose	int
)	O
tr_char	function
(	O
(	O
void	O
*	O
)	O
buf	pointer
,	O
buflen	int
,	O
(	O
int	O
)	O
'^'	O
,	O
(	O
int	O
)	O
'\000'	O
)	O
;	O
if	O
(	O
verbose	int
>	O
1	int
)	O
{	O
write	pointer
(	O
ofd	int
,	O
(	O
void	O
*	O
)	O
paxheader_annotation	pointer
,	O
(	O
size_t	long
)	O
paxap_len	int
)	O
;	O
write	pointer
(	O
ofd	int
,	O
(	O
void	O
*	O
)	O
annotation_prefix	pointer
,	O
(	O
size_t	long
)	O
ap_len	int
)	O
;	O
swlib_writef	function
(	O
ofd	int
,	O
wf	pointer
,	O
" "	pointer
)	O
;	O
}	O
if	O
(	O
verbose	int
>	O
0	int
)	O
{	O
swlib_writef	function
(	O
ofd	int
,	O
wf	pointer
,	O
"[%d] %-12s["	pointer
,	O
HN	int
,	O
fieldname	pointer
)	O
;	O
}	O
else	O
{	O
swlib_writef	function
(	O
ofd	int
,	O
wf	pointer
,	O
"[%d] %s:=["	pointer
,	O
HN	int
,	O
fieldname	pointer
)	O
;	O
}	O
write	pointer
(	O
ofd	int
,	O
(	O
void	O
*	O
)	O
buf	pointer
,	O
(	O
size_t	long
)	O
buflen	int
)	O
;	O
write	pointer
(	O
ofd	int
,	O
"]"	pointer
,	O
1	int
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
switch	O
(	O
thboffset	int
)	O
{	O
case	O
THB_BO_uid	int
:	O
case	O
THB_BO_gid	int
:	O
case	O
THB_BO_size	int
:	O
case	O
THB_BO_devmajor	int
:	O
case	O
THB_BO_devminor	int
:	O
uitmp	int
=	O
0	int
;	O
if	O
(	O
sscanf	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
"%o"	pointer
,	O
&	O
uitmp	int
)	O
==	O
1	int
)	O
{	O
swlib_writef	function
(	O
ofd	int
,	O
wf	pointer
,	O
" (%d)"	pointer
,	O
(	O
int	O
)	O
uitmp	int
)	O
;	O
}	O
break	O
;	O
case	O
THB_BO_mtime	int
:	O
uitmp	int
=	O
0	int
;	O
if	O
(	O
sscanf	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
"%o"	pointer
,	O
&	O
uitmp	int
)	O
==	O
1	int
)	O
{	O
unctimeme	pointer
=	O
ctime	function
(	O
(	O
time_t	long
*	O
)	O
(	O
&	O
uitmp	int
)	O
)	O
;	O
unctimeme	pointer
[	O
strlen	function
(	O
unctimeme	pointer
)	O
-	O
2	int
]	O
=	O
'\0'	O
;	O
swlib_writef	function
(	O
ofd	int
,	O
wf	pointer
,	O
" (%d) (%s)"	pointer
,	O
(	O
int	O
)	O
uitmp	int
,	O
unctimeme	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
write	pointer
(	O
ofd	int
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
write_header_decode_format	function
(	O
struct	O
new_cpio_header	struct
*	O
hdr	pointer
,	O
STROB	struct
*	O
wf	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
buf	pointer
,	O
int	O
buflen	int
,	O
int	O
v	int
)	O
{	O
char	O
*	O
p	pointer
;	O
unsigned	O
char	O
*	O
paxheader	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
;	O
char	O
paxSum	array
[	O
100	int
]	O
;	O
uintmax_t	long
sum	long
;	O
char	O
Mchksum	array
[	O
THB_FL_chksum	int
+	O
1	int
]	O
;	O
int	O
termch	int
=	O
' '	O
;	O
sum	long
=	O
mychecksum	function
(	O
paxheader	pointer
,	O
buflen	int
)	O
;	O
memset	function
(	O
paxSum	array
,	O
'\0'	O
,	O
sizeof	O
(	O
paxSum	array
)	O
)	O
;	O
uintmax_to_chars	function
(	O
sum	long
,	O
paxSum	array
,	O
7	int
,	O
POSIX_FORMAT	int
,	O
termch	int
)	O
;	O
strncpy	function
(	O
Mchksum	array
,	O
buf	pointer
+	O
THB_BO_chksum	int
,	O
sizeof	O
(	O
Mchksum	array
)	O
)	O
;	O
if	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
Mchksum	array
,	O
' '	O
)	O
)	O
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
Mchksum	array
[	O
THB_FL_chksum	int
]	O
=	O
'\0'	O
;	O
swlib_writef	function
(	O
ofd	int
,	O
wf	pointer
,	O
"[%d] Extended name=[%s]\n"	pointer
,	O
HN	int
,	O
ahsStaticGetTarFilename	function
(	O
hdr	pointer
)	O
)	O
;	O
swlib_writef	function
(	O
ofd	int
,	O
wf	pointer
,	O
"[%d] Extended linkname=[%s]\n"	pointer
,	O
HN	int
,	O
ahsStaticGetTarLinkname	function
(	O
hdr	pointer
)	O
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_name	int
,	O
THB_FL_name	int
,	O
"name"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_mode	int
,	O
THB_FL_mode	int
,	O
"mode"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_uid	int
,	O
THB_FL_uid	int
,	O
"uid"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_gid	int
,	O
THB_FL_gid	int
,	O
"gid"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_size	int
,	O
THB_FL_size	int
,	O
"size"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_mtime	int
,	O
THB_FL_mtime	int
,	O
"mtime"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_chksum	int
,	O
THB_FL_chksum	int
,	O
"chksum"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_typeflag	int
,	O
THB_FL_typeflag	int
,	O
"typeflag"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_linkname	int
,	O
THB_FL_linkname	int
,	O
"linkname"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_magic	int
,	O
THB_FL_magic	int
,	O
"magic"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_version	int
,	O
THB_FL_version	int
,	O
"version"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_uname	int
,	O
THB_FL_uname	int
,	O
"uname"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_gname	int
,	O
THB_FL_gname	int
,	O
"gname"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_devmajor	int
,	O
THB_FL_devmajor	int
,	O
"devmajor"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_devminor	int
,	O
THB_FL_devminor	int
,	O
"devminor"	pointer
)	O
;	O
write_field	function
(	O
hdr	pointer
,	O
v	int
,	O
wf	pointer
,	O
ofd	int
,	O
paxSum	array
,	O
Mchksum	array
,	O
paxheader	pointer
,	O
THB_BO_prefix	int
,	O
THB_FL_prefix	int
,	O
"prefix"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
decode_filter	function
(	O
XFORMAT	struct
*	O
package	pointer
,	O
int	O
ifd	int
,	O
int	O
verbose	int
)	O
{	O
int	O
nullfd	int
;	O
char	O
*	O
name	pointer
;	O
int	O
ret	int
;	O
int	O
aret	int
;	O
int	O
retval	int
=	O
-	O
1	int
;	O
int	O
ofd	int
;	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
;	O
STROB	struct
*	O
namebuf	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
extended_header	pointer
;	O
int	O
tarheader_length	int
;	O
struct	O
new_cpio_header	struct
*	O
hdr	pointer
;	O
nullfd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
)	O
;	O
file_hdr	pointer
=	O
(	O
struct	O
new_cpio_header	struct
*	O
)	O
(	O
xformat_vfile_hdr	function
(	O
package	pointer
)	O
)	O
;	O
namebuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
ifd	int
=	O
STDIN_FILENO	int
;	O
xformat_set_ifd	function
(	O
package	pointer
,	O
ifd	int
)	O
;	O
ofd	int
=	O
nullfd	int
;	O
xformat_set_ofd	function
(	O
package	pointer
,	O
ofd	int
)	O
;	O
package	pointer
->	O
taruM	pointer
->	O
do_record_headerM	int
=	O
1	int
;	O
taruib_set_fd	function
(	O
nullfd	int
)	O
;	O
retval	int
=	O
1	int
;	O
hdr	pointer
=	O
(	O
struct	O
new_cpio_header	struct
*	O
)	O
(	O
xformat_vfile_hdr	function
(	O
package	pointer
)	O
)	O
;	O
while	O
(	O
(	O
ret	int
=	O
xformat_read_header	function
(	O
package	pointer
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
package	pointer
)	O
)	O
{	O
retval	int
=	O
0	int
;	O
break	O
;	O
}	O
xformat_get_name	function
(	O
package	pointer
,	O
namebuf	pointer
)	O
;	O
name	pointer
=	O
strob_str	function
(	O
namebuf	pointer
)	O
;	O
extended_header	pointer
=	O
strob_str	function
(	O
package	pointer
->	O
taruM	pointer
->	O
headerM	pointer
)	O
;	O
tarheader_length	int
=	O
package	pointer
->	O
taruM	pointer
->	O
header_lengthM	int
;	O
write_header_decode_format	function
(	O
hdr	pointer
,	O
tmp	pointer
,	O
STDOUT_FILENO	int
,	O
extended_header	pointer
,	O
tarheader_length	int
,	O
verbose	int
)	O
;	O
taruib_clear_buffer	function
(	O
)	O
;	O
aret	int
=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
ofd	int
,	O
ifd	int
)	O
;	O
if	O
(	O
aret	int
<	O
0	int
)	O
goto	O
error	O
;	O
retval	int
=	O
0	int
;	O
HN	int
++	O
;	O
}	O
taruib_clear_buffer	function
(	O
)	O
;	O
ret	int
=	O
taru_pump_amount2	function
(	O
ofd	int
,	O
ifd	int
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis: error in taruib_arfcopy\n"	pointer
)	O
;	O
retval	int
=	O
2	int
;	O
}	O
error	O
:	O
taruib_clear_buffer	function
(	O
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
close	pointer
(	O
nullfd	int
)	O
;	O
return	O
retval	int
;	O
}	O
static	O
int	O
paxfilter	function
(	O
void	O
)	O
{	O
int	O
nullblockcount	int
=	O
0	int
;	O
uintmax_t	long
nblocks	int
;	O
uintmax_t	long
i	int
;	O
int	O
ret	int
=	O
0	int
;	O
int	O
rret	int
=	O
0	int
;	O
char	O
buf	pointer
[	O
512	int
]	O
;	O
char	O
nullblock	array
[	O
512	int
]	O
;	O
char	O
devstring	array
[	O
]	O
=	O
"0000000"	pointer
;	O
uintmax_t	long
filesize	long
;	O
unsigned	O
long	O
sum	long
;	O
memset	function
(	O
nullblock	array
,	O
'\0'	O
,	O
512	int
)	O
;	O
while	O
(	O
ret	int
==	O
0	int
&&	O
(	O
rret	int
=	O
uxfio_unix_safe_atomic_read	function
(	O
STDIN_FILENO	int
,	O
buf	pointer
,	O
512	int
)	O
)	O
==	O
512	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
buf	pointer
,	O
nullblock	array
,	O
512	int
)	O
==	O
0	int
)	O
{	O
nullblockcount	int
++	O
;	O
if	O
(	O
nullblockcount	int
>=	O
2	int
)	O
{	O
write	pointer
(	O
STDOUT_FILENO	int
,	O
nullblock	array
,	O
512	int
)	O
;	O
swlib_pipe_pump	function
(	O
STDOUT_FILENO	int
,	O
STDIN_FILENO	int
)	O
;	O
break	O
;	O
}	O
else	O
{	O
write	pointer
(	O
STDOUT_FILENO	int
,	O
nullblock	array
,	O
512	int
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
strncmp	function
(	O
buf	pointer
+	O
257	int
,	O
"ustar"	pointer
,	O
5	int
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"tar format not recognized.\n"	pointer
)	O
;	O
ret	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
(	O
buf	pointer
+	O
156	int
)	O
!=	O
CHRTYPE	char
&&	O
*	O
(	O
buf	pointer
+	O
156	int
)	O
!=	O
BLKTYPE	char
)	O
{	O
strcpy	function
(	O
buf	pointer
+	O
329	int
,	O
devstring	array
)	O
;	O
strcpy	function
(	O
buf	pointer
+	O
337	int
,	O
devstring	array
)	O
;	O
memcpy	function
(	O
buf	pointer
+	O
148	int
,	O
CHKBLANKS	pointer
,	O
8	int
)	O
;	O
sum	long
=	O
taru_tar_checksum	function
(	O
(	O
void	O
*	O
)	O
buf	pointer
)	O
;	O
uintmax_to_chars	function
(	O
sum	long
,	O
buf	pointer
+	O
148	int
,	O
8	int
,	O
POSIX_FORMAT	int
,	O
0	int
)	O
;	O
}	O
write	pointer
(	O
STDOUT_FILENO	int
,	O
buf	pointer
,	O
512	int
)	O
;	O
if	O
(	O
*	O
(	O
buf	pointer
+	O
156	int
)	O
==	O
REGTYPE	char
)	O
{	O
taru_otoumax	function
(	O
buf	pointer
+	O
124	int
,	O
&	O
filesize	long
)	O
;	O
i	int
=	O
0	int
;	O
nblocks	int
=	O
0	int
;	O
if	O
(	O
filesize	long
)	O
{	O
nblocks	int
=	O
filesize	long
/	O
512	int
;	O
if	O
(	O
filesize	long
%	O
512	int
)	O
nblocks	int
++	O
;	O
while	O
(	O
i	int
<	O
nblocks	int
)	O
{	O
ret	int
=	O
uxfio_unix_safe_atomic_read	function
(	O
STDIN_FILENO	int
,	O
buf	pointer
,	O
512	int
)	O
;	O
if	O
(	O
ret	int
!=	O
512	int
)	O
{	O
ret	int
=	O
2	int
;	O
break	O
;	O
}	O
write	pointer
(	O
STDOUT_FILENO	int
,	O
buf	pointer
,	O
512	int
)	O
;	O
i	int
++	O
;	O
}	O
ret	int
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
ret	int
==	O
0	int
&&	O
rret	int
==	O
512	int
)	O
ret	int
=	O
0	int
;	O
return	O
ret	int
;	O
}	O
static	O
char	O
*	O
getnextpath	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
char	O
*	O
ret	int
;	O
static	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
char	O
*	O
s	pointer
;	O
ret	int
=	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fp	pointer
)	O
;	O
if	O
(	O
!	O
ret	int
)	O
return	O
ret	int
;	O
buf	pointer
[	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
s	pointer
=	O
strrchr	function
(	O
buf	pointer
,	O
'\n'	O
)	O
)	O
)	O
*	O
s	pointer
=	O
'\0'	O
;	O
if	O
(	O
(	O
s	pointer
=	O
strrchr	function
(	O
buf	pointer
,	O
'\r'	O
)	O
)	O
)	O
*	O
s	pointer
=	O
'\0'	O
;	O
return	O
ret	int
;	O
}	O
static	O
char	O
*	O
get_next_filename	function
(	O
FILE	struct
*	O
flp	pointer
,	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
,	O
char	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
path	pointer
;	O
if	O
(	O
filename	pointer
)	O
{	O
path	pointer
=	O
filename	pointer
;	O
}	O
else	O
if	O
(	O
flp	pointer
)	O
{	O
path	pointer
=	O
getnextpath	function
(	O
flp	pointer
)	O
;	O
if	O
(	O
path	pointer
)	O
{	O
if	O
(	O
lstat	function
(	O
path	pointer
,	O
st	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"could not stat pathname [%s] \n"	pointer
,	O
path	pointer
)	O
;	O
path	pointer
=	O
""	pointer
;	O
}	O
}	O
}	O
else	O
{	O
path	pointer
=	O
swvarfs_get_next_dirent	function
(	O
swvarfs	pointer
,	O
st	pointer
)	O
;	O
}	O
return	O
path	pointer
;	O
}	O
int	O
main	function
(	O
int	O
argc	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
path	pointer
;	O
char	O
*	O
t	pointer
;	O
char	O
*	O
filename	pointer
;	O
int	O
c	int
;	O
int	O
did_list	int
=	O
0	int
;	O
int	O
filelistonly	int
=	O
0	int
;	O
int	O
dumpmode	int
=	O
0	int
;	O
int	O
ret	int
=	O
0	int
;	O
int	O
statret	int
=	O
0	int
;	O
int	O
arf_format	int
=	O
arf_ustar	int
;	O
int	O
verbose	int
=	O
0	int
;	O
int	O
testmode	int
=	O
0	int
;	O
int	O
eoa	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
FILE	struct
*	O
flp	pointer
;	O
char	O
*	O
opt_owner	pointer
=	O
NULL	O
;	O
char	O
*	O
opt_group	pointer
=	O
NULL	O
;	O
uid_t	int
opt_owner_uid	int
;	O
gid_t	int
opt_owner_gid	int
;	O
STROB	struct
*	O
buf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
SWVARFS	struct
*	O
swvarfs	pointer
=	O
NULL	O
;	O
XFORMAT	struct
*	O
xformat	pointer
;	O
int	O
nullfd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
;	O
int	O
tarheaderflags	int
=	O
0	int
;	O
int	O
mode_tar2tar	int
=	O
0	int
;	O
xformat	pointer
=	O
xformat_open	function
(	O
-	O
1	int
,	O
STDOUT_FILENO	int
,	O
arf_format	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"debug-dump"	pointer
,	O
0	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"test"	pointer
,	O
0	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"tar2tar"	pointer
,	O
0	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"tarheaderflags"	pointer
,	O
1	int
,	O
0	int
,	O
'G'	O
}	O
,	O
{	O
"numeric-owner"	pointer
,	O
0	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"gnu-long-links"	pointer
,	O
0	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"pax-rdev-filter"	pointer
,	O
0	int
,	O
0	int
,	O
'X'	O
}	O
,	O
{	O
"be-like-pax"	pointer
,	O
0	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"format"	pointer
,	O
1	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
"file-list-only"	pointer
,	O
0	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"owner"	pointer
,	O
1	int
,	O
0	int
,	O
155	int
}	O
,	O
{	O
"group"	pointer
,	O
1	int
,	O
0	int
,	O
156	int
}	O
,	O
{	O
"oldgnu-namesize"	pointer
,	O
0	int
,	O
0	int
,	O
157	int
}	O
,	O
{	O
"gnu-namesize"	pointer
,	O
0	int
,	O
0	int
,	O
158	int
}	O
,	O
{	O
"scratch-pad"	pointer
,	O
1	int
,	O
0	int
,	O
159	int
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
'\005'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
c	int
=	O
ugetopt_long	function
(	O
argc	pointer
,	O
argv	pointer
,	O
"tvaxLIFXDH:G:"	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\005'	O
:	O
usage	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
dumpmode	int
=	O
1	int
;	O
break	O
;	O
case	O
'I'	O
:	O
mode_tar2tar	int
=	O
1	int
;	O
break	O
;	O
case	O
'G'	O
:	O
tarheaderflags	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
xformat	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
=	O
tarheaderflags	int
;	O
break	O
;	O
case	O
't'	O
:	O
xformat_set_ofd	function
(	O
xformat	pointer
,	O
nullfd	int
)	O
;	O
xformat	pointer
->	O
taruM	pointer
->	O
do_record_headerM	int
=	O
1	int
;	O
testmode	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'a'	O
:	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_BE_LIKE_PAX	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_GNU_LONG_LINKS	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'X'	O
:	O
ret	int
=	O
paxfilter	function
(	O
)	O
;	O
close	pointer
(	O
STDOUT_FILENO	int
)	O
;	O
close	pointer
(	O
STDERR_FILENO	int
)	O
;	O
exit	function
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
filelistonly	int
=	O
1	int
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
taru_set_tar_header_policy	function
(	O
xformat	pointer
->	O
taruM	pointer
,	O
optarg	pointer
,	O
&	O
arf_format	int
)	O
)	O
exit	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
xformat_set_numeric_uids	function
(	O
xformat	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
155	int
:	O
opt_owner	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
taru_get_uid_by_name	function
(	O
opt_owner	pointer
,	O
&	O
opt_owner_uid	int
)	O
;	O
break	O
;	O
case	O
156	int
:	O
opt_group	pointer
=	O
strdup	function
(	O
optarg	pointer
)	O
;	O
taru_get_gid_by_name	function
(	O
opt_group	pointer
,	O
&	O
opt_owner_gid	int
)	O
;	O
break	O
;	O
case	O
157	int
:	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_NAMESIZE_99	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
158	int
:	O
xformat_set_tarheader_flag	function
(	O
xformat	pointer
,	O
TARU_TAR_NAMESIZE_99	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
159	int
:	O
{	O
unsigned	O
long	O
devno	long
;	O
TARU	struct
*	O
taru	pointer
=	O
taru_create	function
(	O
)	O
;	O
ETAR	struct
*	O
etar	pointer
;	O
etar	pointer
=	O
etar_open	function
(	O
taru	pointer
->	O
taru_tarheaderflagsM	int
)	O
;	O
devno	long
=	O
swlib_atoul	function
(	O
optarg	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
etar_set_devmajor	function
(	O
etar	pointer
,	O
devno	long
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"%s\n"	pointer
,	O
(	O
char	O
*	O
)	O
(	O
ETAR__HDR	O
(	O
etar	pointer
)	O
->	O
devmajor	array
)	O
)	O
;	O
}	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
exit	function
(	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
mode_tar2tar	int
)	O
{	O
int	O
tf_fd	int
;	O
TARU	struct
*	O
tf_taru	pointer
;	O
int	O
tf_ret	int
;	O
tf_fd	int
=	O
STDIN_FILENO	int
;	O
if	O
(	O
optind	int
<	O
argc	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
tf_fd	int
=	O
STDIN_FILENO	int
;	O
}	O
else	O
{	O
tf_fd	int
=	O
open	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
tf_fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swbistar: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
tf_taru	pointer
=	O
xformat	pointer
->	O
taruM	pointer
;	O
tf_ret	int
=	O
taru_process_copy_out	function
(	O
tf_taru	pointer
,	O
tf_fd	int
,	O
STDOUT_FILENO	int
,	O
NULL	O
,	O
NULL	O
,	O
arf_ustar	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
(	O
intmax_t	long
*	O
)	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
tf_ret	int
>	O
0	int
)	O
{	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
dumpmode	int
)	O
{	O
int	O
xfd	int
=	O
-	O
1	int
;	O
if	O
(	O
optind	int
<	O
argc	pointer
)	O
{	O
xfd	int
=	O
open	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
xfd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swbistar: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
HN	int
=	O
0	int
;	O
ret	int
=	O
decode_filter	function
(	O
xformat	pointer
,	O
xfd	int
,	O
verbose	int
)	O
;	O
exit	function
(	O
ret	int
)	O
;	O
}	O
xformat_set_output_format	function
(	O
xformat	pointer
,	O
arf_format	int
)	O
;	O
did_list	int
=	O
1	int
;	O
filename	pointer
=	O
NULL	O
;	O
while	O
(	O
optind	int
<	O
argc	pointer
||	O
did_list	int
)	O
{	O
did_list	int
=	O
0	int
;	O
if	O
(	O
optind	int
<	O
argc	pointer
)	O
{	O
if	O
(	O
filename	pointer
)	O
free	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
statret	int
=	O
lstat	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
&	O
st	pointer
)	O
)	O
==	O
0	int
&&	O
(	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
==	O
0	int
)	O
{	O
filename	pointer
=	O
strdup	function
(	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
flp	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
statret	int
==	O
0	int
&&	O
(	O
S_IFDIR	O
&	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
swvarfs	pointer
=	O
swvarfs_open	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
UINFILE_DETECT_FORCEUXFIOFD	O
|	O
UINFILE_DETECT_NATIVE	O
,	O
(	O
mode_t	int
)	O
(	O
NULL	O
)	O
)	O
;	O
flp	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s not found\n"	pointer
,	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
swvarfs	pointer
=	O
NULL	O
;	O
flp	pointer
=	O
stdin	pointer
;	O
}	O
path	pointer
=	O
get_next_filename	function
(	O
flp	pointer
,	O
swvarfs	pointer
,	O
&	O
st	pointer
,	O
filename	pointer
)	O
;	O
while	O
(	O
ret	int
>=	O
0	int
&&	O
path	pointer
)	O
{	O
if	O
(	O
(	O
t	pointer
=	O
strpbrk	function
(	O
path	pointer
,	O
"\n\r"	pointer
)	O
)	O
)	O
{	O
*	O
t	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
strlen	function
(	O
path	pointer
)	O
)	O
{	O
if	O
(	O
filelistonly	int
||	O
(	O
testmode	int
&&	O
verbose	int
==	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"%s\n"	pointer
,	O
path	pointer
)	O
;	O
}	O
else	O
if	O
(	O
testmode	int
&&	O
verbose	int
>	O
0	int
)	O
{	O
if	O
(	O
opt_owner	pointer
)	O
{	O
st	pointer
.	O
st_uid	int
=	O
opt_owner_uid	int
;	O
}	O
if	O
(	O
opt_group	pointer
)	O
{	O
st	pointer
.	O
st_gid	int
=	O
opt_owner_gid	int
;	O
}	O
ret	int
=	O
xformat_write_by_name	function
(	O
xformat	pointer
,	O
path	pointer
,	O
&	O
st	pointer
)	O
;	O
if	O
(	O
ret	int
>	O
0	int
)	O
{	O
file_hdr	pointer
=	O
xformat_vfile_hdr	function
(	O
xformat	pointer
)	O
;	O
taru_read_in_tar_header2	function
(	O
xformat	pointer
->	O
taruM	pointer
,	O
file_hdr	pointer
,	O
-	O
1	int
,	O
strob_str	function
(	O
xformat	pointer
->	O
taruM	pointer
->	O
headerM	pointer
)	O
,	O
&	O
eoa	pointer
,	O
xformat_get_tarheader_flags	function
(	O
xformat	pointer
)	O
,	O
512	int
)	O
;	O
taru_print_tar_ls_list	function
(	O
buf	pointer
,	O
file_hdr	pointer
,	O
LS_LIST_VERBOSE_L1	O
)	O
;	O
write	pointer
(	O
STDOUT_FILENO	int
,	O
strob_str	function
(	O
buf	pointer
)	O
,	O
strob_strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
;	O
}	O
else	O
{	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"swbistar: xformat_write_by_name returned %d\n"	pointer
,	O
ret	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
opt_owner	pointer
)	O
{	O
st	pointer
.	O
st_uid	int
=	O
opt_owner_uid	int
;	O
}	O
if	O
(	O
opt_group	pointer
)	O
{	O
st	pointer
.	O
st_gid	int
=	O
opt_owner_gid	int
;	O
}	O
ret	int
=	O
xformat_write_by_name	function
(	O
xformat	pointer
,	O
path	pointer
,	O
&	O
st	pointer
)	O
;	O
}	O
}	O
if	O
(	O
filename	pointer
)	O
{	O
path	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
path	pointer
=	O
get_next_filename	function
(	O
flp	pointer
,	O
swvarfs	pointer
,	O
&	O
st	pointer
,	O
filename	pointer
)	O
;	O
}	O
}	O
optind	int
++	O
;	O
}	O
if	O
(	O
!	O
filelistonly	int
&&	O
ret	int
>=	O
0	int
)	O
xformat_write_trailer	function
(	O
xformat	pointer
)	O
;	O
xformat_close	function
(	O
xformat	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
)	O
swvarfs_close	function
(	O
swvarfs	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
