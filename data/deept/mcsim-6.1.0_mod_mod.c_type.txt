static	O
char	O
vszOptions	array
[	O
]	O
=	O
"hHDRG"	pointer
;	O
static	O
char	O
vszFilenameDefault	array
[	O
]	O
=	O
"model.c"	pointer
;	O
char	O
szFileWithExt	array
[	O
MAX_FILENAMESIZE	int
]	O
;	O
void	O
AnnounceProgram	function
(	O
void	O
)	O
{	O
printf	function
(	O
"\n________________________________________\n"	pointer
)	O
;	O
printf	function
(	O
"\nMod "	pointer
VSZ_VERSION	pointer
" - Model Generator for MCSim\n\n"	pointer
)	O
;	O
printf	function
(	O
"MCSim and associated software comes with ABSOLUTELY NO WARRANTY;\n"	pointer
"This is free software, and you are welcome to redistribute it\n"	pointer
"under certain conditions; see the GNU General Public License.\n\n"	pointer
)	O
;	O
}	O
void	O
PromptFilenames	function
(	O
PSTR	pointer
*	O
pszFileIn	pointer
,	O
PSTR	pointer
*	O
pszFileOut	pointer
)	O
{	O
if	O
(	O
!	O
(	O
*	O
pszFileIn	pointer
=	O
(	O
PSTR	pointer
)	O
calloc	function
(	O
1	int
,	O
MAX_FILENAMESIZE	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"PromptFilenames"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
*	O
pszFileOut	pointer
=	O
(	O
PSTR	pointer
)	O
calloc	function
(	O
1	int
,	O
MAX_FILENAMESIZE	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"PromptFilenames"	pointer
,	O
NULL	O
)	O
;	O
printf	function
(	O
"Input filename? "	pointer
)	O
;	O
fgets	function
(	O
*	O
pszFileIn	pointer
,	O
MAX_FILENAMESIZE	int
,	O
stdin	pointer
)	O
;	O
*	O
pszFileIn	pointer
=	O
strtok	function
(	O
*	O
pszFileIn	pointer
,	O
" \t\n"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
*	O
pszFileIn	pointer
)	O
)	O
return	O
;	O
if	O
(	O
(	O
*	O
pszFileIn	pointer
)	O
[	O
0	int
]	O
)	O
{	O
printf	function
(	O
"Output filename? "	pointer
)	O
;	O
fgets	function
(	O
*	O
pszFileOut	pointer
,	O
MAX_FILENAMESIZE	int
,	O
stdin	pointer
)	O
;	O
*	O
pszFileOut	pointer
=	O
strtok	function
(	O
*	O
pszFileOut	pointer
,	O
" \t\n"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
pszFileOut	pointer
)	O
||	O
!	O
(	O
*	O
pszFileOut	pointer
)	O
[	O
0	int
]	O
)	O
{	O
free	function
(	O
*	O
pszFileOut	pointer
)	O
;	O
*	O
pszFileOut	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
*	O
pszFileIn	pointer
=	O
(	O
PSTR	pointer
)	O
realloc	function
(	O
*	O
pszFileIn	pointer
,	O
MyStrlen	O
(	O
*	O
pszFileIn	pointer
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"PromptFilenames"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
*	O
pszFileOut	pointer
=	O
(	O
PSTR	pointer
)	O
realloc	function
(	O
*	O
pszFileOut	pointer
,	O
MyStrlen	O
(	O
*	O
pszFileOut	pointer
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"PromptFilenames"	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
void	O
ShowHelp	function
(	O
)	O
{	O
printf	function
(	O
"Help:\n"	pointer
)	O
;	O
printf	function
(	O
"Usage: mod [options] [input-file [output-file]]\n"	pointer
)	O
;	O
printf	function
(	O
"Options:\n"	pointer
)	O
;	O
printf	function
(	O
"  -h  Display this information\n"	pointer
)	O
;	O
printf	function
(	O
"  -H  Display this information\n"	pointer
)	O
;	O
printf	function
(	O
"  -D  Debug mode\n"	pointer
)	O
;	O
printf	function
(	O
"  -R  Generate an R deSolve compatible C file\n"	pointer
)	O
;	O
printf	function
(	O
"Creates file 'output-file' (or 'model.c', by default)\n"	pointer
)	O
;	O
printf	function
(	O
"according to the input-file specifications.\n\n"	pointer
)	O
;	O
}	O
void	O
GetCmdLineArgs	function
(	O
int	O
nArg	int
,	O
char	O
*	O
const	O
*	O
rgszArg	pointer
,	O
PSTR	pointer
*	O
pszFileIn	pointer
,	O
PSTR	pointer
*	O
pszFileOut	pointer
,	O
PINPUTINFO	pointer
pinfo	pointer
)	O
{	O
int	O
c	int
;	O
opterr	int
=	O
1	int
;	O
*	O
pszFileIn	pointer
=	O
*	O
pszFileOut	pointer
=	O
(	O
PSTR	pointer
)	O
NULL	O
;	O
while	O
(	O
1	int
)	O
{	O
c	int
=	O
_getopt	function
(	O
nArg	int
,	O
rgszArg	pointer
,	O
vszOptions	array
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'D'	O
:	O
printf	function
(	O
">> Debug mode using option '%s': "	pointer
"Not implemented, ignored.\n\n"	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
case	O
'h'	O
:	O
ShowHelp	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
printf	function
(	O
">> Generating code for linking with R deSolve package.\n\n"	pointer
)	O
;	O
pinfo	pointer
->	O
bforR	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'?'	O
:	O
default	O
:	O
ShowHelp	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
switch	O
(	O
nArg	int
-	O
optind	int
)	O
{	O
case	O
2	int
:	O
*	O
pszFileOut	pointer
=	O
rgszArg	pointer
[	O
optind	int
+	O
1	int
]	O
;	O
case	O
1	int
:	O
*	O
pszFileIn	pointer
=	O
rgszArg	pointer
[	O
optind	int
]	O
;	O
break	O
;	O
case	O
0	int
:	O
PromptFilenames	function
(	O
pszFileIn	pointer
,	O
pszFileOut	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"mod: too many parameters on command line\n"	pointer
)	O
;	O
ShowHelp	function
(	O
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
}	O
while	O
(	O
*	O
pszFileIn	pointer
&&	O
(	O
*	O
pszFileIn	pointer
)	O
[	O
0	int
]	O
&&	O
!	O
MyStrcmp	function
(	O
*	O
pszFileIn	pointer
,	O
*	O
pszFileOut	pointer
)	O
)	O
{	O
printf	function
(	O
"\n** Input and output filename must be different.\n"	pointer
)	O
;	O
PromptFilenames	function
(	O
pszFileIn	pointer
,	O
pszFileOut	pointer
)	O
;	O
}	O
if	O
(	O
!	O
(	O
*	O
pszFileIn	pointer
&&	O
(	O
*	O
pszFileIn	pointer
)	O
[	O
0	int
]	O
)	O
)	O
{	O
printf	function
(	O
"Error: an input file name must be specified - Exiting\n\n"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
pinfo	pointer
->	O
szInputFilename	pointer
=	O
*	O
pszFileIn	pointer
;	O
if	O
(	O
!	O
*	O
pszFileOut	pointer
)	O
*	O
pszFileOut	pointer
=	O
vszFilenameDefault	array
;	O
}	O
void	O
InitInfo	function
(	O
PINPUTINFO	pointer
pinfo	pointer
,	O
PSTR	pointer
szModGenName	pointer
)	O
{	O
pinfo	pointer
->	O
wContext	int
=	O
CN_GLOBAL	int
;	O
pinfo	pointer
->	O
bDelays	int
=	O
FALSE	int
;	O
pinfo	pointer
->	O
bforR	int
=	O
FALSE	int
;	O
pinfo	pointer
->	O
bTemplateInUse	int
=	O
FALSE	int
;	O
pinfo	pointer
->	O
szModGenName	pointer
=	O
szModGenName	pointer
;	O
pinfo	pointer
->	O
pvmGloVars	pointer
=	O
NULL	O
;	O
pinfo	pointer
->	O
pvmDynEqns	pointer
=	O
NULL	O
;	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
=	O
NULL	O
;	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
=	O
NULL	O
;	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
=	O
NULL	O
;	O
pinfo	pointer
->	O
pvmEventEqns	pointer
=	O
NULL	O
;	O
pinfo	pointer
->	O
pvmRootEqns	pointer
=	O
NULL	O
;	O
pinfo	pointer
->	O
pvmCpts	pointer
=	O
NULL	O
;	O
pinfo	pointer
->	O
pvmLocalCpts	pointer
=	O
NULL	O
;	O
}	O
void	O
Cleanup	function
(	O
PINPUTINFO	pointer
pinfo	pointer
)	O
{	O
PVMMAPSTRCT	pointer
next	pointer
;	O
while	O
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmGloVars	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmGloVars	pointer
)	O
;	O
pinfo	pointer
->	O
pvmGloVars	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
pinfo	pointer
->	O
pvmDynEqns	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmDynEqns	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmDynEqns	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmDynEqns	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmDynEqns	pointer
)	O
;	O
pinfo	pointer
->	O
pvmDynEqns	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
)	O
;	O
pinfo	pointer
->	O
pvmScaleEqns	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
)	O
;	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
)	O
;	O
pinfo	pointer
->	O
pvmCalcOutEqns	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
pinfo	pointer
->	O
pvmEventEqns	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmEventEqns	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmEventEqns	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmEventEqns	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmEventEqns	pointer
)	O
;	O
pinfo	pointer
->	O
pvmEventEqns	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
pinfo	pointer
->	O
pvmRootEqns	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmRootEqns	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmRootEqns	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmRootEqns	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmRootEqns	pointer
)	O
;	O
pinfo	pointer
->	O
pvmRootEqns	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
pinfo	pointer
->	O
pvmCpts	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmCpts	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmCpts	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmCpts	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmCpts	pointer
)	O
;	O
pinfo	pointer
->	O
pvmCpts	pointer
=	O
next	pointer
;	O
}	O
while	O
(	O
pinfo	pointer
->	O
pvmLocalCpts	pointer
)	O
{	O
next	pointer
=	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
->	O
pvmNextVar	pointer
;	O
free	function
(	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
->	O
szName	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
->	O
szEqn	pointer
)	O
;	O
free	function
(	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
)	O
;	O
pinfo	pointer
->	O
pvmJacobEqns	pointer
=	O
next	pointer
;	O
}	O
}	O
int	O
main	function
(	O
int	O
nArg	int
,	O
PSTR	pointer
rgszArg	pointer
[	O
]	O
)	O
{	O
INPUTINFO	struct
info	struct
;	O
INPUTINFO	struct
tempinfo	struct
;	O
PSTR	pointer
szFileIn	pointer
,	O
szFileOut	pointer
;	O
AnnounceProgram	function
(	O
)	O
;	O
InitInfo	function
(	O
&	O
info	struct
,	O
rgszArg	pointer
[	O
0	int
]	O
)	O
;	O
InitInfo	function
(	O
&	O
tempinfo	struct
,	O
rgszArg	pointer
[	O
0	int
]	O
)	O
;	O
GetCmdLineArgs	function
(	O
nArg	int
,	O
rgszArg	pointer
,	O
&	O
szFileIn	pointer
,	O
&	O
szFileOut	pointer
,	O
&	O
info	struct
)	O
;	O
ReadModel	function
(	O
&	O
info	struct
,	O
&	O
tempinfo	struct
,	O
szFileIn	pointer
)	O
;	O
if	O
(	O
info	struct
.	O
bforR	int
==	O
TRUE	int
)	O
Write_R_Model	function
(	O
&	O
info	struct
,	O
szFileOut	pointer
)	O
;	O
else	O
WriteModel	function
(	O
&	O
info	struct
,	O
szFileOut	pointer
)	O
;	O
Cleanup	function
(	O
&	O
info	struct
)	O
;	O
return	O
0	int
;	O
}	O
