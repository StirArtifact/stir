void	O
DISUpdateWorldCoordinates	function
(	O
WorldCoordinates	struct
*	O
p	pointer
,	O
double	O
cos_course	double
,	O
double	O
sin_course	double
,	O
double	O
d_meters	double
)	O
{	O
double	O
n1	double
,	O
n2	double
,	O
m1	double
;	O
double	O
sin_lat	double
,	O
sin_lat_sqr	double
,	O
tan_lat	double
,	O
sin_course_sqr	double
;	O
double	O
delta_latitude	double
,	O
delta_longitude	double
,	O
d_sqr	double
,	O
cos_lat	double
;	O
double	O
B	double
,	O
C	double
,	O
E	double
,	O
h	double
,	O
sin_newlat	double
;	O
double	O
wgs84_a	double
=	O
WGS84_MAJOR	int
+	O
p	pointer
->	O
z	float
;	O
sin_lat	double
=	O
sin	function
(	O
p	pointer
->	O
latitude	double
)	O
;	O
sin_lat_sqr	double
=	O
sin_lat	double
*	O
sin_lat	double
;	O
cos_lat	double
=	O
cos	function
(	O
p	pointer
->	O
latitude	double
)	O
;	O
tan_lat	double
=	O
sin_lat	double
/	O
cos_lat	double
;	O
sin_course_sqr	double
=	O
sin_course	double
*	O
sin_course	double
;	O
d_sqr	double
=	O
d_meters	double
*	O
d_meters	double
;	O
n1	double
=	O
wgs84_a	double
/	O
sqrt	function
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
)	O
;	O
m1	double
=	O
(	O
wgs84_a	double
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
)	O
)	O
/	O
pow	function
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
,	O
1.5	int
)	O
;	O
B	double
=	O
1.0	int
/	O
m1	double
;	O
h	double
=	O
d_meters	double
*	O
B	double
*	O
cos_course	double
;	O
C	double
=	O
tan_lat	double
/	O
(	O
2.0	int
*	O
m1	double
*	O
n1	double
)	O
;	O
E	double
=	O
(	O
1.0	int
+	O
3.0	int
*	O
tan_lat	double
*	O
tan_lat	double
)	O
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
)	O
/	O
(	O
6.0	int
*	O
wgs84_a	double
*	O
wgs84_a	double
)	O
;	O
delta_latitude	double
=	O
d_meters	double
*	O
B	double
*	O
cos_course	double
-	O
d_sqr	double
*	O
C	double
*	O
sin_course_sqr	double
-	O
h	double
*	O
d_sqr	double
*	O
E	double
*	O
sin_course_sqr	double
;	O
p	pointer
->	O
latitude	double
+=	O
delta_latitude	double
;	O
if	O
(	O
p	pointer
->	O
latitude	double
>	O
M_PI_2	int
)	O
{	O
p	pointer
->	O
latitude	double
-=	O
M_PI_2	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
latitude	double
<	O
-	O
M_PI_2	int
)	O
{	O
p	pointer
->	O
latitude	double
+=	O
M_PI_2	int
;	O
}	O
sin_newlat	double
=	O
sin	function
(	O
p	pointer
->	O
latitude	double
)	O
;	O
n2	double
=	O
wgs84_a	double
/	O
sqrt	function
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_newlat	double
*	O
sin_newlat	double
)	O
;	O
delta_longitude	double
=	O
(	O
d_meters	double
*	O
sin_course	double
)	O
/	O
(	O
n2	double
*	O
cos	function
(	O
p	pointer
->	O
latitude	double
)	O
)	O
;	O
p	pointer
->	O
longitude	double
+=	O
delta_longitude	double
;	O
if	O
(	O
p	pointer
->	O
longitude	double
>	O
M_PI	int
)	O
{	O
p	pointer
->	O
longitude	double
-=	O
M_PI	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
longitude	double
<	O
-	O
M_PI	int
)	O
{	O
p	pointer
->	O
longitude	double
+=	O
M_PI	int
;	O
}	O
}	O
void	O
DISUpdateWorldCoordinatesEx	function
(	O
WorldCoordinates	struct
*	O
p	pointer
,	O
double	O
cos_course	double
,	O
double	O
sin_course	double
,	O
double	O
d_meters	double
,	O
double	O
*	O
delta_course_rad	pointer
)	O
{	O
double	O
n1	double
,	O
n2	double
,	O
m1	double
;	O
double	O
sin_lat	double
,	O
sin_lat_sqr	double
,	O
tan_lat	double
,	O
sin_course_sqr	double
;	O
double	O
delta_latitude	double
,	O
delta_longitude	double
,	O
d_sqr	double
,	O
cos_lat	double
;	O
double	O
B	double
,	O
C	double
,	O
E	double
,	O
h	double
,	O
sin_newlat	double
;	O
double	O
old_latitude	double
,	O
phi_m	double
,	O
sin_phi_m	double
,	O
cos_phi_m	double
;	O
const	O
double	O
rho	double
=	O
206264.8062470964	int
;	O
double	O
wgs84_a	double
=	O
WGS84_MAJOR	int
+	O
p	pointer
->	O
z	float
;	O
sin_lat	double
=	O
sin	function
(	O
p	pointer
->	O
latitude	double
)	O
;	O
sin_lat_sqr	double
=	O
sin_lat	double
*	O
sin_lat	double
;	O
cos_lat	double
=	O
cos	function
(	O
p	pointer
->	O
latitude	double
)	O
;	O
tan_lat	double
=	O
sin_lat	double
/	O
cos_lat	double
;	O
sin_course_sqr	double
=	O
sin_course	double
*	O
sin_course	double
;	O
d_sqr	double
=	O
d_meters	double
*	O
d_meters	double
;	O
n1	double
=	O
wgs84_a	double
/	O
sqrt	function
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
)	O
;	O
m1	double
=	O
(	O
wgs84_a	double
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
)	O
)	O
/	O
pow	function
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
,	O
1.5	int
)	O
;	O
B	double
=	O
1.0	int
/	O
m1	double
;	O
h	double
=	O
d_meters	double
*	O
B	double
*	O
cos_course	double
;	O
C	double
=	O
tan_lat	double
/	O
(	O
2.0	int
*	O
m1	double
*	O
n1	double
)	O
;	O
E	double
=	O
(	O
1.0	int
+	O
3.0	int
*	O
tan_lat	double
*	O
tan_lat	double
)	O
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_lat_sqr	double
)	O
/	O
(	O
6.0	int
*	O
wgs84_a	double
*	O
wgs84_a	double
)	O
;	O
delta_latitude	double
=	O
d_meters	double
*	O
B	double
*	O
cos_course	double
-	O
d_sqr	double
*	O
C	double
*	O
sin_course_sqr	double
-	O
h	double
*	O
d_sqr	double
*	O
E	double
*	O
sin_course_sqr	double
;	O
old_latitude	double
=	O
p	pointer
->	O
latitude	double
;	O
p	pointer
->	O
latitude	double
+=	O
delta_latitude	double
;	O
if	O
(	O
p	pointer
->	O
latitude	double
>	O
M_PI_2	int
)	O
{	O
p	pointer
->	O
latitude	double
-=	O
M_PI_2	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
latitude	double
<	O
-	O
M_PI_2	int
)	O
{	O
p	pointer
->	O
latitude	double
+=	O
M_PI_2	int
;	O
}	O
phi_m	double
=	O
old_latitude	double
+	O
delta_latitude	double
/	O
2.0	int
;	O
sin_phi_m	double
=	O
sin	function
(	O
phi_m	double
)	O
;	O
cos_phi_m	double
=	O
cos	function
(	O
phi_m	double
)	O
;	O
sin_newlat	double
=	O
sin	function
(	O
p	pointer
->	O
latitude	double
)	O
;	O
n2	double
=	O
wgs84_a	double
/	O
sqrt	function
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
*	O
sin_newlat	double
*	O
sin_newlat	double
)	O
;	O
delta_longitude	double
=	O
(	O
d_meters	double
*	O
sin_course	double
)	O
/	O
(	O
n2	double
*	O
cos	function
(	O
p	pointer
->	O
latitude	double
)	O
)	O
;	O
*	O
delta_course_rad	pointer
=	O
delta_longitude	double
*	O
sin_phi_m	double
/	O
cos	function
(	O
delta_latitude	double
/	O
2.0	int
)	O
+	O
delta_longitude	double
*	O
(	O
sin_phi_m	double
*	O
cos_phi_m	double
*	O
cos_phi_m	double
)	O
/	O
rho	double
;	O
p	pointer
->	O
longitude	double
+=	O
delta_longitude	double
;	O
if	O
(	O
p	pointer
->	O
longitude	double
>	O
M_PI	int
)	O
{	O
p	pointer
->	O
longitude	double
-=	O
M_PI	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
longitude	double
<	O
-	O
M_PI	int
)	O
{	O
p	pointer
->	O
longitude	double
+=	O
M_PI	int
;	O
}	O
}	O
void	O
DISGeocentricToWorldCoordinates	function
(	O
dis_world_coordinates	struct
*	O
loc	struct
,	O
WorldCoordinates	struct
*	O
p	pointer
)	O
{	O
double	O
a_sqr	double
=	O
WGS84_MAJOR	int
*	O
WGS84_MAJOR	int
,	O
b_sqr	double
=	O
WGS84_MINOR	int
*	O
WGS84_MINOR	int
;	O
double	O
w	pointer
,	O
x	float
,	O
x_sqr	double
,	O
z	float
,	O
delta_x	double
,	O
cos_x	double
;	O
double	O
f	array
,	O
f_prime	double
,	O
w0	double
,	O
z0	double
;	O
w	pointer
=	O
sqrt	function
(	O
loc	struct
->	O
x	float
*	O
loc	struct
->	O
x	float
+	O
loc	struct
->	O
y	float
*	O
loc	struct
->	O
y	float
)	O
;	O
z	float
=	O
loc	struct
->	O
z	float
;	O
if	O
(	O
w	pointer
==	O
0.0	int
&&	O
z	float
==	O
0.0	int
)	O
{	O
p	pointer
->	O
latitude	double
=	O
0.0	int
;	O
p	pointer
->	O
longitude	double
=	O
0.0	int
;	O
p	pointer
->	O
z	float
=	O
0.0	int
;	O
return	O
;	O
}	O
x	float
=	O
z	float
/	O
sqrt	function
(	O
w	pointer
*	O
w	pointer
+	O
z	float
*	O
z	float
)	O
;	O
for	O
(	O
delta_x	double
=	O
1.0	int
;	O
fabs	function
(	O
delta_x	double
)	O
>	O
4.8E-10	int
;	O
)	O
{	O
x_sqr	double
=	O
x	float
*	O
x	float
;	O
cos_x	double
=	O
sqrt	function
(	O
1.0	int
-	O
x_sqr	double
)	O
;	O
f	array
=	O
2.0	int
*	O
(	O
WGS84_MAJOR	int
*	O
x	float
*	O
w	pointer
-	O
a_sqr	double
*	O
x	float
*	O
cos_x	double
-	O
WGS84_MINOR	int
*	O
cos_x	double
*	O
z	float
+	O
b_sqr	double
*	O
cos_x	double
*	O
x	float
)	O
;	O
f_prime	double
=	O
2.0	int
*	O
(	O
a_sqr	double
+	O
2.0	int
*	O
(	O
a_sqr	double
*	O
x_sqr	double
)	O
-	O
WGS84_MAJOR	int
*	O
w	pointer
*	O
x_sqr	double
+	O
b_sqr	double
-	O
2.0	int
*	O
b_sqr	double
*	O
x_sqr	double
+	O
WGS84_MINOR	int
*	O
x	float
*	O
z	float
)	O
;	O
delta_x	double
=	O
f	array
/	O
f_prime	double
;	O
x	float
-=	O
delta_x	double
;	O
}	O
z0	double
=	O
WGS84_MINOR	int
*	O
x	float
;	O
w0	double
=	O
WGS84_MAJOR	int
*	O
sqrt	function
(	O
1.0	int
-	O
x	float
*	O
x	float
)	O
;	O
p	pointer
->	O
z	float
=	O
sqrt	function
(	O
(	O
z	float
-	O
z0	double
)	O
*	O
(	O
z	float
-	O
z0	double
)	O
+	O
(	O
w	pointer
-	O
w0	double
)	O
*	O
(	O
w	pointer
-	O
w0	double
)	O
)	O
;	O
p	pointer
->	O
latitude	double
=	O
atan	function
(	O
z0	double
/	O
(	O
w0	double
*	O
(	O
1.0	int
-	O
WGS84_ECC_SQR	int
)	O
)	O
)	O
;	O
p	pointer
->	O
longitude	double
=	O
atan2	function
(	O
loc	struct
->	O
y	float
,	O
loc	struct
->	O
x	float
)	O
;	O
}	O
void	O
DISWorldCoordinatesToGeocentric	function
(	O
WorldCoordinates	struct
*	O
w	pointer
,	O
dis_world_coordinates	struct
*	O
p	pointer
)	O
{	O
double	O
N	double
,	O
N1	double
;	O
double	O
cos_latitude	double
,	O
sin_latitude	double
;	O
sin_latitude	double
=	O
sin	function
(	O
w	pointer
->	O
latitude	double
)	O
;	O
cos_latitude	double
=	O
cos	function
(	O
w	pointer
->	O
latitude	double
)	O
;	O
N	double
=	O
WGS84_MAJOR	int
/	O
sqrt	function
(	O
1.0	int
-	O
(	O
WGS84_ECC_SQR	int
*	O
sin_latitude	double
*	O
sin_latitude	double
)	O
)	O
;	O
N1	double
=	O
N	double
+	O
w	pointer
->	O
z	float
;	O
p	pointer
->	O
x	float
=	O
N1	double
*	O
cos_latitude	double
*	O
cos	function
(	O
w	pointer
->	O
longitude	double
)	O
;	O
p	pointer
->	O
y	float
=	O
N1	double
*	O
cos_latitude	double
*	O
sin	function
(	O
w	pointer
->	O
longitude	double
)	O
;	O
p	pointer
->	O
z	float
=	O
(	O
(	O
(	O
WGS84_MINOR	int
*	O
WGS84_MINOR	int
)	O
/	O
(	O
WGS84_MAJOR	int
*	O
WGS84_MAJOR	int
)	O
)	O
*	O
N	double
+	O
w	pointer
->	O
z	float
)	O
*	O
sin_latitude	double
;	O
}	O
char	O
*	O
DISLatitudeToString	function
(	O
char	O
*	O
s	array
,	O
double	O
la	double
,	O
LatLongDisplayFormat	enum
mode	enum
)	O
{	O
int	O
d	double
,	O
m	array
;	O
double	O
dla	double
,	O
dmin	double
,	O
dsec	double
;	O
double	O
round_dms	double
=	O
1.0	int
/	O
(	O
36000.0	int
*	O
2.0	int
)	O
;	O
double	O
round_dm	double
=	O
1.0	int
/	O
(	O
600.0	int
*	O
2.0	int
)	O
;	O
char	O
*	O
ns	pointer
;	O
round_dms	double
=	O
round_dm	double
=	O
0.0	int
;	O
switch	O
(	O
mode	enum
)	O
{	O
case	O
LLM_DMS	int
:	O
ns	pointer
=	O
(	O
la	double
>=	O
0.0	int
)	O
?	O
"N"	pointer
:	O
"S"	pointer
;	O
dla	double
=	O
RADtoDEG	O
(	O
fabs	function
(	O
la	double
)	O
)	O
+	O
round_dms	double
;	O
d	double
=	O
(	O
int	O
)	O
dla	double
;	O
dmin	double
=	O
(	O
dla	double
-	O
(	O
double	O
)	O
d	double
)	O
*	O
60.0	int
;	O
m	array
=	O
(	O
int	O
)	O
dmin	double
;	O
dsec	double
=	O
(	O
dmin	double
-	O
(	O
double	O
)	O
m	array
)	O
*	O
60.0	int
;	O
sprintf	function
(	O
s	array
,	O
"%d %d %.1f %s"	pointer
,	O
d	double
,	O
m	array
,	O
dsec	double
,	O
ns	pointer
)	O
;	O
break	O
;	O
case	O
LLM_DM	int
:	O
ns	pointer
=	O
(	O
la	double
>=	O
0.0	int
)	O
?	O
"N"	pointer
:	O
"S"	pointer
;	O
dla	double
=	O
RADtoDEG	O
(	O
fabs	function
(	O
la	double
)	O
)	O
+	O
round_dm	double
;	O
d	double
=	O
(	O
int	O
)	O
dla	double
;	O
dmin	double
=	O
(	O
dla	double
-	O
(	O
double	O
)	O
d	double
)	O
*	O
60.0	int
;	O
sprintf	function
(	O
s	array
,	O
"%d %.1f %s"	pointer
,	O
d	double
,	O
dmin	double
,	O
ns	pointer
)	O
;	O
break	O
;	O
case	O
LLM_D	int
:	O
ns	pointer
=	O
(	O
la	double
>=	O
0.0	int
)	O
?	O
"N"	pointer
:	O
"S"	pointer
;	O
dla	double
=	O
RADtoDEG	O
(	O
fabs	function
(	O
la	double
)	O
)	O
+	O
0.05	int
;	O
sprintf	function
(	O
s	array
,	O
"%.1f %s"	pointer
,	O
dla	double
,	O
ns	pointer
)	O
;	O
break	O
;	O
case	O
LLM_SIGNED_D	int
:	O
sprintf	function
(	O
s	array
,	O
"%.1f"	pointer
,	O
RADtoDEG	O
(	O
la	double
)	O
)	O
;	O
break	O
;	O
}	O
return	O
s	array
;	O
}	O
char	O
*	O
DISLongitudeToString	function
(	O
char	O
*	O
s	array
,	O
double	O
lo	double
,	O
LatLongDisplayFormat	enum
mode	enum
)	O
{	O
int	O
d	double
,	O
m	array
;	O
double	O
dlo	double
,	O
dmin	double
,	O
dsec	double
;	O
double	O
round_dms	double
=	O
1.0	int
/	O
(	O
36000.0	int
*	O
2.0	int
)	O
;	O
double	O
round_dm	double
=	O
1.0	int
/	O
(	O
600.0	int
*	O
2.0	int
)	O
;	O
char	O
*	O
ew	pointer
;	O
round_dms	double
=	O
round_dm	double
=	O
0.0	int
;	O
switch	O
(	O
mode	enum
)	O
{	O
case	O
LLM_DMS	int
:	O
ew	pointer
=	O
(	O
lo	double
>=	O
0.0	int
)	O
?	O
"E"	pointer
:	O
"W"	pointer
;	O
dlo	double
=	O
RADtoDEG	O
(	O
fabs	function
(	O
lo	double
)	O
)	O
+	O
round_dms	double
;	O
d	double
=	O
(	O
int	O
)	O
dlo	double
;	O
dmin	double
=	O
(	O
dlo	double
-	O
(	O
double	O
)	O
d	double
)	O
*	O
60.0	int
;	O
m	array
=	O
(	O
int	O
)	O
dmin	double
;	O
dsec	double
=	O
(	O
dmin	double
-	O
(	O
double	O
)	O
m	array
)	O
*	O
60.0	int
;	O
sprintf	function
(	O
s	array
,	O
"%d %d %.1f %s"	pointer
,	O
d	double
,	O
m	array
,	O
dsec	double
,	O
ew	pointer
)	O
;	O
break	O
;	O
case	O
LLM_DM	int
:	O
ew	pointer
=	O
(	O
lo	double
>=	O
0.0	int
)	O
?	O
"E"	pointer
:	O
"W"	pointer
;	O
dlo	double
=	O
RADtoDEG	O
(	O
fabs	function
(	O
lo	double
)	O
)	O
+	O
round_dm	double
;	O
d	double
=	O
(	O
int	O
)	O
dlo	double
;	O
dmin	double
=	O
(	O
dlo	double
-	O
(	O
double	O
)	O
d	double
)	O
*	O
60.0	int
;	O
sprintf	function
(	O
s	array
,	O
"%d %.1f %s"	pointer
,	O
d	double
,	O
dmin	double
,	O
ew	pointer
)	O
;	O
break	O
;	O
case	O
LLM_D	int
:	O
ew	pointer
=	O
(	O
lo	double
>=	O
0.0	int
)	O
?	O
"E"	pointer
:	O
"W"	pointer
;	O
dlo	double
=	O
RADtoDEG	O
(	O
fabs	function
(	O
lo	double
)	O
)	O
+	O
0.05	int
;	O
sprintf	function
(	O
s	array
,	O
"%.1f %s"	pointer
,	O
dlo	double
,	O
ew	pointer
)	O
;	O
break	O
;	O
case	O
LLM_SIGNED_D	int
:	O
sprintf	function
(	O
s	array
,	O
"%.1f"	pointer
,	O
RADtoDEG	O
(	O
lo	double
)	O
)	O
;	O
break	O
;	O
}	O
return	O
s	array
;	O
}	O
typedef	O
enum	O
{	O
EndOfFile	int
,	O
TOKEN_FLOAT	int
,	O
TOKEN_LONG	int
,	O
TOKEN_DASH	int
,	O
TOKEN_NORTH	int
,	O
TOKEN_SOUTH	int
,	O
TOKEN_EAST	int
,	O
TOKEN_WEST	int
}	O
token_id	enum
;	O
typedef	O
union	O
{	O
double	O
double_value	double
;	O
long	O
long_value	long
;	O
}	O
lex_val	union
;	O
static	O
lex_val	union
lex_value	union
;	O
struct	O
lex_record	struct
{	O
char	O
*	O
s	array
;	O
FILE	struct
*	O
f	array
;	O
int	O
lookahead_valid	int
;	O
int	O
lookahead	int
;	O
int	O
stack_top	int
;	O
lex_val	union
value_stack	array
[	O
16	int
]	O
;	O
}	O
;	O
static	O
int	O
input	function
(	O
struct	O
lex_record	struct
*	O
p	pointer
)	O
{	O
int	O
val	array
;	O
if	O
(	O
p	pointer
->	O
lookahead_valid	int
)	O
{	O
p	pointer
->	O
lookahead_valid	int
=	O
0	int
;	O
val	array
=	O
p	pointer
->	O
lookahead	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
s	array
)	O
{	O
val	array
=	O
*	O
(	O
p	pointer
->	O
s	array
)	O
++	O
;	O
}	O
else	O
{	O
val	array
=	O
fgetc	function
(	O
p	pointer
->	O
f	array
)	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
char	O
token	array
[	O
256	int
]	O
;	O
static	O
int	O
token_length	int
=	O
0	int
;	O
static	O
token_id	enum
NextTokenx	function
(	O
struct	O
lex_record	struct
*	O
p	pointer
)	O
{	O
register	O
int	O
c	array
,	O
state	pointer
=	O
STATE_INITIAL	int
;	O
token_length	int
=	O
0	int
;	O
while	O
(	O
(	O
c	array
=	O
input	function
(	O
p	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
STATE_INITIAL	int
:	O
if	O
(	O
isspace	function
(	O
c	array
)	O
)	O
{	O
continue	O
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
c	array
)	O
)	O
{	O
token	array
[	O
token_length	int
++	O
]	O
=	O
c	array
;	O
state	pointer
=	O
STATE_INTEGER	int
;	O
}	O
else	O
if	O
(	O
c	array
==	O
'.'	O
)	O
{	O
token	array
[	O
token_length	int
++	O
]	O
=	O
c	array
;	O
state	pointer
=	O
STATE_FLOAT	int
;	O
}	O
else	O
{	O
token	array
[	O
0	int
]	O
=	O
c	array
;	O
token	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
switch	O
(	O
c	array
)	O
{	O
case	O
'-'	O
:	O
return	O
TOKEN_DASH	int
;	O
case	O
'n'	O
:	O
case	O
'N'	O
:	O
return	O
TOKEN_NORTH	int
;	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
return	O
TOKEN_EAST	int
;	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
return	O
TOKEN_SOUTH	int
;	O
case	O
'w'	O
:	O
case	O
'W'	O
:	O
return	O
TOKEN_WEST	int
;	O
default	O
:	O
return	O
EndOfFile	int
;	O
}	O
}	O
break	O
;	O
case	O
STATE_INTEGER	int
:	O
case	O
STATE_FLOAT	int
:	O
if	O
(	O
isspace	function
(	O
c	array
)	O
||	O
c	array
==	O
'-'	O
||	O
toupper	function
(	O
c	array
)	O
==	O
'N'	O
||	O
toupper	function
(	O
c	array
)	O
==	O
'S'	O
||	O
toupper	function
(	O
c	array
)	O
==	O
'W'	O
||	O
toupper	function
(	O
c	array
)	O
==	O
'E'	O
)	O
{	O
token	array
[	O
token_length	int
]	O
=	O
'\0'	O
;	O
unput	O
(	O
p	pointer
,	O
c	array
)	O
;	O
if	O
(	O
state	pointer
==	O
STATE_INTEGER	int
)	O
{	O
lex_value	union
.	O
long_value	long
=	O
atoi	function
(	O
token	array
)	O
;	O
return	O
TOKEN_LONG	int
;	O
}	O
else	O
{	O
lex_value	union
.	O
double_value	double
=	O
atof	function
(	O
token	array
)	O
;	O
return	O
TOKEN_FLOAT	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
c	array
==	O
'.'	O
)	O
{	O
state	pointer
=	O
STATE_FLOAT	int
;	O
}	O
token	array
[	O
token_length	int
++	O
]	O
=	O
c	array
;	O
}	O
break	O
;	O
default	O
:	O
token	array
[	O
token_length	int
++	O
]	O
=	O
c	array
;	O
break	O
;	O
}	O
}	O
return	O
EndOfFile	int
;	O
}	O
static	O
token_id	enum
NextToken	function
(	O
struct	O
lex_record	struct
*	O
p	pointer
)	O
{	O
token_id	enum
t	enum
;	O
t	enum
=	O
NextTokenx	function
(	O
p	pointer
)	O
;	O
return	O
t	enum
;	O
}	O
static	O
int	O
ParseLatitude	function
(	O
struct	O
lex_record	struct
*	O
p	pointer
)	O
{	O
double	O
x	float
=	O
0.0	int
;	O
double	O
divider	double
=	O
1.0	int
;	O
int	O
int_valid	int
=	O
1	int
;	O
token_id	enum
t	enum
;	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
t	enum
)	O
{	O
case	O
TOKEN_NORTH	int
:	O
lex_value	union
.	O
double_value	double
=	O
x	float
;	O
return	O
0	int
;	O
case	O
TOKEN_SOUTH	int
:	O
lex_value	union
.	O
double_value	double
=	O
-	O
x	float
;	O
return	O
0	int
;	O
case	O
TOKEN_LONG	int
:	O
if	O
(	O
int_valid	int
)	O
{	O
x	float
+=	O
lex_value	union
.	O
long_value	long
/	O
divider	double
;	O
divider	double
*=	O
60.0	int
;	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
if	O
(	O
t	enum
==	O
TOKEN_DASH	int
)	O
{	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
}	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
TOKEN_FLOAT	int
:	O
int_valid	int
=	O
0	int
;	O
x	float
+=	O
lex_value	union
.	O
double_value	double
/	O
divider	double
;	O
divider	double
*=	O
60.0	int
;	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
if	O
(	O
t	enum
==	O
TOKEN_DASH	int
)	O
{	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
static	O
int	O
ParseLongitude	function
(	O
struct	O
lex_record	struct
*	O
p	pointer
)	O
{	O
double	O
x	float
=	O
0.0	int
;	O
double	O
divider	double
=	O
1.0	int
;	O
int	O
t	enum
,	O
int_valid	int
=	O
1	int
;	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
t	enum
)	O
{	O
case	O
TOKEN_EAST	int
:	O
lex_value	union
.	O
double_value	double
=	O
x	float
;	O
return	O
0	int
;	O
case	O
TOKEN_WEST	int
:	O
lex_value	union
.	O
double_value	double
=	O
-	O
x	float
;	O
return	O
0	int
;	O
case	O
TOKEN_LONG	int
:	O
if	O
(	O
int_valid	int
)	O
{	O
x	float
+=	O
lex_value	union
.	O
long_value	long
/	O
divider	double
;	O
divider	double
*=	O
60.0	int
;	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
if	O
(	O
t	enum
==	O
TOKEN_DASH	int
)	O
{	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
}	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
TOKEN_FLOAT	int
:	O
int_valid	int
=	O
0	int
;	O
x	float
+=	O
lex_value	union
.	O
double_value	double
/	O
divider	double
;	O
divider	double
*=	O
60.0	int
;	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
if	O
(	O
t	enum
==	O
TOKEN_DASH	int
)	O
{	O
t	enum
=	O
NextToken	function
(	O
p	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
char	O
*	O
DISStringToLatLong	function
(	O
char	O
*	O
s	array
,	O
WorldCoordinates	struct
*	O
w	pointer
)	O
{	O
struct	O
lex_record	struct
p	pointer
;	O
p	pointer
.	O
s	array
=	O
s	array
;	O
p	pointer
.	O
lookahead_valid	int
=	O
0	int
;	O
if	O
(	O
ParseLatitude	function
(	O
&	O
p	pointer
)	O
!=	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
w	pointer
->	O
latitude	double
=	O
DEGtoRAD	O
(	O
lex_value	union
.	O
double_value	double
)	O
;	O
if	O
(	O
ParseLongitude	function
(	O
&	O
p	pointer
)	O
!=	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
w	pointer
->	O
longitude	double
=	O
DEGtoRAD	O
(	O
lex_value	union
.	O
double_value	double
)	O
;	O
w	pointer
->	O
z	float
=	O
0.0	int
;	O
return	O
p	pointer
.	O
s	array
;	O
}	O
