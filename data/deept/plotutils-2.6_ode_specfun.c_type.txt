extern	O
int	O
SIGNGAM	O
;	O
double	O
f_gamma	function
(	O
double	O
x	double
)	O
;	O
double	O
ibeta	function
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
x	double
)	O
;	O
double	O
igamma	function
(	O
double	O
a	double
,	O
double	O
x	double
)	O
;	O
double	O
inverf	function
(	O
double	O
x	double
)	O
;	O
double	O
invnorm	function
(	O
double	O
x	double
)	O
;	O
double	O
norm	function
(	O
double	O
x	double
)	O
;	O
static	O
double	O
ibeta_internal	function
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
x	double
)	O
;	O
double	O
f_gamma	function
(	O
double	O
x	double
)	O
{	O
double	O
y	double
=	O
F_LGAMMA	O
(	O
x	double
)	O
;	O
if	O
(	O
y	double
>	O
MAXEXP	O
)	O
{	O
errno	O
=	O
ERANGE	int
;	O
return	O
HUGE_VAL	O
;	O
}	O
else	O
return	O
SIGNGAM	O
*	O
exp	function
(	O
y	double
)	O
;	O
}	O
double	O
ibeta	function
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
x	double
)	O
{	O
double	O
retval	double
;	O
if	O
(	O
x	double
<	O
0.0	int
||	O
x	double
>	O
1.0	int
||	O
a	double
<=	O
0.0	int
||	O
b	double
<=	O
0.0	int
)	O
{	O
errno	O
=	O
EDOM	int
;	O
return	O
HUGE_VAL	O
;	O
}	O
if	O
(	O
x	double
==	O
0.0	int
||	O
x	double
==	O
1.0	int
)	O
return	O
x	double
;	O
if	O
(	O
a	double
<	O
x	double
*	O
(	O
a	double
+	O
b	double
)	O
)	O
retval	double
=	O
1.0	int
-	O
ibeta_internal	function
(	O
b	double
,	O
a	double
,	O
1.0	int
-	O
x	double
)	O
;	O
else	O
retval	double
=	O
ibeta_internal	function
(	O
a	double
,	O
b	double
,	O
x	double
)	O
;	O
if	O
(	O
retval	double
<	O
0.0	int
)	O
{	O
errno	O
=	O
EDOM	int
;	O
return	O
HUGE_VAL	O
;	O
}	O
return	O
retval	double
;	O
}	O
static	O
double	O
ibeta_internal	function
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
x	double
)	O
{	O
double	O
A0	double
,	O
B0	double
;	O
double	O
A2	double
=	O
1.0	int
;	O
double	O
B2	double
=	O
0.0	int
;	O
double	O
A1	double
=	O
1.0	int
;	O
double	O
B1	double
=	O
1.0	int
;	O
double	O
prefactor	double
;	O
double	O
f0	double
=	O
0.0	int
,	O
f1	double
=	O
1.0	int
;	O
int	O
goodf0	int
,	O
goodf1	int
=	O
1	int
;	O
int	O
j	int
;	O
prefactor	double
=	O
exp	function
(	O
a	double
*	O
log	function
(	O
x	double
)	O
+	O
b	double
*	O
log	function
(	O
1.0	int
-	O
x	double
)	O
+	O
F_LGAMMA	O
(	O
a	double
+	O
b	double
)	O
-	O
F_LGAMMA	O
(	O
a	double
+	O
1.0	int
)	O
-	O
F_LGAMMA	O
(	O
b	double
)	O
)	O
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
ITERMAX	int
;	O
j	int
++	O
)	O
{	O
double	O
aj	double
;	O
int	O
m	int
;	O
if	O
(	O
j	int
%	O
2	int
)	O
{	O
m	int
=	O
(	O
j	int
-	O
1	int
)	O
/	O
2	int
;	O
aj	double
=	O
-	O
(	O
a	double
+	O
m	int
)	O
*	O
(	O
a	double
+	O
b	double
+	O
m	int
)	O
*	O
x	double
/	O
(	O
(	O
a	double
+	O
2	int
*	O
m	int
)	O
*	O
(	O
a	double
+	O
2	int
*	O
m	int
+	O
1	int
)	O
)	O
;	O
}	O
else	O
{	O
m	int
=	O
j	int
/	O
2	int
;	O
aj	double
=	O
m	int
*	O
(	O
b	double
-	O
m	int
)	O
*	O
x	double
/	O
(	O
(	O
a	double
+	O
2	int
*	O
m	int
-	O
1	int
)	O
*	O
(	O
a	double
+	O
2	int
*	O
m	int
)	O
)	O
;	O
}	O
A0	double
=	O
1.0	int
*	O
A1	double
+	O
aj	double
*	O
A2	double
;	O
B0	double
=	O
1.0	int
*	O
B1	double
+	O
aj	double
*	O
B2	double
;	O
if	O
(	O
B0	double
!=	O
0.0	int
)	O
{	O
double	O
ren	double
;	O
ren	double
=	O
1.0	int
/	O
B0	double
;	O
A0	double
*=	O
ren	double
;	O
B0	double
=	O
1.0	int
;	O
A1	double
*=	O
ren	double
;	O
B1	double
*=	O
ren	double
;	O
f0	double
=	O
A0	double
;	O
goodf0	int
=	O
1	int
;	O
if	O
(	O
goodf1	int
&&	O
fabs	function
(	O
f0	double
-	O
f1	double
)	O
<=	O
DMIN	O
(	O
MACHEPS	O
,	O
fabs	function
(	O
f0	double
)	O
*	O
MACHEPS	O
)	O
)	O
return	O
(	O
prefactor	double
/	O
f0	double
)	O
;	O
}	O
else	O
goodf0	int
=	O
0	int
;	O
A2	double
=	O
A1	double
;	O
B2	double
=	O
B1	double
;	O
A1	double
=	O
A0	double
;	O
B1	double
=	O
B0	double
;	O
f1	double
=	O
f0	double
;	O
goodf1	int
=	O
goodf0	int
;	O
}	O
return	O
-	O
1.0	int
;	O
}	O
double	O
igamma	function
(	O
double	O
a	double
,	O
double	O
x	double
)	O
{	O
double	O
arg	double
,	O
prefactor	double
;	O
int	O
i	int
;	O
if	O
(	O
x	double
<	O
0.0	int
||	O
a	double
<=	O
0.0	int
)	O
{	O
errno	O
=	O
EDOM	int
;	O
return	O
HUGE_VAL	O
;	O
}	O
if	O
(	O
x	double
>	O
XBIG	O
)	O
{	O
errno	O
=	O
EDOM	int
;	O
return	O
1.0	int
;	O
}	O
if	O
(	O
x	double
==	O
0.0	int
)	O
return	O
0.0	int
;	O
arg	double
=	O
a	double
*	O
log	function
(	O
x	double
)	O
-	O
x	double
-	O
F_LGAMMA	O
(	O
a	double
+	O
1.0	int
)	O
;	O
if	O
(	O
arg	double
<	O
MINEXP	O
)	O
{	O
errno	O
=	O
EDOM	int
;	O
return	O
0.0	int
;	O
}	O
prefactor	double
=	O
exp	function
(	O
arg	double
)	O
;	O
if	O
(	O
(	O
x	double
>	O
1.0	int
)	O
&&	O
(	O
x	double
>=	O
a	double
+	O
2.0	int
)	O
)	O
{	O
double	O
A0	double
,	O
B0	double
,	O
A1	double
,	O
B1	double
,	O
A2	double
,	O
B2	double
;	O
double	O
f0	double
=	O
0.0	int
,	O
f1	double
;	O
double	O
aa	double
,	O
bb	double
;	O
int	O
goodf0	int
,	O
goodf1	int
=	O
1	int
;	O
aa	double
=	O
1.0	int
-	O
a	double
;	O
bb	double
=	O
aa	double
+	O
x	double
+	O
1.0	int
;	O
A2	double
=	O
1.0	int
;	O
B2	double
=	O
x	double
;	O
A1	double
=	O
x	double
+	O
1.0	int
;	O
B1	double
=	O
x	double
*	O
bb	double
;	O
f1	double
=	O
A1	double
/	O
B1	double
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
ITERMAX	int
;	O
i	int
++	O
)	O
{	O
aa	double
++	O
;	O
bb	double
+=	O
2.0	int
;	O
A0	double
=	O
bb	double
*	O
A1	double
-	O
i	int
*	O
aa	double
*	O
A2	double
;	O
B0	double
=	O
bb	double
*	O
B1	double
-	O
i	int
*	O
aa	double
*	O
B2	double
;	O
if	O
(	O
B0	double
!=	O
0.0	int
)	O
{	O
f0	double
=	O
A0	double
/	O
B0	double
;	O
if	O
(	O
goodf1	int
&&	O
fabs	function
(	O
f0	double
-	O
f1	double
)	O
<=	O
DMIN	O
(	O
MACHEPS	O
,	O
fabs	function
(	O
f0	double
)	O
*	O
MACHEPS	O
)	O
)	O
return	O
(	O
1.0	int
-	O
prefactor	double
*	O
a	double
*	O
f0	double
)	O
;	O
goodf0	int
=	O
1	int
;	O
}	O
else	O
goodf0	int
=	O
0	int
;	O
A2	double
=	O
A1	double
;	O
B2	double
=	O
B1	double
;	O
A1	double
=	O
A0	double
;	O
B1	double
=	O
B0	double
;	O
f1	double
=	O
f0	double
;	O
goodf1	int
=	O
goodf0	int
;	O
if	O
(	O
fabs	function
(	O
A0	double
)	O
>=	O
OFLOW	O
)	O
{	O
A2	double
/=	O
OFLOW	O
;	O
B2	double
/=	O
OFLOW	O
;	O
A1	double
/=	O
OFLOW	O
;	O
B1	double
/=	O
OFLOW	O
;	O
}	O
}	O
}	O
else	O
{	O
double	O
aa	double
,	O
bb	double
,	O
cc	double
;	O
aa	double
=	O
a	double
;	O
bb	double
=	O
1.0	int
;	O
cc	double
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
ITERMAX	int
;	O
i	int
++	O
)	O
{	O
aa	double
++	O
;	O
cc	double
*=	O
(	O
x	double
/	O
aa	double
)	O
;	O
bb	double
+=	O
cc	double
;	O
if	O
(	O
cc	double
<	O
bb	double
*	O
MACHEPS	O
)	O
return	O
prefactor	double
*	O
bb	double
;	O
}	O
}	O
errno	O
=	O
EDOM	int
;	O
return	O
HUGE_VAL	O
;	O
}	O
double	O
norm	function
(	O
double	O
x	double
)	O
{	O
return	O
0.5	int
*	O
(	O
1.0	int
+	O
erf	function
(	O
0.5	int
*	O
M_SQRT2	int
*	O
x	double
)	O
)	O
;	O
}	O
static	O
const	O
double	O
n0	array
[	O
4	int
]	O
=	O
{	O
-	O
6.075593	int
,	O
9.577584	int
,	O
-	O
4.026908	int
,	O
0.3110567	int
}	O
;	O
static	O
const	O
double	O
d0	array
[	O
4	int
]	O
=	O
{	O
-	O
6.855572	int
,	O
12.601905	int
,	O
-	O
6.855985	int
,	O
1.0	int
}	O
;	O
static	O
const	O
double	O
n1	array
[	O
4	int
]	O
=	O
{	O
-	O
39.202359	int
,	O
19.332985	int
,	O
-	O
6.953050	int
,	O
0.9360732	int
}	O
;	O
static	O
const	O
double	O
d1	array
[	O
4	int
]	O
=	O
{	O
-	O
44.27977	int
,	O
21.98546	int
,	O
-	O
7.586103	int
,	O
1.0	int
}	O
;	O
static	O
const	O
double	O
n2	array
[	O
4	int
]	O
=	O
{	O
-	O
5.911558	int
,	O
4.795462	int
,	O
-	O
3.111584	int
,	O
1.005405	int
}	O
;	O
static	O
const	O
double	O
d2	array
[	O
4	int
]	O
=	O
{	O
-	O
6.266786	int
,	O
4.666263	int
,	O
-	O
2.962883	int
,	O
1.0	int
}	O
;	O
static	O
const	O
double	O
n3	array
[	O
4	int
]	O
=	O
{	O
0.09952975	int
,	O
0.51914515	int
,	O
-	O
0.2187214	int
,	O
1.0107864	int
}	O
;	O
static	O
const	O
double	O
d3	array
[	O
4	int
]	O
=	O
{	O
0.09952975	int
,	O
0.5211733	int
,	O
-	O
0.06888301	int
,	O
1.0	int
}	O
;	O
double	O
inverf	function
(	O
double	O
x	double
)	O
{	O
static	O
double	O
num	double
,	O
den	double
,	O
retval	double
;	O
static	O
int	O
xsign	int
;	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
||	O
x	double
>=	O
1.0	int
)	O
{	O
errno	O
=	O
EDOM	int
;	O
return	O
(	O
x	double
<	O
0.0	int
?	O
-	O
HUGE_VAL	O
:	O
HUGE_VAL	O
)	O
;	O
}	O
xsign	int
=	O
(	O
x	double
>=	O
0.0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
x	double
=	O
(	O
xsign	int
>	O
0	int
?	O
x	double
:	O
-	O
x	double
)	O
;	O
if	O
(	O
x	double
<=	O
0.85	int
)	O
{	O
double	O
y	double
;	O
y	double
=	O
x	double
*	O
x	double
;	O
num	double
=	O
n0	array
[	O
0	int
]	O
+	O
n0	array
[	O
1	int
]	O
*	O
y	double
+	O
n0	array
[	O
2	int
]	O
*	O
y	double
*	O
y	double
+	O
n0	array
[	O
3	int
]	O
*	O
y	double
*	O
y	double
*	O
y	double
;	O
den	double
=	O
d0	array
[	O
0	int
]	O
+	O
d0	array
[	O
1	int
]	O
*	O
y	double
+	O
d0	array
[	O
2	int
]	O
*	O
y	double
*	O
y	double
+	O
d0	array
[	O
3	int
]	O
*	O
y	double
*	O
y	double
*	O
y	double
;	O
retval	double
=	O
x	double
*	O
num	double
/	O
den	double
;	O
}	O
else	O
{	O
double	O
w	double
;	O
w	double
=	O
sqrt	function
(	O
-	O
log	function
(	O
1	int
-	O
x	double
*	O
x	double
)	O
)	O
;	O
if	O
(	O
w	double
<=	O
2.5	int
)	O
{	O
num	double
=	O
n1	array
[	O
0	int
]	O
+	O
n1	array
[	O
1	int
]	O
*	O
w	double
+	O
n1	array
[	O
2	int
]	O
*	O
w	double
*	O
w	double
+	O
n1	array
[	O
3	int
]	O
*	O
w	double
*	O
w	double
*	O
w	double
;	O
den	double
=	O
d1	array
[	O
0	int
]	O
+	O
d1	array
[	O
1	int
]	O
*	O
w	double
+	O
d1	array
[	O
2	int
]	O
*	O
w	double
*	O
w	double
+	O
d1	array
[	O
3	int
]	O
*	O
w	double
*	O
w	double
*	O
w	double
;	O
retval	double
=	O
w	double
*	O
num	double
/	O
den	double
;	O
}	O
else	O
if	O
(	O
w	double
<=	O
4.0	int
)	O
{	O
num	double
=	O
n2	array
[	O
0	int
]	O
+	O
n2	array
[	O
1	int
]	O
*	O
w	double
+	O
n2	array
[	O
2	int
]	O
*	O
w	double
*	O
w	double
+	O
n2	array
[	O
3	int
]	O
*	O
w	double
*	O
w	double
*	O
w	double
;	O
den	double
=	O
d2	array
[	O
0	int
]	O
+	O
d2	array
[	O
1	int
]	O
*	O
w	double
+	O
d2	array
[	O
2	int
]	O
*	O
w	double
*	O
w	double
+	O
d2	array
[	O
3	int
]	O
*	O
w	double
*	O
w	double
*	O
w	double
;	O
retval	double
=	O
w	double
*	O
num	double
/	O
den	double
;	O
}	O
else	O
{	O
double	O
w1	double
;	O
w1	double
=	O
1.0	int
/	O
w	double
;	O
num	double
=	O
n3	array
[	O
0	int
]	O
+	O
n3	array
[	O
1	int
]	O
*	O
w1	double
+	O
n3	array
[	O
2	int
]	O
*	O
w1	double
*	O
w1	double
+	O
n3	array
[	O
3	int
]	O
*	O
w1	double
*	O
w1	double
*	O
w1	double
;	O
den	double
=	O
d3	array
[	O
0	int
]	O
+	O
d3	array
[	O
1	int
]	O
*	O
w1	double
+	O
d3	array
[	O
2	int
]	O
*	O
w1	double
*	O
w1	double
+	O
d3	array
[	O
3	int
]	O
*	O
w1	double
*	O
w1	double
*	O
w1	double
;	O
retval	double
=	O
w	double
*	O
num	double
/	O
den	double
;	O
}	O
}	O
return	O
(	O
xsign	int
>	O
0	int
?	O
retval	double
:	O
-	O
retval	double
)	O
;	O
}	O
double	O
invnorm	function
(	O
double	O
x	double
)	O
{	O
if	O
(	O
x	double
<=	O
0.0	int
||	O
x	double
>=	O
1.0	int
)	O
{	O
errno	O
=	O
EDOM	int
;	O
return	O
HUGE_VAL	O
;	O
}	O
return	O
-	O
M_SQRT2	int
*	O
inverf	function
(	O
1.0	int
-	O
2	int
*	O
x	double
)	O
;	O
}	O
