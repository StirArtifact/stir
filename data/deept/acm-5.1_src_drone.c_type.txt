extern	O
double	O
efrandom	function
(	O
void	O
)	O
;	O
void	O
myCoordSys	function
(	O
craft	struct
*	O
c	pointer
,	O
craft	struct
*	O
p	pointer
,	O
VPoint	struct
*	O
pos	struct
,	O
VPoint	struct
*	O
vel	struct
)	O
{	O
VPoint	struct
tpos	struct
;	O
VTransform	function
(	O
&	O
p	pointer
->	O
prevSg	struct
,	O
&	O
c	pointer
->	O
XYZtoNED	struct
,	O
&	O
tpos	struct
)	O
;	O
VReverseTransform_	function
(	O
&	O
tpos	struct
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
pos	struct
)	O
;	O
VTransform_	function
(	O
&	O
p	pointer
->	O
Cg	struct
,	O
&	O
c	pointer
->	O
XYZtoNED	struct
,	O
&	O
tpos	struct
)	O
;	O
VReverseTransform_	function
(	O
&	O
tpos	struct
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
vel	struct
)	O
;	O
}	O
void	O
unholdFireAlarm	function
(	O
char	O
*	O
arg1	pointer
,	O
char	O
*	O
arg2	pointer
)	O
{	O
craft	struct
*	O
c	pointer
=	O
(	O
craft	struct
*	O
)	O
arg1	pointer
;	O
if	O
(	O
c	pointer
->	O
holdCount	short
>	O
0	int
)	O
{	O
c	pointer
->	O
holdCount	short
--	O
;	O
}	O
}	O
int	O
pickTarget	function
(	O
craft	struct
*	O
c	pointer
)	O
{	O
int	O
i	int
,	O
target	long
=	O
-	O
1	int
;	O
craft	struct
*	O
p	pointer
;	O
double	O
d	long
,	O
min	double
;	O
VPoint	struct
pos	struct
,	O
vel	struct
;	O
min	double
=	O
100000000.0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
ptbl	array
;	O
i	int
<	O
MAXPLAYERS	int
;	O
++	O
i	int
,	O
++	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
pIndex	int
==	O
c	pointer
->	O
pIndex	int
||	O
p	pointer
->	O
team	int
==	O
c	pointer
->	O
team	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
p	pointer
->	O
type	pointer
==	O
CT_PLANE	int
||	O
p	pointer
->	O
type	pointer
==	O
CT_DIS_PLANE	int
||	O
p	pointer
->	O
type	pointer
==	O
CT_DRONE	int
)	O
{	O
myCoordSys	function
(	O
c	pointer
,	O
p	pointer
,	O
&	O
pos	struct
,	O
&	O
vel	struct
)	O
;	O
d	long
=	O
mag	O
(	O
pos	struct
)	O
;	O
if	O
(	O
d	long
<	O
min	double
)	O
{	O
min	double
=	O
d	long
;	O
target	long
=	O
p	pointer
->	O
pIndex	int
;	O
}	O
}	O
}	O
return	O
target	long
;	O
}	O
void	O
droneFlyTo	function
(	O
craft	struct
*	O
c	pointer
,	O
VPoint	struct
*	O
pos	struct
)	O
{	O
double	O
d	long
;	O
double	O
phi_rad	double
;	O
d	long
=	O
sqrt	function
(	O
pos	struct
->	O
x	float
*	O
pos	struct
->	O
x	float
+	O
pos	struct
->	O
y	short
*	O
pos	struct
->	O
y	short
+	O
pos	struct
->	O
z	short
*	O
pos	struct
->	O
z	short
)	O
;	O
phi_rad	double
=	O
atan2	function
(	O
pos	struct
->	O
y	short
,	O
-	O
pos	struct
->	O
z	short
)	O
;	O
if	O
(	O
pos	struct
->	O
x	float
<	O
0.0	int
)	O
{	O
if	O
(	O
(	O
fabs	function
(	O
phi_rad	double
)	O
>	O
DEGtoRAD	O
(	O
130.0	int
)	O
)	O
||	O
fabs	function
(	O
phi_rad	double
)	O
<	O
DEGtoRAD	O
(	O
50.0	int
)	O
)	O
{	O
c	pointer
->	O
Se	double
=	O
DRONE_MAX_Se	O
;	O
}	O
}	O
else	O
{	O
c	pointer
->	O
Se	double
=	O
-	O
pos	struct
->	O
z	short
/	O
d	long
*	O
3.0	int
;	O
}	O
if	O
(	O
pos	struct
->	O
z	short
==	O
0.0	int
)	O
{	O
c	pointer
->	O
Sa	double
=	O
0.0	int
;	O
}	O
else	O
if	O
(	O
fabs	function
(	O
phi_rad	double
)	O
>	O
DEGtoRAD	O
(	O
150.0	int
)	O
)	O
{	O
c	pointer
->	O
Sa	double
=	O
-	O
0.2	int
*	O
phi_rad	double
;	O
}	O
else	O
if	O
(	O
fabs	function
(	O
phi_rad	double
)	O
>	O
DEGtoRAD	O
(	O
20.0	int
)	O
)	O
{	O
c	pointer
->	O
Sa	double
=	O
phi_rad	double
;	O
}	O
else	O
{	O
c	pointer
->	O
Sa	double
=	O
0.2	int
*	O
phi_rad	double
;	O
}	O
c	pointer
->	O
Sr	double
=	O
0.0	int
;	O
if	O
(	O
c	pointer
->	O
Se	double
>	O
DRONE_MAX_Se	O
)	O
c	pointer
->	O
Se	double
=	O
DRONE_MAX_Se	O
;	O
else	O
if	O
(	O
c	pointer
->	O
Se	double
<	O
-	O
DRONE_MAX_Se	O
)	O
c	pointer
->	O
Se	double
=	O
-	O
DRONE_MAX_Se	O
;	O
if	O
(	O
c	pointer
->	O
Sa	double
>	O
DRONE_MAX_Sa	O
)	O
c	pointer
->	O
Sa	double
=	O
DRONE_MAX_Sa	O
;	O
else	O
if	O
(	O
c	pointer
->	O
Sa	double
<	O
-	O
DRONE_MAX_Sa	O
)	O
c	pointer
->	O
Sa	double
=	O
-	O
DRONE_MAX_Sa	O
;	O
if	O
(	O
c	pointer
->	O
Sr	double
>	O
DRONE_MAX_Sr	O
)	O
c	pointer
->	O
Sr	double
=	O
DRONE_MAX_Sr	O
;	O
else	O
if	O
(	O
c	pointer
->	O
Sr	double
<	O
-	O
DRONE_MAX_Sr	O
)	O
c	pointer
->	O
Sr	double
=	O
-	O
DRONE_MAX_Sr	O
;	O
c	pointer
->	O
Sa	double
=	O
-	O
c	pointer
->	O
Sa	double
;	O
c	pointer
->	O
Se	double
=	O
-	O
c	pointer
->	O
Se	double
;	O
}	O
int	O
droneCalculationsAttackMode	function
(	O
craft	struct
*	O
c	pointer
)	O
{	O
double	O
d	long
,	O
phi	float
,	O
htime	double
;	O
VPoint	struct
pos	struct
,	O
vel	struct
;	O
int	O
x	float
,	O
y	short
;	O
if	O
(	O
(	O
c	pointer
->	O
flags	short
&	O
FL_END_GAME_DRONE	O
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
curOpponent	short
!=	O
-	O
1	int
&&	O
ptbl	array
[	O
c	pointer
->	O
curOpponent	short
]	O
.	O
type	pointer
==	O
CT_FREE	int
)	O
{	O
c	pointer
->	O
curDroneMode	short
=	O
DM_RETURN	int
;	O
}	O
}	O
else	O
if	O
(	O
c	pointer
->	O
curOpponent	short
==	O
-	O
1	int
||	O
ptbl	array
[	O
c	pointer
->	O
curOpponent	short
]	O
.	O
type	pointer
==	O
CT_FREE	int
)	O
{	O
c	pointer
->	O
curOpponent	short
=	O
pickTarget	function
(	O
c	pointer
)	O
;	O
c	pointer
->	O
holdCount	short
=	O
0	int
;	O
}	O
if	O
(	O
c	pointer
->	O
curOpponent	short
!=	O
-	O
1	int
)	O
{	O
myCoordSys	function
(	O
c	pointer
,	O
&	O
(	O
ptbl	array
[	O
c	pointer
->	O
curOpponent	short
]	O
)	O
,	O
&	O
pos	struct
,	O
&	O
vel	struct
)	O
;	O
droneFlyTo	function
(	O
c	pointer
,	O
&	O
pos	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
holdCount	short
==	O
0	int
&&	O
doWeaponDisplay	function
(	O
c	pointer
,	O
(	O
viewer	struct
*	O
)	O
NULL	O
,	O
&	O
x	float
,	O
&	O
y	short
)	O
==	O
1	int
)	O
{	O
fireWeapon	function
(	O
c	pointer
)	O
;	O
htime	double
=	O
10.0	int
+	O
(	O
efrandom	function
(	O
)	O
+	O
efrandom	function
(	O
)	O
)	O
*	O
5.0	int
;	O
addAlarm	function
(	O
htime	double
,	O
unholdFireAlarm	function
,	O
(	O
char	O
*	O
)	O
c	pointer
,	O
NULL	O
)	O
;	O
c	pointer
->	O
holdCount	short
++	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
droneCalculationsReturnMode	function
(	O
craft	struct
*	O
c	pointer
)	O
{	O
VPoint	struct
tpos	struct
,	O
pos	struct
,	O
vel	struct
;	O
double	O
dist_meters	double
,	O
closure_meters_per_sec	double
;	O
int	O
result	char
=	O
0	int
;	O
VTransform	function
(	O
&	O
c	pointer
->	O
interceptStartPoint	struct
,	O
&	O
c	pointer
->	O
XYZtoNED	struct
,	O
&	O
tpos	struct
)	O
;	O
VReverseTransform_	function
(	O
&	O
tpos	struct
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
&	O
pos	struct
)	O
;	O
VReverseTransform_	function
(	O
&	O
c	pointer
->	O
Cg	struct
,	O
&	O
c	pointer
->	O
trihedral	struct
,	O
&	O
vel	struct
)	O
;	O
dist_meters	double
=	O
mag	O
(	O
pos	struct
)	O
;	O
closure_meters_per_sec	double
=	O
(	O
vel	struct
.	O
x	float
*	O
pos	struct
.	O
x	float
+	O
vel	struct
.	O
y	short
*	O
pos	struct
.	O
y	short
+	O
vel	struct
.	O
z	short
*	O
pos	struct
.	O
z	short
)	O
/	O
dist_meters	double
;	O
droneFlyTo	function
(	O
c	pointer
,	O
&	O
pos	struct
)	O
;	O
if	O
(	O
c	pointer
->	O
curDroneMode	short
==	O
DM_RETURN	int
)	O
{	O
if	O
(	O
closure_meters_per_sec	double
>	O
0.866	int
*	O
FEETtoMETERS	O
(	O
c	pointer
->	O
VT	double
)	O
)	O
{	O
c	pointer
->	O
curDroneMode	short
=	O
DM_RETURN_CAPTURED	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
closure_meters_per_sec	double
<	O
0.0	int
)	O
{	O
killPlayer	function
(	O
c	pointer
)	O
;	O
result	char
=	O
1	int
;	O
}	O
}	O
return	O
result	char
;	O
}	O
int	O
droneCalculations	function
(	O
craft	struct
*	O
c	pointer
)	O
{	O
int	O
result	char
;	O
switch	O
(	O
c	pointer
->	O
curDroneMode	short
)	O
{	O
case	O
DM_ATTACK	int
:	O
result	char
=	O
droneCalculationsAttackMode	function
(	O
c	pointer
)	O
;	O
break	O
;	O
case	O
DM_RETURN	int
:	O
result	char
=	O
droneCalculationsReturnMode	function
(	O
c	pointer
)	O
;	O
break	O
;	O
case	O
DM_RETURN_CAPTURED	int
:	O
result	char
=	O
droneCalculationsReturnMode	function
(	O
c	pointer
)	O
;	O
break	O
;	O
}	O
return	O
result	char
;	O
}	O
extern	O
int	O
controlRequestCallback	pointer
(	O
dis_pdu	union
*	O
pdu	struct
,	O
void	O
*	O
pu	pointer
)	O
;	O
void	O
endGameDistanceCheck	function
(	O
char	O
*	O
p1	pointer
,	O
char	O
*	O
p2	pointer
)	O
{	O
double	O
range_meters	double
;	O
VPoint	struct
del	struct
;	O
craft	struct
*	O
p	pointer
;	O
craft	struct
*	O
c	pointer
=	O
(	O
craft	struct
*	O
)	O
p1	pointer
;	O
viewer	struct
*	O
u	pointer
=	O
(	O
viewer	struct
*	O
)	O
p2	pointer
;	O
int	O
i	int
;	O
int	O
done	int
=	O
0	int
;	O
double	O
threshold_meters	double
;	O
if	O
(	O
c	pointer
->	O
type	pointer
==	O
CT_DIS_PLANE	int
&&	O
(	O
c	pointer
->	O
flags	short
&	O
FL_END_GAME_DRONE	O
)	O
)	O
{	O
if	O
(	O
end_game_threshold_meters	double
<=	O
0.0	int
)	O
{	O
threshold_meters	double
=	O
FEETtoMETERS	O
(	O
c	pointer
->	O
cinfo	pointer
->	O
radarTRange	double
*	O
NM	int
)	O
;	O
}	O
else	O
{	O
threshold_meters	double
=	O
end_game_threshold_meters	double
;	O
}	O
for	O
(	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
ptbl	array
)	O
;	O
(	O
i	int
<	O
MAXPLAYERS	int
)	O
&&	O
(	O
!	O
done	int
)	O
;	O
(	O
++	O
i	int
,	O
++	O
p	pointer
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
pIndex	int
==	O
c	pointer
->	O
pIndex	int
||	O
c	pointer
->	O
team	int
==	O
p	pointer
->	O
team	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
p	pointer
->	O
type	pointer
==	O
CT_PLANE	int
||	O
p	pointer
->	O
type	pointer
==	O
CT_DIS_PLANE	int
||	O
p	pointer
->	O
type	pointer
==	O
CT_DRONE	int
)	O
{	O
del	struct
.	O
x	float
=	O
p	pointer
->	O
Sg	struct
.	O
x	float
-	O
c	pointer
->	O
Sg	struct
.	O
x	float
;	O
del	struct
.	O
y	short
=	O
p	pointer
->	O
Sg	struct
.	O
y	short
-	O
c	pointer
->	O
Sg	struct
.	O
y	short
;	O
del	struct
.	O
z	short
=	O
p	pointer
->	O
Sg	struct
.	O
z	short
-	O
c	pointer
->	O
Sg	struct
.	O
z	short
;	O
range_meters	double
=	O
mag	O
(	O
del	struct
)	O
;	O
if	O
(	O
range_meters	double
<=	O
threshold_meters	double
)	O
{	O
Entity_t	struct
*	O
e	pointer
=	O
dis_getEntityTable	function
(	O
)	O
;	O
c	pointer
->	O
interceptStartPoint	struct
=	O
c	pointer
->	O
Sg	struct
;	O
dis_requestControl	function
(	O
&	O
e	pointer
[	O
c	pointer
->	O
disId	int
]	O
,	O
controlRequestCallback	pointer
,	O
u	pointer
)	O
;	O
done	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
else	O
{	O
done	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
done	int
)	O
{	O
addAlarm	function
(	O
1.0	int
,	O
endGameDistanceCheck	function
,	O
p1	pointer
,	O
p2	pointer
)	O
;	O
}	O
}	O
