static	O
void	O
amd_destroy	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
;	O
static	O
int	O
amd_open	function
(	O
mu_mailbox_t	pointer
,	O
int	O
)	O
;	O
static	O
int	O
amd_close	function
(	O
mu_mailbox_t	pointer
)	O
;	O
static	O
int	O
amd_get_message	function
(	O
mu_mailbox_t	pointer
,	O
size_t	long
,	O
mu_message_t	pointer
*	O
)	O
;	O
static	O
int	O
amd_quick_get_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_message_qid_t	pointer
qid	pointer
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
;	O
static	O
int	O
amd_append_message	function
(	O
mu_mailbox_t	pointer
,	O
mu_message_t	pointer
)	O
;	O
static	O
int	O
amd_messages_count	function
(	O
mu_mailbox_t	pointer
,	O
size_t	long
*	O
)	O
;	O
static	O
int	O
amd_messages_recent	function
(	O
mu_mailbox_t	pointer
,	O
size_t	long
*	O
)	O
;	O
static	O
int	O
amd_message_unseen	function
(	O
mu_mailbox_t	pointer
,	O
size_t	long
*	O
)	O
;	O
static	O
int	O
amd_expunge	function
(	O
mu_mailbox_t	pointer
)	O
;	O
static	O
int	O
amd_sync	function
(	O
mu_mailbox_t	pointer
)	O
;	O
static	O
int	O
amd_uidnext	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
puidnext	pointer
)	O
;	O
static	O
int	O
amd_uidvalidity	function
(	O
mu_mailbox_t	pointer
,	O
unsigned	O
long	O
*	O
)	O
;	O
static	O
int	O
amd_scan	function
(	O
mu_mailbox_t	pointer
,	O
size_t	long
,	O
size_t	long
*	O
)	O
;	O
static	O
int	O
amd_is_updated	function
(	O
mu_mailbox_t	pointer
)	O
;	O
static	O
int	O
amd_get_size	function
(	O
mu_mailbox_t	pointer
,	O
mu_off_t	long
*	O
)	O
;	O
static	O
int	O
amd_body_size	function
(	O
mu_body_t	pointer
body	pointer
,	O
size_t	long
*	O
psize	pointer
)	O
;	O
static	O
int	O
amd_body_lines	function
(	O
mu_body_t	pointer
body	pointer
,	O
size_t	long
*	O
plines	pointer
)	O
;	O
static	O
int	O
amd_header_fill	function
(	O
void	O
*	O
data	pointer
,	O
char	O
*	O
*	O
pbuf	pointer
,	O
size_t	long
*	O
plen	pointer
)	O
;	O
static	O
int	O
amd_get_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
*	O
pflags	pointer
)	O
;	O
static	O
int	O
amd_set_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
flags	int
)	O
;	O
static	O
int	O
amd_unset_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
flags	int
)	O
;	O
static	O
int	O
amd_pool_open	function
(	O
struct	O
_amd_message	struct
*	O
mhm	pointer
)	O
;	O
static	O
int	O
amd_pool_open_count	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
)	O
;	O
static	O
void	O
amd_pool_flush	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
)	O
;	O
static	O
struct	O
_amd_message	struct
*	O
*	O
amd_pool_lookup	function
(	O
struct	O
_amd_message	struct
*	O
mhm	pointer
)	O
;	O
static	O
int	O
amd_envelope_date	function
(	O
mu_envelope_t	pointer
envelope	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	int
,	O
size_t	long
*	O
psize	pointer
)	O
;	O
static	O
int	O
amd_envelope_sender	function
(	O
mu_envelope_t	pointer
envelope	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	int
,	O
size_t	long
*	O
psize	pointer
)	O
;	O
static	O
int	O
amd_remove_mbox	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
;	O
static	O
int	O
amd_body_stream_read	function
(	O
mu_stream_t	pointer
str	pointer
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buflen	long
,	O
size_t	long
*	O
pnread	pointer
)	O
;	O
static	O
int	O
amd_body_stream_readdelim	function
(	O
mu_stream_t	pointer
is	pointer
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buflen	long
,	O
int	O
delim	pointer
,	O
size_t	long
*	O
pnread	pointer
)	O
;	O
static	O
int	O
amd_body_stream_size	function
(	O
mu_stream_t	pointer
str	pointer
,	O
mu_off_t	long
*	O
psize	pointer
)	O
;	O
static	O
int	O
amd_body_stream_seek	function
(	O
mu_stream_t	pointer
str	pointer
,	O
mu_off_t	long
off	long
,	O
mu_off_t	long
*	O
presult	pointer
)	O
;	O
struct	O
_amd_body_stream	struct
{	O
struct	O
_mu_stream	struct
stream	pointer
;	O
mu_body_t	pointer
body	pointer
;	O
mu_off_t	long
off	long
;	O
}	O
;	O
int	O
_amd_prop_fetch_off	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
mu_off_t	long
*	O
pval	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
mu_off_t	long
n	long
=	O
0	int
;	O
if	O
(	O
!	O
amd	pointer
->	O
prop	pointer
||	O
mu_property_sget_value	function
(	O
amd	pointer
->	O
prop	pointer
,	O
name	pointer
,	O
&	O
p	pointer
)	O
)	O
return	O
MU_ERR_NOENT	O
;	O
if	O
(	O
!	O
pval	pointer
)	O
return	O
0	int
;	O
for	O
(	O
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
!	O
mu_isdigit	O
(	O
*	O
p	pointer
)	O
)	O
return	O
EINVAL	int
;	O
n	long
=	O
n	long
*	O
10	int
+	O
*	O
p	pointer
-	O
'0'	O
;	O
}	O
*	O
pval	pointer
=	O
n	long
;	O
return	O
0	int
;	O
}	O
int	O
_amd_prop_fetch_size	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
*	O
pval	pointer
)	O
{	O
mu_off_t	long
n	long
;	O
int	O
rc	int
=	O
_amd_prop_fetch_off	function
(	O
amd	pointer
,	O
name	pointer
,	O
&	O
n	long
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
size_t	long
s	pointer
=	O
n	long
;	O
if	O
(	O
s	pointer
!=	O
n	long
)	O
return	O
ERANGE	int
;	O
if	O
(	O
pval	pointer
)	O
*	O
pval	pointer
=	O
s	pointer
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
_amd_prop_fetch_ulong	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
unsigned	O
long	O
*	O
pval	pointer
)	O
{	O
mu_off_t	long
n	long
;	O
int	O
rc	int
=	O
_amd_prop_fetch_off	function
(	O
amd	pointer
,	O
name	pointer
,	O
&	O
n	long
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
unsigned	O
long	O
s	pointer
=	O
n	long
;	O
if	O
(	O
s	pointer
!=	O
n	long
)	O
return	O
ERANGE	int
;	O
if	O
(	O
pval	pointer
)	O
*	O
pval	pointer
=	O
s	pointer
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
_amd_prop_store_off	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
mu_off_t	long
val	array
)	O
{	O
char	O
nbuf	array
[	O
128	int
]	O
;	O
char	O
*	O
p	pointer
;	O
int	O
sign	int
=	O
0	int
;	O
p	pointer
=	O
nbuf	array
+	O
sizeof	O
nbuf	array
;	O
*	O
--	O
p	pointer
=	O
0	int
;	O
if	O
(	O
val	array
<	O
0	int
)	O
{	O
sign	int
=	O
1	int
;	O
val	array
=	O
-	O
val	array
;	O
}	O
do	O
{	O
unsigned	O
d	int
=	O
val	array
%	O
10	int
;	O
if	O
(	O
p	pointer
==	O
nbuf	array
)	O
return	O
ERANGE	int
;	O
*	O
--	O
p	pointer
=	O
d	int
+	O
'0'	O
;	O
val	array
/=	O
10	int
;	O
}	O
while	O
(	O
val	array
)	O
;	O
if	O
(	O
sign	int
)	O
{	O
if	O
(	O
p	pointer
==	O
nbuf	array
)	O
return	O
ERANGE	int
;	O
*	O
--	O
p	pointer
=	O
'-'	O
;	O
}	O
return	O
mu_property_set_value	function
(	O
amd	pointer
->	O
prop	pointer
,	O
name	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
_amd_prop_create	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_mh_prop	struct
*	O
mhprop	pointer
;	O
mhprop	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
mhprop	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
mhprop	pointer
)	O
return	O
ENOMEM	int
;	O
mhprop	pointer
->	O
filename	pointer
=	O
mu_make_file_name	O
(	O
amd	pointer
->	O
name	pointer
,	O
_MU_AMD_PROP_FILE_NAME	pointer
)	O
;	O
if	O
(	O
!	O
mhprop	pointer
->	O
filename	pointer
)	O
{	O
free	function
(	O
mhprop	pointer
)	O
;	O
return	O
errno	O
;	O
}	O
rc	int
=	O
mu_property_create_init	function
(	O
&	O
amd	pointer
->	O
prop	pointer
,	O
mu_mh_property_init	function
,	O
mhprop	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"mu_property_create_init: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
free	function
(	O
mhprop	pointer
->	O
filename	pointer
)	O
;	O
free	function
(	O
mhprop	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
amd_msg_bsearch	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
mu_off_t	long
first	pointer
,	O
mu_off_t	long
last	long
,	O
struct	O
_amd_message	struct
*	O
msg	pointer
,	O
mu_off_t	long
*	O
pret	pointer
)	O
{	O
mu_off_t	long
mid	long
;	O
int	O
rc	int
;	O
if	O
(	O
last	long
<	O
first	pointer
)	O
return	O
1	int
;	O
mid	long
=	O
(	O
first	pointer
+	O
last	long
)	O
/	O
2	int
;	O
rc	int
=	O
amd	pointer
->	O
msg_cmp	pointer
(	O
amd	pointer
->	O
msg_array	pointer
[	O
mid	long
]	O
,	O
msg	pointer
)	O
;	O
if	O
(	O
rc	int
>	O
0	int
)	O
return	O
amd_msg_bsearch	function
(	O
amd	pointer
,	O
first	pointer
,	O
mid	long
-	O
1	int
,	O
msg	pointer
,	O
pret	pointer
)	O
;	O
*	O
pret	pointer
=	O
mid	long
;	O
if	O
(	O
rc	int
<	O
0	int
)	O
return	O
amd_msg_bsearch	function
(	O
amd	pointer
,	O
mid	long
+	O
1	int
,	O
last	long
,	O
msg	pointer
,	O
pret	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
amd_msg_lookup	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
struct	O
_amd_message	struct
*	O
msg	pointer
,	O
size_t	long
*	O
pret	pointer
)	O
{	O
int	O
rc	int
;	O
mu_off_t	long
i	long
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
{	O
*	O
pret	pointer
=	O
0	int
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
amd	pointer
->	O
msg_cmp	pointer
(	O
msg	pointer
,	O
amd	pointer
->	O
msg_array	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
)	O
{	O
*	O
pret	pointer
=	O
0	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
*	O
pret	pointer
=	O
1	int
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
amd	pointer
->	O
msg_cmp	pointer
(	O
msg	pointer
,	O
amd	pointer
->	O
msg_array	pointer
[	O
amd	pointer
->	O
msg_count	long
-	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
>	O
0	int
)	O
{	O
*	O
pret	pointer
=	O
amd	pointer
->	O
msg_count	long
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
*	O
pret	pointer
=	O
amd	pointer
->	O
msg_count	long
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
amd_msg_bsearch	function
(	O
amd	pointer
,	O
0	int
,	O
amd	pointer
->	O
msg_count	long
-	O
1	int
,	O
msg	pointer
,	O
&	O
i	long
)	O
;	O
*	O
pret	pointer
=	O
i	long
+	O
1	int
;	O
return	O
rc	int
;	O
}	O
int	O
amd_array_expand	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
size_t	long
index	function
)	O
{	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
amd	pointer
->	O
msg_max	long
)	O
{	O
struct	O
_amd_message	struct
*	O
*	O
p	pointer
;	O
amd	pointer
->	O
msg_max	long
+=	O
AMD_MSG_INC	int
;	O
p	pointer
=	O
realloc	function
(	O
amd	pointer
->	O
msg_array	pointer
,	O
amd	pointer
->	O
msg_max	long
*	O
sizeof	O
(	O
amd	pointer
->	O
msg_array	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
amd	pointer
->	O
msg_max	long
-=	O
AMD_MSG_INC	int
;	O
return	O
ENOMEM	int
;	O
}	O
amd	pointer
->	O
msg_array	pointer
=	O
p	pointer
;	O
}	O
if	O
(	O
amd	pointer
->	O
msg_count	long
>	O
index	function
)	O
memmove	function
(	O
&	O
amd	pointer
->	O
msg_array	pointer
[	O
index	function
+	O
1	int
]	O
,	O
&	O
amd	pointer
->	O
msg_array	pointer
[	O
index	function
]	O
,	O
(	O
amd	pointer
->	O
msg_count	long
-	O
index	function
)	O
*	O
sizeof	O
(	O
amd	pointer
->	O
msg_array	pointer
[	O
0	int
]	O
)	O
)	O
;	O
amd	pointer
->	O
msg_count	long
++	O
;	O
return	O
0	int
;	O
}	O
int	O
amd_array_shrink	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
size_t	long
index	function
,	O
size_t	long
count	pointer
)	O
{	O
if	O
(	O
amd	pointer
->	O
msg_count	long
-	O
index	function
-	O
1	int
&&	O
index	function
<	O
amd	pointer
->	O
msg_count	long
)	O
memmove	function
(	O
&	O
amd	pointer
->	O
msg_array	pointer
[	O
index	function
-	O
count	pointer
+	O
1	int
]	O
,	O
&	O
amd	pointer
->	O
msg_array	pointer
[	O
index	function
+	O
1	int
]	O
,	O
(	O
amd	pointer
->	O
msg_count	long
-	O
index	function
-	O
1	int
)	O
*	O
sizeof	O
(	O
amd	pointer
->	O
msg_array	pointer
[	O
0	int
]	O
)	O
)	O
;	O
amd	pointer
->	O
msg_count	long
-=	O
count	pointer
;	O
return	O
0	int
;	O
}	O
int	O
amd_init_mailbox	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
amd_size	long
,	O
struct	O
_amd_data	struct
*	O
*	O
pamd	pointer
)	O
{	O
int	O
status	int
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
;	O
if	O
(	O
mailbox	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
amd_size	long
<	O
sizeof	O
(	O
*	O
amd	pointer
)	O
)	O
return	O
EINVAL	int
;	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
=	O
calloc	function
(	O
1	int
,	O
amd_size	long
)	O
;	O
if	O
(	O
amd	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
amd	pointer
->	O
mailbox	pointer
=	O
mailbox	pointer
;	O
status	int
=	O
mu_url_aget_path	function
(	O
mailbox	pointer
->	O
url	pointer
,	O
&	O
amd	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
amd	pointer
)	O
;	O
mailbox	pointer
->	O
data	pointer
=	O
NULL	O
;	O
return	O
status	int
;	O
}	O
mailbox	pointer
->	O
_destroy	pointer
=	O
amd_destroy	function
;	O
mailbox	pointer
->	O
_open	pointer
=	O
amd_open	function
;	O
mailbox	pointer
->	O
_close	pointer
=	O
amd_close	function
;	O
mailbox	pointer
->	O
_get_message	pointer
=	O
amd_get_message	function
;	O
mailbox	pointer
->	O
_quick_get_message	pointer
=	O
amd_quick_get_message	function
;	O
mailbox	pointer
->	O
_append_message	pointer
=	O
amd_append_message	function
;	O
mailbox	pointer
->	O
_messages_count	pointer
=	O
amd_messages_count	function
;	O
mailbox	pointer
->	O
_messages_recent	pointer
=	O
amd_messages_recent	function
;	O
mailbox	pointer
->	O
_message_unseen	pointer
=	O
amd_message_unseen	function
;	O
mailbox	pointer
->	O
_expunge	pointer
=	O
amd_expunge	function
;	O
mailbox	pointer
->	O
_sync	pointer
=	O
amd_sync	function
;	O
mailbox	pointer
->	O
_uidvalidity	pointer
=	O
amd_uidvalidity	function
;	O
mailbox	pointer
->	O
_uidnext	pointer
=	O
amd_uidnext	function
;	O
mailbox	pointer
->	O
_scan	pointer
=	O
amd_scan	function
;	O
mailbox	pointer
->	O
_is_updated	pointer
=	O
amd_is_updated	function
;	O
mailbox	pointer
->	O
_get_size	pointer
=	O
amd_get_size	function
;	O
mailbox	pointer
->	O
_remove	pointer
=	O
amd_remove_mbox	function
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_TRACE1	int
,	O
(	O
"amd_init(%s)"	pointer
,	O
amd	pointer
->	O
name	pointer
)	O
)	O
;	O
*	O
pamd	pointer
=	O
amd	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
amd_destroy	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
size_t	long
i	long
;	O
if	O
(	O
!	O
amd	pointer
)	O
return	O
;	O
amd_pool_flush	function
(	O
amd	pointer
)	O
;	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
amd	pointer
->	O
msg_count	long
;	O
i	long
++	O
)	O
{	O
mu_message_destroy	function
(	O
&	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
->	O
message	pointer
,	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
amd	pointer
->	O
msg_free	pointer
)	O
amd	pointer
->	O
msg_free	pointer
(	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
)	O
;	O
free	function
(	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
)	O
;	O
}	O
free	function
(	O
amd	pointer
->	O
msg_array	pointer
)	O
;	O
mu_property_destroy	function
(	O
&	O
amd	pointer
->	O
prop	pointer
)	O
;	O
if	O
(	O
amd	pointer
->	O
name	pointer
)	O
free	function
(	O
amd	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
amd	pointer
)	O
;	O
mailbox	pointer
->	O
data	pointer
=	O
NULL	O
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
}	O
static	O
int	O
amd_open	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
int	O
flags	int
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
mailbox	pointer
->	O
flags	int
=	O
flags	int
;	O
if	O
(	O
stat	struct
(	O
amd	pointer
->	O
name	pointer
,	O
&	O
st	pointer
)	O
<	O
0	int
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
MU_STREAM_CREAT	int
)	O
&&	O
errno	O
==	O
ENOENT	int
)	O
{	O
int	O
rc	int
;	O
int	O
perms	int
=	O
mu_stream_flags_to_mode	function
(	O
flags	int
,	O
1	int
)	O
;	O
if	O
(	O
mkdir	function
(	O
amd	pointer
->	O
name	pointer
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IXUSR	O
|	O
perms	int
)	O
)	O
return	O
errno	O
;	O
if	O
(	O
stat	struct
(	O
amd	pointer
->	O
name	pointer
,	O
&	O
st	pointer
)	O
<	O
0	int
)	O
return	O
errno	O
;	O
if	O
(	O
amd	pointer
->	O
create	pointer
&&	O
(	O
rc	int
=	O
amd	pointer
->	O
create	pointer
(	O
amd	pointer
,	O
flags	int
)	O
)	O
)	O
return	O
rc	int
;	O
}	O
else	O
return	O
errno	O
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
access	function
(	O
amd	pointer
->	O
name	pointer
,	O
(	O
flags	int
&	O
(	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_APPEND	int
)	O
)	O
?	O
W_OK	int
:	O
R_OK	int
|	O
X_OK	int
)	O
)	O
return	O
errno	O
;	O
_amd_prop_create	function
(	O
amd	pointer
)	O
;	O
if	O
(	O
mailbox	pointer
->	O
locker	pointer
==	O
NULL	O
)	O
mu_locker_create	function
(	O
&	O
mailbox	pointer
->	O
locker	pointer
,	O
"/dev/null"	pointer
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_close	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
;	O
int	O
i	long
;	O
if	O
(	O
!	O
mailbox	pointer
)	O
return	O
EINVAL	int
;	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
amd_pool_flush	function
(	O
amd	pointer
)	O
;	O
mu_monitor_wrlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
amd	pointer
->	O
msg_count	long
;	O
i	long
++	O
)	O
{	O
mu_message_destroy	function
(	O
&	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
->	O
message	pointer
,	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
amd	pointer
->	O
msg_free	pointer
)	O
amd	pointer
->	O
msg_free	pointer
(	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
)	O
;	O
free	function
(	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
)	O
;	O
}	O
free	function
(	O
amd	pointer
->	O
msg_array	pointer
)	O
;	O
amd	pointer
->	O
msg_array	pointer
=	O
NULL	O
;	O
mu_property_save	function
(	O
amd	pointer
->	O
prop	pointer
)	O
;	O
amd	pointer
->	O
msg_count	long
=	O
0	int
;	O
amd	pointer
->	O
msg_max	long
=	O
0	int
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_message_qid	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mu_message_qid_t	pointer
*	O
pqid	pointer
)	O
{	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
return	O
mhm	pointer
->	O
amd	pointer
->	O
cur_msg_file_name	pointer
(	O
mhm	pointer
,	O
pqid	pointer
)	O
;	O
}	O
struct	O
_amd_message	struct
*	O
_amd_get_message	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
size_t	long
msgno	long
)	O
{	O
msgno	long
--	O
;	O
if	O
(	O
msgno	long
>=	O
amd	pointer
->	O
msg_count	long
)	O
return	O
NULL	O
;	O
return	O
amd	pointer
->	O
msg_array	pointer
[	O
msgno	long
]	O
;	O
}	O
static	O
int	O
_amd_attach_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
struct	O
_amd_message	struct
*	O
mhm	pointer
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
{	O
int	O
status	int
;	O
mu_message_t	pointer
msg	pointer
;	O
if	O
(	O
mhm	pointer
->	O
message	pointer
)	O
{	O
if	O
(	O
pmsg	pointer
)	O
*	O
pmsg	pointer
=	O
mhm	pointer
->	O
message	pointer
;	O
return	O
0	int
;	O
}	O
status	int
=	O
mu_message_create	function
(	O
&	O
msg	pointer
,	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
{	O
mu_header_t	pointer
header	pointer
=	O
NULL	O
;	O
status	int
=	O
mu_header_create	function
(	O
&	O
header	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
mu_message_destroy	function
(	O
&	O
msg	pointer
,	O
mhm	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mu_header_set_fill	function
(	O
header	pointer
,	O
amd_header_fill	function
,	O
msg	pointer
)	O
;	O
mu_message_set_header	function
(	O
msg	pointer
,	O
header	pointer
,	O
mhm	pointer
)	O
;	O
}	O
{	O
mu_attribute_t	pointer
attribute	pointer
;	O
status	int
=	O
mu_attribute_create	function
(	O
&	O
attribute	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
mu_message_destroy	function
(	O
&	O
msg	pointer
,	O
mhm	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mu_attribute_set_get_flags	function
(	O
attribute	pointer
,	O
amd_get_attr_flags	function
,	O
msg	pointer
)	O
;	O
mu_attribute_set_set_flags	function
(	O
attribute	pointer
,	O
amd_set_attr_flags	function
,	O
msg	pointer
)	O
;	O
mu_attribute_set_unset_flags	function
(	O
attribute	pointer
,	O
amd_unset_attr_flags	function
,	O
msg	pointer
)	O
;	O
mu_message_set_attribute	function
(	O
msg	pointer
,	O
attribute	pointer
,	O
mhm	pointer
)	O
;	O
}	O
{	O
mu_body_t	pointer
body	pointer
=	O
NULL	O
;	O
struct	O
_amd_body_stream	struct
*	O
str	pointer
;	O
if	O
(	O
(	O
status	int
=	O
mu_body_create	function
(	O
&	O
body	pointer
,	O
msg	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
status	int
;	O
str	pointer
=	O
(	O
struct	O
_amd_body_stream	struct
*	O
)	O
_mu_stream_create	function
(	O
sizeof	O
(	O
*	O
str	pointer
)	O
,	O
mailbox	pointer
->	O
flags	int
|	O
MU_STREAM_SEEK	int
|	O
_MU_STR_OPEN	int
)	O
;	O
if	O
(	O
!	O
str	pointer
)	O
{	O
mu_body_destroy	function
(	O
&	O
body	pointer
,	O
msg	pointer
)	O
;	O
mu_message_destroy	function
(	O
&	O
msg	pointer
,	O
mhm	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
str	pointer
->	O
stream	pointer
.	O
read	pointer
=	O
amd_body_stream_read	function
;	O
str	pointer
->	O
stream	pointer
.	O
readdelim	pointer
=	O
amd_body_stream_readdelim	function
;	O
str	pointer
->	O
stream	pointer
.	O
size	long
=	O
amd_body_stream_size	function
;	O
str	pointer
->	O
stream	pointer
.	O
seek	pointer
=	O
amd_body_stream_seek	function
;	O
mu_body_set_stream	function
(	O
body	pointer
,	O
(	O
mu_stream_t	pointer
)	O
str	pointer
,	O
msg	pointer
)	O
;	O
mu_body_clear_modified	function
(	O
body	pointer
)	O
;	O
mu_body_set_size	function
(	O
body	pointer
,	O
amd_body_size	function
,	O
msg	pointer
)	O
;	O
mu_body_set_lines	function
(	O
body	pointer
,	O
amd_body_lines	function
,	O
msg	pointer
)	O
;	O
mu_message_set_body	function
(	O
msg	pointer
,	O
body	pointer
,	O
mhm	pointer
)	O
;	O
str	pointer
->	O
body	pointer
=	O
body	pointer
;	O
}	O
{	O
mu_envelope_t	pointer
envelope	pointer
=	O
NULL	O
;	O
status	int
=	O
mu_envelope_create	function
(	O
&	O
envelope	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
mu_message_destroy	function
(	O
&	O
msg	pointer
,	O
mhm	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mu_envelope_set_sender	function
(	O
envelope	pointer
,	O
amd_envelope_sender	function
,	O
msg	pointer
)	O
;	O
mu_envelope_set_date	function
(	O
envelope	pointer
,	O
amd_envelope_date	function
,	O
msg	pointer
)	O
;	O
mu_message_set_envelope	function
(	O
msg	pointer
,	O
envelope	pointer
,	O
mhm	pointer
)	O
;	O
}	O
if	O
(	O
mhm	pointer
->	O
amd	pointer
->	O
message_uid	pointer
)	O
mu_message_set_uid	function
(	O
msg	pointer
,	O
mhm	pointer
->	O
amd	pointer
->	O
message_uid	pointer
,	O
mhm	pointer
)	O
;	O
mu_message_set_qid	function
(	O
msg	pointer
,	O
amd_message_qid	function
,	O
mhm	pointer
)	O
;	O
mhm	pointer
->	O
message	pointer
=	O
msg	pointer
;	O
mu_message_set_mailbox	function
(	O
msg	pointer
,	O
mailbox	pointer
,	O
mhm	pointer
)	O
;	O
mu_message_clear_modified	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
pmsg	pointer
)	O
*	O
pmsg	pointer
=	O
msg	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_amd_scan0	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
size_t	long
msgno	long
,	O
size_t	long
*	O
pcount	pointer
,	O
int	O
do_notify	int
)	O
{	O
unsigned	O
long	O
uidval	long
;	O
int	O
status	int
=	O
amd	pointer
->	O
scan0	pointer
(	O
amd	pointer
->	O
mailbox	pointer
,	O
msgno	long
,	O
pcount	pointer
,	O
do_notify	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
||	O
_amd_prop_fetch_ulong	function
(	O
amd	pointer
,	O
_MU_AMD_PROP_UIDVALIDITY	pointer
,	O
&	O
uidval	long
)	O
||	O
!	O
uidval	long
)	O
{	O
uidval	long
=	O
(	O
unsigned	O
long	O
)	O
amd	pointer
->	O
mtime	long
;	O
_amd_prop_store_off	function
(	O
amd	pointer
,	O
_MU_AMD_PROP_UIDVALIDITY	pointer
,	O
uidval	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_get_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
msgno	long
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
{	O
int	O
status	int
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
;	O
if	O
(	O
pmsg	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
if	O
(	O
amd	pointer
==	O
NULL	O
||	O
msgno	long
<	O
1	int
)	O
return	O
EINVAL	int
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
{	O
status	int
=	O
_amd_scan0	function
(	O
amd	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
if	O
(	O
(	O
mhm	pointer
=	O
_amd_get_message	function
(	O
amd	pointer
,	O
msgno	long
)	O
)	O
==	O
NULL	O
)	O
return	O
MU_ERR_NOENT	O
;	O
return	O
_amd_attach_message	function
(	O
mailbox	pointer
,	O
mhm	pointer
,	O
pmsg	pointer
)	O
;	O
}	O
static	O
int	O
amd_quick_get_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_message_qid_t	pointer
qid	pointer
,	O
mu_message_t	pointer
*	O
pmsg	pointer
)	O
{	O
int	O
status	int
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
)	O
{	O
mu_message_qid_t	pointer
vqid	pointer
;	O
mu_message_t	pointer
msg	pointer
=	O
amd	pointer
->	O
msg_array	pointer
[	O
0	int
]	O
->	O
message	pointer
;	O
status	int
=	O
mu_message_get_qid	function
(	O
msg	pointer
,	O
&	O
vqid	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
strcmp	function
(	O
qid	pointer
,	O
vqid	pointer
)	O
;	O
free	function
(	O
vqid	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
MU_ERR_EXISTS	O
;	O
*	O
pmsg	pointer
=	O
msg	pointer
;	O
}	O
else	O
if	O
(	O
amd	pointer
->	O
qfetch	pointer
)	O
{	O
status	int
=	O
amd	pointer
->	O
qfetch	pointer
(	O
amd	pointer
,	O
qid	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
_amd_attach_message	function
(	O
mailbox	pointer
,	O
amd	pointer
->	O
msg_array	pointer
[	O
0	int
]	O
,	O
pmsg	pointer
)	O
;	O
}	O
return	O
ENOSYS	int
;	O
}	O
static	O
int	O
_amd_tempfile	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
FILE	struct
*	O
*	O
pfile	pointer
,	O
char	O
*	O
*	O
namep	pointer
)	O
{	O
struct	O
mu_tempfile_hints	struct
hints	pointer
;	O
int	O
fd	int
,	O
rc	int
;	O
hints	pointer
.	O
tmpdir	pointer
=	O
amd	pointer
->	O
name	pointer
;	O
rc	int
=	O
mu_tempfile	function
(	O
&	O
hints	pointer
,	O
MU_TEMPFILE_TMPDIR	int
,	O
&	O
fd	int
,	O
namep	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
if	O
(	O
(	O
*	O
pfile	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"w"	pointer
)	O
)	O
==	O
NULL	O
)	O
rc	int
=	O
errno	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_amd_delim	function
(	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
str	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
for	O
(	O
;	O
*	O
str	pointer
==	O
'-'	O
;	O
str	pointer
++	O
)	O
;	O
for	O
(	O
;	O
*	O
str	pointer
==	O
' '	O
||	O
*	O
str	pointer
==	O
'\t'	O
;	O
str	pointer
++	O
)	O
;	O
}	O
return	O
str	pointer
[	O
0	int
]	O
==	O
'\n'	O
;	O
}	O
static	O
int	O
_amd_message_save	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
struct	O
_amd_message	struct
*	O
mhm	pointer
,	O
int	O
expunge	int
)	O
{	O
mu_stream_t	pointer
stream	pointer
=	O
NULL	O
;	O
char	O
*	O
name	pointer
=	O
NULL	O
,	O
*	O
buf	pointer
=	O
NULL	O
,	O
*	O
msg_name	pointer
,	O
*	O
old_name	pointer
;	O
size_t	long
n	long
;	O
size_t	long
bsize	long
;	O
size_t	long
nlines	long
,	O
nbytes	long
;	O
size_t	long
new_body_start	long
,	O
new_header_lines	long
;	O
FILE	struct
*	O
fp	pointer
;	O
mu_message_t	pointer
msg	pointer
=	O
mhm	pointer
->	O
message	pointer
;	O
mu_header_t	pointer
hdr	pointer
;	O
int	O
status	int
;	O
mu_attribute_t	pointer
attr	pointer
;	O
mu_body_t	pointer
body	pointer
;	O
const	O
char	O
*	O
sbuf	pointer
;	O
mu_envelope_t	pointer
env	pointer
=	O
NULL	O
;	O
status	int
=	O
mu_message_size	function
(	O
msg	pointer
,	O
&	O
bsize	long
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
amd	pointer
->	O
new_msg_file_name	pointer
(	O
mhm	pointer
,	O
mhm	pointer
->	O
attr_flags	int
,	O
expunge	int
,	O
&	O
msg_name	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
!	O
msg_name	pointer
)	O
{	O
char	O
*	O
old_name	pointer
;	O
status	int
=	O
amd	pointer
->	O
cur_msg_file_name	pointer
(	O
mhm	pointer
,	O
&	O
old_name	pointer
)	O
;	O
free	function
(	O
msg_name	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
&&	O
unlink	function
(	O
old_name	pointer
)	O
)	O
status	int
=	O
errno	O
;	O
free	function
(	O
old_name	pointer
)	O
;	O
return	O
status	int
;	O
}	O
status	int
=	O
_amd_tempfile	function
(	O
mhm	pointer
->	O
amd	pointer
,	O
&	O
fp	pointer
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
msg_name	pointer
)	O
;	O
return	O
status	int
;	O
}	O
for	O
(	O
;	O
bsize	long
>	O
1	int
;	O
bsize	long
/=	O
2	int
)	O
if	O
(	O
(	O
buf	pointer
=	O
malloc	function
(	O
bsize	long
)	O
)	O
)	O
break	O
;	O
if	O
(	O
!	O
bsize	long
)	O
{	O
unlink	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
free	function
(	O
msg_name	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
;	O
mu_header_get_streamref	function
(	O
hdr	pointer
,	O
&	O
stream	pointer
)	O
;	O
status	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
unlink	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
free	function
(	O
msg_name	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
return	O
status	int
;	O
}	O
nlines	long
=	O
nbytes	long
=	O
0	int
;	O
while	O
(	O
(	O
status	int
=	O
mu_stream_readline	function
(	O
stream	pointer
,	O
buf	pointer
,	O
bsize	long
,	O
&	O
n	long
)	O
)	O
==	O
0	int
&&	O
n	long
!=	O
0	int
)	O
{	O
if	O
(	O
_amd_delim	function
(	O
buf	pointer
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
"status:"	pointer
,	O
7	int
)	O
==	O
0	int
||	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
"x-imapbase:"	pointer
,	O
11	int
)	O
==	O
0	int
||	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
"x-uid:"	pointer
,	O
6	int
)	O
==	O
0	int
||	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
MU_HEADER_ENV_DATE	pointer
":"	pointer
,	O
sizeof	O
(	O
MU_HEADER_ENV_DATE	pointer
)	O
)	O
==	O
0	int
||	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
MU_HEADER_ENV_SENDER	pointer
":"	pointer
,	O
sizeof	O
(	O
MU_HEADER_ENV_SENDER	pointer
)	O
)	O
==	O
0	int
)	O
)	O
{	O
nlines	long
++	O
;	O
nbytes	long
+=	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
}	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
mu_message_get_envelope	function
(	O
msg	pointer
,	O
&	O
env	pointer
)	O
;	O
if	O
(	O
mu_envelope_sget_date	function
(	O
env	pointer
,	O
&	O
sbuf	pointer
)	O
==	O
0	int
)	O
{	O
while	O
(	O
*	O
sbuf	pointer
&&	O
mu_isspace	O
(	O
*	O
sbuf	pointer
)	O
)	O
sbuf	pointer
++	O
;	O
nbytes	long
+=	O
fprintf	function
(	O
fp	pointer
,	O
"%s: %s"	pointer
,	O
MU_HEADER_ENV_DATE	pointer
,	O
sbuf	pointer
)	O
;	O
if	O
(	O
*	O
sbuf	pointer
&&	O
sbuf	pointer
[	O
strlen	function
(	O
sbuf	pointer
)	O
-	O
1	int
]	O
!=	O
'\n'	O
)	O
nbytes	long
+=	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
nlines	long
++	O
;	O
}	O
if	O
(	O
mu_envelope_sget_sender	function
(	O
env	pointer
,	O
&	O
sbuf	pointer
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s: %s\n"	pointer
,	O
MU_HEADER_ENV_SENDER	pointer
,	O
sbuf	pointer
)	O
;	O
nlines	long
++	O
;	O
}	O
if	O
(	O
!	O
(	O
amd	pointer
->	O
capabilities	int
&	O
MU_AMD_STATUS	int
)	O
)	O
{	O
char	O
statbuf	array
[	O
MU_STATUS_BUF_SIZE	O
]	O
;	O
mu_message_get_attribute	function
(	O
msg	pointer
,	O
&	O
attr	pointer
)	O
;	O
mu_attribute_to_string	function
(	O
attr	pointer
,	O
statbuf	array
,	O
sizeof	O
(	O
statbuf	array
)	O
,	O
&	O
n	long
)	O
;	O
if	O
(	O
n	long
)	O
{	O
nbytes	long
+=	O
fprintf	function
(	O
fp	pointer
,	O
"Status: %s\n"	pointer
,	O
statbuf	array
)	O
;	O
nlines	long
++	O
;	O
}	O
}	O
nbytes	long
+=	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
nlines	long
++	O
;	O
new_header_lines	long
=	O
nlines	long
;	O
new_body_start	long
=	O
nbytes	long
;	O
mu_message_get_body	function
(	O
msg	pointer
,	O
&	O
body	pointer
)	O
;	O
mu_body_get_streamref	function
(	O
body	pointer
,	O
&	O
stream	pointer
)	O
;	O
status	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
unlink	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
free	function
(	O
msg_name	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
return	O
status	int
;	O
}	O
nlines	long
=	O
0	int
;	O
while	O
(	O
mu_stream_read	function
(	O
stream	pointer
,	O
buf	pointer
,	O
bsize	long
,	O
&	O
n	long
)	O
==	O
0	int
&&	O
n	long
!=	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
buf	pointer
;	O
p	pointer
<	O
buf	pointer
+	O
n	long
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
)	O
nlines	long
++	O
;	O
fwrite	function
(	O
buf	pointer
,	O
1	int
,	O
n	long
,	O
fp	pointer
)	O
;	O
nbytes	long
+=	O
n	long
;	O
}	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
mhm	pointer
->	O
header_lines	long
=	O
new_header_lines	long
;	O
mhm	pointer
->	O
body_start	long
=	O
new_body_start	long
;	O
mhm	pointer
->	O
body_lines	long
=	O
nlines	long
;	O
mhm	pointer
->	O
body_end	long
=	O
nbytes	long
;	O
free	function
(	O
buf	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
status	int
=	O
amd	pointer
->	O
cur_msg_file_name	pointer
(	O
mhm	pointer
,	O
&	O
old_name	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
if	O
(	O
rename	function
(	O
name	pointer
,	O
msg_name	pointer
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
mu_observable_notify	function
(	O
amd	pointer
->	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_CORRUPT	int
,	O
amd	pointer
->	O
mailbox	pointer
)	O
;	O
else	O
{	O
status	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"renaming %s to %s failed: %s"	pointer
,	O
name	pointer
,	O
msg_name	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
}	O
}	O
else	O
{	O
mode_t	int
perms	int
;	O
perms	int
=	O
mu_stream_flags_to_mode	function
(	O
amd	pointer
->	O
mailbox	pointer
->	O
flags	int
,	O
0	int
)	O
;	O
if	O
(	O
perms	int
!=	O
0	int
)	O
{	O
mode_t	int
mask	int
=	O
umask	function
(	O
0	int
)	O
;	O
chmod	function
(	O
msg_name	pointer
,	O
(	O
0600	int
|	O
perms	int
)	O
&	O
~	O
mask	int
)	O
;	O
umask	function
(	O
mask	int
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
old_name	pointer
,	O
msg_name	pointer
)	O
)	O
unlink	function
(	O
old_name	pointer
)	O
;	O
}	O
free	function
(	O
old_name	pointer
)	O
;	O
mhm	pointer
->	O
orig_flags	int
=	O
mhm	pointer
->	O
attr_flags	int
;	O
}	O
free	function
(	O
msg_name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
amd_append_message	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
int	O
status	int
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
;	O
if	O
(	O
!	O
mailbox	pointer
||	O
!	O
msg	pointer
)	O
return	O
EINVAL	int
;	O
mhm	pointer
=	O
calloc	function
(	O
1	int
,	O
amd	pointer
->	O
msg_size	long
)	O
;	O
if	O
(	O
!	O
mhm	pointer
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
{	O
status	int
=	O
_amd_scan0	function
(	O
amd	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
free	function
(	O
mhm	pointer
)	O
;	O
return	O
status	int
;	O
}	O
}	O
amd	pointer
->	O
has_new_msg	int
=	O
1	int
;	O
mhm	pointer
->	O
amd	pointer
=	O
amd	pointer
;	O
if	O
(	O
amd	pointer
->	O
msg_init_delivery	pointer
)	O
{	O
status	int
=	O
amd	pointer
->	O
msg_init_delivery	pointer
(	O
amd	pointer
,	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
mhm	pointer
)	O
;	O
return	O
status	int
;	O
}	O
}	O
mhm	pointer
->	O
message	pointer
=	O
msg	pointer
;	O
status	int
=	O
_amd_message_save	function
(	O
amd	pointer
,	O
mhm	pointer
,	O
0	int
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
mhm	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mhm	pointer
->	O
message	pointer
=	O
NULL	O
;	O
status	int
=	O
_amd_message_insert	function
(	O
amd	pointer
,	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
mhm	pointer
)	O
;	O
return	O
status	int
;	O
}	O
if	O
(	O
amd	pointer
->	O
msg_finish_delivery	pointer
)	O
status	int
=	O
amd	pointer
->	O
msg_finish_delivery	pointer
(	O
amd	pointer
,	O
mhm	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
&&	O
mailbox	pointer
->	O
observable	pointer
)	O
{	O
char	O
*	O
qid	pointer
;	O
if	O
(	O
amd	pointer
->	O
cur_msg_file_name	pointer
(	O
mhm	pointer
,	O
&	O
qid	pointer
)	O
==	O
0	int
)	O
{	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_MESSAGE_APPEND	int
,	O
qid	pointer
)	O
;	O
free	function
(	O
qid	pointer
)	O
;	O
}	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
amd_messages_count	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
amd	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
amd_is_updated	function
(	O
mailbox	pointer
)	O
)	O
return	O
_amd_scan0	function
(	O
amd	pointer
,	O
amd	pointer
->	O
msg_count	long
,	O
pcount	pointer
,	O
0	int
)	O
;	O
if	O
(	O
pcount	pointer
)	O
*	O
pcount	pointer
=	O
amd	pointer
->	O
msg_count	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_messages_recent	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
size_t	long
count	pointer
,	O
i	long
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
{	O
int	O
status	int
=	O
_amd_scan0	function
(	O
amd	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
count	pointer
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
amd	pointer
->	O
msg_count	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
MU_ATTRIBUTE_IS_UNSEEN	O
(	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
->	O
attr_flags	int
)	O
)	O
count	pointer
++	O
;	O
}	O
*	O
pcount	pointer
=	O
count	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_message_unseen	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
pmsgno	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
size_t	long
i	long
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
{	O
int	O
status	int
=	O
_amd_scan0	function
(	O
amd	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
amd	pointer
->	O
msg_count	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
MU_ATTRIBUTE_IS_UNREAD	O
(	O
amd	pointer
->	O
msg_array	pointer
[	O
0	int
]	O
->	O
attr_flags	int
)	O
)	O
{	O
*	O
pmsgno	pointer
=	O
i	long
+	O
1	int
;	O
break	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_compute_mailbox_size_recursive	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
mu_off_t	long
*	O
psize	pointer
)	O
{	O
DIR	struct
*	O
dir	pointer
;	O
struct	O
dirent	struct
*	O
entry	pointer
;	O
char	O
*	O
buf	pointer
;	O
size_t	long
bufsize	long
;	O
size_t	long
dirlen	long
;	O
size_t	long
flen	long
;	O
int	O
status	int
=	O
0	int
;	O
struct	O
stat	struct
sb	struct
;	O
dir	pointer
=	O
opendir	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
errno	O
;	O
dirlen	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
bufsize	long
=	O
dirlen	long
+	O
32	int
;	O
buf	pointer
=	O
malloc	function
(	O
bufsize	long
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
closedir	function
(	O
dir	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
strcpy	function
(	O
buf	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
buf	pointer
[	O
dirlen	long
-	O
1	int
]	O
!=	O
'/'	O
)	O
buf	pointer
[	O
++	O
dirlen	long
-	O
1	int
]	O
=	O
'/'	O
;	O
while	O
(	O
(	O
entry	pointer
=	O
readdir	function
(	O
dir	pointer
)	O
)	O
)	O
{	O
switch	O
(	O
entry	pointer
->	O
d_name	array
[	O
0	int
]	O
)	O
{	O
case	O
'.'	O
:	O
break	O
;	O
default	O
:	O
flen	long
=	O
strlen	function
(	O
entry	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
dirlen	long
+	O
flen	long
+	O
1	int
>	O
bufsize	long
)	O
{	O
bufsize	long
=	O
dirlen	long
+	O
flen	long
+	O
1	int
;	O
buf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
bufsize	long
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
status	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
}	O
strcpy	function
(	O
buf	pointer
+	O
dirlen	long
,	O
entry	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
stat	struct
(	O
buf	pointer
,	O
&	O
sb	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
S_ISREG	O
(	O
sb	struct
.	O
st_mode	int
)	O
)	O
*	O
psize	pointer
+=	O
sb	struct
.	O
st_size	long
;	O
else	O
if	O
(	O
S_ISDIR	O
(	O
sb	struct
.	O
st_mode	int
)	O
)	O
_compute_mailbox_size_recursive	function
(	O
amd	pointer
,	O
buf	pointer
,	O
psize	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
closedir	function
(	O
dir	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
compute_mailbox_size	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
mu_off_t	long
*	O
psize	pointer
)	O
{	O
mu_off_t	long
size	long
=	O
0	int
;	O
int	O
rc	int
=	O
_compute_mailbox_size_recursive	function
(	O
amd	pointer
,	O
amd	pointer
->	O
name	pointer
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
_amd_prop_store_off	function
(	O
amd	pointer
,	O
_MU_AMD_PROP_SIZE	pointer
,	O
size	long
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
psize	pointer
)	O
*	O
psize	pointer
=	O
size	long
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
amd_remove_mbox	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
!	O
amd	pointer
->	O
remove	function
)	O
return	O
ENOSYS	int
;	O
rc	int
=	O
amd	pointer
->	O
remove	function
(	O
amd	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
mu_make_file_name	O
(	O
amd	pointer
->	O
name	pointer
,	O
_MU_AMD_PROP_FILE_NAME	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
unlink	function
(	O
name	pointer
)	O
&&	O
errno	O
!=	O
ENOENT	int
)	O
rc	int
=	O
errno	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
rmdir	function
(	O
amd	pointer
->	O
name	pointer
)	O
&&	O
errno	O
!=	O
ENOENT	int
)	O
{	O
rc	int
=	O
errno	O
;	O
if	O
(	O
rc	int
==	O
EEXIST	int
)	O
rc	int
=	O
ENOTEMPTY	int
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
_amd_update_message	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
struct	O
_amd_message	struct
*	O
mhm	pointer
,	O
int	O
expunge	int
,	O
int	O
*	O
upd	pointer
)	O
{	O
int	O
flg	int
,	O
rc	int
;	O
if	O
(	O
mhm	pointer
->	O
message	pointer
)	O
flg	int
=	O
mu_message_is_modified	function
(	O
mhm	pointer
->	O
message	pointer
)	O
;	O
else	O
if	O
(	O
mhm	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_MODIFIED	int
)	O
flg	int
=	O
MU_MSG_ATTRIBUTE_MODIFIED	int
;	O
else	O
return	O
0	int
;	O
if	O
(	O
!	O
flg	int
)	O
return	O
0	int
;	O
if	O
(	O
flg	int
==	O
MU_MSG_ATTRIBUTE_MODIFIED	int
&&	O
amd	pointer
->	O
chattr_msg	pointer
)	O
{	O
rc	int
=	O
amd	pointer
->	O
chattr_msg	pointer
(	O
mhm	pointer
,	O
expunge	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"_amd_update_message: chattr_msg failed: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
else	O
{	O
rc	int
=	O
_amd_attach_message	function
(	O
amd	pointer
->	O
mailbox	pointer
,	O
mhm	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"_amd_update_message: _amd_attach_message failed: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
_amd_message_save	function
(	O
amd	pointer
,	O
mhm	pointer
,	O
expunge	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"_amd_update_message: _amd_message_save failed: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
*	O
upd	pointer
=	O
1	int
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
amd_expunge	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
;	O
size_t	long
i	long
;	O
int	O
updated	int
=	O
amd	pointer
->	O
has_new_msg	int
;	O
size_t	long
expcount	long
=	O
0	int
;	O
size_t	long
last_expunged	long
=	O
0	int
;	O
if	O
(	O
amd	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
amd	pointer
->	O
msg_count	long
;	O
i	long
++	O
)	O
{	O
mhm	pointer
=	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
;	O
if	O
(	O
mhm	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_DELETED	int
)	O
{	O
int	O
rc	int
;	O
struct	O
_amd_message	struct
*	O
*	O
pp	pointer
;	O
if	O
(	O
amd	pointer
->	O
delete_msg	pointer
)	O
{	O
rc	int
=	O
amd	pointer
->	O
delete_msg	pointer
(	O
amd	pointer
,	O
mhm	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
else	O
{	O
char	O
*	O
old_name	pointer
;	O
char	O
*	O
new_name	pointer
;	O
rc	int
=	O
amd	pointer
->	O
cur_msg_file_name	pointer
(	O
mhm	pointer
,	O
&	O
old_name	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
amd	pointer
->	O
new_msg_file_name	pointer
(	O
mhm	pointer
,	O
mhm	pointer
->	O
attr_flags	int
,	O
1	int
,	O
&	O
new_name	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	function
(	O
old_name	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
new_name	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
old_name	pointer
,	O
new_name	pointer
)	O
&&	O
rename	function
(	O
old_name	pointer
,	O
new_name	pointer
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_CORRUPT	int
,	O
mailbox	pointer
)	O
;	O
else	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"renaming %s to %s failed: %s"	pointer
,	O
old_name	pointer
,	O
new_name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
}	O
}	O
else	O
unlink	function
(	O
old_name	pointer
)	O
;	O
free	function
(	O
old_name	pointer
)	O
;	O
free	function
(	O
new_name	pointer
)	O
;	O
}	O
pp	pointer
=	O
amd_pool_lookup	function
(	O
mhm	pointer
)	O
;	O
if	O
(	O
pp	pointer
)	O
*	O
pp	pointer
=	O
NULL	O
;	O
mu_message_destroy	function
(	O
&	O
mhm	pointer
->	O
message	pointer
,	O
mhm	pointer
)	O
;	O
if	O
(	O
amd	pointer
->	O
msg_free	pointer
)	O
amd	pointer
->	O
msg_free	pointer
(	O
mhm	pointer
)	O
;	O
free	function
(	O
mhm	pointer
)	O
;	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
=	O
NULL	O
;	O
last_expunged	long
=	O
i	long
;	O
updated	int
=	O
1	int
;	O
{	O
size_t	long
expevt	array
[	O
2	int
]	O
=	O
{	O
i	long
+	O
1	int
,	O
expcount	long
}	O
;	O
mu_observable_notify	function
(	O
mailbox	pointer
->	O
observable	pointer
,	O
MU_EVT_MAILBOX_MESSAGE_EXPUNGE	int
,	O
expevt	array
)	O
;	O
++	O
expcount	long
;	O
}	O
}	O
else	O
{	O
_amd_update_message	function
(	O
amd	pointer
,	O
mhm	pointer
,	O
1	int
,	O
&	O
updated	int
)	O
;	O
}	O
}	O
if	O
(	O
expcount	long
)	O
{	O
last_expunged	long
++	O
;	O
do	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
1	int
;	O
j	long
<	O
last_expunged	long
&&	O
!	O
amd	pointer
->	O
msg_array	pointer
[	O
last_expunged	long
-	O
j	long
-	O
1	int
]	O
;	O
j	long
++	O
)	O
;	O
amd_array_shrink	function
(	O
amd	pointer
,	O
last_expunged	long
-	O
1	int
,	O
j	long
)	O
;	O
for	O
(	O
last_expunged	long
-=	O
j	long
;	O
last_expunged	long
>	O
0	int
&&	O
amd	pointer
->	O
msg_array	pointer
[	O
last_expunged	long
-	O
1	int
]	O
;	O
last_expunged	long
--	O
)	O
;	O
}	O
while	O
(	O
last_expunged	long
)	O
;	O
}	O
if	O
(	O
updated	int
&&	O
!	O
amd	pointer
->	O
mailbox_size	pointer
)	O
{	O
compute_mailbox_size	function
(	O
amd	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_sync	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
;	O
size_t	long
i	long
;	O
int	O
updated	int
=	O
amd	pointer
->	O
has_new_msg	int
;	O
if	O
(	O
amd	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
amd	pointer
->	O
msg_count	long
;	O
i	long
++	O
)	O
{	O
mhm	pointer
=	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
;	O
if	O
(	O
(	O
mhm	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_MODIFIED	int
)	O
||	O
(	O
mhm	pointer
->	O
message	pointer
&&	O
mu_message_is_modified	function
(	O
mhm	pointer
->	O
message	pointer
)	O
)	O
)	O
break	O
;	O
}	O
for	O
(	O
;	O
i	long
<	O
amd	pointer
->	O
msg_count	long
;	O
i	long
++	O
)	O
{	O
mhm	pointer
=	O
amd	pointer
->	O
msg_array	pointer
[	O
i	long
]	O
;	O
_amd_update_message	function
(	O
amd	pointer
,	O
mhm	pointer
,	O
0	int
,	O
&	O
updated	int
)	O
;	O
}	O
if	O
(	O
updated	int
&&	O
!	O
amd	pointer
->	O
mailbox_size	pointer
)	O
{	O
compute_mailbox_size	function
(	O
amd	pointer
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_uidvalidity	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
unsigned	O
long	O
*	O
puidvalidity	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
status	int
=	O
amd_messages_count	function
(	O
mailbox	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
{	O
status	int
=	O
_amd_scan0	function
(	O
amd	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
return	O
_amd_prop_fetch_ulong	function
(	O
amd	pointer
,	O
_MU_AMD_PROP_UIDVALIDITY	pointer
,	O
puidvalidity	pointer
)	O
;	O
}	O
static	O
int	O
amd_uidnext	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
*	O
puidnext	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
int	O
status	int
;	O
if	O
(	O
!	O
amd	pointer
->	O
next_uid	pointer
)	O
return	O
ENOSYS	int
;	O
status	int
=	O
mu_mailbox_messages_count	function
(	O
mailbox	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
amd	pointer
->	O
msg_count	long
==	O
0	int
)	O
{	O
status	int
=	O
_amd_scan0	function
(	O
amd	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
}	O
if	O
(	O
puidnext	pointer
)	O
*	O
puidnext	pointer
=	O
amd	pointer
->	O
next_uid	pointer
(	O
amd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
amd_cleanup	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
mu_mailbox_t	pointer
mailbox	pointer
=	O
arg	pointer
;	O
mu_monitor_unlock	function
(	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
}	O
int	O
_amd_message_lookup_or_insert	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
struct	O
_amd_message	struct
*	O
key	pointer
,	O
size_t	long
*	O
pindex	pointer
)	O
{	O
int	O
result	int
=	O
0	int
;	O
size_t	long
index	function
;	O
if	O
(	O
amd_msg_lookup	function
(	O
amd	pointer
,	O
key	pointer
,	O
&	O
index	function
)	O
)	O
{	O
result	int
=	O
amd_array_expand	function
(	O
amd	pointer
,	O
index	function
)	O
;	O
if	O
(	O
result	int
)	O
return	O
result	int
;	O
else	O
result	int
=	O
MU_ERR_NOENT	O
;	O
}	O
else	O
result	int
=	O
0	int
;	O
*	O
pindex	pointer
=	O
index	function
;	O
return	O
result	int
;	O
}	O
int	O
_amd_message_insert	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
struct	O
_amd_message	struct
*	O
msg	pointer
)	O
{	O
size_t	long
index	function
;	O
int	O
rc	int
=	O
_amd_message_lookup_or_insert	function
(	O
amd	pointer
,	O
msg	pointer
,	O
&	O
index	function
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
{	O
amd	pointer
->	O
msg_array	pointer
[	O
index	function
]	O
=	O
msg	pointer
;	O
msg	pointer
->	O
amd	pointer
=	O
amd	pointer
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
return	O
EEXIST	int
;	O
}	O
else	O
return	O
rc	int
;	O
return	O
0	int
;	O
}	O
int	O
_amd_message_append	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
,	O
struct	O
_amd_message	struct
*	O
msg	pointer
)	O
{	O
size_t	long
index	function
=	O
amd	pointer
->	O
msg_count	long
;	O
int	O
rc	int
=	O
amd_array_expand	function
(	O
amd	pointer
,	O
index	function
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
amd	pointer
->	O
msg_array	pointer
[	O
index	function
]	O
=	O
msg	pointer
;	O
msg	pointer
->	O
amd	pointer
=	O
amd	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
msg_array_comp	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
struct	O
_amd_message	struct
*	O
*	O
ma	pointer
=	O
(	O
struct	O
_amd_message	struct
*	O
*	O
)	O
a	pointer
;	O
struct	O
_amd_message	struct
*	O
*	O
mb	pointer
=	O
(	O
struct	O
_amd_message	struct
*	O
*	O
)	O
b	pointer
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
(	O
*	O
ma	pointer
)	O
->	O
amd	pointer
;	O
return	O
amd	pointer
->	O
msg_cmp	pointer
(	O
*	O
ma	pointer
,	O
*	O
mb	pointer
)	O
;	O
}	O
void	O
amd_sort	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
)	O
{	O
qsort	function
(	O
amd	pointer
->	O
msg_array	pointer
,	O
amd	pointer
->	O
msg_count	long
,	O
sizeof	O
(	O
amd	pointer
->	O
msg_array	pointer
[	O
0	int
]	O
)	O
,	O
msg_array_comp	function
)	O
;	O
}	O
static	O
int	O
amd_scan_message	function
(	O
struct	O
_amd_message	struct
*	O
mhm	pointer
)	O
{	O
mu_stream_t	pointer
stream	pointer
=	O
mhm	pointer
->	O
stream	pointer
;	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
size_t	long
off	long
;	O
size_t	long
n	long
;	O
int	O
status	int
;	O
int	O
in_header	int
=	O
1	int
;	O
size_t	long
hlines	long
=	O
0	int
;	O
size_t	long
blines	long
=	O
0	int
;	O
size_t	long
body_start	long
=	O
0	int
;	O
struct	O
stat	struct
st	pointer
;	O
char	O
*	O
msg_name	pointer
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mhm	pointer
->	O
amd	pointer
;	O
int	O
amd_capa	int
=	O
amd	pointer
->	O
capabilities	int
;	O
status	int
=	O
mhm	pointer
->	O
amd	pointer
->	O
cur_msg_file_name	pointer
(	O
mhm	pointer
,	O
&	O
msg_name	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"amd_scan_message: cur_msg_file_name=%s"	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
return	O
status	int
;	O
}	O
if	O
(	O
stat	struct
(	O
msg_name	pointer
,	O
&	O
st	pointer
)	O
==	O
0	int
&&	O
st	pointer
.	O
st_mtime	O
==	O
mhm	pointer
->	O
mtime	long
)	O
{	O
free	function
(	O
msg_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
off	long
=	O
0	int
;	O
status	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"amd_scan_message(%s): mu_stream_seek=%s"	pointer
,	O
msg_name	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
else	O
{	O
while	O
(	O
(	O
status	int
=	O
mu_stream_readline	function
(	O
stream	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
&	O
n	long
)	O
)	O
==	O
0	int
&&	O
n	long
!=	O
0	int
)	O
{	O
if	O
(	O
in_header	int
)	O
{	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
{	O
in_header	int
=	O
0	int
;	O
body_start	long
=	O
off	long
+	O
1	int
;	O
}	O
if	O
(	O
buf	pointer
[	O
n	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
hlines	long
++	O
;	O
if	O
(	O
!	O
(	O
amd_capa	int
&	O
MU_AMD_STATUS	int
)	O
&&	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
"status:"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
int	O
deleted	int
=	O
mhm	pointer
->	O
attr_flags	int
&	O
MU_ATTRIBUTE_DELETED	int
;	O
mu_string_to_flags	function
(	O
buf	pointer
,	O
&	O
mhm	pointer
->	O
attr_flags	int
)	O
;	O
mhm	pointer
->	O
attr_flags	int
|=	O
deleted	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
amd_capa	int
&	O
MU_AMD_IMAPBASE	int
)	O
&&	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
"x-imapbase:"	pointer
,	O
11	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
_amd_prop_fetch_ulong	function
(	O
amd	pointer
,	O
_MU_AMD_PROP_UIDVALIDITY	pointer
,	O
NULL	O
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
unsigned	O
long	O
uidval	long
=	O
strtoul	function
(	O
buf	pointer
+	O
11	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
_amd_prop_store_off	function
(	O
amd	pointer
,	O
_MU_AMD_PROP_UIDVALIDITY	pointer
,	O
uidval	long
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
buf	pointer
[	O
n	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
blines	long
++	O
;	O
}	O
off	long
+=	O
n	long
;	O
}	O
if	O
(	O
status	int
)	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"amd_scan_message(%s): %s"	pointer
,	O
msg_name	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
}	O
free	function
(	O
msg_name	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
mhm	pointer
->	O
mtime	long
=	O
st	pointer
.	O
st_mtime	O
;	O
if	O
(	O
!	O
body_start	long
)	O
body_start	long
=	O
off	long
;	O
mhm	pointer
->	O
header_lines	long
=	O
hlines	long
;	O
mhm	pointer
->	O
body_lines	long
=	O
blines	long
;	O
mhm	pointer
->	O
body_start	long
=	O
body_start	long
;	O
mhm	pointer
->	O
body_end	long
=	O
off	long
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
amd_scan	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
size_t	long
msgno	long
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
!	O
amd_is_updated	function
(	O
mailbox	pointer
)	O
)	O
return	O
_amd_scan0	function
(	O
amd	pointer
,	O
msgno	long
,	O
pcount	pointer
,	O
1	int
)	O
;	O
if	O
(	O
pcount	pointer
)	O
*	O
pcount	pointer
=	O
amd	pointer
->	O
msg_count	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_is_updated	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
stat	struct
(	O
amd	pointer
->	O
name	pointer
,	O
&	O
st	pointer
)	O
<	O
0	int
)	O
return	O
1	int
;	O
return	O
amd	pointer
->	O
mtime	long
==	O
st	pointer
.	O
st_mtime	O
;	O
}	O
static	O
int	O
amd_get_size	function
(	O
mu_mailbox_t	pointer
mailbox	pointer
,	O
mu_off_t	long
*	O
psize	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mailbox	pointer
->	O
data	pointer
;	O
if	O
(	O
amd	pointer
->	O
mailbox_size	pointer
)	O
return	O
amd	pointer
->	O
mailbox_size	pointer
(	O
mailbox	pointer
,	O
psize	pointer
)	O
;	O
if	O
(	O
_amd_prop_fetch_off	function
(	O
amd	pointer
,	O
_MU_AMD_PROP_SIZE	pointer
,	O
psize	pointer
)	O
)	O
return	O
compute_mailbox_size	function
(	O
amd	pointer
,	O
psize	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_pool_open_count	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
)	O
{	O
int	O
cnt	pointer
=	O
amd	pointer
->	O
pool_last	int
-	O
amd	pointer
->	O
pool_first	int
;	O
if	O
(	O
cnt	pointer
<	O
0	int
)	O
cnt	pointer
+=	O
MAX_OPEN_STREAMS	int
;	O
return	O
cnt	pointer
;	O
}	O
static	O
struct	O
_amd_message	struct
*	O
*	O
amd_pool_lookup	function
(	O
struct	O
_amd_message	struct
*	O
mhm	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mhm	pointer
->	O
amd	pointer
;	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
amd	pointer
->	O
pool_first	int
;	O
i	long
!=	O
amd	pointer
->	O
pool_last	int
;	O
)	O
{	O
if	O
(	O
amd	pointer
->	O
msg_pool	array
[	O
i	long
]	O
==	O
mhm	pointer
)	O
return	O
&	O
amd	pointer
->	O
msg_pool	array
[	O
i	long
]	O
;	O
if	O
(	O
++	O
i	long
==	O
MAX_OPEN_STREAMS	int
)	O
i	long
=	O
0	int
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
amd_pool_open	function
(	O
struct	O
_amd_message	struct
*	O
mhm	pointer
)	O
{	O
int	O
status	int
;	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mhm	pointer
->	O
amd	pointer
;	O
if	O
(	O
amd_pool_lookup	function
(	O
mhm	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
amd_pool_open_count	function
(	O
amd	pointer
)	O
==	O
MAX_OPEN_STREAMS	int
-	O
1	int
)	O
{	O
amd_message_stream_close	function
(	O
amd	pointer
->	O
msg_pool	array
[	O
amd	pointer
->	O
pool_first	int
++	O
]	O
)	O
;	O
amd	pointer
->	O
pool_first	int
%=	O
MAX_OPEN_STREAMS	int
;	O
}	O
status	int
=	O
amd_message_stream_open	function
(	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"amd_pool_open: amd_message_stream_open=%s"	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
return	O
status	int
;	O
}	O
amd	pointer
->	O
msg_pool	array
[	O
amd	pointer
->	O
pool_last	int
++	O
]	O
=	O
mhm	pointer
;	O
amd	pointer
->	O
pool_last	int
%=	O
MAX_OPEN_STREAMS	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
amd_pool_flush	function
(	O
struct	O
_amd_data	struct
*	O
amd	pointer
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
amd	pointer
->	O
pool_first	int
;	O
i	long
!=	O
amd	pointer
->	O
pool_last	int
;	O
)	O
{	O
if	O
(	O
amd	pointer
->	O
msg_pool	array
[	O
i	long
]	O
)	O
amd_message_stream_close	function
(	O
amd	pointer
->	O
msg_pool	array
[	O
i	long
]	O
)	O
;	O
if	O
(	O
++	O
i	long
==	O
MAX_OPEN_STREAMS	int
)	O
i	long
=	O
0	int
;	O
}	O
amd	pointer
->	O
pool_first	int
=	O
amd	pointer
->	O
pool_last	int
=	O
0	int
;	O
}	O
int	O
amd_message_stream_open	function
(	O
struct	O
_amd_message	struct
*	O
mhm	pointer
)	O
{	O
struct	O
_amd_data	struct
*	O
amd	pointer
=	O
mhm	pointer
->	O
amd	pointer
;	O
char	O
*	O
filename	pointer
;	O
int	O
status	int
;	O
int	O
flags	int
=	O
0	int
;	O
status	int
=	O
amd	pointer
->	O
cur_msg_file_name	pointer
(	O
mhm	pointer
,	O
&	O
filename	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"amd_message_stream_open: cur_msg_file_name=%s"	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
return	O
status	int
;	O
}	O
if	O
(	O
amd	pointer
->	O
mailbox	pointer
->	O
flags	int
&	O
(	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_APPEND	int
)	O
)	O
flags	int
|=	O
MU_STREAM_RDWR	O
;	O
else	O
flags	int
|=	O
MU_STREAM_READ	int
;	O
status	int
=	O
mu_file_stream_create	function
(	O
&	O
mhm	pointer
->	O
stream	pointer
,	O
filename	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
status	int
)	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"amd_message_stream_open: mu_file_stream_create(%s)=%s"	pointer
,	O
filename	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
mu_stream_set_buffer	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
mu_buffer_full	int
,	O
16384	int
)	O
;	O
status	int
=	O
amd_scan_message	function
(	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
mu_debug	O
(	O
MU_DEBCAT_MAILBOX	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"amd_message_stream_open: amd_scan_message=%s"	pointer
,	O
mu_strerror	function
(	O
status	int
)	O
)	O
)	O
;	O
return	O
status	int
;	O
}	O
void	O
amd_message_stream_close	function
(	O
struct	O
_amd_message	struct
*	O
mhm	pointer
)	O
{	O
if	O
(	O
mhm	pointer
)	O
{	O
mu_stream_close	function
(	O
mhm	pointer
->	O
stream	pointer
)	O
;	O
mhm	pointer
->	O
stream	pointer
=	O
NULL	O
;	O
}	O
}	O
int	O
amd_check_message	function
(	O
struct	O
_amd_message	struct
*	O
mhm	pointer
)	O
{	O
if	O
(	O
mhm	pointer
->	O
body_end	long
==	O
0	int
)	O
return	O
amd_pool_open	function
(	O
mhm	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_body_stream_read	function
(	O
mu_stream_t	pointer
is	pointer
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buflen	long
,	O
size_t	long
*	O
pnread	pointer
)	O
{	O
struct	O
_amd_body_stream	struct
*	O
amdstr	pointer
=	O
(	O
struct	O
_amd_body_stream	struct
*	O
)	O
is	pointer
;	O
mu_body_t	pointer
body	pointer
=	O
amdstr	pointer
->	O
body	pointer
;	O
mu_message_t	pointer
msg	pointer
=	O
mu_body_get_owner	function
(	O
body	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
size_t	long
nread	long
=	O
0	int
;	O
int	O
status	int
=	O
0	int
;	O
mu_off_t	long
ln	long
;	O
status	int
=	O
amd_pool_open	function
(	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
||	O
buflen	long
==	O
0	int
)	O
{	O
*	O
pnread	pointer
=	O
nread	long
;	O
return	O
0	int
;	O
}	O
mu_monitor_rdlock	function
(	O
mhm	pointer
->	O
amd	pointer
->	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
pthread_cleanup_push	O
(	O
amd_cleanup	function
,	O
(	O
void	O
*	O
)	O
mhm	pointer
->	O
amd	pointer
->	O
mailbox	pointer
)	O
;	O
ln	long
=	O
mhm	pointer
->	O
body_end	long
-	O
(	O
mhm	pointer
->	O
body_start	long
+	O
amdstr	pointer
->	O
off	long
)	O
;	O
if	O
(	O
ln	long
>	O
0	int
)	O
{	O
nread	long
=	O
(	O
(	O
size_t	long
)	O
ln	long
<	O
buflen	long
)	O
?	O
(	O
size_t	long
)	O
ln	long
:	O
buflen	long
;	O
status	int
=	O
mu_stream_seek	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
mhm	pointer
->	O
body_start	long
+	O
amdstr	pointer
->	O
off	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
status	int
=	O
mu_stream_read	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
buffer	pointer
,	O
nread	long
,	O
&	O
nread	long
)	O
;	O
amdstr	pointer
->	O
off	long
+=	O
nread	long
;	O
}	O
}	O
*	O
pnread	pointer
=	O
nread	long
;	O
mu_monitor_unlock	function
(	O
mhm	pointer
->	O
amd	pointer
->	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
pthread_cleanup_pop	O
(	O
0	int
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
amd_body_stream_readdelim	function
(	O
mu_stream_t	pointer
is	pointer
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buflen	long
,	O
int	O
delim	pointer
,	O
size_t	long
*	O
pnread	pointer
)	O
{	O
struct	O
_amd_body_stream	struct
*	O
amdstr	pointer
=	O
(	O
struct	O
_amd_body_stream	struct
*	O
)	O
is	pointer
;	O
mu_body_t	pointer
body	pointer
=	O
amdstr	pointer
->	O
body	pointer
;	O
mu_message_t	pointer
msg	pointer
=	O
mu_body_get_owner	function
(	O
body	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
int	O
status	int
=	O
0	int
;	O
status	int
=	O
amd_pool_open	function
(	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
||	O
buflen	long
==	O
0	int
)	O
{	O
if	O
(	O
pnread	pointer
)	O
*	O
pnread	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
mu_monitor_rdlock	function
(	O
mhm	pointer
->	O
amd	pointer
->	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
pthread_cleanup_push	O
(	O
amd_cleanup	function
,	O
(	O
void	O
*	O
)	O
mhm	pointer
->	O
amd	pointer
->	O
mailbox	pointer
)	O
;	O
status	int
=	O
mu_stream_seek	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
mhm	pointer
->	O
body_start	long
+	O
amdstr	pointer
->	O
off	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
size_t	long
nread	long
=	O
0	int
;	O
size_t	long
ln	long
;	O
ln	long
=	O
mhm	pointer
->	O
body_end	long
-	O
(	O
mhm	pointer
->	O
body_start	long
+	O
amdstr	pointer
->	O
off	long
)	O
+	O
1	int
;	O
if	O
(	O
ln	long
>	O
0	int
)	O
{	O
size_t	long
rdsize	long
=	O
(	O
(	O
size_t	long
)	O
ln	long
<	O
buflen	long
)	O
?	O
(	O
size_t	long
)	O
ln	long
:	O
buflen	long
;	O
status	int
=	O
mu_stream_readdelim	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
buffer	pointer
,	O
rdsize	long
,	O
delim	pointer
,	O
&	O
nread	long
)	O
;	O
amdstr	pointer
->	O
off	long
+=	O
nread	long
;	O
}	O
if	O
(	O
pnread	pointer
)	O
*	O
pnread	pointer
=	O
nread	long
;	O
}	O
mu_monitor_unlock	function
(	O
mhm	pointer
->	O
amd	pointer
->	O
mailbox	pointer
->	O
monitor	pointer
)	O
;	O
pthread_cleanup_pop	O
(	O
0	int
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
amd_body_stream_seek	function
(	O
mu_stream_t	pointer
str	pointer
,	O
mu_off_t	long
off	long
,	O
mu_off_t	long
*	O
presult	pointer
)	O
{	O
size_t	long
size	long
;	O
struct	O
_amd_body_stream	struct
*	O
amdstr	pointer
=	O
(	O
struct	O
_amd_body_stream	struct
*	O
)	O
str	pointer
;	O
amd_body_size	function
(	O
amdstr	pointer
->	O
body	pointer
,	O
&	O
size	long
)	O
;	O
if	O
(	O
off	long
<	O
0	int
||	O
off	long
>	O
size	long
)	O
return	O
ESPIPE	int
;	O
amdstr	pointer
->	O
off	long
=	O
off	long
;	O
if	O
(	O
presult	pointer
)	O
*	O
presult	pointer
=	O
off	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_body_stream_size	function
(	O
mu_stream_t	pointer
stream	pointer
,	O
mu_off_t	long
*	O
psize	pointer
)	O
{	O
mu_body_t	pointer
body	pointer
=	O
(	O
(	O
struct	O
_amd_body_stream	struct
*	O
)	O
stream	pointer
)	O
->	O
body	pointer
;	O
size_t	long
size	long
;	O
int	O
rc	int
=	O
amd_body_size	function
(	O
body	pointer
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
psize	pointer
=	O
size	long
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
amd_body_size	function
(	O
mu_body_t	pointer
body	pointer
,	O
size_t	long
*	O
psize	pointer
)	O
{	O
int	O
status	int
;	O
mu_message_t	pointer
msg	pointer
=	O
mu_body_get_owner	function
(	O
body	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mhm	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
status	int
=	O
amd_check_message	function
(	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
psize	pointer
)	O
*	O
psize	pointer
=	O
mhm	pointer
->	O
body_end	long
-	O
mhm	pointer
->	O
body_start	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_body_lines	function
(	O
mu_body_t	pointer
body	pointer
,	O
size_t	long
*	O
plines	pointer
)	O
{	O
int	O
status	int
;	O
mu_message_t	pointer
msg	pointer
=	O
mu_body_get_owner	function
(	O
body	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mhm	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
status	int
=	O
amd_check_message	function
(	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
plines	pointer
)	O
*	O
plines	pointer
=	O
mhm	pointer
->	O
body_lines	long
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_header_fill	function
(	O
void	O
*	O
data	pointer
,	O
char	O
*	O
*	O
pbuf	pointer
,	O
size_t	long
*	O
plen	pointer
)	O
{	O
char	O
*	O
buffer	pointer
;	O
size_t	long
len	int
;	O
mu_message_t	pointer
msg	pointer
=	O
data	pointer
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
int	O
status	int
,	O
rc	int
;	O
mu_off_t	long
pos	long
;	O
status	int
=	O
amd_pool_open	function
(	O
mhm	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
len	int
=	O
mhm	pointer
->	O
body_start	long
;	O
buffer	pointer
=	O
malloc	function
(	O
len	int
)	O
;	O
if	O
(	O
!	O
buffer	pointer
)	O
return	O
ENOMEM	int
;	O
status	int
=	O
mu_stream_seek	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_CUR	int
,	O
&	O
pos	long
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_stream_seek	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_stream_read	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
buffer	pointer
,	O
len	int
,	O
NULL	O
)	O
;	O
rc	int
=	O
mu_stream_seek	function
(	O
mhm	pointer
->	O
stream	pointer
,	O
pos	long
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
status	int
)	O
status	int
=	O
rc	int
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
buffer	pointer
)	O
;	O
return	O
status	int
;	O
}	O
*	O
plen	pointer
=	O
len	int
;	O
*	O
pbuf	pointer
=	O
buffer	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_get_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
*	O
pflags	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_attribute_get_owner	function
(	O
attr	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mhm	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
pflags	pointer
)	O
*	O
pflags	pointer
=	O
mhm	pointer
->	O
attr_flags	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_set_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
flags	int
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_attribute_get_owner	function
(	O
attr	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mhm	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mhm	pointer
->	O
attr_flags	int
|=	O
flags	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_unset_attr_flags	function
(	O
mu_attribute_t	pointer
attr	pointer
,	O
int	O
flags	int
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_attribute_get_owner	function
(	O
attr	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
mhm	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
mhm	pointer
->	O
attr_flags	int
&=	O
~	O
flags	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_envelope_date	function
(	O
mu_envelope_t	pointer
envelope	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	int
,	O
size_t	long
*	O
psize	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_envelope_get_owner	function
(	O
envelope	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
mu_header_t	pointer
hdr	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
date	struct
;	O
char	O
datebuf	array
[	O
25	int
]	O
;	O
int	O
status	int
;	O
if	O
(	O
mhm	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
(	O
status	int
=	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
mu_header_sget_value	O
(	O
hdr	pointer
,	O
MU_HEADER_ENV_DATE	pointer
,	O
&	O
date	struct
)	O
&&	O
mu_header_sget_value	O
(	O
hdr	pointer
,	O
MU_HEADER_DELIVERY_DATE	pointer
,	O
&	O
date	struct
)	O
)	O
return	O
MU_ERR_NOENT	O
;	O
else	O
{	O
time_t	long
t	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_parse_date	function
(	O
date	struct
,	O
&	O
t	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
MU_ERR_NOENT	O
;	O
memcpy	function
(	O
datebuf	array
,	O
ctime	function
(	O
&	O
t	long
)	O
,	O
sizeof	O
(	O
datebuf	array
)	O
-	O
1	int
)	O
;	O
datebuf	array
[	O
sizeof	O
(	O
datebuf	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
date	struct
=	O
datebuf	array
;	O
}	O
if	O
(	O
buf	pointer
&&	O
len	int
>	O
0	int
)	O
{	O
len	int
--	O
;	O
strncpy	function
(	O
buf	pointer
,	O
date	struct
,	O
len	int
)	O
;	O
if	O
(	O
strlen	function
(	O
date	struct
)	O
<	O
len	int
)	O
{	O
len	int
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
!=	O
'\n'	O
)	O
buf	pointer
[	O
len	int
++	O
]	O
=	O
'\n'	O
;	O
}	O
buf	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
len	int
=	O
strlen	function
(	O
date	struct
)	O
;	O
if	O
(	O
psize	pointer
)	O
*	O
psize	pointer
=	O
len	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
amd_envelope_sender	function
(	O
mu_envelope_t	pointer
envelope	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	int
,	O
size_t	long
*	O
psize	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
=	O
mu_envelope_get_owner	function
(	O
envelope	pointer
)	O
;	O
struct	O
_amd_message	struct
*	O
mhm	pointer
=	O
mu_message_get_owner	function
(	O
msg	pointer
)	O
;	O
mu_header_t	pointer
hdr	pointer
=	O
NULL	O
;	O
char	O
*	O
from	pointer
;	O
int	O
status	int
;	O
if	O
(	O
mhm	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
(	O
status	int
=	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
)	O
)	O
return	O
status	int
;	O
if	O
(	O
(	O
status	int
=	O
mu_header_aget_value	O
(	O
hdr	pointer
,	O
MU_HEADER_ENV_SENDER	pointer
,	O
&	O
from	pointer
)	O
)	O
)	O
return	O
status	int
;	O
if	O
(	O
buf	pointer
&&	O
len	int
>	O
0	int
)	O
{	O
int	O
slen	int
=	O
strlen	function
(	O
from	pointer
)	O
;	O
if	O
(	O
len	int
<	O
slen	int
+	O
1	int
)	O
slen	int
=	O
len	int
-	O
1	int
;	O
memcpy	function
(	O
buf	pointer
,	O
from	pointer
,	O
slen	int
)	O
;	O
buf	pointer
[	O
slen	int
]	O
=	O
0	int
;	O
}	O
else	O
len	int
=	O
strlen	function
(	O
from	pointer
)	O
;	O
if	O
(	O
psize	pointer
)	O
*	O
psize	pointer
=	O
len	int
;	O
free	function
(	O
from	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
amd_remove_dir	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
DIR	struct
*	O
dir	pointer
;	O
struct	O
dirent	struct
*	O
ent	pointer
;	O
char	O
*	O
namebuf	pointer
;	O
size_t	long
namelen	long
,	O
namesize	long
;	O
int	O
rc	int
=	O
0	int
;	O
int	O
has_subdirs	int
=	O
0	int
;	O
namelen	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
namesize	long
=	O
namelen	long
+	O
128	int
;	O
namebuf	pointer
=	O
malloc	function
(	O
namesize	long
)	O
;	O
if	O
(	O
!	O
namebuf	pointer
)	O
return	O
ENOMEM	int
;	O
memcpy	function
(	O
namebuf	pointer
,	O
name	pointer
,	O
namelen	long
)	O
;	O
if	O
(	O
namebuf	pointer
[	O
namelen	long
-	O
1	int
]	O
!=	O
'/'	O
)	O
namebuf	pointer
[	O
namelen	long
++	O
]	O
=	O
'/'	O
;	O
dir	pointer
=	O
opendir	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
errno	O
;	O
while	O
(	O
(	O
ent	pointer
=	O
readdir	function
(	O
dir	pointer
)	O
)	O
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
size_t	long
len	int
;	O
if	O
(	O
strcmp	function
(	O
ent	pointer
->	O
d_name	array
,	O
"."	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
ent	pointer
->	O
d_name	array
,	O
".."	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
len	int
=	O
strlen	function
(	O
ent	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
namelen	long
+	O
len	int
>=	O
namesize	long
)	O
{	O
char	O
*	O
p	pointer
;	O
namesize	long
+=	O
len	int
+	O
1	int
;	O
p	pointer
=	O
realloc	function
(	O
namebuf	pointer
,	O
namesize	long
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
}	O
strcpy	function
(	O
namebuf	pointer
+	O
namelen	long
,	O
ent	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
stat	struct
(	O
namebuf	pointer
,	O
&	O
st	pointer
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
has_subdirs	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
unlink	function
(	O
namebuf	pointer
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_diag_output	function
(	O
MU_DIAG_WARNING	O
,	O
"failed to remove %s: %s"	pointer
,	O
namebuf	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
break	O
;	O
}	O
}	O
closedir	function
(	O
dir	pointer
)	O
;	O
free	function
(	O
namebuf	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
!	O
has_subdirs	int
)	O
{	O
if	O
(	O
rmdir	function
(	O
name	pointer
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
if	O
(	O
rc	int
==	O
EEXIST	int
)	O
rc	int
=	O
ENOTEMPTY	int
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
