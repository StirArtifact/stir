enum	O
{	O
CSI_PB	int
=	O
0	int
,	O
CSI_PX	int
=	O
1	int
,	O
CSI_PY	int
=	O
2	int
,	O
CSI_DONE	int
=	O
3	int
,	O
CSI_ESC_SEEN	int
,	O
CSI_BEGIN	int
,	O
CSI_INACTIVE	int
,	O
CSI_INVALID	int
}	O
;	O
static	O
int	O
CountChars	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
DoAddChar	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
BlankResize	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
CallRewrite	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
disp_readev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
disp_processinput	function
__P	O
(	O
(	O
struct	O
display	struct
*	O
,	O
unsigned	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
disp_writeev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
disp_writeev_eagain	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
disp_status_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
disp_hstatus_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
disp_blocked_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
disp_map_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
disp_idle_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
disp_blanker_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
WriteLP	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
INSERTCHAR	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
RAW_PUTCHAR	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
SetBackColor	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
RemoveStatusMinWait	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
win	struct
*	O
windows	pointer
,	O
*	O
fore	pointer
;	O
extern	O
struct	O
LayFuncs	struct
WinLf	struct
;	O
extern	O
int	O
use_hardstatus	int
;	O
extern	O
int	O
MsgWait	int
,	O
MsgMinWait	int
;	O
extern	O
const	O
int	O
Z0width	int
,	O
Z1width	int
;	O
extern	O
unsigned	O
char	O
*	O
blank	pointer
,	O
*	O
null	pointer
;	O
extern	O
struct	O
mline	struct
mline_blank	struct
,	O
mline_null	struct
,	O
mline_old	struct
;	O
extern	O
struct	O
mchar	struct
mchar_null	struct
,	O
mchar_blank	struct
,	O
mchar_so	struct
;	O
extern	O
struct	O
NewWindow	struct
nwin_default	struct
;	O
extern	O
struct	O
action	struct
idleaction	struct
;	O
extern	O
char	O
*	O
hstatusstring	pointer
;	O
extern	O
char	O
*	O
captionstring	pointer
;	O
extern	O
int	O
pastefont	int
;	O
extern	O
int	O
idletimo	int
;	O
extern	O
int	O
pty_preopen	int
;	O
extern	O
struct	O
winsize	struct
glwz	struct
;	O
extern	O
char	O
*	O
*	O
NewEnv	pointer
;	O
extern	O
int	O
real_uid	int
,	O
real_gid	int
;	O
extern	O
int	O
ServerSocket	int
,	O
eff_uid	int
,	O
eff_gid	int
;	O
extern	O
short	O
ospeed	short
;	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
int	O
attr2color	array
[	O
8	int
]	O
[	O
4	int
]	O
;	O
int	O
nattr2color	int
;	O
int	O
defobuflimit	int
=	O
OBUF_MAX	int
;	O
int	O
defnonblock	int
=	O
-	O
1	int
;	O
int	O
defmousetrack	int
=	O
0	int
;	O
int	O
defautonuke	int
=	O
0	int
;	O
int	O
captionalways	int
;	O
int	O
hardstatusemu	int
=	O
HSTATUS_IGNORE	int
;	O
int	O
focusminwidth	int
,	O
focusminheight	int
;	O
void	O
DefProcess	function
(	O
bufp	pointer
,	O
lenp	pointer
)	O
char	O
*	O
*	O
bufp	pointer
;	O
int	O
*	O
lenp	pointer
;	O
{	O
*	O
bufp	pointer
+=	O
*	O
lenp	pointer
;	O
*	O
lenp	pointer
=	O
0	int
;	O
}	O
void	O
DefRedisplayLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	int
)	O
int	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	int
;	O
{	O
if	O
(	O
isblank	int
==	O
0	int
&&	O
y	int
>=	O
0	int
)	O
DefClearLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
0	int
)	O
;	O
}	O
void	O
DefClearLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
)	O
int	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
;	O
{	O
LClearLine	function
(	O
flayer	pointer
,	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
,	O
(	O
struct	O
mline	struct
*	O
)	O
0	int
)	O
;	O
}	O
int	O
DefRewrite	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
rend	pointer
,	O
doit	int
)	O
int	O
y	int
,	O
xs	int
,	O
xe	int
,	O
doit	int
;	O
struct	O
mchar	struct
*	O
rend	pointer
;	O
{	O
return	O
EXPENSIVE	int
;	O
}	O
int	O
DefResize	function
(	O
wi	int
,	O
he	int
)	O
int	O
wi	int
,	O
he	int
;	O
{	O
return	O
-	O
1	int
;	O
}	O
void	O
DefRestore	function
(	O
)	O
{	O
LAY_DISPLAYS	O
(	O
flayer	pointer
,	O
InsertMode	function
(	O
0	int
)	O
)	O
;	O
LKeypadMode	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
LCursorkeysMode	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
LCursorVisibility	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
LMouseMode	function
(	O
flayer	pointer
,	O
0	int
)	O
;	O
LSetRendition	function
(	O
flayer	pointer
,	O
&	O
mchar_null	struct
)	O
;	O
LSetFlow	function
(	O
flayer	pointer
,	O
nwin_default	struct
.	O
flowflag	int
&	O
FLOW_NOW	O
)	O
;	O
}	O
struct	O
LayFuncs	struct
BlankLf	struct
=	O
{	O
DefProcess	function
,	O
0	int
,	O
DefRedisplayLine	function
,	O
DefClearLine	function
,	O
DefRewrite	function
,	O
BlankResize	function
,	O
DefRestore	function
,	O
0	int
}	O
;	O
static	O
int	O
BlankResize	function
(	O
wi	int
,	O
he	int
)	O
int	O
wi	int
,	O
he	int
;	O
{	O
flayer	pointer
->	O
l_width	int
=	O
wi	int
;	O
flayer	pointer
->	O
l_height	int
=	O
he	int
;	O
return	O
0	int
;	O
}	O
struct	O
display	struct
*	O
MakeDisplay	function
(	O
uname	pointer
,	O
utty	pointer
,	O
term	struct
,	O
fd	int
,	O
pid	int
,	O
Mode	pointer
)	O
char	O
*	O
uname	pointer
,	O
*	O
utty	pointer
,	O
*	O
term	struct
;	O
int	O
fd	int
,	O
pid	int
;	O
struct	O
mode	struct
*	O
Mode	pointer
;	O
{	O
struct	O
acluser	struct
*	O
*	O
u	pointer
;	O
struct	O
baud_values	struct
*	O
b	pointer
;	O
if	O
(	O
!	O
*	O
(	O
u	pointer
=	O
FindUserPtr	function
(	O
uname	pointer
)	O
)	O
&&	O
UserAdd	function
(	O
uname	pointer
,	O
(	O
char	O
*	O
)	O
0	int
,	O
u	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
display	struct
)	O
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
display	struct
->	O
d_next	pointer
=	O
displays	pointer
;	O
displays	pointer
=	O
display	struct
;	O
D_flow	O
=	O
1	int
;	O
D_nonblock	O
=	O
defnonblock	int
;	O
D_userfd	O
=	O
fd	int
;	O
D_readev	O
.	O
fd	int
=	O
D_writeev	O
.	O
fd	int
=	O
fd	int
;	O
D_readev	O
.	O
type	enum
=	O
EV_READ	int
;	O
D_writeev	O
.	O
type	enum
=	O
EV_WRITE	int
;	O
D_readev	O
.	O
data	pointer
=	O
D_writeev	O
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
display	struct
;	O
D_readev	O
.	O
handler	pointer
=	O
disp_readev_fn	function
;	O
D_writeev	O
.	O
handler	pointer
=	O
disp_writeev_fn	function
;	O
evenq	function
(	O
&	O
D_readev	O
)	O
;	O
D_writeev	O
.	O
condpos	pointer
=	O
&	O
D_obuflen	O
;	O
D_writeev	O
.	O
condneg	pointer
=	O
&	O
D_obuffree	O
;	O
evenq	function
(	O
&	O
D_writeev	O
)	O
;	O
D_statusev	O
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
D_statusev	O
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
display	struct
;	O
D_statusev	O
.	O
handler	pointer
=	O
disp_status_fn	function
;	O
D_hstatusev	O
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
D_hstatusev	O
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
display	struct
;	O
D_hstatusev	O
.	O
handler	pointer
=	O
disp_hstatus_fn	function
;	O
D_blockedev	O
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
D_blockedev	O
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
display	struct
;	O
D_blockedev	O
.	O
handler	pointer
=	O
disp_blocked_fn	function
;	O
D_blockedev	O
.	O
condpos	pointer
=	O
&	O
D_obuffree	O
;	O
D_blockedev	O
.	O
condneg	pointer
=	O
&	O
D_obuflenmax	O
;	O
D_hstatusev	O
.	O
handler	pointer
=	O
disp_hstatus_fn	function
;	O
D_mapev	O
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
D_mapev	O
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
display	struct
;	O
D_mapev	O
.	O
handler	pointer
=	O
disp_map_fn	function
;	O
D_idleev	O
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
D_idleev	O
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
display	struct
;	O
D_idleev	O
.	O
handler	pointer
=	O
disp_idle_fn	function
;	O
D_blankerev	O
.	O
type	enum
=	O
EV_READ	int
;	O
D_blankerev	O
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
display	struct
;	O
D_blankerev	O
.	O
handler	pointer
=	O
disp_blanker_fn	function
;	O
D_blankerev	O
.	O
fd	int
=	O
-	O
1	int
;	O
D_OldMode	O
=	O
*	O
Mode	pointer
;	O
D_status_obuffree	O
=	O
-	O
1	int
;	O
Resize_obuf	function
(	O
)	O
;	O
D_obufmax	O
=	O
defobuflimit	int
;	O
D_obuflenmax	O
=	O
D_obuflen	O
-	O
D_obufmax	O
;	O
D_auto_nuke	O
=	O
defautonuke	int
;	O
D_obufp	O
=	O
D_obuf	O
;	O
D_printfd	O
=	O
-	O
1	int
;	O
D_userpid	O
=	O
pid	int
;	O
if	O
(	O
(	O
b	pointer
=	O
lookup_baud	function
(	O
(	O
int	O
)	O
cfgetospeed	function
(	O
&	O
D_OldMode	O
.	O
tio	struct
)	O
)	O
)	O
)	O
D_dospeed	O
=	O
b	pointer
->	O
idx	int
;	O
debug1	O
(	O
"New displays ospeed = %d\n"	pointer
,	O
D_dospeed	O
)	O
;	O
strncpy	function
(	O
D_usertty	O
,	O
utty	pointer
,	O
sizeof	O
(	O
D_usertty	O
)	O
-	O
1	int
)	O
;	O
D_usertty	O
[	O
sizeof	O
(	O
D_usertty	O
)	O
-	O
1	int
]	O
=	O
0	int
;	O
strncpy	function
(	O
D_termname	O
,	O
term	struct
,	O
MAXTERMLEN	int
)	O
;	O
D_termname	O
[	O
MAXTERMLEN	int
]	O
=	O
0	int
;	O
D_user	O
=	O
*	O
u	pointer
;	O
D_processinput	O
=	O
ProcessInput	function
;	O
D_mousetrack	O
=	O
defmousetrack	int
;	O
return	O
display	struct
;	O
}	O
void	O
FreeDisplay	function
(	O
)	O
{	O
struct	O
win	struct
*	O
p	pointer
;	O
struct	O
display	struct
*	O
d	int
,	O
*	O
*	O
dp	pointer
;	O
FreeTransTable	function
(	O
)	O
;	O
KillBlanker	function
(	O
)	O
;	O
if	O
(	O
D_userfd	O
>=	O
0	int
)	O
{	O
Flush	function
(	O
3	int
)	O
;	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
SetTTY	function
(	O
D_userfd	O
,	O
&	O
D_OldMode	O
)	O
;	O
fcntl	function
(	O
D_userfd	O
,	O
F_SETFL	int
,	O
0	int
)	O
;	O
}	O
freetty	function
(	O
)	O
;	O
if	O
(	O
D_tentry	O
)	O
free	function
(	O
D_tentry	O
)	O
;	O
D_tentry	O
=	O
0	int
;	O
if	O
(	O
D_processinputdata	O
)	O
free	function
(	O
D_processinputdata	O
)	O
;	O
D_processinputdata	O
=	O
0	int
;	O
D_tcinited	O
=	O
0	int
;	O
evdeq	function
(	O
&	O
D_hstatusev	O
)	O
;	O
evdeq	function
(	O
&	O
D_statusev	O
)	O
;	O
evdeq	function
(	O
&	O
D_readev	O
)	O
;	O
evdeq	function
(	O
&	O
D_writeev	O
)	O
;	O
evdeq	function
(	O
&	O
D_blockedev	O
)	O
;	O
evdeq	function
(	O
&	O
D_mapev	O
)	O
;	O
if	O
(	O
D_kmaps	O
)	O
{	O
free	function
(	O
D_kmaps	O
)	O
;	O
D_kmaps	O
=	O
0	int
;	O
D_aseqs	O
=	O
0	int
;	O
D_nseqs	O
=	O
0	int
;	O
D_seqp	O
=	O
0	int
;	O
D_seql	O
=	O
0	int
;	O
D_seqh	O
=	O
0	int
;	O
}	O
evdeq	function
(	O
&	O
D_idleev	O
)	O
;	O
evdeq	function
(	O
&	O
D_blankerev	O
)	O
;	O
for	O
(	O
dp	pointer
=	O
&	O
displays	pointer
;	O
(	O
d	int
=	O
*	O
dp	pointer
)	O
;	O
dp	pointer
=	O
&	O
d	int
->	O
d_next	pointer
)	O
if	O
(	O
d	int
==	O
display	struct
)	O
break	O
;	O
ASSERT	O
(	O
d	int
)	O
;	O
if	O
(	O
D_status_lastmsg	O
)	O
free	function
(	O
D_status_lastmsg	O
)	O
;	O
if	O
(	O
D_obuf	O
)	O
free	function
(	O
D_obuf	O
)	O
;	O
*	O
dp	pointer
=	O
display	struct
->	O
d_next	pointer
;	O
while	O
(	O
D_canvas	O
.	O
c_slperp	pointer
)	O
FreeCanvas	function
(	O
D_canvas	O
.	O
c_slperp	pointer
)	O
;	O
D_cvlist	O
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
w_pdisplay	pointer
==	O
display	struct
)	O
p	pointer
->	O
w_pdisplay	pointer
=	O
0	int
;	O
if	O
(	O
p	pointer
->	O
w_lastdisp	pointer
==	O
display	struct
)	O
p	pointer
->	O
w_lastdisp	pointer
=	O
0	int
;	O
if	O
(	O
p	pointer
->	O
w_readev	struct
.	O
condneg	pointer
==	O
&	O
D_status	O
||	O
p	pointer
->	O
w_readev	struct
.	O
condneg	pointer
==	O
&	O
D_obuflenmax	O
)	O
p	pointer
->	O
w_readev	struct
.	O
condpos	pointer
=	O
p	pointer
->	O
w_readev	struct
.	O
condneg	pointer
=	O
0	int
;	O
}	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
if	O
(	O
p	pointer
->	O
w_zdisplay	pointer
==	O
display	struct
)	O
zmodem_abort	function
(	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
D_mousetrack	O
)	O
{	O
D_mousetrack	O
=	O
0	int
;	O
MouseMode	function
(	O
0	int
)	O
;	O
}	O
free	function
(	O
(	O
char	O
*	O
)	O
display	struct
)	O
;	O
display	struct
=	O
0	int
;	O
}	O
void	O
InitTerm	function
(	O
adapt	int
)	O
int	O
adapt	int
;	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
ASSERT	O
(	O
D_tcinited	O
)	O
;	O
D_top	O
=	O
D_bot	O
=	O
-	O
1	int
;	O
AddCStr	function
(	O
D_IS	O
)	O
;	O
AddCStr	function
(	O
D_TI	O
)	O
;	O
if	O
(	O
D_IM	O
&&	O
strcmp	function
(	O
D_IM	O
,	O
D_EI	O
)	O
)	O
AddCStr	function
(	O
D_EI	O
)	O
;	O
D_insert	O
=	O
0	int
;	O
AddCStr	function
(	O
D_KS	O
)	O
;	O
AddCStr	function
(	O
D_CCS	O
)	O
;	O
D_keypad	O
=	O
0	int
;	O
D_cursorkeys	O
=	O
0	int
;	O
AddCStr	function
(	O
D_ME	O
)	O
;	O
AddCStr	function
(	O
D_EA	O
)	O
;	O
AddCStr	function
(	O
D_CE0	O
)	O
;	O
D_rend	O
=	O
mchar_null	struct
;	O
D_atyp	O
=	O
0	int
;	O
if	O
(	O
adapt	int
==	O
0	int
)	O
ResizeDisplay	function
(	O
D_defwidth	O
,	O
D_defheight	O
)	O
;	O
ChangeScrollRegion	function
(	O
0	int
,	O
D_height	O
-	O
1	int
)	O
;	O
D_x	O
=	O
D_y	O
=	O
0	int
;	O
Flush	function
(	O
3	int
)	O
;	O
ClearAll	function
(	O
)	O
;	O
debug1	O
(	O
"we %swant to adapt all our windows to the display\n"	pointer
,	O
(	O
adapt	int
)	O
?	O
""	pointer
:	O
"don't "	pointer
)	O
;	O
CheckScreenSize	function
(	O
(	O
adapt	int
)	O
?	O
2	int
:	O
0	int
)	O
;	O
}	O
void	O
FinitTerm	function
(	O
)	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
KillBlanker	function
(	O
)	O
;	O
if	O
(	O
D_tcinited	O
)	O
{	O
ResizeDisplay	function
(	O
D_defwidth	O
,	O
D_defheight	O
)	O
;	O
InsertMode	function
(	O
0	int
)	O
;	O
ChangeScrollRegion	function
(	O
0	int
,	O
D_height	O
-	O
1	int
)	O
;	O
KeypadMode	function
(	O
0	int
)	O
;	O
CursorkeysMode	function
(	O
0	int
)	O
;	O
CursorVisibility	function
(	O
0	int
)	O
;	O
if	O
(	O
D_mousetrack	O
)	O
D_mousetrack	O
=	O
0	int
;	O
MouseMode	function
(	O
0	int
)	O
;	O
ExtMouseMode	function
(	O
0	int
)	O
;	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
SetFlow	function
(	O
FLOW_NOW	O
)	O
;	O
AddCStr	function
(	O
D_KE	O
)	O
;	O
AddCStr	function
(	O
D_CCE	O
)	O
;	O
if	O
(	O
D_hstatus	O
)	O
ShowHStatus	function
(	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
D_x	O
=	O
D_y	O
=	O
-	O
1	int
;	O
GotoPos	function
(	O
0	int
,	O
D_height	O
-	O
1	int
)	O
;	O
AddChar	O
(	O
'\r'	O
)	O
;	O
AddChar	O
(	O
'\n'	O
)	O
;	O
AddCStr	function
(	O
D_TE	O
)	O
;	O
}	O
Flush	function
(	O
3	int
)	O
;	O
}	O
static	O
void	O
INSERTCHAR	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
!	O
D_insert	O
&&	O
D_x	O
<	O
D_width	O
-	O
1	int
)	O
{	O
if	O
(	O
D_IC	O
||	O
D_CIC	O
)	O
{	O
if	O
(	O
D_IC	O
)	O
AddCStr	function
(	O
D_IC	O
)	O
;	O
else	O
AddCStr2	function
(	O
D_CIC	O
,	O
1	int
)	O
;	O
RAW_PUTCHAR	function
(	O
c	int
)	O
;	O
return	O
;	O
}	O
InsertMode	function
(	O
1	int
)	O
;	O
if	O
(	O
!	O
D_insert	O
)	O
{	O
RefreshLine	function
(	O
D_y	O
,	O
D_x	O
,	O
D_width	O
-	O
1	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
}	O
RAW_PUTCHAR	function
(	O
c	int
)	O
;	O
}	O
void	O
PUTCHAR	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
D_insert	O
&&	O
D_x	O
<	O
D_width	O
-	O
1	int
)	O
InsertMode	function
(	O
0	int
)	O
;	O
RAW_PUTCHAR	function
(	O
c	int
)	O
;	O
}	O
void	O
PUTCHARLP	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
D_x	O
<	O
D_width	O
-	O
1	int
)	O
{	O
if	O
(	O
D_insert	O
)	O
InsertMode	function
(	O
0	int
)	O
;	O
RAW_PUTCHAR	function
(	O
c	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
D_CLP	O
||	O
D_y	O
!=	O
D_bot	O
)	O
{	O
int	O
y	int
=	O
D_y	O
;	O
RAW_PUTCHAR	function
(	O
c	int
)	O
;	O
if	O
(	O
D_AM	O
&&	O
!	O
D_CLP	O
)	O
GotoPos	function
(	O
D_width	O
-	O
1	int
,	O
y	int
)	O
;	O
return	O
;	O
}	O
debug	O
(	O
"PUTCHARLP: lp_missing!\n"	pointer
)	O
;	O
D_lp_missing	O
=	O
1	int
;	O
D_rend	O
.	O
image	char
=	O
c	int
;	O
D_lpchar	O
=	O
D_rend	O
;	O
if	O
(	O
D_mbcs	O
)	O
{	O
D_lpchar	O
.	O
mbcs	char
=	O
c	int
;	O
D_lpchar	O
.	O
image	char
=	O
D_mbcs	O
;	O
D_mbcs	O
=	O
0	int
;	O
D_x	O
--	O
;	O
}	O
}	O
STATIC	O
void	O
RAW_PUTCHAR	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
{	O
c	int
=	O
(	O
c	int
&	O
255	int
)	O
|	O
(	O
unsigned	O
char	O
)	O
D_rend	O
.	O
font	char
<<	O
8	int
|	O
(	O
unsigned	O
char	O
)	O
D_rend	O
.	O
fontx	char
<<	O
16	int
;	O
if	O
(	O
D_mbcs	O
)	O
{	O
c	int
=	O
D_mbcs	O
;	O
if	O
(	O
D_x	O
==	O
D_width	O
)	O
D_x	O
+=	O
D_AM	O
?	O
1	int
:	O
-	O
1	int
;	O
D_mbcs	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
utf8_isdouble	function
(	O
c	int
)	O
)	O
{	O
D_mbcs	O
=	O
c	int
;	O
D_x	O
++	O
;	O
return	O
;	O
}	O
if	O
(	O
c	int
<	O
32	int
)	O
{	O
AddCStr2	function
(	O
D_CS0	O
,	O
'0'	O
)	O
;	O
AddChar	O
(	O
c	int
+	O
0x5f	int
)	O
;	O
AddCStr	function
(	O
D_CE0	O
)	O
;	O
goto	O
addedutf8	O
;	O
}	O
if	O
(	O
c	int
<	O
0x80	int
)	O
{	O
if	O
(	O
D_xtable	O
&&	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
D_rend	O
.	O
font	char
]	O
&&	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
D_rend	O
.	O
font	char
]	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
c	int
]	O
)	O
AddStr	function
(	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
D_rend	O
.	O
font	char
]	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
c	int
]	O
)	O
;	O
else	O
AddChar	O
(	O
c	int
)	O
;	O
}	O
else	O
AddUtf8	function
(	O
c	int
)	O
;	O
goto	O
addedutf8	O
;	O
}	O
if	O
(	O
is_dw_font	O
(	O
D_rend	O
.	O
font	char
)	O
)	O
{	O
int	O
t	int
=	O
c	int
;	O
if	O
(	O
D_mbcs	O
==	O
0	int
)	O
{	O
D_mbcs	O
=	O
c	int
;	O
D_x	O
++	O
;	O
return	O
;	O
}	O
D_x	O
--	O
;	O
if	O
(	O
D_x	O
==	O
D_width	O
-	O
1	int
)	O
D_x	O
+=	O
D_AM	O
?	O
1	int
:	O
-	O
1	int
;	O
c	int
=	O
D_mbcs	O
;	O
D_mbcs	O
=	O
t	int
;	O
}	O
if	O
(	O
D_encoding	O
)	O
c	int
=	O
PrepareEncodedChar	function
(	O
c	int
)	O
;	O
kanjiloop	O
:	O
if	O
(	O
D_xtable	O
&&	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
D_rend	O
.	O
font	char
]	O
&&	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
D_rend	O
.	O
font	char
]	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
c	int
]	O
)	O
AddStr	function
(	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
D_rend	O
.	O
font	char
]	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
c	int
]	O
)	O
;	O
else	O
AddChar	O
(	O
D_rend	O
.	O
font	char
!=	O
'0'	O
?	O
c	int
:	O
D_c0_tab	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
c	int
]	O
)	O
;	O
addedutf8	O
:	O
if	O
(	O
++	O
D_x	O
>=	O
D_width	O
)	O
{	O
if	O
(	O
D_AM	O
==	O
0	int
)	O
D_x	O
=	O
D_width	O
-	O
1	int
;	O
else	O
if	O
(	O
!	O
D_CLP	O
||	O
D_x	O
>	O
D_width	O
)	O
{	O
D_x	O
-=	O
D_width	O
;	O
if	O
(	O
D_y	O
<	O
D_height	O
-	O
1	int
&&	O
D_y	O
!=	O
D_bot	O
)	O
D_y	O
++	O
;	O
}	O
}	O
if	O
(	O
D_mbcs	O
)	O
{	O
c	int
=	O
D_mbcs	O
;	O
D_mbcs	O
=	O
0	int
;	O
goto	O
kanjiloop	O
;	O
}	O
}	O
static	O
int	O
DoAddChar	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
AddChar	O
(	O
c	int
)	O
;	O
return	O
c	int
;	O
}	O
void	O
AddCStr	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
if	O
(	O
display	struct
&&	O
s	pointer
&&	O
*	O
s	pointer
)	O
{	O
ospeed	short
=	O
D_dospeed	O
;	O
tputs	function
(	O
s	pointer
,	O
1	int
,	O
DoAddChar	function
)	O
;	O
}	O
}	O
void	O
AddCStr2	function
(	O
s	pointer
,	O
c	int
)	O
char	O
*	O
s	pointer
;	O
int	O
c	int
;	O
{	O
if	O
(	O
display	struct
&&	O
s	pointer
&&	O
*	O
s	pointer
)	O
{	O
ospeed	short
=	O
D_dospeed	O
;	O
tputs	function
(	O
tgoto	function
(	O
s	pointer
,	O
0	int
,	O
c	int
)	O
,	O
1	int
,	O
DoAddChar	function
)	O
;	O
}	O
}	O
void	O
InsertMode	function
(	O
on	int
)	O
int	O
on	int
;	O
{	O
if	O
(	O
display	struct
&&	O
on	int
!=	O
D_insert	O
&&	O
D_IM	O
)	O
{	O
D_insert	O
=	O
on	int
;	O
if	O
(	O
on	int
)	O
AddCStr	function
(	O
D_IM	O
)	O
;	O
else	O
AddCStr	function
(	O
D_EI	O
)	O
;	O
}	O
}	O
void	O
KeypadMode	function
(	O
on	int
)	O
int	O
on	int
;	O
{	O
if	O
(	O
display	struct
)	O
D_keypad	O
=	O
on	int
;	O
}	O
void	O
CursorkeysMode	function
(	O
on	int
)	O
int	O
on	int
;	O
{	O
if	O
(	O
display	struct
)	O
D_cursorkeys	O
=	O
on	int
;	O
}	O
void	O
ReverseVideo	function
(	O
on	int
)	O
int	O
on	int
;	O
{	O
if	O
(	O
display	struct
&&	O
D_revvid	O
!=	O
on	int
&&	O
D_CVR	O
)	O
{	O
D_revvid	O
=	O
on	int
;	O
if	O
(	O
D_revvid	O
)	O
AddCStr	function
(	O
D_CVR	O
)	O
;	O
else	O
AddCStr	function
(	O
D_CVN	O
)	O
;	O
}	O
}	O
void	O
CursorVisibility	function
(	O
v	int
)	O
int	O
v	int
;	O
{	O
if	O
(	O
display	struct
&&	O
D_curvis	O
!=	O
v	int
)	O
{	O
if	O
(	O
D_curvis	O
)	O
AddCStr	function
(	O
D_VE	O
)	O
;	O
D_curvis	O
=	O
0	int
;	O
if	O
(	O
v	int
==	O
-	O
1	int
&&	O
D_VI	O
)	O
AddCStr	function
(	O
D_VI	O
)	O
;	O
else	O
if	O
(	O
v	int
==	O
1	int
&&	O
D_VS	O
)	O
AddCStr	function
(	O
D_VS	O
)	O
;	O
else	O
return	O
;	O
D_curvis	O
=	O
v	int
;	O
}	O
}	O
void	O
MouseMode	function
(	O
mode	struct
)	O
int	O
mode	struct
;	O
{	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
if	O
(	O
mode	struct
<	O
D_mousetrack	O
)	O
mode	struct
=	O
D_mousetrack	O
;	O
if	O
(	O
D_mouse	O
!=	O
mode	struct
)	O
{	O
char	O
mousebuf	array
[	O
20	int
]	O
;	O
if	O
(	O
!	O
D_CXT	O
)	O
return	O
;	O
if	O
(	O
D_mouse	O
)	O
{	O
sprintf	function
(	O
mousebuf	array
,	O
"\033[?%dl"	pointer
,	O
D_mouse	O
)	O
;	O
AddStr	function
(	O
mousebuf	array
)	O
;	O
}	O
if	O
(	O
mode	struct
)	O
{	O
sprintf	function
(	O
mousebuf	array
,	O
"\033[?%dh"	pointer
,	O
mode	struct
)	O
;	O
AddStr	function
(	O
mousebuf	array
)	O
;	O
}	O
D_mouse	O
=	O
mode	struct
;	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_INACTIVE	int
;	O
}	O
}	O
void	O
ExtMouseMode	function
(	O
mode	struct
)	O
int	O
mode	struct
;	O
{	O
if	O
(	O
display	struct
&&	O
D_extmouse	O
!=	O
mode	struct
)	O
{	O
char	O
mousebuf	array
[	O
20	int
]	O
;	O
if	O
(	O
!	O
D_CXT	O
)	O
return	O
;	O
if	O
(	O
D_extmouse	O
)	O
{	O
sprintf	function
(	O
mousebuf	array
,	O
"\033[?%dl"	pointer
,	O
D_extmouse	O
)	O
;	O
AddStr	function
(	O
mousebuf	array
)	O
;	O
}	O
if	O
(	O
mode	struct
)	O
{	O
sprintf	function
(	O
mousebuf	array
,	O
"\033[?%dh"	pointer
,	O
mode	struct
)	O
;	O
AddStr	function
(	O
mousebuf	array
)	O
;	O
}	O
D_extmouse	O
=	O
mode	struct
;	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_INACTIVE	int
;	O
}	O
}	O
static	O
int	O
StrCost	int
;	O
static	O
int	O
CountChars	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
StrCost	int
++	O
;	O
return	O
c	int
;	O
}	O
int	O
CalcCost	function
(	O
s	pointer
)	O
register	O
char	O
*	O
s	pointer
;	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
StrCost	int
=	O
0	int
;	O
ospeed	short
=	O
D_dospeed	O
;	O
tputs	function
(	O
s	pointer
,	O
1	int
,	O
CountChars	function
)	O
;	O
return	O
StrCost	int
;	O
}	O
else	O
return	O
EXPENSIVE	int
;	O
}	O
static	O
int	O
CallRewrite	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
doit	int
)	O
int	O
y	int
,	O
xs	int
,	O
xe	int
,	O
doit	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
*	O
cvlist	pointer
,	O
*	O
cvlnext	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
struct	O
layer	struct
*	O
oldflayer	pointer
;	O
int	O
cost	int
;	O
debug3	O
(	O
"CallRewrite %d %d %d\n"	pointer
,	O
y	int
,	O
xs	int
,	O
xe	int
)	O
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
ASSERT	O
(	O
xe	int
>=	O
xs	int
)	O
;	O
vp	pointer
=	O
0	int
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
if	O
(	O
y	int
<	O
cv	pointer
->	O
c_ys	int
||	O
y	int
>	O
cv	pointer
->	O
c_ye	int
||	O
xe	int
<	O
cv	pointer
->	O
c_xs	int
||	O
xs	int
>	O
cv	pointer
->	O
c_xe	int
)	O
continue	O
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
if	O
(	O
y	int
>=	O
vp	pointer
->	O
v_ys	int
&&	O
y	int
<=	O
vp	pointer
->	O
v_ye	int
&&	O
xe	int
>=	O
vp	pointer
->	O
v_xs	int
&&	O
xs	int
<=	O
vp	pointer
->	O
v_xe	int
)	O
break	O
;	O
if	O
(	O
vp	pointer
)	O
break	O
;	O
}	O
if	O
(	O
doit	int
)	O
{	O
oldflayer	pointer
=	O
flayer	pointer
;	O
flayer	pointer
=	O
cv	pointer
->	O
c_layer	pointer
;	O
cvlist	pointer
=	O
flayer	pointer
->	O
l_cvlist	pointer
;	O
cvlnext	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
;	O
flayer	pointer
->	O
l_cvlist	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
LayRewrite	O
(	O
y	int
-	O
vp	pointer
->	O
v_yoff	int
,	O
xs	int
-	O
vp	pointer
->	O
v_xoff	int
,	O
xe	int
-	O
vp	pointer
->	O
v_xoff	int
,	O
&	O
D_rend	O
,	O
1	int
)	O
;	O
flayer	pointer
->	O
l_cvlist	pointer
=	O
cvlist	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
cvlnext	pointer
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
cv	pointer
==	O
0	int
||	O
cv	pointer
->	O
c_layer	pointer
==	O
0	int
)	O
return	O
EXPENSIVE	int
;	O
if	O
(	O
xs	int
<	O
vp	pointer
->	O
v_xs	int
||	O
xe	int
>	O
vp	pointer
->	O
v_xe	int
)	O
return	O
EXPENSIVE	int
;	O
if	O
(	O
y	int
-	O
vp	pointer
->	O
v_yoff	int
<	O
0	int
||	O
y	int
-	O
vp	pointer
->	O
v_yoff	int
>=	O
cv	pointer
->	O
c_layer	pointer
->	O
l_height	int
)	O
return	O
EXPENSIVE	int
;	O
if	O
(	O
xs	int
-	O
vp	pointer
->	O
v_xoff	int
<	O
0	int
||	O
xe	int
-	O
vp	pointer
->	O
v_xoff	int
>=	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
)	O
return	O
EXPENSIVE	int
;	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
D_rend	O
.	O
font	char
=	O
0	int
;	O
oldflayer	pointer
=	O
flayer	pointer
;	O
flayer	pointer
=	O
cv	pointer
->	O
c_layer	pointer
;	O
debug3	O
(	O
"Calling Rewrite %d %d %d\n"	pointer
,	O
y	int
-	O
vp	pointer
->	O
v_yoff	int
,	O
xs	int
-	O
vp	pointer
->	O
v_xoff	int
,	O
xe	int
-	O
vp	pointer
->	O
v_xoff	int
)	O
;	O
cost	int
=	O
LayRewrite	O
(	O
y	int
-	O
vp	pointer
->	O
v_yoff	int
,	O
xs	int
-	O
vp	pointer
->	O
v_xoff	int
,	O
xe	int
-	O
vp	pointer
->	O
v_xoff	int
,	O
&	O
D_rend	O
,	O
0	int
)	O
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
if	O
(	O
D_insert	O
)	O
cost	int
+=	O
D_EIcost	O
+	O
D_IMcost	O
;	O
return	O
cost	int
;	O
}	O
void	O
GotoPos	function
(	O
x2	int
,	O
y2	int
)	O
int	O
x2	int
,	O
y2	int
;	O
{	O
register	O
int	O
dy	int
,	O
dx	int
,	O
x1	int
,	O
y1	int
;	O
register	O
int	O
costx	int
,	O
costy	int
;	O
register	O
int	O
m	union
;	O
register	O
char	O
*	O
s	pointer
;	O
int	O
CMcost	int
;	O
enum	O
move_t	enum
xm	enum
=	O
M_NONE	int
,	O
ym	enum
=	O
M_NONE	int
;	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
x1	int
=	O
D_x	O
;	O
y1	int
=	O
D_y	O
;	O
if	O
(	O
x1	int
==	O
D_width	O
)	O
{	O
if	O
(	O
D_CLP	O
&&	O
D_AM	O
)	O
x1	int
=	O
-	O
1	int
;	O
else	O
x1	int
--	O
;	O
}	O
if	O
(	O
x2	int
==	O
D_width	O
)	O
x2	int
--	O
;	O
dx	int
=	O
x2	int
-	O
x1	int
;	O
dy	int
=	O
y2	int
-	O
y1	int
;	O
if	O
(	O
dy	int
==	O
0	int
&&	O
dx	int
==	O
0	int
)	O
return	O
;	O
debug2	O
(	O
"GotoPos (%d,%d)"	pointer
,	O
x1	int
,	O
y1	int
)	O
;	O
debug2	O
(	O
" -> (%d,%d)\n"	pointer
,	O
x2	int
,	O
y2	int
)	O
;	O
if	O
(	O
!	O
D_MS	O
)	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
if	O
(	O
y1	int
<	O
0	int
||	O
(	O
y2	int
>	O
D_bot	O
&&	O
y1	int
<=	O
D_bot	O
)	O
||	O
(	O
y2	int
<	O
D_top	O
&&	O
y1	int
>=	O
D_top	O
)	O
)	O
{	O
DoCM	O
:	O
if	O
(	O
D_HO	O
&&	O
!	O
x2	int
&&	O
!	O
y2	int
)	O
AddCStr	function
(	O
D_HO	O
)	O
;	O
else	O
AddCStr	function
(	O
tgoto	function
(	O
D_CM	O
,	O
x2	int
,	O
y2	int
)	O
)	O
;	O
D_x	O
=	O
x2	int
;	O
D_y	O
=	O
y2	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
y1	int
>	O
D_bot	O
&&	O
y2	int
>	O
y1	int
)	O
||	O
(	O
y1	int
<	O
D_top	O
&&	O
y2	int
<	O
y1	int
)	O
)	O
goto	O
DoCM	O
;	O
if	O
(	O
D_HO	O
&&	O
!	O
x2	int
&&	O
!	O
y2	int
)	O
s	pointer
=	O
D_HO	O
;	O
else	O
s	pointer
=	O
tgoto	function
(	O
D_CM	O
,	O
x2	int
,	O
y2	int
)	O
;	O
CMcost	int
=	O
CalcCost	function
(	O
s	pointer
)	O
;	O
costx	int
=	O
EXPENSIVE	int
;	O
if	O
(	O
x1	int
>=	O
0	int
)	O
{	O
if	O
(	O
dx	int
>	O
0	int
)	O
{	O
if	O
(	O
D_CRI	O
&&	O
(	O
dx	int
>	O
1	int
||	O
!	O
D_ND	O
)	O
)	O
{	O
costx	int
=	O
CalcCost	function
(	O
tgoto	function
(	O
D_CRI	O
,	O
0	int
,	O
dx	int
)	O
)	O
;	O
xm	enum
=	O
M_CRI	int
;	O
}	O
if	O
(	O
(	O
m	union
=	O
D_NDcost	O
*	O
dx	int
)	O
<	O
costx	int
)	O
{	O
costx	int
=	O
m	union
;	O
xm	enum
=	O
M_RI	int
;	O
}	O
if	O
(	O
dx	int
<	O
costx	int
&&	O
(	O
m	union
=	O
CallRewrite	function
(	O
y1	int
,	O
x1	int
,	O
x2	int
-	O
1	int
,	O
0	int
)	O
)	O
<	O
costx	int
)	O
{	O
costx	int
=	O
m	union
;	O
xm	enum
=	O
M_RW	int
;	O
}	O
}	O
else	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
if	O
(	O
D_CLE	O
&&	O
(	O
dx	int
<	O
-	O
1	int
||	O
!	O
D_BC	O
)	O
)	O
{	O
costx	int
=	O
CalcCost	function
(	O
tgoto	function
(	O
D_CLE	O
,	O
0	int
,	O
-	O
dx	int
)	O
)	O
;	O
xm	enum
=	O
M_CLE	int
;	O
}	O
if	O
(	O
(	O
m	union
=	O
-	O
dx	int
*	O
D_LEcost	O
)	O
<	O
costx	int
)	O
{	O
costx	int
=	O
m	union
;	O
xm	enum
=	O
M_LE	int
;	O
}	O
}	O
else	O
costx	int
=	O
0	int
;	O
}	O
if	O
(	O
x2	int
+	O
D_CRcost	O
<	O
costx	int
&&	O
(	O
m	union
=	O
(	O
x2	int
?	O
CallRewrite	function
(	O
y1	int
,	O
0	int
,	O
x2	int
-	O
1	int
,	O
0	int
)	O
:	O
0	int
)	O
+	O
D_CRcost	O
)	O
<	O
costx	int
)	O
{	O
costx	int
=	O
m	union
;	O
xm	enum
=	O
M_CR	int
;	O
}	O
if	O
(	O
costx	int
>=	O
CMcost	int
)	O
goto	O
DoCM	O
;	O
costy	int
=	O
EXPENSIVE	int
;	O
if	O
(	O
dy	int
>	O
0	int
)	O
{	O
if	O
(	O
D_CDO	O
&&	O
dy	int
>	O
1	int
)	O
{	O
costy	int
=	O
CalcCost	function
(	O
tgoto	function
(	O
D_CDO	O
,	O
0	int
,	O
dy	int
)	O
)	O
;	O
ym	enum
=	O
M_CDO	int
;	O
}	O
if	O
(	O
(	O
m	union
=	O
dy	int
*	O
(	O
(	O
x2	int
==	O
0	int
)	O
?	O
D_NLcost	O
:	O
D_DOcost	O
)	O
)	O
<	O
costy	int
)	O
{	O
costy	int
=	O
m	union
;	O
ym	enum
=	O
M_DO	int
;	O
}	O
}	O
else	O
if	O
(	O
dy	int
<	O
0	int
)	O
{	O
if	O
(	O
D_CUP	O
&&	O
(	O
dy	int
<	O
-	O
1	int
||	O
!	O
D_UP	O
)	O
)	O
{	O
costy	int
=	O
CalcCost	function
(	O
tgoto	function
(	O
D_CUP	O
,	O
0	int
,	O
-	O
dy	int
)	O
)	O
;	O
ym	enum
=	O
M_CUP	int
;	O
}	O
if	O
(	O
(	O
m	union
=	O
-	O
dy	int
*	O
D_UPcost	O
)	O
<	O
costy	int
)	O
{	O
costy	int
=	O
m	union
;	O
ym	enum
=	O
M_UP	int
;	O
}	O
}	O
else	O
costy	int
=	O
0	int
;	O
if	O
(	O
costx	int
+	O
costy	int
>=	O
CMcost	int
)	O
goto	O
DoCM	O
;	O
switch	O
(	O
xm	enum
)	O
{	O
case	O
M_LE	int
:	O
while	O
(	O
dx	int
++	O
<	O
0	int
)	O
AddCStr	function
(	O
D_BC	O
)	O
;	O
break	O
;	O
case	O
M_CLE	int
:	O
AddCStr2	function
(	O
D_CLE	O
,	O
-	O
dx	int
)	O
;	O
break	O
;	O
case	O
M_RI	int
:	O
while	O
(	O
dx	int
--	O
>	O
0	int
)	O
AddCStr	function
(	O
D_ND	O
)	O
;	O
break	O
;	O
case	O
M_CRI	int
:	O
AddCStr2	function
(	O
D_CRI	O
,	O
dx	int
)	O
;	O
break	O
;	O
case	O
M_CR	int
:	O
AddCStr	function
(	O
D_CR	O
)	O
;	O
D_x	O
=	O
0	int
;	O
x1	int
=	O
0	int
;	O
case	O
M_RW	int
:	O
if	O
(	O
x1	int
<	O
x2	int
)	O
(	O
void	O
)	O
CallRewrite	function
(	O
y1	int
,	O
x1	int
,	O
x2	int
-	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
ym	enum
)	O
{	O
case	O
M_UP	int
:	O
while	O
(	O
dy	int
++	O
<	O
0	int
)	O
AddCStr	function
(	O
D_UP	O
)	O
;	O
break	O
;	O
case	O
M_CUP	int
:	O
AddCStr2	function
(	O
D_CUP	O
,	O
-	O
dy	int
)	O
;	O
break	O
;	O
case	O
M_DO	int
:	O
s	pointer
=	O
(	O
x2	int
==	O
0	int
)	O
?	O
D_NL	O
:	O
D_DO	O
;	O
while	O
(	O
dy	int
--	O
>	O
0	int
)	O
AddCStr	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
M_CDO	int
:	O
AddCStr2	function
(	O
D_CDO	O
,	O
dy	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
D_x	O
=	O
x2	int
;	O
D_y	O
=	O
y2	int
;	O
}	O
void	O
ClearAll	function
(	O
)	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
ClearArea	function
(	O
0	int
,	O
0	int
,	O
0	int
,	O
D_width	O
-	O
1	int
,	O
D_width	O
-	O
1	int
,	O
D_height	O
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
ClearArea	function
(	O
x1	int
,	O
y1	int
,	O
xs	int
,	O
xe	int
,	O
x2	int
,	O
y2	int
,	O
bce	int
,	O
uselayfn	int
)	O
int	O
x1	int
,	O
y1	int
,	O
xs	int
,	O
xe	int
,	O
x2	int
,	O
y2	int
,	O
bce	int
,	O
uselayfn	int
;	O
{	O
int	O
y	int
,	O
xxe	int
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
viewport	struct
*	O
vp	pointer
;	O
debug2	O
(	O
"Clear %d,%d"	pointer
,	O
x1	int
,	O
y1	int
)	O
;	O
debug2	O
(	O
" %d-%d"	pointer
,	O
xs	int
,	O
xe	int
)	O
;	O
debug2	O
(	O
" %d,%d"	pointer
,	O
x2	int
,	O
y2	int
)	O
;	O
debug2	O
(	O
" uselayfn=%d bce=%d\n"	pointer
,	O
uselayfn	int
,	O
bce	int
)	O
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
x1	int
==	O
D_width	O
)	O
x1	int
--	O
;	O
if	O
(	O
x2	int
==	O
D_width	O
)	O
x2	int
--	O
;	O
if	O
(	O
xs	int
==	O
-	O
1	int
)	O
xs	int
=	O
x1	int
;	O
if	O
(	O
xe	int
==	O
-	O
1	int
)	O
xe	int
=	O
x2	int
;	O
if	O
(	O
D_UT	O
)	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
if	O
(	O
D_BE	O
)	O
SetBackColor	function
(	O
bce	int
)	O
;	O
if	O
(	O
D_lp_missing	O
&&	O
y1	int
<=	O
D_bot	O
&&	O
xe	int
>=	O
D_width	O
-	O
1	int
)	O
{	O
if	O
(	O
y2	int
>	O
D_bot	O
||	O
(	O
y2	int
==	O
D_bot	O
&&	O
x2	int
>=	O
D_width	O
-	O
1	int
)	O
)	O
D_lp_missing	O
=	O
0	int
;	O
}	O
if	O
(	O
x2	int
==	O
D_width	O
-	O
1	int
&&	O
(	O
xs	int
==	O
0	int
||	O
y1	int
==	O
y2	int
)	O
&&	O
xe	int
==	O
D_width	O
-	O
1	int
&&	O
y2	int
==	O
D_height	O
-	O
1	int
&&	O
(	O
!	O
bce	int
||	O
D_BE	O
)	O
)	O
{	O
if	O
(	O
x1	int
==	O
0	int
&&	O
y1	int
==	O
0	int
&&	O
D_auto_nuke	O
)	O
NukePending	function
(	O
)	O
;	O
if	O
(	O
x1	int
==	O
0	int
&&	O
y1	int
==	O
0	int
&&	O
D_CL	O
)	O
{	O
AddCStr	function
(	O
D_CL	O
)	O
;	O
D_y	O
=	O
D_x	O
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
D_CD	O
&&	O
(	O
y1	int
<	O
y2	int
||	O
!	O
D_CE	O
)	O
)	O
{	O
GotoPos	function
(	O
x1	int
,	O
y1	int
)	O
;	O
AddCStr	function
(	O
D_CD	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
x1	int
==	O
0	int
&&	O
xs	int
==	O
0	int
&&	O
(	O
xe	int
==	O
D_width	O
-	O
1	int
||	O
y1	int
==	O
y2	int
)	O
&&	O
y1	int
==	O
0	int
&&	O
D_CCD	O
&&	O
(	O
!	O
bce	int
||	O
D_BE	O
)	O
)	O
{	O
GotoPos	function
(	O
x1	int
,	O
y1	int
)	O
;	O
AddCStr	function
(	O
D_CCD	O
)	O
;	O
return	O
;	O
}	O
xxe	int
=	O
xe	int
;	O
for	O
(	O
y	int
=	O
y1	int
;	O
y	int
<=	O
y2	int
;	O
y	int
++	O
,	O
x1	int
=	O
xs	int
)	O
{	O
if	O
(	O
y	int
==	O
y2	int
)	O
xxe	int
=	O
x2	int
;	O
if	O
(	O
x1	int
==	O
0	int
&&	O
D_CB	O
&&	O
(	O
xxe	int
!=	O
D_width	O
-	O
1	int
||	O
(	O
D_x	O
==	O
xxe	int
&&	O
D_y	O
==	O
y	int
)	O
)	O
&&	O
(	O
!	O
bce	int
||	O
D_BE	O
)	O
)	O
{	O
GotoPos	function
(	O
xxe	int
,	O
y	int
)	O
;	O
AddCStr	function
(	O
D_CB	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
xxe	int
==	O
D_width	O
-	O
1	int
&&	O
D_CE	O
&&	O
(	O
!	O
bce	int
||	O
D_BE	O
)	O
)	O
{	O
GotoPos	function
(	O
x1	int
,	O
y	int
)	O
;	O
AddCStr	function
(	O
D_CE	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
uselayfn	int
)	O
{	O
vp	pointer
=	O
0	int
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
if	O
(	O
y	int
<	O
cv	pointer
->	O
c_ys	int
||	O
y	int
>	O
cv	pointer
->	O
c_ye	int
||	O
xxe	int
<	O
cv	pointer
->	O
c_xs	int
||	O
x1	int
>	O
cv	pointer
->	O
c_xe	int
)	O
continue	O
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
if	O
(	O
y	int
>=	O
vp	pointer
->	O
v_ys	int
&&	O
y	int
<=	O
vp	pointer
->	O
v_ye	int
&&	O
xxe	int
>=	O
vp	pointer
->	O
v_xs	int
&&	O
x1	int
<=	O
vp	pointer
->	O
v_xe	int
)	O
break	O
;	O
if	O
(	O
vp	pointer
)	O
break	O
;	O
}	O
if	O
(	O
cv	pointer
&&	O
cv	pointer
->	O
c_layer	pointer
&&	O
x1	int
>=	O
vp	pointer
->	O
v_xs	int
&&	O
xxe	int
<=	O
vp	pointer
->	O
v_xe	int
&&	O
y	int
-	O
vp	pointer
->	O
v_yoff	int
>=	O
0	int
&&	O
y	int
-	O
vp	pointer
->	O
v_yoff	int
<	O
cv	pointer
->	O
c_layer	pointer
->	O
l_height	int
&&	O
xxe	int
-	O
vp	pointer
->	O
v_xoff	int
>=	O
0	int
&&	O
x1	int
-	O
vp	pointer
->	O
v_xoff	int
<	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
)	O
{	O
struct	O
layer	struct
*	O
oldflayer	pointer
=	O
flayer	pointer
;	O
struct	O
canvas	struct
*	O
cvlist	pointer
,	O
*	O
cvlnext	pointer
;	O
flayer	pointer
=	O
cv	pointer
->	O
c_layer	pointer
;	O
cvlist	pointer
=	O
flayer	pointer
->	O
l_cvlist	pointer
;	O
cvlnext	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
;	O
flayer	pointer
->	O
l_cvlist	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
LayClearLine	O
(	O
y	int
-	O
vp	pointer
->	O
v_yoff	int
,	O
x1	int
-	O
vp	pointer
->	O
v_xoff	int
,	O
xxe	int
-	O
vp	pointer
->	O
v_xoff	int
,	O
bce	int
)	O
;	O
flayer	pointer
->	O
l_cvlist	pointer
=	O
cvlist	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
cvlnext	pointer
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
continue	O
;	O
}	O
}	O
ClearLine	function
(	O
(	O
struct	O
mline	struct
*	O
)	O
0	int
,	O
y	int
,	O
x1	int
,	O
xxe	int
,	O
bce	int
)	O
;	O
}	O
}	O
void	O
Redisplay	function
(	O
cur_only	int
)	O
int	O
cur_only	int
;	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
InsertMode	function
(	O
0	int
)	O
;	O
ChangeScrollRegion	function
(	O
0	int
,	O
D_height	O
-	O
1	int
)	O
;	O
KeypadMode	function
(	O
0	int
)	O
;	O
CursorkeysMode	function
(	O
0	int
)	O
;	O
CursorVisibility	function
(	O
0	int
)	O
;	O
MouseMode	function
(	O
0	int
)	O
;	O
ExtMouseMode	function
(	O
0	int
)	O
;	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
SetFlow	function
(	O
FLOW_NOW	O
)	O
;	O
ClearAll	function
(	O
)	O
;	O
if	O
(	O
cur_only	int
>	O
0	int
&&	O
D_fore	O
)	O
RefreshArea	function
(	O
0	int
,	O
D_fore	O
->	O
w_y	O
,	O
D_width	O
-	O
1	int
,	O
D_fore	O
->	O
w_y	O
,	O
1	int
)	O
;	O
else	O
RefreshAll	function
(	O
1	int
)	O
;	O
RefreshHStatus	function
(	O
)	O
;	O
CV_CALL	O
(	O
D_forecv	O
,	O
LayRestore	O
(	O
)	O
;	O
LaySetCursor	O
(	O
)	O
)	O
;	O
}	O
void	O
RedisplayDisplays	function
(	O
cur_only	int
)	O
int	O
cur_only	int
;	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
Redisplay	function
(	O
cur_only	int
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
}	O
void	O
ScrollH	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
n	int
,	O
bce	int
,	O
oml	pointer
)	O
int	O
y	int
,	O
xs	int
,	O
xe	int
,	O
n	int
,	O
bce	int
;	O
struct	O
mline	struct
*	O
oml	pointer
;	O
{	O
int	O
i	int
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
xe	int
!=	O
D_width	O
-	O
1	int
)	O
{	O
RefreshLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
GotoPos	function
(	O
xs	int
,	O
y	int
)	O
;	O
if	O
(	O
D_UT	O
)	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
if	O
(	O
D_BE	O
)	O
SetBackColor	function
(	O
bce	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
n	int
>=	O
xe	int
-	O
xs	int
+	O
1	int
)	O
n	int
=	O
xe	int
-	O
xs	int
+	O
1	int
;	O
if	O
(	O
D_CDC	O
&&	O
!	O
(	O
n	int
==	O
1	int
&&	O
D_DC	O
)	O
)	O
AddCStr2	function
(	O
D_CDC	O
,	O
n	int
)	O
;	O
else	O
if	O
(	O
D_DC	O
)	O
{	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
;	O
)	O
AddCStr	function
(	O
D_DC	O
)	O
;	O
}	O
else	O
{	O
RefreshLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
-	O
n	int
>=	O
xe	int
-	O
xs	int
+	O
1	int
)	O
n	int
=	O
-	O
(	O
xe	int
-	O
xs	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
D_insert	O
)	O
{	O
if	O
(	O
D_CIC	O
&&	O
!	O
(	O
n	int
==	O
-	O
1	int
&&	O
D_IC	O
)	O
)	O
AddCStr2	function
(	O
D_CIC	O
,	O
-	O
n	int
)	O
;	O
else	O
if	O
(	O
D_IC	O
)	O
{	O
for	O
(	O
i	int
=	O
-	O
n	int
;	O
i	int
--	O
;	O
)	O
AddCStr	function
(	O
D_IC	O
)	O
;	O
}	O
else	O
if	O
(	O
D_IM	O
)	O
{	O
InsertMode	function
(	O
1	int
)	O
;	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
SetBackColor	function
(	O
bce	int
)	O
;	O
for	O
(	O
i	int
=	O
-	O
n	int
;	O
i	int
--	O
;	O
)	O
INSERTCHAR	function
(	O
' '	O
)	O
;	O
bce	int
=	O
0	int
;	O
}	O
else	O
{	O
RefreshLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
SetBackColor	function
(	O
bce	int
)	O
;	O
for	O
(	O
i	int
=	O
-	O
n	int
;	O
i	int
--	O
;	O
)	O
INSERTCHAR	function
(	O
' '	O
)	O
;	O
bce	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
bce	int
&&	O
!	O
D_BE	O
)	O
{	O
if	O
(	O
n	int
>	O
0	int
)	O
ClearLine	function
(	O
(	O
struct	O
mline	struct
*	O
)	O
0	int
,	O
y	int
,	O
xe	int
-	O
n	int
+	O
1	int
,	O
xe	int
,	O
bce	int
)	O
;	O
else	O
ClearLine	function
(	O
(	O
struct	O
mline	struct
*	O
)	O
0	int
,	O
y	int
,	O
xs	int
,	O
xs	int
-	O
n	int
-	O
1	int
,	O
bce	int
)	O
;	O
}	O
if	O
(	O
D_lp_missing	O
&&	O
y	int
==	O
D_bot	O
)	O
{	O
if	O
(	O
n	int
>	O
0	int
)	O
WriteLP	function
(	O
D_width	O
-	O
1	int
-	O
n	int
,	O
y	int
)	O
;	O
D_lp_missing	O
=	O
0	int
;	O
}	O
}	O
void	O
ScrollV	function
(	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
n	int
,	O
bce	int
)	O
int	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
n	int
,	O
bce	int
;	O
{	O
int	O
i	int
;	O
int	O
up	int
;	O
int	O
oldbot	int
;	O
int	O
alok	int
,	O
dlok	int
,	O
aldlfaster	int
;	O
int	O
missy	int
=	O
0	int
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
n	int
>=	O
ye	int
-	O
ys	int
+	O
1	int
||	O
-	O
n	int
>=	O
ye	int
-	O
ys	int
+	O
1	int
)	O
{	O
ClearArea	function
(	O
xs	int
,	O
ys	int
,	O
xs	int
,	O
xe	int
,	O
xe	int
,	O
ye	int
,	O
bce	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
xs	int
>	O
D_vpxmin	O
||	O
xe	int
<	O
D_vpxmax	O
)	O
{	O
RefreshArea	function
(	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
D_lp_missing	O
)	O
{	O
if	O
(	O
D_bot	O
>	O
ye	int
||	O
D_bot	O
<	O
ys	int
)	O
missy	int
=	O
D_bot	O
;	O
else	O
{	O
missy	int
=	O
D_bot	O
-	O
n	int
;	O
if	O
(	O
missy	int
>	O
ye	int
||	O
missy	int
<	O
ys	int
)	O
D_lp_missing	O
=	O
0	int
;	O
}	O
}	O
up	int
=	O
1	int
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
up	int
=	O
0	int
;	O
n	int
=	O
-	O
n	int
;	O
}	O
if	O
(	O
n	int
>=	O
ye	int
-	O
ys	int
+	O
1	int
)	O
n	int
=	O
ye	int
-	O
ys	int
+	O
1	int
;	O
oldbot	int
=	O
D_bot	O
;	O
if	O
(	O
ys	int
<	O
D_top	O
||	O
D_bot	O
!=	O
ye	int
)	O
ChangeScrollRegion	function
(	O
ys	int
,	O
ye	int
)	O
;	O
alok	int
=	O
(	O
D_AL	O
||	O
D_CAL	O
||	O
(	O
ys	int
>=	O
D_top	O
&&	O
ye	int
==	O
D_bot	O
&&	O
up	int
)	O
)	O
;	O
dlok	int
=	O
(	O
D_DL	O
||	O
D_CDL	O
||	O
(	O
ys	int
>=	O
D_top	O
&&	O
ye	int
==	O
D_bot	O
&&	O
!	O
up	int
)	O
)	O
;	O
if	O
(	O
D_top	O
!=	O
ys	int
&&	O
!	O
(	O
alok	int
&&	O
dlok	int
)	O
)	O
ChangeScrollRegion	function
(	O
ys	int
,	O
ye	int
)	O
;	O
if	O
(	O
D_lp_missing	O
&&	O
(	O
oldbot	int
!=	O
D_bot	O
||	O
(	O
oldbot	int
==	O
D_bot	O
&&	O
up	int
&&	O
D_top	O
==	O
ys	int
&&	O
D_bot	O
==	O
ye	int
)	O
)	O
)	O
{	O
WriteLP	function
(	O
D_width	O
-	O
1	int
,	O
oldbot	int
)	O
;	O
if	O
(	O
oldbot	int
==	O
D_bot	O
)	O
{	O
if	O
(	O
--	O
n	int
==	O
0	int
)	O
{	O
if	O
(	O
bce	int
&&	O
!	O
D_BE	O
)	O
ClearLine	function
(	O
(	O
struct	O
mline	struct
*	O
)	O
0	int
,	O
ye	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
if	O
(	O
D_UT	O
)	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
if	O
(	O
D_BE	O
)	O
SetBackColor	function
(	O
bce	int
)	O
;	O
aldlfaster	int
=	O
(	O
n	int
>	O
1	int
&&	O
ys	int
>=	O
D_top	O
&&	O
ye	int
==	O
D_bot	O
&&	O
(	O
(	O
up	int
&&	O
D_CDL	O
)	O
||	O
(	O
!	O
up	int
&&	O
D_CAL	O
)	O
)	O
)	O
;	O
if	O
(	O
(	O
up	int
||	O
D_SR	O
)	O
&&	O
D_top	O
==	O
ys	int
&&	O
D_bot	O
==	O
ye	int
&&	O
!	O
aldlfaster	int
)	O
{	O
if	O
(	O
up	int
)	O
{	O
GotoPos	function
(	O
0	int
,	O
ye	int
)	O
;	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
>	O
0	int
;	O
)	O
AddCStr	function
(	O
D_NL	O
)	O
;	O
}	O
else	O
{	O
GotoPos	function
(	O
0	int
,	O
ys	int
)	O
;	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
>	O
0	int
;	O
)	O
AddCStr	function
(	O
D_SR	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
alok	int
&&	O
dlok	int
)	O
{	O
if	O
(	O
up	int
||	O
ye	int
!=	O
D_bot	O
)	O
{	O
GotoPos	function
(	O
0	int
,	O
up	int
?	O
ys	int
:	O
ye	int
+	O
1	int
-	O
n	int
)	O
;	O
if	O
(	O
D_CDL	O
&&	O
!	O
(	O
n	int
==	O
1	int
&&	O
D_DL	O
)	O
)	O
AddCStr2	function
(	O
D_CDL	O
,	O
n	int
)	O
;	O
else	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
;	O
)	O
AddCStr	function
(	O
D_DL	O
)	O
;	O
}	O
if	O
(	O
!	O
up	int
||	O
ye	int
!=	O
D_bot	O
)	O
{	O
GotoPos	function
(	O
0	int
,	O
up	int
?	O
ye	int
+	O
1	int
-	O
n	int
:	O
ys	int
)	O
;	O
if	O
(	O
D_CAL	O
&&	O
!	O
(	O
n	int
==	O
1	int
&&	O
D_AL	O
)	O
)	O
AddCStr2	function
(	O
D_CAL	O
,	O
n	int
)	O
;	O
else	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
--	O
;	O
)	O
AddCStr	function
(	O
D_AL	O
)	O
;	O
}	O
}	O
else	O
{	O
RefreshArea	function
(	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
bce	int
&&	O
!	O
D_BE	O
)	O
{	O
if	O
(	O
up	int
)	O
ClearArea	function
(	O
xs	int
,	O
ye	int
-	O
n	int
+	O
1	int
,	O
xs	int
,	O
xe	int
,	O
xe	int
,	O
ye	int
,	O
bce	int
,	O
0	int
)	O
;	O
else	O
ClearArea	function
(	O
xs	int
,	O
ys	int
,	O
xs	int
,	O
xe	int
,	O
xe	int
,	O
ys	int
+	O
n	int
-	O
1	int
,	O
bce	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
D_lp_missing	O
&&	O
missy	int
!=	O
D_bot	O
)	O
WriteLP	function
(	O
D_width	O
-	O
1	int
,	O
missy	int
)	O
;	O
}	O
void	O
SetAttr	function
(	O
new	int
)	O
register	O
int	O
new	int
;	O
{	O
register	O
int	O
i	int
,	O
j	int
,	O
old	int
,	O
typ	int
;	O
if	O
(	O
!	O
display	struct
||	O
(	O
old	int
=	O
D_rend	O
.	O
attr	char
)	O
==	O
new	int
)	O
return	O
;	O
D_col16change	O
=	O
(	O
old	int
^	O
new	int
)	O
&	O
(	O
A_BFG	O
|	O
A_BBG	O
)	O
;	O
new	int
^=	O
D_col16change	O
;	O
if	O
(	O
old	int
==	O
new	int
)	O
return	O
;	O
D_rend	O
.	O
attr	char
=	O
new	int
;	O
typ	int
=	O
D_atyp	O
;	O
if	O
(	O
(	O
new	int
&	O
old	int
)	O
!=	O
old	int
)	O
{	O
if	O
(	O
(	O
typ	int
&	O
ATYP_U	O
)	O
)	O
AddCStr	function
(	O
D_UE	O
)	O
;	O
if	O
(	O
(	O
typ	int
&	O
ATYP_S	O
)	O
)	O
AddCStr	function
(	O
D_SE	O
)	O
;	O
if	O
(	O
(	O
typ	int
&	O
ATYP_M	O
)	O
)	O
{	O
AddCStr	function
(	O
D_ME	O
)	O
;	O
if	O
(	O
D_hascolor	O
)	O
rend_setdefault	O
(	O
&	O
D_rend	O
)	O
;	O
if	O
(	O
!	O
D_CG0	O
)	O
{	O
D_rend	O
.	O
font	char
=	O
0	int
;	O
D_realfont	O
=	O
0	int
;	O
}	O
}	O
old	int
=	O
0	int
;	O
typ	int
=	O
0	int
;	O
}	O
old	int
^=	O
new	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
1	int
;	O
old	int
&&	O
i	int
<	O
NATTR	int
;	O
i	int
++	O
,	O
j	int
<<=	O
1	int
)	O
{	O
if	O
(	O
(	O
old	int
&	O
j	int
)	O
==	O
0	int
)	O
continue	O
;	O
old	int
^=	O
j	int
;	O
if	O
(	O
D_attrtab	O
[	O
i	int
]	O
)	O
{	O
AddCStr	function
(	O
D_attrtab	O
[	O
i	int
]	O
)	O
;	O
typ	int
|=	O
D_attrtyp	O
[	O
i	int
]	O
;	O
}	O
}	O
D_atyp	O
=	O
typ	int
;	O
}	O
void	O
SetFont	function
(	O
new	int
)	O
int	O
new	int
;	O
{	O
int	O
old	int
=	O
D_rend	O
.	O
font	char
;	O
if	O
(	O
!	O
display	struct
||	O
old	int
==	O
new	int
)	O
return	O
;	O
D_rend	O
.	O
font	char
=	O
new	int
;	O
if	O
(	O
D_encoding	O
&&	O
CanEncodeFont	function
(	O
D_encoding	O
,	O
new	int
)	O
)	O
return	O
;	O
if	O
(	O
new	int
==	O
D_realfont	O
)	O
return	O
;	O
D_realfont	O
=	O
new	int
;	O
if	O
(	O
D_xtable	O
&&	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
new	int
]	O
&&	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
new	int
]	O
[	O
256	int
]	O
)	O
{	O
AddCStr	function
(	O
D_xtable	O
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
new	int
]	O
[	O
256	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
D_CG0	O
&&	O
new	int
!=	O
'0'	O
)	O
{	O
new	int
=	O
ASCII	int
;	O
if	O
(	O
old	int
==	O
new	int
)	O
return	O
;	O
}	O
if	O
(	O
new	int
==	O
ASCII	int
)	O
AddCStr	function
(	O
D_CE0	O
)	O
;	O
else	O
if	O
(	O
new	int
<	O
' '	O
)	O
{	O
AddStr	function
(	O
"\033$"	pointer
)	O
;	O
if	O
(	O
new	int
>	O
2	int
)	O
AddChar	O
(	O
'('	O
)	O
;	O
AddChar	O
(	O
new	int
+	O
'@'	O
)	O
;	O
}	O
else	O
AddCStr2	function
(	O
D_CS0	O
,	O
new	int
)	O
;	O
}	O
int	O
color256to16	function
(	O
jj	int
)	O
int	O
jj	int
;	O
{	O
int	O
min	int
,	O
max	int
;	O
int	O
r	int
,	O
g	int
,	O
b	pointer
;	O
if	O
(	O
jj	int
>=	O
232	int
)	O
{	O
jj	int
=	O
(	O
jj	int
-	O
232	int
)	O
/	O
6	int
;	O
jj	int
=	O
(	O
jj	int
&	O
1	int
)	O
<<	O
3	int
|	O
(	O
jj	int
&	O
2	int
?	O
7	int
:	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
jj	int
>=	O
16	int
)	O
{	O
jj	int
-=	O
16	int
;	O
r	int
=	O
jj	int
/	O
36	int
;	O
g	int
=	O
(	O
jj	int
/	O
6	int
)	O
%	O
6	int
;	O
b	pointer
=	O
jj	int
%	O
6	int
;	O
min	int
=	O
r	int
<	O
g	int
?	O
(	O
r	int
<	O
b	pointer
?	O
r	int
:	O
b	pointer
)	O
:	O
(	O
g	int
<	O
b	pointer
?	O
g	int
:	O
b	pointer
)	O
;	O
max	int
=	O
r	int
>	O
g	int
?	O
(	O
r	int
>	O
b	pointer
?	O
r	int
:	O
b	pointer
)	O
:	O
(	O
g	int
>	O
b	pointer
?	O
g	int
:	O
b	pointer
)	O
;	O
if	O
(	O
min	int
==	O
max	int
)	O
jj	int
=	O
(	O
(	O
max	int
+	O
1	int
)	O
&	O
2	int
)	O
<<	O
2	int
|	O
(	O
(	O
max	int
+	O
1	int
)	O
&	O
4	int
?	O
7	int
:	O
0	int
)	O
;	O
else	O
jj	int
=	O
(	O
b	pointer
-	O
min	int
)	O
/	O
(	O
max	int
-	O
min	int
)	O
<<	O
2	int
|	O
(	O
g	int
-	O
min	int
)	O
/	O
(	O
max	int
-	O
min	int
)	O
<<	O
1	int
|	O
(	O
r	int
-	O
min	int
)	O
/	O
(	O
max	int
-	O
min	int
)	O
|	O
(	O
max	int
>	O
3	int
?	O
8	int
:	O
0	int
)	O
;	O
}	O
return	O
jj	int
;	O
}	O
void	O
SetColor	function
(	O
f	int
,	O
b	pointer
)	O
int	O
f	int
,	O
b	pointer
;	O
{	O
int	O
of	int
,	O
ob	int
;	O
static	O
unsigned	O
char	O
sftrans	array
[	O
8	int
]	O
=	O
{	O
0	int
,	O
4	int
,	O
2	int
,	O
6	int
,	O
1	int
,	O
5	int
,	O
3	int
,	O
7	int
}	O
;	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
of	int
=	O
rend_getfg	O
(	O
&	O
D_rend	O
)	O
;	O
ob	int
=	O
rend_getbg	O
(	O
&	O
D_rend	O
)	O
;	O
if	O
(	O
f	int
==	O
0x100	int
)	O
f	int
=	O
0	int
;	O
if	O
(	O
b	pointer
==	O
0x100	int
)	O
b	pointer
=	O
0	int
;	O
debug2	O
(	O
"SetColor %d %d"	pointer
,	O
coli2e	O
(	O
of	int
)	O
,	O
coli2e	O
(	O
ob	int
)	O
)	O
;	O
debug2	O
(	O
" -> %d %d\n"	pointer
,	O
coli2e	O
(	O
f	int
)	O
,	O
coli2e	O
(	O
b	pointer
)	O
)	O
;	O
debug2	O
(	O
"(%d %d"	pointer
,	O
of	int
,	O
ob	int
)	O
;	O
debug2	O
(	O
" -> %d %d)\n"	pointer
,	O
f	int
,	O
b	pointer
)	O
;	O
if	O
(	O
!	O
D_CAX	O
&&	O
D_hascolor	O
&&	O
(	O
(	O
f	int
==	O
0	int
&&	O
f	int
!=	O
of	int
)	O
||	O
(	O
b	pointer
==	O
0	int
&&	O
b	pointer
!=	O
ob	int
)	O
)	O
)	O
{	O
if	O
(	O
D_OP	O
)	O
AddCStr	function
(	O
D_OP	O
)	O
;	O
else	O
{	O
int	O
oattr	int
;	O
oattr	int
=	O
D_rend	O
.	O
attr	char
;	O
AddCStr	function
(	O
D_ME	O
?	O
D_ME	O
:	O
"\033[m"	pointer
)	O
;	O
if	O
(	O
D_ME	O
&&	O
!	O
D_CG0	O
)	O
{	O
D_rend	O
.	O
font	char
=	O
0	int
;	O
D_realfont	O
=	O
0	int
;	O
}	O
D_atyp	O
=	O
0	int
;	O
D_rend	O
.	O
attr	char
=	O
0	int
;	O
SetAttr	function
(	O
oattr	int
)	O
;	O
}	O
of	int
=	O
ob	int
=	O
0	int
;	O
}	O
rend_setfg	O
(	O
&	O
D_rend	O
,	O
f	int
)	O
;	O
rend_setbg	O
(	O
&	O
D_rend	O
,	O
b	pointer
)	O
;	O
D_col16change	O
=	O
0	int
;	O
if	O
(	O
!	O
D_hascolor	O
)	O
return	O
;	O
f	int
=	O
f	int
?	O
coli2e	O
(	O
f	int
)	O
:	O
-	O
1	int
;	O
b	pointer
=	O
b	pointer
?	O
coli2e	O
(	O
b	pointer
)	O
:	O
-	O
1	int
;	O
of	int
=	O
of	int
?	O
coli2e	O
(	O
of	int
)	O
:	O
-	O
1	int
;	O
ob	int
=	O
ob	int
?	O
coli2e	O
(	O
ob	int
)	O
:	O
-	O
1	int
;	O
if	O
(	O
f	int
!=	O
of	int
&&	O
f	int
!=	O
(	O
of	int
|	O
8	int
)	O
)	O
{	O
if	O
(	O
f	int
==	O
-	O
1	int
)	O
AddCStr	function
(	O
"\033[39m"	pointer
)	O
;	O
else	O
if	O
(	O
D_CAF	O
)	O
AddCStr2	function
(	O
D_CAF	O
,	O
f	int
&	O
7	int
)	O
;	O
else	O
if	O
(	O
D_CSF	O
)	O
AddCStr2	function
(	O
D_CSF	O
,	O
sftrans	array
[	O
f	int
&	O
7	int
]	O
)	O
;	O
}	O
if	O
(	O
b	pointer
!=	O
ob	int
&&	O
b	pointer
!=	O
(	O
ob	int
|	O
8	int
)	O
)	O
{	O
if	O
(	O
b	pointer
==	O
-	O
1	int
)	O
AddCStr	function
(	O
"\033[49m"	pointer
)	O
;	O
else	O
if	O
(	O
D_CAB	O
)	O
AddCStr2	function
(	O
D_CAB	O
,	O
b	pointer
&	O
7	int
)	O
;	O
else	O
if	O
(	O
D_CSB	O
)	O
AddCStr2	function
(	O
D_CSB	O
,	O
sftrans	array
[	O
b	pointer
&	O
7	int
]	O
)	O
;	O
}	O
if	O
(	O
f	int
!=	O
of	int
&&	O
D_CXT	O
&&	O
(	O
f	int
&	O
8	int
)	O
!=	O
0	int
&&	O
f	int
!=	O
-	O
1	int
)	O
{	O
AddCStr2	function
(	O
"\033[9%p1%dm"	pointer
,	O
f	int
&	O
7	int
)	O
;	O
}	O
if	O
(	O
b	pointer
!=	O
ob	int
&&	O
D_CXT	O
&&	O
(	O
b	pointer
&	O
8	int
)	O
!=	O
0	int
&&	O
b	pointer
!=	O
-	O
1	int
)	O
{	O
AddCStr2	function
(	O
"\033[10%p1%dm"	pointer
,	O
b	pointer
&	O
7	int
)	O
;	O
}	O
}	O
static	O
void	O
SetBackColor	function
(	O
new	int
)	O
int	O
new	int
;	O
{	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
SetColor	function
(	O
rend_getfg	O
(	O
&	O
D_rend	O
)	O
,	O
new	int
)	O
;	O
}	O
void	O
SetRendition	function
(	O
mc	pointer
)	O
struct	O
mchar	struct
*	O
mc	pointer
;	O
{	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
if	O
(	O
nattr2color	int
&&	O
D_hascolor	O
&&	O
(	O
mc	pointer
->	O
attr	char
&	O
nattr2color	int
)	O
!=	O
0	int
)	O
{	O
static	O
struct	O
mchar	struct
mmc	struct
;	O
int	O
i	int
;	O
mmc	struct
=	O
*	O
mc	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
if	O
(	O
attr2color	array
[	O
i	int
]	O
&&	O
(	O
mc	pointer
->	O
attr	char
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
mc	pointer
->	O
color	char
==	O
0	int
&&	O
attr2color	array
[	O
i	int
]	O
[	O
3	int
]	O
)	O
ApplyAttrColor	function
(	O
attr2color	array
[	O
i	int
]	O
[	O
3	int
]	O
,	O
&	O
mmc	struct
)	O
;	O
else	O
if	O
(	O
(	O
mc	pointer
->	O
color	char
&	O
0x0f	int
)	O
==	O
0	int
&&	O
attr2color	array
[	O
i	int
]	O
[	O
2	int
]	O
)	O
ApplyAttrColor	function
(	O
attr2color	array
[	O
i	int
]	O
[	O
2	int
]	O
,	O
&	O
mmc	struct
)	O
;	O
else	O
if	O
(	O
(	O
mc	pointer
->	O
color	char
&	O
0xf0	int
)	O
==	O
0	int
&&	O
attr2color	array
[	O
i	int
]	O
[	O
1	int
]	O
)	O
ApplyAttrColor	function
(	O
attr2color	array
[	O
i	int
]	O
[	O
1	int
]	O
,	O
&	O
mmc	struct
)	O
;	O
else	O
ApplyAttrColor	function
(	O
attr2color	array
[	O
i	int
]	O
[	O
0	int
]	O
,	O
&	O
mmc	struct
)	O
;	O
}	O
mc	pointer
=	O
&	O
mmc	struct
;	O
debug2	O
(	O
"SetRendition: mapped to %02x %02x\n"	pointer
,	O
(	O
unsigned	O
char	O
)	O
mc	pointer
->	O
attr	char
,	O
0x99	int
-	O
(	O
unsigned	O
char	O
)	O
mc	pointer
->	O
color	char
)	O
;	O
}	O
if	O
(	O
D_hascolor	O
&&	O
D_CC8	O
&&	O
(	O
mc	pointer
->	O
attr	char
&	O
(	O
A_BFG	O
|	O
A_BBG	O
)	O
)	O
)	O
{	O
int	O
a	int
=	O
mc	pointer
->	O
attr	char
;	O
if	O
(	O
(	O
mc	pointer
->	O
attr	char
&	O
A_BFG	O
)	O
&&	O
D_MD	O
)	O
a	int
|=	O
A_BD	O
;	O
if	O
(	O
(	O
mc	pointer
->	O
attr	char
&	O
A_BBG	O
)	O
&&	O
D_MB	O
)	O
a	int
|=	O
A_BL	O
;	O
if	O
(	O
D_rend	O
.	O
attr	char
!=	O
a	int
)	O
SetAttr	function
(	O
a	int
)	O
;	O
}	O
else	O
if	O
(	O
D_rend	O
.	O
attr	char
!=	O
mc	pointer
->	O
attr	char
)	O
SetAttr	function
(	O
mc	pointer
->	O
attr	char
)	O
;	O
if	O
(	O
D_rend	O
.	O
color	char
!=	O
mc	pointer
->	O
color	char
||	O
D_col16change	O
)	O
SetColor	function
(	O
rend_getfg	O
(	O
mc	pointer
)	O
,	O
rend_getbg	O
(	O
mc	pointer
)	O
)	O
;	O
if	O
(	O
D_rend	O
.	O
font	char
!=	O
mc	pointer
->	O
font	char
)	O
SetFont	function
(	O
mc	pointer
->	O
font	char
)	O
;	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
D_rend	O
.	O
fontx	char
=	O
mc	pointer
->	O
fontx	char
;	O
}	O
void	O
SetRenditionMline	function
(	O
ml	pointer
,	O
x	int
)	O
struct	O
mline	struct
*	O
ml	pointer
;	O
int	O
x	int
;	O
{	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
if	O
(	O
nattr2color	int
&&	O
D_hascolor	O
&&	O
(	O
ml	pointer
->	O
attr	char
[	O
x	int
]	O
&	O
nattr2color	int
)	O
!=	O
0	int
)	O
{	O
struct	O
mchar	struct
mc	pointer
;	O
copy_mline2mchar	O
(	O
&	O
mc	pointer
,	O
ml	pointer
,	O
x	int
)	O
;	O
SetRendition	function
(	O
&	O
mc	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
D_hascolor	O
&&	O
D_CC8	O
&&	O
(	O
ml	pointer
->	O
attr	char
[	O
x	int
]	O
&	O
(	O
A_BFG	O
|	O
A_BBG	O
)	O
)	O
)	O
{	O
int	O
a	int
=	O
ml	pointer
->	O
attr	char
[	O
x	int
]	O
;	O
if	O
(	O
(	O
ml	pointer
->	O
attr	char
[	O
x	int
]	O
&	O
A_BFG	O
)	O
&&	O
D_MD	O
)	O
a	int
|=	O
A_BD	O
;	O
if	O
(	O
(	O
ml	pointer
->	O
attr	char
[	O
x	int
]	O
&	O
A_BBG	O
)	O
&&	O
D_MB	O
)	O
a	int
|=	O
A_BL	O
;	O
if	O
(	O
D_rend	O
.	O
attr	char
!=	O
a	int
)	O
SetAttr	function
(	O
a	int
)	O
;	O
}	O
else	O
if	O
(	O
D_rend	O
.	O
attr	char
!=	O
ml	pointer
->	O
attr	char
[	O
x	int
]	O
)	O
SetAttr	function
(	O
ml	pointer
->	O
attr	char
[	O
x	int
]	O
)	O
;	O
if	O
(	O
D_rend	O
.	O
color	char
!=	O
ml	pointer
->	O
color	char
[	O
x	int
]	O
||	O
D_col16change	O
)	O
{	O
struct	O
mchar	struct
mc	pointer
;	O
copy_mline2mchar	O
(	O
&	O
mc	pointer
,	O
ml	pointer
,	O
x	int
)	O
;	O
SetColor	function
(	O
rend_getfg	O
(	O
&	O
mc	pointer
)	O
,	O
rend_getbg	O
(	O
&	O
mc	pointer
)	O
)	O
;	O
}	O
if	O
(	O
D_rend	O
.	O
font	char
!=	O
ml	pointer
->	O
font	char
[	O
x	int
]	O
)	O
SetFont	function
(	O
ml	pointer
->	O
font	char
[	O
x	int
]	O
)	O
;	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
D_rend	O
.	O
fontx	char
=	O
ml	pointer
->	O
fontx	char
[	O
x	int
]	O
;	O
}	O
void	O
MakeStatus	function
(	O
msg	struct
)	O
char	O
*	O
msg	struct
;	O
{	O
register	O
char	O
*	O
s	pointer
,	O
*	O
t	int
;	O
register	O
int	O
max	int
;	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
if	O
(	O
D_blocked	O
)	O
return	O
;	O
if	O
(	O
!	O
D_tcinited	O
)	O
{	O
debug	O
(	O
"tc not inited, just writing msg\n"	pointer
)	O
;	O
if	O
(	O
D_processinputdata	O
)	O
return	O
;	O
AddStr	function
(	O
msg	struct
)	O
;	O
AddStr	function
(	O
"\r\n"	pointer
)	O
;	O
Flush	function
(	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
use_hardstatus	int
||	O
!	O
D_HS	O
)	O
{	O
max	int
=	O
D_width	O
;	O
if	O
(	O
D_CLP	O
==	O
0	int
)	O
max	int
--	O
;	O
}	O
else	O
max	int
=	O
D_WS	O
>	O
0	int
?	O
D_WS	O
:	O
(	O
D_width	O
-	O
!	O
D_CLP	O
)	O
;	O
if	O
(	O
D_status	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
msg	struct
,	O
D_status_lastmsg	O
)	O
==	O
0	int
)	O
{	O
debug	O
(	O
"same message - increase timeout"	pointer
)	O
;	O
if	O
(	O
!	O
D_status_obufpos	O
)	O
SetTimeout	function
(	O
&	O
D_statusev	O
,	O
MsgWait	int
)	O
;	O
return	O
;	O
}	O
RemoveStatusMinWait	function
(	O
)	O
;	O
}	O
for	O
(	O
s	pointer
=	O
t	int
=	O
msg	struct
;	O
*	O
s	pointer
&&	O
t	int
-	O
msg	struct
<	O
max	int
;	O
++	O
s	pointer
)	O
if	O
(	O
*	O
s	pointer
==	O
BELL	O
)	O
AddCStr	function
(	O
D_BL	O
)	O
;	O
else	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
>=	O
' '	O
&&	O
*	O
s	pointer
!=	O
0177	int
)	O
*	O
t	int
++	O
=	O
*	O
s	pointer
;	O
*	O
t	int
=	O
'\0'	O
;	O
if	O
(	O
t	int
==	O
msg	struct
)	O
return	O
;	O
if	O
(	O
t	int
-	O
msg	struct
>=	O
D_status_buflen	O
)	O
{	O
char	O
*	O
buf	pointer
;	O
if	O
(	O
D_status_lastmsg	O
)	O
buf	pointer
=	O
realloc	function
(	O
D_status_lastmsg	O
,	O
t	int
-	O
msg	struct
+	O
1	int
)	O
;	O
else	O
buf	pointer
=	O
malloc	function
(	O
t	int
-	O
msg	struct
+	O
1	int
)	O
;	O
if	O
(	O
buf	pointer
)	O
{	O
D_status_lastmsg	O
=	O
buf	pointer
;	O
D_status_buflen	O
=	O
t	int
-	O
msg	struct
+	O
1	int
;	O
}	O
}	O
if	O
(	O
t	int
-	O
msg	struct
<	O
D_status_buflen	O
)	O
strcpy	function
(	O
D_status_lastmsg	O
,	O
msg	struct
)	O
;	O
D_status_len	O
=	O
t	int
-	O
msg	struct
;	O
D_status_lastx	O
=	O
D_x	O
;	O
D_status_lasty	O
=	O
D_y	O
;	O
if	O
(	O
!	O
use_hardstatus	int
||	O
D_has_hstatus	O
==	O
HSTATUS_IGNORE	int
||	O
D_has_hstatus	O
==	O
HSTATUS_MESSAGE	int
)	O
{	O
D_status	O
=	O
STATUS_ON_WIN	int
;	O
debug1	O
(	O
"using STATLINE %d\n"	pointer
,	O
STATLINE	O
)	O
;	O
GotoPos	function
(	O
0	int
,	O
STATLINE	O
)	O
;	O
SetRendition	function
(	O
&	O
mchar_so	struct
)	O
;	O
InsertMode	function
(	O
0	int
)	O
;	O
AddStr	function
(	O
msg	struct
)	O
;	O
if	O
(	O
D_status_len	O
<	O
max	int
)	O
{	O
D_status_len	O
++	O
;	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
AddChar	O
(	O
' '	O
)	O
;	O
if	O
(	O
D_status_len	O
<	O
max	int
)	O
{	O
D_status_len	O
++	O
;	O
AddChar	O
(	O
' '	O
)	O
;	O
AddChar	O
(	O
'\b'	O
)	O
;	O
}	O
AddChar	O
(	O
'\b'	O
)	O
;	O
}	O
D_x	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
D_status	O
=	O
STATUS_ON_HS	int
;	O
ShowHStatus	function
(	O
msg	struct
)	O
;	O
}	O
D_status_obufpos	O
=	O
D_obufp	O
-	O
D_obuf	O
;	O
ASSERT	O
(	O
D_status_obufpos	O
>	O
0	int
)	O
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
)	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
struct	O
layer	struct
*	O
oldflayer	pointer
=	O
flayer	pointer
;	O
D_status	O
=	O
0	int
;	O
GotoPos	function
(	O
0	int
,	O
STATLINE	O
)	O
;	O
RefreshLine	function
(	O
STATLINE	O
,	O
0	int
,	O
D_status_len	O
-	O
1	int
,	O
0	int
)	O
;	O
GotoPos	function
(	O
D_status_lastx	O
,	O
D_status_lasty	O
)	O
;	O
flayer	pointer
=	O
D_forecv	O
?	O
D_forecv	O
->	O
c_layer	pointer
:	O
0	int
;	O
if	O
(	O
flayer	pointer
)	O
LaySetCursor	O
(	O
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
D_status	O
=	O
STATUS_ON_WIN	int
;	O
}	O
}	O
void	O
RemoveStatus	function
(	O
)	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
;	O
struct	O
layer	struct
*	O
oldflayer	pointer
;	O
int	O
where	int
;	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
if	O
(	O
!	O
(	O
where	int
=	O
D_status	O
)	O
)	O
return	O
;	O
debug	O
(	O
"RemoveStatus\n"	pointer
)	O
;	O
if	O
(	O
D_status_obuffree	O
>=	O
0	int
)	O
{	O
D_obuflen	O
=	O
D_status_obuflen	O
;	O
D_obuffree	O
=	O
D_status_obuffree	O
;	O
D_status_obuffree	O
=	O
-	O
1	int
;	O
}	O
D_status	O
=	O
0	int
;	O
D_status_obufpos	O
=	O
0	int
;	O
D_status_bell	O
=	O
0	int
;	O
evdeq	function
(	O
&	O
D_statusev	O
)	O
;	O
olddisplay	pointer
=	O
display	struct
;	O
oldflayer	pointer
=	O
flayer	pointer
;	O
if	O
(	O
where	int
==	O
STATUS_ON_WIN	int
)	O
{	O
if	O
(	O
captionalways	int
||	O
(	O
D_canvas	O
.	O
c_slperp	pointer
&&	O
D_canvas	O
.	O
c_slperp	pointer
->	O
c_slnext	pointer
)	O
)	O
{	O
GotoPos	function
(	O
0	int
,	O
STATLINE	O
)	O
;	O
RefreshLine	function
(	O
STATLINE	O
,	O
0	int
,	O
D_status_len	O
-	O
1	int
,	O
0	int
)	O
;	O
GotoPos	function
(	O
D_status_lastx	O
,	O
D_status_lasty	O
)	O
;	O
}	O
}	O
else	O
RefreshHStatus	function
(	O
)	O
;	O
flayer	pointer
=	O
D_forecv	O
?	O
D_forecv	O
->	O
c_layer	pointer
:	O
0	int
;	O
if	O
(	O
flayer	pointer
)	O
LaySetCursor	O
(	O
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
}	O
static	O
void	O
RemoveStatusMinWait	function
(	O
)	O
{	O
if	O
(	O
!	O
D_status_bell	O
&&	O
!	O
D_status_obufpos	O
)	O
{	O
struct	O
timeval	struct
now	struct
;	O
int	O
ti	int
;	O
gettimeofday	function
(	O
&	O
now	struct
,	O
NULL	O
)	O
;	O
ti	int
=	O
(	O
now	struct
.	O
tv_sec	long
-	O
D_status_time	O
.	O
tv_sec	long
)	O
*	O
1000	int
+	O
(	O
now	struct
.	O
tv_usec	long
-	O
D_status_time	O
.	O
tv_usec	long
)	O
/	O
1000	int
;	O
if	O
(	O
ti	int
<	O
MsgMinWait	int
)	O
DisplaySleep1000	function
(	O
MsgMinWait	int
-	O
ti	int
,	O
0	int
)	O
;	O
}	O
RemoveStatus	function
(	O
)	O
;	O
}	O
static	O
int	O
strlen_onscreen	function
(	O
unsigned	O
char	O
*	O
c	int
,	O
unsigned	O
char	O
*	O
end	pointer
)	O
{	O
int	O
len	int
=	O
0	int
;	O
while	O
(	O
*	O
c	int
&&	O
(	O
!	O
end	pointer
||	O
c	int
<	O
end	pointer
)	O
)	O
{	O
int	O
v	int
,	O
dec	int
=	O
0	int
;	O
do	O
{	O
v	int
=	O
FromUtf8	function
(	O
*	O
c	int
++	O
,	O
&	O
dec	int
)	O
;	O
if	O
(	O
v	int
==	O
-	O
2	int
)	O
c	int
--	O
;	O
}	O
while	O
(	O
v	int
<	O
0	int
&&	O
(	O
!	O
end	pointer
||	O
c	int
<	O
end	pointer
)	O
)	O
;	O
if	O
(	O
!	O
utf8_iscomb	function
(	O
v	int
)	O
)	O
{	O
if	O
(	O
utf8_isdouble	function
(	O
v	int
)	O
)	O
len	int
++	O
;	O
len	int
++	O
;	O
}	O
}	O
return	O
len	int
;	O
}	O
static	O
int	O
PrePutWinMsg	function
(	O
s	pointer
,	O
start	int
,	O
max	int
)	O
char	O
*	O
s	pointer
;	O
int	O
start	int
,	O
max	int
;	O
{	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
{	O
int	O
chars	int
=	O
strlen_onscreen	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
s	pointer
+	O
start	int
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
s	pointer
+	O
max	int
)	O
)	O
;	O
D_encoding	O
=	O
0	int
;	O
PutWinMsg	function
(	O
s	pointer
,	O
start	int
,	O
max	int
+	O
(	O
(	O
max	int
-	O
start	int
)	O
-	O
chars	int
)	O
)	O
;	O
D_encoding	O
=	O
UTF8	int
;	O
D_x	O
-=	O
(	O
max	int
-	O
chars	int
)	O
;	O
return	O
start	int
+	O
chars	int
;	O
}	O
else	O
{	O
PutWinMsg	function
(	O
s	pointer
,	O
start	int
,	O
max	int
)	O
;	O
return	O
max	int
;	O
}	O
}	O
void	O
ShowHStatus	function
(	O
str	pointer
)	O
char	O
*	O
str	pointer
;	O
{	O
int	O
l	pointer
,	O
ox	int
,	O
oy	int
,	O
max	int
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
&&	O
D_has_hstatus	O
==	O
HSTATUS_LASTLINE	int
&&	O
STATLINE	O
==	O
D_height	O
-	O
1	int
)	O
return	O
;	O
if	O
(	O
D_blocked	O
)	O
return	O
;	O
if	O
(	O
D_HS	O
&&	O
D_has_hstatus	O
==	O
HSTATUS_HS	int
)	O
{	O
if	O
(	O
!	O
D_hstatus	O
&&	O
(	O
str	pointer
==	O
0	int
||	O
*	O
str	pointer
==	O
0	int
)	O
)	O
return	O
;	O
debug	O
(	O
"ShowHStatus: using HS\n"	pointer
)	O
;	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
InsertMode	function
(	O
0	int
)	O
;	O
if	O
(	O
D_hstatus	O
)	O
AddCStr	function
(	O
D_DS	O
)	O
;	O
D_hstatus	O
=	O
0	int
;	O
if	O
(	O
str	pointer
==	O
0	int
||	O
*	O
str	pointer
==	O
0	int
)	O
return	O
;	O
AddCStr2	function
(	O
D_TS	O
,	O
0	int
)	O
;	O
max	int
=	O
D_WS	O
>	O
0	int
?	O
D_WS	O
:	O
(	O
D_width	O
-	O
!	O
D_CLP	O
)	O
;	O
if	O
(	O
(	O
int	O
)	O
strlen	function
(	O
str	pointer
)	O
>	O
max	int
)	O
AddStrn	function
(	O
str	pointer
,	O
max	int
)	O
;	O
else	O
AddStr	function
(	O
str	pointer
)	O
;	O
AddCStr	function
(	O
D_FS	O
)	O
;	O
D_hstatus	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
D_has_hstatus	O
==	O
HSTATUS_LASTLINE	int
)	O
{	O
debug	O
(	O
"ShowHStatus: using last line\n"	pointer
)	O
;	O
ox	int
=	O
D_x	O
;	O
oy	int
=	O
D_y	O
;	O
str	pointer
=	O
str	pointer
?	O
str	pointer
:	O
""	pointer
;	O
l	pointer
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
l	pointer
>	O
D_width	O
)	O
l	pointer
=	O
D_width	O
;	O
GotoPos	function
(	O
0	int
,	O
D_height	O
-	O
1	int
)	O
;	O
SetRendition	function
(	O
captionalways	int
||	O
D_cvlist	O
==	O
0	int
||	O
D_cvlist	O
->	O
c_next	pointer
?	O
&	O
mchar_null	struct
:	O
&	O
mchar_so	struct
)	O
;	O
l	pointer
=	O
PrePutWinMsg	function
(	O
str	pointer
,	O
0	int
,	O
l	pointer
)	O
;	O
if	O
(	O
!	O
captionalways	int
&&	O
D_cvlist	O
&&	O
!	O
D_cvlist	O
->	O
c_next	pointer
)	O
while	O
(	O
l	pointer
++	O
<	O
D_width	O
)	O
PUTCHARLP	function
(	O
' '	O
)	O
;	O
if	O
(	O
l	pointer
<	O
D_width	O
)	O
ClearArea	function
(	O
l	pointer
,	O
D_height	O
-	O
1	int
,	O
l	pointer
,	O
D_width	O
-	O
1	int
,	O
D_width	O
-	O
1	int
,	O
D_height	O
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
ox	int
!=	O
-	O
1	int
&&	O
oy	int
!=	O
-	O
1	int
)	O
GotoPos	function
(	O
ox	int
,	O
oy	int
)	O
;	O
D_hstatus	O
=	O
*	O
str	pointer
?	O
1	int
:	O
0	int
;	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
}	O
else	O
if	O
(	O
D_has_hstatus	O
==	O
HSTATUS_FIRSTLINE	int
)	O
{	O
debug	O
(	O
"ShowHStatus: using first line\n"	pointer
)	O
;	O
ox	int
=	O
D_x	O
;	O
oy	int
=	O
D_y	O
;	O
str	pointer
=	O
str	pointer
?	O
str	pointer
:	O
""	pointer
;	O
l	pointer
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
l	pointer
>	O
D_width	O
)	O
l	pointer
=	O
D_width	O
;	O
GotoPos	function
(	O
0	int
,	O
0	int
)	O
;	O
SetRendition	function
(	O
captionalways	int
||	O
D_cvlist	O
==	O
0	int
||	O
D_cvlist	O
->	O
c_next	pointer
?	O
&	O
mchar_null	struct
:	O
&	O
mchar_so	struct
)	O
;	O
l	pointer
=	O
PrePutWinMsg	function
(	O
str	pointer
,	O
0	int
,	O
l	pointer
)	O
;	O
if	O
(	O
!	O
captionalways	int
||	O
(	O
D_cvlist	O
&&	O
!	O
D_cvlist	O
->	O
c_next	pointer
)	O
)	O
while	O
(	O
l	pointer
++	O
<	O
D_width	O
)	O
PUTCHARLP	function
(	O
' '	O
)	O
;	O
if	O
(	O
l	pointer
<	O
D_width	O
)	O
ClearArea	function
(	O
l	pointer
,	O
0	int
,	O
l	pointer
,	O
D_width	O
-	O
1	int
,	O
D_width	O
-	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
ox	int
!=	O
-	O
1	int
&&	O
oy	int
!=	O
-	O
1	int
)	O
GotoPos	function
(	O
ox	int
,	O
oy	int
)	O
;	O
D_hstatus	O
=	O
*	O
str	pointer
?	O
1	int
:	O
0	int
;	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
}	O
else	O
if	O
(	O
str	pointer
&&	O
*	O
str	pointer
&&	O
D_has_hstatus	O
==	O
HSTATUS_MESSAGE	int
)	O
{	O
debug	O
(	O
"ShowHStatus: using message\n"	pointer
)	O
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
str	pointer
)	O
;	O
}	O
}	O
void	O
RefreshHStatus	function
(	O
)	O
{	O
char	O
*	O
buf	pointer
;	O
int	O
extrabytes	int
=	O
strlen	function
(	O
hstatusstring	pointer
)	O
-	O
strlen_onscreen	function
(	O
hstatusstring	pointer
,	O
NULL	O
)	O
;	O
evdeq	function
(	O
&	O
D_hstatusev	O
)	O
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_HS	int
)	O
return	O
;	O
buf	pointer
=	O
MakeWinMsgEv	function
(	O
hstatusstring	pointer
,	O
D_fore	O
,	O
'%'	O
,	O
(	O
D_HS	O
&&	O
D_has_hstatus	O
==	O
HSTATUS_HS	int
&&	O
D_WS	O
>	O
0	int
)	O
?	O
D_WS	O
:	O
D_width	O
-	O
!	O
D_CLP	O
+	O
extrabytes	int
,	O
&	O
D_hstatusev	O
,	O
0	int
)	O
;	O
if	O
(	O
buf	pointer
&&	O
*	O
buf	pointer
)	O
{	O
ShowHStatus	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
D_has_hstatus	O
!=	O
HSTATUS_IGNORE	int
&&	O
D_hstatusev	O
.	O
timeout	struct
.	O
tv_sec	long
)	O
evenq	function
(	O
&	O
D_hstatusev	O
)	O
;	O
}	O
else	O
ShowHStatus	function
(	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
void	O
RefreshAll	function
(	O
isblank	int
)	O
int	O
isblank	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
debug	O
(	O
"Signalling full refresh!\n"	pointer
)	O
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
CV_CALL	O
(	O
cv	pointer
,	O
LayRedisplayLine	O
(	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
isblank	int
)	O
)	O
;	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
}	O
RefreshArea	function
(	O
0	int
,	O
0	int
,	O
D_width	O
-	O
1	int
,	O
D_height	O
-	O
1	int
,	O
isblank	int
)	O
;	O
}	O
void	O
RefreshArea	function
(	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
isblank	int
)	O
int	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
isblank	int
;	O
{	O
int	O
y	int
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
debug2	O
(	O
"Refresh Area: %d,%d"	pointer
,	O
xs	int
,	O
ys	int
)	O
;	O
debug3	O
(	O
" - %d,%d (isblank=%d)\n"	pointer
,	O
xe	int
,	O
ye	int
,	O
isblank	int
)	O
;	O
if	O
(	O
!	O
isblank	int
&&	O
xs	int
==	O
0	int
&&	O
xe	int
==	O
D_width	O
-	O
1	int
&&	O
ye	int
==	O
D_height	O
-	O
1	int
&&	O
(	O
ys	int
==	O
0	int
||	O
D_CD	O
)	O
)	O
{	O
ClearArea	function
(	O
xs	int
,	O
ys	int
,	O
xs	int
,	O
xe	int
,	O
xe	int
,	O
ye	int
,	O
0	int
,	O
0	int
)	O
;	O
isblank	int
=	O
1	int
;	O
}	O
for	O
(	O
y	int
=	O
ys	int
;	O
y	int
<=	O
ye	int
;	O
y	int
++	O
)	O
RefreshLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	int
)	O
;	O
}	O
void	O
RefreshLine	function
(	O
y	int
,	O
from	int
,	O
to	int
,	O
isblank	int
)	O
int	O
y	int
,	O
from	int
,	O
to	int
,	O
isblank	int
;	O
{	O
struct	O
viewport	struct
*	O
vp	pointer
,	O
*	O
lvp	pointer
;	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
*	O
lcv	pointer
,	O
*	O
cvlist	pointer
,	O
*	O
cvlnext	pointer
;	O
struct	O
layer	struct
*	O
oldflayer	pointer
;	O
int	O
xx	int
,	O
yy	int
,	O
l	pointer
;	O
char	O
*	O
buf	pointer
;	O
struct	O
win	struct
*	O
p	pointer
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
debug2	O
(	O
"RefreshLine %d %d"	pointer
,	O
y	int
,	O
from	int
)	O
;	O
debug2	O
(	O
" %d %d\n"	pointer
,	O
to	int
,	O
isblank	int
)	O
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
&&	O
y	int
==	O
STATLINE	O
)	O
{	O
if	O
(	O
to	int
>=	O
D_status_len	O
)	O
D_status_len	O
=	O
to	int
+	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
isblank	int
==	O
0	int
&&	O
D_CE	O
&&	O
to	int
==	O
D_width	O
-	O
1	int
&&	O
from	int
<	O
to	int
&&	O
D_status	O
!=	O
STATUS_ON_HS	int
)	O
{	O
GotoPos	function
(	O
from	int
,	O
y	int
)	O
;	O
if	O
(	O
D_UT	O
||	O
D_BE	O
)	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
AddCStr	function
(	O
D_CE	O
)	O
;	O
isblank	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
y	int
==	O
D_height	O
-	O
1	int
&&	O
D_has_hstatus	O
==	O
HSTATUS_LASTLINE	int
)	O
||	O
(	O
y	int
==	O
0	int
&&	O
D_has_hstatus	O
==	O
HSTATUS_FIRSTLINE	int
)	O
)	O
{	O
RefreshHStatus	function
(	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
from	int
<=	O
to	int
)	O
{	O
lcv	pointer
=	O
0	int
;	O
lvp	pointer
=	O
0	int
;	O
for	O
(	O
cv	pointer
=	O
display	struct
->	O
d_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
if	O
(	O
y	int
==	O
cv	pointer
->	O
c_ye	int
+	O
1	int
&&	O
from	int
>=	O
cv	pointer
->	O
c_xs	int
&&	O
from	int
<=	O
cv	pointer
->	O
c_xe	int
)	O
{	O
int	O
extrabytes	int
=	O
strlen	function
(	O
captionstring	pointer
)	O
-	O
strlen_onscreen	function
(	O
captionstring	pointer
,	O
NULL	O
)	O
;	O
p	pointer
=	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
;	O
buf	pointer
=	O
MakeWinMsgEv	function
(	O
captionstring	pointer
,	O
p	pointer
,	O
'%'	O
,	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
(	O
cv	pointer
->	O
c_xe	int
+	O
1	int
<	O
D_width	O
||	O
D_CLP	O
)	O
+	O
extrabytes	int
,	O
&	O
cv	pointer
->	O
c_captev	struct
,	O
0	int
)	O
;	O
if	O
(	O
cv	pointer
->	O
c_captev	struct
.	O
timeout	struct
.	O
tv_sec	long
)	O
evenq	function
(	O
&	O
cv	pointer
->	O
c_captev	struct
)	O
;	O
xx	int
=	O
to	int
>	O
cv	pointer
->	O
c_xe	int
?	O
cv	pointer
->	O
c_xe	int
:	O
to	int
;	O
l	pointer
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
GotoPos	function
(	O
from	int
,	O
y	int
)	O
;	O
SetRendition	function
(	O
&	O
mchar_so	struct
)	O
;	O
if	O
(	O
l	pointer
>	O
xx	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
)	O
l	pointer
=	O
xx	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
;	O
l	pointer
=	O
PrePutWinMsg	function
(	O
buf	pointer
,	O
from	int
-	O
cv	pointer
->	O
c_xs	int
,	O
l	pointer
+	O
extrabytes	int
)	O
;	O
from	int
=	O
cv	pointer
->	O
c_xs	int
+	O
l	pointer
;	O
for	O
(	O
;	O
from	int
<=	O
xx	int
;	O
from	int
++	O
)	O
PUTCHARLP	function
(	O
' '	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
from	int
==	O
cv	pointer
->	O
c_xe	int
+	O
1	int
&&	O
y	int
>=	O
cv	pointer
->	O
c_ys	int
&&	O
y	int
<=	O
cv	pointer
->	O
c_ye	int
+	O
1	int
)	O
{	O
GotoPos	function
(	O
from	int
,	O
y	int
)	O
;	O
SetRendition	function
(	O
&	O
mchar_so	struct
)	O
;	O
PUTCHARLP	function
(	O
' '	O
)	O
;	O
from	int
++	O
;	O
break	O
;	O
}	O
if	O
(	O
y	int
<	O
cv	pointer
->	O
c_ys	int
||	O
y	int
>	O
cv	pointer
->	O
c_ye	int
||	O
to	int
<	O
cv	pointer
->	O
c_xs	int
||	O
from	int
>	O
cv	pointer
->	O
c_xe	int
)	O
continue	O
;	O
debug2	O
(	O
"- canvas hit: %d %d"	pointer
,	O
cv	pointer
->	O
c_xs	int
,	O
cv	pointer
->	O
c_ys	int
)	O
;	O
debug2	O
(	O
"  %d %d\n"	pointer
,	O
cv	pointer
->	O
c_xe	int
,	O
cv	pointer
->	O
c_ye	int
)	O
;	O
for	O
(	O
vp	pointer
=	O
cv	pointer
->	O
c_vplist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
v_next	pointer
)	O
{	O
debug2	O
(	O
"  - vp: %d %d"	pointer
,	O
vp	pointer
->	O
v_xs	int
,	O
vp	pointer
->	O
v_ys	int
)	O
;	O
debug2	O
(	O
"  %d %d\n"	pointer
,	O
vp	pointer
->	O
v_xe	int
,	O
vp	pointer
->	O
v_ye	int
)	O
;	O
if	O
(	O
y	int
>=	O
vp	pointer
->	O
v_ys	int
&&	O
y	int
<=	O
vp	pointer
->	O
v_ye	int
&&	O
from	int
<=	O
vp	pointer
->	O
v_xe	int
&&	O
to	int
>=	O
vp	pointer
->	O
v_xs	int
&&	O
(	O
lvp	pointer
==	O
0	int
||	O
lvp	pointer
->	O
v_xs	int
>	O
vp	pointer
->	O
v_xs	int
)	O
)	O
{	O
lcv	pointer
=	O
cv	pointer
;	O
lvp	pointer
=	O
vp	pointer
;	O
}	O
}	O
}	O
if	O
(	O
cv	pointer
)	O
continue	O
;	O
if	O
(	O
lvp	pointer
==	O
0	int
)	O
break	O
;	O
if	O
(	O
from	int
<	O
lvp	pointer
->	O
v_xs	int
)	O
{	O
if	O
(	O
!	O
isblank	int
)	O
DisplayLine	function
(	O
&	O
mline_null	struct
,	O
&	O
mline_blank	struct
,	O
y	int
,	O
from	int
,	O
lvp	pointer
->	O
v_xs	int
-	O
1	int
)	O
;	O
from	int
=	O
lvp	pointer
->	O
v_xs	int
;	O
}	O
yy	int
=	O
y	int
-	O
lvp	pointer
->	O
v_yoff	int
;	O
xx	int
=	O
to	int
<	O
lvp	pointer
->	O
v_xe	int
?	O
to	int
:	O
lvp	pointer
->	O
v_xe	int
;	O
if	O
(	O
lcv	pointer
->	O
c_layer	pointer
&&	O
lcv	pointer
->	O
c_xoff	int
+	O
lcv	pointer
->	O
c_layer	pointer
->	O
l_width	int
==	O
from	int
)	O
{	O
GotoPos	function
(	O
from	int
,	O
y	int
)	O
;	O
SetRendition	function
(	O
&	O
mchar_blank	struct
)	O
;	O
PUTCHARLP	function
(	O
'|'	O
)	O
;	O
from	int
++	O
;	O
}	O
if	O
(	O
lcv	pointer
->	O
c_layer	pointer
&&	O
yy	int
==	O
lcv	pointer
->	O
c_layer	pointer
->	O
l_height	int
)	O
{	O
GotoPos	function
(	O
from	int
,	O
y	int
)	O
;	O
SetRendition	function
(	O
&	O
mchar_blank	struct
)	O
;	O
while	O
(	O
from	int
<=	O
lvp	pointer
->	O
v_xe	int
&&	O
from	int
-	O
lvp	pointer
->	O
v_xoff	int
<	O
lcv	pointer
->	O
c_layer	pointer
->	O
l_width	int
)	O
{	O
PUTCHARLP	function
(	O
'-'	O
)	O
;	O
from	int
++	O
;	O
}	O
if	O
(	O
from	int
>=	O
lvp	pointer
->	O
v_xe	int
+	O
1	int
)	O
continue	O
;	O
}	O
if	O
(	O
lcv	pointer
->	O
c_layer	pointer
==	O
0	int
||	O
yy	int
>=	O
lcv	pointer
->	O
c_layer	pointer
->	O
l_height	int
||	O
from	int
-	O
lvp	pointer
->	O
v_xoff	int
>=	O
lcv	pointer
->	O
c_layer	pointer
->	O
l_width	int
)	O
{	O
if	O
(	O
!	O
isblank	int
)	O
DisplayLine	function
(	O
&	O
mline_null	struct
,	O
&	O
mline_blank	struct
,	O
y	int
,	O
from	int
,	O
lvp	pointer
->	O
v_xe	int
)	O
;	O
from	int
=	O
lvp	pointer
->	O
v_xe	int
+	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
xx	int
-	O
lvp	pointer
->	O
v_xoff	int
>=	O
lcv	pointer
->	O
c_layer	pointer
->	O
l_width	int
)	O
xx	int
=	O
lcv	pointer
->	O
c_layer	pointer
->	O
l_width	int
+	O
lvp	pointer
->	O
v_xoff	int
-	O
1	int
;	O
oldflayer	pointer
=	O
flayer	pointer
;	O
flayer	pointer
=	O
lcv	pointer
->	O
c_layer	pointer
;	O
cvlist	pointer
=	O
flayer	pointer
->	O
l_cvlist	pointer
;	O
cvlnext	pointer
=	O
lcv	pointer
->	O
c_lnext	pointer
;	O
flayer	pointer
->	O
l_cvlist	pointer
=	O
lcv	pointer
;	O
lcv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
LayRedisplayLine	O
(	O
yy	int
,	O
from	int
-	O
lvp	pointer
->	O
v_xoff	int
,	O
xx	int
-	O
lvp	pointer
->	O
v_xoff	int
,	O
isblank	int
)	O
;	O
flayer	pointer
->	O
l_cvlist	pointer
=	O
cvlist	pointer
;	O
lcv	pointer
->	O
c_lnext	pointer
=	O
cvlnext	pointer
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
from	int
=	O
xx	int
+	O
1	int
;	O
}	O
if	O
(	O
!	O
isblank	int
&&	O
from	int
<=	O
to	int
)	O
DisplayLine	function
(	O
&	O
mline_null	struct
,	O
&	O
mline_blank	struct
,	O
y	int
,	O
from	int
,	O
to	int
)	O
;	O
}	O
static	O
void	O
WriteLP	function
(	O
x2	int
,	O
y2	int
)	O
int	O
x2	int
,	O
y2	int
;	O
{	O
struct	O
mchar	struct
oldrend	struct
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
ASSERT	O
(	O
D_lp_missing	O
)	O
;	O
oldrend	struct
=	O
D_rend	O
;	O
debug2	O
(	O
"WriteLP(%d,%d)\n"	pointer
,	O
x2	int
,	O
y2	int
)	O
;	O
if	O
(	O
D_lpchar	O
.	O
mbcs	char
)	O
{	O
if	O
(	O
x2	int
>	O
0	int
)	O
x2	int
--	O
;	O
else	O
D_lpchar	O
=	O
mchar_blank	struct
;	O
}	O
GotoPos	function
(	O
x2	int
,	O
y2	int
)	O
;	O
SetRendition	function
(	O
&	O
D_lpchar	O
)	O
;	O
PUTCHAR	function
(	O
D_lpchar	O
.	O
image	char
)	O
;	O
if	O
(	O
D_lpchar	O
.	O
mbcs	char
)	O
PUTCHAR	function
(	O
D_lpchar	O
.	O
mbcs	char
)	O
;	O
D_lp_missing	O
=	O
0	int
;	O
SetRendition	function
(	O
&	O
oldrend	struct
)	O
;	O
}	O
void	O
ClearLine	function
(	O
oml	pointer
,	O
y	int
,	O
from	int
,	O
to	int
,	O
bce	int
)	O
struct	O
mline	struct
*	O
oml	pointer
;	O
int	O
from	int
,	O
to	int
,	O
y	int
,	O
bce	int
;	O
{	O
int	O
x	int
;	O
struct	O
mchar	struct
bcechar	struct
;	O
debug3	O
(	O
"ClearLine %d,%d-%d\n"	pointer
,	O
y	int
,	O
from	int
,	O
to	int
)	O
;	O
if	O
(	O
D_UT	O
)	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
if	O
(	O
D_BE	O
)	O
SetBackColor	function
(	O
bce	int
)	O
;	O
if	O
(	O
from	int
==	O
0	int
&&	O
D_CB	O
&&	O
(	O
to	int
!=	O
D_width	O
-	O
1	int
||	O
(	O
D_x	O
==	O
to	int
&&	O
D_y	O
==	O
y	int
)	O
)	O
&&	O
(	O
!	O
bce	int
||	O
D_BE	O
)	O
)	O
{	O
GotoPos	function
(	O
to	int
,	O
y	int
)	O
;	O
AddCStr	function
(	O
D_CB	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
to	int
==	O
D_width	O
-	O
1	int
&&	O
D_CE	O
&&	O
(	O
!	O
bce	int
||	O
D_BE	O
)	O
)	O
{	O
GotoPos	function
(	O
from	int
,	O
y	int
)	O
;	O
AddCStr	function
(	O
D_CE	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
oml	pointer
==	O
0	int
)	O
oml	pointer
=	O
&	O
mline_null	struct
;	O
if	O
(	O
!	O
bce	int
)	O
{	O
DisplayLine	function
(	O
oml	pointer
,	O
&	O
mline_blank	struct
,	O
y	int
,	O
from	int
,	O
to	int
)	O
;	O
return	O
;	O
}	O
bcechar	struct
=	O
mchar_null	struct
;	O
rend_setbg	O
(	O
&	O
bcechar	struct
,	O
bce	int
)	O
;	O
for	O
(	O
x	int
=	O
from	int
;	O
x	int
<=	O
to	int
;	O
x	int
++	O
)	O
copy_mchar2mline	O
(	O
&	O
bcechar	struct
,	O
&	O
mline_old	struct
,	O
x	int
)	O
;	O
DisplayLine	function
(	O
oml	pointer
,	O
&	O
mline_old	struct
,	O
y	int
,	O
from	int
,	O
to	int
)	O
;	O
}	O
void	O
DisplayLine	function
(	O
oml	pointer
,	O
ml	pointer
,	O
y	int
,	O
from	int
,	O
to	int
)	O
struct	O
mline	struct
*	O
oml	pointer
,	O
*	O
ml	pointer
;	O
int	O
from	int
,	O
to	int
,	O
y	int
;	O
{	O
register	O
int	O
x	int
;	O
int	O
last2flag	int
=	O
0	int
,	O
delete_lp	int
=	O
0	int
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
ASSERT	O
(	O
y	int
>=	O
0	int
&&	O
y	int
<	O
D_height	O
)	O
;	O
ASSERT	O
(	O
from	int
>=	O
0	int
&&	O
from	int
<	O
D_width	O
)	O
;	O
ASSERT	O
(	O
to	int
>=	O
0	int
&&	O
to	int
<	O
D_width	O
)	O
;	O
if	O
(	O
!	O
D_CLP	O
&&	O
y	int
==	O
D_bot	O
&&	O
to	int
==	O
D_width	O
-	O
1	int
)	O
{	O
if	O
(	O
D_lp_missing	O
||	O
!	O
cmp_mline	O
(	O
oml	pointer
,	O
ml	pointer
,	O
to	int
)	O
)	O
{	O
if	O
(	O
(	O
D_IC	O
||	O
D_IM	O
)	O
&&	O
from	int
<	O
to	int
&&	O
!	O
dw_left	O
(	O
ml	pointer
,	O
to	int
,	O
D_encoding	O
)	O
)	O
{	O
last2flag	int
=	O
1	int
;	O
D_lp_missing	O
=	O
0	int
;	O
to	int
--	O
;	O
}	O
else	O
{	O
delete_lp	int
=	O
!	O
cmp_mchar_mline	O
(	O
&	O
mchar_blank	struct
,	O
oml	pointer
,	O
to	int
)	O
&&	O
(	O
D_CE	O
||	O
D_DC	O
||	O
D_CDC	O
)	O
;	O
D_lp_missing	O
=	O
!	O
cmp_mchar_mline	O
(	O
&	O
mchar_blank	struct
,	O
ml	pointer
,	O
to	int
)	O
;	O
copy_mline2mchar	O
(	O
&	O
D_lpchar	O
,	O
ml	pointer
,	O
to	int
)	O
;	O
}	O
}	O
to	int
--	O
;	O
}	O
if	O
(	O
D_mbcs	O
)	O
{	O
debug	O
(	O
"DisplayLine finishing kanji\n"	pointer
)	O
;	O
SetRenditionMline	function
(	O
ml	pointer
,	O
from	int
)	O
;	O
PUTCHAR	function
(	O
ml	pointer
->	O
image	char
[	O
from	int
]	O
)	O
;	O
from	int
++	O
;	O
}	O
for	O
(	O
x	int
=	O
from	int
;	O
x	int
<=	O
to	int
;	O
x	int
++	O
)	O
{	O
{	O
if	O
(	O
ml	pointer
!=	O
NULL	O
&&	O
(	O
x	int
<	O
to	int
||	O
x	int
!=	O
D_width	O
-	O
1	int
||	O
ml	pointer
->	O
image	char
[	O
x	int
+	O
1	int
]	O
)	O
)	O
if	O
(	O
cmp_mline	O
(	O
oml	pointer
,	O
ml	pointer
,	O
x	int
)	O
)	O
continue	O
;	O
GotoPos	function
(	O
x	int
,	O
y	int
)	O
;	O
}	O
if	O
(	O
dw_right	O
(	O
ml	pointer
,	O
x	int
,	O
D_encoding	O
)	O
)	O
{	O
x	int
--	O
;	O
debug1	O
(	O
"DisplayLine on right side of dw char- x now %d\n"	pointer
,	O
x	int
)	O
;	O
GotoPos	function
(	O
x	int
,	O
y	int
)	O
;	O
}	O
if	O
(	O
x	int
==	O
to	int
&&	O
dw_left	O
(	O
ml	pointer
,	O
x	int
,	O
D_encoding	O
)	O
)	O
break	O
;	O
SetRenditionMline	function
(	O
ml	pointer
,	O
x	int
)	O
;	O
PUTCHAR	function
(	O
ml	pointer
->	O
image	char
[	O
x	int
]	O
)	O
;	O
if	O
(	O
dw_left	O
(	O
ml	pointer
,	O
x	int
,	O
D_encoding	O
)	O
)	O
PUTCHAR	function
(	O
ml	pointer
->	O
image	char
[	O
++	O
x	int
]	O
)	O
;	O
}	O
if	O
(	O
last2flag	int
)	O
{	O
GotoPos	function
(	O
x	int
,	O
y	int
)	O
;	O
SetRenditionMline	function
(	O
ml	pointer
,	O
x	int
+	O
1	int
)	O
;	O
PUTCHAR	function
(	O
ml	pointer
->	O
image	char
[	O
x	int
+	O
1	int
]	O
)	O
;	O
GotoPos	function
(	O
x	int
,	O
y	int
)	O
;	O
SetRenditionMline	function
(	O
ml	pointer
,	O
x	int
)	O
;	O
INSERTCHAR	function
(	O
ml	pointer
->	O
image	char
[	O
x	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
delete_lp	int
)	O
{	O
if	O
(	O
D_UT	O
)	O
SetRendition	function
(	O
&	O
mchar_null	struct
)	O
;	O
if	O
(	O
D_DC	O
)	O
AddCStr	function
(	O
D_DC	O
)	O
;	O
else	O
if	O
(	O
D_CDC	O
)	O
AddCStr2	function
(	O
D_CDC	O
,	O
1	int
)	O
;	O
else	O
if	O
(	O
D_CE	O
)	O
AddCStr	function
(	O
D_CE	O
)	O
;	O
}	O
}	O
void	O
PutChar	function
(	O
c	int
,	O
x	int
,	O
y	int
)	O
struct	O
mchar	struct
*	O
c	int
;	O
int	O
x	int
,	O
y	int
;	O
{	O
GotoPos	function
(	O
x	int
,	O
y	int
)	O
;	O
SetRendition	function
(	O
c	int
)	O
;	O
PUTCHARLP	function
(	O
c	int
->	O
image	char
)	O
;	O
if	O
(	O
c	int
->	O
mbcs	char
)	O
{	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
D_rend	O
.	O
font	char
=	O
0	int
;	O
PUTCHARLP	function
(	O
c	int
->	O
mbcs	char
)	O
;	O
}	O
}	O
void	O
InsChar	function
(	O
c	int
,	O
x	int
,	O
xe	int
,	O
y	int
,	O
oml	pointer
)	O
struct	O
mchar	struct
*	O
c	int
;	O
int	O
x	int
,	O
xe	int
,	O
y	int
;	O
struct	O
mline	struct
*	O
oml	pointer
;	O
{	O
GotoPos	function
(	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
y	int
==	O
D_bot	O
&&	O
!	O
D_CLP	O
)	O
{	O
if	O
(	O
x	int
==	O
D_width	O
-	O
1	int
)	O
{	O
D_lp_missing	O
=	O
1	int
;	O
D_lpchar	O
=	O
*	O
c	int
;	O
return	O
;	O
}	O
if	O
(	O
xe	int
==	O
D_width	O
-	O
1	int
)	O
D_lp_missing	O
=	O
0	int
;	O
}	O
if	O
(	O
x	int
==	O
xe	int
)	O
{	O
SetRendition	function
(	O
c	int
)	O
;	O
PUTCHARLP	function
(	O
c	int
->	O
image	char
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
(	O
D_IC	O
||	O
D_CIC	O
||	O
D_IM	O
)	O
||	O
xe	int
!=	O
D_width	O
-	O
1	int
)	O
{	O
RefreshLine	function
(	O
y	int
,	O
x	int
,	O
xe	int
,	O
0	int
)	O
;	O
GotoPos	function
(	O
x	int
+	O
1	int
,	O
y	int
)	O
;	O
return	O
;	O
}	O
InsertMode	function
(	O
1	int
)	O
;	O
if	O
(	O
!	O
D_insert	O
)	O
{	O
if	O
(	O
c	int
->	O
mbcs	char
&&	O
D_IC	O
)	O
AddCStr	function
(	O
D_IC	O
)	O
;	O
if	O
(	O
D_IC	O
)	O
AddCStr	function
(	O
D_IC	O
)	O
;	O
else	O
AddCStr2	function
(	O
D_CIC	O
,	O
c	int
->	O
mbcs	char
?	O
2	int
:	O
1	int
)	O
;	O
}	O
SetRendition	function
(	O
c	int
)	O
;	O
RAW_PUTCHAR	function
(	O
c	int
->	O
image	char
)	O
;	O
if	O
(	O
c	int
->	O
mbcs	char
)	O
{	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
D_rend	O
.	O
font	char
=	O
0	int
;	O
if	O
(	O
D_x	O
==	O
D_width	O
-	O
1	int
)	O
PUTCHARLP	function
(	O
c	int
->	O
mbcs	char
)	O
;	O
else	O
RAW_PUTCHAR	function
(	O
c	int
->	O
mbcs	char
)	O
;	O
}	O
}	O
void	O
WrapChar	function
(	O
c	int
,	O
x	int
,	O
y	int
,	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
ins	int
)	O
struct	O
mchar	struct
*	O
c	int
;	O
int	O
x	int
,	O
y	int
;	O
int	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
;	O
int	O
ins	int
;	O
{	O
int	O
bce	int
;	O
bce	int
=	O
rend_getbg	O
(	O
c	int
)	O
;	O
debug	O
(	O
"WrapChar:"	pointer
)	O
;	O
debug2	O
(	O
"  x %d  y %d"	pointer
,	O
x	int
,	O
y	int
)	O
;	O
debug2	O
(	O
"  Dx %d  Dy %d"	pointer
,	O
D_x	O
,	O
D_y	O
)	O
;	O
debug2	O
(	O
"  xs %d  ys %d"	pointer
,	O
xs	int
,	O
ys	int
)	O
;	O
debug3	O
(	O
"  xe %d  ye %d ins %d\n"	pointer
,	O
xe	int
,	O
ye	int
,	O
ins	int
)	O
;	O
if	O
(	O
xs	int
!=	O
0	int
||	O
x	int
!=	O
D_width	O
||	O
!	O
D_AM	O
)	O
{	O
if	O
(	O
y	int
==	O
ye	int
)	O
ScrollV	function
(	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
1	int
,	O
bce	int
)	O
;	O
else	O
if	O
(	O
y	int
<	O
D_height	O
-	O
1	int
)	O
y	int
++	O
;	O
if	O
(	O
ins	int
)	O
InsChar	function
(	O
c	int
,	O
xs	int
,	O
xe	int
,	O
y	int
,	O
0	int
)	O
;	O
else	O
PutChar	function
(	O
c	int
,	O
xs	int
,	O
y	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
y	int
==	O
ye	int
)	O
{	O
debug	O
(	O
"- scrolling\n"	pointer
)	O
;	O
ChangeScrollRegion	function
(	O
ys	int
,	O
ye	int
)	O
;	O
if	O
(	O
D_bot	O
!=	O
y	int
||	O
D_x	O
!=	O
D_width	O
||	O
(	O
!	O
bce	int
&&	O
!	O
D_BE	O
)	O
)	O
{	O
debug	O
(	O
"- have to call ScrollV\n"	pointer
)	O
;	O
ScrollV	function
(	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
1	int
,	O
bce	int
)	O
;	O
y	int
--	O
;	O
}	O
}	O
else	O
if	O
(	O
y	int
==	O
D_bot	O
)	O
ChangeScrollRegion	function
(	O
0	int
,	O
D_height	O
-	O
1	int
)	O
;	O
if	O
(	O
D_x	O
!=	O
D_width	O
||	O
D_y	O
!=	O
y	int
)	O
{	O
if	O
(	O
D_CLP	O
&&	O
y	int
>=	O
0	int
)	O
RefreshLine	function
(	O
y	int
,	O
D_width	O
-	O
1	int
,	O
D_width	O
-	O
1	int
,	O
0	int
)	O
;	O
debug2	O
(	O
"- refresh last char -> x,y now %d,%d\n"	pointer
,	O
D_x	O
,	O
D_y	O
)	O
;	O
if	O
(	O
D_x	O
!=	O
D_width	O
||	O
D_y	O
!=	O
y	int
)	O
{	O
if	O
(	O
y	int
==	O
ye	int
)	O
ScrollV	function
(	O
xs	int
,	O
ys	int
,	O
xe	int
,	O
ye	int
,	O
1	int
,	O
bce	int
)	O
;	O
GotoPos	function
(	O
xs	int
,	O
y	int
==	O
ye	int
||	O
y	int
==	O
D_height	O
-	O
1	int
?	O
y	int
:	O
y	int
+	O
1	int
)	O
;	O
}	O
}	O
debug	O
(	O
"- writeing new char"	pointer
)	O
;	O
if	O
(	O
y	int
!=	O
ye	int
&&	O
y	int
<	O
D_height	O
-	O
1	int
)	O
y	int
++	O
;	O
if	O
(	O
ins	int
!=	O
D_insert	O
)	O
InsertMode	function
(	O
ins	int
)	O
;	O
if	O
(	O
ins	int
&&	O
!	O
D_insert	O
)	O
{	O
InsChar	function
(	O
c	int
,	O
0	int
,	O
xe	int
,	O
y	int
,	O
0	int
)	O
;	O
debug2	O
(	O
" -> done with insert (%d,%d)\n"	pointer
,	O
D_x	O
,	O
D_y	O
)	O
;	O
return	O
;	O
}	O
D_y	O
=	O
y	int
;	O
D_x	O
=	O
0	int
;	O
SetRendition	function
(	O
c	int
)	O
;	O
RAW_PUTCHAR	function
(	O
c	int
->	O
image	char
)	O
;	O
if	O
(	O
c	int
->	O
mbcs	char
)	O
{	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
D_rend	O
.	O
font	char
=	O
0	int
;	O
RAW_PUTCHAR	function
(	O
c	int
->	O
mbcs	char
)	O
;	O
}	O
debug2	O
(	O
" -> done (%d,%d)\n"	pointer
,	O
D_x	O
,	O
D_y	O
)	O
;	O
}	O
int	O
ResizeDisplay	function
(	O
wi	int
,	O
he	int
)	O
int	O
wi	int
,	O
he	int
;	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
debug2	O
(	O
"ResizeDisplay: to (%d,%d).\n"	pointer
,	O
wi	int
,	O
he	int
)	O
;	O
if	O
(	O
D_width	O
==	O
wi	int
&&	O
D_height	O
==	O
he	int
)	O
{	O
debug	O
(	O
"ResizeDisplay: No change\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
D_width	O
!=	O
wi	int
&&	O
(	O
D_height	O
==	O
he	int
||	O
!	O
D_CWS	O
)	O
&&	O
D_CZ0	O
&&	O
(	O
wi	int
==	O
Z0width	int
||	O
wi	int
==	O
Z1width	int
)	O
)	O
{	O
debug	O
(	O
"ResizeDisplay: using Z0/Z1\n"	pointer
)	O
;	O
AddCStr	function
(	O
wi	int
==	O
Z0width	int
?	O
D_CZ0	O
:	O
D_CZ1	O
)	O
;	O
ChangeScreenSize	function
(	O
wi	int
,	O
D_height	O
,	O
0	int
)	O
;	O
return	O
(	O
he	int
==	O
D_height	O
)	O
?	O
0	int
:	O
-	O
1	int
;	O
}	O
if	O
(	O
D_CWS	O
)	O
{	O
debug	O
(	O
"ResizeDisplay: using WS\n"	pointer
)	O
;	O
AddCStr	function
(	O
tgoto	function
(	O
D_CWS	O
,	O
wi	int
,	O
he	int
)	O
)	O
;	O
ChangeScreenSize	function
(	O
wi	int
,	O
he	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
void	O
ChangeScrollRegion	function
(	O
newtop	int
,	O
newbot	int
)	O
int	O
newtop	int
,	O
newbot	int
;	O
{	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
if	O
(	O
newtop	int
==	O
newbot	int
)	O
return	O
;	O
if	O
(	O
newtop	int
==	O
-	O
1	int
)	O
newtop	int
=	O
0	int
;	O
if	O
(	O
newbot	int
==	O
-	O
1	int
)	O
newbot	int
=	O
D_height	O
-	O
1	int
;	O
if	O
(	O
D_CS	O
==	O
0	int
)	O
{	O
D_top	O
=	O
0	int
;	O
D_bot	O
=	O
D_height	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
D_top	O
==	O
newtop	int
&&	O
D_bot	O
==	O
newbot	int
)	O
return	O
;	O
debug2	O
(	O
"ChangeScrollRegion: (%d - %d)\n"	pointer
,	O
newtop	int
,	O
newbot	int
)	O
;	O
AddCStr	function
(	O
tgoto	function
(	O
D_CS	O
,	O
newbot	int
,	O
newtop	int
)	O
)	O
;	O
D_top	O
=	O
newtop	int
;	O
D_bot	O
=	O
newbot	int
;	O
D_y	O
=	O
D_x	O
=	O
-	O
1	int
;	O
}	O
void	O
AddStr	function
(	O
str	pointer
)	O
char	O
*	O
str	pointer
;	O
{	O
register	O
char	O
c	int
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
{	O
while	O
(	O
(	O
c	int
=	O
*	O
str	pointer
++	O
)	O
)	O
AddUtf8	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
;	O
return	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
*	O
str	pointer
++	O
)	O
)	O
AddChar	O
(	O
c	int
)	O
;	O
}	O
void	O
AddStrn	function
(	O
str	pointer
,	O
n	int
)	O
char	O
*	O
str	pointer
;	O
int	O
n	int
;	O
{	O
register	O
char	O
c	int
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
D_encoding	O
==	O
UTF8	int
)	O
{	O
while	O
(	O
(	O
c	int
=	O
*	O
str	pointer
++	O
)	O
&&	O
n	int
--	O
>	O
0	int
)	O
AddUtf8	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
;	O
}	O
else	O
while	O
(	O
(	O
c	int
=	O
*	O
str	pointer
++	O
)	O
&&	O
n	int
--	O
>	O
0	int
)	O
AddChar	O
(	O
c	int
)	O
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
AddChar	O
(	O
' '	O
)	O
;	O
}	O
void	O
Flush	function
(	O
progress	int
)	O
int	O
progress	int
;	O
{	O
register	O
int	O
l	pointer
;	O
int	O
wr	int
;	O
register	O
char	O
*	O
p	pointer
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
l	pointer
=	O
D_obufp	O
-	O
D_obuf	O
;	O
debug1	O
(	O
"Flush(): %d\n"	pointer
,	O
l	pointer
)	O
;	O
if	O
(	O
l	pointer
==	O
0	int
)	O
return	O
;	O
ASSERT	O
(	O
l	pointer
+	O
D_obuffree	O
==	O
D_obuflen	O
)	O
;	O
if	O
(	O
D_userfd	O
<	O
0	int
)	O
{	O
D_obuffree	O
+=	O
l	pointer
;	O
D_obufp	O
=	O
D_obuf	O
;	O
return	O
;	O
}	O
p	pointer
=	O
D_obuf	O
;	O
if	O
(	O
!	O
progress	int
)	O
{	O
if	O
(	O
fcntl	function
(	O
D_userfd	O
,	O
F_SETFL	int
,	O
0	int
)	O
)	O
debug1	O
(	O
"Warning: BLOCK fcntl failed: %d\n"	pointer
,	O
errno	O
)	O
;	O
}	O
while	O
(	O
l	pointer
)	O
{	O
if	O
(	O
progress	int
)	O
{	O
fd_set	struct
w	struct
;	O
FD_ZERO	O
(	O
&	O
w	struct
)	O
;	O
FD_SET	O
(	O
D_userfd	O
,	O
&	O
w	struct
)	O
;	O
struct	O
timeval	struct
t	int
;	O
t	int
.	O
tv_sec	long
=	O
progress	int
;	O
t	int
.	O
tv_usec	long
=	O
0	int
;	O
wr	int
=	O
select	function
(	O
FD_SETSIZE	O
,	O
(	O
fd_set	struct
*	O
)	O
0	int
,	O
&	O
w	struct
,	O
(	O
fd_set	struct
*	O
)	O
0	int
,	O
&	O
t	int
)	O
;	O
if	O
(	O
wr	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
debug1	O
(	O
"Warning: select failed: %d\n"	pointer
,	O
errno	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
wr	int
==	O
0	int
)	O
{	O
debug1	O
(	O
"Warning: no progress after %d seconds\n"	pointer
,	O
progress	int
)	O
;	O
break	O
;	O
}	O
}	O
wr	int
=	O
write	pointer
(	O
D_userfd	O
,	O
p	pointer
,	O
l	pointer
)	O
;	O
if	O
(	O
wr	int
<=	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
debug1	O
(	O
"Writing to display: %d\n"	pointer
,	O
errno	O
)	O
;	O
break	O
;	O
}	O
D_obuffree	O
+=	O
wr	int
;	O
p	pointer
+=	O
wr	int
;	O
l	pointer
-=	O
wr	int
;	O
}	O
if	O
(	O
l	pointer
)	O
debug1	O
(	O
"Warning: Flush could not write %d bytes\n"	pointer
,	O
l	pointer
)	O
;	O
D_obuffree	O
+=	O
l	pointer
;	O
D_obufp	O
=	O
D_obuf	O
;	O
if	O
(	O
!	O
progress	int
)	O
{	O
if	O
(	O
fcntl	function
(	O
D_userfd	O
,	O
F_SETFL	int
,	O
FNBLOCK	O
)	O
)	O
debug1	O
(	O
"Warning: NBLOCK fcntl failed: %d\n"	pointer
,	O
errno	O
)	O
;	O
}	O
if	O
(	O
D_blocked	O
==	O
1	int
)	O
D_blocked	O
=	O
0	int
;	O
D_blocked_fuzz	O
=	O
0	int
;	O
}	O
void	O
freetty	function
(	O
)	O
{	O
if	O
(	O
D_userfd	O
>=	O
0	int
)	O
close	pointer
(	O
D_userfd	O
)	O
;	O
debug1	O
(	O
"did freetty %d\n"	pointer
,	O
D_userfd	O
)	O
;	O
D_userfd	O
=	O
-	O
1	int
;	O
D_obufp	O
=	O
0	int
;	O
D_obuffree	O
=	O
0	int
;	O
if	O
(	O
D_obuf	O
)	O
free	function
(	O
D_obuf	O
)	O
;	O
D_obuf	O
=	O
0	int
;	O
D_obuflen	O
=	O
0	int
;	O
D_obuflenmax	O
=	O
-	O
D_obufmax	O
;	O
D_blocked	O
=	O
0	int
;	O
D_blocked_fuzz	O
=	O
0	int
;	O
}	O
void	O
Resize_obuf	function
(	O
)	O
{	O
register	O
int	O
ind	int
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
D_status_obuffree	O
>=	O
0	int
)	O
{	O
ASSERT	O
(	O
D_obuffree	O
==	O
-	O
1	int
)	O
;	O
RemoveStatusMinWait	function
(	O
)	O
;	O
if	O
(	O
--	O
D_obuffree	O
>	O
0	int
)	O
return	O
;	O
}	O
if	O
(	O
D_obuflen	O
&&	O
D_obuf	O
)	O
{	O
ind	int
=	O
D_obufp	O
-	O
D_obuf	O
;	O
D_obuflen	O
+=	O
GRAIN	int
;	O
D_obuffree	O
+=	O
GRAIN	int
;	O
D_obuf	O
=	O
realloc	function
(	O
D_obuf	O
,	O
D_obuflen	O
)	O
;	O
}	O
else	O
{	O
ind	int
=	O
0	int
;	O
D_obuflen	O
=	O
GRAIN	int
;	O
D_obuffree	O
=	O
GRAIN	int
;	O
D_obuf	O
=	O
malloc	function
(	O
D_obuflen	O
)	O
;	O
}	O
if	O
(	O
!	O
D_obuf	O
)	O
Panic	function
(	O
0	int
,	O
"Out of memory"	pointer
)	O
;	O
D_obufp	O
=	O
D_obuf	O
+	O
ind	int
;	O
D_obuflenmax	O
=	O
D_obuflen	O
-	O
D_obufmax	O
;	O
debug1	O
(	O
"ResizeObuf: resized to %d\n"	pointer
,	O
D_obuflen	O
)	O
;	O
}	O
void	O
DisplaySleep1000	function
(	O
n	int
,	O
eat	int
)	O
int	O
n	int
;	O
int	O
eat	int
;	O
{	O
char	O
buf	pointer
;	O
fd_set	struct
r	int
;	O
struct	O
timeval	struct
t	int
;	O
if	O
(	O
n	int
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
display	struct
)	O
{	O
debug	O
(	O
"DisplaySleep has no display sigh\n"	pointer
)	O
;	O
sleep1000	function
(	O
n	int
)	O
;	O
return	O
;	O
}	O
t	int
.	O
tv_usec	long
=	O
(	O
n	int
%	O
1000	int
)	O
*	O
1000	int
;	O
t	int
.	O
tv_sec	long
=	O
n	int
/	O
1000	int
;	O
FD_ZERO	O
(	O
&	O
r	int
)	O
;	O
FD_SET	O
(	O
D_userfd	O
,	O
&	O
r	int
)	O
;	O
if	O
(	O
select	function
(	O
FD_SETSIZE	O
,	O
&	O
r	int
,	O
(	O
fd_set	struct
*	O
)	O
0	int
,	O
(	O
fd_set	struct
*	O
)	O
0	int
,	O
&	O
t	int
)	O
>	O
0	int
)	O
{	O
debug	O
(	O
"display activity stopped sleep\n"	pointer
)	O
;	O
if	O
(	O
eat	int
)	O
read	pointer
(	O
D_userfd	O
,	O
&	O
buf	pointer
,	O
1	int
)	O
;	O
}	O
debug2	O
(	O
"DisplaySleep(%d) ending, eat was %d\n"	pointer
,	O
n	int
,	O
eat	int
)	O
;	O
}	O
void	O
NukePending	function
(	O
)	O
{	O
register	O
int	O
len	int
;	O
int	O
oldtop	int
=	O
D_top	O
,	O
oldbot	int
=	O
D_bot	O
;	O
struct	O
mchar	struct
oldrend	struct
;	O
int	O
oldkeypad	int
=	O
D_keypad	O
,	O
oldcursorkeys	int
=	O
D_cursorkeys	O
;	O
int	O
oldcurvis	int
=	O
D_curvis	O
;	O
int	O
oldmouse	int
=	O
D_mouse	O
;	O
int	O
oldextmouse	int
=	O
D_extmouse	O
;	O
oldrend	struct
=	O
D_rend	O
;	O
len	int
=	O
D_obufp	O
-	O
D_obuf	O
;	O
debug1	O
(	O
"NukePending: nuking %d chars\n"	pointer
,	O
len	int
)	O
;	O
tcflush	function
(	O
D_userfd	O
,	O
TCOFLUSH	int
)	O
;	O
D_obufp	O
=	O
D_obuf	O
;	O
D_obuffree	O
+=	O
len	int
;	O
D_top	O
=	O
D_bot	O
=	O
-	O
1	int
;	O
AddCStr	function
(	O
D_IS	O
)	O
;	O
AddCStr	function
(	O
D_TI	O
)	O
;	O
if	O
(	O
D_ME	O
)	O
AddCStr	function
(	O
D_ME	O
)	O
;	O
else	O
{	O
if	O
(	O
D_hascolor	O
)	O
AddStr	function
(	O
"\033[m"	pointer
)	O
;	O
AddCStr	function
(	O
D_SE	O
)	O
;	O
AddCStr	function
(	O
D_UE	O
)	O
;	O
}	O
if	O
(	O
D_IM	O
&&	O
strcmp	function
(	O
D_IM	O
,	O
D_EI	O
)	O
)	O
AddCStr	function
(	O
D_EI	O
)	O
;	O
D_insert	O
=	O
0	int
;	O
if	O
(	O
D_KS	O
&&	O
strcmp	function
(	O
D_KS	O
,	O
D_KE	O
)	O
)	O
AddCStr	function
(	O
D_KS	O
)	O
;	O
if	O
(	O
D_CCS	O
&&	O
strcmp	function
(	O
D_CCS	O
,	O
D_CCE	O
)	O
)	O
AddCStr	function
(	O
D_CCS	O
)	O
;	O
AddCStr	function
(	O
D_CE0	O
)	O
;	O
D_rend	O
=	O
mchar_null	struct
;	O
D_atyp	O
=	O
0	int
;	O
AddCStr	function
(	O
D_DS	O
)	O
;	O
D_hstatus	O
=	O
0	int
;	O
AddCStr	function
(	O
D_VE	O
)	O
;	O
D_curvis	O
=	O
0	int
;	O
ChangeScrollRegion	function
(	O
oldtop	int
,	O
oldbot	int
)	O
;	O
SetRendition	function
(	O
&	O
oldrend	struct
)	O
;	O
KeypadMode	function
(	O
oldkeypad	int
)	O
;	O
CursorkeysMode	function
(	O
oldcursorkeys	int
)	O
;	O
CursorVisibility	function
(	O
oldcurvis	int
)	O
;	O
MouseMode	function
(	O
oldmouse	int
)	O
;	O
ExtMouseMode	function
(	O
oldextmouse	int
)	O
;	O
if	O
(	O
D_CWS	O
)	O
{	O
debug	O
(	O
"ResizeDisplay: using WS\n"	pointer
)	O
;	O
AddCStr	function
(	O
tgoto	function
(	O
D_CWS	O
,	O
D_width	O
,	O
D_height	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
D_CZ0	O
&&	O
(	O
D_width	O
==	O
Z0width	int
||	O
D_width	O
==	O
Z1width	int
)	O
)	O
{	O
debug	O
(	O
"ResizeDisplay: using Z0/Z1\n"	pointer
)	O
;	O
AddCStr	function
(	O
D_width	O
==	O
Z0width	int
?	O
D_CZ0	O
:	O
D_CZ1	O
)	O
;	O
}	O
}	O
static	O
void	O
disp_writeev_eagain	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
evdeq	function
(	O
&	O
D_writeev	O
)	O
;	O
D_writeev	O
.	O
type	enum
=	O
EV_WRITE	int
;	O
D_writeev	O
.	O
handler	pointer
=	O
disp_writeev_fn	function
;	O
evenq	function
(	O
&	O
D_writeev	O
)	O
;	O
}	O
static	O
void	O
disp_writeev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
len	int
,	O
size	int
=	O
OUTPUT_BLOCK_SIZE	int
;	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
len	int
=	O
D_obufp	O
-	O
D_obuf	O
;	O
if	O
(	O
len	int
<	O
size	int
)	O
size	int
=	O
len	int
;	O
if	O
(	O
D_status_obufpos	O
&&	O
size	int
>	O
D_status_obufpos	O
)	O
size	int
=	O
D_status_obufpos	O
;	O
ASSERT	O
(	O
len	int
>=	O
0	int
)	O
;	O
size	int
=	O
write	pointer
(	O
D_userfd	O
,	O
D_obuf	O
,	O
size	int
)	O
;	O
if	O
(	O
size	int
>=	O
0	int
)	O
{	O
len	int
-=	O
size	int
;	O
if	O
(	O
len	int
)	O
{	O
bcopy	function
(	O
D_obuf	O
+	O
size	int
,	O
D_obuf	O
,	O
len	int
)	O
;	O
debug2	O
(	O
"ASYNC: wrote %d - remaining %d\n"	pointer
,	O
size	int
,	O
len	int
)	O
;	O
}	O
D_obufp	O
-=	O
size	int
;	O
D_obuffree	O
+=	O
size	int
;	O
if	O
(	O
D_status_obufpos	O
)	O
{	O
D_status_obufpos	O
-=	O
size	int
;	O
if	O
(	O
!	O
D_status_obufpos	O
)	O
{	O
debug	O
(	O
"finished writing the status message\n"	pointer
)	O
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
)	O
{	O
D_status_obuflen	O
=	O
D_obuflen	O
;	O
D_status_obuffree	O
=	O
D_obuffree	O
;	O
D_obuffree	O
=	O
D_obuflen	O
=	O
0	int
;	O
}	O
gettimeofday	function
(	O
&	O
D_status_time	O
,	O
NULL	O
)	O
;	O
SetTimeout	function
(	O
&	O
D_statusev	O
,	O
MsgWait	int
)	O
;	O
evenq	function
(	O
&	O
D_statusev	O
)	O
;	O
}	O
}	O
if	O
(	O
D_blocked_fuzz	O
)	O
{	O
D_blocked_fuzz	O
-=	O
size	int
;	O
if	O
(	O
D_blocked_fuzz	O
<	O
0	int
)	O
D_blocked_fuzz	O
=	O
0	int
;	O
}	O
if	O
(	O
D_blockedev	O
.	O
queued	int
)	O
{	O
if	O
(	O
D_obufp	O
-	O
D_obuf	O
>	O
D_obufmax	O
/	O
2	int
)	O
{	O
debug2	O
(	O
"%s: resetting timeout to %g secs\n"	pointer
,	O
D_usertty	O
,	O
D_nonblock	O
/	O
1000.	int
)	O
;	O
SetTimeout	function
(	O
&	O
D_blockedev	O
,	O
D_nonblock	O
)	O
;	O
}	O
else	O
{	O
debug1	O
(	O
"%s: deleting blocked timeout\n"	pointer
,	O
D_usertty	O
)	O
;	O
evdeq	function
(	O
&	O
D_blockedev	O
)	O
;	O
}	O
}	O
if	O
(	O
D_blocked	O
==	O
1	int
&&	O
D_obuf	O
==	O
D_obufp	O
)	O
{	O
debug1	O
(	O
"%s: buffer empty, unblocking\n"	pointer
,	O
D_usertty	O
)	O
;	O
D_blocked	O
=	O
0	int
;	O
Activate	function
(	O
D_fore	O
?	O
D_fore	O
->	O
w_norefresh	char
:	O
0	int
)	O
;	O
D_blocked_fuzz	O
=	O
D_obufp	O
-	O
D_obuf	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
errno	O
==	O
EAGAIN	int
)	O
{	O
evdeq	function
(	O
&	O
D_writeev	O
)	O
;	O
D_writeev	O
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
D_writeev	O
.	O
handler	pointer
=	O
disp_writeev_eagain	function
;	O
SetTimeout	function
(	O
&	O
D_writeev	O
,	O
100	int
)	O
;	O
evenq	function
(	O
&	O
D_writeev	O
)	O
;	O
}	O
if	O
(	O
errno	O
!=	O
EINTR	int
&&	O
errno	O
!=	O
EAGAIN	int
)	O
Msg	function
(	O
errno	O
,	O
"Error writing output to display"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
disp_readev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
size	int
;	O
char	O
bufspace	array
[	O
MAX_MOUSE_SEQUENCE	O
+	O
IOSIZE	int
]	O
;	O
unsigned	O
char	O
*	O
buf	pointer
=	O
bufspace	array
+	O
MAX_MOUSE_SEQUENCE	O
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
D_forecv	O
)	O
for	O
(	O
cv	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
)	O
RemoveStatus	function
(	O
)	O
;	O
}	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
D_fore	O
==	O
0	int
)	O
size	int
=	O
IOSIZE	int
;	O
else	O
{	O
if	O
(	O
W_UWP	O
(	O
D_fore	O
)	O
)	O
size	int
=	O
sizeof	O
(	O
D_fore	O
->	O
w_pwin	pointer
->	O
p_inbuf	array
)	O
-	O
D_fore	O
->	O
w_pwin	pointer
->	O
p_inlen	int
;	O
else	O
size	int
=	O
sizeof	O
(	O
D_fore	O
->	O
w_inbuf	array
)	O
-	O
D_fore	O
->	O
w_inlen	int
;	O
}	O
if	O
(	O
size	int
>	O
IOSIZE	int
)	O
size	int
=	O
IOSIZE	int
;	O
if	O
(	O
size	int
<=	O
0	int
)	O
size	int
=	O
1	int
;	O
size	int
=	O
read	pointer
(	O
D_userfd	O
,	O
buf	pointer
,	O
size	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
||	O
errno	O
==	O
EAGAIN	int
)	O
return	O
;	O
debug1	O
(	O
"Read error: %d - hangup!\n"	pointer
,	O
errno	O
)	O
;	O
Hangup	function
(	O
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
size	int
==	O
0	int
)	O
{	O
debug	O
(	O
"Found EOF - hangup!\n"	pointer
)	O
;	O
Hangup	function
(	O
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
D_blocked	O
==	O
4	int
)	O
{	O
D_blocked	O
=	O
0	int
;	O
KillBlanker	function
(	O
)	O
;	O
Activate	function
(	O
D_fore	O
?	O
D_fore	O
->	O
w_norefresh	char
:	O
0	int
)	O
;	O
ResetIdle	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
D_blocked	O
>	O
1	int
)	O
{	O
char	O
*	O
bufp	pointer
;	O
struct	O
win	struct
*	O
p	pointer
;	O
flayer	pointer
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
if	O
(	O
p	pointer
->	O
w_zdisplay	pointer
==	O
display	struct
)	O
{	O
flayer	pointer
=	O
&	O
p	pointer
->	O
w_layer	struct
;	O
bufp	pointer
=	O
buf	pointer
;	O
while	O
(	O
size	int
>	O
0	int
)	O
LayProcess	O
(	O
&	O
bufp	pointer
,	O
&	O
size	int
)	O
;	O
return	O
;	O
}	O
debug	O
(	O
"zmodem window gone, deblocking display"	pointer
)	O
;	O
zmodem_abort	function
(	O
0	int
,	O
display	struct
)	O
;	O
}	O
if	O
(	O
idletimo	int
>	O
0	int
)	O
ResetIdle	function
(	O
)	O
;	O
if	O
(	O
D_fore	O
)	O
D_fore	O
->	O
w_lastdisp	pointer
=	O
display	struct
;	O
if	O
(	O
D_mouse	O
&&	O
D_forecv	O
)	O
{	O
unsigned	O
char	O
*	O
bp	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
;	O
unsigned	O
char	O
*	O
end	pointer
=	O
bp	pointer
+	O
size	int
;	O
unsigned	O
char	O
*	O
mark	pointer
=	O
NULL	O
;	O
switch	O
(	O
D_mouse_parse	O
.	O
state	pointer
)	O
{	O
case	O
CSI_PY	int
:	O
case	O
CSI_PX	int
:	O
case	O
CSI_PB	int
:	O
break	O
;	O
case	O
CSI_BEGIN	int
:	O
*	O
(	O
--	O
buf	pointer
)	O
=	O
'['	O
;	O
++	O
size	int
;	O
case	O
CSI_ESC_SEEN	int
:	O
*	O
(	O
--	O
buf	pointer
)	O
=	O
'\033'	O
;	O
++	O
size	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
;	O
while	O
(	O
bp	pointer
!=	O
end	pointer
)	O
{	O
unsigned	O
char	O
c	int
=	O
*	O
(	O
bp	pointer
++	O
)	O
;	O
switch	O
(	O
D_mouse_parse	O
.	O
state	pointer
)	O
{	O
case	O
CSI_INACTIVE	int
:	O
if	O
(	O
c	int
==	O
'\033'	O
)	O
{	O
mark	pointer
=	O
bp	pointer
-	O
1	int
;	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_ESC_SEEN	int
;	O
}	O
break	O
;	O
case	O
CSI_ESC_SEEN	int
:	O
if	O
(	O
c	int
==	O
'['	O
)	O
{	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_BEGIN	int
;	O
}	O
else	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_INACTIVE	int
;	O
break	O
;	O
case	O
CSI_BEGIN	int
:	O
if	O
(	O
c	int
==	O
'M'	O
)	O
{	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_PB	int
;	O
D_mouse_parse	O
.	O
sgrmode	char
=	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'<'	O
)	O
{	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_PB	int
;	O
D_mouse_parse	O
.	O
params	array
[	O
D_mouse_parse	O
.	O
state	pointer
]	O
=	O
0	int
;	O
D_mouse_parse	O
.	O
sgrmode	char
=	O
1	int
;	O
}	O
else	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_INACTIVE	int
;	O
break	O
;	O
case	O
CSI_PB	int
:	O
case	O
CSI_PX	int
:	O
case	O
CSI_PY	int
:	O
if	O
(	O
D_mouse_parse	O
.	O
sgrmode	char
)	O
{	O
if	O
(	O
'0'	O
<=	O
c	int
&&	O
c	int
<=	O
'9'	O
)	O
{	O
D_mouse_parse	O
.	O
params	array
[	O
D_mouse_parse	O
.	O
state	pointer
]	O
*=	O
10	int
;	O
D_mouse_parse	O
.	O
params	array
[	O
D_mouse_parse	O
.	O
state	pointer
]	O
+=	O
c	int
-	O
'0'	O
;	O
}	O
else	O
if	O
(	O
D_mouse_parse	O
.	O
state	pointer
==	O
CSI_PY	int
)	O
{	O
if	O
(	O
c	int
==	O
'M'	O
||	O
c	int
==	O
'm'	O
)	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_DONE	int
;	O
else	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_INVALID	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
';'	O
)	O
{	O
D_mouse_parse	O
.	O
state	pointer
++	O
;	O
D_mouse_parse	O
.	O
params	array
[	O
D_mouse_parse	O
.	O
state	pointer
]	O
=	O
0	int
;	O
}	O
else	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_INVALID	int
;	O
}	O
else	O
{	O
D_mouse_parse	O
.	O
params	array
[	O
D_mouse_parse	O
.	O
state	pointer
++	O
]	O
=	O
c	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
D_mouse_parse	O
.	O
state	pointer
==	O
CSI_INVALID	int
)	O
{	O
if	O
(	O
buf	pointer
<	O
mark	pointer
)	O
disp_processinput	function
(	O
display	struct
,	O
buf	pointer
,	O
mark	pointer
-	O
buf	pointer
)	O
;	O
buf	pointer
=	O
bp	pointer
;	O
size	int
=	O
end	pointer
-	O
bp	pointer
;	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_INACTIVE	int
;	O
}	O
else	O
if	O
(	O
D_mouse_parse	O
.	O
state	pointer
==	O
CSI_DONE	int
)	O
{	O
if	O
(	O
buf	pointer
<	O
mark	pointer
)	O
disp_processinput	function
(	O
display	struct
,	O
buf	pointer
,	O
mark	pointer
-	O
buf	pointer
)	O
;	O
buf	pointer
=	O
bp	pointer
;	O
size	int
=	O
end	pointer
-	O
bp	pointer
;	O
int	O
x	int
=	O
D_mouse_parse	O
.	O
params	array
[	O
CSI_PX	int
]	O
;	O
int	O
y	int
=	O
D_mouse_parse	O
.	O
params	array
[	O
CSI_PY	int
]	O
;	O
int	O
bias	int
=	O
D_mouse_parse	O
.	O
sgrmode	char
?	O
1	int
:	O
33	int
;	O
x	int
-=	O
bias	int
;	O
y	int
-=	O
bias	int
;	O
if	O
(	O
x	int
>=	O
D_forecv	O
->	O
c_xs	int
&&	O
x	int
<=	O
D_forecv	O
->	O
c_xe	int
&&	O
y	int
>=	O
D_forecv	O
->	O
c_ys	int
&&	O
y	int
<=	O
D_forecv	O
->	O
c_ye	int
)	O
{	O
if	O
(	O
(	O
D_fore	O
&&	O
D_fore	O
->	O
w_mouse	int
)	O
||	O
(	O
D_mousetrack	O
&&	O
D_forecv	O
->	O
c_layer	pointer
->	O
l_mode	int
==	O
1	int
)	O
)	O
{	O
x	int
-=	O
D_forecv	O
->	O
c_xoff	int
;	O
y	int
-=	O
D_forecv	O
->	O
c_yoff	int
;	O
if	O
(	O
x	int
>=	O
0	int
&&	O
x	int
<	O
D_forecv	O
->	O
c_layer	pointer
->	O
l_width	int
&&	O
y	int
>=	O
0	int
&&	O
y	int
<	O
D_forecv	O
->	O
c_layer	pointer
->	O
l_height	int
)	O
{	O
char	O
tmp	array
[	O
MAX_MOUSE_SEQUENCE	O
+	O
1	int
]	O
;	O
int	O
n	int
;	O
x	int
+=	O
bias	int
;	O
y	int
+=	O
bias	int
;	O
if	O
(	O
D_mouse_parse	O
.	O
sgrmode	char
)	O
{	O
n	int
=	O
snprintf	function
(	O
tmp	array
,	O
MAX_MOUSE_SEQUENCE	O
,	O
"\033[<%d;%d;%d%c"	pointer
,	O
D_mouse_parse	O
.	O
params	array
[	O
CSI_PB	int
]	O
,	O
x	int
,	O
y	int
,	O
c	int
)	O
;	O
}	O
else	O
{	O
n	int
=	O
snprintf	function
(	O
tmp	array
,	O
MAX_MOUSE_SEQUENCE	O
,	O
"\033[M%c%c%c"	pointer
,	O
D_mouse_parse	O
.	O
params	array
[	O
CSI_PB	int
]	O
,	O
x	int
,	O
y	int
)	O
;	O
}	O
if	O
(	O
n	int
>	O
MAX_MOUSE_SEQUENCE	O
)	O
n	int
=	O
MAX_MOUSE_SEQUENCE	O
;	O
buf	pointer
-=	O
n	int
;	O
size	int
+=	O
n	int
;	O
memcpy	function
(	O
buf	pointer
,	O
tmp	array
,	O
n	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
D_mousetrack	O
)	O
{	O
int	O
focus	int
=	O
0	int
;	O
if	O
(	O
D_mouse_parse	O
.	O
sgrmode	char
)	O
focus	int
=	O
(	O
c	int
==	O
'm'	O
)	O
;	O
else	O
focus	int
=	O
(	O
D_mouse_parse	O
.	O
params	array
[	O
CSI_PB	int
]	O
==	O
'#'	O
)	O
;	O
struct	O
canvas	struct
*	O
cv	pointer
=	O
FindCanvas	function
(	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
focus	int
&&	O
cv	pointer
)	O
{	O
SetForeCanvas	function
(	O
display	struct
,	O
cv	pointer
)	O
;	O
}	O
}	O
D_mouse_parse	O
.	O
state	pointer
=	O
CSI_INACTIVE	int
;	O
}	O
}	O
if	O
(	O
D_mouse_parse	O
.	O
state	pointer
!=	O
CSI_INACTIVE	int
)	O
{	O
size	int
=	O
mark	pointer
?	O
mark	pointer
-	O
buf	pointer
:	O
0	int
;	O
}	O
}	O
if	O
(	O
size	int
>	O
0	int
)	O
disp_processinput	function
(	O
display	struct
,	O
buf	pointer
,	O
size	int
)	O
;	O
}	O
static	O
void	O
disp_processinput	function
(	O
display	struct
,	O
buf	pointer
,	O
size	int
)	O
struct	O
display	struct
*	O
display	struct
;	O
unsigned	O
char	O
*	O
buf	pointer
;	O
int	O
size	int
;	O
{	O
if	O
(	O
D_encoding	O
!=	O
(	O
D_forecv	O
?	O
D_forecv	O
->	O
c_layer	pointer
->	O
l_encoding	int
:	O
0	int
)	O
)	O
{	O
int	O
i	int
,	O
j	int
,	O
c	int
,	O
enc	int
;	O
char	O
buf2	array
[	O
IOSIZE	int
*	O
2	int
+	O
10	int
]	O
;	O
enc	int
=	O
D_forecv	O
?	O
D_forecv	O
->	O
c_layer	pointer
->	O
l_encoding	int
:	O
0	int
;	O
for	O
(	O
i	int
=	O
j	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
c	int
=	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
)	O
[	O
i	int
]	O
;	O
c	int
=	O
DecodeChar	function
(	O
c	int
,	O
D_encoding	O
,	O
&	O
D_decodestate	O
)	O
;	O
if	O
(	O
c	int
==	O
-	O
2	int
)	O
i	int
--	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
pastefont	int
)	O
{	O
int	O
font	char
=	O
0	int
;	O
j	int
+=	O
EncodeChar	function
(	O
buf2	array
+	O
j	int
,	O
c	int
,	O
enc	int
,	O
&	O
font	char
)	O
;	O
j	int
+=	O
EncodeChar	function
(	O
buf2	array
+	O
j	int
,	O
-	O
1	int
,	O
enc	int
,	O
&	O
font	char
)	O
;	O
}	O
else	O
j	int
+=	O
EncodeChar	function
(	O
buf2	array
+	O
j	int
,	O
c	int
,	O
enc	int
,	O
0	int
)	O
;	O
if	O
(	O
j	int
>	O
(	O
int	O
)	O
sizeof	O
(	O
buf2	array
)	O
-	O
10	int
)	O
break	O
;	O
}	O
(	O
*	O
D_processinput	O
)	O
(	O
buf2	array
,	O
j	int
)	O
;	O
return	O
;	O
}	O
(	O
*	O
D_processinput	O
)	O
(	O
buf	pointer
,	O
size	int
)	O
;	O
}	O
static	O
void	O
disp_status_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
debug1	O
(	O
"disp_status_fn for display %x\n"	pointer
,	O
(	O
int	O
)	O
display	struct
)	O
;	O
if	O
(	O
D_status	O
)	O
RemoveStatus	function
(	O
)	O
;	O
}	O
static	O
void	O
disp_hstatus_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_HS	int
)	O
{	O
SetTimeout	function
(	O
ev	pointer
,	O
1	int
)	O
;	O
evenq	function
(	O
ev	pointer
)	O
;	O
return	O
;	O
}	O
RefreshHStatus	function
(	O
)	O
;	O
}	O
static	O
void	O
disp_blocked_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
;	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
debug1	O
(	O
"blocked timeout %s\n"	pointer
,	O
D_usertty	O
)	O
;	O
if	O
(	O
D_obufp	O
-	O
D_obuf	O
>	O
D_obufmax	O
+	O
D_blocked_fuzz	O
)	O
{	O
debug	O
(	O
"stopping output to display\n"	pointer
)	O
;	O
D_blocked	O
=	O
1	int
;	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
if	O
(	O
p	pointer
->	O
w_readev	struct
.	O
condneg	pointer
==	O
&	O
D_obuflenmax	O
)	O
{	O
debug1	O
(	O
"freeing window #%d\n"	pointer
,	O
p	pointer
->	O
w_number	int
)	O
;	O
p	pointer
->	O
w_readev	struct
.	O
condpos	pointer
=	O
p	pointer
->	O
w_readev	struct
.	O
condneg	pointer
=	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
disp_map_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
char	O
*	O
p	pointer
;	O
int	O
l	pointer
,	O
i	int
;	O
unsigned	O
char	O
*	O
q	pointer
;	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
debug	O
(	O
"Flushing map sequence\n"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
l	pointer
=	O
D_seql	O
)	O
)	O
return	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
D_seqp	O
-	O
l	pointer
;	O
D_seqp	O
=	O
D_kmaps	O
+	O
3	int
;	O
D_seql	O
=	O
0	int
;	O
if	O
(	O
(	O
q	pointer
=	O
D_seqh	O
)	O
!=	O
0	int
)	O
{	O
D_seqh	O
=	O
0	int
;	O
i	int
=	O
q	pointer
[	O
0	int
]	O
<<	O
8	int
|	O
q	pointer
[	O
1	int
]	O
;	O
i	int
&=	O
~	O
KMAP_NOTIMEOUT	int
;	O
debug1	O
(	O
"Mapping former hit #%d - "	pointer
,	O
i	int
)	O
;	O
debug2	O
(	O
"%d(%s) - "	pointer
,	O
q	pointer
[	O
2	int
]	O
,	O
q	pointer
+	O
3	int
)	O
;	O
if	O
(	O
StuffKey	function
(	O
i	int
)	O
)	O
ProcessInput2	function
(	O
(	O
char	O
*	O
)	O
q	pointer
+	O
3	int
,	O
q	pointer
[	O
2	int
]	O
)	O
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
l	pointer
-=	O
q	pointer
[	O
2	int
]	O
;	O
p	pointer
+=	O
q	pointer
[	O
2	int
]	O
;	O
}	O
else	O
D_dontmap	O
=	O
1	int
;	O
ProcessInput	function
(	O
p	pointer
,	O
l	pointer
)	O
;	O
}	O
static	O
void	O
disp_idle_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
;	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
debug	O
(	O
"idle timeout\n"	pointer
)	O
;	O
if	O
(	O
idletimo	int
<=	O
0	int
||	O
idleaction	struct
.	O
nr	int
==	O
RC_ILLEGAL	O
)	O
return	O
;	O
olddisplay	pointer
=	O
display	struct
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
fore	pointer
=	O
D_fore	O
;	O
DoAction	function
(	O
&	O
idleaction	struct
,	O
-	O
1	int
)	O
;	O
if	O
(	O
idleaction	struct
.	O
nr	int
==	O
RC_BLANKER	int
)	O
return	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
if	O
(	O
olddisplay	pointer
==	O
display	struct
)	O
break	O
;	O
if	O
(	O
display	struct
)	O
ResetIdle	function
(	O
)	O
;	O
}	O
void	O
ResetIdle	function
(	O
)	O
{	O
if	O
(	O
idletimo	int
>	O
0	int
)	O
{	O
SetTimeout	function
(	O
&	O
D_idleev	O
,	O
idletimo	int
)	O
;	O
if	O
(	O
!	O
D_idleev	O
.	O
queued	int
)	O
evenq	function
(	O
&	O
D_idleev	O
)	O
;	O
}	O
else	O
evdeq	function
(	O
&	O
D_idleev	O
)	O
;	O
}	O
static	O
void	O
disp_blanker_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
char	O
buf	pointer
[	O
IOSIZE	int
]	O
,	O
*	O
b	pointer
;	O
int	O
size	int
;	O
display	struct
=	O
(	O
struct	O
display	struct
*	O
)	O
data	pointer
;	O
size	int
=	O
read	pointer
(	O
D_blankerev	O
.	O
fd	int
,	O
buf	pointer
,	O
IOSIZE	int
)	O
;	O
if	O
(	O
size	int
<=	O
0	int
)	O
{	O
evdeq	function
(	O
&	O
D_blankerev	O
)	O
;	O
close	pointer
(	O
D_blankerev	O
.	O
fd	int
)	O
;	O
D_blankerev	O
.	O
fd	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
for	O
(	O
b	pointer
=	O
buf	pointer
;	O
size	int
;	O
size	int
--	O
)	O
AddChar	O
(	O
*	O
b	pointer
++	O
)	O
;	O
}	O
void	O
KillBlanker	function
(	O
)	O
{	O
int	O
oldtop	int
=	O
D_top	O
,	O
oldbot	int
=	O
D_bot	O
;	O
struct	O
mchar	struct
oldrend	struct
;	O
if	O
(	O
D_blankerev	O
.	O
fd	int
==	O
-	O
1	int
)	O
return	O
;	O
if	O
(	O
D_blocked	O
==	O
4	int
)	O
D_blocked	O
=	O
0	int
;	O
evdeq	function
(	O
&	O
D_blankerev	O
)	O
;	O
close	pointer
(	O
D_blankerev	O
.	O
fd	int
)	O
;	O
D_blankerev	O
.	O
fd	int
=	O
-	O
1	int
;	O
Kill	function
(	O
D_blankerpid	O
,	O
SIGHUP	int
)	O
;	O
D_top	O
=	O
D_bot	O
=	O
-	O
1	int
;	O
oldrend	struct
=	O
D_rend	O
;	O
if	O
(	O
D_ME	O
)	O
{	O
AddCStr	function
(	O
D_ME	O
)	O
;	O
AddCStr	function
(	O
D_ME	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
D_hascolor	O
)	O
AddStr	function
(	O
"\033[m\033[m"	pointer
)	O
;	O
AddCStr	function
(	O
D_SE	O
)	O
;	O
AddCStr	function
(	O
D_UE	O
)	O
;	O
}	O
AddCStr	function
(	O
D_VE	O
)	O
;	O
AddCStr	function
(	O
D_CE0	O
)	O
;	O
D_rend	O
=	O
mchar_null	struct
;	O
D_atyp	O
=	O
0	int
;	O
D_curvis	O
=	O
0	int
;	O
D_x	O
=	O
D_y	O
=	O
-	O
1	int
;	O
ChangeScrollRegion	function
(	O
oldtop	int
,	O
oldbot	int
)	O
;	O
SetRendition	function
(	O
&	O
oldrend	struct
)	O
;	O
ClearAll	function
(	O
)	O
;	O
}	O
void	O
RunBlanker	function
(	O
cmdv	pointer
)	O
char	O
*	O
*	O
cmdv	pointer
;	O
{	O
char	O
*	O
m	union
;	O
int	O
pid	int
;	O
int	O
slave	int
=	O
-	O
1	int
;	O
int	O
ptype	int
=	O
0	int
;	O
char	O
termname	array
[	O
MAXTERMLEN	int
+	O
6	int
]	O
;	O
char	O
*	O
*	O
np	pointer
;	O
strcpy	function
(	O
termname	array
,	O
"TERM="	pointer
)	O
;	O
strncpy	function
(	O
termname	array
+	O
5	int
,	O
D_termname	O
,	O
MAXTERMLEN	int
-	O
6	int
)	O
;	O
termname	array
[	O
sizeof	O
(	O
termname	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
KillBlanker	function
(	O
)	O
;	O
D_blankerpid	O
=	O
-	O
1	int
;	O
if	O
(	O
(	O
D_blankerev	O
.	O
fd	int
=	O
OpenDevice	function
(	O
cmdv	pointer
,	O
0	int
,	O
&	O
ptype	int
,	O
&	O
m	union
)	O
)	O
==	O
-	O
1	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"OpenDevice failed"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pty_preopen	int
)	O
{	O
if	O
(	O
(	O
slave	int
=	O
open	function
(	O
m	union
,	O
O_RDWR	int
|	O
O_NOCTTY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"%s"	pointer
,	O
m	union
)	O
;	O
close	pointer
(	O
D_blankerev	O
.	O
fd	int
)	O
;	O
D_blankerev	O
.	O
fd	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
}	O
switch	O
(	O
pid	int
=	O
(	O
int	O
)	O
fork	function
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
Msg	function
(	O
errno	O
,	O
"fork"	pointer
)	O
;	O
close	pointer
(	O
D_blankerev	O
.	O
fd	int
)	O
;	O
D_blankerev	O
.	O
fd	int
=	O
-	O
1	int
;	O
close	pointer
(	O
slave	int
)	O
;	O
return	O
;	O
case	O
0	int
:	O
displays	pointer
=	O
0	int
;	O
ServerSocket	int
=	O
-	O
1	int
;	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
if	O
(	O
setgid	function
(	O
real_gid	int
)	O
||	O
setuid	function
(	O
real_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"setuid/setgid"	pointer
)	O
;	O
eff_uid	int
=	O
real_uid	int
;	O
eff_gid	int
=	O
real_gid	int
;	O
brktty	function
(	O
D_userfd	O
)	O
;	O
freetty	function
(	O
)	O
;	O
if	O
(	O
slave	int
!=	O
-	O
1	int
)	O
{	O
close	pointer
(	O
0	int
)	O
;	O
dup	function
(	O
slave	int
)	O
;	O
close	pointer
(	O
slave	int
)	O
;	O
closeallfiles	function
(	O
D_blankerev	O
.	O
fd	int
)	O
;	O
slave	int
=	O
dup	function
(	O
0	int
)	O
;	O
}	O
else	O
closeallfiles	function
(	O
D_blankerev	O
.	O
fd	int
)	O
;	O
close	pointer
(	O
0	int
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
close	pointer
(	O
2	int
)	O
;	O
if	O
(	O
open	function
(	O
m	union
,	O
O_RDWR	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"Cannot open %s"	pointer
,	O
m	union
)	O
;	O
dup	function
(	O
0	int
)	O
;	O
dup	function
(	O
0	int
)	O
;	O
close	pointer
(	O
D_blankerev	O
.	O
fd	int
)	O
;	O
if	O
(	O
slave	int
!=	O
-	O
1	int
)	O
close	pointer
(	O
slave	int
)	O
;	O
InitPTY	function
(	O
0	int
)	O
;	O
fgtty	function
(	O
0	int
)	O
;	O
SetTTY	function
(	O
0	int
,	O
&	O
D_OldMode	O
)	O
;	O
np	pointer
=	O
NewEnv	pointer
+	O
3	int
;	O
*	O
np	pointer
++	O
=	O
NewEnv	pointer
[	O
0	int
]	O
;	O
*	O
np	pointer
++	O
=	O
termname	array
;	O
glwz	struct
.	O
ws_col	short
=	O
D_width	O
;	O
glwz	struct
.	O
ws_row	short
=	O
D_height	O
;	O
(	O
void	O
)	O
ioctl	function
(	O
0	int
,	O
TIOCSWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
glwz	struct
)	O
;	O
debug1	O
(	O
"calling execvpe %s\n"	pointer
,	O
*	O
cmdv	pointer
)	O
;	O
execvpe	function
(	O
*	O
cmdv	pointer
,	O
cmdv	pointer
,	O
NewEnv	pointer
+	O
3	int
)	O
;	O
debug1	O
(	O
"exec error: %d\n"	pointer
,	O
errno	O
)	O
;	O
Panic	function
(	O
errno	O
,	O
"Cannot exec '%s'"	pointer
,	O
*	O
cmdv	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
D_blankerpid	O
=	O
pid	int
;	O
evenq	function
(	O
&	O
D_blankerev	O
)	O
;	O
D_blocked	O
=	O
4	int
;	O
ClearAll	function
(	O
)	O
;	O
close	pointer
(	O
slave	int
)	O
;	O
}	O
