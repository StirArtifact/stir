enum	O
rw_yytokentype	enum
{	O
TYPE	int
=	O
258	int
,	O
IF	int
=	O
259	int
,	O
ELSE	int
=	O
260	int
,	O
RETURN	int
=	O
261	int
,	O
WHILE	int
=	O
262	int
,	O
FOR	int
=	O
263	int
,	O
DO	int
=	O
264	int
,	O
BREAK	int
=	O
265	int
,	O
CONTINUE	int
=	O
266	int
,	O
DELETE	int
=	O
267	int
,	O
STRING	int
=	O
268	int
,	O
IDENT	int
=	O
269	int
,	O
NUMBER	int
=	O
270	int
,	O
REFERENCE	int
=	O
271	int
,	O
VARIABLE	int
=	O
272	int
,	O
FUN	int
=	O
273	int
,	O
BUILTIN	int
=	O
274	int
,	O
ATTR	int
=	O
275	int
,	O
BOGUS	int
=	O
276	int
,	O
OR	int
=	O
277	int
,	O
AND	int
=	O
278	int
,	O
NM	int
=	O
279	int
,	O
MT	int
=	O
280	int
,	O
NE	int
=	O
281	int
,	O
EQ	int
=	O
282	int
,	O
GE	int
=	O
283	int
,	O
GT	int
=	O
284	int
,	O
LE	int
=	O
285	int
,	O
LT	int
=	O
286	int
,	O
SHR	int
=	O
287	int
,	O
SHL	int
=	O
288	int
,	O
TYPECAST	int
=	O
289	int
,	O
NOT	int
=	O
290	int
,	O
UMINUS	int
=	O
291	int
}	O
;	O
typedef	O
long	O
RWSTYPE	long
;	O
typedef	O
struct	O
rw_list	struct
RWLIST	struct
;	O
struct	O
rw_list	struct
{	O
RWLIST	struct
(	O
RWLIST	struct
)	O
;	O
}	O
;	O
typedef	O
struct	O
object_t	struct
OBJECT	struct
;	O
struct	O
object_t	struct
{	O
OBJ	O
(	O
OBJECT	struct
)	O
;	O
}	O
;	O
typedef	O
struct	O
{	O
size_t	long
size	int
;	O
void	O
(	O
*	O
free	pointer
)	O
(	O
)	O
;	O
OBJECT	struct
*	O
alloc_list	pointer
;	O
}	O
OBUCKET	struct
;	O
typedef	O
int	O
stkoff_t	int
;	O
typedef	O
unsigned	O
int	O
pctr_t	int
;	O
typedef	O
struct	O
{	O
RWSTYPE	long
reg	array
[	O
RW_REG	O
]	O
;	O
char	O
*	O
sA	pointer
;	O
pctr_t	int
pc	int
;	O
RWSTYPE	long
*	O
stack	pointer
;	O
int	O
stacksize	int
;	O
int	O
st	int
;	O
int	O
sb	int
;	O
int	O
ht	int
;	O
int	O
nmatch	int
;	O
regmatch_t	struct
*	O
pmatch	pointer
;	O
grad_request_t	struct
*	O
req	pointer
;	O
jmp_buf	array
jmp	array
;	O
}	O
RWMACH	struct
;	O
typedef	O
void	O
(	O
*	O
INSTR	pointer
)	O
(	O
)	O
;	O
typedef	O
struct	O
comp_regex	struct
COMP_REGEX	struct
;	O
struct	O
comp_regex	struct
{	O
OBJ	O
(	O
COMP_REGEX	struct
)	O
;	O
regex_t	struct
regex	struct
;	O
int	O
nmatch	int
;	O
}	O
;	O
typedef	O
enum	O
{	O
Eq	int
,	O
Ne	int
,	O
Lt	int
,	O
Le	int
,	O
Gt	int
,	O
Ge	int
,	O
BAnd	int
,	O
BXor	int
,	O
BOr	int
,	O
And	int
,	O
Or	int
,	O
Shl	int
,	O
Shr	int
,	O
Add	int
,	O
Sub	int
,	O
Mul	int
,	O
Div	int
,	O
Rem	int
,	O
Max_opcode	int
}	O
Bopcode	enum
;	O
typedef	O
enum	O
{	O
Neg	int
,	O
Not	int
,	O
Max_unary	int
}	O
Uopcode	enum
;	O
typedef	O
enum	O
{	O
Generic	int
,	O
Nop	int
,	O
Enter	int
,	O
Leave	int
,	O
Stop	int
,	O
Constant	int
,	O
Matchref	int
,	O
Variable	int
,	O
Unary	int
,	O
Binary	int
,	O
Cond	int
,	O
Asgn	int
,	O
Match	int
,	O
Coercion	int
,	O
Expression	int
,	O
Return	int
,	O
Jump	int
,	O
Branch	int
,	O
Target	int
,	O
Call	int
,	O
Builtin	int
,	O
Pop	int
,	O
Pusha	int
,	O
Popa	int
,	O
Attr	int
,	O
Attr_asgn	int
,	O
Attr_check	int
,	O
Attr_delete	int
,	O
Max_mtxtype	int
}	O
Mtxtype	enum
;	O
typedef	O
struct	O
parm_t	struct
PARAMETER	struct
;	O
struct	O
parm_t	struct
{	O
PARAMETER	struct
*	O
prev	pointer
;	O
PARAMETER	struct
*	O
next	pointer
;	O
grad_data_type_t	enum
datatype	enum
;	O
stkoff_t	int
offset	long
;	O
}	O
;	O
typedef	O
struct	O
variable	struct
VAR	struct
;	O
struct	O
variable	struct
{	O
OBJ	O
(	O
VAR	struct
)	O
;	O
VAR	struct
*	O
dcllink	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
level	int
;	O
int	O
offset	long
;	O
grad_data_type_t	enum
datatype	enum
;	O
int	O
constant	long
;	O
grad_datum_t	union
datum	union
;	O
}	O
;	O
typedef	O
struct	O
function_def	struct
{	O
struct	O
function_def	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
grad_data_type_t	enum
rettype	enum
;	O
pctr_t	int
entry	int
;	O
COMP_REGEX	struct
*	O
rx_list	pointer
;	O
int	O
nparm	int
;	O
PARAMETER	struct
*	O
parm	pointer
;	O
stkoff_t	int
stack_alloc	int
;	O
grad_locus_t	struct
loc	struct
;	O
}	O
FUNCTION	struct
;	O
typedef	O
struct	O
{	O
INSTR	pointer
handler	pointer
;	O
char	O
*	O
name	pointer
;	O
grad_data_type_t	enum
rettype	enum
;	O
char	O
*	O
parms	pointer
;	O
}	O
builtin_t	struct
;	O
typedef	O
union	O
mtx	union
MTX	union
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
}	O
GEN_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
grad_datum_t	union
datum	union
;	O
}	O
CONST_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
int	O
num	int
;	O
}	O
MATCHREF_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
VAR	struct
*	O
var	pointer
;	O
}	O
VAR_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
Uopcode	enum
opcode	enum
;	O
MTX	union
*	O
arg	pointer
;	O
}	O
UN_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
Bopcode	enum
opcode	enum
;	O
MTX	union
*	O
arg	pointer
[	O
2	int
]	O
;	O
}	O
BIN_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
VAR	struct
*	O
lval	pointer
;	O
MTX	union
*	O
arg	pointer
;	O
}	O
ASGN_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
MTX	union
*	O
expr	pointer
;	O
MTX	union
*	O
if_true	pointer
;	O
MTX	union
*	O
if_false	pointer
;	O
}	O
COND_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
int	O
negated	int
;	O
MTX	union
*	O
arg	pointer
;	O
COMP_REGEX	struct
*	O
rx	pointer
;	O
}	O
MATCH_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
MTX	union
*	O
arg	pointer
;	O
}	O
COERCE_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
MTX	union
*	O
expr	pointer
;	O
}	O
EXPR_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
MTX	union
*	O
expr	pointer
;	O
}	O
RET_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
MTX	union
*	O
link	function
;	O
MTX	union
*	O
dest	pointer
;	O
}	O
JUMP_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
int	O
cond	int
;	O
MTX	union
*	O
dest	pointer
;	O
}	O
BRANCH_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
stkoff_t	int
stacksize	int
;	O
}	O
FRAME_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
pctr_t	int
pc	int
;	O
}	O
TGT_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_MTX	O
TGT_MTX	struct
*	O
tgt	pointer
;	O
pctr_t	int
pc	int
;	O
}	O
NOP_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
FUNCTION	struct
*	O
fun	pointer
;	O
int	O
nargs	int
;	O
MTX	union
*	O
args	pointer
;	O
}	O
CALL_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
INSTR	pointer
fun	pointer
;	O
int	O
nargs	int
;	O
MTX	union
*	O
args	pointer
;	O
}	O
BTIN_MTX	struct
;	O
typedef	O
struct	O
{	O
COMMON_EXPR_MTX	O
int	O
attrno	int
;	O
MTX	union
*	O
index	function
;	O
MTX	union
*	O
rval	pointer
;	O
}	O
ATTR_MTX	struct
;	O
union	O
mtx	union
{	O
GEN_MTX	struct
gen	struct
;	O
NOP_MTX	struct
nop	struct
;	O
FRAME_MTX	struct
frame	struct
;	O
CONST_MTX	struct
cnst	struct
;	O
MATCHREF_MTX	struct
ref	struct
;	O
VAR_MTX	struct
var	pointer
;	O
UN_MTX	struct
un	struct
;	O
BIN_MTX	struct
bin	struct
;	O
COND_MTX	struct
cond	int
;	O
ASGN_MTX	struct
asgn	struct
;	O
MATCH_MTX	struct
match	struct
;	O
COERCE_MTX	struct
coerce	struct
;	O
RET_MTX	struct
ret	struct
;	O
JUMP_MTX	struct
jump	struct
;	O
BRANCH_MTX	struct
branch	struct
;	O
TGT_MTX	struct
tgt	pointer
;	O
CALL_MTX	struct
call	struct
;	O
BTIN_MTX	struct
btin	struct
;	O
ATTR_MTX	struct
attr	pointer
;	O
}	O
;	O
typedef	O
struct	O
frame_t	struct
FRAME	struct
;	O
struct	O
frame_t	struct
{	O
OBJ	O
(	O
FRAME	struct
)	O
;	O
int	O
level	int
;	O
stkoff_t	int
stack_offset	int
;	O
}	O
;	O
static	O
OBUCKET	struct
frame_bkt	struct
=	O
{	O
sizeof	O
(	O
FRAME	struct
)	O
,	O
NULL	O
}	O
;	O
static	O
FRAME	struct
*	O
frame_first	pointer
,	O
*	O
frame_last	pointer
;	O
static	O
int	O
errcnt	long
;	O
static	O
FUNCTION	struct
*	O
function	pointer
;	O
static	O
grad_symtab_t	struct
*	O
rewrite_tab	pointer
;	O
static	O
MTX	union
*	O
mtx_first	pointer
,	O
*	O
mtx_last	pointer
;	O
static	O
VAR	struct
*	O
var_first	pointer
,	O
*	O
var_last	pointer
;	O
typedef	O
struct	O
loop_t	struct
LOOP	struct
;	O
struct	O
loop_t	struct
{	O
OBJ	O
(	O
LOOP	struct
)	O
;	O
JUMP_MTX	struct
*	O
lp_break	pointer
;	O
JUMP_MTX	struct
*	O
lp_cont	pointer
;	O
}	O
;	O
static	O
OBUCKET	struct
loop_bkt	struct
=	O
{	O
sizeof	O
(	O
LOOP	struct
)	O
,	O
NULL	O
}	O
;	O
static	O
LOOP	struct
*	O
loop_first	pointer
,	O
*	O
loop_last	pointer
;	O
void	O
loop_push	function
(	O
MTX	union
*	O
mtx	union
)	O
;	O
void	O
loop_pop	function
(	O
)	O
;	O
void	O
loop_fixup	function
(	O
JUMP_MTX	struct
*	O
list	pointer
,	O
MTX	union
*	O
target	pointer
)	O
;	O
void	O
loop_init	function
(	O
)	O
;	O
void	O
loop_free_all	function
(	O
)	O
;	O
void	O
loop_unwind_all	function
(	O
)	O
;	O
static	O
FILE	struct
*	O
infile	pointer
;	O
static	O
grad_locus_t	struct
locus	struct
;	O
static	O
char	O
*	O
inbuf	pointer
;	O
static	O
char	O
*	O
curp	pointer
;	O
static	O
int	O
rw_yyeof	int
;	O
static	O
struct	O
obstack	struct
input_stk	struct
;	O
static	O
grad_data_type_t	enum
return_type	enum
=	O
Undefined	int
;	O
static	O
int	O
regcomp_flags	int
=	O
0	int
;	O
static	O
size_t	long
rewrite_stack_size	long
=	O
4096	int
;	O
static	O
RWSTYPE	long
*	O
runtime_stack	pointer
;	O
static	O
RWMACH	struct
mach	struct
;	O
static	O
char	O
*	O
default_gettext_domain	pointer
;	O
static	O
int	O
rw_yylex	function
(	O
)	O
;	O
static	O
void	O
rw_yysync	function
(	O
)	O
;	O
static	O
int	O
rw_yyerror	function
(	O
char	O
*	O
s	pointer
)	O
;	O
static	O
void	O
frame_init	function
(	O
)	O
;	O
static	O
void	O
frame_push	function
(	O
)	O
;	O
static	O
void	O
frame_pop	function
(	O
)	O
;	O
static	O
void	O
frame_unwind_all	function
(	O
)	O
;	O
static	O
void	O
frame_free_all	function
(	O
)	O
;	O
static	O
void	O
var_init	function
(	O
)	O
;	O
static	O
VAR	struct
*	O
var_alloc	function
(	O
grad_data_type_t	enum
type	int
,	O
char	O
*	O
name	pointer
,	O
int	O
grow	int
)	O
;	O
static	O
void	O
var_unwind_level	function
(	O
)	O
;	O
static	O
void	O
var_unwind_all	function
(	O
)	O
;	O
static	O
void	O
var_type	function
(	O
grad_data_type_t	enum
type	int
,	O
VAR	struct
*	O
var	pointer
)	O
;	O
static	O
void	O
var_free_all	function
(	O
)	O
;	O
static	O
VAR	struct
*	O
var_lookup	function
(	O
char	O
*	O
name	pointer
)	O
;	O
static	O
void	O
mtx_init	function
(	O
)	O
;	O
static	O
void	O
mtx_free_all	function
(	O
)	O
;	O
static	O
void	O
mtx_unwind_all	function
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_cur	function
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_nop	function
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_jump	function
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_frame	function
(	O
Mtxtype	enum
type	int
,	O
stkoff_t	int
stksize	int
)	O
;	O
static	O
MTX	union
*	O
mtx_stop	function
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_pop	function
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_return	function
(	O
)	O
;	O
static	O
MTX	union
*	O
mtx_alloc	function
(	O
Mtxtype	enum
type	int
)	O
;	O
static	O
MTX	union
*	O
mtx_const	function
(	O
grad_value_t	struct
*	O
val	array
)	O
;	O
static	O
MTX	union
*	O
mtx_ref	function
(	O
int	O
num	int
)	O
;	O
static	O
MTX	union
*	O
mtx_var	function
(	O
VAR	struct
*	O
var	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_asgn	function
(	O
VAR	struct
*	O
var	pointer
,	O
MTX	union
*	O
arg	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_bin	function
(	O
Bopcode	enum
opcode	enum
,	O
MTX	union
*	O
arg1	pointer
,	O
MTX	union
*	O
arg2	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_un	function
(	O
Uopcode	enum
opcode	enum
,	O
MTX	union
*	O
arg	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_match	function
(	O
int	O
negated	int
,	O
MTX	union
*	O
mtx	union
,	O
COMP_REGEX	struct
*	O
)	O
;	O
static	O
MTX	union
*	O
mtx_cond	function
(	O
MTX	union
*	O
cond	int
,	O
MTX	union
*	O
if_true	pointer
,	O
MTX	union
*	O
if_false	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_coerce	function
(	O
grad_data_type_t	enum
type	int
,	O
MTX	union
*	O
arg	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_call	function
(	O
FUNCTION	struct
*	O
fun	pointer
,	O
MTX	union
*	O
args	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_builtin	function
(	O
builtin_t	struct
*	O
bin	struct
,	O
MTX	union
*	O
args	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_attr	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
,	O
MTX	union
*	O
index	function
)	O
;	O
static	O
MTX	union
*	O
mtx_attr_asgn	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
,	O
MTX	union
*	O
index	function
,	O
MTX	union
*	O
rval	pointer
)	O
;	O
static	O
MTX	union
*	O
mtx_attr_check	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
,	O
MTX	union
*	O
index	function
)	O
;	O
static	O
MTX	union
*	O
mtx_attr_delete	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
,	O
MTX	union
*	O
index	function
)	O
;	O
static	O
MTX	union
*	O
coerce	struct
(	O
MTX	union
*	O
arg	pointer
,	O
grad_data_type_t	enum
type	int
)	O
;	O
static	O
COMP_REGEX	struct
*	O
rx_alloc	function
(	O
regex_t	struct
*	O
regex	struct
,	O
int	O
nmatch	int
)	O
;	O
static	O
void	O
rx_free	function
(	O
COMP_REGEX	struct
*	O
rx	pointer
)	O
;	O
static	O
COMP_REGEX	struct
*	O
compile_regexp	function
(	O
char	O
*	O
str	pointer
)	O
;	O
static	O
FUNCTION	struct
*	O
function_install	function
(	O
FUNCTION	struct
*	O
fun	pointer
)	O
;	O
static	O
int	O
function_free	function
(	O
FUNCTION	struct
*	O
fun	pointer
)	O
;	O
static	O
void	O
function_delete	function
(	O
)	O
;	O
static	O
void	O
function_cleanup	function
(	O
)	O
;	O
static	O
builtin_t	struct
*	O
builtin_lookup	function
(	O
char	O
*	O
name	pointer
)	O
;	O
static	O
int	O
optimize	function
(	O
)	O
;	O
static	O
pctr_t	int
codegen	function
(	O
)	O
;	O
static	O
void	O
code_init	function
(	O
)	O
;	O
static	O
void	O
code_check	function
(	O
)	O
;	O
static	O
void	O
debug_dump_code	function
(	O
)	O
;	O
static	O
const	O
char	O
*	O
datatype_str_nom	function
(	O
grad_data_type_t	enum
type	int
)	O
;	O
static	O
const	O
char	O
*	O
datatype_str_acc	function
(	O
grad_data_type_t	enum
type	int
)	O
;	O
static	O
const	O
char	O
*	O
datatype_str_abl	function
(	O
grad_data_type_t	enum
type	int
)	O
;	O
static	O
grad_data_type_t	enum
attr_datatype	function
(	O
grad_dict_attr_t	struct
*	O
)	O
;	O
static	O
void	O
gc	function
(	O
)	O
;	O
static	O
void	O
run	function
(	O
pctr_t	int
pc	int
)	O
;	O
static	O
int	O
run_init	function
(	O
pctr_t	int
pc	int
,	O
grad_request_t	struct
*	O
req	pointer
)	O
;	O
static	O
int	O
rw_error	function
(	O
const	O
char	O
*	O
msg	pointer
)	O
;	O
static	O
int	O
rw_error_free	function
(	O
char	O
*	O
msg	pointer
)	O
;	O
typedef	O
union	O
YYSTYPE	union
{	O
int	O
number	long
;	O
int	O
type	int
;	O
VAR	struct
*	O
var	pointer
;	O
MTX	union
*	O
mtx	union
;	O
FUNCTION	struct
*	O
fun	pointer
;	O
builtin_t	struct
*	O
btin	struct
;	O
grad_dict_attr_t	struct
*	O
attr	pointer
;	O
struct	O
{	O
MTX	union
*	O
arg_first	pointer
;	O
MTX	union
*	O
arg_last	pointer
;	O
}	O
arg	pointer
;	O
struct	O
{	O
int	O
nmatch	int
;	O
regex_t	struct
regex	struct
;	O
}	O
rx	pointer
;	O
char	O
*	O
string	pointer
;	O
}	O
YYSTYPE	union
;	O
typedef	O
unsigned	O
char	O
rw_yytype_uint8	char
;	O
typedef	O
signed	O
char	O
rw_yytype_int8	char
;	O
typedef	O
unsigned	O
short	O
int	O
rw_yytype_uint16	short
;	O
typedef	O
short	O
int	O
rw_yytype_int16	short
;	O
union	O
rw_yyalloc	union
{	O
rw_yytype_int16	short
rw_yyss	short
;	O
YYSTYPE	union
rw_yyvs	union
;	O
}	O
;	O
static	O
const	O
rw_yytype_uint8	char
rw_yytranslate	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
42	int
,	O
29	int
,	O
2	int
,	O
50	int
,	O
51	int
,	O
40	int
,	O
38	int
,	O
49	int
,	O
39	int
,	O
2	int
,	O
41	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
48	int
,	O
2	int
,	O
22	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
28	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
46	int
,	O
27	int
,	O
47	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
43	int
,	O
44	int
,	O
45	int
}	O
;	O
static	O
const	O
rw_yytype_uint16	short
rw_yyprhs	array
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
3	int
,	O
5	int
,	O
7	int
,	O
9	int
,	O
11	int
,	O
14	int
,	O
17	int
,	O
22	int
,	O
26	int
,	O
30	int
,	O
32	int
,	O
35	int
,	O
37	int
,	O
39	int
,	O
41	int
,	O
43	int
,	O
46	int
,	O
50	int
,	O
52	int
,	O
56	int
,	O
59	int
,	O
63	int
,	O
65	int
,	O
69	int
,	O
72	int
,	O
73	int
,	O
75	int
,	O
77	int
,	O
81	int
,	O
83	int
,	O
85	int
,	O
88	int
,	O
92	int
,	O
95	int
,	O
99	int
,	O
105	int
,	O
109	int
,	O
113	int
,	O
114	int
,	O
121	int
,	O
124	int
,	O
127	int
,	O
131	int
,	O
138	int
,	O
140	int
,	O
142	int
,	O
144	int
,	O
148	int
,	O
150	int
,	O
152	int
,	O
154	int
,	O
156	int
,	O
158	int
,	O
162	int
,	O
164	int
,	O
169	int
,	O
172	int
,	O
178	int
,	O
182	int
,	O
189	int
,	O
194	int
,	O
199	int
,	O
203	int
,	O
207	int
,	O
211	int
,	O
215	int
,	O
219	int
,	O
223	int
,	O
227	int
,	O
231	int
,	O
235	int
,	O
239	int
,	O
243	int
,	O
247	int
,	O
250	int
,	O
253	int
,	O
256	int
,	O
260	int
,	O
265	int
,	O
269	int
,	O
273	int
,	O
277	int
,	O
281	int
,	O
285	int
,	O
289	int
,	O
293	int
}	O
;	O
static	O
const	O
rw_yytype_int8	char
rw_yyrhs	array
[	O
]	O
=	O
{	O
53	int
,	O
0	int
,	O
-	O
1	int
,	O
54	int
,	O
-	O
1	int
,	O
55	int
,	O
-	O
1	int
,	O
78	int
,	O
-	O
1	int
,	O
56	int
,	O
-	O
1	int
,	O
55	int
,	O
56	int
,	O
-	O
1	int
,	O
55	int
,	O
1	int
,	O
-	O
1	int
,	O
57	int
,	O
58	int
,	O
71	int
,	O
59	int
,	O
-	O
1	int
,	O
3	int
,	O
14	int
,	O
65	int
,	O
-	O
1	int
,	O
3	int
,	O
18	int
,	O
65	int
,	O
-	O
1	int
,	O
60	int
,	O
-	O
1	int
,	O
60	int
,	O
62	int
,	O
-	O
1	int
,	O
61	int
,	O
-	O
1	int
,	O
46	int
,	O
-	O
1	int
,	O
47	int
,	O
-	O
1	int
,	O
63	int
,	O
-	O
1	int
,	O
62	int
,	O
63	int
,	O
-	O
1	int
,	O
3	int
,	O
64	int
,	O
48	int
,	O
-	O
1	int
,	O
14	int
,	O
-	O
1	int
,	O
64	int
,	O
49	int
,	O
14	int
,	O
-	O
1	int
,	O
50	int
,	O
51	int
,	O
-	O
1	int
,	O
50	int
,	O
66	int
,	O
51	int
,	O
-	O
1	int
,	O
67	int
,	O
-	O
1	int
,	O
66	int
,	O
49	int
,	O
67	int
,	O
-	O
1	int
,	O
3	int
,	O
14	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
69	int
,	O
-	O
1	int
,	O
70	int
,	O
-	O
1	int
,	O
69	int
,	O
49	int
,	O
70	int
,	O
-	O
1	int
,	O
78	int
,	O
-	O
1	int
,	O
72	int
,	O
-	O
1	int
,	O
71	int
,	O
72	int
,	O
-	O
1	int
,	O
58	int
,	O
71	int
,	O
59	int
,	O
-	O
1	int
,	O
78	int
,	O
48	int
,	O
-	O
1	int
,	O
4	int
,	O
77	int
,	O
72	int
,	O
-	O
1	int
,	O
4	int
,	O
77	int
,	O
72	int
,	O
76	int
,	O
72	int
,	O
-	O
1	int
,	O
6	int
,	O
78	int
,	O
48	int
,	O
-	O
1	int
,	O
74	int
,	O
77	int
,	O
72	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
75	int
,	O
72	int
,	O
73	int
,	O
7	int
,	O
77	int
,	O
48	int
,	O
-	O
1	int
,	O
10	int
,	O
48	int
,	O
-	O
1	int
,	O
11	int
,	O
48	int
,	O
-	O
1	int
,	O
12	int
,	O
20	int
,	O
48	int
,	O
-	O
1	int
,	O
12	int
,	O
20	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
48	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
,	O
9	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
-	O
1	int
,	O
15	int
,	O
-	O
1	int
,	O
13	int
,	O
-	O
1	int
,	O
16	int
,	O
-	O
1	int
,	O
17	int
,	O
-	O
1	int
,	O
14	int
,	O
-	O
1	int
,	O
17	int
,	O
22	int
,	O
78	int
,	O
-	O
1	int
,	O
20	int
,	O
-	O
1	int
,	O
20	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
-	O
1	int
,	O
40	int
,	O
20	int
,	O
-	O
1	int
,	O
40	int
,	O
20	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
-	O
1	int
,	O
20	int
,	O
22	int
,	O
78	int
,	O
-	O
1	int
,	O
20	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
22	int
,	O
78	int
,	O
-	O
1	int
,	O
18	int
,	O
50	int
,	O
68	int
,	O
51	int
,	O
-	O
1	int
,	O
19	int
,	O
50	int
,	O
68	int
,	O
51	int
,	O
-	O
1	int
,	O
78	int
,	O
38	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
39	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
40	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
41	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
42	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
27	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
29	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
28	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
37	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
36	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
24	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
23	int
,	O
78	int
,	O
-	O
1	int
,	O
39	int
,	O
78	int
,	O
-	O
1	int
,	O
38	int
,	O
78	int
,	O
-	O
1	int
,	O
44	int
,	O
78	int
,	O
-	O
1	int
,	O
50	int
,	O
78	int
,	O
51	int
,	O
-	O
1	int
,	O
50	int
,	O
3	int
,	O
51	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
31	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
30	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
35	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
34	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
33	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
32	int
,	O
78	int
,	O
-	O
1	int
,	O
78	int
,	O
26	int
,	O
13	int
,	O
-	O
1	int
,	O
78	int
,	O
25	int
,	O
13	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
rw_yytype_uint16	short
rw_yyrline	array
[	O
]	O
=	O
{	O
0	int
,	O
717	int
,	O
717	int
,	O
726	int
,	O
730	int
,	O
754	int
,	O
755	int
,	O
756	int
,	O
773	int
,	O
799	int
,	O
838	int
,	O
849	int
,	O
850	int
,	O
853	int
,	O
856	int
,	O
862	int
,	O
873	int
,	O
874	int
,	O
877	int
,	O
883	int
,	O
888	int
,	O
899	int
,	O
903	int
,	O
909	int
,	O
914	int
,	O
921	int
,	O
931	int
,	O
934	int
,	O
940	int
,	O
945	int
,	O
953	int
,	O
959	int
,	O
960	int
,	O
963	int
,	O
967	int
,	O
972	int
,	O
977	int
,	O
984	int
,	O
989	int
,	O
1005	int
,	O
1005	int
,	O
1024	int
,	O
1038	int
,	O
1051	int
,	O
1055	int
,	O
1061	int
,	O
1068	int
,	O
1075	int
,	O
1083	int
,	O
1094	int
,	O
1101	int
,	O
1109	int
,	O
1113	int
,	O
1117	int
,	O
1123	int
,	O
1127	int
,	O
1131	int
,	O
1135	int
,	O
1139	int
,	O
1143	int
,	O
1147	int
,	O
1151	int
,	O
1155	int
,	O
1159	int
,	O
1163	int
,	O
1167	int
,	O
1171	int
,	O
1175	int
,	O
1179	int
,	O
1183	int
,	O
1187	int
,	O
1191	int
,	O
1195	int
,	O
1199	int
,	O
1203	int
,	O
1207	int
,	O
1211	int
,	O
1215	int
,	O
1219	int
,	O
1223	int
,	O
1227	int
,	O
1231	int
,	O
1235	int
,	O
1239	int
,	O
1243	int
,	O
1247	int
,	O
1251	int
,	O
1260	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
rw_yytname	array
[	O
]	O
=	O
{	O
"$end"	pointer
,	O
"error"	pointer
,	O
"$undefined"	pointer
,	O
"TYPE"	pointer
,	O
"IF"	pointer
,	O
"ELSE"	pointer
,	O
"RETURN"	pointer
,	O
"WHILE"	pointer
,	O
"FOR"	pointer
,	O
"DO"	pointer
,	O
"BREAK"	pointer
,	O
"CONTINUE"	pointer
,	O
"DELETE"	pointer
,	O
"STRING"	pointer
,	O
"IDENT"	pointer
,	O
"NUMBER"	pointer
,	O
"REFERENCE"	pointer
,	O
"VARIABLE"	pointer
,	O
"FUN"	pointer
,	O
"BUILTIN"	pointer
,	O
"ATTR"	pointer
,	O
"BOGUS"	pointer
,	O
"'='"	pointer
,	O
"OR"	pointer
,	O
"AND"	pointer
,	O
"NM"	pointer
,	O
"MT"	pointer
,	O
"'|'"	pointer
,	O
"'^'"	pointer
,	O
"'&'"	pointer
,	O
"NE"	pointer
,	O
"EQ"	pointer
,	O
"GE"	pointer
,	O
"GT"	pointer
,	O
"LE"	pointer
,	O
"LT"	pointer
,	O
"SHR"	pointer
,	O
"SHL"	pointer
,	O
"'+'"	pointer
,	O
"'-'"	pointer
,	O
"'*'"	pointer
,	O
"'/'"	pointer
,	O
"'%'"	pointer
,	O
"TYPECAST"	pointer
,	O
"NOT"	pointer
,	O
"UMINUS"	pointer
,	O
"'{'"	pointer
,	O
"'}'"	pointer
,	O
"';'"	pointer
,	O
"','"	pointer
,	O
"'('"	pointer
,	O
"')'"	pointer
,	O
"$accept"	pointer
,	O
"program"	pointer
,	O
"input"	pointer
,	O
"dcllist"	pointer
,	O
"decl"	pointer
,	O
"fundecl"	pointer
,	O
"begin"	pointer
,	O
"end"	pointer
,	O
"obrace"	pointer
,	O
"cbrace"	pointer
,	O
"autodcl"	pointer
,	O
"autovar"	pointer
,	O
"varlist"	pointer
,	O
"dclparm"	pointer
,	O
"parmlist"	pointer
,	O
"parm"	pointer
,	O
"args"	pointer
,	O
"arglist"	pointer
,	O
"arg"	pointer
,	O
"list"	pointer
,	O
"stmt"	pointer
,	O
"@1"	pointer
,	O
"while"	pointer
,	O
"do"	pointer
,	O
"else"	pointer
,	O
"cond"	pointer
,	O
"expr"	pointer
,	O
0	int
}	O
;	O
static	O
const	O
rw_yytype_uint8	char
rw_yyr1	array
[	O
]	O
=	O
{	O
0	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
54	int
,	O
55	int
,	O
55	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
57	int
,	O
58	int
,	O
58	int
,	O
59	int
,	O
60	int
,	O
61	int
,	O
62	int
,	O
62	int
,	O
63	int
,	O
64	int
,	O
64	int
,	O
65	int
,	O
65	int
,	O
66	int
,	O
66	int
,	O
67	int
,	O
68	int
,	O
68	int
,	O
69	int
,	O
69	int
,	O
70	int
,	O
71	int
,	O
71	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
73	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
72	int
,	O
74	int
,	O
75	int
,	O
76	int
,	O
77	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
}	O
;	O
static	O
const	O
rw_yytype_uint8	char
rw_yyr2	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
4	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
3	int
,	O
3	int
,	O
0	int
,	O
6	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
4	int
,	O
2	int
,	O
5	int
,	O
3	int
,	O
6	int
,	O
4	int
,	O
4	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
;	O
static	O
const	O
rw_yytype_uint8	char
rw_yydefact	array
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
50	int
,	O
53	int
,	O
49	int
,	O
51	int
,	O
52	int
,	O
0	int
,	O
0	int
,	O
55	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
5	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
26	int
,	O
26	int
,	O
0	int
,	O
0	int
,	O
76	int
,	O
75	int
,	O
57	int
,	O
77	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
7	int
,	O
6	int
,	O
14	int
,	O
0	int
,	O
11	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
9	int
,	O
10	int
,	O
54	int
,	O
0	int
,	O
27	int
,	O
28	int
,	O
30	int
,	O
0	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
78	int
,	O
0	int
,	O
0	int
,	O
45	int
,	O
46	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
31	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
16	int
,	O
74	int
,	O
73	int
,	O
87	int
,	O
86	int
,	O
68	int
,	O
70	int
,	O
69	int
,	O
81	int
,	O
80	int
,	O
85	int
,	O
84	int
,	O
83	int
,	O
82	int
,	O
72	int
,	O
71	int
,	O
63	int
,	O
64	int
,	O
65	int
,	O
66	int
,	O
67	int
,	O
0	int
,	O
21	int
,	O
0	int
,	O
23	int
,	O
61	int
,	O
0	int
,	O
62	int
,	O
56	int
,	O
0	int
,	O
79	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
41	int
,	O
42	int
,	O
0	int
,	O
0	int
,	O
15	int
,	O
8	int
,	O
13	int
,	O
32	int
,	O
0	int
,	O
39	int
,	O
34	int
,	O
19	int
,	O
0	int
,	O
17	int
,	O
25	int
,	O
0	int
,	O
22	int
,	O
29	int
,	O
0	int
,	O
58	int
,	O
0	int
,	O
35	int
,	O
37	int
,	O
43	int
,	O
0	int
,	O
33	int
,	O
38	int
,	O
0	int
,	O
18	int
,	O
0	int
,	O
24	int
,	O
60	int
,	O
48	int
,	O
47	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
20	int
,	O
36	int
,	O
0	int
,	O
0	int
,	O
44	int
,	O
40	int
}	O
;	O
static	O
const	O
rw_yytype_int16	short
rw_yydefgoto	array
[	O
]	O
=	O
{	O
-	O
1	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
81	int
,	O
128	int
,	O
39	int
,	O
129	int
,	O
88	int
,	O
89	int
,	O
135	int
,	O
61	int
,	O
112	int
,	O
113	int
,	O
64	int
,	O
65	int
,	O
66	int
,	O
82	int
,	O
83	int
,	O
150	int
,	O
84	int
,	O
85	int
,	O
157	int
,	O
121	int
,	O
86	int
}	O
;	O
static	O
const	O
rw_yytype_int16	short
rw_yypact	array
[	O
]	O
=	O
{	O
67	int
,	O
17	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
1	int
,	O
-	O
22	int
,	O
12	int
,	O
-	O
20	int
,	O
207	int
,	O
207	int
,	O
44	int
,	O
207	int
,	O
110	int
,	O
65	int
,	O
-	O
84	int
,	O
33	int
,	O
-	O
84	int
,	O
20	int
,	O
432	int
,	O
19	int
,	O
19	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
24	int
,	O
-	O
84	int
,	O
16	int
,	O
235	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
169	int
,	O
74	int
,	O
207	int
,	O
207	int
,	O
66	int
,	O
90	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
207	int
,	O
9	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
432	int
,	O
57	int
,	O
61	int
,	O
-	O
84	int
,	O
432	int
,	O
58	int
,	O
432	int
,	O
264	int
,	O
207	int
,	O
207	int
,	O
-	O
84	int
,	O
62	int
,	O
207	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
68	int
,	O
70	int
,	O
94	int
,	O
169	int
,	O
152	int
,	O
-	O
84	int
,	O
62	int
,	O
169	int
,	O
380	int
,	O
105	int
,	O
74	int
,	O
-	O
84	int
,	O
451	int
,	O
469	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
60	int
,	O
199	int
,	O
482	int
,	O
493	int
,	O
493	int
,	O
-	O
33	int
,	O
-	O
33	int
,	O
-	O
33	int
,	O
-	O
33	int
,	O
-	O
23	int
,	O
-	O
23	int
,	O
-	O
3	int
,	O
-	O
3	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
107	int
,	O
-	O
84	int
,	O
-	O
29	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
207	int
,	O
-	O
84	int
,	O
100	int
,	O
293	int
,	O
-	O
84	int
,	O
207	int
,	O
169	int
,	O
406	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
13	int
,	O
152	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
169	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
6	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
128	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
207	int
,	O
-	O
84	int
,	O
322	int
,	O
127	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
207	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
126	int
,	O
-	O
84	int
,	O
120	int
,	O
-	O
84	int
,	O
432	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
169	int
,	O
351	int
,	O
62	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
87	int
,	O
88	int
,	O
-	O
84	int
,	O
-	O
84	int
}	O
;	O
static	O
const	O
rw_yytype_int16	short
rw_yypgoto	array
[	O
]	O
=	O
{	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
121	int
,	O
-	O
84	int
,	O
118	int
,	O
14	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
51	int
,	O
-	O
84	int
,	O
122	int
,	O
-	O
84	int
,	O
4	int
,	O
130	int
,	O
-	O
84	int
,	O
28	int
,	O
64	int
,	O
-	O
53	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
84	int
,	O
-	O
83	int
,	O
0	int
}	O
;	O
static	O
const	O
rw_yytype_int16	short
rw_yytable	array
[	O
]	O
=	O
{	O
20	int
,	O
131	int
,	O
26	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
28	int
,	O
29	int
,	O
110	int
,	O
31	int
,	O
33	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
138	int
,	O
23	int
,	O
139	int
,	O
63	int
,	O
67	int
,	O
67	int
,	O
69	int
,	O
70	int
,	O
24	int
,	O
130	int
,	O
27	int
,	O
21	int
,	O
132	int
,	O
-	O
3	int
,	O
35	int
,	O
22	int
,	O
1	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
90	int
,	O
91	int
,	O
151	int
,	O
152	int
,	O
94	int
,	O
95	int
,	O
96	int
,	O
97	int
,	O
98	int
,	O
99	int
,	O
100	int
,	O
101	int
,	O
102	int
,	O
103	int
,	O
104	int
,	O
105	int
,	O
106	int
,	O
107	int
,	O
108	int
,	O
109	int
,	O
111	int
,	O
146	int
,	O
25	int
,	O
147	int
,	O
30	int
,	O
34	int
,	O
37	int
,	O
72	int
,	O
144	int
,	O
60	int
,	O
1	int
,	O
118	int
,	O
119	int
,	O
130	int
,	O
71	int
,	O
122	int
,	O
163	int
,	O
87	int
,	O
149	int
,	O
92	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
93	int
,	O
161	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
114	int
,	O
116	int
,	O
115	int
,	O
13	int
,	O
120	int
,	O
32	int
,	O
125	int
,	O
67	int
,	O
123	int
,	O
14	int
,	O
124	int
,	O
134	int
,	O
143	int
,	O
137	int
,	O
141	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
110	int
,	O
156	int
,	O
159	int
,	O
160	int
,	O
164	int
,	O
165	int
,	O
38	int
,	O
36	int
,	O
136	int
,	O
148	int
,	O
154	int
,	O
153	int
,	O
140	int
,	O
62	int
,	O
126	int
,	O
0	int
,	O
158	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
68	int
,	O
74	int
,	O
0	int
,	O
75	int
,	O
76	int
,	O
14	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
74	int
,	O
0	int
,	O
75	int
,	O
76	int
,	O
0	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
0	int
,	O
37	int
,	O
127	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
0	int
,	O
37	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
73	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
117	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
142	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
155	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
162	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
133	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
145	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
}	O
;	O
static	O
const	O
rw_yytype_int16	short
rw_yycheck	array
[	O
]	O
=	O
{	O
0	int
,	O
84	int
,	O
22	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
10	int
,	O
11	int
,	O
3	int
,	O
13	int
,	O
14	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
49	int
,	O
22	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
50	int
,	O
82	int
,	O
50	int
,	O
14	int
,	O
85	int
,	O
0	int
,	O
1	int
,	O
18	int
,	O
3	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
40	int
,	O
41	int
,	O
48	int
,	O
49	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
51	int
,	O
48	int
,	O
50	int
,	O
50	int
,	O
20	int
,	O
0	int
,	O
46	int
,	O
51	int
,	O
121	int
,	O
50	int
,	O
3	int
,	O
71	int
,	O
72	int
,	O
126	int
,	O
50	int
,	O
75	int
,	O
159	int
,	O
3	int
,	O
131	int
,	O
13	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
13	int
,	O
157	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
51	int
,	O
51	int
,	O
49	int
,	O
44	int
,	O
50	int
,	O
3	int
,	O
20	int
,	O
115	int
,	O
48	int
,	O
50	int
,	O
48	int
,	O
14	int
,	O
120	int
,	O
14	int
,	O
22	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
3	int
,	O
5	int
,	O
7	int
,	O
14	int
,	O
48	int
,	O
48	int
,	O
19	int
,	O
17	int
,	O
88	int
,	O
126	int
,	O
141	int
,	O
138	int
,	O
115	int
,	O
22	int
,	O
81	int
,	O
-	O
1	int
,	O
147	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
25	int
,	O
4	int
,	O
-	O
1	int
,	O
6	int
,	O
7	int
,	O
50	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
4	int
,	O
-	O
1	int
,	O
6	int
,	O
7	int
,	O
-	O
1	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
-	O
1	int
,	O
46	int
,	O
47	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
50	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
-	O
1	int
,	O
46	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
50	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
44	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
50	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
51	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
48	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
48	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
}	O
;	O
static	O
const	O
rw_yytype_uint8	char
rw_yystos	array
[	O
]	O
=	O
{	O
0	int
,	O
3	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
44	int
,	O
50	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
78	int
,	O
14	int
,	O
18	int
,	O
22	int
,	O
50	int
,	O
50	int
,	O
22	int
,	O
50	int
,	O
78	int
,	O
78	int
,	O
20	int
,	O
78	int
,	O
3	int
,	O
78	int
,	O
0	int
,	O
1	int
,	O
56	int
,	O
46	int
,	O
58	int
,	O
60	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
50	int
,	O
65	int
,	O
65	int
,	O
78	int
,	O
68	int
,	O
69	int
,	O
70	int
,	O
78	int
,	O
68	int
,	O
78	int
,	O
78	int
,	O
50	int
,	O
51	int
,	O
51	int
,	O
4	int
,	O
6	int
,	O
7	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
58	int
,	O
71	int
,	O
72	int
,	O
74	int
,	O
75	int
,	O
78	int
,	O
3	int
,	O
62	int
,	O
63	int
,	O
78	int
,	O
78	int
,	O
13	int
,	O
13	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
3	int
,	O
51	int
,	O
66	int
,	O
67	int
,	O
51	int
,	O
49	int
,	O
51	int
,	O
51	int
,	O
78	int
,	O
78	int
,	O
50	int
,	O
77	int
,	O
78	int
,	O
48	int
,	O
48	int
,	O
20	int
,	O
71	int
,	O
47	int
,	O
59	int
,	O
61	int
,	O
72	int
,	O
77	int
,	O
72	int
,	O
48	int
,	O
14	int
,	O
64	int
,	O
63	int
,	O
14	int
,	O
49	int
,	O
51	int
,	O
70	int
,	O
22	int
,	O
51	int
,	O
78	int
,	O
72	int
,	O
48	int
,	O
48	int
,	O
50	int
,	O
59	int
,	O
72	int
,	O
73	int
,	O
48	int
,	O
49	int
,	O
67	int
,	O
78	int
,	O
51	int
,	O
5	int
,	O
76	int
,	O
78	int
,	O
7	int
,	O
14	int
,	O
72	int
,	O
51	int
,	O
77	int
,	O
48	int
,	O
48	int
}	O
;	O
static	O
void	O
rw_yy_symbol_value_print	function
(	O
FILE	struct
*	O
rw_yyoutput	pointer
,	O
int	O
rw_yytype	int
,	O
YYSTYPE	union
const	O
*	O
const	O
rw_yyvaluep	pointer
)	O
{	O
if	O
(	O
!	O
rw_yyvaluep	pointer
)	O
return	O
;	O
YYUSE	O
(	O
rw_yyoutput	pointer
)	O
;	O
switch	O
(	O
rw_yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
rw_yy_symbol_print	function
(	O
FILE	struct
*	O
rw_yyoutput	pointer
,	O
int	O
rw_yytype	int
,	O
YYSTYPE	union
const	O
*	O
const	O
rw_yyvaluep	pointer
)	O
{	O
if	O
(	O
rw_yytype	int
<	O
YYNTOKENS	int
)	O
YYFPRINTF	O
(	O
rw_yyoutput	pointer
,	O
"token %s ("	pointer
,	O
rw_yytname	array
[	O
rw_yytype	int
]	O
)	O
;	O
else	O
YYFPRINTF	O
(	O
rw_yyoutput	pointer
,	O
"nterm %s ("	pointer
,	O
rw_yytname	array
[	O
rw_yytype	int
]	O
)	O
;	O
rw_yy_symbol_value_print	function
(	O
rw_yyoutput	pointer
,	O
rw_yytype	int
,	O
rw_yyvaluep	pointer
)	O
;	O
YYFPRINTF	O
(	O
rw_yyoutput	pointer
,	O
")"	pointer
)	O
;	O
}	O
static	O
void	O
rw_yy_stack_print	function
(	O
rw_yytype_int16	short
*	O
bottom	pointer
,	O
rw_yytype_int16	short
*	O
top	pointer
)	O
{	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"Stack now"	pointer
)	O
;	O
for	O
(	O
;	O
bottom	pointer
<=	O
top	pointer
;	O
++	O
bottom	pointer
)	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
" %d"	pointer
,	O
*	O
bottom	pointer
)	O
;	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
rw_yy_reduce_print	function
(	O
YYSTYPE	union
*	O
rw_yyvsp	pointer
,	O
int	O
rw_yyrule	int
)	O
{	O
int	O
rw_yynrhs	int
=	O
rw_yyr2	array
[	O
rw_yyrule	int
]	O
;	O
int	O
rw_yyi	int
;	O
unsigned	O
long	O
int	O
rw_yylno	long
=	O
rw_yyrline	array
[	O
rw_yyrule	int
]	O
;	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"Reducing stack by rule %d (line %lu):\n"	pointer
,	O
rw_yyrule	int
-	O
1	int
,	O
rw_yylno	long
)	O
;	O
for	O
(	O
rw_yyi	int
=	O
0	int
;	O
rw_yyi	int
<	O
rw_yynrhs	int
;	O
rw_yyi	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"   $%d = "	pointer
,	O
rw_yyi	int
+	O
1	int
)	O
;	O
rw_yy_symbol_print	function
(	O
stderr	pointer
,	O
rw_yyrhs	array
[	O
rw_yyprhs	array
[	O
rw_yyrule	int
]	O
+	O
rw_yyi	int
]	O
,	O
&	O
(	O
rw_yyvsp	pointer
[	O
(	O
rw_yyi	int
+	O
1	int
)	O
-	O
(	O
rw_yynrhs	int
)	O
]	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
int	O
rw_yydebug	int
;	O
static	O
void	O
rw_yydestruct	function
(	O
const	O
char	O
*	O
rw_yymsg	pointer
,	O
int	O
rw_yytype	int
,	O
YYSTYPE	union
*	O
rw_yyvaluep	pointer
)	O
{	O
YYUSE	O
(	O
rw_yyvaluep	pointer
)	O
;	O
if	O
(	O
!	O
rw_yymsg	pointer
)	O
rw_yymsg	pointer
=	O
"Deleting"	pointer
;	O
YY_SYMBOL_PRINT	O
(	O
rw_yymsg	pointer
,	O
rw_yytype	int
,	O
rw_yyvaluep	pointer
,	O
rw_yylocationp	O
)	O
;	O
switch	O
(	O
rw_yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
rw_yyparse	function
(	O
void	O
)	O
;	O
int	O
rw_yychar	int
;	O
YYSTYPE	union
rw_yylval	union
;	O
int	O
rw_yynerrs	int
;	O
int	O
rw_yyparse	function
(	O
void	O
)	O
{	O
int	O
rw_yystate	int
;	O
int	O
rw_yyn	int
;	O
int	O
rw_yyresult	int
;	O
int	O
rw_yyerrstatus	int
;	O
int	O
rw_yytoken	int
=	O
0	int
;	O
rw_yytype_int16	short
rw_yyssa	array
[	O
YYINITDEPTH	int
]	O
;	O
rw_yytype_int16	short
*	O
rw_yyss	short
=	O
rw_yyssa	array
;	O
rw_yytype_int16	short
*	O
rw_yyssp	pointer
;	O
YYSTYPE	union
rw_yyvsa	array
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	union
*	O
rw_yyvs	union
=	O
rw_yyvsa	array
;	O
YYSTYPE	union
*	O
rw_yyvsp	pointer
;	O
YYSIZE_T	O
rw_yystacksize	long
=	O
YYINITDEPTH	int
;	O
YYSTYPE	union
rw_yyval	union
;	O
int	O
rw_yylen	int
=	O
0	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Starting parse\n"	pointer
)	O
)	O
;	O
rw_yystate	int
=	O
0	int
;	O
rw_yyerrstatus	int
=	O
0	int
;	O
rw_yynerrs	int
=	O
0	int
;	O
rw_yychar	int
=	O
YYEMPTY	O
;	O
rw_yyssp	pointer
=	O
rw_yyss	short
;	O
rw_yyvsp	pointer
=	O
rw_yyvs	union
;	O
goto	O
rw_yysetstate	O
;	O
rw_yynewstate	O
:	O
rw_yyssp	pointer
++	O
;	O
rw_yysetstate	O
:	O
*	O
rw_yyssp	pointer
=	O
rw_yystate	int
;	O
if	O
(	O
rw_yyss	short
+	O
rw_yystacksize	long
-	O
1	int
<=	O
rw_yyssp	pointer
)	O
{	O
YYSIZE_T	O
rw_yysize	long
=	O
rw_yyssp	pointer
-	O
rw_yyss	short
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
rw_yystacksize	long
)	O
goto	O
rw_yyexhaustedlab	O
;	O
rw_yystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
rw_yystacksize	long
)	O
rw_yystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
rw_yytype_int16	short
*	O
rw_yyss1	pointer
=	O
rw_yyss	short
;	O
union	O
rw_yyalloc	union
*	O
rw_yyptr	pointer
=	O
(	O
union	O
rw_yyalloc	union
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
rw_yystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
rw_yyptr	pointer
)	O
goto	O
rw_yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
rw_yyss	short
)	O
;	O
YYSTACK_RELOCATE	O
(	O
rw_yyvs	union
)	O
;	O
if	O
(	O
rw_yyss1	pointer
!=	O
rw_yyssa	array
)	O
YYSTACK_FREE	O
(	O
rw_yyss1	pointer
)	O
;	O
}	O
rw_yyssp	pointer
=	O
rw_yyss	short
+	O
rw_yysize	long
-	O
1	int
;	O
rw_yyvsp	pointer
=	O
rw_yyvs	union
+	O
rw_yysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Stack size increased to %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
rw_yystacksize	long
)	O
)	O
;	O
if	O
(	O
rw_yyss	short
+	O
rw_yystacksize	long
-	O
1	int
<=	O
rw_yyssp	pointer
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Entering state %d\n"	pointer
,	O
rw_yystate	int
)	O
)	O
;	O
goto	O
rw_yybackup	O
;	O
rw_yybackup	O
:	O
rw_yyn	int
=	O
rw_yypact	array
[	O
rw_yystate	int
]	O
;	O
if	O
(	O
rw_yyn	int
==	O
YYPACT_NINF	O
)	O
goto	O
rw_yydefault	O
;	O
if	O
(	O
rw_yychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Reading a token: "	pointer
)	O
)	O
;	O
rw_yychar	int
=	O
YYLEX	O
;	O
}	O
if	O
(	O
rw_yychar	int
<=	O
YYEOF	int
)	O
{	O
rw_yychar	int
=	O
rw_yytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Now at end of input.\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
rw_yytoken	int
=	O
YYTRANSLATE	O
(	O
rw_yychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	pointer
,	O
rw_yytoken	int
,	O
&	O
rw_yylval	union
,	O
&	O
rw_yylloc	O
)	O
;	O
}	O
rw_yyn	int
+=	O
rw_yytoken	int
;	O
if	O
(	O
rw_yyn	int
<	O
0	int
||	O
YYLAST	int
<	O
rw_yyn	int
||	O
rw_yycheck	array
[	O
rw_yyn	int
]	O
!=	O
rw_yytoken	int
)	O
goto	O
rw_yydefault	O
;	O
rw_yyn	int
=	O
rw_yytable	array
[	O
rw_yyn	int
]	O
;	O
if	O
(	O
rw_yyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
rw_yyn	int
==	O
0	int
||	O
rw_yyn	int
==	O
YYTABLE_NINF	O
)	O
goto	O
rw_yyerrlab	O
;	O
rw_yyn	int
=	O
-	O
rw_yyn	int
;	O
goto	O
rw_yyreduce	O
;	O
}	O
if	O
(	O
rw_yyn	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
if	O
(	O
rw_yyerrstatus	int
)	O
rw_yyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
rw_yytoken	int
,	O
&	O
rw_yylval	union
,	O
&	O
rw_yylloc	O
)	O
;	O
if	O
(	O
rw_yychar	int
!=	O
YYEOF	int
)	O
rw_yychar	int
=	O
YYEMPTY	O
;	O
rw_yystate	int
=	O
rw_yyn	int
;	O
*	O
++	O
rw_yyvsp	pointer
=	O
rw_yylval	union
;	O
goto	O
rw_yynewstate	O
;	O
rw_yydefault	O
:	O
rw_yyn	int
=	O
rw_yydefact	array
[	O
rw_yystate	int
]	O
;	O
if	O
(	O
rw_yyn	int
==	O
0	int
)	O
goto	O
rw_yyerrlab	O
;	O
goto	O
rw_yyreduce	O
;	O
rw_yyreduce	O
:	O
rw_yylen	int
=	O
rw_yyr2	array
[	O
rw_yyn	int
]	O
;	O
rw_yyval	union
=	O
rw_yyvsp	pointer
[	O
1	int
-	O
rw_yylen	int
]	O
;	O
YY_REDUCE_PRINT	O
(	O
rw_yyn	int
)	O
;	O
switch	O
(	O
rw_yyn	int
)	O
{	O
case	O
2	int
:	O
{	O
var_free_all	function
(	O
)	O
;	O
loop_free_all	function
(	O
)	O
;	O
frame_free_all	function
(	O
)	O
;	O
mtx_free_all	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
3	int
:	O
{	O
return_type	enum
=	O
Undefined	int
;	O
}	O
break	O
;	O
case	O
4	int
:	O
{	O
FUNCTION	struct
fmain	struct
;	O
if	O
(	O
errcnt	long
)	O
{	O
YYERROR	O
;	O
}	O
mtx_return	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
memset	function
(	O
&	O
fmain	struct
,	O
0	int
,	O
sizeof	O
(	O
fmain	struct
)	O
)	O
;	O
fmain	struct
.	O
name	pointer
=	O
"main"	pointer
;	O
fmain	struct
.	O
rettype	enum
=	O
return_type	enum
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
mtx	union
)	O
->	O
gen	struct
.	O
datatype	enum
;	O
function	pointer
=	O
&	O
fmain	struct
;	O
if	O
(	O
optimize	function
(	O
)	O
==	O
0	int
)	O
{	O
codegen	function
(	O
)	O
;	O
if	O
(	O
errcnt	long
)	O
{	O
YYERROR	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
var_unwind_all	function
(	O
)	O
;	O
loop_unwind_all	function
(	O
)	O
;	O
frame_unwind_all	function
(	O
)	O
;	O
mtx_unwind_all	function
(	O
)	O
;	O
function_delete	function
(	O
)	O
;	O
rw_yysync	function
(	O
)	O
;	O
rw_yyclearin	O
;	O
rw_yyerrok	O
;	O
errcnt	long
=	O
0	int
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
if	O
(	O
errcnt	long
)	O
{	O
function_delete	function
(	O
)	O
;	O
YYERROR	O
;	O
}	O
if	O
(	O
optimize	function
(	O
)	O
==	O
0	int
)	O
{	O
codegen	function
(	O
)	O
;	O
if	O
(	O
errcnt	long
)	O
{	O
function_delete	function
(	O
)	O
;	O
YYERROR	O
;	O
}	O
}	O
else	O
{	O
function_delete	function
(	O
)	O
;	O
}	O
var_unwind_all	function
(	O
)	O
;	O
loop_unwind_all	function
(	O
)	O
;	O
frame_unwind_all	function
(	O
)	O
;	O
mtx_unwind_all	function
(	O
)	O
;	O
function_cleanup	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
VAR	struct
*	O
var	pointer
;	O
PARAMETER	struct
*	O
last	pointer
,	O
*	O
parm	pointer
;	O
FUNCTION	struct
f	pointer
;	O
if	O
(	O
errcnt	long
)	O
YYERROR	O
;	O
memset	function
(	O
&	O
f	pointer
,	O
0	int
,	O
sizeof	O
(	O
f	pointer
)	O
)	O
;	O
f	pointer
.	O
name	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	pointer
)	O
;	O
f	pointer
.	O
rettype	enum
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
type	int
)	O
;	O
f	pointer
.	O
entry	int
=	O
0	int
;	O
f	pointer
.	O
loc	struct
=	O
locus	struct
;	O
f	pointer
.	O
nparm	int
=	O
0	int
;	O
f	pointer
.	O
parm	pointer
=	O
NULL	O
;	O
for	O
(	O
var	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	pointer
)	O
;	O
var	pointer
;	O
var	pointer
=	O
var	pointer
->	O
next	pointer
)	O
f	pointer
.	O
nparm	int
++	O
;	O
f	pointer
.	O
parm	pointer
=	O
last	pointer
=	O
NULL	O
;	O
for	O
(	O
var	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	pointer
)	O
;	O
var	pointer
;	O
var	pointer
=	O
var	pointer
->	O
next	pointer
)	O
{	O
parm	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
parm	pointer
)	O
)	O
;	O
parm	pointer
->	O
datatype	enum
=	O
var	pointer
->	O
datatype	enum
;	O
var	pointer
->	O
offset	long
=	O
-	O
(	O
STACK_BASE	int
+	O
f	pointer
.	O
nparm	int
-	O
var	pointer
->	O
offset	long
)	O
;	O
parm	pointer
->	O
offset	long
=	O
var	pointer
->	O
offset	long
;	O
parm	pointer
->	O
prev	pointer
=	O
last	pointer
;	O
parm	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
f	pointer
.	O
parm	pointer
==	O
NULL	O
)	O
f	pointer
.	O
parm	pointer
=	O
parm	pointer
;	O
else	O
last	pointer
->	O
next	pointer
=	O
parm	pointer
;	O
last	pointer
=	O
parm	pointer
;	O
}	O
function	pointer
=	O
function_install	function
(	O
&	O
f	pointer
)	O
;	O
}	O
break	O
;	O
case	O
10	int
:	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"redefinition of function `%s'"	pointer
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
fun	pointer
)	O
->	O
name	pointer
)	O
;	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
fun	pointer
)	O
->	O
loc	struct
,	O
_	O
(	O
"previously defined here"	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
frame_push	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
var_unwind_level	function
(	O
)	O
;	O
frame_pop	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
var_type	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
type	int
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
19	int
:	O
{	O
(	O
rw_yyval	union
.	O
var	pointer
)	O
=	O
var_alloc	function
(	O
Undefined	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	pointer
)	O
,	O
+	O
1	int
)	O
;	O
(	O
rw_yyval	union
.	O
var	pointer
)	O
->	O
dcllink	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
20	int
:	O
{	O
VAR	struct
*	O
var	pointer
=	O
var_alloc	function
(	O
Undefined	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	pointer
)	O
,	O
+	O
1	int
)	O
;	O
var	pointer
->	O
dcllink	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	pointer
)	O
;	O
(	O
rw_yyval	union
.	O
var	pointer
)	O
=	O
var	pointer
;	O
}	O
break	O
;	O
case	O
21	int
:	O
{	O
(	O
rw_yyval	union
.	O
var	pointer
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
(	O
rw_yyval	union
.	O
var	pointer
)	O
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	pointer
)	O
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
(	O
rw_yyval	union
.	O
var	pointer
)	O
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	pointer
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
(	O
rw_yyval	union
.	O
var	pointer
)	O
=	O
var_alloc	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
type	int
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	pointer
)	O
,	O
+	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
26	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
27	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
arg	pointer
)	O
.	O
arg_first	pointer
;	O
}	O
break	O
;	O
case	O
28	int
:	O
{	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
mtx	union
)	O
->	O
gen	struct
.	O
arglink	pointer
=	O
NULL	O
;	O
(	O
rw_yyval	union
.	O
arg	pointer
)	O
.	O
arg_first	pointer
=	O
(	O
rw_yyval	union
.	O
arg	pointer
)	O
.	O
arg_last	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
mtx	union
)	O
;	O
}	O
break	O
;	O
case	O
29	int
:	O
{	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arg	pointer
)	O
.	O
arg_last	pointer
->	O
gen	struct
.	O
arglink	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
;	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arg	pointer
)	O
.	O
arg_last	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
;	O
(	O
rw_yyval	union
.	O
arg	pointer
)	O
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
arg	pointer
)	O
;	O
}	O
break	O
;	O
case	O
33	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
;	O
}	O
break	O
;	O
case	O
34	int
:	O
{	O
mtx_stop	function
(	O
)	O
;	O
mtx_pop	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
35	int
:	O
{	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
->	O
cond	int
.	O
if_false	pointer
=	O
mtx_nop	function
(	O
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_cur	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
36	int
:	O
{	O
mtx_stop	function
(	O
)	O
;	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
mtx	union
)	O
->	O
cond	int
.	O
if_false	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
mtx	union
)	O
;	O
(	O
rw_yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
mtx	union
)	O
->	O
nop	struct
.	O
prev	pointer
->	O
jump	struct
.	O
dest	pointer
=	O
mtx_nop	function
(	O
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_cur	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
37	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_return	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
38	int
:	O
{	O
MTX	union
*	O
mtx	union
;	O
mtx_stop	function
(	O
)	O
;	O
mtx	union
=	O
mtx_jump	function
(	O
)	O
;	O
mtx	union
->	O
jump	struct
.	O
dest	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
;	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
->	O
cond	int
.	O
if_false	pointer
=	O
mtx_nop	function
(	O
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_cur	function
(	O
)	O
;	O
loop_fixup	function
(	O
loop_last	pointer
->	O
lp_break	pointer
,	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
)	O
;	O
loop_fixup	function
(	O
loop_last	pointer
->	O
lp_cont	pointer
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
loop_pop	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
39	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_nop	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
40	int
:	O
{	O
(	O
rw_yyvsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	union
)	O
->	O
cond	int
.	O
if_false	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	union
)	O
->	O
cond	int
.	O
if_true	pointer
;	O
(	O
rw_yyvsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	union
)	O
->	O
cond	int
.	O
if_true	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	union
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_cur	function
(	O
)	O
;	O
loop_fixup	function
(	O
loop_last	pointer
->	O
lp_break	pointer
,	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
)	O
;	O
loop_fixup	function
(	O
loop_last	pointer
->	O
lp_cont	pointer
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
loop_pop	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
41	int
:	O
{	O
if	O
(	O
!	O
loop_last	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"nothing to break from"	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_jump	function
(	O
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
->	O
jump	struct
.	O
link	function
=	O
(	O
MTX	union
*	O
)	O
loop_last	pointer
->	O
lp_break	pointer
;	O
loop_last	pointer
->	O
lp_break	pointer
=	O
(	O
JUMP_MTX	struct
*	O
)	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
;	O
}	O
break	O
;	O
case	O
42	int
:	O
{	O
if	O
(	O
!	O
loop_last	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"nothing to continue"	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_jump	function
(	O
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
->	O
jump	struct
.	O
link	function
=	O
(	O
MTX	union
*	O
)	O
loop_last	pointer
->	O
lp_cont	pointer
;	O
loop_last	pointer
->	O
lp_cont	pointer
=	O
(	O
JUMP_MTX	struct
*	O
)	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
;	O
}	O
break	O
;	O
case	O
43	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_attr_delete	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
attr	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
44	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_attr_delete	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
attr	pointer
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
45	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_nop	function
(	O
)	O
;	O
loop_push	function
(	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
46	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_nop	function
(	O
)	O
;	O
loop_push	function
(	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
47	int
:	O
{	O
mtx_stop	function
(	O
)	O
;	O
mtx_jump	function
(	O
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_nop	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
48	int
:	O
{	O
mtx_stop	function
(	O
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_cond	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
->	O
cond	int
.	O
if_true	pointer
=	O
mtx_nop	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
49	int
:	O
{	O
grad_value_t	struct
val	array
;	O
val	array
.	O
type	int
=	O
Integer	int
;	O
val	array
.	O
datum	union
.	O
ival	int
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	long
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_const	function
(	O
&	O
val	array
)	O
;	O
}	O
break	O
;	O
case	O
50	int
:	O
{	O
grad_value_t	struct
val	array
;	O
val	array
.	O
type	int
=	O
String	int
;	O
val	array
.	O
datum	union
.	O
sval	struct
.	O
size	int
=	O
strlen	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	pointer
)	O
)	O
;	O
val	array
.	O
datum	union
.	O
sval	struct
.	O
data	pointer
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	pointer
)	O
;	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_const	function
(	O
&	O
val	array
)	O
;	O
}	O
break	O
;	O
case	O
51	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_ref	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	long
)	O
)	O
;	O
}	O
break	O
;	O
case	O
52	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_var	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
var	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
53	int
:	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"undefined variable: %s"	pointer
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
54	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_asgn	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
var	pointer
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
55	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_attr	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
attr	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
56	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_attr	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
attr	pointer
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
57	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_attr_check	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
attr	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
58	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_attr_check	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
attr	pointer
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
59	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_attr_asgn	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
attr	pointer
)	O
,	O
NULL	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
60	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_attr_asgn	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
attr	pointer
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
61	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_call	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
fun	pointer
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
62	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_builtin	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
btin	struct
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
63	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Add	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
64	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Sub	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
65	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Mul	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
66	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Div	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
67	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Rem	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
68	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
BOr	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
69	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
BAnd	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
70	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
BXor	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
71	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Shl	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
72	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Shr	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
73	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
And	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
74	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Or	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
75	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_un	function
(	O
Neg	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
76	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
mtx	union
)	O
;	O
}	O
break	O
;	O
case	O
77	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_un	function
(	O
Not	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
78	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
;	O
}	O
break	O
;	O
case	O
79	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_coerce	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
type	int
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
80	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Eq	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
81	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Ne	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
82	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Lt	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
83	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Le	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
84	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Gt	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
85	int
:	O
{	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_bin	function
(	O
Ge	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
)	O
;	O
}	O
break	O
;	O
case	O
86	int
:	O
{	O
COMP_REGEX	struct
*	O
rx	pointer
;	O
if	O
(	O
(	O
rx	pointer
=	O
compile_regexp	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_match	function
(	O
0	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
rx	pointer
)	O
;	O
}	O
break	O
;	O
case	O
87	int
:	O
{	O
COMP_REGEX	struct
*	O
rx	pointer
;	O
if	O
(	O
(	O
rx	pointer
=	O
compile_regexp	function
(	O
(	O
rw_yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errcnt	long
++	O
;	O
YYERROR	O
;	O
}	O
(	O
rw_yyval	union
.	O
mtx	union
)	O
=	O
mtx_match	function
(	O
1	int
,	O
(	O
rw_yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
mtx	union
)	O
,	O
rx	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	pointer
,	O
rw_yyr1	array
[	O
rw_yyn	int
]	O
,	O
&	O
rw_yyval	union
,	O
&	O
rw_yyloc	O
)	O
;	O
YYPOPSTACK	O
(	O
rw_yylen	int
)	O
;	O
rw_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
rw_yyss	short
,	O
rw_yyssp	pointer
)	O
;	O
*	O
++	O
rw_yyvsp	pointer
=	O
rw_yyval	union
;	O
rw_yyn	int
=	O
rw_yyr1	array
[	O
rw_yyn	int
]	O
;	O
rw_yystate	int
=	O
rw_yypgoto	array
[	O
rw_yyn	int
-	O
YYNTOKENS	int
]	O
+	O
*	O
rw_yyssp	pointer
;	O
if	O
(	O
0	int
<=	O
rw_yystate	int
&&	O
rw_yystate	int
<=	O
YYLAST	int
&&	O
rw_yycheck	array
[	O
rw_yystate	int
]	O
==	O
*	O
rw_yyssp	pointer
)	O
rw_yystate	int
=	O
rw_yytable	array
[	O
rw_yystate	int
]	O
;	O
else	O
rw_yystate	int
=	O
rw_yydefgoto	array
[	O
rw_yyn	int
-	O
YYNTOKENS	int
]	O
;	O
goto	O
rw_yynewstate	O
;	O
rw_yyerrlab	O
:	O
if	O
(	O
!	O
rw_yyerrstatus	int
)	O
{	O
++	O
rw_yynerrs	int
;	O
rw_yyerror	function
(	O
YY_	O
(	O
"syntax error"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
rw_yyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
rw_yychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
rw_yychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
rw_yydestruct	function
(	O
"Error: discarding"	pointer
,	O
rw_yytoken	int
,	O
&	O
rw_yylval	union
)	O
;	O
rw_yychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
rw_yyerrlab1	O
;	O
rw_yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
rw_yyerrorlab	O
;	O
YYPOPSTACK	O
(	O
rw_yylen	int
)	O
;	O
rw_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
rw_yyss	short
,	O
rw_yyssp	pointer
)	O
;	O
rw_yystate	int
=	O
*	O
rw_yyssp	pointer
;	O
goto	O
rw_yyerrlab1	O
;	O
rw_yyerrlab1	O
:	O
rw_yyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
rw_yyn	int
=	O
rw_yypact	array
[	O
rw_yystate	int
]	O
;	O
if	O
(	O
rw_yyn	int
!=	O
YYPACT_NINF	O
)	O
{	O
rw_yyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
rw_yyn	int
&&	O
rw_yyn	int
<=	O
YYLAST	int
&&	O
rw_yycheck	array
[	O
rw_yyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
rw_yyn	int
=	O
rw_yytable	array
[	O
rw_yyn	int
]	O
;	O
if	O
(	O
0	int
<	O
rw_yyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
rw_yyssp	pointer
==	O
rw_yyss	short
)	O
YYABORT	O
;	O
rw_yydestruct	function
(	O
"Error: popping"	pointer
,	O
rw_yystos	array
[	O
rw_yystate	int
]	O
,	O
rw_yyvsp	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
rw_yystate	int
=	O
*	O
rw_yyssp	pointer
;	O
YY_STACK_PRINT	O
(	O
rw_yyss	short
,	O
rw_yyssp	pointer
)	O
;	O
}	O
if	O
(	O
rw_yyn	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
*	O
++	O
rw_yyvsp	pointer
=	O
rw_yylval	union
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
rw_yystos	array
[	O
rw_yyn	int
]	O
,	O
rw_yyvsp	pointer
,	O
rw_yylsp	O
)	O
;	O
rw_yystate	int
=	O
rw_yyn	int
;	O
goto	O
rw_yynewstate	O
;	O
rw_yyacceptlab	O
:	O
rw_yyresult	int
=	O
0	int
;	O
goto	O
rw_yyreturn	O
;	O
rw_yyabortlab	O
:	O
rw_yyresult	int
=	O
1	int
;	O
goto	O
rw_yyreturn	O
;	O
rw_yyexhaustedlab	O
:	O
rw_yyerror	function
(	O
YY_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
rw_yyresult	int
=	O
2	int
;	O
rw_yyreturn	O
:	O
if	O
(	O
rw_yychar	int
!=	O
YYEOF	int
&&	O
rw_yychar	int
!=	O
YYEMPTY	O
)	O
rw_yydestruct	function
(	O
"Cleanup: discarding lookahead"	pointer
,	O
rw_yytoken	int
,	O
&	O
rw_yylval	union
)	O
;	O
YYPOPSTACK	O
(	O
rw_yylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
rw_yyss	short
,	O
rw_yyssp	pointer
)	O
;	O
while	O
(	O
rw_yyssp	pointer
!=	O
rw_yyss	short
)	O
{	O
rw_yydestruct	function
(	O
"Cleanup: popping"	pointer
,	O
rw_yystos	array
[	O
*	O
rw_yyssp	pointer
]	O
,	O
rw_yyvsp	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
rw_yyss	short
!=	O
rw_yyssa	array
)	O
YYSTACK_FREE	O
(	O
rw_yyss	short
)	O
;	O
return	O
YYID	O
(	O
rw_yyresult	int
)	O
;	O
}	O
int	O
rw_yyerror	function
(	O
char	O
*	O
s	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
int	O
parse_rewrite	function
(	O
char	O
*	O
path	pointer
)	O
{	O
locus	struct
.	O
file	pointer
=	O
path	pointer
;	O
infile	pointer
=	O
fopen	function
(	O
locus	struct
.	O
file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
infile	pointer
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't open file `%s'"	pointer
)	O
,	O
locus	struct
.	O
file	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
-	O
2	int
;	O
}	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"Loading file %s"	pointer
,	O
locus	struct
.	O
file	pointer
)	O
;	O
rw_code_lock	O
(	O
)	O
;	O
rw_yyeof	int
=	O
0	int
;	O
locus	struct
.	O
line	long
=	O
1	int
;	O
errcnt	long
=	O
0	int
;	O
regex_init	O
(	O
)	O
;	O
obstack_init	O
(	O
&	O
input_stk	struct
)	O
;	O
mtx_init	function
(	O
)	O
;	O
var_init	function
(	O
)	O
;	O
loop_init	function
(	O
)	O
;	O
frame_init	function
(	O
)	O
;	O
frame_push	function
(	O
)	O
;	O
rw_yyparse	function
(	O
)	O
;	O
var_free_all	function
(	O
)	O
;	O
frame_free_all	function
(	O
)	O
;	O
mtx_free_all	function
(	O
)	O
;	O
fclose	function
(	O
infile	pointer
)	O
;	O
obstack_free	function
(	O
&	O
input_stk	struct
,	O
NULL	O
)	O
;	O
rw_code_unlock	O
(	O
)	O
;	O
return	O
errcnt	long
;	O
}	O
static	O
int	O
parse_rewrite_string	function
(	O
char	O
*	O
str	pointer
)	O
{	O
rw_code_lock	O
(	O
)	O
;	O
code_check	function
(	O
)	O
;	O
rw_yyeof	int
=	O
0	int
;	O
locus	struct
.	O
file	pointer
=	O
"<string>"	pointer
;	O
locus	struct
.	O
line	long
=	O
1	int
;	O
errcnt	long
=	O
0	int
;	O
regex_init	O
(	O
)	O
;	O
obstack_init	O
(	O
&	O
input_stk	struct
)	O
;	O
mtx_init	function
(	O
)	O
;	O
var_init	function
(	O
)	O
;	O
loop_init	function
(	O
)	O
;	O
frame_init	function
(	O
)	O
;	O
frame_push	function
(	O
)	O
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
50	int
)	O
)	O
rw_yydebug	int
++	O
;	O
infile	pointer
=	O
0	int
;	O
inbuf	pointer
=	O
curp	pointer
=	O
str	pointer
;	O
rw_yyparse	function
(	O
)	O
;	O
var_free_all	function
(	O
)	O
;	O
frame_free_all	function
(	O
)	O
;	O
mtx_free_all	function
(	O
)	O
;	O
obstack_free	function
(	O
&	O
input_stk	struct
,	O
NULL	O
)	O
;	O
rw_code_unlock	O
(	O
)	O
;	O
return	O
errcnt	long
;	O
}	O
static	O
int	O
unput	function
(	O
int	O
c	pointer
)	O
{	O
if	O
(	O
!	O
c	pointer
)	O
return	O
0	int
;	O
if	O
(	O
infile	pointer
)	O
ungetc	function
(	O
c	pointer
,	O
infile	pointer
)	O
;	O
else	O
if	O
(	O
curp	pointer
>	O
inbuf	pointer
)	O
*	O
--	O
curp	pointer
=	O
c	pointer
;	O
return	O
c	pointer
;	O
}	O
static	O
int	O
input	pointer
(	O
)	O
{	O
if	O
(	O
rw_yyeof	int
)	O
rw_yychar	int
=	O
0	int
;	O
else	O
if	O
(	O
infile	pointer
)	O
{	O
if	O
(	O
(	O
rw_yychar	int
=	O
getc	function
(	O
infile	pointer
)	O
)	O
<=	O
0	int
)	O
{	O
rw_yyeof	int
++	O
;	O
rw_yychar	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
curp	pointer
)	O
{	O
rw_yychar	int
=	O
*	O
curp	pointer
++	O
;	O
if	O
(	O
!	O
rw_yychar	int
)	O
rw_yyeof	int
++	O
;	O
}	O
return	O
rw_yychar	int
;	O
}	O
static	O
int	O
rw_backslash	function
(	O
)	O
;	O
static	O
int	O
c2d	function
(	O
int	O
c	pointer
)	O
;	O
static	O
int	O
read_number	function
(	O
)	O
;	O
static	O
int	O
read_num	function
(	O
int	O
n	long
,	O
int	O
base	int
)	O
;	O
static	O
char	O
*	O
read_string	function
(	O
)	O
;	O
static	O
char	O
*	O
read_ident	function
(	O
int	O
c	pointer
)	O
;	O
static	O
char	O
*	O
read_to_delim	function
(	O
int	O
c	pointer
)	O
;	O
static	O
int	O
skip_to_nl	function
(	O
)	O
;	O
static	O
int	O
c_comment	function
(	O
)	O
;	O
int	O
c2d	function
(	O
int	O
c	pointer
)	O
{	O
switch	O
(	O
c	pointer
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
return	O
c	pointer
-	O
'0'	O
;	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
return	O
c	pointer
-	O
'A'	O
+	O
16	int
;	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
return	O
c	pointer
-	O
'a'	O
+	O
10	int
;	O
}	O
return	O
100	int
;	O
}	O
int	O
read_number	function
(	O
)	O
{	O
int	O
c	pointer
;	O
int	O
base	int
;	O
int	O
res	int
;	O
c	pointer
=	O
rw_yychar	int
;	O
if	O
(	O
c	pointer
==	O
'0'	O
)	O
{	O
if	O
(	O
input	pointer
(	O
)	O
==	O
'x'	O
||	O
rw_yychar	int
==	O
'X'	O
)	O
{	O
base	int
=	O
16	int
;	O
}	O
else	O
{	O
base	int
=	O
8	int
;	O
unput	function
(	O
rw_yychar	int
)	O
;	O
}	O
}	O
else	O
base	int
=	O
10	int
;	O
res	int
=	O
read_num	function
(	O
c2d	function
(	O
c	pointer
)	O
,	O
base	int
)	O
;	O
if	O
(	O
base	int
==	O
10	int
&&	O
rw_yychar	int
==	O
'.'	O
)	O
{	O
int	O
n	long
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
3	int
&&	O
rw_yychar	int
==	O
'.'	O
;	O
n	long
++	O
)	O
{	O
int	O
val	array
;	O
input	pointer
(	O
)	O
;	O
val	array
=	O
read_num	function
(	O
0	int
,	O
base	int
)	O
;	O
res	int
=	O
(	O
res	int
<<	O
8	int
)	O
+	O
val	array
;	O
}	O
if	O
(	O
n	long
!=	O
3	int
)	O
res	int
<<=	O
8	int
*	O
(	O
3	int
-	O
n	long
)	O
;	O
}	O
return	O
res	int
;	O
}	O
int	O
read_num	function
(	O
int	O
n	long
,	O
int	O
base	int
)	O
{	O
int	O
d	pointer
;	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
(	O
d	pointer
=	O
c2d	function
(	O
rw_yychar	int
)	O
)	O
<	O
16	int
)	O
n	long
=	O
n	long
*	O
base	int
+	O
d	pointer
;	O
unput	function
(	O
rw_yychar	int
)	O
;	O
return	O
n	long
;	O
}	O
int	O
rw_backslash	function
(	O
)	O
{	O
switch	O
(	O
input	pointer
(	O
)	O
)	O
{	O
case	O
'\\'	O
:	O
return	O
'\\'	O
;	O
case	O
'a'	O
:	O
return	O
'\a'	O
;	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'e'	O
:	O
return	O
'\033'	O
;	O
case	O
'0'	O
:	O
return	O
read_number	function
(	O
)	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
return	O
read_num	function
(	O
0	int
,	O
16	int
)	O
;	O
case	O
'('	O
:	O
case	O
')'	O
:	O
unput	function
(	O
rw_yychar	int
)	O
;	O
rw_yychar	int
=	O
'\\'	O
;	O
}	O
return	O
rw_yychar	int
;	O
}	O
char	O
*	O
read_string	function
(	O
)	O
{	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
rw_yychar	int
!=	O
'"'	O
)	O
{	O
if	O
(	O
rw_yychar	int
==	O
'\\'	O
)	O
rw_yychar	int
=	O
rw_backslash	function
(	O
)	O
;	O
obstack_1grow	O
(	O
&	O
input_stk	struct
,	O
rw_yychar	int
)	O
;	O
}	O
obstack_1grow	O
(	O
&	O
input_stk	struct
,	O
0	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
input_stk	struct
)	O
;	O
}	O
char	O
*	O
read_to_delim	function
(	O
int	O
c	pointer
)	O
{	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
rw_yychar	int
!=	O
c	pointer
)	O
obstack_1grow	O
(	O
&	O
input_stk	struct
,	O
rw_yychar	int
)	O
;	O
obstack_1grow	O
(	O
&	O
input_stk	struct
,	O
0	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
input_stk	struct
)	O
;	O
}	O
char	O
*	O
read_ident	function
(	O
int	O
c	pointer
)	O
{	O
obstack_1grow	O
(	O
&	O
input_stk	struct
,	O
c	pointer
)	O
;	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
isword	O
(	O
rw_yychar	int
)	O
)	O
obstack_1grow	O
(	O
&	O
input_stk	struct
,	O
rw_yychar	int
)	O
;	O
obstack_1grow	O
(	O
&	O
input_stk	struct
,	O
0	int
)	O
;	O
unput	function
(	O
rw_yychar	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
input_stk	struct
)	O
;	O
}	O
int	O
skip_to_nl	function
(	O
)	O
{	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
rw_yychar	int
!=	O
'\n'	O
)	O
;	O
return	O
unput	function
(	O
rw_yychar	int
)	O
;	O
}	O
int	O
c_comment	function
(	O
)	O
{	O
if	O
(	O
rw_yychar	int
!=	O
'/'	O
)	O
return	O
0	int
;	O
if	O
(	O
input	pointer
(	O
)	O
==	O
'*'	O
)	O
{	O
size_t	long
keep_line	long
=	O
locus	struct
.	O
line	long
;	O
do	O
{	O
while	O
(	O
input	pointer
(	O
)	O
!=	O
'*'	O
)	O
{	O
if	O
(	O
rw_yychar	int
==	O
0	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"unexpected EOF in comment started at line %lu"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
keep_line	long
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
rw_yychar	int
==	O
'\n'	O
)	O
locus	struct
.	O
line	long
++	O
;	O
}	O
}	O
while	O
(	O
input	pointer
(	O
)	O
!=	O
'/'	O
)	O
;	O
return	O
1	int
;	O
}	O
unput	function
(	O
rw_yychar	int
)	O
;	O
rw_yychar	int
=	O
'/'	O
;	O
return	O
0	int
;	O
}	O
enum	O
pragma_handler_phase	enum
{	O
pragma_begin	int
,	O
pragma_cont	int
,	O
pragma_error	int
,	O
pragma_end	int
}	O
;	O
typedef	O
int	O
(	O
*	O
pragma_handler_fp	pointer
)	O
(	O
enum	O
pragma_handler_phase	enum
)	O
;	O
static	O
int	O
regex_pragma	function
(	O
enum	O
pragma_handler_phase	enum
phase	enum
)	O
{	O
int	O
disable	int
=	O
0	int
;	O
int	O
bit	int
;	O
char	O
*	O
s	pointer
;	O
static	O
int	O
regexp_accum	int
;	O
switch	O
(	O
phase	enum
)	O
{	O
case	O
pragma_begin	int
:	O
regexp_accum	int
=	O
0	int
;	O
return	O
0	int
;	O
case	O
pragma_end	int
:	O
regcomp_flags	int
=	O
regexp_accum	int
;	O
return	O
0	int
;	O
case	O
pragma_error	int
:	O
return	O
0	int
;	O
case	O
pragma_cont	int
:	O
break	O
;	O
}	O
switch	O
(	O
rw_yychar	int
)	O
{	O
case	O
'+'	O
:	O
disable	int
=	O
0	int
;	O
input	pointer
(	O
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
disable	int
=	O
1	int
;	O
input	pointer
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
isword	O
(	O
rw_yychar	int
)	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"Malformed pragma"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
s	pointer
=	O
read_ident	function
(	O
rw_yychar	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"extended"	pointer
)	O
==	O
0	int
)	O
bit	int
=	O
REG_EXTENDED	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"icase"	pointer
)	O
==	O
0	int
)	O
bit	int
=	O
REG_ICASE	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"newline"	pointer
)	O
==	O
0	int
)	O
bit	int
=	O
REG_NEWLINE	O
;	O
else	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"Unknown regexp flag: %s"	pointer
)	O
,	O
s	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
disable	int
)	O
regexp_accum	int
&=	O
~	O
bit	int
;	O
else	O
regexp_accum	int
|=	O
bit	int
;	O
return	O
0	int
;	O
}	O
static	O
pragma_handler_fp	pointer
find_pragma_handler	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"regex"	pointer
)	O
==	O
0	int
)	O
return	O
regex_pragma	function
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
handle_pragma	function
(	O
)	O
{	O
int	O
rc	int
;	O
pragma_handler_fp	pointer
pragma_handler	pointer
;	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
isws	O
(	O
rw_yychar	int
)	O
)	O
;	O
if	O
(	O
rw_yychar	int
==	O
0	int
)	O
return	O
;	O
pragma_handler	pointer
=	O
find_pragma_handler	function
(	O
read_ident	function
(	O
rw_yychar	int
)	O
)	O
;	O
if	O
(	O
pragma_handler	pointer
)	O
{	O
pragma_handler	pointer
(	O
pragma_begin	int
)	O
;	O
do	O
{	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
isws	O
(	O
rw_yychar	int
)	O
)	O
;	O
if	O
(	O
rw_yychar	int
==	O
0	int
||	O
rw_yychar	int
==	O
'\n'	O
)	O
break	O
;	O
rc	int
=	O
pragma_handler	pointer
(	O
pragma_cont	int
)	O
;	O
}	O
while	O
(	O
rc	int
==	O
0	int
&&	O
rw_yychar	int
!=	O
'\n'	O
&&	O
rw_yychar	int
!=	O
0	int
)	O
;	O
pragma_handler	pointer
(	O
rc	int
?	O
pragma_error	int
:	O
pragma_end	int
)	O
;	O
}	O
}	O
void	O
sharp_comment	function
(	O
)	O
{	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
isws	O
(	O
rw_yychar	int
)	O
)	O
;	O
if	O
(	O
rw_yychar	int
==	O
0	int
)	O
return	O
;	O
else	O
if	O
(	O
rw_yychar	int
==	O
'\n'	O
)	O
{	O
locus	struct
.	O
line	long
++	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
isword	O
(	O
rw_yychar	int
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
read_ident	function
(	O
rw_yychar	int
)	O
,	O
"pragma"	pointer
)	O
==	O
0	int
)	O
handle_pragma	function
(	O
)	O
;	O
}	O
skip_to_nl	function
(	O
)	O
;	O
}	O
static	O
grad_keyword_t	struct
rw_kw	array
[	O
]	O
=	O
{	O
{	O
"if"	pointer
,	O
IF	int
}	O
,	O
{	O
"else"	pointer
,	O
ELSE	int
}	O
,	O
{	O
"return"	pointer
,	O
RETURN	int
}	O
,	O
{	O
"for"	pointer
,	O
FOR	int
}	O
,	O
{	O
"do"	pointer
,	O
DO	int
}	O
,	O
{	O
"while"	pointer
,	O
WHILE	int
}	O
,	O
{	O
"break"	pointer
,	O
BREAK	int
}	O
,	O
{	O
"continue"	pointer
,	O
CONTINUE	int
}	O
,	O
{	O
"delete"	pointer
,	O
DELETE	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
rw_yylex	function
(	O
)	O
{	O
int	O
nl	int
;	O
int	O
c	pointer
;	O
VAR	struct
*	O
var	pointer
;	O
FUNCTION	struct
*	O
fun	pointer
;	O
builtin_t	struct
*	O
btin	struct
;	O
do	O
{	O
nl	int
=	O
0	int
;	O
while	O
(	O
input	pointer
(	O
)	O
&&	O
isspace	function
(	O
rw_yychar	int
)	O
)	O
if	O
(	O
rw_yychar	int
==	O
'\n'	O
)	O
locus	struct
.	O
line	long
++	O
;	O
if	O
(	O
!	O
rw_yychar	int
)	O
return	O
0	int
;	O
if	O
(	O
rw_yychar	int
==	O
'#'	O
)	O
{	O
sharp_comment	function
(	O
)	O
;	O
nl	int
=	O
1	int
;	O
}	O
}	O
while	O
(	O
nl	int
||	O
c_comment	function
(	O
)	O
)	O
;	O
if	O
(	O
rw_yychar	int
==	O
'\\'	O
)	O
{	O
input	pointer
(	O
)	O
;	O
rw_yylval	union
.	O
number	long
=	O
read_number	function
(	O
)	O
;	O
DEBUG_LEX2	O
(	O
"REFERENCE %d"	pointer
,	O
rw_yylval	union
.	O
number	long
)	O
;	O
return	O
REFERENCE	int
;	O
}	O
if	O
(	O
rw_yychar	int
==	O
'\''	O
)	O
{	O
if	O
(	O
input	pointer
(	O
)	O
==	O
'\\'	O
)	O
c	pointer
=	O
rw_backslash	function
(	O
)	O
;	O
else	O
c	pointer
=	O
rw_yychar	int
;	O
if	O
(	O
input	pointer
(	O
)	O
!=	O
'\''	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"unterminated character constant"	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
}	O
rw_yylval	union
.	O
number	long
=	O
c	pointer
;	O
DEBUG_LEX2	O
(	O
"CHAR %d"	pointer
,	O
c	pointer
)	O
;	O
return	O
NUMBER	int
;	O
}	O
if	O
(	O
isdigit	function
(	O
rw_yychar	int
)	O
)	O
{	O
rw_yylval	union
.	O
number	long
=	O
read_number	function
(	O
)	O
;	O
DEBUG_LEX2	O
(	O
"NUMBER %d"	pointer
,	O
rw_yylval	union
.	O
number	long
)	O
;	O
return	O
NUMBER	int
;	O
}	O
if	O
(	O
rw_yychar	int
==	O
'"'	O
)	O
{	O
rw_yylval	union
.	O
string	pointer
=	O
read_string	function
(	O
)	O
;	O
DEBUG_LEX2	O
(	O
"STRING %s"	pointer
,	O
rw_yylval	union
.	O
string	pointer
)	O
;	O
return	O
STRING	int
;	O
}	O
if	O
(	O
rw_yychar	int
==	O
'%'	O
)	O
{	O
grad_dict_attr_t	struct
*	O
attr	pointer
=	O
0	int
;	O
char	O
*	O
attr_name	pointer
;	O
input	pointer
(	O
)	O
;	O
if	O
(	O
rw_yychar	int
==	O
'['	O
||	O
rw_yychar	int
==	O
'{'	O
)	O
{	O
attr_name	pointer
=	O
read_to_delim	function
(	O
rw_yychar	int
==	O
'['	O
?	O
']'	O
:	O
'}'	O
)	O
;	O
attr	pointer
=	O
grad_attr_name_to_dict	function
(	O
attr_name	pointer
)	O
;	O
}	O
else	O
{	O
unput	function
(	O
rw_yychar	int
)	O
;	O
return	O
'%'	O
;	O
}	O
if	O
(	O
!	O
attr	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"unknown attribute `%s'"	pointer
)	O
,	O
attr_name	pointer
)	O
;	O
errcnt	long
++	O
;	O
return	O
BOGUS	int
;	O
}	O
rw_yylval	union
.	O
attr	pointer
=	O
attr	pointer
;	O
DEBUG_LEX2	O
(	O
"ATTR: %s"	pointer
,	O
attr	pointer
->	O
name	pointer
)	O
;	O
return	O
ATTR	int
;	O
}	O
if	O
(	O
isword	O
(	O
rw_yychar	int
)	O
)	O
{	O
rw_yylval	union
.	O
string	pointer
=	O
read_ident	function
(	O
rw_yychar	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
rw_yylval	union
.	O
string	pointer
,	O
"integer"	pointer
)	O
==	O
0	int
)	O
{	O
DEBUG_LEX1	O
(	O
"TYPE(Integer)"	pointer
)	O
;	O
rw_yylval	union
.	O
type	int
=	O
Integer	int
;	O
return	O
TYPE	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
rw_yylval	union
.	O
string	pointer
,	O
"string"	pointer
)	O
==	O
0	int
)	O
{	O
DEBUG_LEX1	O
(	O
"TYPE(String)"	pointer
)	O
;	O
rw_yylval	union
.	O
type	int
=	O
String	int
;	O
return	O
TYPE	int
;	O
}	O
if	O
(	O
(	O
c	pointer
=	O
grad_xlat_keyword	function
(	O
rw_kw	array
,	O
rw_yylval	union
.	O
string	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
DEBUG_LEX2	O
(	O
"KW: %s"	pointer
,	O
rw_yylval	union
.	O
string	pointer
)	O
;	O
return	O
c	pointer
;	O
}	O
if	O
(	O
var	pointer
=	O
var_lookup	function
(	O
rw_yylval	union
.	O
string	pointer
)	O
)	O
{	O
DEBUG_LEX2	O
(	O
"VARIABLE: %s"	pointer
,	O
rw_yylval	union
.	O
string	pointer
)	O
;	O
rw_yylval	union
.	O
var	pointer
=	O
var	pointer
;	O
return	O
VARIABLE	int
;	O
}	O
if	O
(	O
fun	pointer
=	O
(	O
FUNCTION	struct
*	O
)	O
grad_sym_lookup	function
(	O
rewrite_tab	pointer
,	O
rw_yylval	union
.	O
string	pointer
)	O
)	O
{	O
DEBUG_LEX2	O
(	O
"FUN %s"	pointer
,	O
rw_yylval	union
.	O
string	pointer
)	O
;	O
rw_yylval	union
.	O
fun	pointer
=	O
fun	pointer
;	O
return	O
FUN	int
;	O
}	O
if	O
(	O
btin	struct
=	O
builtin_lookup	function
(	O
rw_yylval	union
.	O
string	pointer
)	O
)	O
{	O
DEBUG_LEX2	O
(	O
"BUILTIN %s"	pointer
,	O
rw_yylval	union
.	O
string	pointer
)	O
;	O
rw_yylval	union
.	O
btin	struct
=	O
btin	struct
;	O
return	O
BUILTIN	int
;	O
}	O
DEBUG_LEX2	O
(	O
"IDENT: %s"	pointer
,	O
rw_yylval	union
.	O
string	pointer
)	O
;	O
return	O
IDENT	int
;	O
}	O
if	O
(	O
rw_yychar	int
==	O
'&'	O
||	O
rw_yychar	int
==	O
'|'	O
)	O
{	O
int	O
c	pointer
=	O
rw_yychar	int
;	O
if	O
(	O
input	pointer
(	O
)	O
==	O
c	pointer
)	O
{	O
DEBUG_LEX2	O
(	O
"%s"	pointer
,	O
rw_yychar	int
==	O
'&'	O
?	O
"AND"	pointer
:	O
"OR"	pointer
)	O
;	O
return	O
rw_yychar	int
==	O
'&'	O
?	O
AND	int
:	O
OR	int
;	O
}	O
unput	function
(	O
rw_yychar	int
)	O
;	O
DEBUG_LEX2	O
(	O
"%c"	pointer
,	O
c	pointer
)	O
;	O
return	O
c	pointer
;	O
}	O
if	O
(	O
strchr	function
(	O
"<>=!"	pointer
,	O
rw_yychar	int
)	O
)	O
{	O
int	O
c	pointer
=	O
rw_yychar	int
;	O
if	O
(	O
input	pointer
(	O
)	O
==	O
'='	O
)	O
{	O
switch	O
(	O
c	pointer
)	O
{	O
case	O
'<'	O
:	O
DEBUG_LEX1	O
(	O
"LE"	pointer
)	O
;	O
return	O
LE	int
;	O
case	O
'>'	O
:	O
DEBUG_LEX1	O
(	O
"GE"	pointer
)	O
;	O
return	O
GE	int
;	O
case	O
'='	O
:	O
DEBUG_LEX1	O
(	O
"EQ"	pointer
)	O
;	O
return	O
EQ	int
;	O
case	O
'!'	O
:	O
DEBUG_LEX1	O
(	O
"NE"	pointer
)	O
;	O
return	O
NE	int
;	O
}	O
}	O
else	O
if	O
(	O
c	pointer
==	O
rw_yychar	int
)	O
{	O
if	O
(	O
c	pointer
==	O
'<'	O
)	O
{	O
DEBUG_LEX1	O
(	O
"SHL"	pointer
)	O
;	O
return	O
SHL	int
;	O
}	O
if	O
(	O
c	pointer
==	O
'>'	O
)	O
{	O
DEBUG_LEX1	O
(	O
"SHR"	pointer
)	O
;	O
return	O
SHR	int
;	O
}	O
unput	function
(	O
rw_yychar	int
)	O
;	O
DEBUG_LEX2	O
(	O
"%c"	pointer
,	O
rw_yychar	int
)	O
;	O
return	O
rw_yychar	int
;	O
}	O
else	O
if	O
(	O
rw_yychar	int
==	O
'~'	O
)	O
{	O
if	O
(	O
c	pointer
==	O
'='	O
)	O
{	O
DEBUG_LEX1	O
(	O
"MT"	pointer
)	O
;	O
return	O
MT	int
;	O
}	O
if	O
(	O
c	pointer
==	O
'!'	O
)	O
{	O
DEBUG_LEX1	O
(	O
"NM"	pointer
)	O
;	O
return	O
NM	int
;	O
}	O
}	O
unput	function
(	O
rw_yychar	int
)	O
;	O
switch	O
(	O
c	pointer
)	O
{	O
case	O
'<'	O
:	O
DEBUG_LEX1	O
(	O
"LT"	pointer
)	O
;	O
return	O
LT	int
;	O
case	O
'>'	O
:	O
DEBUG_LEX1	O
(	O
"GT"	pointer
)	O
;	O
return	O
GT	int
;	O
case	O
'!'	O
:	O
DEBUG_LEX1	O
(	O
"NOT"	pointer
)	O
;	O
return	O
NOT	int
;	O
default	O
:	O
return	O
c	pointer
;	O
}	O
}	O
DEBUG_LEX2	O
(	O
"%c"	pointer
,	O
rw_yychar	int
)	O
;	O
return	O
rw_yychar	int
;	O
}	O
void	O
rw_yysync	function
(	O
)	O
{	O
while	O
(	O
skip_to_nl	function
(	O
)	O
==	O
'\n'	O
&&	O
!	O
isalpha	function
(	O
input	pointer
(	O
)	O
)	O
)	O
locus	struct
.	O
line	long
++	O
;	O
unput	function
(	O
rw_yychar	int
)	O
;	O
}	O
static	O
RWLIST	struct
*	O
_list_insert	function
(	O
RWLIST	struct
*	O
*	O
first	pointer
,	O
RWLIST	struct
*	O
*	O
last	pointer
,	O
RWLIST	struct
*	O
prev	pointer
,	O
RWLIST	struct
*	O
obj	pointer
,	O
int	O
before	int
)	O
;	O
static	O
RWLIST	struct
*	O
_list_remove	function
(	O
RWLIST	struct
*	O
*	O
first	pointer
,	O
RWLIST	struct
*	O
*	O
last	pointer
,	O
RWLIST	struct
*	O
obj	pointer
)	O
;	O
static	O
RWLIST	struct
*	O
_list_append	function
(	O
RWLIST	struct
*	O
*	O
first	pointer
,	O
RWLIST	struct
*	O
*	O
last	pointer
,	O
RWLIST	struct
*	O
obj	pointer
)	O
;	O
RWLIST	struct
*	O
_list_append	function
(	O
RWLIST	struct
*	O
*	O
first	pointer
,	O
RWLIST	struct
*	O
*	O
last	pointer
,	O
RWLIST	struct
*	O
obj	pointer
)	O
{	O
return	O
rw_list_insert	O
(	O
first	pointer
,	O
last	pointer
,	O
*	O
last	pointer
,	O
obj	pointer
,	O
0	int
)	O
;	O
}	O
RWLIST	struct
*	O
_list_insert	function
(	O
RWLIST	struct
*	O
*	O
first	pointer
,	O
RWLIST	struct
*	O
*	O
last	pointer
,	O
RWLIST	struct
*	O
prev	pointer
,	O
RWLIST	struct
*	O
obj	pointer
,	O
int	O
before	int
)	O
{	O
RWLIST	struct
*	O
next	pointer
;	O
if	O
(	O
!	O
*	O
first	pointer
)	O
{	O
*	O
first	pointer
=	O
obj	pointer
;	O
if	O
(	O
last	pointer
)	O
*	O
last	pointer
=	O
obj	pointer
;	O
obj	pointer
->	O
prev	pointer
=	O
obj	pointer
->	O
next	pointer
=	O
NULL	O
;	O
return	O
obj	pointer
;	O
}	O
if	O
(	O
before	int
)	O
{	O
_list_insert	function
(	O
first	pointer
,	O
last	pointer
,	O
prev	pointer
,	O
obj	pointer
,	O
0	int
)	O
;	O
_list_remove	function
(	O
first	pointer
,	O
last	pointer
,	O
prev	pointer
)	O
;	O
_list_insert	function
(	O
first	pointer
,	O
last	pointer
,	O
obj	pointer
,	O
prev	pointer
,	O
0	int
)	O
;	O
return	O
obj	pointer
;	O
}	O
obj	pointer
->	O
prev	pointer
=	O
prev	pointer
;	O
obj	pointer
->	O
next	pointer
=	O
prev	pointer
->	O
next	pointer
;	O
if	O
(	O
next	pointer
=	O
prev	pointer
->	O
next	pointer
)	O
next	pointer
->	O
prev	pointer
=	O
obj	pointer
;	O
prev	pointer
->	O
next	pointer
=	O
obj	pointer
;	O
if	O
(	O
last	pointer
&&	O
prev	pointer
==	O
*	O
last	pointer
)	O
*	O
last	pointer
=	O
obj	pointer
;	O
return	O
obj	pointer
;	O
}	O
RWLIST	struct
*	O
_list_remove	function
(	O
RWLIST	struct
*	O
*	O
first	pointer
,	O
RWLIST	struct
*	O
*	O
last	pointer
,	O
RWLIST	struct
*	O
obj	pointer
)	O
{	O
RWLIST	struct
*	O
temp	union
;	O
if	O
(	O
temp	union
=	O
obj	pointer
->	O
prev	pointer
)	O
temp	union
->	O
next	pointer
=	O
obj	pointer
->	O
next	pointer
;	O
else	O
*	O
first	pointer
=	O
obj	pointer
->	O
next	pointer
;	O
if	O
(	O
temp	union
=	O
obj	pointer
->	O
next	pointer
)	O
temp	union
->	O
prev	pointer
=	O
obj	pointer
->	O
prev	pointer
;	O
else	O
if	O
(	O
last	pointer
)	O
*	O
last	pointer
=	O
obj	pointer
->	O
prev	pointer
;	O
obj	pointer
->	O
prev	pointer
=	O
obj	pointer
->	O
next	pointer
=	O
NULL	O
;	O
return	O
obj	pointer
;	O
}	O
void	O
*	O
obj_alloc	function
(	O
OBUCKET	struct
*	O
bucket	pointer
)	O
;	O
void	O
obj_free_all	function
(	O
OBUCKET	struct
*	O
bucket	pointer
)	O
;	O
void	O
*	O
obj_alloc	function
(	O
OBUCKET	struct
*	O
bucket	pointer
)	O
{	O
OBJECT	struct
*	O
optr	pointer
;	O
optr	pointer
=	O
grad_emalloc	function
(	O
bucket	pointer
->	O
size	int
)	O
;	O
optr	pointer
->	O
alloc	pointer
=	O
bucket	pointer
->	O
alloc_list	pointer
;	O
bucket	pointer
->	O
alloc_list	pointer
=	O
optr	pointer
;	O
return	O
optr	pointer
;	O
}	O
void	O
obj_free_all	function
(	O
OBUCKET	struct
*	O
bucket	pointer
)	O
{	O
OBJECT	struct
*	O
obj	pointer
,	O
*	O
next	pointer
;	O
obj	pointer
=	O
bucket	pointer
->	O
alloc_list	pointer
;	O
while	O
(	O
obj	pointer
)	O
{	O
next	pointer
=	O
obj	pointer
->	O
alloc	pointer
;	O
if	O
(	O
bucket	pointer
->	O
free	pointer
)	O
bucket	pointer
->	O
free	pointer
(	O
obj	pointer
)	O
;	O
grad_free	function
(	O
obj	pointer
)	O
;	O
obj	pointer
=	O
next	pointer
;	O
}	O
bucket	pointer
->	O
alloc_list	pointer
=	O
NULL	O
;	O
}	O
void	O
frame_init	function
(	O
)	O
{	O
frame_bkt	struct
.	O
alloc_list	pointer
=	O
NULL	O
;	O
frame_first	pointer
=	O
frame_last	pointer
=	O
NULL	O
;	O
}	O
void	O
frame_push	function
(	O
)	O
{	O
FRAME	struct
*	O
this_frame	pointer
=	O
obj_alloc	function
(	O
&	O
frame_bkt	struct
)	O
;	O
if	O
(	O
!	O
frame_last	pointer
)	O
{	O
this_frame	pointer
->	O
level	int
=	O
0	int
;	O
this_frame	pointer
->	O
stack_offset	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
frame_last	pointer
->	O
level	int
==	O
0	int
)	O
this_frame	pointer
->	O
stack_offset	int
=	O
1	int
;	O
else	O
this_frame	pointer
->	O
stack_offset	int
=	O
frame_last	pointer
->	O
stack_offset	int
;	O
this_frame	pointer
->	O
level	int
=	O
frame_last	pointer
->	O
level	int
+	O
1	int
;	O
}	O
rw_list_append	O
(	O
&	O
frame_first	pointer
,	O
&	O
frame_last	pointer
,	O
this_frame	pointer
)	O
;	O
}	O
void	O
frame_pop	function
(	O
)	O
{	O
rw_list_remove	O
(	O
&	O
frame_first	pointer
,	O
&	O
frame_last	pointer
,	O
frame_last	pointer
)	O
;	O
}	O
void	O
frame_update_alloc	function
(	O
)	O
{	O
FRAME	struct
*	O
this_frame	pointer
=	O
frame_last	pointer
;	O
if	O
(	O
this_frame	pointer
->	O
stack_offset	int
>	O
function	pointer
->	O
stack_alloc	int
)	O
function	pointer
->	O
stack_alloc	int
=	O
this_frame	pointer
->	O
stack_offset	int
;	O
}	O
void	O
frame_free_all	function
(	O
)	O
{	O
obj_free_all	function
(	O
&	O
frame_bkt	struct
)	O
;	O
frame_first	pointer
=	O
frame_last	pointer
=	O
NULL	O
;	O
}	O
void	O
frame_unwind_all	function
(	O
)	O
{	O
while	O
(	O
frame_last	pointer
)	O
rw_list_remove	O
(	O
&	O
frame_first	pointer
,	O
&	O
frame_last	pointer
,	O
frame_last	pointer
)	O
;	O
frame_push	function
(	O
)	O
;	O
}	O
void	O
loop_init	function
(	O
)	O
{	O
loop_bkt	struct
.	O
alloc_list	pointer
=	O
NULL	O
;	O
loop_first	pointer
=	O
loop_last	pointer
=	O
NULL	O
;	O
}	O
void	O
loop_free_all	function
(	O
)	O
{	O
obj_free_all	function
(	O
&	O
loop_bkt	struct
)	O
;	O
loop_first	pointer
=	O
loop_last	pointer
=	O
NULL	O
;	O
}	O
void	O
loop_unwind_all	function
(	O
)	O
{	O
loop_first	pointer
=	O
loop_last	pointer
=	O
NULL	O
;	O
}	O
void	O
loop_push	function
(	O
MTX	union
*	O
mtx	union
)	O
{	O
LOOP	struct
*	O
this_loop	pointer
=	O
obj_alloc	function
(	O
&	O
loop_bkt	struct
)	O
;	O
rw_list_append	O
(	O
&	O
loop_first	pointer
,	O
&	O
loop_last	pointer
,	O
this_loop	pointer
)	O
;	O
}	O
void	O
loop_pop	function
(	O
)	O
{	O
rw_list_remove	O
(	O
&	O
loop_first	pointer
,	O
&	O
loop_last	pointer
,	O
loop_last	pointer
)	O
;	O
}	O
void	O
loop_fixup	function
(	O
JUMP_MTX	struct
*	O
list	pointer
,	O
MTX	union
*	O
target	pointer
)	O
{	O
JUMP_MTX	struct
*	O
jp	pointer
;	O
for	O
(	O
jp	pointer
=	O
list	pointer
;	O
jp	pointer
;	O
jp	pointer
=	O
(	O
JUMP_MTX	struct
*	O
)	O
jp	pointer
->	O
link	function
)	O
jp	pointer
->	O
dest	pointer
=	O
target	pointer
;	O
}	O
OBUCKET	struct
var_bucket	struct
=	O
{	O
sizeof	O
(	O
VAR	struct
)	O
,	O
NULL	O
}	O
;	O
void	O
var_init	function
(	O
)	O
{	O
var_bucket	struct
.	O
alloc_list	pointer
=	O
NULL	O
;	O
var_first	pointer
=	O
var_last	pointer
=	O
NULL	O
;	O
}	O
VAR	struct
*	O
var_alloc	function
(	O
grad_data_type_t	enum
type	int
,	O
char	O
*	O
name	pointer
,	O
int	O
grow	int
)	O
{	O
VAR	struct
*	O
var	pointer
;	O
var	pointer
=	O
(	O
VAR	struct
*	O
)	O
obj_alloc	function
(	O
&	O
var_bucket	struct
)	O
;	O
rw_list_append	O
(	O
&	O
var_first	pointer
,	O
&	O
var_last	pointer
,	O
var	pointer
)	O
;	O
var	pointer
->	O
name	pointer
=	O
name	pointer
;	O
var	pointer
->	O
datatype	enum
=	O
type	int
;	O
var	pointer
->	O
level	int
=	O
curframe	O
->	O
level	int
;	O
var	pointer
->	O
offset	long
=	O
curframe	O
->	O
stack_offset	int
;	O
curframe	O
->	O
stack_offset	int
+=	O
grow	int
;	O
return	O
var	pointer
;	O
}	O
void	O
var_unwind_level	function
(	O
)	O
{	O
int	O
cnt	int
=	O
0	int
;	O
while	O
(	O
var_last	pointer
&&	O
var_last	pointer
->	O
level	int
==	O
curframe	O
->	O
level	int
)	O
{	O
rw_list_remove	O
(	O
&	O
var_first	pointer
,	O
&	O
var_last	pointer
,	O
var_last	pointer
)	O
;	O
cnt	int
++	O
;	O
}	O
if	O
(	O
cnt	int
)	O
frame_update_alloc	function
(	O
)	O
;	O
}	O
void	O
var_unwind_all	function
(	O
)	O
{	O
while	O
(	O
var_last	pointer
)	O
rw_list_remove	O
(	O
&	O
var_first	pointer
,	O
&	O
var_last	pointer
,	O
var_last	pointer
)	O
;	O
}	O
void	O
var_type	function
(	O
grad_data_type_t	enum
type	int
,	O
VAR	struct
*	O
var	pointer
)	O
{	O
for	O
(	O
;	O
var	pointer
;	O
var	pointer
=	O
var	pointer
->	O
dcllink	pointer
)	O
var	pointer
->	O
datatype	enum
=	O
type	int
;	O
}	O
void	O
var_free_all	function
(	O
)	O
{	O
obj_free_all	function
(	O
&	O
var_bucket	struct
)	O
;	O
var_first	pointer
=	O
var_last	pointer
=	O
NULL	O
;	O
}	O
VAR	struct
*	O
var_lookup	function
(	O
char	O
*	O
name	pointer
)	O
{	O
VAR	struct
*	O
var	pointer
;	O
var	pointer
=	O
var_last	pointer
;	O
while	O
(	O
var	pointer
&&	O
strcmp	function
(	O
var	pointer
->	O
name	pointer
,	O
name	pointer
)	O
)	O
var	pointer
=	O
var	pointer
->	O
prev	pointer
;	O
return	O
var	pointer
;	O
}	O
OBUCKET	struct
mtx_bucket	struct
=	O
{	O
sizeof	O
(	O
MTX	union
)	O
,	O
NULL	O
}	O
;	O
void	O
mtx_insert	function
(	O
MTX	union
*	O
prev	pointer
,	O
MTX	union
*	O
mtx	union
)	O
{	O
MTX	union
*	O
up	pointer
;	O
rw_list_insert	O
(	O
&	O
mtx_first	pointer
,	O
&	O
mtx_last	pointer
,	O
prev	pointer
,	O
mtx	union
,	O
0	int
)	O
;	O
if	O
(	O
up	pointer
=	O
prev	pointer
->	O
gen	struct
.	O
uplink	pointer
)	O
{	O
switch	O
(	O
up	pointer
->	O
gen	struct
.	O
type	int
)	O
{	O
case	O
Unary	int
:	O
up	pointer
->	O
un	struct
.	O
arg	pointer
=	O
mtx	union
;	O
break	O
;	O
case	O
Binary	int
:	O
if	O
(	O
up	pointer
->	O
bin	struct
.	O
arg	pointer
[	O
0	int
]	O
==	O
prev	pointer
)	O
up	pointer
->	O
bin	struct
.	O
arg	pointer
[	O
0	int
]	O
=	O
mtx	union
;	O
else	O
up	pointer
->	O
bin	struct
.	O
arg	pointer
[	O
1	int
]	O
=	O
mtx	union
;	O
break	O
;	O
case	O
Return	int
:	O
up	pointer
->	O
ret	struct
.	O
expr	pointer
=	O
mtx	union
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
void	O
mtx_init	function
(	O
)	O
{	O
mtx_bucket	struct
.	O
alloc_list	pointer
=	O
NULL	O
;	O
mtx_first	pointer
=	O
mtx_last	pointer
=	O
NULL	O
;	O
}	O
void	O
mtx_unwind_all	function
(	O
)	O
{	O
while	O
(	O
mtx_last	pointer
)	O
rw_list_remove	O
(	O
&	O
mtx_first	pointer
,	O
&	O
mtx_last	pointer
,	O
mtx_last	pointer
)	O
;	O
}	O
void	O
mtx_free_all	function
(	O
)	O
{	O
obj_free_all	function
(	O
&	O
mtx_bucket	struct
)	O
;	O
mtx_first	pointer
=	O
mtx_last	pointer
=	O
NULL	O
;	O
}	O
MTX	union
*	O
mtx_cur	function
(	O
)	O
{	O
return	O
mtx_last	pointer
;	O
}	O
MTX	union
*	O
mtx_frame	function
(	O
Mtxtype	enum
type	int
,	O
stkoff_t	int
stksize	int
)	O
{	O
FRAME_MTX	struct
*	O
mtx	union
=	O
(	O
FRAME_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
type	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
stacksize	int
=	O
stksize	int
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_nop	function
(	O
)	O
{	O
MTX	union
*	O
mtx	union
=	O
mtx_alloc	function
(	O
Nop	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
return	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_jump	function
(	O
)	O
{	O
MTX	union
*	O
mtx	union
=	O
mtx_alloc	function
(	O
Jump	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
return	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_stop	function
(	O
)	O
{	O
MTX	union
*	O
mtx	union
=	O
mtx_alloc	function
(	O
Stop	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
return	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_pop	function
(	O
)	O
{	O
MTX	union
*	O
mtx	union
=	O
mtx_alloc	function
(	O
Pop	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
return	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_return	function
(	O
MTX	union
*	O
arg	pointer
)	O
{	O
MTX	union
*	O
mtx	union
=	O
mtx_alloc	function
(	O
Return	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
ret	struct
.	O
expr	pointer
=	O
arg	pointer
;	O
arg	pointer
->	O
gen	struct
.	O
uplink	pointer
=	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_alloc	function
(	O
Mtxtype	enum
type	int
)	O
{	O
MTX	union
*	O
mtx	union
=	O
obj_alloc	function
(	O
&	O
mtx_bucket	struct
)	O
;	O
mtx	union
->	O
gen	struct
.	O
type	int
=	O
type	int
;	O
mtx	union
->	O
gen	struct
.	O
loc	struct
=	O
locus	struct
;	O
return	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_const	function
(	O
grad_value_t	struct
*	O
val	array
)	O
{	O
CONST_MTX	struct
*	O
mtx	union
=	O
(	O
CONST_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Constant	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
datatype	enum
=	O
val	array
->	O
type	int
;	O
mtx	union
->	O
datum	union
=	O
val	array
->	O
datum	union
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_ref	function
(	O
int	O
num	int
)	O
{	O
MATCHREF_MTX	struct
*	O
mtx	union
=	O
(	O
MATCHREF_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Matchref	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
datatype	enum
=	O
String	int
;	O
mtx	union
->	O
num	int
=	O
num	int
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_var	function
(	O
VAR	struct
*	O
var	pointer
)	O
{	O
VAR_MTX	struct
*	O
mtx	union
=	O
(	O
VAR_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Variable	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
datatype	enum
=	O
var	pointer
->	O
datatype	enum
;	O
mtx	union
->	O
var	pointer
=	O
var	pointer
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_asgn	function
(	O
VAR	struct
*	O
var	pointer
,	O
MTX	union
*	O
arg	pointer
)	O
{	O
ASGN_MTX	struct
*	O
mtx	union
=	O
(	O
ASGN_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Asgn	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
if	O
(	O
var	pointer
->	O
datatype	enum
!=	O
arg	pointer
->	O
gen	struct
.	O
datatype	enum
)	O
coerce	struct
(	O
arg	pointer
,	O
var	pointer
->	O
datatype	enum
)	O
;	O
mtx	union
->	O
datatype	enum
=	O
var	pointer
->	O
datatype	enum
;	O
mtx	union
->	O
lval	pointer
=	O
var	pointer
;	O
mtx	union
->	O
arg	pointer
=	O
arg	pointer
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
grad_data_type_t	enum
attr_datatype	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
)	O
{	O
switch	O
(	O
attr	pointer
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
return	O
String	int
;	O
case	O
GRAD_TYPE_DATE	int
:	O
return	O
String	int
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
case	O
GRAD_TYPE_IPADDR	int
:	O
return	O
Integer	int
;	O
default	O
:	O
grad_insist_fail	O
(	O
"unknown attribute type"	pointer
)	O
;	O
}	O
}	O
MTX	union
*	O
mtx_attr	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
,	O
MTX	union
*	O
index	function
)	O
{	O
ATTR_MTX	struct
*	O
mtx	union
=	O
(	O
ATTR_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Attr	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
attrno	int
=	O
attr	pointer
->	O
value	pointer
;	O
mtx	union
->	O
datatype	enum
=	O
attr_datatype	function
(	O
attr	pointer
)	O
;	O
mtx	union
->	O
index	function
=	O
index	function
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_attr_check	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
,	O
MTX	union
*	O
index	function
)	O
{	O
ATTR_MTX	struct
*	O
mtx	union
=	O
(	O
ATTR_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Attr_check	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
attrno	int
=	O
attr	pointer
->	O
value	pointer
;	O
mtx	union
->	O
datatype	enum
=	O
Integer	int
;	O
mtx	union
->	O
index	function
=	O
index	function
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
void	O
rw_coercion_warning	function
(	O
grad_data_type_t	enum
from	pointer
,	O
grad_data_type_t	enum
to	pointer
,	O
char	O
*	O
pref	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_WARN	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"%s implicit coercion %s %s"	pointer
)	O
,	O
pref	pointer
?	O
pref	pointer
:	O
""	pointer
,	O
datatype_str_abl	function
(	O
from	pointer
)	O
,	O
datatype_str_acc	function
(	O
to	pointer
)	O
)	O
;	O
}	O
MTX	union
*	O
mtx_attr_asgn	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
,	O
MTX	union
*	O
index	function
,	O
MTX	union
*	O
rval	pointer
)	O
{	O
ATTR_MTX	struct
*	O
mtx	union
=	O
(	O
ATTR_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Attr_asgn	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
attrno	int
=	O
attr	pointer
->	O
value	pointer
;	O
mtx	union
->	O
datatype	enum
=	O
attr_datatype	function
(	O
attr	pointer
)	O
;	O
if	O
(	O
rval	pointer
->	O
gen	struct
.	O
datatype	enum
!=	O
mtx	union
->	O
datatype	enum
)	O
{	O
rw_coercion_warning	function
(	O
rval	pointer
->	O
gen	struct
.	O
datatype	enum
,	O
mtx	union
->	O
datatype	enum
,	O
NULL	O
)	O
;	O
rval	pointer
=	O
coerce	struct
(	O
rval	pointer
,	O
mtx	union
->	O
datatype	enum
)	O
;	O
}	O
mtx	union
->	O
index	function
=	O
index	function
;	O
mtx	union
->	O
rval	pointer
=	O
rval	pointer
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_attr_delete	function
(	O
grad_dict_attr_t	struct
*	O
attr	pointer
,	O
MTX	union
*	O
index	function
)	O
{	O
ATTR_MTX	struct
*	O
mtx	union
=	O
(	O
ATTR_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Attr_delete	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
attrno	int
=	O
attr	pointer
->	O
value	pointer
;	O
mtx	union
->	O
datatype	enum
=	O
attr_datatype	function
(	O
attr	pointer
)	O
;	O
mtx	union
->	O
index	function
=	O
index	function
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_bin	function
(	O
Bopcode	enum
opcode	enum
,	O
MTX	union
*	O
arg1	pointer
,	O
MTX	union
*	O
arg2	pointer
)	O
{	O
BIN_MTX	struct
*	O
mtx	union
=	O
(	O
BIN_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Binary	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
if	O
(	O
arg1	pointer
->	O
gen	struct
.	O
datatype	enum
!=	O
arg2	pointer
->	O
gen	struct
.	O
datatype	enum
)	O
{	O
rw_coercion_warning	function
(	O
String	int
,	O
Integer	int
,	O
NULL	O
)	O
;	O
if	O
(	O
arg1	pointer
->	O
gen	struct
.	O
datatype	enum
==	O
String	int
)	O
arg1	pointer
=	O
coerce	struct
(	O
arg1	pointer
,	O
Integer	int
)	O
;	O
else	O
arg2	pointer
=	O
coerce	struct
(	O
arg2	pointer
,	O
Integer	int
)	O
;	O
}	O
switch	O
(	O
arg1	pointer
->	O
gen	struct
.	O
datatype	enum
)	O
{	O
case	O
String	int
:	O
switch	O
(	O
opcode	enum
)	O
{	O
case	O
Add	int
:	O
mtx	union
->	O
datatype	enum
=	O
String	int
;	O
break	O
;	O
case	O
Eq	int
:	O
case	O
Ne	int
:	O
case	O
Lt	int
:	O
case	O
Le	int
:	O
case	O
Gt	int
:	O
case	O
Ge	int
:	O
mtx	union
->	O
datatype	enum
=	O
Integer	int
;	O
break	O
;	O
default	O
:	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"operation not applicable to strings"	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
break	O
;	O
case	O
Integer	int
:	O
mtx	union
->	O
datatype	enum
=	O
Integer	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"unknown data type"	pointer
)	O
;	O
}	O
mtx	union
->	O
opcode	enum
=	O
opcode	enum
;	O
mtx	union
->	O
arg	pointer
[	O
0	int
]	O
=	O
arg1	pointer
;	O
mtx	union
->	O
arg	pointer
[	O
1	int
]	O
=	O
arg2	pointer
;	O
arg1	pointer
->	O
gen	struct
.	O
uplink	pointer
=	O
arg2	pointer
->	O
gen	struct
.	O
uplink	pointer
=	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_un	function
(	O
Uopcode	enum
opcode	enum
,	O
MTX	union
*	O
arg	pointer
)	O
{	O
UN_MTX	struct
*	O
mtx	union
=	O
(	O
UN_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Unary	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
if	O
(	O
arg	pointer
->	O
gen	struct
.	O
datatype	enum
!=	O
Integer	int
)	O
{	O
rw_coercion_warning	function
(	O
String	int
,	O
Integer	int
,	O
NULL	O
)	O
;	O
coerce	struct
(	O
arg	pointer
,	O
Integer	int
)	O
;	O
}	O
mtx	union
->	O
datatype	enum
=	O
Integer	int
;	O
mtx	union
->	O
opcode	enum
=	O
opcode	enum
;	O
mtx	union
->	O
arg	pointer
=	O
arg	pointer
;	O
arg	pointer
->	O
gen	struct
.	O
uplink	pointer
=	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_match	function
(	O
int	O
negated	int
,	O
MTX	union
*	O
arg	pointer
,	O
COMP_REGEX	struct
*	O
rx	pointer
)	O
{	O
MATCH_MTX	struct
*	O
mtx	union
=	O
(	O
MATCH_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Match	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
if	O
(	O
arg	pointer
->	O
gen	struct
.	O
datatype	enum
!=	O
String	int
)	O
{	O
rw_coercion_warning	function
(	O
Integer	int
,	O
String	int
,	O
NULL	O
)	O
;	O
coerce	struct
(	O
arg	pointer
,	O
String	int
)	O
;	O
}	O
mtx	union
->	O
datatype	enum
=	O
Integer	int
;	O
mtx	union
->	O
negated	int
=	O
negated	int
;	O
mtx	union
->	O
arg	pointer
=	O
arg	pointer
;	O
mtx	union
->	O
rx	pointer
=	O
rx	pointer
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_cond	function
(	O
MTX	union
*	O
cond	int
,	O
MTX	union
*	O
if_true	pointer
,	O
MTX	union
*	O
if_false	pointer
)	O
{	O
COND_MTX	struct
*	O
mtx	union
=	O
(	O
COND_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Cond	int
)	O
;	O
mtx_append	O
(	O
mtx	union
)	O
;	O
mtx	union
->	O
expr	pointer
=	O
cond	int
;	O
mtx	union
->	O
if_true	pointer
=	O
if_true	pointer
;	O
mtx	union
->	O
if_false	pointer
=	O
if_false	pointer
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_coerce	function
(	O
grad_data_type_t	enum
type	int
,	O
MTX	union
*	O
arg	pointer
)	O
{	O
if	O
(	O
type	int
==	O
arg	pointer
->	O
gen	struct
.	O
datatype	enum
)	O
return	O
mtx_cur	function
(	O
)	O
;	O
return	O
coerce	struct
(	O
arg	pointer
,	O
type	int
)	O
;	O
}	O
MTX	union
*	O
coerce	struct
(	O
MTX	union
*	O
arg	pointer
,	O
grad_data_type_t	enum
type	int
)	O
{	O
COERCE_MTX	struct
*	O
mtx	union
=	O
(	O
COERCE_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Coercion	int
)	O
;	O
mtx_insert	function
(	O
arg	pointer
,	O
(	O
MTX	union
*	O
)	O
mtx	union
)	O
;	O
mtx	union
->	O
datatype	enum
=	O
type	int
;	O
mtx	union
->	O
arg	pointer
=	O
arg	pointer
;	O
return	O
(	O
MTX	union
*	O
)	O
mtx	union
;	O
}	O
MTX	union
*	O
mtx_call	function
(	O
FUNCTION	struct
*	O
fun	pointer
,	O
MTX	union
*	O
args	pointer
)	O
{	O
MTX	union
*	O
argp	pointer
;	O
CALL_MTX	struct
*	O
call	struct
;	O
PARAMETER	struct
*	O
parmp	pointer
;	O
int	O
argn	int
;	O
argn	int
=	O
0	int
;	O
argp	pointer
=	O
args	pointer
;	O
parmp	pointer
=	O
fun	pointer
->	O
parm	pointer
;	O
while	O
(	O
argp	pointer
&&	O
parmp	pointer
)	O
{	O
if	O
(	O
argp	pointer
->	O
gen	struct
.	O
datatype	enum
!=	O
parmp	pointer
->	O
datatype	enum
)	O
{	O
char	O
buf	pointer
[	O
24	int
]	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
_	O
(	O
"(argument %d)"	pointer
)	O
,	O
argn	int
)	O
;	O
rw_coercion_warning	function
(	O
argp	pointer
->	O
gen	struct
.	O
datatype	enum
,	O
parmp	pointer
->	O
datatype	enum
,	O
buf	pointer
)	O
;	O
coerce	struct
(	O
argp	pointer
,	O
parmp	pointer
->	O
datatype	enum
)	O
;	O
}	O
argn	int
++	O
;	O
argp	pointer
=	O
argp	pointer
->	O
gen	struct
.	O
arglink	pointer
;	O
parmp	pointer
=	O
parmp	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
argp	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"too many arguments in call to %s"	pointer
)	O
,	O
fun	pointer
->	O
name	pointer
)	O
;	O
errcnt	long
++	O
;	O
}	O
else	O
if	O
(	O
parmp	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"too few arguments in call to %s"	pointer
)	O
,	O
fun	pointer
->	O
name	pointer
)	O
;	O
errcnt	long
++	O
;	O
}	O
call	struct
=	O
(	O
CALL_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Call	int
)	O
;	O
mtx_append	O
(	O
(	O
MTX	union
*	O
)	O
call	struct
)	O
;	O
call	struct
->	O
datatype	enum
=	O
fun	pointer
->	O
rettype	enum
;	O
call	struct
->	O
fun	pointer
=	O
fun	pointer
;	O
call	struct
->	O
args	pointer
=	O
args	pointer
;	O
call	struct
->	O
nargs	int
=	O
argn	int
;	O
return	O
(	O
MTX	union
*	O
)	O
call	struct
;	O
}	O
MTX	union
*	O
mtx_builtin	function
(	O
builtin_t	struct
*	O
bin	struct
,	O
MTX	union
*	O
args	pointer
)	O
{	O
MTX	union
*	O
argp	pointer
;	O
BTIN_MTX	struct
*	O
call	struct
;	O
int	O
argn	int
;	O
char	O
*	O
parmp	pointer
;	O
grad_data_type_t	enum
type	int
;	O
argn	int
=	O
0	int
;	O
argp	pointer
=	O
args	pointer
;	O
parmp	pointer
=	O
bin	struct
->	O
parms	pointer
;	O
while	O
(	O
argp	pointer
&&	O
parmp	pointer
)	O
{	O
switch	O
(	O
parmp	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'i'	O
:	O
type	int
=	O
Integer	int
;	O
break	O
;	O
case	O
's'	O
:	O
type	int
=	O
String	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"malformed builtin"	pointer
)	O
;	O
}	O
if	O
(	O
argp	pointer
->	O
gen	struct
.	O
datatype	enum
!=	O
type	int
)	O
{	O
char	O
buf	pointer
[	O
24	int
]	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
_	O
(	O
"(argument %d)"	pointer
)	O
,	O
argn	int
)	O
;	O
rw_coercion_warning	function
(	O
argp	pointer
->	O
gen	struct
.	O
datatype	enum
,	O
type	int
,	O
buf	pointer
)	O
;	O
coerce	struct
(	O
argp	pointer
,	O
type	int
)	O
;	O
}	O
argn	int
++	O
;	O
argp	pointer
=	O
argp	pointer
->	O
gen	struct
.	O
arglink	pointer
;	O
parmp	pointer
++	O
;	O
}	O
if	O
(	O
argp	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"too many arguments in call to %s"	pointer
)	O
,	O
bin	struct
->	O
name	pointer
)	O
;	O
errcnt	long
++	O
;	O
}	O
else	O
if	O
(	O
*	O
parmp	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"too few arguments in call to %s"	pointer
)	O
,	O
bin	struct
->	O
name	pointer
)	O
;	O
errcnt	long
++	O
;	O
}	O
call	struct
=	O
(	O
BTIN_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Builtin	int
)	O
;	O
mtx_append	O
(	O
(	O
MTX	union
*	O
)	O
call	struct
)	O
;	O
call	struct
->	O
datatype	enum
=	O
bin	struct
->	O
rettype	enum
;	O
call	struct
->	O
fun	pointer
=	O
bin	struct
->	O
handler	pointer
;	O
call	struct
->	O
args	pointer
=	O
args	pointer
;	O
call	struct
->	O
nargs	int
=	O
argn	int
;	O
return	O
(	O
MTX	union
*	O
)	O
call	struct
;	O
}	O
const	O
char	O
*	O
datatype_str_nom	function
(	O
grad_data_type_t	enum
type	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
Undefined	int
:	O
return	O
_	O
(	O
"Undefined"	pointer
)	O
;	O
case	O
Integer	int
:	O
return	O
_	O
(	O
"integer"	pointer
)	O
;	O
case	O
String	int
:	O
return	O
_	O
(	O
"string"	pointer
)	O
;	O
default	O
:	O
return	O
_	O
(	O
"UNKNOWN"	pointer
)	O
;	O
}	O
}	O
const	O
char	O
*	O
datatype_str_abl	function
(	O
grad_data_type_t	enum
type	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
Undefined	int
:	O
return	O
_	O
(	O
"from Undefined"	pointer
)	O
;	O
case	O
Integer	int
:	O
return	O
_	O
(	O
"from integer"	pointer
)	O
;	O
case	O
String	int
:	O
return	O
_	O
(	O
"from string"	pointer
)	O
;	O
default	O
:	O
return	O
_	O
(	O
"from UNKNOWN"	pointer
)	O
;	O
}	O
}	O
const	O
char	O
*	O
datatype_str_acc	function
(	O
grad_data_type_t	enum
type	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
Undefined	int
:	O
return	O
_	O
(	O
"to Undefined"	pointer
)	O
;	O
case	O
Integer	int
:	O
return	O
_	O
(	O
"to integer"	pointer
)	O
;	O
case	O
String	int
:	O
return	O
_	O
(	O
"to string"	pointer
)	O
;	O
default	O
:	O
return	O
_	O
(	O
"to UNKNOWN"	pointer
)	O
;	O
}	O
}	O
FILE	struct
*	O
debug_open_file	function
(	O
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
path	pointer
;	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_log_dir	pointer
,	O
"radius.mtx"	pointer
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
path	pointer
,	O
"a"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't open file `%s'"	pointer
)	O
,	O
path	pointer
)	O
;	O
}	O
grad_free	function
(	O
path	pointer
)	O
;	O
return	O
fp	pointer
;	O
}	O
static	O
void	O
pass1	function
(	O
)	O
;	O
static	O
int	O
pass2_unary	function
(	O
MTX	union
*	O
mtx	union
)	O
;	O
static	O
int	O
pass2_binary	function
(	O
MTX	union
*	O
mtx	union
)	O
;	O
void	O
pass1	function
(	O
)	O
{	O
MTX	union
*	O
mtx	union
;	O
MTX	union
*	O
end	pointer
;	O
mtx	union
=	O
mtx_alloc	function
(	O
Enter	int
)	O
;	O
rw_list_insert	O
(	O
&	O
mtx_first	pointer
,	O
&	O
mtx_last	pointer
,	O
mtx_first	pointer
,	O
mtx	union
,	O
1	int
)	O
;	O
mtx	union
->	O
frame	struct
.	O
stacksize	int
=	O
function	pointer
->	O
stack_alloc	int
;	O
if	O
(	O
mtx_last	pointer
->	O
gen	struct
.	O
type	int
!=	O
Return	int
)	O
{	O
grad_value_t	struct
val	array
;	O
grad_log_loc	function
(	O
GRAD_LOG_WARN	int
,	O
&	O
mtx_last	pointer
->	O
gen	struct
.	O
loc	struct
,	O
_	O
(	O
"missing return statement"	pointer
)	O
)	O
;	O
val	array
.	O
type	int
=	O
function	pointer
->	O
rettype	enum
;	O
switch	O
(	O
function	pointer
->	O
rettype	enum
)	O
{	O
case	O
Integer	int
:	O
val	array
.	O
datum	union
.	O
ival	int
=	O
0	int
;	O
break	O
;	O
case	O
String	int
:	O
val	array
.	O
datum	union
.	O
sval	struct
.	O
data	pointer
=	O
""	pointer
;	O
val	array
.	O
datum	union
.	O
sval	struct
.	O
size	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unknown data type"	pointer
)	O
;	O
}	O
mtx_const	function
(	O
&	O
val	array
)	O
;	O
mtx_frame	function
(	O
Leave	int
,	O
function	pointer
->	O
stack_alloc	int
)	O
;	O
}	O
else	O
{	O
mtx_last	pointer
->	O
gen	struct
.	O
type	int
=	O
Leave	int
;	O
mtx_last	pointer
->	O
frame	struct
.	O
stacksize	int
=	O
function	pointer
->	O
stack_alloc	int
;	O
}	O
end	pointer
=	O
mtx_alloc	function
(	O
Nop	int
)	O
;	O
rw_list_insert	O
(	O
&	O
mtx_first	pointer
,	O
&	O
mtx_last	pointer
,	O
mtx_last	pointer
,	O
end	pointer
,	O
1	int
)	O
;	O
for	O
(	O
mtx	union
=	O
mtx_first	pointer
;	O
mtx	union
;	O
mtx	union
=	O
mtx	union
->	O
gen	struct
.	O
next	pointer
)	O
{	O
if	O
(	O
mtx	union
->	O
gen	struct
.	O
type	int
==	O
Return	int
)	O
{	O
if	O
(	O
mtx	union
->	O
ret	struct
.	O
expr	pointer
->	O
gen	struct
.	O
datatype	enum
!=	O
function	pointer
->	O
rettype	enum
)	O
{	O
rw_coercion_warning	function
(	O
mtx	union
->	O
ret	struct
.	O
expr	pointer
->	O
gen	struct
.	O
datatype	enum
,	O
function	pointer
->	O
rettype	enum
,	O
NULL	O
)	O
;	O
coerce	struct
(	O
mtx	union
->	O
ret	struct
.	O
expr	pointer
,	O
function	pointer
->	O
rettype	enum
)	O
;	O
}	O
mtx	union
->	O
gen	struct
.	O
type	int
=	O
Jump	int
;	O
mtx	union
->	O
jump	struct
.	O
dest	pointer
=	O
end	pointer
;	O
}	O
}	O
}	O
int	O
pass2_unary	function
(	O
MTX	union
*	O
mtx	union
)	O
{	O
MTX	union
*	O
arg	pointer
=	O
mtx	union
->	O
un	struct
.	O
arg	pointer
;	O
switch	O
(	O
mtx	union
->	O
un	struct
.	O
opcode	enum
)	O
{	O
case	O
Not	int
:	O
arg	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
=	O
!	O
arg	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Neg	int
:	O
arg	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
=	O
-	O
arg	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected opcode"	pointer
)	O
;	O
}	O
mtx	union
->	O
gen	struct
.	O
type	int
=	O
Constant	int
;	O
mtx	union
->	O
cnst	struct
.	O
datum	union
=	O
arg	pointer
->	O
cnst	struct
.	O
datum	union
;	O
mtx_remove	O
(	O
arg	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
pass2_binary	function
(	O
MTX	union
*	O
mtx	union
)	O
{	O
MTX	union
*	O
arg0	pointer
=	O
mtx	union
->	O
bin	struct
.	O
arg	pointer
[	O
0	int
]	O
;	O
MTX	union
*	O
arg1	pointer
=	O
mtx	union
->	O
bin	struct
.	O
arg	pointer
[	O
1	int
]	O
;	O
grad_datum_t	union
dat	union
;	O
switch	O
(	O
mtx	union
->	O
bin	struct
.	O
opcode	enum
)	O
{	O
case	O
Eq	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
==	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Ne	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
!=	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Lt	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
<	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Le	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
<=	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Gt	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
>	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Ge	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
>=	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
BAnd	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
&	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
BOr	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
|	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
BXor	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
^	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
And	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
&&	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Or	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
||	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Shl	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
<<	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Shr	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
>>	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Add	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
+	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Sub	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
-	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Mul	int
:	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
*	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Div	int
:	O
if	O
(	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
==	O
0	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
arg1	pointer
->	O
cnst	struct
.	O
loc	struct
,	O
_	O
(	O
"divide by zero"	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
}	O
else	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
/	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
case	O
Rem	int
:	O
if	O
(	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
==	O
0	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
arg1	pointer
->	O
cnst	struct
.	O
loc	struct
,	O
_	O
(	O
"divide by zero"	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
}	O
else	O
dat	union
.	O
ival	int
=	O
arg0	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
%	O
arg1	pointer
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected opcode"	pointer
)	O
;	O
}	O
mtx	union
->	O
gen	struct
.	O
type	int
=	O
Constant	int
;	O
mtx	union
->	O
cnst	struct
.	O
datum	union
=	O
dat	union
;	O
mtx_remove	O
(	O
arg0	pointer
)	O
;	O
mtx_remove	O
(	O
arg1	pointer
)	O
;	O
return	O
0	int
;	O
}	O
MTX	union
*	O
mtx_branch	function
(	O
int	O
cond	int
,	O
MTX	union
*	O
target	pointer
)	O
{	O
MTX	union
*	O
nop	struct
=	O
mtx_alloc	function
(	O
Nop	int
)	O
;	O
MTX	union
*	O
mtx	union
=	O
mtx_alloc	function
(	O
Branch	int
)	O
;	O
mtx_insert	function
(	O
target	pointer
,	O
nop	struct
)	O
;	O
mtx	union
->	O
branch	struct
.	O
cond	int
=	O
cond	int
;	O
mtx	union
->	O
branch	struct
.	O
dest	pointer
=	O
nop	struct
;	O
return	O
mtx	union
;	O
}	O
void	O
mtx_bool	function
(	O
MTX	union
*	O
mtx	union
)	O
{	O
MTX	union
*	O
j_mtx	pointer
,	O
*	O
p	pointer
,	O
*	O
p1	pointer
;	O
p	pointer
=	O
mtx_alloc	function
(	O
Popa	int
)	O
;	O
mtx_insert	function
(	O
mtx	union
->	O
bin	struct
.	O
arg	pointer
[	O
0	int
]	O
,	O
p	pointer
)	O
;	O
p1	pointer
=	O
mtx_alloc	function
(	O
Pusha	int
)	O
;	O
mtx_insert	function
(	O
p	pointer
,	O
p1	pointer
)	O
;	O
p	pointer
=	O
mtx_alloc	function
(	O
Pusha	int
)	O
;	O
mtx_insert	function
(	O
p1	pointer
,	O
p	pointer
)	O
;	O
j_mtx	pointer
=	O
mtx_branch	function
(	O
mtx	union
->	O
bin	struct
.	O
opcode	enum
==	O
Or	int
,	O
mtx	union
)	O
;	O
mtx_insert	function
(	O
p	pointer
,	O
j_mtx	pointer
)	O
;	O
p1	pointer
=	O
mtx_alloc	function
(	O
Popa	int
)	O
;	O
mtx_insert	function
(	O
j_mtx	pointer
,	O
p1	pointer
)	O
;	O
mtx_remove	O
(	O
mtx	union
)	O
;	O
}	O
int	O
pass2	function
(	O
)	O
{	O
MTX	union
*	O
mtx	union
,	O
*	O
next	pointer
;	O
int	O
optcnt	int
;	O
int	O
errcnt	long
=	O
0	int
;	O
do	O
{	O
optcnt	int
=	O
0	int
;	O
mtx	union
=	O
mtx_first	pointer
;	O
while	O
(	O
mtx	union
)	O
{	O
next	pointer
=	O
mtx	union
->	O
gen	struct
.	O
next	pointer
;	O
switch	O
(	O
mtx	union
->	O
gen	struct
.	O
type	int
)	O
{	O
case	O
Unary	int
:	O
if	O
(	O
mtx	union
->	O
un	struct
.	O
arg	pointer
->	O
gen	struct
.	O
type	int
!=	O
Constant	int
)	O
break	O
;	O
if	O
(	O
pass2_unary	function
(	O
mtx	union
)	O
)	O
errcnt	long
++	O
;	O
else	O
optcnt	int
++	O
;	O
break	O
;	O
case	O
Binary	int
:	O
if	O
(	O
mtx	union
->	O
bin	struct
.	O
arg	pointer
[	O
0	int
]	O
->	O
gen	struct
.	O
type	int
==	O
Constant	int
&&	O
mtx	union
->	O
bin	struct
.	O
arg	pointer
[	O
1	int
]	O
->	O
gen	struct
.	O
type	int
==	O
Constant	int
)	O
{	O
switch	O
(	O
mtx	union
->	O
bin	struct
.	O
datatype	enum
)	O
{	O
case	O
Integer	int
:	O
if	O
(	O
pass2_binary	function
(	O
mtx	union
)	O
)	O
errcnt	long
++	O
;	O
else	O
optcnt	int
++	O
;	O
break	O
;	O
case	O
String	int
:	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unknown data type"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mtx	union
->	O
bin	struct
.	O
opcode	enum
==	O
And	int
||	O
mtx	union
->	O
bin	struct
.	O
opcode	enum
==	O
Or	int
)	O
{	O
mtx_bool	function
(	O
mtx	union
)	O
;	O
}	O
break	O
;	O
case	O
Jump	int
:	O
if	O
(	O
mtx	union
->	O
jump	struct
.	O
dest	pointer
==	O
mtx	union
->	O
jump	struct
.	O
next	pointer
)	O
mtx_remove	O
(	O
mtx	union
)	O
;	O
break	O
;	O
case	O
Attr	int
:	O
case	O
Attr_asgn	int
:	O
case	O
Attr_check	int
:	O
case	O
Attr_delete	int
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
mtx	union
=	O
next	pointer
;	O
}	O
}	O
while	O
(	O
errcnt	long
==	O
0	int
&&	O
optcnt	int
>	O
0	int
)	O
;	O
return	O
errcnt	long
;	O
}	O
int	O
optimize	function
(	O
)	O
{	O
DEBUG_FUN	O
(	O
)	O
;	O
DEBUG_MTX	O
(	O
"on entry to optimize"	pointer
)	O
;	O
pass1	function
(	O
)	O
;	O
DEBUG_MTX	O
(	O
"after first pass"	pointer
)	O
;	O
if	O
(	O
pass2	function
(	O
)	O
)	O
return	O
-	O
1	int
;	O
DEBUG_MTX	O
(	O
"after second pass (immediate computations)"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
INSTR	pointer
*	O
rw_code	pointer
;	O
static	O
pctr_t	int
rw_pc	int
;	O
static	O
size_t	long
rw_codesize	long
;	O
void	O
code_check	function
(	O
)	O
{	O
if	O
(	O
rw_code	pointer
==	O
NULL	O
)	O
{	O
rw_codesize	long
=	O
4096	int
;	O
rw_code	pointer
=	O
grad_emalloc	function
(	O
rw_codesize	long
*	O
sizeof	O
(	O
rw_code	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
}	O
void	O
code_init	function
(	O
)	O
{	O
code_check	function
(	O
)	O
;	O
rw_code	pointer
[	O
0	int
]	O
=	O
0	int
;	O
rw_pc	int
=	O
1	int
;	O
}	O
static	O
int	O
pushn	function
(	O
RWSTYPE	long
n	long
)	O
;	O
static	O
int	O
cpopn	function
(	O
RWSTYPE	long
*	O
np	pointer
)	O
;	O
static	O
RWSTYPE	long
popn	function
(	O
)	O
;	O
static	O
void	O
checkpop	function
(	O
int	O
cnt	int
)	O
;	O
static	O
void	O
pushref	function
(	O
char	O
*	O
str	pointer
,	O
int	O
from	pointer
,	O
int	O
to	pointer
)	O
;	O
static	O
RWSTYPE	long
*	O
heap_reserve	function
(	O
int	O
size	int
)	O
;	O
static	O
void	O
pushs	function
(	O
RWSTYPE	long
*	O
sptr	pointer
,	O
size_t	long
size	int
,	O
int	O
len	int
)	O
;	O
static	O
void	O
pushstr	function
(	O
const	O
char	O
*	O
str	pointer
,	O
int	O
len	int
)	O
;	O
static	O
void	O
rw_pushn	function
(	O
)	O
;	O
static	O
void	O
rw_pushs	function
(	O
)	O
;	O
static	O
void	O
rw_pushref	function
(	O
)	O
;	O
static	O
void	O
rw_pushv	function
(	O
)	O
;	O
static	O
void	O
rw_i2s	function
(	O
)	O
;	O
static	O
void	O
rw_s2i	function
(	O
)	O
;	O
static	O
void	O
rw_eq	function
(	O
)	O
;	O
static	O
void	O
rw_ne	function
(	O
)	O
;	O
static	O
void	O
rw_lt	function
(	O
)	O
;	O
static	O
void	O
rw_le	function
(	O
)	O
;	O
static	O
void	O
rw_gt	function
(	O
)	O
;	O
static	O
void	O
rw_ge	function
(	O
)	O
;	O
static	O
void	O
rw_eqs	function
(	O
)	O
;	O
static	O
void	O
rw_nes	function
(	O
)	O
;	O
static	O
void	O
rw_lts	function
(	O
)	O
;	O
static	O
void	O
rw_les	function
(	O
)	O
;	O
static	O
void	O
rw_gts	function
(	O
)	O
;	O
static	O
void	O
rw_ges	function
(	O
)	O
;	O
static	O
void	O
rw_b_xor	function
(	O
)	O
;	O
static	O
void	O
rw_b_and	function
(	O
)	O
;	O
static	O
void	O
rw_b_or	function
(	O
)	O
;	O
static	O
void	O
rw_shl	function
(	O
)	O
;	O
static	O
void	O
rw_shr	function
(	O
)	O
;	O
static	O
void	O
rw_add	function
(	O
)	O
;	O
static	O
void	O
rw_sub	function
(	O
)	O
;	O
static	O
void	O
rw_mul	function
(	O
)	O
;	O
static	O
void	O
rw_div	function
(	O
)	O
;	O
static	O
void	O
rw_rem	function
(	O
)	O
;	O
static	O
void	O
rw_not	function
(	O
)	O
;	O
static	O
void	O
rw_neg	function
(	O
)	O
;	O
static	O
void	O
rw_asgn	function
(	O
)	O
;	O
static	O
void	O
rw_enter	function
(	O
)	O
;	O
static	O
void	O
rw_leave	function
(	O
)	O
;	O
static	O
void	O
rw_match	function
(	O
)	O
;	O
static	O
void	O
rw_jmp	function
(	O
)	O
;	O
static	O
void	O
rw_jne	function
(	O
)	O
;	O
static	O
void	O
rw_je	function
(	O
)	O
;	O
static	O
void	O
rw_adds	function
(	O
)	O
;	O
static	O
void	O
rw_adjstk	function
(	O
)	O
;	O
static	O
void	O
rw_popn	function
(	O
)	O
;	O
static	O
void	O
rw_pusha	function
(	O
)	O
;	O
static	O
void	O
rw_popa	function
(	O
)	O
;	O
static	O
void	O
rw_call	function
(	O
)	O
;	O
static	O
void	O
rw_builtin	function
(	O
)	O
;	O
static	O
void	O
rw_attrs	function
(	O
)	O
;	O
static	O
void	O
rw_attrs0	function
(	O
)	O
;	O
static	O
void	O
rw_attrn	function
(	O
)	O
;	O
static	O
void	O
rw_attrn0	function
(	O
)	O
;	O
static	O
void	O
rw_attrcheck	function
(	O
)	O
;	O
static	O
void	O
rw_attrcheck0	function
(	O
)	O
;	O
static	O
void	O
rw_attrasgn	function
(	O
)	O
;	O
static	O
void	O
rw_attrasgn0	function
(	O
)	O
;	O
static	O
void	O
rw_attr_delete	function
(	O
)	O
;	O
static	O
void	O
rw_attr_delete0	function
(	O
)	O
;	O
INSTR	pointer
bin_codetab	array
[	O
]	O
=	O
{	O
rw_eq	function
,	O
rw_ne	function
,	O
rw_lt	function
,	O
rw_le	function
,	O
rw_gt	function
,	O
rw_ge	function
,	O
rw_b_and	function
,	O
rw_b_xor	function
,	O
rw_b_or	function
,	O
NULL	O
,	O
NULL	O
,	O
rw_shl	function
,	O
rw_shr	function
,	O
rw_add	function
,	O
rw_sub	function
,	O
rw_mul	function
,	O
rw_div	function
,	O
rw_rem	function
,	O
}	O
;	O
INSTR	pointer
bin_string_codetab	array
[	O
]	O
=	O
{	O
rw_eqs	function
,	O
rw_nes	function
,	O
rw_lts	function
,	O
rw_les	function
,	O
rw_gts	function
,	O
rw_ges	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
rw_adds	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
INSTR	pointer
coerce_tab	array
[	O
Max_datatype	O
]	O
[	O
Max_datatype	O
]	O
=	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
rw_i2s	function
}	O
,	O
{	O
NULL	O
,	O
rw_s2i	function
,	O
NULL	O
}	O
,	O
}	O
;	O
static	O
void	O
check_codesize	function
(	O
int	O
delta	int
)	O
;	O
static	O
int	O
code	char
(	O
INSTR	pointer
instr	pointer
)	O
;	O
static	O
int	O
data	pointer
(	O
int	O
val	array
)	O
;	O
static	O
int	O
data_str	function
(	O
char	O
*	O
ptr	pointer
)	O
;	O
static	O
void	O
add_target	function
(	O
NOP_MTX	struct
*	O
mtx	union
,	O
pctr_t	int
pc	int
)	O
;	O
void	O
add_target	function
(	O
NOP_MTX	struct
*	O
mtx	union
,	O
pctr_t	int
pc	int
)	O
{	O
TGT_MTX	struct
*	O
tgt	pointer
=	O
(	O
TGT_MTX	struct
*	O
)	O
mtx_alloc	function
(	O
Target	int
)	O
;	O
tgt	pointer
->	O
next	pointer
=	O
(	O
MTX	union
*	O
)	O
mtx	union
->	O
tgt	pointer
;	O
mtx	union
->	O
tgt	pointer
=	O
tgt	pointer
;	O
tgt	pointer
->	O
pc	int
=	O
pc	int
;	O
}	O
void	O
fixup_target	function
(	O
NOP_MTX	struct
*	O
mtx	union
,	O
pctr_t	int
pc	int
)	O
{	O
TGT_MTX	struct
*	O
tgt	pointer
;	O
for	O
(	O
tgt	pointer
=	O
(	O
TGT_MTX	struct
*	O
)	O
mtx	union
->	O
tgt	pointer
;	O
tgt	pointer
;	O
tgt	pointer
=	O
(	O
TGT_MTX	struct
*	O
)	O
tgt	pointer
->	O
next	pointer
)	O
rw_code	pointer
[	O
tgt	pointer
->	O
pc	int
]	O
=	O
(	O
INSTR	pointer
)	O
pc	int
;	O
mtx	union
->	O
tgt	pointer
=	O
NULL	O
;	O
}	O
pctr_t	int
codegen	function
(	O
)	O
{	O
MTX	union
*	O
mtx	union
;	O
function	pointer
->	O
entry	int
=	O
rw_pc	int
;	O
for	O
(	O
mtx	union
=	O
mtx_first	pointer
;	O
mtx	union
;	O
mtx	union
=	O
mtx	union
->	O
gen	struct
.	O
next	pointer
)	O
{	O
switch	O
(	O
mtx	union
->	O
gen	struct
.	O
type	int
)	O
{	O
case	O
Generic	int
:	O
case	O
Return	int
:	O
default	O
:	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
,	O
"INTERNAL ERROR: codegen stumbled accross generic matrix!"	pointer
)	O
;	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
case	O
Nop	int
:	O
fixup_target	function
(	O
&	O
mtx	union
->	O
nop	struct
,	O
rw_pc	int
)	O
;	O
mtx	union
->	O
nop	struct
.	O
pc	int
=	O
rw_pc	int
;	O
break	O
;	O
case	O
Stop	int
:	O
break	O
;	O
case	O
Enter	int
:	O
code	char
(	O
rw_enter	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
frame	struct
.	O
stacksize	int
)	O
;	O
break	O
;	O
case	O
Leave	int
:	O
code	char
(	O
rw_leave	function
)	O
;	O
break	O
;	O
case	O
Constant	int
:	O
switch	O
(	O
mtx	union
->	O
cnst	struct
.	O
datatype	enum
)	O
{	O
case	O
Integer	int
:	O
code	char
(	O
rw_pushn	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
cnst	struct
.	O
datum	union
.	O
ival	int
)	O
;	O
break	O
;	O
case	O
String	int
:	O
code	char
(	O
rw_pushs	function
)	O
;	O
data_str	function
(	O
mtx	union
->	O
cnst	struct
.	O
datum	union
.	O
sval	struct
.	O
data	pointer
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unknown data type"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
Matchref	int
:	O
code	char
(	O
rw_pushref	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
ref	struct
.	O
num	int
)	O
;	O
break	O
;	O
case	O
Variable	int
:	O
code	char
(	O
rw_pushv	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
var	pointer
.	O
var	pointer
->	O
offset	long
)	O
;	O
break	O
;	O
case	O
Unary	int
:	O
switch	O
(	O
mtx	union
->	O
un	struct
.	O
opcode	enum
)	O
{	O
case	O
Not	int
:	O
code	char
(	O
rw_not	function
)	O
;	O
break	O
;	O
case	O
Neg	int
:	O
code	char
(	O
rw_neg	function
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unexpected opcode"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
Binary	int
:	O
if	O
(	O
mtx	union
->	O
bin	struct
.	O
arg	pointer
[	O
0	int
]	O
->	O
gen	struct
.	O
datatype	enum
==	O
String	int
)	O
code	char
(	O
bin_string_codetab	array
[	O
mtx	union
->	O
bin	struct
.	O
opcode	enum
]	O
)	O
;	O
else	O
code	char
(	O
bin_codetab	array
[	O
mtx	union
->	O
bin	struct
.	O
opcode	enum
]	O
)	O
;	O
break	O
;	O
case	O
Cond	int
:	O
code	char
(	O
rw_jne	function
)	O
;	O
add_target	function
(	O
&	O
mtx	union
->	O
cond	int
.	O
if_true	pointer
->	O
nop	struct
,	O
rw_pc	int
)	O
;	O
code	char
(	O
NULL	O
)	O
;	O
if	O
(	O
mtx	union
->	O
cond	int
.	O
if_false	pointer
)	O
{	O
code	char
(	O
rw_jmp	function
)	O
;	O
add_target	function
(	O
&	O
mtx	union
->	O
cond	int
.	O
if_false	pointer
->	O
nop	struct
,	O
rw_pc	int
)	O
;	O
code	char
(	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
Asgn	int
:	O
code	char
(	O
rw_asgn	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
asgn	struct
.	O
lval	pointer
->	O
offset	long
)	O
;	O
break	O
;	O
case	O
Match	int
:	O
code	char
(	O
rw_match	function
)	O
;	O
code	char
(	O
(	O
INSTR	pointer
)	O
mtx	union
->	O
match	struct
.	O
rx	pointer
)	O
;	O
if	O
(	O
mtx	union
->	O
match	struct
.	O
negated	int
)	O
code	char
(	O
rw_not	function
)	O
;	O
break	O
;	O
case	O
Coercion	int
:	O
code	char
(	O
coerce_tab	array
[	O
mtx	union
->	O
coerce	struct
.	O
arg	pointer
->	O
gen	struct
.	O
datatype	enum
]	O
[	O
mtx	union
->	O
coerce	struct
.	O
datatype	enum
]	O
)	O
;	O
break	O
;	O
case	O
Jump	int
:	O
code	char
(	O
rw_jmp	function
)	O
;	O
add_target	function
(	O
&	O
mtx	union
->	O
jump	struct
.	O
dest	pointer
->	O
nop	struct
,	O
rw_pc	int
)	O
;	O
code	char
(	O
NULL	O
)	O
;	O
break	O
;	O
case	O
Branch	int
:	O
code	char
(	O
mtx	union
->	O
branch	struct
.	O
cond	int
?	O
rw_jne	function
:	O
rw_je	function
)	O
;	O
add_target	function
(	O
&	O
mtx	union
->	O
branch	struct
.	O
dest	pointer
->	O
nop	struct
,	O
rw_pc	int
)	O
;	O
code	char
(	O
NULL	O
)	O
;	O
break	O
;	O
case	O
Call	int
:	O
code	char
(	O
rw_call	function
)	O
;	O
code	char
(	O
(	O
INSTR	pointer
)	O
mtx	union
->	O
call	struct
.	O
fun	pointer
->	O
entry	int
)	O
;	O
code	char
(	O
rw_adjstk	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
call	struct
.	O
nargs	int
)	O
;	O
break	O
;	O
case	O
Builtin	int
:	O
code	char
(	O
rw_builtin	function
)	O
;	O
code	char
(	O
mtx	union
->	O
btin	struct
.	O
fun	pointer
)	O
;	O
code	char
(	O
rw_adjstk	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
btin	struct
.	O
nargs	int
)	O
;	O
break	O
;	O
case	O
Pop	int
:	O
code	char
(	O
rw_popn	function
)	O
;	O
break	O
;	O
case	O
Popa	int
:	O
code	char
(	O
rw_popa	function
)	O
;	O
break	O
;	O
case	O
Pusha	int
:	O
code	char
(	O
rw_pusha	function
)	O
;	O
break	O
;	O
case	O
Attr	int
:	O
switch	O
(	O
mtx	union
->	O
attr	pointer
.	O
datatype	enum
)	O
{	O
case	O
Integer	int
:	O
if	O
(	O
mtx	union
->	O
attr	pointer
.	O
index	function
)	O
code	char
(	O
rw_attrn	function
)	O
;	O
else	O
code	char
(	O
rw_attrn0	function
)	O
;	O
break	O
;	O
case	O
String	int
:	O
if	O
(	O
mtx	union
->	O
attr	pointer
.	O
index	function
)	O
code	char
(	O
rw_attrs	function
)	O
;	O
else	O
code	char
(	O
rw_attrs0	function
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"Unknown data type"	pointer
)	O
;	O
}	O
data	pointer
(	O
mtx	union
->	O
attr	pointer
.	O
attrno	int
)	O
;	O
break	O
;	O
case	O
Attr_check	int
:	O
if	O
(	O
mtx	union
->	O
attr	pointer
.	O
index	function
)	O
code	char
(	O
rw_attrcheck	function
)	O
;	O
else	O
code	char
(	O
rw_attrcheck0	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
attr	pointer
.	O
attrno	int
)	O
;	O
break	O
;	O
case	O
Attr_asgn	int
:	O
if	O
(	O
mtx	union
->	O
attr	pointer
.	O
index	function
)	O
code	char
(	O
rw_attrasgn	function
)	O
;	O
else	O
code	char
(	O
rw_attrasgn0	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
attr	pointer
.	O
attrno	int
)	O
;	O
break	O
;	O
case	O
Attr_delete	int
:	O
if	O
(	O
mtx	union
->	O
attr	pointer
.	O
index	function
)	O
code	char
(	O
rw_attr_delete	function
)	O
;	O
else	O
code	char
(	O
rw_attr_delete0	function
)	O
;	O
data	pointer
(	O
mtx	union
->	O
attr	pointer
.	O
attrno	int
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
mtx	union
=	O
mtx_first	pointer
;	O
mtx	union
;	O
mtx	union
=	O
mtx	union
->	O
gen	struct
.	O
next	pointer
)	O
{	O
if	O
(	O
mtx	union
->	O
gen	struct
.	O
type	int
==	O
Nop	int
)	O
fixup_target	function
(	O
&	O
mtx	union
->	O
nop	struct
,	O
mtx	union
->	O
nop	struct
.	O
pc	int
)	O
;	O
}	O
return	O
function	pointer
->	O
entry	int
;	O
}	O
void	O
check_codesize	function
(	O
int	O
delta	int
)	O
{	O
if	O
(	O
rw_pc	int
+	O
delta	int
>=	O
rw_codesize	long
)	O
{	O
INSTR	pointer
*	O
p	pointer
=	O
grad_emalloc	function
(	O
(	O
rw_codesize	long
+	O
4096	int
)	O
*	O
sizeof	O
(	O
rw_code	pointer
[	O
0	int
]	O
)	O
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
rw_code	pointer
,	O
rw_codesize	long
*	O
sizeof	O
(	O
rw_code	pointer
[	O
0	int
]	O
)	O
)	O
;	O
grad_free	function
(	O
rw_code	pointer
)	O
;	O
rw_code	pointer
=	O
p	pointer
;	O
rw_codesize	long
+=	O
4096	int
;	O
}	O
}	O
int	O
code	char
(	O
INSTR	pointer
instr	pointer
)	O
{	O
check_codesize	function
(	O
1	int
)	O
;	O
rw_code	pointer
[	O
rw_pc	int
]	O
=	O
instr	pointer
;	O
return	O
rw_pc	int
++	O
;	O
}	O
int	O
data	pointer
(	O
int	O
val	array
)	O
{	O
return	O
code	char
(	O
(	O
INSTR	pointer
)	O
(	O
RWSTYPE	long
)	O
val	array
)	O
;	O
}	O
int	O
data_str	function
(	O
char	O
*	O
ptr	pointer
)	O
{	O
int	O
len	int
=	O
strlen	function
(	O
ptr	pointer
)	O
+	O
1	int
;	O
RWSTYPE	long
delta	int
=	O
(	O
len	int
+	O
sizeof	O
(	O
rw_code	pointer
[	O
0	int
]	O
)	O
)	O
/	O
sizeof	O
(	O
rw_code	pointer
[	O
0	int
]	O
)	O
;	O
check_codesize	function
(	O
delta	int
+	O
1	int
)	O
;	O
rw_code	pointer
[	O
rw_pc	int
++	O
]	O
=	O
(	O
INSTR	pointer
)	O
delta	int
;	O
memcpy	function
(	O
rw_code	pointer
+	O
rw_pc	int
,	O
ptr	pointer
,	O
len	int
)	O
;	O
rw_pc	int
+=	O
delta	int
;	O
return	O
rw_pc	int
;	O
}	O
COMP_REGEX	struct
*	O
rx_alloc	function
(	O
regex_t	struct
*	O
regex	struct
,	O
int	O
nmatch	int
)	O
{	O
COMP_REGEX	struct
*	O
rx	pointer
;	O
rx	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
rx	pointer
)	O
)	O
;	O
rx	pointer
->	O
regex	struct
=	O
*	O
regex	struct
;	O
rx	pointer
->	O
nmatch	int
=	O
nmatch	int
;	O
rw_list_insert	O
(	O
&	O
function	pointer
->	O
rx_list	pointer
,	O
NULL	O
,	O
function	pointer
->	O
rx_list	pointer
,	O
rx	pointer
,	O
1	int
)	O
;	O
return	O
rx	pointer
;	O
}	O
void	O
rx_free	function
(	O
COMP_REGEX	struct
*	O
rx	pointer
)	O
{	O
COMP_REGEX	struct
*	O
next	pointer
;	O
while	O
(	O
rx	pointer
)	O
{	O
next	pointer
=	O
rx	pointer
->	O
next	pointer
;	O
regfree	O
(	O
&	O
rx	pointer
->	O
regex	struct
)	O
;	O
grad_free	function
(	O
rx	pointer
)	O
;	O
rx	pointer
=	O
next	pointer
;	O
}	O
}	O
COMP_REGEX	struct
*	O
compile_regexp	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
regex_t	struct
regex	struct
;	O
int	O
nmatch	int
;	O
int	O
rc	int
=	O
regcomp	O
(	O
&	O
regex	struct
,	O
str	pointer
,	O
regcomp_flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
char	O
errbuf	array
[	O
512	int
]	O
;	O
regerror	O
(	O
rc	int
,	O
&	O
regex	struct
,	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
)	O
;	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
locus	struct
,	O
_	O
(	O
"regexp error: %s"	pointer
)	O
,	O
errbuf	array
)	O
;	O
return	O
NULL	O
;	O
}	O
nmatch	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
str	pointer
;	O
*	O
p	pointer
;	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
)	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'('	O
)	O
{	O
nmatch	int
++	O
;	O
p	pointer
+=	O
2	int
;	O
continue	O
;	O
}	O
p	pointer
++	O
;	O
}	O
return	O
rx_alloc	function
(	O
&	O
regex	struct
,	O
nmatch	int
)	O
;	O
}	O
void	O
function_delete	function
(	O
)	O
{	O
if	O
(	O
function	pointer
)	O
{	O
grad_symtab_delete	function
(	O
rewrite_tab	pointer
,	O
(	O
grad_symbol_t	struct
*	O
)	O
function	pointer
)	O
;	O
function_cleanup	function
(	O
)	O
;	O
}	O
}	O
void	O
function_cleanup	function
(	O
)	O
{	O
function	pointer
=	O
NULL	O
;	O
}	O
int	O
pushn	function
(	O
RWSTYPE	long
n	long
)	O
{	O
if	O
(	O
mach	struct
.	O
st	int
>=	O
mach	struct
.	O
ht	int
)	O
{	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"st=%d, ht=%d"	pointer
,	O
mach	struct
.	O
st	int
,	O
mach	struct
.	O
ht	int
)	O
;	O
rw_error	function
(	O
_	O
(	O
"out of pushdown space"	pointer
)	O
)	O
;	O
}	O
mach	struct
.	O
stack	pointer
[	O
mach	struct
.	O
st	int
++	O
]	O
=	O
n	long
;	O
return	O
0	int
;	O
}	O
void	O
pushs	function
(	O
RWSTYPE	long
*	O
sptr	pointer
,	O
size_t	long
size	int
,	O
int	O
len	int
)	O
{	O
if	O
(	O
mach	struct
.	O
ht	int
-	O
len	int
-	O
1	int
<=	O
mach	struct
.	O
st	int
)	O
{	O
rw_error	function
(	O
_	O
(	O
"heap overrun"	pointer
)	O
)	O
;	O
}	O
while	O
(	O
len	int
)	O
mach	struct
.	O
stack	pointer
[	O
mach	struct
.	O
ht	int
--	O
]	O
=	O
sptr	pointer
[	O
--	O
len	int
]	O
;	O
mach	struct
.	O
stack	pointer
[	O
mach	struct
.	O
ht	int
--	O
]	O
=	O
size	int
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
(	O
mach	struct
.	O
stack	pointer
+	O
mach	struct
.	O
ht	int
+	O
1	int
)	O
)	O
;	O
}	O
void	O
pushstr	function
(	O
const	O
char	O
*	O
str	pointer
,	O
int	O
len	int
)	O
{	O
RWSTYPE	long
*	O
p	pointer
=	O
heap_reserve	function
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
len	int
+	O
1	int
)	O
;	O
char	O
*	O
s	pointer
=	O
(	O
char	O
*	O
)	O
(	O
p	pointer
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	pointer
,	O
str	pointer
,	O
len	int
)	O
;	O
s	pointer
[	O
len	int
]	O
=	O
0	int
;	O
p	pointer
[	O
0	int
]	O
=	O
len	int
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
p	pointer
)	O
;	O
}	O
RWSTYPE	long
*	O
heap_reserve	function
(	O
int	O
size	int
)	O
{	O
size_t	long
words	long
=	O
B2RW	O
(	O
size	int
)	O
;	O
if	O
(	O
mach	struct
.	O
ht	int
-	O
words	long
<=	O
mach	struct
.	O
st	int
)	O
{	O
gc	function
(	O
)	O
;	O
if	O
(	O
mach	struct
.	O
ht	int
-	O
words	long
<=	O
mach	struct
.	O
st	int
)	O
rw_error	function
(	O
_	O
(	O
"heap overrun"	pointer
)	O
)	O
;	O
}	O
mach	struct
.	O
ht	int
-=	O
words	long
;	O
return	O
mach	struct
.	O
stack	pointer
+	O
mach	struct
.	O
ht	int
--	O
;	O
}	O
char	O
*	O
temp_space_create	function
(	O
)	O
{	O
return	O
(	O
char	O
*	O
)	O
(	O
mach	struct
.	O
stack	pointer
+	O
mach	struct
.	O
st	int
)	O
;	O
}	O
size_t	long
temp_space_size	function
(	O
)	O
{	O
return	O
(	O
mach	struct
.	O
ht	int
-	O
mach	struct
.	O
st	int
)	O
*	O
sizeof	O
(	O
mach	struct
.	O
stack	pointer
[	O
0	int
]	O
)	O
;	O
}	O
void	O
temp_space_copy	function
(	O
char	O
*	O
*	O
baseptr	pointer
,	O
char	O
*	O
text	pointer
,	O
size_t	long
size	int
)	O
{	O
size_t	long
len	int
=	O
(	O
size	int
+	O
sizeof	O
(	O
mach	struct
.	O
stack	pointer
[	O
0	int
]	O
)	O
)	O
/	O
sizeof	O
(	O
mach	struct
.	O
stack	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
*	O
baseptr	pointer
+	O
len	int
>=	O
(	O
char	O
*	O
)	O
(	O
mach	struct
.	O
stack	pointer
+	O
mach	struct
.	O
ht	int
)	O
)	O
rw_error	function
(	O
_	O
(	O
"out of heap space"	pointer
)	O
)	O
;	O
memcpy	function
(	O
*	O
baseptr	pointer
,	O
text	pointer
,	O
size	int
)	O
;	O
*	O
baseptr	pointer
+=	O
size	int
;	O
}	O
RWSTYPE	long
*	O
temp_space_fix	function
(	O
char	O
*	O
end	pointer
)	O
{	O
size_t	long
len	int
,	O
size	int
;	O
char	O
*	O
base	int
=	O
(	O
char	O
*	O
)	O
(	O
mach	struct
.	O
stack	pointer
+	O
mach	struct
.	O
st	int
)	O
;	O
temp_space_copy	function
(	O
&	O
end	pointer
,	O
""	pointer
,	O
0	int
)	O
;	O
size	int
=	O
end	pointer
-	O
base	int
;	O
len	int
=	O
B2RW	O
(	O
size	int
)	O
;	O
mach	struct
.	O
ht	int
-=	O
len	int
;	O
memmove	function
(	O
mach	struct
.	O
stack	pointer
+	O
mach	struct
.	O
ht	int
,	O
base	int
,	O
size	int
)	O
;	O
mach	struct
.	O
stack	pointer
[	O
--	O
mach	struct
.	O
ht	int
]	O
=	O
strlen	function
(	O
base	int
)	O
;	O
return	O
mach	struct
.	O
stack	pointer
+	O
mach	struct
.	O
ht	int
--	O
;	O
}	O
int	O
cpopn	function
(	O
RWSTYPE	long
*	O
np	pointer
)	O
{	O
if	O
(	O
mach	struct
.	O
st	int
<=	O
0	int
)	O
{	O
rw_error	function
(	O
_	O
(	O
"out of popup"	pointer
)	O
)	O
;	O
}	O
*	O
np	pointer
=	O
mach	struct
.	O
stack	pointer
[	O
--	O
mach	struct
.	O
st	int
]	O
;	O
return	O
0	int
;	O
}	O
RWSTYPE	long
popn	function
(	O
)	O
{	O
return	O
mach	struct
.	O
stack	pointer
[	O
--	O
mach	struct
.	O
st	int
]	O
;	O
}	O
void	O
mem2string	function
(	O
grad_string_t	struct
*	O
p	pointer
,	O
RWSTYPE	long
*	O
loc	struct
)	O
{	O
p	pointer
->	O
size	int
=	O
loc	struct
[	O
0	int
]	O
;	O
p	pointer
->	O
data	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
loc	struct
+	O
1	int
)	O
;	O
}	O
void	O
poparr	function
(	O
grad_string_t	struct
*	O
p	pointer
)	O
{	O
mem2string	function
(	O
p	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
popn	function
(	O
)	O
)	O
;	O
}	O
RWSTYPE	long
tos	function
(	O
)	O
{	O
return	O
mach	struct
.	O
stack	pointer
[	O
mach	struct
.	O
st	int
-	O
1	int
]	O
;	O
}	O
void	O
checkpop	function
(	O
int	O
cnt	int
)	O
{	O
if	O
(	O
mach	struct
.	O
st	int
<	O
cnt	int
)	O
rw_error	function
(	O
_	O
(	O
"out of popup"	pointer
)	O
)	O
;	O
}	O
void	O
pushref	function
(	O
char	O
*	O
str	pointer
,	O
int	O
from	pointer
,	O
int	O
to	pointer
)	O
{	O
pushstr	function
(	O
str	pointer
+	O
from	pointer
,	O
to	pointer
-	O
from	pointer
)	O
;	O
}	O
void	O
enter	function
(	O
int	O
n	long
)	O
{	O
pushn	function
(	O
mach	struct
.	O
sb	int
)	O
;	O
mach	struct
.	O
sb	int
=	O
mach	struct
.	O
st	int
;	O
mach	struct
.	O
st	int
+=	O
n	long
;	O
}	O
void	O
leave	function
(	O
)	O
{	O
mach	struct
.	O
rA	O
=	O
popn	function
(	O
)	O
;	O
mach	struct
.	O
st	int
=	O
mach	struct
.	O
sb	int
;	O
mach	struct
.	O
sb	int
=	O
popn	function
(	O
)	O
;	O
mach	struct
.	O
pc	int
=	O
(	O
pctr_t	int
)	O
popn	function
(	O
)	O
;	O
}	O
RWSTYPE	long
getarg	function
(	O
int	O
num	int
)	O
{	O
return	O
mach	struct
.	O
stack	pointer
[	O
mach	struct
.	O
sb	int
-	O
(	O
STACK_BASE	int
+	O
num	int
)	O
]	O
;	O
}	O
static	O
int	O
rw_error	function
(	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
"%s: %s"	pointer
,	O
_	O
(	O
"rewrite runtime error"	pointer
)	O
,	O
msg	pointer
)	O
;	O
longjmp	function
(	O
mach	struct
.	O
jmp	array
,	O
1	int
)	O
;	O
}	O
static	O
int	O
rw_error_free	function
(	O
char	O
*	O
msg	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
"%s: %s"	pointer
,	O
_	O
(	O
"rewrite runtime error"	pointer
)	O
,	O
msg	pointer
)	O
;	O
free	pointer
(	O
msg	pointer
)	O
;	O
longjmp	function
(	O
mach	struct
.	O
jmp	array
,	O
1	int
)	O
;	O
}	O
void	O
rw_call	function
(	O
)	O
{	O
pctr_t	int
pc	int
=	O
(	O
pctr_t	int
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
pushn	function
(	O
mach	struct
.	O
pc	int
)	O
;	O
mach	struct
.	O
pc	int
=	O
pc	int
;	O
}	O
void	O
rw_adjstk	function
(	O
)	O
{	O
int	O
delta	int
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
mach	struct
.	O
st	int
-=	O
delta	int
;	O
pushn	function
(	O
mach	struct
.	O
rA	O
)	O
;	O
}	O
void	O
rw_enter	function
(	O
)	O
{	O
int	O
n	long
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
enter	function
(	O
n	long
)	O
;	O
}	O
void	O
rw_leave	function
(	O
)	O
{	O
leave	function
(	O
)	O
;	O
}	O
void	O
rw_pushn	function
(	O
)	O
{	O
RWSTYPE	long
n	long
=	O
(	O
RWSTYPE	long
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
pushn	function
(	O
n	long
)	O
;	O
}	O
void	O
rw_pushref	function
(	O
)	O
{	O
int	O
i	int
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
pushref	function
(	O
mach	struct
.	O
sA	pointer
,	O
mach	struct
.	O
pmatch	pointer
[	O
i	int
]	O
.	O
rm_so	long
,	O
mach	struct
.	O
pmatch	pointer
[	O
i	int
]	O
.	O
rm_eo	long
)	O
;	O
}	O
void	O
rw_pushv	function
(	O
)	O
{	O
stkoff_t	int
n	long
=	O
(	O
stkoff_t	int
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
pushn	function
(	O
mach	struct
.	O
stack	pointer
[	O
mach	struct
.	O
sb	int
+	O
n	long
]	O
)	O
;	O
}	O
void	O
rw_pushs	function
(	O
)	O
{	O
int	O
len	int
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
*	O
sptr	pointer
=	O
(	O
RWSTYPE	long
*	O
)	O
(	O
rw_code	pointer
+	O
mach	struct
.	O
pc	int
)	O
;	O
mach	struct
.	O
pc	int
+=	O
len	int
;	O
pushs	function
(	O
sptr	pointer
,	O
strlen	function
(	O
(	O
char	O
*	O
)	O
sptr	pointer
)	O
,	O
len	int
)	O
;	O
}	O
void	O
rw_asgn	function
(	O
)	O
{	O
stkoff_t	int
off	long
=	O
(	O
stkoff_t	int
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
n	long
;	O
cpopn	function
(	O
&	O
n	long
)	O
;	O
mach	struct
.	O
stack	pointer
[	O
mach	struct
.	O
sb	int
+	O
off	long
]	O
=	O
n	long
;	O
pushn	function
(	O
n	long
)	O
;	O
}	O
void	O
assert_request_presence	function
(	O
)	O
{	O
if	O
(	O
!	O
mach	struct
.	O
req	pointer
)	O
rw_error	function
(	O
_	O
(	O
"no request supplied"	pointer
)	O
)	O
;	O
}	O
void	O
rw_attrcheck0	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
pushn	function
(	O
grad_avl_find	function
(	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
,	O
attr	pointer
)	O
!=	O
NULL	O
)	O
;	O
}	O
void	O
rw_attrcheck	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
index	function
;	O
cpopn	function
(	O
&	O
index	function
)	O
;	O
pushn	function
(	O
grad_avl_find_n	function
(	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
,	O
attr	pointer
,	O
index	function
)	O
!=	O
NULL	O
)	O
;	O
}	O
void	O
attrasgn_internal	function
(	O
int	O
attr	pointer
,	O
grad_avp_t	struct
*	O
pair	pointer
,	O
RWSTYPE	long
val	array
)	O
{	O
grad_string_t	struct
str	pointer
;	O
assert_request_presence	function
(	O
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
{	O
pair	pointer
=	O
grad_avp_create	function
(	O
attr	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
rw_error	function
(	O
_	O
(	O
"can't create A/V pair"	pointer
)	O
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
mach	struct
.	O
req	pointer
->	O
avlist	pointer
,	O
pair	pointer
)	O
;	O
}	O
switch	O
(	O
pair	pointer
->	O
type	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
case	O
GRAD_TYPE_DATE	int
:	O
mem2string	function
(	O
&	O
str	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
val	array
)	O
;	O
grad_free	function
(	O
pair	pointer
->	O
avp_strvalue	O
)	O
;	O
pair	pointer
->	O
avp_strvalue	O
=	O
grad_malloc	function
(	O
str	pointer
.	O
size	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
pair	pointer
->	O
avp_strvalue	O
,	O
str	pointer
.	O
data	pointer
,	O
str	pointer
.	O
size	int
)	O
;	O
pair	pointer
->	O
avp_strvalue	O
[	O
str	pointer
.	O
size	int
]	O
=	O
0	int
;	O
pair	pointer
->	O
avp_strlength	O
=	O
str	pointer
.	O
size	int
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
case	O
GRAD_TYPE_IPADDR	int
:	O
pair	pointer
->	O
avp_lvalue	O
=	O
val	array
;	O
break	O
;	O
}	O
pushn	function
(	O
val	array
)	O
;	O
}	O
void	O
rw_attrasgn0	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
val	array
;	O
cpopn	function
(	O
&	O
val	array
)	O
;	O
attrasgn_internal	function
(	O
attr	pointer
,	O
grad_avl_find	function
(	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
,	O
attr	pointer
)	O
,	O
val	array
)	O
;	O
}	O
void	O
rw_attrasgn	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
val	array
;	O
RWSTYPE	long
index	function
;	O
cpopn	function
(	O
&	O
val	array
)	O
;	O
cpopn	function
(	O
&	O
index	function
)	O
;	O
attrasgn_internal	function
(	O
attr	pointer
,	O
grad_avl_find_n	function
(	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
,	O
attr	pointer
,	O
index	function
)	O
,	O
val	array
)	O
;	O
}	O
void	O
rw_attrs0	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
if	O
(	O
(	O
pair	pointer
=	O
grad_avl_find	function
(	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
,	O
attr	pointer
)	O
)	O
==	O
NULL	O
)	O
pushstr	function
(	O
""	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
pair	pointer
->	O
prop	int
&	O
GRAD_AP_ENCRYPT	O
)	O
{	O
char	O
string	pointer
[	O
GRAD_STRING_LENGTH	int
+	O
1	int
]	O
;	O
int	O
len	int
;	O
req_decrypt_password	function
(	O
string	pointer
,	O
mach	struct
.	O
req	pointer
,	O
pair	pointer
)	O
;	O
len	int
=	O
strlen	function
(	O
string	pointer
)	O
;	O
pushstr	function
(	O
string	pointer
,	O
len	int
)	O
;	O
}	O
else	O
pushstr	function
(	O
pair	pointer
->	O
avp_strvalue	O
,	O
pair	pointer
->	O
avp_strlength	O
)	O
;	O
}	O
void	O
rw_attrn0	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
if	O
(	O
(	O
pair	pointer
=	O
grad_avl_find	function
(	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
,	O
attr	pointer
)	O
)	O
==	O
NULL	O
)	O
pushn	function
(	O
0	int
)	O
;	O
else	O
pushn	function
(	O
pair	pointer
->	O
avp_lvalue	O
)	O
;	O
}	O
void	O
rw_attrs	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
RWSTYPE	long
index	function
;	O
cpopn	function
(	O
&	O
index	function
)	O
;	O
if	O
(	O
(	O
pair	pointer
=	O
grad_avl_find_n	function
(	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
,	O
attr	pointer
,	O
index	function
)	O
)	O
==	O
NULL	O
)	O
pushstr	function
(	O
""	pointer
,	O
0	int
)	O
;	O
else	O
pushstr	function
(	O
pair	pointer
->	O
avp_strvalue	O
,	O
pair	pointer
->	O
avp_strlength	O
)	O
;	O
}	O
void	O
rw_attrn	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
RWSTYPE	long
index	function
;	O
cpopn	function
(	O
&	O
index	function
)	O
;	O
if	O
(	O
(	O
pair	pointer
=	O
grad_avl_find_n	function
(	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
,	O
attr	pointer
,	O
index	function
)	O
)	O
==	O
NULL	O
)	O
pushn	function
(	O
0	int
)	O
;	O
else	O
pushn	function
(	O
pair	pointer
->	O
avp_lvalue	O
)	O
;	O
}	O
void	O
rw_attr_delete0	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
grad_avl_delete	function
(	O
&	O
mach	struct
.	O
req	pointer
->	O
avlist	pointer
,	O
attr	pointer
)	O
;	O
}	O
void	O
rw_attr_delete	function
(	O
)	O
{	O
int	O
attr	pointer
=	O
(	O
int	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
RWSTYPE	long
index	function
;	O
assert_request_presence	function
(	O
)	O
;	O
cpopn	function
(	O
&	O
index	function
)	O
;	O
grad_avl_delete_n	function
(	O
&	O
mach	struct
.	O
req	pointer
->	O
avlist	pointer
,	O
attr	pointer
,	O
index	function
)	O
;	O
}	O
void	O
rw_popn	function
(	O
)	O
{	O
RWSTYPE	long
n	long
;	O
cpopn	function
(	O
&	O
n	long
)	O
;	O
}	O
void	O
rw_popa	function
(	O
)	O
{	O
cpopn	function
(	O
&	O
mach	struct
.	O
rA	O
)	O
;	O
}	O
void	O
rw_pusha	function
(	O
)	O
{	O
pushn	function
(	O
mach	struct
.	O
rA	O
)	O
;	O
}	O
void	O
rw_adds	function
(	O
)	O
{	O
grad_string_t	struct
s1	struct
,	O
s2	struct
;	O
RWSTYPE	long
*	O
p	pointer
;	O
char	O
*	O
s	pointer
;	O
checkpop	function
(	O
2	int
)	O
;	O
poparr	function
(	O
&	O
s2	struct
)	O
;	O
poparr	function
(	O
&	O
s1	struct
)	O
;	O
p	pointer
=	O
heap_reserve	function
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
s1	struct
.	O
size	int
+	O
s2	struct
.	O
size	int
+	O
1	int
)	O
;	O
s	pointer
=	O
(	O
char	O
*	O
)	O
(	O
p	pointer
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	pointer
,	O
s1	struct
.	O
data	pointer
,	O
s1	struct
.	O
size	int
)	O
;	O
s	pointer
+=	O
s1	struct
.	O
size	int
;	O
memcpy	function
(	O
s	pointer
,	O
s2	struct
.	O
data	pointer
,	O
s2	struct
.	O
size	int
)	O
;	O
s	pointer
+=	O
s2	struct
.	O
size	int
;	O
*	O
s	pointer
=	O
0	int
;	O
p	pointer
[	O
0	int
]	O
=	O
s1	struct
.	O
size	int
+	O
s2	struct
.	O
size	int
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
p	pointer
)	O
;	O
}	O
void	O
rw_neg	function
(	O
)	O
{	O
checkpop	function
(	O
1	int
)	O
;	O
pushn	function
(	O
-	O
popn	function
(	O
)	O
)	O
;	O
}	O
void	O
rw_b_and	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
&	O
n2	int
)	O
;	O
}	O
void	O
rw_b_or	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
|	O
n2	int
)	O
;	O
}	O
void	O
rw_b_xor	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
^	O
n2	int
)	O
;	O
}	O
void	O
rw_shl	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
<<	O
n2	int
)	O
;	O
}	O
void	O
rw_shr	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
>>	O
n2	int
)	O
;	O
}	O
void	O
rw_add	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
+	O
n2	int
)	O
;	O
}	O
void	O
rw_sub	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
-	O
n2	int
)	O
;	O
}	O
void	O
rw_mul	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
*	O
n2	int
)	O
;	O
}	O
void	O
rw_div	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
if	O
(	O
n2	int
==	O
0	int
)	O
rw_error	function
(	O
_	O
(	O
"division by zero!"	pointer
)	O
)	O
;	O
pushn	function
(	O
n1	int
/	O
n2	int
)	O
;	O
}	O
void	O
rw_rem	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
if	O
(	O
n2	int
==	O
0	int
)	O
rw_error	function
(	O
_	O
(	O
"division by zero!"	pointer
)	O
)	O
;	O
pushn	function
(	O
n1	int
%	O
n2	int
)	O
;	O
}	O
void	O
rw_i2s	function
(	O
)	O
{	O
int	O
n	long
=	O
popn	function
(	O
)	O
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%d"	pointer
,	O
n	long
)	O
;	O
pushstr	function
(	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
void	O
rw_s2i	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
popn	function
(	O
)	O
)	O
;	O
pushn	function
(	O
strtol	function
(	O
s	pointer
.	O
data	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
;	O
}	O
void	O
rw_eq	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
==	O
n2	int
)	O
;	O
}	O
void	O
rw_ne	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
!=	O
n2	int
)	O
;	O
}	O
void	O
rw_lt	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
<	O
n2	int
)	O
;	O
}	O
void	O
rw_le	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
<=	O
n2	int
)	O
;	O
}	O
void	O
rw_gt	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
>	O
n2	int
)	O
;	O
}	O
void	O
rw_ge	function
(	O
)	O
{	O
int	O
n1	int
,	O
n2	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
n2	int
=	O
popn	function
(	O
)	O
;	O
n1	int
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
n1	int
>=	O
n2	int
)	O
;	O
}	O
void	O
rw_eqs	function
(	O
)	O
{	O
grad_string_t	struct
s1	struct
,	O
s2	struct
;	O
checkpop	function
(	O
2	int
)	O
;	O
poparr	function
(	O
&	O
s2	struct
)	O
;	O
poparr	function
(	O
&	O
s1	struct
)	O
;	O
pushn	function
(	O
s1	struct
.	O
size	int
==	O
s2	struct
.	O
size	int
&&	O
memcmp	function
(	O
s1	struct
.	O
data	pointer
,	O
s2	struct
.	O
data	pointer
,	O
s1	struct
.	O
size	int
)	O
==	O
0	int
)	O
;	O
}	O
void	O
rw_nes	function
(	O
)	O
{	O
grad_string_t	struct
s1	struct
,	O
s2	struct
;	O
checkpop	function
(	O
2	int
)	O
;	O
poparr	function
(	O
&	O
s2	struct
)	O
;	O
poparr	function
(	O
&	O
s1	struct
)	O
;	O
pushn	function
(	O
!	O
(	O
s1	struct
.	O
size	int
==	O
s2	struct
.	O
size	int
&&	O
memcmp	function
(	O
s1	struct
.	O
data	pointer
,	O
s2	struct
.	O
data	pointer
,	O
s1	struct
.	O
size	int
)	O
==	O
0	int
)	O
)	O
;	O
}	O
void	O
rw_lts	function
(	O
)	O
{	O
grad_string_t	struct
s1	struct
,	O
s2	struct
;	O
size_t	long
size	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
poparr	function
(	O
&	O
s2	struct
)	O
;	O
poparr	function
(	O
&	O
s1	struct
)	O
;	O
size	int
=	O
RW_MIN	O
(	O
s1	struct
.	O
size	int
,	O
s2	struct
.	O
size	int
)	O
;	O
pushn	function
(	O
memcmp	function
(	O
s1	struct
.	O
data	pointer
,	O
s2	struct
.	O
data	pointer
,	O
size	int
<	O
0	int
)	O
||	O
s1	struct
.	O
size	int
<	O
s2	struct
.	O
size	int
)	O
;	O
}	O
void	O
rw_les	function
(	O
)	O
{	O
grad_string_t	struct
s1	struct
,	O
s2	struct
;	O
size_t	long
size	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
poparr	function
(	O
&	O
s2	struct
)	O
;	O
poparr	function
(	O
&	O
s1	struct
)	O
;	O
size	int
=	O
RW_MIN	O
(	O
s1	struct
.	O
size	int
,	O
s2	struct
.	O
size	int
)	O
;	O
pushn	function
(	O
memcmp	function
(	O
s1	struct
.	O
data	pointer
,	O
s2	struct
.	O
data	pointer
,	O
size	int
<=	O
0	int
)	O
||	O
s1	struct
.	O
size	int
<=	O
s2	struct
.	O
size	int
)	O
;	O
}	O
void	O
rw_gts	function
(	O
)	O
{	O
grad_string_t	struct
s1	struct
,	O
s2	struct
;	O
size_t	long
size	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
poparr	function
(	O
&	O
s2	struct
)	O
;	O
poparr	function
(	O
&	O
s1	struct
)	O
;	O
size	int
=	O
RW_MIN	O
(	O
s1	struct
.	O
size	int
,	O
s2	struct
.	O
size	int
)	O
;	O
pushn	function
(	O
memcmp	function
(	O
s1	struct
.	O
data	pointer
,	O
s2	struct
.	O
data	pointer
,	O
size	int
>	O
0	int
)	O
||	O
s1	struct
.	O
size	int
>	O
s2	struct
.	O
size	int
)	O
;	O
}	O
void	O
rw_ges	function
(	O
)	O
{	O
grad_string_t	struct
s1	struct
,	O
s2	struct
;	O
size_t	long
size	int
;	O
checkpop	function
(	O
2	int
)	O
;	O
poparr	function
(	O
&	O
s2	struct
)	O
;	O
poparr	function
(	O
&	O
s1	struct
)	O
;	O
size	int
=	O
RW_MIN	O
(	O
s1	struct
.	O
size	int
,	O
s2	struct
.	O
size	int
)	O
;	O
pushn	function
(	O
memcmp	function
(	O
s1	struct
.	O
data	pointer
,	O
s2	struct
.	O
data	pointer
,	O
size	int
>=	O
0	int
)	O
||	O
s1	struct
.	O
size	int
>=	O
s2	struct
.	O
size	int
)	O
;	O
}	O
void	O
rw_not	function
(	O
)	O
{	O
int	O
n	long
;	O
checkpop	function
(	O
1	int
)	O
;	O
n	long
=	O
popn	function
(	O
)	O
;	O
pushn	function
(	O
!	O
n	long
)	O
;	O
}	O
static	O
void	O
need_pmatch	function
(	O
size_t	long
n	long
)	O
{	O
n	long
++	O
;	O
if	O
(	O
mach	struct
.	O
nmatch	int
<	O
n	long
)	O
{	O
grad_free	function
(	O
mach	struct
.	O
pmatch	pointer
)	O
;	O
mach	struct
.	O
nmatch	int
=	O
n	long
;	O
mach	struct
.	O
pmatch	pointer
=	O
grad_emalloc	function
(	O
n	long
*	O
sizeof	O
(	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
}	O
void	O
rw_match	function
(	O
)	O
{	O
COMP_REGEX	struct
*	O
rx	pointer
=	O
(	O
COMP_REGEX	struct
*	O
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
grad_string_t	struct
s	pointer
;	O
int	O
rc	int
;	O
poparr	function
(	O
&	O
s	pointer
)	O
;	O
need_pmatch	function
(	O
rx	pointer
->	O
nmatch	int
)	O
;	O
mach	struct
.	O
sA	pointer
=	O
s	pointer
.	O
data	pointer
;	O
rc	int
=	O
regexec	O
(	O
&	O
rx	pointer
->	O
regex	struct
,	O
mach	struct
.	O
sA	pointer
,	O
rx	pointer
->	O
nmatch	int
+	O
1	int
,	O
mach	struct
.	O
pmatch	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
&&	O
GRAD_DEBUG_LEVEL	O
(	O
1	int
)	O
)	O
{	O
char	O
errbuf	array
[	O
512	int
]	O
;	O
regerror	O
(	O
rc	int
,	O
&	O
rx	pointer
->	O
regex	struct
,	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
)	O
;	O
grad_log	function
(	O
GRAD_LOG_DEBUG	int
,	O
_	O
(	O
"rewrite regex failure: %s. Input: %s"	pointer
)	O
,	O
errbuf	array
,	O
(	O
char	O
*	O
)	O
mach	struct
.	O
rA	O
)	O
;	O
}	O
pushn	function
(	O
rc	int
==	O
0	int
)	O
;	O
}	O
void	O
rw_jmp	function
(	O
)	O
{	O
pctr_t	int
pc	int
=	O
(	O
pctr_t	int
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
mach	struct
.	O
pc	int
=	O
pc	int
;	O
}	O
void	O
rw_jne	function
(	O
)	O
{	O
int	O
n	long
;	O
pctr_t	int
pc	int
=	O
(	O
pctr_t	int
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
n	long
=	O
popn	function
(	O
)	O
;	O
if	O
(	O
n	long
!=	O
0	int
)	O
mach	struct
.	O
pc	int
=	O
pc	int
;	O
}	O
void	O
rw_je	function
(	O
)	O
{	O
int	O
n	long
;	O
pctr_t	int
pc	int
=	O
(	O
pctr_t	int
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
n	long
=	O
popn	function
(	O
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
mach	struct
.	O
pc	int
=	O
pc	int
;	O
}	O
void	O
rw_builtin	function
(	O
)	O
{	O
INSTR	pointer
fun	pointer
=	O
(	O
INSTR	pointer
)	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
;	O
pushn	function
(	O
mach	struct
.	O
pc	int
)	O
;	O
enter	function
(	O
0	int
)	O
;	O
fun	pointer
(	O
)	O
;	O
leave	function
(	O
)	O
;	O
}	O
void	O
run	function
(	O
pctr_t	int
pc	int
)	O
{	O
mach	struct
.	O
pc	int
=	O
pc	int
;	O
while	O
(	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
]	O
)	O
{	O
if	O
(	O
mach	struct
.	O
pc	int
>=	O
rw_codesize	long
)	O
rw_error	function
(	O
_	O
(	O
"pc out of range"	pointer
)	O
)	O
;	O
(	O
*	O
(	O
rw_code	pointer
[	O
mach	struct
.	O
pc	int
++	O
]	O
)	O
)	O
(	O
)	O
;	O
}	O
}	O
void	O
gc	function
(	O
)	O
{	O
}	O
static	O
void	O
bi_length	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
pushn	function
(	O
s	pointer
.	O
size	int
)	O
;	O
}	O
static	O
void	O
bi_index	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
c	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
c	pointer
=	O
(	O
int	O
)	O
getarg	function
(	O
1	int
)	O
;	O
p	pointer
=	O
memchr	function
(	O
s	pointer
.	O
data	pointer
,	O
c	pointer
,	O
s	pointer
.	O
size	int
)	O
;	O
pushn	function
(	O
p	pointer
?	O
p	pointer
-	O
s	pointer
.	O
data	pointer
:	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
bi_rindex	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
int	O
i	int
;	O
int	O
c	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
s	pointer
.	O
size	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
s	pointer
.	O
data	pointer
[	O
i	int
]	O
==	O
c	pointer
)	O
break	O
;	O
pushn	function
(	O
i	int
)	O
;	O
}	O
static	O
void	O
bi_substr	function
(	O
)	O
{	O
grad_string_t	struct
src	pointer
;	O
RWSTYPE	long
*	O
p	pointer
;	O
char	O
*	O
dest	pointer
;	O
int	O
start	pointer
,	O
length	short
;	O
mem2string	function
(	O
&	O
src	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
3	int
)	O
)	O
;	O
start	pointer
=	O
getarg	function
(	O
2	int
)	O
;	O
length	short
=	O
getarg	function
(	O
1	int
)	O
;	O
if	O
(	O
length	short
<	O
0	int
)	O
length	short
=	O
src	pointer
.	O
size	int
-	O
start	pointer
;	O
p	pointer
=	O
heap_reserve	function
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
length	short
+	O
1	int
)	O
;	O
dest	pointer
=	O
(	O
char	O
*	O
)	O
(	O
p	pointer
+	O
1	int
)	O
;	O
if	O
(	O
length	short
>	O
0	int
)	O
memcpy	function
(	O
dest	pointer
,	O
src	pointer
.	O
data	pointer
+	O
start	pointer
,	O
length	short
)	O
;	O
dest	pointer
[	O
length	short
]	O
=	O
0	int
;	O
p	pointer
[	O
0	int
]	O
=	O
length	short
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
p	pointer
)	O
;	O
}	O
static	O
void	O
bi_field	function
(	O
)	O
{	O
grad_string_t	struct
str	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
endp	pointer
;	O
int	O
fn	pointer
=	O
getarg	function
(	O
1	int
)	O
;	O
char	O
*	O
s	pointer
=	O
""	pointer
;	O
int	O
len	int
=	O
1	int
;	O
mem2string	function
(	O
&	O
str	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
endp	pointer
=	O
str	pointer
.	O
data	pointer
+	O
str	pointer
.	O
size	int
;	O
for	O
(	O
p	pointer
=	O
str	pointer
.	O
data	pointer
;	O
p	pointer
<	O
endp	pointer
&&	O
fn	pointer
--	O
;	O
)	O
{	O
while	O
(	O
p	pointer
<	O
endp	pointer
&&	O
isspace	function
(	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
s	pointer
=	O
p	pointer
;	O
len	int
=	O
0	int
;	O
while	O
(	O
p	pointer
<	O
endp	pointer
&&	O
!	O
isspace	function
(	O
*	O
p	pointer
)	O
)	O
{	O
p	pointer
++	O
;	O
len	int
++	O
;	O
}	O
}	O
if	O
(	O
p	pointer
==	O
endp	pointer
&&	O
fn	pointer
)	O
pushstr	function
(	O
""	pointer
,	O
0	int
)	O
;	O
else	O
pushstr	function
(	O
s	pointer
,	O
len	int
)	O
;	O
}	O
static	O
void	O
bi_logit	function
(	O
)	O
{	O
grad_string_t	struct
msg	pointer
;	O
mem2string	function
(	O
&	O
msg	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
"%s"	pointer
,	O
msg	pointer
.	O
data	pointer
)	O
;	O
pushn	function
(	O
0	int
)	O
;	O
}	O
static	O
void	O
bi_htonl	function
(	O
)	O
{	O
pushn	function
(	O
htonl	function
(	O
getarg	function
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
bi_ntohl	function
(	O
)	O
{	O
pushn	function
(	O
ntohl	function
(	O
getarg	function
(	O
1	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
bi_htons	function
(	O
)	O
{	O
pushn	function
(	O
htons	function
(	O
getarg	function
(	O
1	int
)	O
&	O
0xffff	int
)	O
)	O
;	O
}	O
static	O
void	O
bi_ntohs	function
(	O
)	O
{	O
pushn	function
(	O
ntohs	function
(	O
getarg	function
(	O
1	int
)	O
&	O
0xffff	int
)	O
)	O
;	O
}	O
static	O
void	O
bi_inet_ntoa	function
(	O
)	O
{	O
char	O
buffer	pointer
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
char	O
*	O
s	pointer
=	O
grad_ip_iptostr	function
(	O
getarg	function
(	O
1	int
)	O
,	O
buffer	pointer
)	O
;	O
pushstr	function
(	O
s	pointer
,	O
strlen	function
(	O
s	pointer
)	O
)	O
;	O
}	O
static	O
void	O
bi_inet_aton	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
pushn	function
(	O
grad_ip_strtoip	function
(	O
s	pointer
.	O
data	pointer
)	O
)	O
;	O
}	O
static	O
void	O
bi_tolower	function
(	O
)	O
{	O
grad_string_t	struct
src	pointer
;	O
grad_string_t	struct
dest	pointer
;	O
int	O
i	int
;	O
mem2string	function
(	O
&	O
src	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
pushstr	function
(	O
src	pointer
.	O
data	pointer
,	O
src	pointer
.	O
size	int
)	O
;	O
mem2string	function
(	O
&	O
dest	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
tos	function
(	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dest	pointer
.	O
size	int
;	O
i	int
++	O
)	O
dest	pointer
.	O
data	pointer
[	O
i	int
]	O
=	O
tolower	function
(	O
dest	pointer
.	O
data	pointer
[	O
i	int
]	O
)	O
;	O
}	O
static	O
void	O
bi_toupper	function
(	O
)	O
{	O
grad_string_t	struct
src	pointer
;	O
grad_string_t	struct
dest	pointer
;	O
int	O
i	int
;	O
mem2string	function
(	O
&	O
src	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
pushstr	function
(	O
src	pointer
.	O
data	pointer
,	O
src	pointer
.	O
size	int
)	O
;	O
mem2string	function
(	O
&	O
dest	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
tos	function
(	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dest	pointer
.	O
size	int
;	O
i	int
++	O
)	O
dest	pointer
.	O
data	pointer
[	O
i	int
]	O
=	O
toupper	function
(	O
dest	pointer
.	O
data	pointer
[	O
i	int
]	O
)	O
;	O
}	O
static	O
void	O
bi_request_code_string	function
(	O
)	O
{	O
int	O
code	char
=	O
(	O
int	O
)	O
getarg	function
(	O
1	int
)	O
;	O
const	O
char	O
*	O
s	pointer
=	O
grad_request_code_to_name	function
(	O
code	char
)	O
;	O
pushstr	function
(	O
s	pointer
,	O
strlen	function
(	O
s	pointer
)	O
)	O
;	O
}	O
static	O
void	O
bi_request_source_ip	function
(	O
)	O
{	O
assert_request_presence	function
(	O
)	O
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
mach	struct
.	O
req	pointer
->	O
ipaddr	int
)	O
;	O
}	O
static	O
void	O
bi_request_source_port	function
(	O
)	O
{	O
assert_request_presence	function
(	O
)	O
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
mach	struct
.	O
req	pointer
->	O
udp_port	short
)	O
;	O
}	O
static	O
void	O
bi_request_id	function
(	O
)	O
{	O
assert_request_presence	function
(	O
)	O
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
mach	struct
.	O
req	pointer
->	O
id	char
)	O
;	O
}	O
static	O
void	O
bi_request_code	function
(	O
)	O
{	O
assert_request_presence	function
(	O
)	O
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
mach	struct
.	O
req	pointer
->	O
code	char
)	O
;	O
}	O
static	O
void	O
bi_nas_name	function
(	O
)	O
{	O
grad_nas_t	struct
*	O
nas	int
;	O
grad_uint32_t	int
ip	pointer
=	O
(	O
grad_uint32_t	int
)	O
getarg	function
(	O
1	int
)	O
;	O
if	O
(	O
(	O
nas	int
=	O
grad_nas_lookup_ip	function
(	O
ip	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
s	pointer
=	O
nas	int
->	O
shortname	array
[	O
0	int
]	O
?	O
nas	int
->	O
shortname	array
:	O
nas	int
->	O
longname	array
;	O
pushstr	function
(	O
s	pointer
,	O
strlen	function
(	O
s	pointer
)	O
)	O
;	O
}	O
else	O
{	O
char	O
nasname	array
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_ip_gethostname	function
(	O
ip	pointer
,	O
nasname	array
,	O
sizeof	O
(	O
nasname	array
)	O
)	O
;	O
pushstr	function
(	O
nasname	array
,	O
strlen	function
(	O
nasname	array
)	O
)	O
;	O
}	O
}	O
static	O
void	O
bi_nas_short_name	function
(	O
)	O
{	O
grad_nas_t	struct
*	O
nas	int
;	O
grad_uint32_t	int
ip	pointer
=	O
(	O
grad_uint32_t	int
)	O
getarg	function
(	O
1	int
)	O
;	O
if	O
(	O
(	O
nas	int
=	O
grad_nas_lookup_ip	function
(	O
ip	pointer
)	O
)	O
&&	O
nas	int
->	O
shortname	array
[	O
0	int
]	O
)	O
{	O
pushstr	function
(	O
nas	int
->	O
shortname	array
,	O
strlen	function
(	O
nas	int
->	O
shortname	array
)	O
)	O
;	O
}	O
else	O
{	O
char	O
nasname	array
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_ip_gethostname	function
(	O
ip	pointer
,	O
nasname	array
,	O
sizeof	O
(	O
nasname	array
)	O
)	O
;	O
pushstr	function
(	O
nasname	array
,	O
strlen	function
(	O
nasname	array
)	O
)	O
;	O
}	O
}	O
static	O
void	O
bi_nas_full_name	function
(	O
)	O
{	O
grad_nas_t	struct
*	O
nas	int
;	O
grad_uint32_t	int
ip	pointer
=	O
(	O
grad_uint32_t	int
)	O
getarg	function
(	O
1	int
)	O
;	O
if	O
(	O
(	O
nas	int
=	O
grad_nas_lookup_ip	function
(	O
ip	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
pushstr	function
(	O
nas	int
->	O
longname	array
,	O
strlen	function
(	O
nas	int
->	O
longname	array
)	O
)	O
;	O
}	O
else	O
{	O
char	O
nasname	array
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_ip_gethostname	function
(	O
ip	pointer
,	O
nasname	array
,	O
sizeof	O
(	O
nasname	array
)	O
)	O
;	O
pushstr	function
(	O
nasname	array
,	O
strlen	function
(	O
nasname	array
)	O
)	O
;	O
}	O
}	O
static	O
void	O
bi_gethostbyaddr	function
(	O
)	O
{	O
grad_uint32_t	int
ip	pointer
=	O
(	O
grad_uint32_t	int
)	O
getarg	function
(	O
1	int
)	O
;	O
char	O
nasname	array
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_ip_gethostname	function
(	O
ip	pointer
,	O
nasname	array
,	O
sizeof	O
(	O
nasname	array
)	O
)	O
;	O
pushstr	function
(	O
nasname	array
,	O
strlen	function
(	O
nasname	array
)	O
)	O
;	O
}	O
static	O
void	O
bi_gethostbyname	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
grad_ip_gethostaddr	function
(	O
s	pointer
.	O
data	pointer
)	O
)	O
;	O
}	O
static	O
void	O
bi_time	function
(	O
)	O
{	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
time	struct
(	O
NULL	O
)	O
)	O
;	O
}	O
static	O
void	O
bi_strftime	function
(	O
)	O
{	O
struct	O
tm	struct
*	O
tm	struct
;	O
char	O
*	O
base	int
;	O
time_t	long
t	long
=	O
(	O
time_t	long
)	O
getarg	function
(	O
1	int
)	O
;	O
grad_string_t	struct
fmt	pointer
;	O
size_t	long
n	long
;	O
mem2string	function
(	O
&	O
fmt	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
tm	struct
=	O
localtime	function
(	O
&	O
t	long
)	O
;	O
base	int
=	O
temp_space_create	function
(	O
)	O
;	O
n	long
=	O
strftime	function
(	O
base	int
,	O
temp_space_size	function
(	O
)	O
,	O
fmt	pointer
.	O
data	pointer
,	O
tm	struct
)	O
;	O
pushstr	function
(	O
base	int
,	O
n	long
)	O
;	O
}	O
static	O
void	O
rw_regerror	function
(	O
const	O
char	O
*	O
prefix	pointer
,	O
regex_t	struct
*	O
rx	pointer
,	O
int	O
rc	int
)	O
{	O
size_t	long
sz	long
=	O
regerror	O
(	O
rc	int
,	O
rx	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
char	O
*	O
errbuf	array
=	O
malloc	function
(	O
sz	long
+	O
strlen	function
(	O
prefix	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
errbuf	array
)	O
rw_error	function
(	O
prefix	pointer
)	O
;	O
else	O
{	O
strcpy	function
(	O
errbuf	array
,	O
prefix	pointer
)	O
;	O
regerror	O
(	O
rc	int
,	O
rx	pointer
,	O
errbuf	array
+	O
strlen	function
(	O
prefix	pointer
)	O
,	O
sz	long
)	O
;	O
rw_error_free	function
(	O
errbuf	array
)	O
;	O
}	O
}	O
enum	O
subst_segment_type	enum
{	O
subst_text	int
,	O
subst_ref	int
,	O
subst_match	int
}	O
;	O
struct	O
subst_segment	struct
{	O
enum	O
subst_segment_type	enum
type	int
;	O
union	O
{	O
struct	O
{	O
char	O
*	O
ptr	pointer
;	O
size_t	long
len	int
;	O
}	O
text	pointer
;	O
size_t	long
ref	struct
;	O
}	O
v	union
;	O
}	O
;	O
static	O
void	O
add_text_segment	function
(	O
grad_list_t	struct
*	O
lst	pointer
,	O
char	O
*	O
ptr	pointer
,	O
char	O
*	O
end	pointer
)	O
{	O
struct	O
subst_segment	struct
*	O
seg	pointer
;	O
if	O
(	O
ptr	pointer
>=	O
end	pointer
)	O
return	O
;	O
seg	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
seg	pointer
)	O
)	O
;	O
seg	pointer
->	O
type	int
=	O
subst_text	int
;	O
seg	pointer
->	O
v	union
.	O
text	pointer
.	O
ptr	pointer
=	O
ptr	pointer
;	O
seg	pointer
->	O
v	union
.	O
text	pointer
.	O
len	int
=	O
end	pointer
-	O
ptr	pointer
;	O
grad_list_append	function
(	O
lst	pointer
,	O
seg	pointer
)	O
;	O
}	O
static	O
void	O
add_match_segment	function
(	O
grad_list_t	struct
*	O
lst	pointer
)	O
{	O
struct	O
subst_segment	struct
*	O
seg	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
seg	pointer
)	O
)	O
;	O
seg	pointer
->	O
type	int
=	O
subst_match	int
;	O
grad_list_append	function
(	O
lst	pointer
,	O
seg	pointer
)	O
;	O
}	O
static	O
void	O
add_ref_segment	function
(	O
grad_list_t	struct
*	O
lst	pointer
,	O
size_t	long
ref	struct
)	O
{	O
struct	O
subst_segment	struct
*	O
seg	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
seg	pointer
)	O
)	O
;	O
seg	pointer
->	O
type	int
=	O
subst_ref	int
;	O
seg	pointer
->	O
v	union
.	O
ref	struct
=	O
ref	struct
;	O
grad_list_append	function
(	O
lst	pointer
,	O
seg	pointer
)	O
;	O
}	O
grad_list_t	struct
*	O
subst_create	function
(	O
char	O
*	O
text	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
grad_list_t	struct
*	O
lst	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
lst	pointer
)	O
return	O
lst	pointer
;	O
p	pointer
=	O
text	pointer
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
&&	O
p	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'&'	O
)	O
{	O
add_text_segment	function
(	O
lst	pointer
,	O
text	pointer
,	O
p	pointer
)	O
;	O
text	pointer
=	O
++	O
p	pointer
;	O
p	pointer
++	O
;	O
}	O
else	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
add_text_segment	function
(	O
lst	pointer
,	O
text	pointer
,	O
p	pointer
+	O
1	int
)	O
;	O
p	pointer
+=	O
2	int
;	O
text	pointer
=	O
p	pointer
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
p	pointer
[	O
1	int
]	O
)	O
)	O
{	O
size_t	long
ref	struct
;	O
char	O
*	O
q	pointer
;	O
add_text_segment	function
(	O
lst	pointer
,	O
text	pointer
,	O
p	pointer
)	O
;	O
ref	struct
=	O
strtoul	function
(	O
p	pointer
+	O
1	int
,	O
&	O
q	pointer
,	O
10	int
)	O
;	O
add_ref_segment	function
(	O
lst	pointer
,	O
ref	struct
)	O
;	O
text	pointer
=	O
p	pointer
=	O
q	pointer
;	O
}	O
else	O
{	O
add_text_segment	function
(	O
lst	pointer
,	O
text	pointer
,	O
p	pointer
)	O
;	O
text	pointer
=	O
++	O
p	pointer
;	O
}	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'&'	O
)	O
{	O
add_text_segment	function
(	O
lst	pointer
,	O
text	pointer
,	O
p	pointer
)	O
;	O
add_match_segment	function
(	O
lst	pointer
)	O
;	O
text	pointer
=	O
++	O
p	pointer
;	O
}	O
else	O
p	pointer
++	O
;	O
}	O
add_text_segment	function
(	O
lst	pointer
,	O
text	pointer
,	O
p	pointer
)	O
;	O
return	O
lst	pointer
;	O
}	O
int	O
seg_free	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
ARG_UNUSED	O
)	O
{	O
grad_free	function
(	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
subst_destroy	function
(	O
grad_list_t	struct
*	O
lst	pointer
)	O
{	O
grad_list_destroy	function
(	O
&	O
lst	pointer
,	O
seg_free	function
,	O
NULL	O
)	O
;	O
}	O
void	O
subst_run	function
(	O
grad_list_t	struct
*	O
subst	pointer
,	O
size_t	long
nsub	long
,	O
char	O
*	O
*	O
baseptr	pointer
,	O
char	O
*	O
arg	pointer
)	O
{	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
subst	pointer
)	O
;	O
struct	O
subst_segment	struct
*	O
seg	pointer
;	O
for	O
(	O
seg	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
seg	pointer
;	O
seg	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
switch	O
(	O
seg	pointer
->	O
type	int
)	O
{	O
case	O
subst_text	int
:	O
temp_space_copy	function
(	O
baseptr	pointer
,	O
seg	pointer
->	O
v	union
.	O
text	pointer
.	O
ptr	pointer
,	O
seg	pointer
->	O
v	union
.	O
text	pointer
.	O
len	int
)	O
;	O
break	O
;	O
case	O
subst_ref	int
:	O
if	O
(	O
seg	pointer
->	O
v	union
.	O
ref	struct
>=	O
nsub	long
)	O
rw_error	function
(	O
_	O
(	O
"Invalid backreference"	pointer
)	O
)	O
;	O
temp_space_copy	function
(	O
baseptr	pointer
,	O
arg	pointer
+	O
mach	struct
.	O
pmatch	pointer
[	O
seg	pointer
->	O
v	union
.	O
ref	struct
]	O
.	O
rm_so	long
,	O
mach	struct
.	O
pmatch	pointer
[	O
seg	pointer
->	O
v	union
.	O
ref	struct
]	O
.	O
rm_eo	long
-	O
mach	struct
.	O
pmatch	pointer
[	O
seg	pointer
->	O
v	union
.	O
ref	struct
]	O
.	O
rm_so	long
)	O
;	O
break	O
;	O
case	O
subst_match	int
:	O
temp_space_copy	function
(	O
baseptr	pointer
,	O
arg	pointer
+	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_so	long
,	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_eo	long
-	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_so	long
)	O
;	O
}	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
static	O
void	O
bi_gsub	function
(	O
)	O
{	O
grad_string_t	struct
re_str	struct
;	O
grad_string_t	struct
repl	struct
;	O
grad_string_t	struct
arg	pointer
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
base	int
;	O
regex_t	struct
rx	pointer
;	O
grad_list_t	struct
*	O
subst	pointer
;	O
int	O
rc	int
;	O
mem2string	function
(	O
&	O
re_str	struct
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
3	int
)	O
)	O
;	O
mem2string	function
(	O
&	O
repl	struct
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
mem2string	function
(	O
&	O
arg	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
p	pointer
=	O
arg	pointer
.	O
data	pointer
;	O
rc	int
=	O
regcomp	O
(	O
&	O
rx	pointer
,	O
re_str	struct
.	O
data	pointer
,	O
regcomp_flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
rw_regerror	function
(	O
_	O
(	O
"regexp compile error: "	pointer
)	O
,	O
&	O
rx	pointer
,	O
rc	int
)	O
;	O
need_pmatch	function
(	O
rx	pointer
.	O
re_nsub	long
)	O
;	O
subst	pointer
=	O
subst_create	function
(	O
repl	struct
.	O
data	pointer
)	O
;	O
if	O
(	O
!	O
subst	pointer
)	O
rw_error	function
(	O
_	O
(	O
"gsub: not enough memory"	pointer
)	O
)	O
;	O
base	int
=	O
temp_space_create	function
(	O
)	O
;	O
while	O
(	O
*	O
p	pointer
&&	O
regexec	O
(	O
&	O
rx	pointer
,	O
p	pointer
,	O
rx	pointer
.	O
re_nsub	long
+	O
1	int
,	O
mach	struct
.	O
pmatch	pointer
,	O
0	int
)	O
==	O
0	int
)	O
{	O
temp_space_copy	function
(	O
&	O
base	int
,	O
p	pointer
,	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_so	long
)	O
;	O
subst_run	function
(	O
subst	pointer
,	O
rx	pointer
.	O
re_nsub	long
+	O
1	int
,	O
&	O
base	int
,	O
p	pointer
)	O
;	O
p	pointer
+=	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_eo	long
;	O
if	O
(	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_eo	long
==	O
0	int
)	O
p	pointer
++	O
;	O
}	O
temp_space_copy	function
(	O
&	O
base	int
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
;	O
subst_destroy	function
(	O
subst	pointer
)	O
;	O
regfree	O
(	O
&	O
rx	pointer
)	O
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
temp_space_fix	function
(	O
base	int
)	O
)	O
;	O
}	O
static	O
void	O
bi_sub	function
(	O
)	O
{	O
grad_string_t	struct
re_str	struct
;	O
grad_string_t	struct
repl	struct
;	O
grad_string_t	struct
arg	pointer
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
base	int
;	O
regex_t	struct
rx	pointer
;	O
grad_list_t	struct
*	O
subst	pointer
;	O
int	O
rc	int
;	O
mem2string	function
(	O
&	O
re_str	struct
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
3	int
)	O
)	O
;	O
mem2string	function
(	O
&	O
repl	struct
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
mem2string	function
(	O
&	O
arg	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
rc	int
=	O
regcomp	O
(	O
&	O
rx	pointer
,	O
re_str	struct
.	O
data	pointer
,	O
regcomp_flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
rw_regerror	function
(	O
_	O
(	O
"regexp compile error: "	pointer
)	O
,	O
&	O
rx	pointer
,	O
rc	int
)	O
;	O
need_pmatch	function
(	O
rx	pointer
.	O
re_nsub	long
)	O
;	O
subst	pointer
=	O
subst_create	function
(	O
repl	struct
.	O
data	pointer
)	O
;	O
if	O
(	O
!	O
subst	pointer
)	O
rw_error	function
(	O
_	O
(	O
"sub: not enough memory"	pointer
)	O
)	O
;	O
base	int
=	O
temp_space_create	function
(	O
)	O
;	O
p	pointer
=	O
arg	pointer
.	O
data	pointer
;	O
if	O
(	O
regexec	O
(	O
&	O
rx	pointer
,	O
p	pointer
,	O
rx	pointer
.	O
re_nsub	long
+	O
1	int
,	O
mach	struct
.	O
pmatch	pointer
,	O
0	int
)	O
==	O
0	int
)	O
{	O
temp_space_copy	function
(	O
&	O
base	int
,	O
p	pointer
,	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_so	long
)	O
;	O
subst_run	function
(	O
subst	pointer
,	O
rx	pointer
.	O
re_nsub	long
+	O
1	int
,	O
&	O
base	int
,	O
p	pointer
)	O
;	O
p	pointer
+=	O
mach	struct
.	O
pmatch	pointer
[	O
0	int
]	O
.	O
rm_eo	long
;	O
}	O
temp_space_copy	function
(	O
&	O
base	int
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
;	O
subst_destroy	function
(	O
subst	pointer
)	O
;	O
regfree	O
(	O
&	O
rx	pointer
)	O
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
temp_space_fix	function
(	O
base	int
)	O
)	O
;	O
}	O
static	O
void	O
bi_qprn	function
(	O
)	O
{	O
grad_string_t	struct
arg	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
s	pointer
,	O
*	O
end	pointer
;	O
size_t	long
count	int
;	O
RWSTYPE	long
*	O
sp	pointer
;	O
mem2string	function
(	O
&	O
arg	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
end	pointer
=	O
arg	pointer
.	O
data	pointer
+	O
arg	pointer
.	O
size	int
;	O
for	O
(	O
count	int
=	O
0	int
,	O
p	pointer
=	O
arg	pointer
.	O
data	pointer
;	O
p	pointer
<	O
end	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
!	O
ISPRINT	O
(	O
*	O
p	pointer
)	O
)	O
count	int
++	O
;	O
sp	pointer
=	O
heap_reserve	function
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
arg	pointer
.	O
size	int
+	O
2	int
*	O
count	int
+	O
1	int
)	O
;	O
sp	pointer
[	O
0	int
]	O
=	O
arg	pointer
.	O
size	int
+	O
2	int
*	O
count	int
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
sp	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
sp	pointer
+	O
1	int
)	O
,	O
s	pointer
=	O
arg	pointer
.	O
data	pointer
;	O
s	pointer
<	O
end	pointer
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
ISPRINT	O
(	O
*	O
s	pointer
)	O
)	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
;	O
else	O
{	O
char	O
buf	pointer
[	O
3	int
]	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"%02X"	pointer
,	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
s	pointer
)	O
;	O
*	O
p	pointer
++	O
=	O
'%'	O
;	O
*	O
p	pointer
++	O
=	O
buf	pointer
[	O
0	int
]	O
;	O
*	O
p	pointer
++	O
=	O
buf	pointer
[	O
1	int
]	O
;	O
}	O
}	O
*	O
p	pointer
=	O
0	int
;	O
}	O
static	O
void	O
bi_quote_string	function
(	O
)	O
{	O
int	O
quote	pointer
;	O
grad_string_t	struct
arg	pointer
;	O
RWSTYPE	long
*	O
sp	pointer
;	O
char	O
*	O
p	pointer
;	O
size_t	long
size	int
;	O
mem2string	function
(	O
&	O
arg	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
size	int
=	O
grad_argcv_quoted_length_n	function
(	O
arg	pointer
.	O
data	pointer
,	O
arg	pointer
.	O
size	int
,	O
&	O
quote	pointer
)	O
;	O
sp	pointer
=	O
heap_reserve	function
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
size	int
+	O
1	int
)	O
;	O
sp	pointer
[	O
0	int
]	O
=	O
size	int
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
sp	pointer
)	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
sp	pointer
+	O
1	int
)	O
;	O
grad_argcv_quote_copy_n	function
(	O
p	pointer
,	O
arg	pointer
.	O
data	pointer
,	O
arg	pointer
.	O
size	int
)	O
;	O
}	O
static	O
void	O
bi_unquote_string	function
(	O
)	O
{	O
int	O
quote	pointer
;	O
grad_string_t	struct
arg	pointer
;	O
RWSTYPE	long
*	O
sp	pointer
;	O
char	O
*	O
p	pointer
;	O
size_t	long
size	int
;	O
mem2string	function
(	O
&	O
arg	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
sp	pointer
=	O
heap_reserve	function
(	O
sizeof	O
(	O
RWSTYPE	long
)	O
+	O
arg	pointer
.	O
size	int
+	O
1	int
)	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
sp	pointer
+	O
1	int
)	O
;	O
grad_argcv_unquote_copy	function
(	O
p	pointer
,	O
arg	pointer
.	O
data	pointer
,	O
arg	pointer
.	O
size	int
)	O
;	O
sp	pointer
[	O
0	int
]	O
=	O
strlen	function
(	O
p	pointer
)	O
;	O
pushn	function
(	O
(	O
RWSTYPE	long
)	O
sp	pointer
)	O
;	O
}	O
static	O
void	O
bi_textdomain	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
pushstr	function
(	O
default_gettext_domain	pointer
,	O
strlen	function
(	O
default_gettext_domain	pointer
)	O
)	O
;	O
grad_string_replace	function
(	O
&	O
default_gettext_domain	pointer
,	O
s	pointer
.	O
data	pointer
)	O
;	O
}	O
static	O
void	O
bi_gettext	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
p	pointer
=	O
dgettext	function
(	O
default_gettext_domain	pointer
,	O
s	pointer
.	O
data	pointer
)	O
;	O
pushstr	function
(	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
)	O
;	O
}	O
static	O
void	O
bi_dgettext	function
(	O
)	O
{	O
grad_string_t	struct
domain	pointer
;	O
grad_string_t	struct
text	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
mem2string	function
(	O
&	O
domain	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
mem2string	function
(	O
&	O
text	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
1	int
)	O
)	O
;	O
p	pointer
=	O
dgettext	function
(	O
domain	pointer
.	O
data	pointer
,	O
text	pointer
.	O
data	pointer
)	O
;	O
pushstr	function
(	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
)	O
;	O
}	O
static	O
void	O
bi_ngettext	function
(	O
)	O
{	O
grad_string_t	struct
s	pointer
;	O
grad_string_t	struct
pl	struct
;	O
unsigned	O
long	O
n	long
;	O
const	O
char	O
*	O
p	pointer
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
3	int
)	O
)	O
;	O
mem2string	function
(	O
&	O
pl	struct
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
n	long
=	O
(	O
unsigned	O
long	O
)	O
getarg	function
(	O
1	int
)	O
;	O
p	pointer
=	O
dngettext	function
(	O
default_gettext_domain	pointer
,	O
s	pointer
.	O
data	pointer
,	O
pl	struct
.	O
data	pointer
,	O
n	long
)	O
;	O
pushstr	function
(	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
)	O
;	O
}	O
static	O
void	O
bi_dngettext	function
(	O
)	O
{	O
grad_string_t	struct
domain	pointer
;	O
grad_string_t	struct
s	pointer
;	O
grad_string_t	struct
pl	struct
;	O
unsigned	O
long	O
n	long
;	O
const	O
char	O
*	O
p	pointer
;	O
mem2string	function
(	O
&	O
domain	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
4	int
)	O
)	O
;	O
mem2string	function
(	O
&	O
s	pointer
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
3	int
)	O
)	O
;	O
mem2string	function
(	O
&	O
pl	struct
,	O
(	O
RWSTYPE	long
*	O
)	O
getarg	function
(	O
2	int
)	O
)	O
;	O
n	long
=	O
(	O
unsigned	O
long	O
)	O
getarg	function
(	O
1	int
)	O
;	O
p	pointer
=	O
dngettext	function
(	O
domain	pointer
.	O
data	pointer
,	O
s	pointer
.	O
data	pointer
,	O
pl	struct
.	O
data	pointer
,	O
n	long
)	O
;	O
pushstr	function
(	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
)	O
;	O
}	O
static	O
builtin_t	struct
builtin	array
[	O
]	O
=	O
{	O
{	O
bi_length	function
,	O
"length"	pointer
,	O
Integer	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_index	function
,	O
"index"	pointer
,	O
Integer	int
,	O
"si"	pointer
}	O
,	O
{	O
bi_rindex	function
,	O
"rindex"	pointer
,	O
Integer	int
,	O
"si"	pointer
}	O
,	O
{	O
bi_substr	function
,	O
"substr"	pointer
,	O
String	int
,	O
"sii"	pointer
}	O
,	O
{	O
bi_logit	function
,	O
"logit"	pointer
,	O
Integer	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_field	function
,	O
"field"	pointer
,	O
String	int
,	O
"si"	pointer
}	O
,	O
{	O
bi_ntohl	function
,	O
"ntohl"	pointer
,	O
Integer	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_htonl	function
,	O
"htonl"	pointer
,	O
Integer	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_ntohs	function
,	O
"ntohs"	pointer
,	O
Integer	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_htons	function
,	O
"htons"	pointer
,	O
Integer	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_inet_ntoa	function
,	O
"inet_ntoa"	pointer
,	O
String	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_inet_aton	function
,	O
"inet_aton"	pointer
,	O
Integer	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_sub	function
,	O
"sub"	pointer
,	O
String	int
,	O
"sss"	pointer
}	O
,	O
{	O
bi_gsub	function
,	O
"gsub"	pointer
,	O
String	int
,	O
"sss"	pointer
}	O
,	O
{	O
bi_qprn	function
,	O
"qprn"	pointer
,	O
String	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_tolower	function
,	O
"tolower"	pointer
,	O
String	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_toupper	function
,	O
"toupper"	pointer
,	O
String	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_unquote_string	function
,	O
"unquote_string"	pointer
,	O
String	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_quote_string	function
,	O
"quote_string"	pointer
,	O
String	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_request_code_string	function
,	O
"request_code_string"	pointer
,	O
String	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_gettext	function
,	O
"gettext"	pointer
,	O
String	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_gettext	function
,	O
"_"	pointer
,	O
String	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_dgettext	function
,	O
"dgettext"	pointer
,	O
String	int
,	O
"ss"	pointer
}	O
,	O
{	O
bi_ngettext	function
,	O
"ngettext"	pointer
,	O
String	int
,	O
"ssi"	pointer
}	O
,	O
{	O
bi_dngettext	function
,	O
"dngettext"	pointer
,	O
String	int
,	O
"sssi"	pointer
}	O
,	O
{	O
bi_textdomain	function
,	O
"textdomain"	pointer
,	O
String	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_request_source_ip	function
,	O
"request_source_ip"	pointer
,	O
Integer	int
,	O
""	pointer
}	O
,	O
{	O
bi_request_source_port	function
,	O
"request_source_port"	pointer
,	O
Integer	int
,	O
""	pointer
}	O
,	O
{	O
bi_request_id	function
,	O
"request_id"	pointer
,	O
Integer	int
,	O
""	pointer
}	O
,	O
{	O
bi_request_code	function
,	O
"request_code"	pointer
,	O
Integer	int
,	O
""	pointer
}	O
,	O
{	O
bi_nas_name	function
,	O
"nas_name"	pointer
,	O
String	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_nas_short_name	function
,	O
"nas_short_name"	pointer
,	O
String	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_nas_full_name	function
,	O
"nas_full_name"	pointer
,	O
String	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_gethostbyaddr	function
,	O
"gethostbyaddr"	pointer
,	O
Integer	int
,	O
"s"	pointer
}	O
,	O
{	O
bi_gethostbyname	function
,	O
"gethostbyname"	pointer
,	O
String	int
,	O
"i"	pointer
}	O
,	O
{	O
bi_time	function
,	O
"time"	pointer
,	O
Integer	int
,	O
""	pointer
}	O
,	O
{	O
bi_strftime	function
,	O
"strftime"	pointer
,	O
String	int
,	O
"si"	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
builtin_t	struct
*	O
builtin_lookup	function
(	O
char	O
*	O
name	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
builtin	array
[	O
i	int
]	O
.	O
handler	pointer
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
builtin	array
[	O
i	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
&	O
builtin	array
[	O
i	int
]	O
;	O
return	O
NULL	O
;	O
}	O
int	O
function_free	function
(	O
FUNCTION	struct
*	O
f	pointer
)	O
{	O
PARAMETER	struct
*	O
parm	pointer
,	O
*	O
next	pointer
;	O
rx_free	function
(	O
f	pointer
->	O
rx_list	pointer
)	O
;	O
parm	pointer
=	O
f	pointer
->	O
parm	pointer
;	O
while	O
(	O
parm	pointer
)	O
{	O
next	pointer
=	O
parm	pointer
->	O
next	pointer
;	O
grad_free	function
(	O
parm	pointer
)	O
;	O
parm	pointer
=	O
next	pointer
;	O
}	O
return	O
0	int
;	O
}	O
FUNCTION	struct
*	O
function_install	function
(	O
FUNCTION	struct
*	O
fun	pointer
)	O
{	O
FUNCTION	struct
*	O
fp	pointer
;	O
if	O
(	O
fp	pointer
=	O
(	O
FUNCTION	struct
*	O
)	O
grad_sym_lookup	function
(	O
rewrite_tab	pointer
,	O
fun	pointer
->	O
name	pointer
)	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
fun	pointer
->	O
loc	struct
,	O
_	O
(	O
"redefinition of function %s"	pointer
)	O
)	O
;	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
fp	pointer
->	O
loc	struct
,	O
_	O
(	O
"previously defined here"	pointer
)	O
)	O
;	O
errcnt	long
++	O
;	O
return	O
fp	pointer
;	O
}	O
fp	pointer
=	O
(	O
FUNCTION	struct
*	O
)	O
grad_sym_install	function
(	O
rewrite_tab	pointer
,	O
fun	pointer
->	O
name	pointer
)	O
;	O
fp	pointer
->	O
rettype	enum
=	O
fun	pointer
->	O
rettype	enum
;	O
fp	pointer
->	O
entry	int
=	O
fun	pointer
->	O
entry	int
;	O
fp	pointer
->	O
rx_list	pointer
=	O
fun	pointer
->	O
rx_list	pointer
;	O
fp	pointer
->	O
nparm	int
=	O
fun	pointer
->	O
nparm	int
;	O
fp	pointer
->	O
parm	pointer
=	O
fun	pointer
->	O
parm	pointer
;	O
fp	pointer
->	O
stack_alloc	int
=	O
fun	pointer
->	O
stack_alloc	int
;	O
fp	pointer
->	O
loc	struct
=	O
fun	pointer
->	O
loc	struct
;	O
return	O
fp	pointer
;	O
}	O
static	O
char	O
pair_print_prefix	array
[	O
]	O
=	O
"    "	pointer
;	O
static	O
void	O
rw_mach_init	function
(	O
)	O
{	O
memset	function
(	O
&	O
mach	struct
,	O
0	int
,	O
sizeof	O
(	O
mach	struct
)	O
)	O
;	O
if	O
(	O
!	O
runtime_stack	pointer
)	O
runtime_stack	pointer
=	O
grad_emalloc	function
(	O
rewrite_stack_size	long
*	O
sizeof	O
(	O
runtime_stack	pointer
[	O
0	int
]	O
)	O
)	O
;	O
mach	struct
.	O
stack	pointer
=	O
runtime_stack	pointer
;	O
mach	struct
.	O
st	int
=	O
0	int
;	O
mach	struct
.	O
ht	int
=	O
rewrite_stack_size	long
-	O
1	int
;	O
grad_string_replace	function
(	O
&	O
default_gettext_domain	pointer
,	O
PACKAGE	pointer
)	O
;	O
}	O
static	O
void	O
rw_mach_destroy	function
(	O
)	O
{	O
grad_free	function
(	O
mach	struct
.	O
pmatch	pointer
)	O
;	O
mach	struct
.	O
pmatch	pointer
=	O
NULL	O
;	O
}	O
FUNCTION	struct
*	O
rewrite_check_function	function
(	O
const	O
char	O
*	O
name	pointer
,	O
grad_data_type_t	enum
rettype	enum
,	O
char	O
*	O
typestr	pointer
)	O
{	O
int	O
i	int
;	O
PARAMETER	struct
*	O
p	pointer
;	O
FUNCTION	struct
*	O
fun	pointer
=	O
(	O
FUNCTION	struct
*	O
)	O
grad_sym_lookup	function
(	O
rewrite_tab	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
fun	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"function %s not defined"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
fun	pointer
->	O
rettype	enum
!=	O
rettype	enum
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"function %s returns wrong data type"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
fun	pointer
->	O
parm	pointer
;	O
i	int
<	O
fun	pointer
->	O
nparm	int
;	O
i	int
++	O
,	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
typestr	pointer
[	O
i	int
]	O
)	O
{	O
case	O
0	int
:	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"function %s takes too many arguments"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
case	O
'i'	O
:	O
if	O
(	O
p	pointer
->	O
datatype	enum
!=	O
Integer	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"function %s: argument %d must be integer"	pointer
)	O
,	O
name	pointer
,	O
i	int
+	O
1	int
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
p	pointer
->	O
datatype	enum
!=	O
String	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"function %s: argument %d must be string"	pointer
)	O
,	O
name	pointer
,	O
i	int
+	O
1	int
)	O
;	O
return	O
NULL	O
;	O
}	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"bad datatype"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
typestr	pointer
[	O
i	int
]	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"function %s takes too few arguments"	pointer
)	O
,	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
fun	pointer
;	O
}	O
int	O
run_init	function
(	O
pctr_t	int
pc	int
,	O
grad_request_t	struct
*	O
request	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
rw_mach_init	function
(	O
)	O
;	O
if	O
(	O
setjmp	function
(	O
mach	struct
.	O
jmp	array
)	O
)	O
{	O
rw_mach_destroy	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
mach	struct
.	O
req	pointer
=	O
request	pointer
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
2	int
)	O
)	O
{	O
fp	pointer
=	O
debug_open_file	function
(	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"Before rewriting:\n"	pointer
)	O
;	O
grad_avl_fprint	function
(	O
fp	pointer
,	O
pair_print_prefix	array
,	O
1	int
,	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
pushn	function
(	O
0	int
)	O
;	O
run	function
(	O
pc	int
)	O
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
2	int
)	O
)	O
{	O
fp	pointer
=	O
debug_open_file	function
(	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"After rewriting\n"	pointer
)	O
;	O
grad_avl_fprint	function
(	O
fp	pointer
,	O
pair_print_prefix	array
,	O
1	int
,	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
rw_mach_destroy	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
return_value	function
(	O
grad_value_t	struct
*	O
val	array
)	O
{	O
u_char	char
*	O
p	pointer
;	O
switch	O
(	O
val	array
->	O
type	int
)	O
{	O
case	O
Integer	int
:	O
val	array
->	O
datum	union
.	O
ival	int
=	O
mach	struct
.	O
rA	O
;	O
break	O
;	O
case	O
String	int
:	O
mem2string	function
(	O
&	O
val	array
->	O
datum	union
.	O
sval	struct
,	O
(	O
RWSTYPE	long
*	O
)	O
mach	struct
.	O
rA	O
)	O
;	O
p	pointer
=	O
grad_emalloc	function
(	O
val	array
->	O
datum	union
.	O
sval	struct
.	O
size	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
val	array
->	O
datum	union
.	O
sval	struct
.	O
data	pointer
,	O
val	array
->	O
datum	union
.	O
sval	struct
.	O
size	int
)	O
;	O
p	pointer
[	O
val	array
->	O
datum	union
.	O
sval	struct
.	O
size	int
]	O
=	O
0	int
;	O
val	array
->	O
datum	union
.	O
sval	struct
.	O
data	pointer
=	O
p	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
int	O
evaluate	function
(	O
pctr_t	int
pc	int
,	O
grad_request_t	struct
*	O
req	pointer
,	O
grad_value_t	struct
*	O
val	array
)	O
{	O
if	O
(	O
run_init	function
(	O
pc	int
,	O
req	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
val	array
)	O
return_value	function
(	O
val	array
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rewrite_invoke	function
(	O
grad_data_type_t	enum
rettype	enum
,	O
grad_value_t	struct
*	O
val	array
,	O
const	O
char	O
*	O
name	pointer
,	O
grad_request_t	struct
*	O
request	pointer
,	O
char	O
*	O
typestr	pointer
,	O
...	O
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
va_list	array
ap	array
;	O
FUNCTION	struct
*	O
fun	pointer
;	O
int	O
nargs	int
;	O
char	O
*	O
s	pointer
;	O
fun	pointer
=	O
rewrite_check_function	function
(	O
name	pointer
,	O
rettype	enum
,	O
typestr	pointer
)	O
;	O
if	O
(	O
!	O
fun	pointer
)	O
return	O
-	O
1	int
;	O
rw_mach_init	function
(	O
)	O
;	O
if	O
(	O
setjmp	function
(	O
mach	struct
.	O
jmp	array
)	O
)	O
{	O
rw_mach_destroy	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
mach	struct
.	O
req	pointer
=	O
request	pointer
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
2	int
)	O
)	O
{	O
fp	pointer
=	O
debug_open_file	function
(	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"Before rewriting:\n"	pointer
)	O
;	O
grad_avl_fprint	function
(	O
fp	pointer
,	O
pair_print_prefix	array
,	O
1	int
,	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
nargs	int
=	O
0	int
;	O
va_start	O
(	O
ap	array
,	O
typestr	pointer
)	O
;	O
while	O
(	O
*	O
typestr	pointer
)	O
{	O
nargs	int
++	O
;	O
switch	O
(	O
*	O
typestr	pointer
++	O
)	O
{	O
case	O
'i'	O
:	O
pushn	function
(	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
s	pointer
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
;	O
pushstr	function
(	O
s	pointer
,	O
strlen	function
(	O
s	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"bad datatype"	pointer
)	O
;	O
}	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
pushn	function
(	O
0	int
)	O
;	O
run	function
(	O
fun	pointer
->	O
entry	int
)	O
;	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
2	int
)	O
)	O
{	O
fp	pointer
=	O
debug_open_file	function
(	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"After rewriting\n"	pointer
)	O
;	O
grad_avl_fprint	function
(	O
fp	pointer
,	O
pair_print_prefix	array
,	O
1	int
,	O
AVPLIST	O
(	O
&	O
mach	struct
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
val	array
->	O
type	int
=	O
fun	pointer
->	O
rettype	enum
;	O
return_value	function
(	O
val	array
)	O
;	O
rw_mach_destroy	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
rewrite_compile	function
(	O
char	O
*	O
expr	pointer
)	O
{	O
int	O
rc	int
;	O
FUNCTION	struct
*	O
fun	pointer
;	O
char	O
*	O
name	pointer
=	O
grad_emalloc	function
(	O
strlen	function
(	O
expr	pointer
)	O
+	O
3	int
)	O
;	O
sprintf	function
(	O
name	pointer
,	O
"$%s$"	pointer
,	O
expr	pointer
)	O
;	O
fun	pointer
=	O
(	O
FUNCTION	struct
*	O
)	O
grad_sym_lookup	function
(	O
rewrite_tab	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
fun	pointer
)	O
{	O
rc	int
=	O
parse_rewrite_string	function
(	O
expr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
grad_free	function
(	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
function	pointer
->	O
name	pointer
=	O
name	pointer
;	O
function_install	function
(	O
function	pointer
)	O
;	O
}	O
return	O
name	pointer
;	O
}	O
int	O
rewrite_interpret	function
(	O
char	O
*	O
expr	pointer
,	O
grad_request_t	struct
*	O
req	pointer
,	O
grad_value_t	struct
*	O
val	array
)	O
{	O
pctr_t	int
save_pc	int
=	O
rw_pc	int
;	O
int	O
rc	int
;	O
rc	int
=	O
parse_rewrite_string	function
(	O
expr	pointer
)	O
;	O
rw_pc	int
=	O
save_pc	int
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
val	array
->	O
type	int
=	O
return_type	enum
;	O
if	O
(	O
return_type	enum
==	O
Undefined	int
)	O
return	O
-	O
1	int
;	O
return	O
evaluate	function
(	O
rw_pc	int
,	O
req	pointer
,	O
val	array
)	O
;	O
}	O
int	O
rewrite_eval	function
(	O
char	O
*	O
symname	pointer
,	O
grad_request_t	struct
*	O
req	pointer
,	O
grad_value_t	struct
*	O
val	array
)	O
{	O
FUNCTION	struct
*	O
fun	pointer
;	O
fun	pointer
=	O
(	O
FUNCTION	struct
*	O
)	O
grad_sym_lookup	function
(	O
rewrite_tab	pointer
,	O
symname	pointer
)	O
;	O
if	O
(	O
!	O
fun	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fun	pointer
->	O
nparm	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
ngettext	function
(	O
"function %s() requires %d parameter"	pointer
,	O
"function %s() requires %d parameters"	pointer
,	O
fun	pointer
->	O
nparm	int
)	O
,	O
fun	pointer
->	O
name	pointer
,	O
fun	pointer
->	O
nparm	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
val	array
)	O
val	array
->	O
type	int
=	O
fun	pointer
->	O
rettype	enum
;	O
return	O
evaluate	function
(	O
fun	pointer
->	O
entry	int
,	O
req	pointer
,	O
val	array
)	O
;	O
}	O
static	O
grad_list_t	struct
*	O
source_list	pointer
;	O
static	O
grad_list_t	struct
*	O
rewrite_load_path	pointer
;	O
static	O
void	O
rewrite_add_load_path	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
!	O
rewrite_load_path	pointer
)	O
rewrite_load_path	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_append	function
(	O
rewrite_load_path	pointer
,	O
grad_estrdup	function
(	O
str	pointer
)	O
)	O
;	O
}	O
void	O
register_source_name	function
(	O
char	O
*	O
path	pointer
)	O
{	O
if	O
(	O
!	O
source_list	pointer
)	O
source_list	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_append	function
(	O
source_list	pointer
,	O
path	pointer
)	O
;	O
}	O
struct	O
load_data	struct
{	O
int	O
rc	int
;	O
char	O
*	O
name	pointer
;	O
}	O
;	O
static	O
int	O
try_load	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
load_data	struct
*	O
lp	pointer
=	O
data	pointer
;	O
char	O
*	O
path	pointer
=	O
grad_mkfilename	function
(	O
(	O
char	O
*	O
)	O
item	pointer
,	O
lp	pointer
->	O
name	pointer
)	O
;	O
lp	pointer
->	O
rc	int
=	O
parse_rewrite	function
(	O
path	pointer
)	O
;	O
if	O
(	O
lp	pointer
->	O
rc	int
>=	O
0	int
)	O
{	O
register_source_name	function
(	O
path	pointer
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
grad_free	function
(	O
path	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
rewrite_load_module	function
(	O
char	O
*	O
name	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
register_source_name	function
(	O
grad_estrdup	function
(	O
name	pointer
)	O
)	O
;	O
rc	int
=	O
parse_rewrite	function
(	O
name	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
load_data	struct
ld	struct
;	O
ld	struct
.	O
rc	int
=	O
1	int
;	O
ld	struct
.	O
name	pointer
=	O
name	pointer
;	O
grad_list_iterate	function
(	O
rewrite_load_path	pointer
,	O
try_load	function
,	O
&	O
ld	struct
)	O
;	O
rc	int
=	O
ld	struct
.	O
rc	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
free_path	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
ARG_UNUSED	O
)	O
{	O
grad_free	function
(	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
grad_list_t	struct
*	O
source_candidate_list	pointer
;	O
int	O
rewrite_stmt_term	function
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
!	O
finish	int
)	O
{	O
grad_symtab_clear	function
(	O
rewrite_tab	pointer
)	O
;	O
rw_yydebug	int
=	O
GRAD_DEBUG_LEVEL	O
(	O
50	int
)	O
;	O
grad_list_destroy	function
(	O
&	O
source_list	pointer
,	O
free_path	function
,	O
NULL	O
)	O
;	O
grad_list_destroy	function
(	O
&	O
rewrite_load_path	pointer
,	O
free_path	function
,	O
NULL	O
)	O
;	O
rewrite_add_load_path	function
(	O
grad_config_dir	pointer
)	O
;	O
rewrite_add_load_path	function
(	O
RADIUS_DATADIR	O
"/rewrite"	pointer
)	O
;	O
grad_free	function
(	O
runtime_stack	pointer
)	O
;	O
runtime_stack	pointer
=	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
rewrite_cfg_add_load_path	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
rewrite_add_load_path	function
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
rewrite_cfg_load	function
(	O
int	O
argc	int
,	O
cfg_value_t	struct
*	O
argv	pointer
,	O
void	O
*	O
block_data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	function
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
grad_list_append	function
(	O
source_candidate_list	pointer
,	O
grad_estrdup	function
(	O
argv	pointer
[	O
1	int
]	O
.	O
v	union
.	O
string	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
rewrite_before_config_hook	function
(	O
void	O
*	O
a	pointer
ARG_UNUSED	O
,	O
void	O
*	O
b	pointer
ARG_UNUSED	O
)	O
{	O
grad_list_destroy	function
(	O
&	O
source_candidate_list	pointer
,	O
free_path	function
,	O
NULL	O
)	O
;	O
source_candidate_list	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
code_init	function
(	O
)	O
;	O
}	O
static	O
int	O
_load_module	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
ARG_UNUSED	O
)	O
{	O
if	O
(	O
rewrite_load_module	function
(	O
item	pointer
)	O
==	O
-	O
2	int
)	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"file not found: %s"	pointer
)	O
,	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
rewrite_load_all	function
(	O
void	O
*	O
a	pointer
ARG_UNUSED	O
,	O
void	O
*	O
b	pointer
ARG_UNUSED	O
)	O
{	O
if	O
(	O
!	O
source_candidate_list	pointer
)	O
return	O
;	O
if	O
(	O
grad_list_count	function
(	O
source_candidate_list	pointer
)	O
==	O
0	int
)	O
rewrite_load_module	function
(	O
"rewrite"	pointer
)	O
;	O
grad_list_iterate	function
(	O
source_candidate_list	pointer
,	O
_load_module	function
,	O
NULL	O
)	O
;	O
}	O
void	O
rewrite_init	function
(	O
)	O
{	O
rewrite_tab	pointer
=	O
grad_symtab_create	function
(	O
sizeof	O
(	O
FUNCTION	struct
)	O
,	O
function_free	function
)	O
;	O
radiusd_set_preconfig_hook	function
(	O
rewrite_before_config_hook	function
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
struct	O
cfg_stmt	struct
rewrite_stmt	array
[	O
]	O
=	O
{	O
{	O
"stack-size"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_number	function
,	O
&	O
rewrite_stack_size	long
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"load-path"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
rewrite_cfg_add_load_path	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"load"	pointer
,	O
CS_STMT	int
,	O
NULL	O
,	O
rewrite_cfg_load	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
size_t	long
rewrite_get_stack_size	function
(	O
)	O
{	O
return	O
rewrite_stack_size	long
;	O
}	O
void	O
rewrite_set_stack_size	function
(	O
size_t	long
s	pointer
)	O
{	O
if	O
(	O
s	pointer
==	O
rewrite_stack_size	long
)	O
return	O
;	O
rewrite_stack_size	long
=	O
s	pointer
;	O
grad_free	function
(	O
runtime_stack	pointer
)	O
;	O
runtime_stack	pointer
=	O
NULL	O
;	O
}	O
void	O
grad_value_free	function
(	O
grad_value_t	struct
*	O
val	array
)	O
{	O
if	O
(	O
val	array
->	O
type	int
==	O
String	int
)	O
grad_free	function
(	O
val	array
->	O
datum	union
.	O
sval	struct
.	O
data	pointer
)	O
;	O
}	O
