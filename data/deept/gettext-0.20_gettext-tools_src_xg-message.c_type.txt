static	O
void	O
set_format_flags_from_context	function
(	O
enum	O
is_format	enum
is_format	enum
[	O
NFORMATS	int
]	O
,	O
flag_context_ty	struct
context	struct
,	O
const	O
char	O
*	O
string	pointer
,	O
lex_pos_ty	struct
*	O
pos	struct
,	O
const	O
char	O
*	O
pretty_msgstr	pointer
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
context	struct
.	O
is_format1	int
!=	O
undecided	int
||	O
context	struct
.	O
is_format2	int
!=	O
undecided	int
||	O
context	struct
.	O
is_format3	int
!=	O
undecided	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
is_format	enum
[	O
i	long
]	O
==	O
undecided	int
)	O
{	O
if	O
(	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser1	pointer
&&	O
context	struct
.	O
is_format1	int
!=	O
undecided	int
)	O
is_format	enum
[	O
i	long
]	O
=	O
(	O
enum	O
is_format	enum
)	O
context	struct
.	O
is_format1	int
;	O
if	O
(	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser2	pointer
&&	O
context	struct
.	O
is_format2	int
!=	O
undecided	int
)	O
is_format	enum
[	O
i	long
]	O
=	O
(	O
enum	O
is_format	enum
)	O
context	struct
.	O
is_format2	int
;	O
if	O
(	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser3	pointer
&&	O
context	struct
.	O
is_format3	int
!=	O
undecided	int
)	O
is_format	enum
[	O
i	long
]	O
=	O
(	O
enum	O
is_format	enum
)	O
context	struct
.	O
is_format3	int
;	O
}	O
if	O
(	O
possible_format_p	function
(	O
is_format	enum
[	O
i	long
]	O
)	O
)	O
{	O
struct	O
formatstring_parser	struct
*	O
parser	pointer
=	O
formatstring_parsers	array
[	O
i	long
]	O
;	O
char	O
*	O
invalid_reason	pointer
=	O
NULL	O
;	O
void	O
*	O
descr	pointer
=	O
parser	pointer
->	O
parse	pointer
(	O
string	pointer
,	O
false	int
,	O
NULL	O
,	O
&	O
invalid_reason	pointer
)	O
;	O
if	O
(	O
descr	pointer
!=	O
NULL	O
)	O
parser	pointer
->	O
free	function
(	O
descr	pointer
)	O
;	O
else	O
{	O
if	O
(	O
is_format	enum
[	O
i	long
]	O
!=	O
possible	int
)	O
{	O
char	O
buffer	array
[	O
21	int
]	O
;	O
error_with_progname	bool
=	O
false	int
;	O
if	O
(	O
pos	struct
->	O
line_number	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
buffer	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
sprintf	function
(	O
buffer	array
,	O
":%ld"	pointer
,	O
(	O
long	O
)	O
pos	struct
->	O
line_number	long
)	O
;	O
multiline_warning	function
(	O
xasprintf	function
(	O
_	O
(	O
"%s%s: warning: "	pointer
)	O
,	O
pos	struct
->	O
file_name	pointer
,	O
buffer	array
)	O
,	O
xasprintf	function
(	O
is_format	enum
[	O
i	long
]	O
==	O
yes_according_to_context	int
?	O
_	O
(	O
"Although being used in a format string position, the %s is not a valid %s format string. Reason: %s\n"	pointer
)	O
:	O
_	O
(	O
"Although declared as such, the %s is not a valid %s format string. Reason: %s\n"	pointer
)	O
,	O
pretty_msgstr	pointer
,	O
format_language_pretty	array
[	O
i	long
]	O
,	O
invalid_reason	pointer
)	O
)	O
;	O
error_with_progname	bool
=	O
true	int
;	O
}	O
is_format	enum
[	O
i	long
]	O
=	O
impossible	int
;	O
free	function
(	O
invalid_reason	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
warn_format_string	function
(	O
enum	O
is_format	enum
is_format	enum
[	O
NFORMATS	int
]	O
,	O
const	O
char	O
*	O
string	pointer
,	O
lex_pos_ty	struct
*	O
pos	struct
,	O
const	O
char	O
*	O
pretty_msgstr	pointer
)	O
{	O
if	O
(	O
possible_format_p	function
(	O
is_format	enum
[	O
format_python	int
]	O
)	O
&&	O
get_python_format_unnamed_arg_count	function
(	O
string	pointer
)	O
>	O
1	int
)	O
{	O
char	O
buffer	array
[	O
21	int
]	O
;	O
error_with_progname	bool
=	O
false	int
;	O
if	O
(	O
pos	struct
->	O
line_number	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
buffer	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
sprintf	function
(	O
buffer	array
,	O
":%ld"	pointer
,	O
(	O
long	O
)	O
pos	struct
->	O
line_number	long
)	O
;	O
multiline_warning	function
(	O
xasprintf	function
(	O
_	O
(	O
"%s%s: warning: "	pointer
)	O
,	O
pos	struct
->	O
file_name	pointer
,	O
buffer	array
)	O
,	O
xasprintf	function
(	O
_	O
(	O
"'%s' format string with unnamed arguments cannot be properly localized:\nThe translator cannot reorder the arguments.\nPlease consider using a format string with named arguments,\nand a mapping instead of a tuple for the arguments.\n"	pointer
)	O
,	O
pretty_msgstr	pointer
)	O
)	O
;	O
error_with_progname	bool
=	O
true	int
;	O
}	O
}	O
message_ty	struct
*	O
remember_a_message	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
char	O
*	O
msgctxt	pointer
,	O
char	O
*	O
msgid	pointer
,	O
bool	bool
is_utf8	bool
,	O
flag_context_ty	struct
context	struct
,	O
lex_pos_ty	struct
*	O
pos	struct
,	O
const	O
char	O
*	O
extracted_comment	pointer
,	O
refcounted_string_list_ty	struct
*	O
comment	pointer
,	O
bool	bool
comment_is_utf8	bool
)	O
{	O
enum	O
is_format	enum
is_format	enum
[	O
NFORMATS	int
]	O
;	O
struct	O
argument_range	struct
range	struct
;	O
enum	O
is_wrap	O
do_wrap	enum
;	O
enum	O
is_syntax_check	O
do_syntax_check	array
[	O
NSYNTAXCHECKS	int
]	O
;	O
message_ty	struct
*	O
mp	pointer
;	O
char	O
*	O
msgstr	pointer
;	O
size_t	long
i	long
;	O
if	O
(	O
exclude	pointer
!=	O
NULL	O
&&	O
message_list_search	function
(	O
exclude	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
)	O
!=	O
NULL	O
)	O
{	O
xgettext_comment_reset	function
(	O
)	O
;	O
savable_comment_reset	function
(	O
)	O
;	O
if	O
(	O
msgctxt	pointer
!=	O
NULL	O
)	O
free	function
(	O
msgctxt	pointer
)	O
;	O
free	function
(	O
msgid	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
savable_comment_to_xgettext_comment	function
(	O
comment	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
is_format	enum
[	O
i	long
]	O
=	O
undecided	int
;	O
range	struct
.	O
min	int
=	O
-	O
1	int
;	O
range	struct
.	O
max	int
=	O
-	O
1	int
;	O
do_wrap	enum
=	O
undecided	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
do_syntax_check	array
[	O
i	long
]	O
=	O
undecided	int
;	O
if	O
(	O
!	O
is_utf8	bool
)	O
{	O
if	O
(	O
msgctxt	pointer
!=	O
NULL	O
)	O
CONVERT_STRING	O
(	O
msgctxt	pointer
,	O
lc_string	int
)	O
;	O
CONVERT_STRING	O
(	O
msgid	pointer
,	O
lc_string	int
)	O
;	O
}	O
if	O
(	O
msgctxt	pointer
==	O
NULL	O
&&	O
msgid	pointer
[	O
0	int
]	O
==	O
'\0'	O
&&	O
!	O
xgettext_omit_header	int
)	O
{	O
char	O
buffer	array
[	O
21	int
]	O
;	O
error_with_progname	bool
=	O
false	int
;	O
if	O
(	O
pos	struct
->	O
line_number	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
buffer	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
sprintf	function
(	O
buffer	array
,	O
":%ld"	pointer
,	O
(	O
long	O
)	O
pos	struct
->	O
line_number	long
)	O
;	O
multiline_warning	function
(	O
xasprintf	function
(	O
_	O
(	O
"%s%s: warning: "	pointer
)	O
,	O
pos	struct
->	O
file_name	pointer
,	O
buffer	array
)	O
,	O
xstrdup	function
(	O
_	O
(	O
"Empty msgid.  It is reserved by GNU gettext:\ngettext(\"\") returns the header entry with\nmeta information, not the empty string.\n"	pointer
)	O
)	O
)	O
;	O
error_with_progname	bool
=	O
true	int
;	O
}	O
mp	pointer
=	O
message_list_search	function
(	O
mlp	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
)	O
;	O
if	O
(	O
mp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
msgctxt	pointer
!=	O
NULL	O
)	O
free	function
(	O
msgctxt	pointer
)	O
;	O
free	function
(	O
msgid	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
is_format	enum
[	O
i	long
]	O
=	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
;	O
do_wrap	enum
=	O
mp	pointer
->	O
do_wrap	enum
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
do_syntax_check	array
[	O
i	long
]	O
=	O
mp	pointer
->	O
do_syntax_check	array
[	O
i	long
]	O
;	O
}	O
else	O
{	O
if	O
(	O
msgstr_prefix	pointer
)	O
msgstr	pointer
=	O
xasprintf	function
(	O
"%s%s%s"	pointer
,	O
msgstr_prefix	pointer
,	O
msgid	pointer
,	O
msgstr_suffix	pointer
)	O
;	O
else	O
msgstr	pointer
=	O
""	pointer
;	O
mp	pointer
=	O
message_alloc	function
(	O
msgctxt	pointer
,	O
msgid	pointer
,	O
NULL	O
,	O
msgstr	pointer
,	O
strlen	function
(	O
msgstr	pointer
)	O
+	O
1	int
,	O
pos	struct
)	O
;	O
message_list_append	function
(	O
mlp	pointer
,	O
mp	pointer
)	O
;	O
}	O
set_format_flags_from_context	function
(	O
is_format	enum
,	O
context	struct
,	O
mp	pointer
->	O
msgid	pointer
,	O
pos	struct
,	O
"msgid"	pointer
)	O
;	O
{	O
size_t	long
nitems_before	long
;	O
size_t	long
nitems_after	long
;	O
int	O
j	long
;	O
bool	bool
add_all_remaining_comments	bool
;	O
const	O
char	O
*	O
comment_tag_prefix	pointer
=	O
""	pointer
;	O
size_t	long
comment_tag_prefix_length	long
=	O
0	int
;	O
nitems_before	long
=	O
(	O
mp	pointer
->	O
comment_dot	pointer
!=	O
NULL	O
?	O
mp	pointer
->	O
comment_dot	pointer
->	O
nitems	long
:	O
0	int
)	O
;	O
if	O
(	O
extracted_comment	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
copy	pointer
=	O
xstrdup	function
(	O
extracted_comment	pointer
)	O
;	O
char	O
*	O
rest	pointer
;	O
rest	pointer
=	O
copy	pointer
;	O
while	O
(	O
*	O
rest	pointer
!=	O
'\0'	O
)	O
{	O
char	O
*	O
newline	pointer
=	O
strchr	function
(	O
rest	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
newline	pointer
!=	O
NULL	O
)	O
{	O
*	O
newline	pointer
=	O
'\0'	O
;	O
message_comment_dot_append	function
(	O
mp	pointer
,	O
rest	pointer
)	O
;	O
rest	pointer
=	O
newline	pointer
+	O
1	int
;	O
}	O
else	O
{	O
message_comment_dot_append	function
(	O
mp	pointer
,	O
rest	pointer
)	O
;	O
break	O
;	O
}	O
}	O
free	function
(	O
copy	pointer
)	O
;	O
}	O
add_all_remaining_comments	bool
=	O
add_all_comments	bool
;	O
for	O
(	O
j	long
=	O
0	int
;	O
;	O
++	O
j	long
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
xgettext_comment	function
(	O
j	long
)	O
;	O
const	O
char	O
*	O
t	pointer
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
!	O
comment_is_utf8	bool
)	O
CONVERT_STRING	O
(	O
s	pointer
,	O
lc_comment	int
)	O
;	O
if	O
(	O
(	O
t	pointer
=	O
c_strstr	function
(	O
s	pointer
,	O
"xgettext:"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
bool	bool
tmp_fuzzy	bool
;	O
enum	O
is_format	enum
tmp_format	array
[	O
NFORMATS	int
]	O
;	O
struct	O
argument_range	struct
tmp_range	struct
;	O
enum	O
is_wrap	O
tmp_wrap	enum
;	O
enum	O
is_syntax_check	O
tmp_syntax_check	array
[	O
NSYNTAXCHECKS	int
]	O
;	O
bool	bool
interesting	bool
;	O
t	pointer
+=	O
strlen	function
(	O
"xgettext:"	pointer
)	O
;	O
po_parse_comment_special	function
(	O
t	pointer
,	O
&	O
tmp_fuzzy	bool
,	O
tmp_format	array
,	O
&	O
tmp_range	struct
,	O
&	O
tmp_wrap	enum
,	O
tmp_syntax_check	array
)	O
;	O
interesting	bool
=	O
false	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
if	O
(	O
tmp_format	array
[	O
i	long
]	O
!=	O
undecided	int
)	O
{	O
is_format	enum
[	O
i	long
]	O
=	O
tmp_format	array
[	O
i	long
]	O
;	O
interesting	bool
=	O
true	int
;	O
}	O
if	O
(	O
has_range_p	O
(	O
tmp_range	struct
)	O
)	O
{	O
range	struct
=	O
tmp_range	struct
;	O
interesting	bool
=	O
true	int
;	O
}	O
if	O
(	O
tmp_wrap	enum
!=	O
undecided	int
)	O
{	O
do_wrap	enum
=	O
tmp_wrap	enum
;	O
interesting	bool
=	O
true	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
if	O
(	O
tmp_syntax_check	array
[	O
i	long
]	O
!=	O
undecided	int
)	O
{	O
do_syntax_check	array
[	O
i	long
]	O
=	O
tmp_syntax_check	array
[	O
i	long
]	O
;	O
interesting	bool
=	O
true	int
;	O
}	O
if	O
(	O
interesting	bool
)	O
continue	O
;	O
}	O
if	O
(	O
!	O
add_all_remaining_comments	bool
&&	O
comment_tag	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t	pointer
=	O
c_strstr	function
(	O
s	pointer
,	O
comment_tag	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
add_all_remaining_comments	bool
=	O
true	int
;	O
comment_tag_prefix	pointer
=	O
s	pointer
;	O
comment_tag_prefix_length	long
=	O
t	pointer
-	O
s	pointer
;	O
}	O
}	O
if	O
(	O
add_all_remaining_comments	bool
)	O
{	O
if	O
(	O
strncmp	function
(	O
s	pointer
,	O
comment_tag_prefix	pointer
,	O
comment_tag_prefix_length	long
)	O
==	O
0	int
)	O
s	pointer
+=	O
comment_tag_prefix_length	long
;	O
message_comment_dot_append	function
(	O
mp	pointer
,	O
s	pointer
)	O
;	O
}	O
}	O
nitems_after	long
=	O
(	O
mp	pointer
->	O
comment_dot	pointer
!=	O
NULL	O
?	O
mp	pointer
->	O
comment_dot	pointer
->	O
nitems	long
:	O
0	int
)	O
;	O
if	O
(	O
nitems_before	long
<	O
nitems_after	long
)	O
{	O
size_t	long
added	long
=	O
nitems_after	long
-	O
nitems_before	long
;	O
if	O
(	O
added	long
<=	O
nitems_before	long
)	O
{	O
bool	bool
repeated	bool
=	O
true	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
added	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
mp	pointer
->	O
comment_dot	pointer
->	O
item	pointer
[	O
nitems_before	long
-	O
added	long
+	O
i	long
]	O
,	O
mp	pointer
->	O
comment_dot	pointer
->	O
item	pointer
[	O
nitems_before	long
+	O
i	long
]	O
)	O
!=	O
0	int
)	O
{	O
repeated	bool
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
repeated	bool
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
added	long
;	O
i	long
++	O
)	O
free	function
(	O
(	O
char	O
*	O
)	O
mp	pointer
->	O
comment_dot	pointer
->	O
item	pointer
[	O
nitems_before	long
+	O
i	long
]	O
)	O
;	O
mp	pointer
->	O
comment_dot	pointer
->	O
nitems	long
=	O
nitems_before	long
;	O
}	O
}	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
is_format	enum
[	O
i	long
]	O
==	O
undecided	int
&&	O
(	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser1	pointer
||	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser2	pointer
||	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser3	pointer
)	O
&&	O
!	O
(	O
i	long
==	O
format_c	int
&&	O
possible_format_p	function
(	O
is_format	enum
[	O
format_objc	int
]	O
)	O
)	O
&&	O
!	O
(	O
i	long
==	O
format_objc	int
&&	O
possible_format_p	function
(	O
is_format	enum
[	O
format_c	int
]	O
)	O
)	O
&&	O
!	O
(	O
i	long
==	O
format_c	int
&&	O
(	O
possible_format_p	function
(	O
is_format	enum
[	O
format_qt	int
]	O
)	O
||	O
possible_format_p	function
(	O
is_format	enum
[	O
format_qt_plural	int
]	O
)	O
||	O
possible_format_p	function
(	O
is_format	enum
[	O
format_kde	int
]	O
)	O
||	O
possible_format_p	function
(	O
is_format	enum
[	O
format_kde_kuit	int
]	O
)	O
||	O
possible_format_p	function
(	O
is_format	enum
[	O
format_boost	int
]	O
)	O
)	O
)	O
&&	O
!	O
(	O
i	long
==	O
format_kde	int
&&	O
possible_format_p	function
(	O
is_format	enum
[	O
format_kde_kuit	int
]	O
)	O
)	O
&&	O
!	O
(	O
i	long
==	O
format_kde_kuit	int
&&	O
possible_format_p	function
(	O
is_format	enum
[	O
format_kde	int
]	O
)	O
)	O
)	O
{	O
struct	O
formatstring_parser	struct
*	O
parser	pointer
=	O
formatstring_parsers	array
[	O
i	long
]	O
;	O
char	O
*	O
invalid_reason	pointer
=	O
NULL	O
;	O
void	O
*	O
descr	pointer
=	O
parser	pointer
->	O
parse	pointer
(	O
mp	pointer
->	O
msgid	pointer
,	O
false	int
,	O
NULL	O
,	O
&	O
invalid_reason	pointer
)	O
;	O
if	O
(	O
descr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
parser	pointer
->	O
get_number_of_directives	pointer
(	O
descr	pointer
)	O
>	O
0	int
&&	O
!	O
(	O
parser	pointer
->	O
is_unlikely_intentional	pointer
!=	O
NULL	O
&&	O
parser	pointer
->	O
is_unlikely_intentional	pointer
(	O
descr	pointer
)	O
)	O
)	O
is_format	enum
[	O
i	long
]	O
=	O
possible	int
;	O
parser	pointer
->	O
free	function
(	O
descr	pointer
)	O
;	O
}	O
else	O
{	O
is_format	enum
[	O
i	long
]	O
=	O
impossible	int
;	O
free	function
(	O
invalid_reason	pointer
)	O
;	O
}	O
}	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
=	O
is_format	enum
[	O
i	long
]	O
;	O
}	O
if	O
(	O
has_range_p	O
(	O
range	struct
)	O
)	O
{	O
if	O
(	O
has_range_p	O
(	O
mp	pointer
->	O
range	struct
)	O
)	O
{	O
if	O
(	O
range	struct
.	O
min	int
<	O
mp	pointer
->	O
range	struct
.	O
min	int
)	O
mp	pointer
->	O
range	struct
.	O
min	int
=	O
range	struct
.	O
min	int
;	O
if	O
(	O
range	struct
.	O
max	int
>	O
mp	pointer
->	O
range	struct
.	O
max	int
)	O
mp	pointer
->	O
range	struct
.	O
max	int
=	O
range	struct
.	O
max	int
;	O
}	O
else	O
mp	pointer
->	O
range	struct
=	O
range	struct
;	O
}	O
mp	pointer
->	O
do_wrap	enum
=	O
do_wrap	enum
==	O
no	int
?	O
no	int
:	O
yes	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
do_syntax_check	array
[	O
i	long
]	O
==	O
undecided	int
)	O
do_syntax_check	array
[	O
i	long
]	O
=	O
default_syntax_check	array
[	O
i	long
]	O
==	O
yes	int
?	O
yes	int
:	O
no	int
;	O
mp	pointer
->	O
do_syntax_check	array
[	O
i	long
]	O
=	O
do_syntax_check	array
[	O
i	long
]	O
;	O
}	O
warn_format_string	function
(	O
is_format	enum
,	O
mp	pointer
->	O
msgid	pointer
,	O
pos	struct
,	O
"msgid"	pointer
)	O
;	O
message_comment_filepos	function
(	O
mp	pointer
,	O
pos	struct
->	O
file_name	pointer
,	O
pos	struct
->	O
line_number	long
)	O
;	O
xgettext_comment_reset	function
(	O
)	O
;	O
savable_comment_reset	function
(	O
)	O
;	O
return	O
mp	pointer
;	O
}	O
void	O
remember_a_message_plural	function
(	O
message_ty	struct
*	O
mp	pointer
,	O
char	O
*	O
string	pointer
,	O
bool	bool
is_utf8	bool
,	O
flag_context_ty	struct
context	struct
,	O
lex_pos_ty	struct
*	O
pos	struct
,	O
refcounted_string_list_ty	struct
*	O
comment	pointer
,	O
bool	bool
comment_is_utf8	bool
)	O
{	O
char	O
*	O
msgid_plural	pointer
;	O
char	O
*	O
msgstr1	pointer
;	O
size_t	long
msgstr1_len	long
;	O
char	O
*	O
msgstr	pointer
;	O
size_t	long
i	long
;	O
msgid_plural	pointer
=	O
string	pointer
;	O
savable_comment_to_xgettext_comment	function
(	O
comment	pointer
)	O
;	O
if	O
(	O
!	O
is_utf8	bool
)	O
CONVERT_STRING	O
(	O
msgid_plural	pointer
,	O
lc_string	int
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
==	O
NULL	O
)	O
{	O
mp	pointer
->	O
msgid_plural	pointer
=	O
msgid_plural	pointer
;	O
if	O
(	O
msgstr_prefix	pointer
)	O
msgstr1	pointer
=	O
xasprintf	function
(	O
"%s%s%s"	pointer
,	O
msgstr_prefix	pointer
,	O
msgid_plural	pointer
,	O
msgstr_suffix	pointer
)	O
;	O
else	O
msgstr1	pointer
=	O
""	pointer
;	O
msgstr1_len	long
=	O
strlen	function
(	O
msgstr1	pointer
)	O
+	O
1	int
;	O
msgstr	pointer
=	O
XNMALLOC	O
(	O
mp	pointer
->	O
msgstr_len	long
+	O
msgstr1_len	long
,	O
char	O
)	O
;	O
memcpy	function
(	O
msgstr	pointer
,	O
mp	pointer
->	O
msgstr	pointer
,	O
mp	pointer
->	O
msgstr_len	long
)	O
;	O
memcpy	function
(	O
msgstr	pointer
+	O
mp	pointer
->	O
msgstr_len	long
,	O
msgstr1	pointer
,	O
msgstr1_len	long
)	O
;	O
mp	pointer
->	O
msgstr	pointer
=	O
msgstr	pointer
;	O
mp	pointer
->	O
msgstr_len	long
=	O
mp	pointer
->	O
msgstr_len	long
+	O
msgstr1_len	long
;	O
if	O
(	O
msgstr_prefix	pointer
)	O
free	function
(	O
msgstr1	pointer
)	O
;	O
set_format_flags_from_context	function
(	O
mp	pointer
->	O
is_format	enum
,	O
context	struct
,	O
mp	pointer
->	O
msgid_plural	pointer
,	O
pos	struct
,	O
"msgid_plural"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
if	O
(	O
(	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser1	pointer
||	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser2	pointer
||	O
formatstring_parsers	array
[	O
i	long
]	O
==	O
current_formatstring_parser3	pointer
)	O
&&	O
(	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
==	O
undecided	int
||	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
==	O
possible	int
)	O
&&	O
!	O
(	O
i	long
==	O
format_c	int
&&	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_objc	int
]	O
)	O
)	O
&&	O
!	O
(	O
i	long
==	O
format_objc	int
&&	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_c	int
]	O
)	O
)	O
&&	O
!	O
(	O
i	long
==	O
format_c	int
&&	O
(	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_qt	int
]	O
)	O
||	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_qt_plural	int
]	O
)	O
||	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_kde	int
]	O
)	O
||	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_kde_kuit	int
]	O
)	O
||	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_boost	int
]	O
)	O
)	O
)	O
&&	O
!	O
(	O
i	long
==	O
format_kde	int
&&	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_kde_kuit	int
]	O
)	O
)	O
&&	O
!	O
(	O
i	long
==	O
format_kde_kuit	int
&&	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_kde	int
]	O
)	O
)	O
)	O
{	O
struct	O
formatstring_parser	struct
*	O
parser	pointer
=	O
formatstring_parsers	array
[	O
i	long
]	O
;	O
char	O
*	O
invalid_reason	pointer
=	O
NULL	O
;	O
void	O
*	O
descr	pointer
=	O
parser	pointer
->	O
parse	pointer
(	O
mp	pointer
->	O
msgid_plural	pointer
,	O
false	int
,	O
NULL	O
,	O
&	O
invalid_reason	pointer
)	O
;	O
if	O
(	O
descr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
parser	pointer
->	O
get_number_of_directives	pointer
(	O
descr	pointer
)	O
>	O
0	int
&&	O
!	O
(	O
parser	pointer
->	O
is_unlikely_intentional	pointer
!=	O
NULL	O
&&	O
parser	pointer
->	O
is_unlikely_intentional	pointer
(	O
descr	pointer
)	O
)	O
)	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
=	O
possible	int
;	O
parser	pointer
->	O
free	function
(	O
descr	pointer
)	O
;	O
}	O
else	O
{	O
mp	pointer
->	O
is_format	enum
[	O
i	long
]	O
=	O
impossible	int
;	O
free	function
(	O
invalid_reason	pointer
)	O
;	O
}	O
}	O
warn_format_string	function
(	O
mp	pointer
->	O
is_format	enum
,	O
mp	pointer
->	O
msgid_plural	pointer
,	O
pos	struct
,	O
"msgid_plural"	pointer
)	O
;	O
}	O
else	O
free	function
(	O
msgid_plural	pointer
)	O
;	O
xgettext_comment_reset	function
(	O
)	O
;	O
savable_comment_reset	function
(	O
)	O
;	O
}	O
