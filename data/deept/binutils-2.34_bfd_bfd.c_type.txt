static	O
bfd_error_type	enum
bfd_error	enum
=	O
bfd_error_no_error	int
;	O
static	O
bfd	struct
*	O
input_bfd	pointer
=	O
NULL	O
;	O
static	O
bfd_error_type	enum
input_error	enum
=	O
bfd_error_no_error	int
;	O
const	O
char	O
*	O
const	O
bfd_errmsgs	array
[	O
]	O
=	O
{	O
N_	O
(	O
"no error"	pointer
)	O
,	O
N_	O
(	O
"system call error"	pointer
)	O
,	O
N_	O
(	O
"invalid bfd target"	pointer
)	O
,	O
N_	O
(	O
"file in wrong format"	pointer
)	O
,	O
N_	O
(	O
"archive object file in wrong format"	pointer
)	O
,	O
N_	O
(	O
"invalid operation"	pointer
)	O
,	O
N_	O
(	O
"memory exhausted"	pointer
)	O
,	O
N_	O
(	O
"no symbols"	pointer
)	O
,	O
N_	O
(	O
"archive has no index; run ranlib to add one"	pointer
)	O
,	O
N_	O
(	O
"no more archived files"	pointer
)	O
,	O
N_	O
(	O
"malformed archive"	pointer
)	O
,	O
N_	O
(	O
"DSO missing from command line"	pointer
)	O
,	O
N_	O
(	O
"file format not recognized"	pointer
)	O
,	O
N_	O
(	O
"file format is ambiguous"	pointer
)	O
,	O
N_	O
(	O
"section has no contents"	pointer
)	O
,	O
N_	O
(	O
"nonrepresentable section on output"	pointer
)	O
,	O
N_	O
(	O
"symbol needs debug section which does not exist"	pointer
)	O
,	O
N_	O
(	O
"bad value"	pointer
)	O
,	O
N_	O
(	O
"file truncated"	pointer
)	O
,	O
N_	O
(	O
"file too big"	pointer
)	O
,	O
N_	O
(	O
"sorry, cannot handle this file"	pointer
)	O
,	O
N_	O
(	O
"error reading %s: %s"	pointer
)	O
,	O
N_	O
(	O
"#<invalid error code>"	pointer
)	O
}	O
;	O
bfd_error_type	enum
bfd_get_error	function
(	O
void	O
)	O
{	O
return	O
bfd_error	enum
;	O
}	O
void	O
bfd_set_error	function
(	O
bfd_error_type	enum
error_tag	enum
)	O
{	O
bfd_error	enum
=	O
error_tag	enum
;	O
if	O
(	O
bfd_error	enum
>=	O
bfd_error_on_input	int
)	O
abort	function
(	O
)	O
;	O
}	O
void	O
bfd_set_input_error	function
(	O
bfd	struct
*	O
input	pointer
,	O
bfd_error_type	enum
error_tag	enum
)	O
{	O
bfd_error	enum
=	O
bfd_error_on_input	int
;	O
input_bfd	pointer
=	O
input	pointer
;	O
input_error	enum
=	O
error_tag	enum
;	O
if	O
(	O
input_error	enum
>=	O
bfd_error_on_input	int
)	O
abort	function
(	O
)	O
;	O
}	O
const	O
char	O
*	O
bfd_errmsg	function
(	O
bfd_error_type	enum
error_tag	enum
)	O
{	O
if	O
(	O
error_tag	enum
==	O
bfd_error_on_input	int
)	O
{	O
char	O
*	O
buf	pointer
;	O
const	O
char	O
*	O
msg	pointer
=	O
bfd_errmsg	function
(	O
input_error	enum
)	O
;	O
if	O
(	O
asprintf	function
(	O
&	O
buf	pointer
,	O
_	O
(	O
bfd_errmsgs	array
[	O
error_tag	enum
]	O
)	O
,	O
input_bfd	pointer
->	O
filename	pointer
,	O
msg	pointer
)	O
!=	O
-	O
1	int
)	O
return	O
buf	pointer
;	O
return	O
msg	pointer
;	O
}	O
if	O
(	O
error_tag	enum
==	O
bfd_error_system_call	int
)	O
return	O
xstrerror	function
(	O
errno	O
)	O
;	O
if	O
(	O
error_tag	enum
>	O
bfd_error_invalid_error_code	int
)	O
error_tag	enum
=	O
bfd_error_invalid_error_code	int
;	O
return	O
_	O
(	O
bfd_errmsgs	array
[	O
error_tag	enum
]	O
)	O
;	O
}	O
void	O
bfd_perror	function
(	O
const	O
char	O
*	O
message	pointer
)	O
{	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
message	pointer
==	O
NULL	O
||	O
*	O
message	pointer
==	O
'\0'	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
message	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
_bfd_error_program_name	pointer
;	O
union	O
_bfd_doprnt_args	union
{	O
int	O
i	pointer
;	O
long	O
l	long
;	O
long	O
long	O
ll	long long
;	O
double	O
d	double
;	O
long	O
double	O
ld	long double
;	O
void	O
*	O
p	pointer
;	O
enum	O
{	O
Bad	int
,	O
Int	int
,	O
Long	int
,	O
LongLong	int
,	O
Double	int
,	O
LongDouble	int
,	O
Ptr	int
}	O
type	enum
;	O
}	O
;	O
static	O
int	O
_bfd_doprnt	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
format	enum
,	O
union	O
_bfd_doprnt_args	union
*	O
args	int
)	O
{	O
const	O
char	O
*	O
ptr	pointer
=	O
format	enum
;	O
char	O
specifier	array
[	O
128	int
]	O
;	O
int	O
total_printed	int
=	O
0	int
;	O
unsigned	O
int	O
arg_count	int
=	O
0	int
;	O
while	O
(	O
*	O
ptr	pointer
!=	O
'\0'	O
)	O
{	O
int	O
result	int
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'%'	O
)	O
{	O
char	O
*	O
end	pointer
=	O
strchr	function
(	O
ptr	pointer
,	O
'%'	O
)	O
;	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
result	int
=	O
fprintf	function
(	O
stream	pointer
,	O
"%.*s"	pointer
,	O
(	O
int	O
)	O
(	O
end	pointer
-	O
ptr	pointer
)	O
,	O
ptr	pointer
)	O
;	O
else	O
result	int
=	O
fprintf	function
(	O
stream	pointer
,	O
"%s"	pointer
,	O
ptr	pointer
)	O
;	O
ptr	pointer
+=	O
result	int
;	O
}	O
else	O
if	O
(	O
ptr	pointer
[	O
1	int
]	O
==	O
'%'	O
)	O
{	O
fputc	function
(	O
'%'	O
,	O
stream	pointer
)	O
;	O
result	int
=	O
1	int
;	O
ptr	pointer
+=	O
2	int
;	O
}	O
else	O
{	O
char	O
*	O
sptr	pointer
=	O
specifier	array
;	O
int	O
wide_width	int
=	O
0	int
,	O
short_width	int
=	O
0	int
;	O
unsigned	O
int	O
arg_no	int
;	O
*	O
sptr	pointer
++	O
=	O
*	O
ptr	pointer
++	O
;	O
arg_no	int
=	O
-	O
1u	int
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'0'	O
&&	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
&&	O
ptr	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
arg_no	int
=	O
*	O
ptr	pointer
-	O
'1'	O
;	O
ptr	pointer
+=	O
2	int
;	O
}	O
while	O
(	O
strchr	function
(	O
"-+ #0'I"	pointer
,	O
*	O
ptr	pointer
)	O
)	O
*	O
sptr	pointer
++	O
=	O
*	O
ptr	pointer
++	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'*'	O
)	O
{	O
int	O
value	long
;	O
unsigned	O
int	O
arg_index	int
;	O
ptr	pointer
++	O
;	O
arg_index	int
=	O
arg_count	int
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'0'	O
&&	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
&&	O
ptr	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
arg_index	int
=	O
*	O
ptr	pointer
-	O
'1'	O
;	O
ptr	pointer
+=	O
2	int
;	O
}	O
value	long
=	O
abs	function
(	O
args	int
[	O
arg_index	int
]	O
.	O
i	pointer
)	O
;	O
arg_count	int
++	O
;	O
sptr	pointer
+=	O
sprintf	function
(	O
sptr	pointer
,	O
"%d"	pointer
,	O
value	long
)	O
;	O
}	O
else	O
while	O
(	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
)	O
*	O
sptr	pointer
++	O
=	O
*	O
ptr	pointer
++	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'.'	O
)	O
{	O
*	O
sptr	pointer
++	O
=	O
*	O
ptr	pointer
++	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'*'	O
)	O
{	O
int	O
value	long
;	O
unsigned	O
int	O
arg_index	int
;	O
ptr	pointer
++	O
;	O
arg_index	int
=	O
arg_count	int
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'0'	O
&&	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
&&	O
ptr	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
arg_index	int
=	O
*	O
ptr	pointer
-	O
'1'	O
;	O
ptr	pointer
+=	O
2	int
;	O
}	O
value	long
=	O
abs	function
(	O
args	int
[	O
arg_index	int
]	O
.	O
i	pointer
)	O
;	O
arg_count	int
++	O
;	O
sptr	pointer
+=	O
sprintf	function
(	O
sptr	pointer
,	O
"%d"	pointer
,	O
value	long
)	O
;	O
}	O
else	O
while	O
(	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
)	O
*	O
sptr	pointer
++	O
=	O
*	O
ptr	pointer
++	O
;	O
}	O
while	O
(	O
strchr	function
(	O
"hlL"	pointer
,	O
*	O
ptr	pointer
)	O
)	O
{	O
switch	O
(	O
*	O
ptr	pointer
)	O
{	O
case	O
'h'	O
:	O
short_width	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
wide_width	int
++	O
;	O
break	O
;	O
case	O
'L'	O
:	O
wide_width	int
=	O
2	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
*	O
sptr	pointer
++	O
=	O
*	O
ptr	pointer
++	O
;	O
}	O
*	O
sptr	pointer
++	O
=	O
*	O
ptr	pointer
++	O
;	O
*	O
sptr	pointer
=	O
'\0'	O
;	O
if	O
(	O
(	O
int	O
)	O
arg_no	int
<	O
0	int
)	O
arg_no	int
=	O
arg_count	int
;	O
switch	O
(	O
ptr	pointer
[	O
-	O
1	int
]	O
)	O
{	O
case	O
'd'	O
:	O
case	O
'i'	O
:	O
case	O
'o'	O
:	O
case	O
'u'	O
:	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
case	O
'c'	O
:	O
{	O
if	O
(	O
short_width	int
)	O
PRINT_TYPE	O
(	O
int	O
,	O
i	pointer
)	O
;	O
else	O
{	O
switch	O
(	O
wide_width	int
)	O
{	O
case	O
0	int
:	O
PRINT_TYPE	O
(	O
int	O
,	O
i	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
PRINT_TYPE	O
(	O
long	O
,	O
l	long
)	O
;	O
break	O
;	O
case	O
2	int
:	O
default	O
:	O
PRINT_TYPE	O
(	O
long	O
long	O
,	O
ll	long long
)	O
;	O
break	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
case	O
'g'	O
:	O
case	O
'G'	O
:	O
{	O
if	O
(	O
wide_width	int
==	O
0	int
)	O
PRINT_TYPE	O
(	O
double	O
,	O
d	double
)	O
;	O
else	O
{	O
PRINT_TYPE	O
(	O
long	O
double	O
,	O
ld	long double
)	O
;	O
}	O
}	O
break	O
;	O
case	O
's'	O
:	O
PRINT_TYPE	O
(	O
char	O
*	O
,	O
p	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
*	O
ptr	pointer
==	O
'A'	O
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
const	O
char	O
*	O
group	pointer
=	O
NULL	O
;	O
struct	O
coff_comdat_info	struct
*	O
ci	pointer
;	O
ptr	pointer
++	O
;	O
sec	pointer
=	O
(	O
asection	struct
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
abfd	pointer
=	O
sec	pointer
->	O
owner	pointer
;	O
if	O
(	O
abfd	pointer
!=	O
NULL	O
&&	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
elf_next_in_group	O
(	O
sec	pointer
)	O
!=	O
NULL	O
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_GROUP	int
)	O
==	O
0	int
)	O
group	pointer
=	O
elf_group_name	O
(	O
sec	pointer
)	O
;	O
else	O
if	O
(	O
abfd	pointer
!=	O
NULL	O
&&	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_coff_flavour	int
&&	O
(	O
ci	pointer
=	O
bfd_coff_get_comdat_section	O
(	O
sec	pointer
->	O
owner	pointer
,	O
sec	pointer
)	O
)	O
!=	O
NULL	O
)	O
group	pointer
=	O
ci	pointer
->	O
name	pointer
;	O
if	O
(	O
group	pointer
!=	O
NULL	O
)	O
result	int
=	O
fprintf	function
(	O
stream	pointer
,	O
"%s[%s]"	pointer
,	O
sec	pointer
->	O
name	pointer
,	O
group	pointer
)	O
;	O
else	O
result	int
=	O
fprintf	function
(	O
stream	pointer
,	O
"%s"	pointer
,	O
sec	pointer
->	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
ptr	pointer
==	O
'B'	O
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
ptr	pointer
++	O
;	O
abfd	pointer
=	O
(	O
bfd	struct
*	O
)	O
args	int
[	O
arg_no	int
]	O
.	O
p	pointer
;	O
if	O
(	O
abfd	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
else	O
if	O
(	O
abfd	pointer
->	O
my_archive	pointer
&&	O
!	O
bfd_is_thin_archive	function
(	O
abfd	pointer
->	O
my_archive	pointer
)	O
)	O
result	int
=	O
fprintf	function
(	O
stream	pointer
,	O
"%s(%s)"	pointer
,	O
abfd	pointer
->	O
my_archive	pointer
->	O
filename	pointer
,	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
else	O
result	int
=	O
fprintf	function
(	O
stream	pointer
,	O
"%s"	pointer
,	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
}	O
else	O
PRINT_TYPE	O
(	O
void	O
*	O
,	O
p	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
arg_count	int
++	O
;	O
}	O
if	O
(	O
result	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
total_printed	int
+=	O
result	int
;	O
}	O
return	O
total_printed	int
;	O
}	O
static	O
unsigned	O
int	O
_bfd_doprnt_scan	function
(	O
const	O
char	O
*	O
format	enum
,	O
union	O
_bfd_doprnt_args	union
*	O
args	int
)	O
{	O
const	O
char	O
*	O
ptr	pointer
=	O
format	enum
;	O
unsigned	O
int	O
arg_count	int
=	O
0	int
;	O
while	O
(	O
*	O
ptr	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
ptr	pointer
!=	O
'%'	O
)	O
{	O
ptr	pointer
=	O
strchr	function
(	O
ptr	pointer
,	O
'%'	O
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
ptr	pointer
[	O
1	int
]	O
==	O
'%'	O
)	O
ptr	pointer
+=	O
2	int
;	O
else	O
{	O
int	O
wide_width	int
=	O
0	int
,	O
short_width	int
=	O
0	int
;	O
unsigned	O
int	O
arg_no	int
;	O
int	O
arg_type	int
;	O
ptr	pointer
++	O
;	O
arg_no	int
=	O
-	O
1u	int
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'0'	O
&&	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
&&	O
ptr	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
arg_no	int
=	O
*	O
ptr	pointer
-	O
'1'	O
;	O
ptr	pointer
+=	O
2	int
;	O
}	O
while	O
(	O
strchr	function
(	O
"-+ #0'I"	pointer
,	O
*	O
ptr	pointer
)	O
)	O
ptr	pointer
++	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'*'	O
)	O
{	O
unsigned	O
int	O
arg_index	int
;	O
ptr	pointer
++	O
;	O
arg_index	int
=	O
arg_count	int
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'0'	O
&&	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
&&	O
ptr	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
arg_index	int
=	O
*	O
ptr	pointer
-	O
'1'	O
;	O
ptr	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
arg_index	int
>=	O
9	int
)	O
abort	function
(	O
)	O
;	O
args	int
[	O
arg_index	int
]	O
.	O
type	enum
=	O
Int	int
;	O
arg_count	int
++	O
;	O
}	O
else	O
while	O
(	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
)	O
ptr	pointer
++	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'.'	O
)	O
{	O
ptr	pointer
++	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'*'	O
)	O
{	O
unsigned	O
int	O
arg_index	int
;	O
ptr	pointer
++	O
;	O
arg_index	int
=	O
arg_count	int
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'0'	O
&&	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
&&	O
ptr	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
{	O
arg_index	int
=	O
*	O
ptr	pointer
-	O
'1'	O
;	O
ptr	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
arg_index	int
>=	O
9	int
)	O
abort	function
(	O
)	O
;	O
args	int
[	O
arg_index	int
]	O
.	O
type	enum
=	O
Int	int
;	O
arg_count	int
++	O
;	O
}	O
else	O
while	O
(	O
ISDIGIT	O
(	O
*	O
ptr	pointer
)	O
)	O
ptr	pointer
++	O
;	O
}	O
while	O
(	O
strchr	function
(	O
"hlL"	pointer
,	O
*	O
ptr	pointer
)	O
)	O
{	O
switch	O
(	O
*	O
ptr	pointer
)	O
{	O
case	O
'h'	O
:	O
short_width	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
wide_width	int
++	O
;	O
break	O
;	O
case	O
'L'	O
:	O
wide_width	int
=	O
2	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
ptr	pointer
++	O
;	O
}	O
ptr	pointer
++	O
;	O
if	O
(	O
(	O
int	O
)	O
arg_no	int
<	O
0	int
)	O
arg_no	int
=	O
arg_count	int
;	O
arg_type	int
=	O
Bad	int
;	O
switch	O
(	O
ptr	pointer
[	O
-	O
1	int
]	O
)	O
{	O
case	O
'd'	O
:	O
case	O
'i'	O
:	O
case	O
'o'	O
:	O
case	O
'u'	O
:	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
case	O
'c'	O
:	O
{	O
if	O
(	O
short_width	int
)	O
arg_type	int
=	O
Int	int
;	O
else	O
{	O
switch	O
(	O
wide_width	int
)	O
{	O
case	O
0	int
:	O
arg_type	int
=	O
Int	int
;	O
break	O
;	O
case	O
1	int
:	O
arg_type	int
=	O
Long	int
;	O
break	O
;	O
case	O
2	int
:	O
default	O
:	O
arg_type	int
=	O
LongLong	int
;	O
break	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
case	O
'g'	O
:	O
case	O
'G'	O
:	O
{	O
if	O
(	O
wide_width	int
==	O
0	int
)	O
arg_type	int
=	O
Double	int
;	O
else	O
{	O
arg_type	int
=	O
LongDouble	int
;	O
}	O
}	O
break	O
;	O
case	O
's'	O
:	O
arg_type	int
=	O
Ptr	int
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
*	O
ptr	pointer
==	O
'A'	O
||	O
*	O
ptr	pointer
==	O
'B'	O
)	O
ptr	pointer
++	O
;	O
arg_type	int
=	O
Ptr	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
arg_no	int
>=	O
9	int
)	O
abort	function
(	O
)	O
;	O
args	int
[	O
arg_no	int
]	O
.	O
type	enum
=	O
arg_type	int
;	O
arg_count	int
++	O
;	O
}	O
}	O
return	O
arg_count	int
;	O
}	O
static	O
void	O
error_handler_internal	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
unsigned	O
int	O
i	pointer
,	O
arg_count	int
;	O
union	O
_bfd_doprnt_args	union
args	int
[	O
9	int
]	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
sizeof	O
(	O
args	int
)	O
/	O
sizeof	O
(	O
args	int
[	O
0	int
]	O
)	O
;	O
i	pointer
++	O
)	O
args	int
[	O
i	pointer
]	O
.	O
type	enum
=	O
Bad	int
;	O
arg_count	int
=	O
_bfd_doprnt_scan	function
(	O
fmt	pointer
,	O
args	int
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
arg_count	int
;	O
i	pointer
++	O
)	O
{	O
switch	O
(	O
args	int
[	O
i	pointer
]	O
.	O
type	enum
)	O
{	O
case	O
Int	int
:	O
args	int
[	O
i	pointer
]	O
.	O
i	pointer
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
Long	int
:	O
args	int
[	O
i	pointer
]	O
.	O
l	long
=	O
va_arg	O
(	O
ap	array
,	O
long	O
)	O
;	O
break	O
;	O
case	O
LongLong	int
:	O
args	int
[	O
i	pointer
]	O
.	O
ll	long long
=	O
va_arg	O
(	O
ap	array
,	O
long	O
long	O
)	O
;	O
break	O
;	O
case	O
Double	int
:	O
args	int
[	O
i	pointer
]	O
.	O
d	double
=	O
va_arg	O
(	O
ap	array
,	O
double	O
)	O
;	O
break	O
;	O
case	O
LongDouble	int
:	O
args	int
[	O
i	pointer
]	O
.	O
ld	long double
=	O
va_arg	O
(	O
ap	array
,	O
long	O
double	O
)	O
;	O
break	O
;	O
case	O
Ptr	int
:	O
args	int
[	O
i	pointer
]	O
.	O
p	pointer
=	O
va_arg	O
(	O
ap	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
_bfd_error_program_name	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
_bfd_error_program_name	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"BFD: "	pointer
)	O
;	O
_bfd_doprnt	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
args	int
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
static	O
bfd_error_handler_type	pointer
_bfd_error_internal	pointer
=	O
error_handler_internal	function
;	O
void	O
_bfd_error_handler	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
_bfd_error_internal	pointer
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
bfd_error_handler_type	pointer
bfd_set_error_handler	function
(	O
bfd_error_handler_type	pointer
pnew	pointer
)	O
{	O
bfd_error_handler_type	pointer
pold	pointer
;	O
pold	pointer
=	O
_bfd_error_internal	pointer
;	O
_bfd_error_internal	pointer
=	O
pnew	pointer
;	O
return	O
pold	pointer
;	O
}	O
void	O
bfd_set_error_program_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
_bfd_error_program_name	pointer
=	O
name	pointer
;	O
}	O
static	O
void	O
_bfd_default_assert_handler	function
(	O
const	O
char	O
*	O
bfd_formatmsg	pointer
,	O
const	O
char	O
*	O
bfd_version	pointer
,	O
const	O
char	O
*	O
bfd_file	pointer
,	O
int	O
bfd_line	int
)	O
{	O
_bfd_error_handler	function
(	O
bfd_formatmsg	pointer
,	O
bfd_version	pointer
,	O
bfd_file	pointer
,	O
bfd_line	int
)	O
;	O
}	O
static	O
bfd_assert_handler_type	pointer
_bfd_assert_handler	pointer
=	O
_bfd_default_assert_handler	function
;	O
bfd_assert_handler_type	pointer
bfd_set_assert_handler	function
(	O
bfd_assert_handler_type	pointer
pnew	pointer
)	O
{	O
bfd_assert_handler_type	pointer
pold	pointer
;	O
pold	pointer
=	O
_bfd_assert_handler	pointer
;	O
_bfd_assert_handler	pointer
=	O
pnew	pointer
;	O
return	O
pold	pointer
;	O
}	O
long	O
bfd_get_reloc_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sec_ptr	pointer
asect	pointer
)	O
{	O
if	O
(	O
abfd	pointer
->	O
format	enum
!=	O
bfd_object	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
BFD_SEND	O
(	O
abfd	pointer
,	O
_get_reloc_upper_bound	pointer
,	O
(	O
abfd	pointer
,	O
asect	pointer
)	O
)	O
;	O
}	O
long	O
bfd_canonicalize_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sec_ptr	pointer
asect	pointer
,	O
arelent	struct
*	O
*	O
location	pointer
,	O
asymbol	struct
*	O
*	O
symbols	pointer
)	O
{	O
if	O
(	O
abfd	pointer
->	O
format	enum
!=	O
bfd_object	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
BFD_SEND	O
(	O
abfd	pointer
,	O
_bfd_canonicalize_reloc	pointer
,	O
(	O
abfd	pointer
,	O
asect	pointer
,	O
location	pointer
,	O
symbols	pointer
)	O
)	O
;	O
}	O
bfd_boolean	int
bfd_set_file_flags	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
flagword	int
flags	int
)	O
{	O
if	O
(	O
abfd	pointer
->	O
format	enum
!=	O
bfd_object	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_read_p	O
(	O
abfd	pointer
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
abfd	pointer
->	O
flags	int
=	O
flags	int
;	O
if	O
(	O
(	O
flags	int
&	O
bfd_applicable_file_flags	function
(	O
abfd	pointer
)	O
)	O
!=	O
flags	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
void	O
bfd_assert	function
(	O
const	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
)	O
{	O
(	O
*	O
_bfd_assert_handler	pointer
)	O
(	O
_	O
(	O
"BFD %s assertion fail %s:%d"	pointer
)	O
,	O
BFD_VERSION_STRING	O
,	O
file	pointer
,	O
line	pointer
)	O
;	O
}	O
void	O
_bfd_abort	function
(	O
const	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
const	O
char	O
*	O
fn	pointer
)	O
{	O
if	O
(	O
fn	pointer
!=	O
NULL	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"BFD %s internal error, aborting at %s:%d in %s\n"	pointer
)	O
,	O
BFD_VERSION_STRING	O
,	O
file	pointer
,	O
line	pointer
,	O
fn	pointer
)	O
;	O
else	O
_bfd_error_handler	function
(	O
_	O
(	O
"BFD %s internal error, aborting at %s:%d\n"	pointer
)	O
,	O
BFD_VERSION_STRING	O
,	O
file	pointer
,	O
line	pointer
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"Please report this bug.\n"	pointer
)	O
)	O
;	O
_exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
int	O
bfd_get_arch_size	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
return	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
arch_size	char
;	O
return	O
bfd_arch_bits_per_address	function
(	O
abfd	pointer
)	O
>	O
32	int
?	O
64	int
:	O
32	int
;	O
}	O
int	O
bfd_get_sign_extend_vma	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
return	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
sign_extend_vma	int
;	O
name	pointer
=	O
bfd_get_target	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
"coff-go32"	pointer
)	O
||	O
strcmp	function
(	O
name	pointer
,	O
"pe-i386"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"pei-i386"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"pe-x86-64"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"pei-x86-64"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"pe-arm-wince-little"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"pei-arm-wince-little"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"aixcoff-rs6000"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"aix5coff64-rs6000"	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
"mach-o"	pointer
)	O
)	O
return	O
0	int
;	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
bfd_boolean	int
bfd_set_start_address	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_vma	long
vma	long
)	O
{	O
abfd	pointer
->	O
start_address	long
=	O
vma	long
;	O
return	O
TRUE	int
;	O
}	O
unsigned	O
int	O
bfd_get_gp_size	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
abfd	pointer
->	O
format	enum
==	O
bfd_object	int
)	O
{	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_ecoff_flavour	int
)	O
return	O
ecoff_data	O
(	O
abfd	pointer
)	O
->	O
gp_size	int
;	O
else	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
return	O
elf_gp_size	O
(	O
abfd	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
bfd_set_gp_size	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
i	pointer
)	O
{	O
if	O
(	O
abfd	pointer
->	O
format	enum
!=	O
bfd_object	int
)	O
return	O
;	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_ecoff_flavour	int
)	O
ecoff_data	O
(	O
abfd	pointer
)	O
->	O
gp_size	int
=	O
i	pointer
;	O
else	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
elf_gp_size	O
(	O
abfd	pointer
)	O
=	O
i	pointer
;	O
}	O
bfd_vma	long
_bfd_get_gp_value	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
!	O
abfd	pointer
)	O
return	O
0	int
;	O
if	O
(	O
abfd	pointer
->	O
format	enum
!=	O
bfd_object	int
)	O
return	O
0	int
;	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_ecoff_flavour	int
)	O
return	O
ecoff_data	O
(	O
abfd	pointer
)	O
->	O
gp	long
;	O
else	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
return	O
elf_gp	O
(	O
abfd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
_bfd_set_gp_value	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_vma	long
v	long
)	O
{	O
if	O
(	O
!	O
abfd	pointer
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
abfd	pointer
->	O
format	enum
!=	O
bfd_object	int
)	O
return	O
;	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_ecoff_flavour	int
)	O
ecoff_data	O
(	O
abfd	pointer
)	O
->	O
gp	long
=	O
v	long
;	O
else	O
if	O
(	O
abfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
elf_gp	O
(	O
abfd	pointer
)	O
=	O
v	long
;	O
}	O
bfd_vma	long
bfd_scan_vma	function
(	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
*	O
end	pointer
,	O
int	O
base	int
)	O
{	O
bfd_vma	long
value	long
;	O
bfd_vma	long
cutoff	long
;	O
unsigned	O
int	O
cutlim	int
;	O
int	O
overflow	int
;	O
if	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
<=	O
sizeof	O
(	O
unsigned	O
long	O
)	O
)	O
return	O
strtoul	function
(	O
string	pointer
,	O
(	O
char	O
*	O
*	O
)	O
end	pointer
,	O
base	int
)	O
;	O
if	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
<=	O
sizeof	O
(	O
unsigned	O
long	O
long	O
)	O
)	O
return	O
strtoull	function
(	O
string	pointer
,	O
(	O
char	O
*	O
*	O
)	O
end	pointer
,	O
base	int
)	O
;	O
if	O
(	O
base	int
==	O
0	int
)	O
{	O
if	O
(	O
string	pointer
[	O
0	int
]	O
==	O
'0'	O
)	O
{	O
if	O
(	O
(	O
string	pointer
[	O
1	int
]	O
==	O
'x'	O
)	O
||	O
(	O
string	pointer
[	O
1	int
]	O
==	O
'X'	O
)	O
)	O
base	int
=	O
16	int
;	O
else	O
base	int
=	O
8	int
;	O
}	O
}	O
if	O
(	O
(	O
base	int
<	O
2	int
)	O
||	O
(	O
base	int
>	O
36	int
)	O
)	O
base	int
=	O
10	int
;	O
if	O
(	O
base	int
==	O
16	int
&&	O
string	pointer
[	O
0	int
]	O
==	O
'0'	O
&&	O
(	O
string	pointer
[	O
1	int
]	O
==	O
'x'	O
||	O
string	pointer
[	O
1	int
]	O
==	O
'X'	O
)	O
&&	O
ISXDIGIT	O
(	O
string	pointer
[	O
2	int
]	O
)	O
)	O
{	O
string	pointer
+=	O
2	int
;	O
}	O
cutoff	long
=	O
(	O
~	O
(	O
bfd_vma	long
)	O
0	int
)	O
/	O
(	O
bfd_vma	long
)	O
base	int
;	O
cutlim	int
=	O
(	O
~	O
(	O
bfd_vma	long
)	O
0	int
)	O
%	O
(	O
bfd_vma	long
)	O
base	int
;	O
value	long
=	O
0	int
;	O
overflow	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
digit	int
;	O
digit	int
=	O
*	O
string	pointer
;	O
if	O
(	O
ISDIGIT	O
(	O
digit	int
)	O
)	O
digit	int
=	O
digit	int
-	O
'0'	O
;	O
else	O
if	O
(	O
ISALPHA	O
(	O
digit	int
)	O
)	O
digit	int
=	O
TOUPPER	O
(	O
digit	int
)	O
-	O
'A'	O
+	O
10	int
;	O
else	O
break	O
;	O
if	O
(	O
digit	int
>=	O
(	O
unsigned	O
int	O
)	O
base	int
)	O
break	O
;	O
if	O
(	O
value	long
>	O
cutoff	long
||	O
(	O
value	long
==	O
cutoff	long
&&	O
digit	int
>	O
cutlim	int
)	O
)	O
overflow	int
=	O
1	int
;	O
value	long
=	O
value	long
*	O
base	int
+	O
digit	int
;	O
++	O
string	pointer
;	O
}	O
if	O
(	O
overflow	int
)	O
value	long
=	O
~	O
(	O
bfd_vma	long
)	O
0	int
;	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
*	O
end	pointer
=	O
string	pointer
;	O
return	O
value	long
;	O
}	O
bfd_byte	char
*	O
bfd_get_relocated_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
,	O
bfd_byte	char
*	O
data	pointer
,	O
bfd_boolean	int
relocatable	int
,	O
asymbol	struct
*	O
*	O
symbols	pointer
)	O
{	O
bfd	struct
*	O
abfd2	pointer
;	O
bfd_byte	char
*	O
(	O
*	O
fn	pointer
)	O
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
struct	O
bfd_link_order	struct
*	O
,	O
bfd_byte	char
*	O
,	O
bfd_boolean	int
,	O
asymbol	struct
*	O
*	O
)	O
;	O
if	O
(	O
link_order	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
abfd2	pointer
=	O
link_order	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
->	O
owner	pointer
;	O
if	O
(	O
abfd2	pointer
==	O
NULL	O
)	O
abfd2	pointer
=	O
abfd	pointer
;	O
}	O
else	O
abfd2	pointer
=	O
abfd	pointer
;	O
fn	pointer
=	O
abfd2	pointer
->	O
xvec	pointer
->	O
_bfd_get_relocated_section_contents	pointer
;	O
return	O
(	O
*	O
fn	pointer
)	O
(	O
abfd	pointer
,	O
link_info	pointer
,	O
link_order	pointer
,	O
data	pointer
,	O
relocatable	int
,	O
symbols	pointer
)	O
;	O
}	O
bfd_boolean	int
bfd_record_phdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
long	O
type	enum
,	O
bfd_boolean	int
flags_valid	int
,	O
flagword	int
flags	int
,	O
bfd_boolean	int
at_valid	int
,	O
bfd_vma	long
at	long
,	O
bfd_boolean	int
includes_filehdr	int
,	O
bfd_boolean	int
includes_phdrs	int
,	O
unsigned	O
int	O
count	int
,	O
asection	struct
*	O
*	O
secs	pointer
)	O
{	O
struct	O
elf_segment_map	struct
*	O
m	pointer
,	O
*	O
*	O
pm	pointer
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
elf_segment_map	struct
)	O
;	O
amt	long
+=	O
(	O
(	O
bfd_size_type	long
)	O
count	int
-	O
1	int
)	O
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
m	pointer
=	O
(	O
struct	O
elf_segment_map	struct
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
m	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
m	pointer
->	O
p_type	array
=	O
type	enum
;	O
m	pointer
->	O
p_flags	array
=	O
flags	int
;	O
m	pointer
->	O
p_paddr	array
=	O
at	long
;	O
m	pointer
->	O
p_flags_valid	int
=	O
flags_valid	int
;	O
m	pointer
->	O
p_paddr_valid	int
=	O
at_valid	int
;	O
m	pointer
->	O
includes_filehdr	int
=	O
includes_filehdr	int
;	O
m	pointer
->	O
includes_phdrs	int
=	O
includes_phdrs	int
;	O
m	pointer
->	O
count	int
=	O
count	int
;	O
if	O
(	O
count	int
>	O
0	int
)	O
memcpy	function
(	O
m	pointer
->	O
sections	pointer
,	O
secs	pointer
,	O
count	int
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
)	O
;	O
for	O
(	O
pm	pointer
=	O
&	O
elf_seg_map	O
(	O
abfd	pointer
)	O
;	O
*	O
pm	pointer
!=	O
NULL	O
;	O
pm	pointer
=	O
&	O
(	O
*	O
pm	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pm	pointer
=	O
m	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
is32bit	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
return	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS32	int
;	O
}	O
return	O
bfd_arch_bits_per_address	function
(	O
abfd	pointer
)	O
<=	O
32	int
;	O
}	O
void	O
bfd_sprintf_vma	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
char	O
*	O
buf	pointer
,	O
bfd_vma	long
value	long
)	O
{	O
if	O
(	O
is32bit	function
(	O
abfd	pointer
)	O
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"%08lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
value	long
&	O
0xffffffff	int
)	O
;	O
return	O
;	O
}	O
sprintf_vma	O
(	O
buf	pointer
,	O
value	long
)	O
;	O
}	O
void	O
bfd_fprintf_vma	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
void	O
*	O
stream	pointer
,	O
bfd_vma	long
value	long
)	O
{	O
if	O
(	O
is32bit	function
(	O
abfd	pointer
)	O
)	O
{	O
fprintf	function
(	O
(	O
FILE	struct
*	O
)	O
stream	pointer
,	O
"%08lx"	pointer
,	O
(	O
unsigned	O
long	O
)	O
value	long
&	O
0xffffffff	int
)	O
;	O
return	O
;	O
}	O
fprintf_vma	O
(	O
(	O
FILE	struct
*	O
)	O
stream	pointer
,	O
value	long
)	O
;	O
}	O
bfd_boolean	int
bfd_alt_mach_code	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
int	O
alternative	int
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
int	O
code	int
;	O
switch	O
(	O
alternative	int
)	O
{	O
case	O
0	int
:	O
code	int
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_machine_code	int
;	O
break	O
;	O
case	O
1	int
:	O
code	int
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_machine_alt1	int
;	O
if	O
(	O
code	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
2	int
:	O
code	int
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
elf_machine_alt2	int
;	O
if	O
(	O
code	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
break	O
;	O
default	O
:	O
return	O
FALSE	int
;	O
}	O
elf_elfheader	O
(	O
abfd	pointer
)	O
->	O
e_machine	array
=	O
code	int
;	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
bfd_vma	long
bfd_emul_get_maxpagesize	function
(	O
const	O
char	O
*	O
emul	pointer
)	O
{	O
const	O
bfd_target	struct
*	O
target	pointer
;	O
target	pointer
=	O
bfd_find_target	function
(	O
emul	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
target	pointer
!=	O
NULL	O
&&	O
target	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
return	O
xvec_get_elf_backend_data	O
(	O
target	pointer
)	O
->	O
maxpagesize	long
;	O
return	O
0	int
;	O
}	O
static	O
void	O
bfd_elf_set_pagesize	function
(	O
const	O
bfd_target	struct
*	O
target	pointer
,	O
bfd_vma	long
size	long
,	O
int	O
offset	long
,	O
const	O
bfd_target	struct
*	O
orig_target	pointer
)	O
{	O
if	O
(	O
target	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bed	pointer
=	O
xvec_get_elf_backend_data	O
(	O
target	pointer
)	O
;	O
*	O
(	O
(	O
bfd_vma	long
*	O
)	O
(	O
(	O
char	O
*	O
)	O
bed	pointer
+	O
offset	long
)	O
)	O
=	O
size	long
;	O
}	O
if	O
(	O
target	pointer
->	O
alternative_target	pointer
&&	O
target	pointer
->	O
alternative_target	pointer
!=	O
orig_target	pointer
)	O
bfd_elf_set_pagesize	function
(	O
target	pointer
->	O
alternative_target	pointer
,	O
size	long
,	O
offset	long
,	O
orig_target	pointer
)	O
;	O
}	O
void	O
bfd_emul_set_maxpagesize	function
(	O
const	O
char	O
*	O
emul	pointer
,	O
bfd_vma	long
size	long
)	O
{	O
const	O
bfd_target	struct
*	O
target	pointer
;	O
target	pointer
=	O
bfd_find_target	function
(	O
emul	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
target	pointer
)	O
bfd_elf_set_pagesize	function
(	O
target	pointer
,	O
size	long
,	O
offsetof	O
(	O
struct	O
elf_backend_data	struct
,	O
maxpagesize	long
)	O
,	O
target	pointer
)	O
;	O
}	O
bfd_vma	long
bfd_emul_get_commonpagesize	function
(	O
const	O
char	O
*	O
emul	pointer
,	O
bfd_boolean	int
relro	int
)	O
{	O
const	O
bfd_target	struct
*	O
target	pointer
;	O
target	pointer
=	O
bfd_find_target	function
(	O
emul	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
target	pointer
!=	O
NULL	O
&&	O
target	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bed	pointer
=	O
xvec_get_elf_backend_data	O
(	O
target	pointer
)	O
;	O
if	O
(	O
relro	int
)	O
return	O
bed	pointer
->	O
relropagesize	long
;	O
else	O
return	O
bed	pointer
->	O
commonpagesize	long
;	O
}	O
return	O
0	int
;	O
}	O
void	O
bfd_emul_set_commonpagesize	function
(	O
const	O
char	O
*	O
emul	pointer
,	O
bfd_vma	long
size	long
)	O
{	O
const	O
bfd_target	struct
*	O
target	pointer
;	O
target	pointer
=	O
bfd_find_target	function
(	O
emul	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
target	pointer
)	O
bfd_elf_set_pagesize	function
(	O
target	pointer
,	O
size	long
,	O
offsetof	O
(	O
struct	O
elf_backend_data	struct
,	O
commonpagesize	long
)	O
,	O
target	pointer
)	O
;	O
}	O
char	O
*	O
bfd_demangle	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
options	int
)	O
{	O
char	O
*	O
res	pointer
,	O
*	O
alloc	pointer
;	O
const	O
char	O
*	O
pre	pointer
,	O
*	O
suf	pointer
;	O
size_t	long
pre_len	long
;	O
bfd_boolean	int
skip_lead	int
;	O
skip_lead	int
=	O
(	O
abfd	pointer
!=	O
NULL	O
&&	O
*	O
name	pointer
!=	O
'\0'	O
&&	O
bfd_get_symbol_leading_char	function
(	O
abfd	pointer
)	O
==	O
*	O
name	pointer
)	O
;	O
if	O
(	O
skip_lead	int
)	O
++	O
name	pointer
;	O
pre	pointer
=	O
name	pointer
;	O
while	O
(	O
*	O
name	pointer
==	O
'.'	O
||	O
*	O
name	pointer
==	O
'$'	O
)	O
++	O
name	pointer
;	O
pre_len	long
=	O
name	pointer
-	O
pre	pointer
;	O
alloc	pointer
=	O
NULL	O
;	O
suf	pointer
=	O
strchr	function
(	O
name	pointer
,	O
'@'	O
)	O
;	O
if	O
(	O
suf	pointer
!=	O
NULL	O
)	O
{	O
alloc	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
suf	pointer
-	O
name	pointer
+	O
1	int
)	O
;	O
if	O
(	O
alloc	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
alloc	pointer
,	O
name	pointer
,	O
suf	pointer
-	O
name	pointer
)	O
;	O
alloc	pointer
[	O
suf	pointer
-	O
name	pointer
]	O
=	O
'\0'	O
;	O
name	pointer
=	O
alloc	pointer
;	O
}	O
res	pointer
=	O
cplus_demangle	function
(	O
name	pointer
,	O
options	int
)	O
;	O
if	O
(	O
alloc	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc	pointer
)	O
;	O
if	O
(	O
res	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
skip_lead	int
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
pre	pointer
)	O
+	O
1	int
;	O
alloc	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
len	long
)	O
;	O
if	O
(	O
alloc	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
alloc	pointer
,	O
pre	pointer
,	O
len	long
)	O
;	O
return	O
alloc	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
if	O
(	O
pre_len	long
!=	O
0	int
||	O
suf	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
size_t	long
suf_len	long
;	O
char	O
*	O
final	pointer
;	O
len	long
=	O
strlen	function
(	O
res	pointer
)	O
;	O
if	O
(	O
suf	pointer
==	O
NULL	O
)	O
suf	pointer
=	O
res	pointer
+	O
len	long
;	O
suf_len	long
=	O
strlen	function
(	O
suf	pointer
)	O
+	O
1	int
;	O
final	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
pre_len	long
+	O
len	long
+	O
suf_len	long
)	O
;	O
if	O
(	O
final	pointer
!=	O
NULL	O
)	O
{	O
memcpy	function
(	O
final	pointer
,	O
pre	pointer
,	O
pre_len	long
)	O
;	O
memcpy	function
(	O
final	pointer
+	O
pre_len	long
,	O
res	pointer
,	O
len	long
)	O
;	O
memcpy	function
(	O
final	pointer
+	O
pre_len	long
+	O
len	long
,	O
suf	pointer
,	O
suf_len	long
)	O
;	O
}	O
free	function
(	O
res	pointer
)	O
;	O
res	pointer
=	O
final	pointer
;	O
}	O
return	O
res	pointer
;	O
}	O
void	O
bfd_update_compression_header	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_COMPRESS	int
)	O
==	O
0	int
)	O
abort	function
(	O
)	O
;	O
switch	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
)	O
{	O
case	O
bfd_target_elf_flavour	int
:	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_COMPRESS_GABI	int
)	O
!=	O
0	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
elf_section_flags	O
(	O
sec	pointer
)	O
|=	O
SHF_COMPRESSED	O
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS32	int
)	O
{	O
Elf32_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf32_External_Chdr	struct
*	O
)	O
contents	pointer
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
ELFCOMPRESS_ZLIB	int
,	O
&	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
sec	pointer
->	O
size	long
,	O
&	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
1	int
<<	O
sec	pointer
->	O
alignment_power	int
,	O
&	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
2	int
)	O
;	O
}	O
else	O
{	O
Elf64_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf64_External_Chdr	struct
*	O
)	O
contents	pointer
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
ELFCOMPRESS_ZLIB	int
,	O
&	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
0	int
,	O
&	O
echdr	pointer
->	O
ch_reserved	array
)	O
;	O
bfd_put_64	O
(	O
abfd	pointer
,	O
sec	pointer
->	O
size	long
,	O
&	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
bfd_put_64	O
(	O
abfd	pointer
,	O
1	int
<<	O
sec	pointer
->	O
alignment_power	int
,	O
&	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
3	int
)	O
;	O
}	O
break	O
;	O
}	O
elf_section_flags	O
(	O
sec	pointer
)	O
&=	O
~	O
SHF_COMPRESSED	O
;	O
default	O
:	O
memcpy	function
(	O
contents	pointer
,	O
"ZLIB"	pointer
,	O
4	int
)	O
;	O
bfd_putb64	function
(	O
sec	pointer
->	O
size	long
,	O
contents	pointer
+	O
4	int
)	O
;	O
bfd_set_section_alignment	function
(	O
sec	pointer
,	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
bfd_boolean	int
bfd_check_compression_header	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_size_type	long
*	O
uncompressed_size	pointer
,	O
unsigned	O
int	O
*	O
uncompressed_alignment_power	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
&&	O
(	O
elf_section_flags	O
(	O
sec	pointer
)	O
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Chdr	struct
chdr	struct
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS32	int
)	O
{	O
Elf32_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf32_External_Chdr	struct
*	O
)	O
contents	pointer
;	O
chdr	struct
.	O
ch_type	array
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
chdr	struct
.	O
ch_size	array
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
chdr	struct
.	O
ch_addralign	array
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
}	O
else	O
{	O
Elf64_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf64_External_Chdr	struct
*	O
)	O
contents	pointer
;	O
chdr	struct
.	O
ch_type	array
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
chdr	struct
.	O
ch_size	array
=	O
bfd_get_64	O
(	O
abfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
chdr	struct
.	O
ch_addralign	array
=	O
bfd_get_64	O
(	O
abfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
}	O
if	O
(	O
chdr	struct
.	O
ch_type	array
==	O
ELFCOMPRESS_ZLIB	int
&&	O
chdr	struct
.	O
ch_addralign	array
==	O
(	O
chdr	struct
.	O
ch_addralign	array
&	O
-	O
chdr	struct
.	O
ch_addralign	array
)	O
)	O
{	O
*	O
uncompressed_size	pointer
=	O
chdr	struct
.	O
ch_size	array
;	O
*	O
uncompressed_alignment_power	pointer
=	O
bfd_log2	function
(	O
chdr	struct
.	O
ch_addralign	array
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
return	O
FALSE	int
;	O
}	O
int	O
bfd_get_compression_header_size	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
abfd	pointer
->	O
flags	int
&	O
BFD_COMPRESS_GABI	int
)	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
elf_section_flags	O
(	O
sec	pointer
)	O
&	O
SHF_COMPRESSED	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS32	int
)	O
return	O
sizeof	O
(	O
Elf32_External_Chdr	struct
)	O
;	O
else	O
return	O
sizeof	O
(	O
Elf64_External_Chdr	struct
)	O
;	O
}	O
return	O
0	int
;	O
}	O
bfd_size_type	long
bfd_convert_section_size	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
sec_ptr	pointer
isec	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
bfd_size_type	long
size	long
)	O
{	O
bfd_size_type	long
hdr_size	long
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
size	long
;	O
if	O
(	O
get_elf_backend_data	O
(	O
ibfd	pointer
)	O
->	O
s	pointer
->	O
elfclass	char
==	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
->	O
s	pointer
->	O
elfclass	char
)	O
return	O
size	long
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
isec	pointer
->	O
name	pointer
,	O
NOTE_GNU_PROPERTY_SECTION_NAME	pointer
)	O
)	O
return	O
_bfd_elf_convert_gnu_property_size	function
(	O
ibfd	pointer
,	O
obfd	pointer
)	O
;	O
if	O
(	O
(	O
ibfd	pointer
->	O
flags	int
&	O
BFD_DECOMPRESS	int
)	O
)	O
return	O
size	long
;	O
hdr_size	long
=	O
bfd_get_compression_header_size	function
(	O
ibfd	pointer
,	O
isec	pointer
)	O
;	O
if	O
(	O
hdr_size	long
==	O
0	int
)	O
return	O
size	long
;	O
if	O
(	O
hdr_size	long
==	O
sizeof	O
(	O
Elf32_External_Chdr	struct
)	O
)	O
return	O
(	O
size	long
-	O
sizeof	O
(	O
Elf32_External_Chdr	struct
)	O
+	O
sizeof	O
(	O
Elf64_External_Chdr	struct
)	O
)	O
;	O
else	O
return	O
(	O
size	long
-	O
sizeof	O
(	O
Elf64_External_Chdr	struct
)	O
+	O
sizeof	O
(	O
Elf32_External_Chdr	struct
)	O
)	O
;	O
}	O
bfd_boolean	int
bfd_convert_section_contents	function
(	O
bfd	struct
*	O
ibfd	pointer
,	O
sec_ptr	pointer
isec	pointer
,	O
bfd	struct
*	O
obfd	pointer
,	O
bfd_byte	char
*	O
*	O
ptr	pointer
,	O
bfd_size_type	long
*	O
ptr_size	pointer
)	O
{	O
bfd_byte	char
*	O
contents	pointer
;	O
bfd_size_type	long
ihdr_size	long
,	O
ohdr_size	long
,	O
size	long
;	O
Elf_Internal_Chdr	struct
chdr	struct
;	O
bfd_boolean	int
use_memmove	int
;	O
if	O
(	O
bfd_get_flavour	function
(	O
ibfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_flavour	function
(	O
obfd	pointer
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
get_elf_backend_data	O
(	O
ibfd	pointer
)	O
->	O
s	pointer
->	O
elfclass	char
==	O
get_elf_backend_data	O
(	O
obfd	pointer
)	O
->	O
s	pointer
->	O
elfclass	char
)	O
return	O
TRUE	int
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
isec	pointer
->	O
name	pointer
,	O
NOTE_GNU_PROPERTY_SECTION_NAME	pointer
)	O
)	O
return	O
_bfd_elf_convert_gnu_properties	function
(	O
ibfd	pointer
,	O
isec	pointer
,	O
obfd	pointer
,	O
ptr	pointer
,	O
ptr_size	pointer
)	O
;	O
if	O
(	O
(	O
ibfd	pointer
->	O
flags	int
&	O
BFD_DECOMPRESS	int
)	O
)	O
return	O
TRUE	int
;	O
ihdr_size	long
=	O
bfd_get_compression_header_size	function
(	O
ibfd	pointer
,	O
isec	pointer
)	O
;	O
if	O
(	O
ihdr_size	long
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
ihdr_size	long
>	O
bfd_get_section_limit	function
(	O
ibfd	pointer
,	O
isec	pointer
)	O
)	O
return	O
FALSE	int
;	O
contents	pointer
=	O
*	O
ptr	pointer
;	O
if	O
(	O
ihdr_size	long
==	O
sizeof	O
(	O
Elf32_External_Chdr	struct
)	O
)	O
{	O
Elf32_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf32_External_Chdr	struct
*	O
)	O
contents	pointer
;	O
chdr	struct
.	O
ch_type	array
=	O
bfd_get_32	O
(	O
ibfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
chdr	struct
.	O
ch_size	array
=	O
bfd_get_32	O
(	O
ibfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
chdr	struct
.	O
ch_addralign	array
=	O
bfd_get_32	O
(	O
ibfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
ohdr_size	long
=	O
sizeof	O
(	O
Elf64_External_Chdr	struct
)	O
;	O
use_memmove	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
ihdr_size	long
!=	O
sizeof	O
(	O
Elf64_External_Chdr	struct
)	O
)	O
{	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
Elf64_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf64_External_Chdr	struct
*	O
)	O
contents	pointer
;	O
chdr	struct
.	O
ch_type	array
=	O
bfd_get_32	O
(	O
ibfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
chdr	struct
.	O
ch_size	array
=	O
bfd_get_64	O
(	O
ibfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
chdr	struct
.	O
ch_addralign	array
=	O
bfd_get_64	O
(	O
ibfd	pointer
,	O
&	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
ohdr_size	long
=	O
sizeof	O
(	O
Elf32_External_Chdr	struct
)	O
;	O
use_memmove	int
=	O
TRUE	int
;	O
}	O
size	long
=	O
bfd_section_size	function
(	O
isec	pointer
)	O
-	O
ihdr_size	long
+	O
ohdr_size	long
;	O
if	O
(	O
!	O
use_memmove	int
)	O
{	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
ohdr_size	long
==	O
sizeof	O
(	O
Elf32_External_Chdr	struct
)	O
)	O
{	O
Elf32_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf32_External_Chdr	struct
*	O
)	O
contents	pointer
;	O
bfd_put_32	O
(	O
obfd	pointer
,	O
ELFCOMPRESS_ZLIB	int
,	O
&	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
bfd_put_32	O
(	O
obfd	pointer
,	O
chdr	struct
.	O
ch_size	array
,	O
&	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
bfd_put_32	O
(	O
obfd	pointer
,	O
chdr	struct
.	O
ch_addralign	array
,	O
&	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
}	O
else	O
{	O
Elf64_External_Chdr	struct
*	O
echdr	pointer
=	O
(	O
Elf64_External_Chdr	struct
*	O
)	O
contents	pointer
;	O
bfd_put_32	O
(	O
obfd	pointer
,	O
ELFCOMPRESS_ZLIB	int
,	O
&	O
echdr	pointer
->	O
ch_type	array
)	O
;	O
bfd_put_32	O
(	O
obfd	pointer
,	O
0	int
,	O
&	O
echdr	pointer
->	O
ch_reserved	array
)	O
;	O
bfd_put_64	O
(	O
obfd	pointer
,	O
chdr	struct
.	O
ch_size	array
,	O
&	O
echdr	pointer
->	O
ch_size	array
)	O
;	O
bfd_put_64	O
(	O
obfd	pointer
,	O
chdr	struct
.	O
ch_addralign	array
,	O
&	O
echdr	pointer
->	O
ch_addralign	array
)	O
;	O
}	O
if	O
(	O
use_memmove	int
)	O
memmove	function
(	O
contents	pointer
+	O
ohdr_size	long
,	O
*	O
ptr	pointer
+	O
ihdr_size	long
,	O
size	long
-	O
ohdr_size	long
)	O
;	O
else	O
{	O
memcpy	function
(	O
contents	pointer
+	O
ohdr_size	long
,	O
*	O
ptr	pointer
+	O
ihdr_size	long
,	O
size	long
-	O
ohdr_size	long
)	O
;	O
free	function
(	O
*	O
ptr	pointer
)	O
;	O
*	O
ptr	pointer
=	O
contents	pointer
;	O
}	O
*	O
ptr_size	pointer
=	O
size	long
;	O
return	O
TRUE	int
;	O
}	O
