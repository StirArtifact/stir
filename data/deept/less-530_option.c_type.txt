static	O
struct	O
loption	struct
*	O
pendopt	pointer
;	O
public	O
int	O
plusoption	int
=	O
FALSE	int
;	O
static	O
char	O
*	O
optstring	function
(	O
)	O
;	O
static	O
int	O
flip_triple	function
(	O
)	O
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
less_is_more	int
;	O
extern	O
int	O
quit_at_eof	int
;	O
extern	O
char	O
*	O
every_first_cmd	pointer
;	O
extern	O
int	O
opt_use_backslash	int
;	O
static	O
char	O
*	O
opt_desc	function
(	O
o	pointer
)	O
struct	O
loption	struct
*	O
o	pointer
;	O
{	O
static	O
char	O
buf	pointer
[	O
OPTNAME_MAX	int
+	O
10	int
]	O
;	O
if	O
(	O
o	pointer
->	O
oletter	char
==	O
OLETTER_NONE	char
)	O
SNPRINTF1	O
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"--%s"	pointer
,	O
o	pointer
->	O
onames	pointer
->	O
oname	pointer
)	O
;	O
else	O
SNPRINTF2	O
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"-%c (--%s)"	pointer
,	O
o	pointer
->	O
oletter	char
,	O
o	pointer
->	O
onames	pointer
->	O
oname	pointer
)	O
;	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
public	O
char	O
*	O
propt	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
static	O
char	O
buf	pointer
[	O
8	int
]	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"-%s"	pointer
,	O
prchar	function
(	O
c	int
)	O
)	O
;	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
public	O
void	O
scan_option	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
struct	O
loption	struct
*	O
o	pointer
;	O
int	O
optc	int
;	O
char	O
*	O
optname	struct
;	O
char	O
*	O
printopt	pointer
;	O
char	O
*	O
str	pointer
;	O
int	O
set_default	int
;	O
int	O
lc	int
;	O
int	O
err	int
;	O
PARG	union
parg	union
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
pendopt	pointer
!=	O
NULL	O
)	O
{	O
switch	O
(	O
pendopt	pointer
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
STRING	int
:	O
(	O
*	O
pendopt	pointer
->	O
ofunc	pointer
)	O
(	O
INIT	int
,	O
s	pointer
)	O
;	O
break	O
;	O
case	O
NUMBER	int
:	O
printopt	pointer
=	O
opt_desc	function
(	O
pendopt	pointer
)	O
;	O
*	O
(	O
pendopt	pointer
->	O
ovar	pointer
)	O
=	O
getnum	function
(	O
&	O
s	pointer
,	O
printopt	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
pendopt	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
set_default	int
=	O
FALSE	int
;	O
optname	struct
=	O
NULL	O
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
optc	int
=	O
*	O
s	pointer
++	O
)	O
{	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
case	O
END_OPTION_STRING	O
:	O
continue	O
;	O
case	O
'-'	O
:	O
if	O
(	O
*	O
s	pointer
==	O
'-'	O
)	O
{	O
optname	struct
=	O
++	O
s	pointer
;	O
break	O
;	O
}	O
set_default	int
=	O
(	O
*	O
s	pointer
==	O
'+'	O
)	O
;	O
if	O
(	O
set_default	int
)	O
s	pointer
++	O
;	O
continue	O
;	O
case	O
'+'	O
:	O
plusoption	int
=	O
TRUE	int
;	O
s	pointer
=	O
optstring	function
(	O
s	pointer
,	O
&	O
str	pointer
,	O
propt	function
(	O
'+'	O
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
*	O
str	pointer
==	O
'+'	O
)	O
every_first_cmd	pointer
=	O
save	function
(	O
str	pointer
+	O
1	int
)	O
;	O
else	O
{	O
ungetcc	function
(	O
CHAR_END_COMMAND	int
)	O
;	O
ungetsc	function
(	O
str	pointer
)	O
;	O
}	O
free	function
(	O
str	pointer
)	O
;	O
continue	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
s	pointer
--	O
;	O
optc	int
=	O
'z'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
if	O
(	O
less_is_more	int
)	O
optc	int
=	O
'z'	O
;	O
break	O
;	O
}	O
err	int
=	O
0	int
;	O
if	O
(	O
optname	struct
==	O
NULL	O
)	O
{	O
printopt	pointer
=	O
propt	function
(	O
optc	int
)	O
;	O
lc	int
=	O
ASCII_IS_LOWER	O
(	O
optc	int
)	O
;	O
o	pointer
=	O
findopt	function
(	O
optc	int
)	O
;	O
}	O
else	O
{	O
printopt	pointer
=	O
optname	struct
;	O
lc	int
=	O
ASCII_IS_LOWER	O
(	O
optname	struct
[	O
0	int
]	O
)	O
;	O
o	pointer
=	O
findopt_name	function
(	O
&	O
optname	struct
,	O
NULL	O
,	O
&	O
err	int
)	O
;	O
s	pointer
=	O
optname	struct
;	O
optname	struct
=	O
NULL	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
||	O
*	O
s	pointer
==	O
' '	O
)	O
{	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'='	O
)	O
{	O
if	O
(	O
o	pointer
!=	O
NULL	O
&&	O
(	O
o	pointer
->	O
otype	int
&	O
OTYPE	O
)	O
!=	O
STRING	int
&&	O
(	O
o	pointer
->	O
otype	int
&	O
OTYPE	O
)	O
!=	O
NUMBER	int
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
printopt	pointer
;	O
error	function
(	O
"The %s option should not be followed by ="	pointer
,	O
&	O
parg	union
)	O
;	O
return	O
;	O
}	O
s	pointer
++	O
;	O
}	O
else	O
{	O
o	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
o	pointer
==	O
NULL	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
printopt	pointer
;	O
if	O
(	O
err	int
==	O
OPT_AMBIG	int
)	O
error	function
(	O
"%s is an ambiguous abbreviation (\"less --help\" for help)"	pointer
,	O
&	O
parg	union
)	O
;	O
else	O
error	function
(	O
"There is no %s option (\"less --help\" for help)"	pointer
,	O
&	O
parg	union
)	O
;	O
return	O
;	O
}	O
str	pointer
=	O
NULL	O
;	O
switch	O
(	O
o	pointer
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
BOOL	int
:	O
if	O
(	O
set_default	int
)	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
o	pointer
->	O
odefault	int
;	O
else	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
!	O
o	pointer
->	O
odefault	int
;	O
break	O
;	O
case	O
TRIPLE	int
:	O
if	O
(	O
set_default	int
)	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
o	pointer
->	O
odefault	int
;	O
else	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
flip_triple	function
(	O
o	pointer
->	O
odefault	int
,	O
lc	int
)	O
;	O
break	O
;	O
case	O
STRING	int
:	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
pendopt	pointer
=	O
o	pointer
;	O
return	O
;	O
}	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
s	pointer
++	O
;	O
s	pointer
=	O
optstring	function
(	O
s	pointer
,	O
&	O
str	pointer
,	O
printopt	pointer
,	O
o	pointer
->	O
odesc	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
return	O
;	O
break	O
;	O
case	O
NUMBER	int
:	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
pendopt	pointer
=	O
o	pointer
;	O
return	O
;	O
}	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
getnum	function
(	O
&	O
s	pointer
,	O
printopt	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
o	pointer
->	O
ofunc	pointer
!=	O
NULL	O
)	O
(	O
*	O
o	pointer
->	O
ofunc	pointer
)	O
(	O
INIT	int
,	O
str	pointer
)	O
;	O
if	O
(	O
str	pointer
!=	O
NULL	O
)	O
free	function
(	O
str	pointer
)	O
;	O
}	O
}	O
public	O
void	O
toggle_option	function
(	O
o	pointer
,	O
lower	int
,	O
s	pointer
,	O
how_toggle	int
)	O
struct	O
loption	struct
*	O
o	pointer
;	O
int	O
lower	int
;	O
char	O
*	O
s	pointer
;	O
int	O
how_toggle	int
;	O
{	O
int	O
num	long
;	O
int	O
no_prompt	int
;	O
int	O
err	int
;	O
PARG	union
parg	union
;	O
no_prompt	int
=	O
(	O
how_toggle	int
&	O
OPT_NO_PROMPT	int
)	O
;	O
how_toggle	int
&=	O
~	O
OPT_NO_PROMPT	int
;	O
if	O
(	O
o	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
"No such option"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
how_toggle	int
==	O
OPT_TOGGLE	int
&&	O
(	O
o	pointer
->	O
otype	int
&	O
NO_TOGGLE	int
)	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
opt_desc	function
(	O
o	pointer
)	O
;	O
error	function
(	O
"Cannot change the %s option"	pointer
,	O
&	O
parg	union
)	O
;	O
return	O
;	O
}	O
if	O
(	O
how_toggle	int
==	O
OPT_NO_TOGGLE	int
&&	O
(	O
o	pointer
->	O
otype	int
&	O
NO_QUERY	int
)	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
opt_desc	function
(	O
o	pointer
)	O
;	O
error	function
(	O
"Cannot query the %s option"	pointer
,	O
&	O
parg	union
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
o	pointer
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
STRING	int
:	O
case	O
NUMBER	int
:	O
if	O
(	O
how_toggle	int
==	O
OPT_TOGGLE	int
&&	O
*	O
s	pointer
==	O
'\0'	O
)	O
how_toggle	int
=	O
OPT_NO_TOGGLE	int
;	O
break	O
;	O
}	O
if	O
(	O
how_toggle	int
!=	O
OPT_NO_TOGGLE	int
&&	O
(	O
o	pointer
->	O
otype	int
&	O
HL_REPAINT	int
)	O
)	O
repaint_hilite	function
(	O
0	int
)	O
;	O
if	O
(	O
how_toggle	int
!=	O
OPT_NO_TOGGLE	int
)	O
{	O
switch	O
(	O
o	pointer
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
BOOL	int
:	O
switch	O
(	O
how_toggle	int
)	O
{	O
case	O
OPT_TOGGLE	int
:	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
!	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
;	O
break	O
;	O
case	O
OPT_UNSET	int
:	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
o	pointer
->	O
odefault	int
;	O
break	O
;	O
case	O
OPT_SET	int
:	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
!	O
o	pointer
->	O
odefault	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
TRIPLE	int
:	O
switch	O
(	O
how_toggle	int
)	O
{	O
case	O
OPT_TOGGLE	int
:	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
flip_triple	function
(	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
,	O
lower	int
)	O
;	O
break	O
;	O
case	O
OPT_UNSET	int
:	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
o	pointer
->	O
odefault	int
;	O
break	O
;	O
case	O
OPT_SET	int
:	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
flip_triple	function
(	O
o	pointer
->	O
odefault	int
,	O
lower	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
STRING	int
:	O
switch	O
(	O
how_toggle	int
)	O
{	O
case	O
OPT_SET	int
:	O
case	O
OPT_UNSET	int
:	O
error	function
(	O
"Cannot use \"-+\" or \"--\" for a string option"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
NUMBER	int
:	O
switch	O
(	O
how_toggle	int
)	O
{	O
case	O
OPT_TOGGLE	int
:	O
num	long
=	O
getnum	function
(	O
&	O
s	pointer
,	O
NULL	O
,	O
&	O
err	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
num	long
;	O
break	O
;	O
case	O
OPT_UNSET	int
:	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
=	O
o	pointer
->	O
odefault	int
;	O
break	O
;	O
case	O
OPT_SET	int
:	O
error	function
(	O
"Can't use \"-!\" for a numeric option"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
o	pointer
->	O
ofunc	pointer
!=	O
NULL	O
)	O
(	O
*	O
o	pointer
->	O
ofunc	pointer
)	O
(	O
(	O
how_toggle	int
==	O
OPT_NO_TOGGLE	int
)	O
?	O
QUERY	int
:	O
TOGGLE	int
,	O
s	pointer
)	O
;	O
if	O
(	O
how_toggle	int
!=	O
OPT_NO_TOGGLE	int
&&	O
(	O
o	pointer
->	O
otype	int
&	O
HL_REPAINT	int
)	O
)	O
chg_hilite	function
(	O
)	O
;	O
if	O
(	O
!	O
no_prompt	int
)	O
{	O
switch	O
(	O
o	pointer
->	O
otype	int
&	O
OTYPE	O
)	O
{	O
case	O
BOOL	int
:	O
case	O
TRIPLE	int
:	O
error	function
(	O
o	pointer
->	O
odesc	array
[	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
]	O
,	O
NULL_PARG	O
)	O
;	O
break	O
;	O
case	O
NUMBER	int
:	O
parg	union
.	O
p_int	int
=	O
*	O
(	O
o	pointer
->	O
ovar	pointer
)	O
;	O
error	function
(	O
o	pointer
->	O
odesc	array
[	O
1	int
]	O
,	O
&	O
parg	union
)	O
;	O
break	O
;	O
case	O
STRING	int
:	O
break	O
;	O
}	O
}	O
if	O
(	O
how_toggle	int
!=	O
OPT_NO_TOGGLE	int
&&	O
(	O
o	pointer
->	O
otype	int
&	O
REPAINT	int
)	O
)	O
screen_trashed	int
=	O
TRUE	int
;	O
}	O
static	O
int	O
flip_triple	function
(	O
val	int
,	O
lc	int
)	O
int	O
val	int
;	O
int	O
lc	int
;	O
{	O
if	O
(	O
lc	int
)	O
return	O
(	O
(	O
val	int
==	O
OPT_ON	int
)	O
?	O
OPT_OFF	int
:	O
OPT_ON	int
)	O
;	O
else	O
return	O
(	O
(	O
val	int
==	O
OPT_ONPLUS	int
)	O
?	O
OPT_OFF	int
:	O
OPT_ONPLUS	int
)	O
;	O
}	O
public	O
int	O
opt_has_param	function
(	O
o	pointer
)	O
struct	O
loption	struct
*	O
o	pointer
;	O
{	O
if	O
(	O
o	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
o	pointer
->	O
otype	int
&	O
(	O
BOOL	int
|	O
TRIPLE	int
|	O
NOVAR	int
|	O
NO_TOGGLE	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
public	O
char	O
*	O
opt_prompt	function
(	O
o	pointer
)	O
struct	O
loption	struct
*	O
o	pointer
;	O
{	O
if	O
(	O
o	pointer
==	O
NULL	O
||	O
(	O
o	pointer
->	O
otype	int
&	O
(	O
STRING	int
|	O
NUMBER	int
)	O
)	O
==	O
0	int
)	O
return	O
(	O
"?"	pointer
)	O
;	O
return	O
(	O
o	pointer
->	O
odesc	array
[	O
0	int
]	O
)	O
;	O
}	O
public	O
int	O
isoptpending	function
(	O
)	O
{	O
return	O
(	O
pendopt	pointer
!=	O
NULL	O
)	O
;	O
}	O
static	O
void	O
nostring	function
(	O
printopt	pointer
)	O
char	O
*	O
printopt	pointer
;	O
{	O
PARG	union
parg	union
;	O
parg	union
.	O
p_string	pointer
=	O
printopt	pointer
;	O
error	function
(	O
"Value is required after %s"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
public	O
void	O
nopendopt	function
(	O
)	O
{	O
nostring	function
(	O
opt_desc	function
(	O
pendopt	pointer
)	O
)	O
;	O
}	O
static	O
char	O
*	O
optstring	function
(	O
s	pointer
,	O
p_str	pointer
,	O
printopt	pointer
,	O
validchars	pointer
)	O
char	O
*	O
s	pointer
;	O
char	O
*	O
*	O
p_str	pointer
;	O
char	O
*	O
printopt	pointer
;	O
char	O
*	O
validchars	pointer
;	O
{	O
char	O
*	O
p	pointer
;	O
char	O
*	O
out	pointer
;	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
nostring	function
(	O
printopt	pointer
)	O
;	O
return	O
(	O
NULL	O
)	O
;	O
}	O
*	O
p_str	pointer
=	O
(	O
char	O
*	O
)	O
ecalloc	function
(	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
out	pointer
=	O
*	O
p_str	pointer
;	O
for	O
(	O
p	pointer
=	O
s	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
opt_use_backslash	int
&&	O
*	O
p	pointer
==	O
'\\'	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
++	O
p	pointer
;	O
}	O
else	O
{	O
if	O
(	O
*	O
p	pointer
==	O
END_OPTION_STRING	O
||	O
(	O
validchars	pointer
!=	O
NULL	O
&&	O
strchr	function
(	O
validchars	pointer
,	O
*	O
p	pointer
)	O
==	O
NULL	O
)	O
)	O
break	O
;	O
}	O
*	O
out	pointer
++	O
=	O
*	O
p	pointer
;	O
}	O
*	O
out	pointer
=	O
'\0'	O
;	O
return	O
(	O
p	pointer
)	O
;	O
}	O
static	O
int	O
num_error	function
(	O
printopt	pointer
,	O
errp	pointer
)	O
char	O
*	O
printopt	pointer
;	O
int	O
*	O
errp	pointer
;	O
{	O
PARG	union
parg	union
;	O
if	O
(	O
errp	pointer
!=	O
NULL	O
)	O
{	O
*	O
errp	pointer
=	O
TRUE	int
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
printopt	pointer
!=	O
NULL	O
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
printopt	pointer
;	O
error	function
(	O
"Number is required after %s"	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
public	O
int	O
getnum	function
(	O
sp	pointer
,	O
printopt	pointer
,	O
errp	pointer
)	O
char	O
*	O
*	O
sp	pointer
;	O
char	O
*	O
printopt	pointer
;	O
int	O
*	O
errp	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
int	O
n	int
;	O
int	O
neg	int
;	O
s	pointer
=	O
skipsp	function
(	O
*	O
sp	pointer
)	O
;	O
neg	int
=	O
FALSE	int
;	O
if	O
(	O
*	O
s	pointer
==	O
'-'	O
)	O
{	O
neg	int
=	O
TRUE	int
;	O
s	pointer
++	O
;	O
}	O
if	O
(	O
*	O
s	pointer
<	O
'0'	O
||	O
*	O
s	pointer
>	O
'9'	O
)	O
return	O
(	O
num_error	function
(	O
printopt	pointer
,	O
errp	pointer
)	O
)	O
;	O
n	int
=	O
0	int
;	O
while	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
)	O
n	int
=	O
10	int
*	O
n	int
+	O
*	O
s	pointer
++	O
-	O
'0'	O
;	O
*	O
sp	pointer
=	O
s	pointer
;	O
if	O
(	O
errp	pointer
!=	O
NULL	O
)	O
*	O
errp	pointer
=	O
FALSE	int
;	O
if	O
(	O
neg	int
)	O
n	int
=	O
-	O
n	int
;	O
return	O
(	O
n	int
)	O
;	O
}	O
public	O
long	O
getfraction	function
(	O
sp	pointer
,	O
printopt	pointer
,	O
errp	pointer
)	O
char	O
*	O
*	O
sp	pointer
;	O
char	O
*	O
printopt	pointer
;	O
int	O
*	O
errp	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
long	O
frac	pointer
=	O
0	int
;	O
int	O
fraclen	int
=	O
0	int
;	O
s	pointer
=	O
skipsp	function
(	O
*	O
sp	pointer
)	O
;	O
if	O
(	O
*	O
s	pointer
<	O
'0'	O
||	O
*	O
s	pointer
>	O
'9'	O
)	O
return	O
(	O
num_error	function
(	O
printopt	pointer
,	O
errp	pointer
)	O
)	O
;	O
for	O
(	O
;	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
;	O
s	pointer
++	O
)	O
{	O
frac	pointer
=	O
(	O
frac	pointer
*	O
10	int
)	O
+	O
(	O
*	O
s	pointer
-	O
'0'	O
)	O
;	O
fraclen	int
++	O
;	O
}	O
if	O
(	O
fraclen	int
>	O
NUM_LOG_FRAC_DENOM	int
)	O
while	O
(	O
fraclen	int
--	O
>	O
NUM_LOG_FRAC_DENOM	int
)	O
frac	pointer
/=	O
10	int
;	O
else	O
while	O
(	O
fraclen	int
++	O
<	O
NUM_LOG_FRAC_DENOM	int
)	O
frac	pointer
*=	O
10	int
;	O
*	O
sp	pointer
=	O
s	pointer
;	O
if	O
(	O
errp	pointer
!=	O
NULL	O
)	O
*	O
errp	pointer
=	O
FALSE	int
;	O
return	O
(	O
frac	pointer
)	O
;	O
}	O
public	O
int	O
get_quit_at_eof	function
(	O
)	O
{	O
if	O
(	O
!	O
less_is_more	int
)	O
return	O
quit_at_eof	int
;	O
return	O
quit_at_eof	int
?	O
OPT_ONPLUS	int
:	O
OPT_ON	int
;	O
}	O
