static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: bt_verify.c,v 1.1 2000/06/28 16:47:00 loic Exp $"	pointer
;	O
static	O
int	O
__bam_safe_getdata	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
PAGE	struct
*	O
,	O
u_int32_t	int
,	O
int	O
,	O
DBT	struct
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__bam_vrfy_inp	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
PAGE	struct
*	O
,	O
db_pgno_t	int
,	O
db_indx_t	short
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__bam_vrfy_treeorder	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
db_pgno_t	int
,	O
PAGE	struct
*	O
,	O
BINTERNAL	struct
*	O
,	O
BINTERNAL	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ram_vrfy_inp	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
VRFY_DBINFO	struct
*	O
,	O
PAGE	struct
*	O
,	O
db_pgno_t	int
,	O
db_indx_t	short
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
CDB___bam_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
BTMETA	struct
*	O
meta	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
isbad	int
,	O
t_ret	int
,	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_INCOMPLETE	int
)	O
&&	O
(	O
ret	int
=	O
CDB___db_vrfy_meta	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
meta	pointer
->	O
minkey	int
<	O
2	int
||	O
meta	pointer
->	O
minkey	int
>	O
(	O
dbp	pointer
->	O
pgsize	int
/	O
BKEYDATA_PSIZE	O
(	O
0	int
)	O
)	O
)	O
{	O
pip	pointer
->	O
bt_minkey	int
=	O
0	int
;	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Nonsensical bt_minkey value %lu on metadata page %lu"	pointer
,	O
meta	pointer
->	O
minkey	int
,	O
pgno	int
)	O
)	O
;	O
}	O
else	O
pip	pointer
->	O
bt_minkey	int
=	O
meta	pointer
->	O
minkey	int
;	O
pip	pointer
->	O
bt_maxkey	int
=	O
meta	pointer
->	O
maxkey	int
;	O
pip	pointer
->	O
re_len	int
=	O
meta	pointer
->	O
re_len	int
;	O
pip	pointer
->	O
root	int
=	O
0	int
;	O
if	O
(	O
meta	pointer
->	O
root	int
==	O
PGNO_INVALID	int
||	O
meta	pointer
->	O
root	int
==	O
pgno	int
||	O
!	O
IS_VALID_PGNO	O
(	O
meta	pointer
->	O
root	int
)	O
||	O
(	O
pgno	int
==	O
PGNO_BASE_MD	int
&&	O
meta	pointer
->	O
root	int
!=	O
1	int
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Nonsensical root page %lu on metadata page %lu"	pointer
,	O
meta	pointer
->	O
root	int
,	O
vdp	pointer
->	O
last_pgno	int
)	O
)	O
;	O
}	O
else	O
pip	pointer
->	O
root	int
=	O
meta	pointer
->	O
root	int
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
BTM_RENUMBER	int
)	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_IS_RRECNO	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
BTM_SUBDB	int
)	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
BTM_DUP	int
)	O
&&	O
pgno	int
==	O
PGNO_BASE_MD	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Btree metadata page %lu has both duplicates and multiple databases"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_SUBDBS	int
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
BTM_DUP	int
)	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
BTM_DUPSORT	int
)	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPSORT	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
BTM_RECNUM	int
)	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_RECNUMS	int
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_RECNUMS	int
)	O
&&	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Btree metadata page %lu illegally has both recnums and dups"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
BTM_RECNO	int
)	O
)	O
{	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_IS_RECNO	int
)	O
;	O
dbp	pointer
->	O
type	enum
=	O
DB_RECNO	int
;	O
}	O
else	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_IS_RRECNO	int
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Metadata page %lu has renumber flag set but is not recno"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_IS_RECNO	int
)	O
&&	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Recno metadata page %lu specifies duplicates"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
&	O
meta	pointer
->	O
dbmeta	struct
,	O
BTM_FIXEDLEN	int
)	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_IS_FIXEDLEN	int
)	O
;	O
else	O
if	O
(	O
pip	pointer
->	O
re_len	int
>	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"re_len of %lu in non-fixed-length database"	pointer
,	O
pip	pointer
->	O
re_len	int
)	O
)	O
;	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___ram_vrfy_leaf	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_indx_t	short
i	short
;	O
int	O
ret	int
,	O
t_ret	int
,	O
isbad	int
;	O
u_int32_t	int
re_len_guess	int
,	O
len	short
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___ram_vrfy_leaf"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_LRECNO	int
)	O
{	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___ram_vrfy_leaf"	pointer
,	O
pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_datapage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__bam_vrfy_inp	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
->	O
entries	short
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Recno database has dups on page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
re_len_guess	int
=	O
0	int
;	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
{	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	short
)	O
;	O
if	O
(	O
B_DISSET	O
(	O
bk	pointer
->	O
type	enum
)	O
)	O
continue	O
;	O
if	O
(	O
bk	pointer
->	O
type	enum
==	O
B_OVERFLOW	int
)	O
len	short
=	O
(	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
)	O
->	O
tlen	int
;	O
else	O
if	O
(	O
bk	pointer
->	O
type	enum
==	O
B_KEYDATA	int
)	O
len	short
=	O
bk	pointer
->	O
len	short
;	O
else	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Nonsensical type for item %lu, page %lu"	pointer
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
re_len_guess	int
==	O
0	int
)	O
re_len_guess	int
=	O
len	short
;	O
if	O
(	O
re_len_guess	int
!=	O
len	short
)	O
{	O
re_len_guess	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
pip	pointer
->	O
re_len	int
=	O
re_len_guess	int
;	O
pip	pointer
->	O
rec_cnt	int
=	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
0	int
)	O
;	O
}	O
int	O
CDB___bam_vrfy	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
ret	int
,	O
t_ret	int
,	O
isbad	int
;	O
isbad	int
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
break	O
;	O
default	O
:	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___bam_vrfy"	pointer
,	O
pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_datapage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
pip	pointer
->	O
rec_cnt	int
=	O
RE_NREC	O
(	O
h	pointer
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IRECNO	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__ram_vrfy_inp	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
->	O
entries	short
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
__bam_vrfy_inp	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
->	O
entries	short
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"item order check on page %lu unsafe: skipping"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_NOORDERCHK	int
)	O
&&	O
(	O
ret	int
=	O
CDB___bam_vrfy_itemorder	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
0	int
)	O
;	O
}	O
static	O
int	O
__ram_vrfy_inp	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
nentriesp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
db_indx_t	short
*	O
nentriesp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
RINTERNAL	struct
*	O
ri	pointer
;	O
VRFY_CHILDINFO	struct
child	struct
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
ret	int
,	O
t_ret	int
,	O
isbad	int
;	O
db_indx_t	short
himark	short
,	O
i	short
,	O
offset	int
,	O
nentries	short
;	O
u_int8_t	char
*	O
pagelayout	pointer
,	O
*	O
p	pointer
;	O
isbad	int
=	O
0	int
;	O
memset	function
(	O
&	O
child	struct
,	O
0	int
,	O
sizeof	O
(	O
VRFY_CHILDINFO	struct
)	O
)	O
;	O
nentries	short
=	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_IRECNO	int
)	O
{	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__ram_vrfy_inp"	pointer
,	O
pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
himark	short
=	O
dbp	pointer
->	O
pgsize	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
pagelayout	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memset	function
(	O
pagelayout	pointer
,	O
0	int
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
{	O
if	O
(	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
->	O
inp	array
+	O
i	short
>=	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
+	O
himark	short
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Page %lu entries listing %lu overlaps data"	pointer
,	O
pgno	int
,	O
i	short
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
offset	int
=	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
;	O
if	O
(	O
offset	int
<=	O
(	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
->	O
inp	array
+	O
i	short
-	O
(	O
u_int8_t	char
*	O
)	O
h	pointer
)	O
||	O
offset	int
>	O
dbp	pointer
->	O
pgsize	int
-	O
RINTERNAL_SIZE	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad offset %lu at page %lu index %lu"	pointer
,	O
offset	int
,	O
pgno	int
,	O
i	short
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
offset	int
<	O
himark	short
)	O
himark	short
=	O
offset	int
;	O
nentries	short
++	O
;	O
ri	pointer
=	O
GET_RINTERNAL	O
(	O
h	pointer
,	O
i	short
)	O
;	O
if	O
(	O
pagelayout	pointer
[	O
offset	int
]	O
==	O
0	int
)	O
{	O
pagelayout	pointer
[	O
offset	int
]	O
=	O
1	int
;	O
child	struct
.	O
pgno	int
=	O
ri	pointer
->	O
pgno	int
;	O
child	struct
.	O
type	enum
=	O
V_RECNO	int
;	O
child	struct
.	O
nrecs	int
=	O
ri	pointer
->	O
nrecs	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_childput	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
child	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"RINTERNAL structure at offset %lu, page %lu referenced twice"	pointer
,	O
offset	int
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
}	O
for	O
(	O
p	pointer
=	O
pagelayout	pointer
+	O
himark	short
;	O
p	pointer
<	O
pagelayout	pointer
+	O
dbp	pointer
->	O
pgsize	int
;	O
p	pointer
+=	O
RINTERNAL_SIZE	O
)	O
if	O
(	O
*	O
p	pointer
!=	O
1	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Gap between items at offset %lu, page %lu"	pointer
,	O
p	pointer
-	O
pagelayout	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
himark	short
!=	O
HOFFSET	O
(	O
h	pointer
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad HOFFSET %lu, appears to be %lu"	pointer
,	O
HOFFSET	O
(	O
h	pointer
)	O
,	O
himark	short
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
*	O
nentriesp	pointer
=	O
nentries	short
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_vrfy_inp	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
nentriesp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
db_indx_t	short
*	O
nentriesp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
;	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
VRFY_CHILDINFO	struct
child	struct
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
int	O
isbad	int
,	O
initem	int
,	O
isdupitem	int
,	O
ret	int
,	O
t_ret	int
;	O
u_int32_t	int
himark	short
,	O
offset	int
;	O
db_indx_t	short
i	short
,	O
endoff	short
,	O
nentries	short
;	O
u_int8_t	char
*	O
pagelayout	pointer
;	O
isbad	int
=	O
isdupitem	int
=	O
0	int
;	O
nentries	short
=	O
0	int
;	O
memset	function
(	O
&	O
child	struct
,	O
0	int
,	O
sizeof	O
(	O
VRFY_CHILDINFO	struct
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
break	O
;	O
default	O
:	O
if	O
(	O
LF_ISSET	O
(	O
DB_SALVAGE	int
)	O
)	O
break	O
;	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__bam_vrfy_inp"	pointer
,	O
pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
himark	short
=	O
dbp	pointer
->	O
pgsize	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
pagelayout	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memset	function
(	O
pagelayout	pointer
,	O
0	int
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
{	O
ret	int
=	O
CDB___db_vrfy_inpitem	function
(	O
dbp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
i	short
,	O
1	int
,	O
flags	int
,	O
&	O
himark	short
,	O
&	O
offset	int
)	O
;	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
{	O
isbad	int
=	O
1	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
ret	int
==	O
DB_VERIFY_FATAL	O
)	O
{	O
isbad	int
=	O
1	int
;	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
ret	int
!=	O
0	int
)	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	short
)	O
;	O
if	O
(	O
pagelayout	pointer
[	O
offset	int
]	O
==	O
0	int
)	O
pagelayout	pointer
[	O
offset	int
]	O
=	O
ITEM_BEGIN	int
;	O
else	O
if	O
(	O
pagelayout	pointer
[	O
offset	int
]	O
==	O
ITEM_BEGIN	int
)	O
{	O
if	O
(	O
(	O
i	short
%	O
P_INDX	int
==	O
0	int
)	O
&&	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
)	O
)	O
{	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
;	O
nentries	short
++	O
;	O
isdupitem	int
=	O
1	int
;	O
}	O
else	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicated item %lu on page %lu"	pointer
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
}	O
}	O
switch	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
)	O
endoff	short
=	O
offset	int
+	O
BINTERNAL_SIZE	O
(	O
bk	pointer
->	O
len	short
)	O
-	O
1	int
;	O
else	O
endoff	short
=	O
offset	int
+	O
BKEYDATA_SIZE	O
(	O
bk	pointer
->	O
len	short
)	O
-	O
1	int
;	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
;	O
case	O
B_OVERFLOW	int
:	O
endoff	short
=	O
offset	int
+	O
(	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
)	O
?	O
BINTERNAL_SIZE	O
(	O
BOVERFLOW_SIZE	O
)	O
:	O
BOVERFLOW_SIZE	O
)	O
-	O
1	int
;	O
break	O
;	O
default	O
:	O
endoff	short
=	O
offset	int
+	O
BKEYDATA_SIZE	O
(	O
0	int
)	O
-	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
isdupitem	int
&&	O
pagelayout	pointer
[	O
endoff	short
]	O
!=	O
ITEM_END	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicated item %lu on page %lu"	pointer
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
pagelayout	pointer
[	O
endoff	short
]	O
==	O
0	int
)	O
pagelayout	pointer
[	O
endoff	short
]	O
=	O
ITEM_END	int
;	O
isdupitem	int
=	O
0	int
;	O
if	O
(	O
B_DISSET	O
(	O
bk	pointer
->	O
type	enum
)	O
&&	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_LRECNO	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Item %lu on page %lu marked deleted"	pointer
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
}	O
switch	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicate page referenced by internal btree page %lu at item %lu"	pointer
,	O
pgno	int
,	O
i	short
)	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LRECNO	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicate page referenced by recno page %lu at item %lu"	pointer
,	O
pgno	int
,	O
i	short
)	O
)	O
;	O
break	O
;	O
}	O
case	O
B_OVERFLOW	int
:	O
bo	pointer
=	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
)	O
?	O
(	O
BOVERFLOW	struct
*	O
)	O
(	O
(	O
(	O
BINTERNAL	struct
*	O
)	O
bk	pointer
)	O
->	O
data	pointer
)	O
:	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
;	O
if	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
if	O
(	O
bo	pointer
->	O
tlen	int
>	O
dbp	pointer
->	O
pgsize	int
*	O
vdp	pointer
->	O
last_pgno	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Impossible tlen %lu, item %lu, page %lu"	pointer
,	O
bo	pointer
->	O
tlen	int
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
bo	pointer
->	O
pgno	int
)	O
||	O
bo	pointer
->	O
pgno	int
==	O
pgno	int
||	O
bo	pointer
->	O
pgno	int
==	O
PGNO_INVALID	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Offpage item %lu, page %lu has bad pgno"	pointer
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
break	O
;	O
}	O
child	struct
.	O
pgno	int
=	O
bo	pointer
->	O
pgno	int
;	O
child	struct
.	O
type	enum
=	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
?	O
V_OVERFLOW	int
:	O
V_DUPLICATE	int
)	O
;	O
child	struct
.	O
tlen	int
=	O
bo	pointer
->	O
tlen	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_childput	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
child	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Item %lu on page %lu of invalid type %lu"	pointer
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
break	O
;	O
}	O
}	O
initem	int
=	O
0	int
;	O
for	O
(	O
i	short
=	O
himark	short
;	O
i	short
<	O
dbp	pointer
->	O
pgsize	int
;	O
i	short
++	O
)	O
if	O
(	O
initem	int
==	O
0	int
)	O
switch	O
(	O
pagelayout	pointer
[	O
i	short
]	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
i	short
!=	O
ALIGN	O
(	O
i	short
,	O
4	int
)	O
)	O
continue	O
;	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Gap between items, page %lu offset %lu"	pointer
,	O
pgno	int
,	O
i	short
)	O
)	O
;	O
for	O
(	O
;	O
pagelayout	pointer
[	O
i	short
+	O
1	int
]	O
==	O
0	int
&&	O
(	O
size_t	long
)	O
(	O
i	short
+	O
1	int
)	O
<	O
dbp	pointer
->	O
pgsize	int
;	O
i	short
++	O
)	O
;	O
break	O
;	O
case	O
ITEM_BEGIN	int
:	O
if	O
(	O
i	short
!=	O
ALIGN	O
(	O
i	short
,	O
4	int
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Offset %lu page %lu unaligned"	pointer
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
}	O
initem	int
=	O
1	int
;	O
nentries	short
++	O
;	O
break	O
;	O
case	O
ITEM_END	int
:	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Overlapping items, page %lu offset %lu"	pointer
,	O
pgno	int
,	O
i	short
)	O
)	O
;	O
break	O
;	O
default	O
:	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
else	O
switch	O
(	O
pagelayout	pointer
[	O
i	short
]	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
ITEM_END	int
:	O
initem	int
=	O
0	int
;	O
break	O
;	O
case	O
ITEM_BEGIN	int
:	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Overlapping items, page %lu offset %lu"	pointer
,	O
pgno	int
,	O
i	short
)	O
)	O
;	O
break	O
;	O
}	O
(	O
void	O
)	O
CDB___os_free	function
(	O
pagelayout	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
if	O
(	O
himark	short
!=	O
HOFFSET	O
(	O
h	pointer
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad HOFFSET %lu, appears to be %lu"	pointer
,	O
HOFFSET	O
(	O
h	pointer
)	O
,	O
himark	short
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
err	pointer
:	O
if	O
(	O
nentriesp	pointer
!=	O
NULL	O
)	O
*	O
nentriesp	pointer
=	O
nentries	short
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
isbad	int
==	O
1	int
&&	O
ret	int
==	O
0	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_vrfy_itemorder	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
nentries	short
,	O
ovflok	int
,	O
hasdups	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
nentries	short
;	O
int	O
ovflok	int
,	O
hasdups	int
;	O
u_int32_t	int
flags	int
;	O
{	O
DBT	struct
dbta	struct
,	O
dbtb	struct
,	O
dup1	struct
,	O
dup2	struct
,	O
*	O
p1	pointer
,	O
*	O
p2	pointer
,	O
*	O
tmp	pointer
;	O
BTREE	struct
*	O
bt	pointer
;	O
BINTERNAL	struct
*	O
bi	pointer
;	O
BKEYDATA	struct
*	O
bk	pointer
;	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_indx_t	short
i	short
;	O
int	O
cmp	int
,	O
freedup1	int
,	O
freedup2	int
,	O
isbad	int
,	O
ret	int
,	O
t_ret	int
;	O
int	O
(	O
*	O
dupfunc	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
int	O
(	O
*	O
func	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
void	O
*	O
buf1	pointer
,	O
*	O
buf2	pointer
,	O
*	O
tmpbuf	pointer
;	O
if	O
(	O
vdp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
nentries	short
=	O
pip	pointer
->	O
entries	short
;	O
}	O
else	O
pip	pointer
=	O
NULL	O
;	O
ret	int
=	O
isbad	int
=	O
0	int
;	O
bo	pointer
=	O
NULL	O
;	O
memset	function
(	O
&	O
dbta	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
F_SET	O
(	O
&	O
dbta	struct
,	O
DB_DBT_REALLOC	int
)	O
;	O
memset	function
(	O
&	O
dbtb	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
F_SET	O
(	O
&	O
dbtb	struct
,	O
DB_DBT_REALLOC	int
)	O
;	O
buf1	pointer
=	O
buf2	pointer
=	O
NULL	O
;	O
DB_ASSERT	O
(	O
!	O
LF_ISSET	O
(	O
DB_NOORDERCHK	int
)	O
)	O
;	O
dupfunc	pointer
=	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
)	O
?	O
CDB___bam_defcmp	function
:	O
dbp	pointer
->	O
dup_compare	pointer
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LDUP	int
)	O
func	pointer
=	O
dupfunc	pointer
;	O
else	O
{	O
func	pointer
=	O
CDB___bam_defcmp	function
;	O
if	O
(	O
dbp	pointer
->	O
bt_internal	pointer
!=	O
NULL	O
)	O
{	O
bt	pointer
=	O
(	O
BTREE	struct
*	O
)	O
dbp	pointer
->	O
bt_internal	pointer
;	O
if	O
(	O
bt	pointer
->	O
bt_compare	pointer
!=	O
NULL	O
)	O
func	pointer
=	O
bt	pointer
->	O
bt_compare	pointer
;	O
}	O
}	O
p1	pointer
=	O
&	O
dbta	struct
;	O
p2	pointer
=	O
&	O
dbtb	struct
;	O
for	O
(	O
i	short
=	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
)	O
?	O
1	int
:	O
0	int
;	O
i	short
<	O
nentries	short
;	O
i	short
+=	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
)	O
?	O
P_INDX	int
:	O
O_INDX	int
)	O
{	O
tmp	pointer
=	O
p1	pointer
;	O
p1	pointer
=	O
p2	pointer
;	O
p2	pointer
=	O
tmp	pointer
;	O
tmpbuf	pointer
=	O
buf1	pointer
;	O
buf1	pointer
=	O
buf2	pointer
;	O
buf2	pointer
=	O
tmpbuf	pointer
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
bi	pointer
=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
i	short
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
bi	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
{	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
(	O
bi	pointer
->	O
data	pointer
)	O
;	O
goto	O
overflow	O
;	O
}	O
else	O
{	O
p2	pointer
->	O
data	pointer
=	O
bi	pointer
->	O
data	pointer
;	O
p2	pointer
->	O
size	int
=	O
bi	pointer
->	O
len	short
;	O
}	O
break	O
;	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	short
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
{	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
;	O
goto	O
overflow	O
;	O
}	O
else	O
{	O
p2	pointer
->	O
data	pointer
=	O
bk	pointer
->	O
data	pointer
;	O
p2	pointer
->	O
size	int
=	O
bk	pointer
->	O
len	short
;	O
}	O
break	O
;	O
default	O
:	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___bam_vrfy_itemorder"	pointer
,	O
pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
0	int
)	O
{	O
overflow	O
:	O
if	O
(	O
!	O
ovflok	int
)	O
{	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_INCOMPLETE	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
p2	pointer
->	O
data	pointer
=	O
buf2	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_goff	function
(	O
dbp	pointer
,	O
p2	pointer
,	O
bo	pointer
->	O
tlen	int
,	O
bo	pointer
->	O
pgno	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Error %lu in fetching overflow item %lu, page %lu"	pointer
,	O
ret	int
,	O
i	short
,	O
pgno	int
)	O
)	O
;	O
}	O
buf2	pointer
=	O
p2	pointer
->	O
data	pointer
;	O
}	O
if	O
(	O
p1	pointer
->	O
data	pointer
!=	O
NULL	O
&&	O
p2	pointer
->	O
data	pointer
!=	O
NULL	O
)	O
{	O
cmp	int
=	O
func	pointer
(	O
p1	pointer
,	O
p2	pointer
)	O
;	O
if	O
(	O
cmp	int
>	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Out-of-order key, page %lu item %lu"	pointer
,	O
pgno	int
,	O
i	short
)	O
)	O
;	O
}	O
else	O
if	O
(	O
cmp	int
==	O
0	int
)	O
{	O
if	O
(	O
pip	pointer
!=	O
NULL	O
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
;	O
else	O
if	O
(	O
hasdups	int
==	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Database with no duplicates has duplicated keys on page %lu"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
)	O
{	O
if	O
(	O
i	short
+	O
1	int
>=	O
(	O
db_indx_t	short
)	O
nentries	short
)	O
continue	O
;	O
if	O
(	O
(	O
(	O
ret	int
=	O
__bam_safe_getdata	function
(	O
dbp	pointer
,	O
h	pointer
,	O
i	short
-	O
1	int
,	O
ovflok	int
,	O
&	O
dup1	struct
,	O
&	O
freedup1	int
)	O
)	O
!=	O
0	int
)	O
||	O
(	O
(	O
ret	int
=	O
__bam_safe_getdata	function
(	O
dbp	pointer
,	O
h	pointer
,	O
i	short
+	O
1	int
,	O
ovflok	int
,	O
&	O
dup2	struct
,	O
&	O
freedup2	int
)	O
)	O
!=	O
0	int
)	O
)	O
goto	O
err	pointer
;	O
if	O
(	O
dup1	struct
.	O
data	pointer
==	O
NULL	O
||	O
dup2	struct
.	O
data	pointer
==	O
NULL	O
)	O
{	O
DB_ASSERT	O
(	O
!	O
ovflok	int
)	O
;	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_INCOMPLETE	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
dupfunc	pointer
(	O
&	O
dup1	struct
,	O
&	O
dup2	struct
)	O
>	O
0	int
)	O
F_SET	O
(	O
pip	pointer
,	O
VRFY_DUPS_UNSORTED	int
)	O
;	O
if	O
(	O
freedup1	int
)	O
CDB___os_free	function
(	O
dup1	struct
.	O
data	pointer
,	O
0	int
)	O
;	O
if	O
(	O
freedup2	int
)	O
CDB___os_free	function
(	O
dup2	struct
.	O
data	pointer
,	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
err	pointer
:	O
if	O
(	O
pip	pointer
!=	O
NULL	O
&&	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
buf1	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
buf1	pointer
,	O
0	int
)	O
;	O
if	O
(	O
buf2	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
buf2	pointer
,	O
0	int
)	O
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_vrfy_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
meta_pgno	int
;	O
u_int32_t	int
flags	int
;	O
{	O
DB	struct
*	O
pgset	pointer
;	O
VRFY_PAGEINFO	struct
*	O
mip	pointer
,	O
*	O
rip	pointer
;	O
db_pgno_t	int
root	int
,	O
p	pointer
;	O
int	O
t_ret	int
,	O
ret	int
;	O
u_int32_t	int
nrecs	int
,	O
level	char
,	O
relen	int
,	O
stflags	int
;	O
mip	pointer
=	O
rip	pointer
=	O
0	int
;	O
pgset	pointer
=	O
vdp	pointer
->	O
pgset	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
meta_pgno	int
,	O
&	O
mip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
meta_pgno	int
,	O
(	O
int	O
*	O
)	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
p	pointer
!=	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Btree metadata page number %lu observed twice"	pointer
,	O
meta_pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
pgset	pointer
,	O
meta_pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
root	int
=	O
mip	pointer
->	O
root	int
;	O
if	O
(	O
root	int
==	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Btree metadata page %lu has no root"	pointer
,	O
meta_pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
root	int
,	O
&	O
rip	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
switch	O
(	O
rip	pointer
->	O
type	enum
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_LBTREE	int
:	O
stflags	int
=	O
flags	int
|	O
ST_TOPLEVEL	int
;	O
if	O
(	O
F_ISSET	O
(	O
mip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
)	O
stflags	int
|=	O
ST_DUPOK	int
;	O
if	O
(	O
F_ISSET	O
(	O
mip	pointer
,	O
VRFY_HAS_DUPSORT	int
)	O
)	O
stflags	int
|=	O
ST_DUPSORT	int
;	O
if	O
(	O
F_ISSET	O
(	O
mip	pointer
,	O
VRFY_HAS_RECNUMS	int
)	O
)	O
stflags	int
|=	O
ST_RECNUM	int
;	O
ret	int
=	O
CDB___bam_vrfy_subtree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
root	int
,	O
NULL	O
,	O
NULL	O
,	O
stflags	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
P_IRECNO	int
:	O
case	O
P_LRECNO	int
:	O
stflags	int
=	O
flags	int
|	O
ST_RECNUM	int
|	O
ST_IS_RECNO	int
|	O
ST_TOPLEVEL	int
;	O
if	O
(	O
mip	pointer
->	O
re_len	int
>	O
0	int
)	O
stflags	int
|=	O
ST_RELEN	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_subtree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
root	int
,	O
NULL	O
,	O
NULL	O
,	O
stflags	int
,	O
&	O
level	char
,	O
&	O
nrecs	int
,	O
&	O
relen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
mip	pointer
->	O
re_len	int
>	O
0	int
&&	O
relen	int
>	O
0	int
&&	O
mip	pointer
->	O
re_len	int
!=	O
relen	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Recno database with meta page %lu has bad re_len %lu"	pointer
,	O
meta_pgno	int
,	O
relen	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
ret	int
=	O
0	int
;	O
break	O
;	O
case	O
P_LDUP	int
:	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicate tree referenced from metadata page %lu"	pointer
,	O
meta_pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
break	O
;	O
default	O
:	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"%s%s"	pointer
,	O
"Btree root of incorrect type "	pointer
,	O
"%lu specified on meta page %lu"	pointer
,	O
rip	pointer
->	O
type	enum
,	O
meta_pgno	int
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
break	O
;	O
}	O
err	pointer
:	O
if	O
(	O
mip	pointer
!=	O
NULL	O
&&	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
mip	pointer
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
==	O
0	int
)	O
t_ret	int
=	O
ret	int
;	O
if	O
(	O
rip	pointer
!=	O
NULL	O
&&	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
rip	pointer
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
==	O
0	int
)	O
t_ret	int
=	O
ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_vrfy_subtree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
l	pointer
,	O
r	pointer
,	O
flags	int
,	O
levelp	pointer
,	O
nrecsp	pointer
,	O
relenp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
void	O
*	O
l	pointer
,	O
*	O
r	pointer
;	O
u_int32_t	int
flags	int
,	O
*	O
levelp	pointer
,	O
*	O
nrecsp	pointer
,	O
*	O
relenp	pointer
;	O
{	O
BINTERNAL	struct
*	O
li	pointer
,	O
*	O
ri	pointer
,	O
*	O
lp	pointer
,	O
*	O
rp	pointer
;	O
DB	struct
*	O
pgset	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
VRFY_CHILDINFO	struct
*	O
child	struct
;	O
VRFY_PAGEINFO	struct
*	O
pip	pointer
;	O
db_recno_t	int
nrecs	int
,	O
child_nrecs	int
;	O
db_indx_t	short
i	short
;	O
int	O
ret	int
,	O
t_ret	int
,	O
isbad	int
,	O
toplevel	int
,	O
p	pointer
;	O
u_int32_t	int
level	char
,	O
child_level	int
,	O
stflags	int
,	O
child_relen	int
,	O
relen	int
;	O
DBC	struct
*	O
cc	pointer
;	O
ret	int
=	O
isbad	int
=	O
0	int
;	O
nrecs	int
=	O
0	int
;	O
h	pointer
=	O
NULL	O
;	O
relen	int
=	O
0	int
;	O
rp	pointer
=	O
(	O
BINTERNAL	struct
*	O
)	O
r	pointer
;	O
lp	pointer
=	O
(	O
BINTERNAL	struct
*	O
)	O
l	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_getpageinfo	function
(	O
vdp	pointer
,	O
pgno	int
,	O
&	O
pip	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
cc	pointer
=	O
NULL	O
;	O
level	char
=	O
pip	pointer
->	O
bt_level	char
;	O
toplevel	int
=	O
LF_ISSET	O
(	O
ST_TOPLEVEL	int
)	O
;	O
LF_CLR	O
(	O
ST_TOPLEVEL	int
)	O
;	O
switch	O
(	O
pip	pointer
->	O
type	enum
)	O
{	O
case	O
P_LRECNO	int
:	O
case	O
P_LDUP	int
:	O
case	O
P_LBTREE	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_childcursor	function
(	O
vdp	pointer
,	O
&	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
ret	int
=	O
CDB___db_vrfy_ccset	function
(	O
cc	pointer
,	O
pgno	int
,	O
&	O
child	struct
)	O
;	O
ret	int
==	O
0	int
;	O
ret	int
=	O
CDB___db_vrfy_ccnext	function
(	O
cc	pointer
,	O
&	O
child	struct
)	O
)	O
if	O
(	O
child	struct
->	O
type	enum
==	O
V_OVERFLOW	int
&&	O
(	O
ret	int
=	O
CDB___db_vrfy_ovfl_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
child	struct
->	O
pgno	int
,	O
child	struct
->	O
tlen	int
,	O
flags	int
|	O
ST_OVFL_LEAF	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
done	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_ccclose	function
(	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
cc	pointer
=	O
NULL	O
;	O
if	O
(	O
pip	pointer
->	O
type	enum
==	O
P_LRECNO	int
)	O
{	O
if	O
(	O
!	O
LF_ISSET	O
(	O
ST_IS_RECNO	int
)	O
&&	O
!	O
(	O
LF_ISSET	O
(	O
ST_DUPOK	int
)	O
&&	O
!	O
LF_ISSET	O
(	O
ST_DUPSORT	int
)	O
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Recno leaf page %lu in non-recno tree"	pointer
,	O
pgno	int
)	O
)	O
;	O
goto	O
done	O
;	O
}	O
goto	O
leaf	O
;	O
}	O
else	O
if	O
(	O
LF_ISSET	O
(	O
ST_IS_RECNO	int
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Non-recno leaf page %lu in recno tree"	pointer
,	O
pgno	int
)	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
pip	pointer
->	O
type	enum
==	O
P_LDUP	int
)	O
goto	O
leaf	O
;	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_HAS_DUPS	int
)	O
)	O
{	O
if	O
(	O
!	O
LF_ISSET	O
(	O
ST_DUPOK	int
)	O
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Duplicates on page %lu in non-dup btree"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_childcursor	function
(	O
vdp	pointer
,	O
&	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
ret	int
=	O
CDB___db_vrfy_ccset	function
(	O
cc	pointer
,	O
pgno	int
,	O
&	O
child	struct
)	O
;	O
ret	int
==	O
0	int
;	O
ret	int
=	O
CDB___db_vrfy_ccnext	function
(	O
cc	pointer
,	O
&	O
child	struct
)	O
)	O
{	O
stflags	int
=	O
flags	int
|	O
ST_RECNUM	int
;	O
if	O
(	O
child	struct
->	O
type	enum
==	O
V_DUPLICATE	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_duptype	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
child	struct
->	O
pgno	int
,	O
stflags	int
)	O
)	O
!=	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_subtree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
child	struct
->	O
pgno	int
,	O
NULL	O
,	O
NULL	O
,	O
stflags	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
!=	O
DB_VERIFY_BAD	O
)	O
goto	O
err	pointer
;	O
else	O
isbad	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_ccclose	function
(	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
cc	pointer
=	O
NULL	O
;	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_DUPS_UNSORTED	int
)	O
&&	O
LF_ISSET	O
(	O
ST_DUPSORT	int
)	O
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Unsorted duplicate set at page %lu in sorted-dup database"	pointer
,	O
pgno	int
)	O
)	O
;	O
isbad	int
=	O
1	int
;	O
}	O
}	O
}	O
goto	O
leaf	O
;	O
break	O
;	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
break	O
;	O
default	O
:	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___bam_vrfy_subtree"	pointer
,	O
pgno	int
,	O
pip	pointer
->	O
type	enum
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_childcursor	function
(	O
vdp	pointer
,	O
&	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
ret	int
=	O
CDB___db_vrfy_ccset	function
(	O
cc	pointer
,	O
pgno	int
,	O
&	O
child	struct
)	O
;	O
ret	int
==	O
0	int
;	O
ret	int
=	O
CDB___db_vrfy_ccnext	function
(	O
cc	pointer
,	O
&	O
child	struct
)	O
)	O
if	O
(	O
child	struct
->	O
type	enum
==	O
V_RECNO	int
)	O
{	O
if	O
(	O
pip	pointer
->	O
type	enum
!=	O
P_IRECNO	int
)	O
{	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___bam_vrfy_subtree"	pointer
,	O
pgno	int
,	O
pip	pointer
->	O
type	enum
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_subtree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
child	struct
->	O
pgno	int
,	O
NULL	O
,	O
NULL	O
,	O
flags	int
,	O
&	O
child_level	int
,	O
&	O
child_nrecs	int
,	O
&	O
child_relen	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
!=	O
DB_VERIFY_BAD	O
)	O
goto	O
done	O
;	O
else	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
ST_RELEN	int
)	O
)	O
{	O
if	O
(	O
relen	int
==	O
0	int
)	O
relen	int
=	O
child_relen	int
;	O
else	O
if	O
(	O
child_relen	int
>	O
0	int
&&	O
relen	int
!=	O
child_relen	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Recno page %lu returned bad re_len"	pointer
,	O
child	struct
->	O
pgno	int
)	O
)	O
;	O
}	O
if	O
(	O
relenp	pointer
)	O
*	O
relenp	pointer
=	O
relen	int
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
ST_RECNUM	int
)	O
)	O
nrecs	int
+=	O
child_nrecs	int
;	O
if	O
(	O
level	char
!=	O
child_level	int
+	O
1	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"%s%lu%s%lu%s%lu"	pointer
,	O
"Recno level incorrect on page "	pointer
,	O
child	struct
->	O
pgno	int
,	O
": got "	pointer
,	O
child_level	int
,	O
", expected "	pointer
,	O
level	char
-	O
1	int
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
child	struct
->	O
type	enum
==	O
V_OVERFLOW	int
&&	O
(	O
ret	int
=	O
CDB___db_vrfy_ovfl_structure	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
child	struct
->	O
pgno	int
,	O
child	struct
->	O
tlen	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
done	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_ccclose	function
(	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
cc	pointer
=	O
NULL	O
;	O
if	O
(	O
pip	pointer
->	O
type	enum
==	O
P_IRECNO	int
)	O
goto	O
done	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
pip	pointer
->	O
entries	short
;	O
i	short
+=	O
O_INDX	int
)	O
{	O
li	pointer
=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
i	short
)	O
;	O
ri	pointer
=	O
(	O
i	short
+	O
O_INDX	int
<	O
pip	pointer
->	O
entries	short
)	O
?	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
i	short
+	O
O_INDX	int
)	O
:	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_subtree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
li	pointer
->	O
pgno	int
,	O
i	short
==	O
0	int
?	O
NULL	O
:	O
li	pointer
,	O
ri	pointer
,	O
flags	int
,	O
&	O
child_level	int
,	O
&	O
child_nrecs	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
!=	O
DB_VERIFY_BAD	O
)	O
goto	O
done	O
;	O
else	O
isbad	int
=	O
1	int
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
ST_RECNUM	int
)	O
)	O
{	O
nrecs	int
+=	O
child_nrecs	int
;	O
if	O
(	O
li	pointer
->	O
nrecs	int
!=	O
child_nrecs	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Item %lu page %lu has incorrect record count of %lu, should be %lu"	pointer
,	O
i	short
,	O
pgno	int
,	O
li	pointer
->	O
nrecs	int
,	O
child_nrecs	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
level	char
!=	O
child_level	int
+	O
1	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"%s%lu%s%lu%s%lu"	pointer
,	O
"Btree level incorrect on page "	pointer
,	O
li	pointer
->	O
pgno	int
,	O
": got "	pointer
,	O
child_level	int
,	O
", expected "	pointer
,	O
level	char
-	O
1	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
0	int
)	O
{	O
leaf	O
:	O
level	char
=	O
LEAFLEVEL	int
;	O
if	O
(	O
LF_ISSET	O
(	O
ST_RECNUM	int
)	O
)	O
nrecs	int
=	O
pip	pointer
->	O
rec_cnt	int
;	O
if	O
(	O
LF_ISSET	O
(	O
ST_RELEN	int
)	O
&&	O
relenp	pointer
)	O
*	O
relenp	pointer
=	O
pip	pointer
->	O
re_len	int
;	O
}	O
done	O
:	O
if	O
(	O
F_ISSET	O
(	O
pip	pointer
,	O
VRFY_INCOMPLETE	int
)	O
&&	O
isbad	int
==	O
0	int
&&	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
h	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy_itemorder	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
F_CLR	O
(	O
pip	pointer
,	O
VRFY_INCOMPLETE	int
)	O
;	O
}	O
if	O
(	O
isbad	int
==	O
0	int
&&	O
ret	int
==	O
0	int
&&	O
!	O
LF_ISSET	O
(	O
DB_NOORDERCHK	int
)	O
&&	O
lp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
h	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pgno	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_vrfy_treeorder	function
(	O
dbp	pointer
,	O
pgno	int
,	O
h	pointer
,	O
lp	pointer
,	O
rp	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
DB_VERIFY_BAD	O
)	O
isbad	int
=	O
1	int
;	O
else	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
LF_ISSET	O
(	O
ST_RECNUM	int
)	O
&&	O
nrecs	int
!=	O
pip	pointer
->	O
rec_cnt	int
&&	O
toplevel	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Bad record count on page %lu: got %lu, expected %lu"	pointer
,	O
pgno	int
,	O
nrecs	int
,	O
pip	pointer
->	O
rec_cnt	int
)	O
)	O
;	O
}	O
if	O
(	O
levelp	pointer
)	O
*	O
levelp	pointer
=	O
level	char
;	O
if	O
(	O
nrecsp	pointer
)	O
*	O
nrecsp	pointer
=	O
nrecs	int
;	O
pgset	pointer
=	O
vdp	pointer
->	O
pgset	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
pgno	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
p	pointer
!=	O
0	int
)	O
{	O
isbad	int
=	O
1	int
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Page %lu linked twice"	pointer
,	O
pgno	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
pgset	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
err	pointer
:	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_putpageinfo	function
(	O
vdp	pointer
,	O
pip	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
cc	pointer
!=	O
NULL	O
&&	O
(	O
(	O
t_ret	int
=	O
CDB___db_vrfy_ccclose	function
(	O
cc	pointer
)	O
)	O
!=	O
0	int
)	O
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
(	O
ret	int
==	O
0	int
&&	O
isbad	int
==	O
1	int
)	O
?	O
DB_VERIFY_BAD	O
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_vrfy_treeorder	function
(	O
dbp	pointer
,	O
pgno	int
,	O
h	pointer
,	O
lp	pointer
,	O
rp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
PAGE	struct
*	O
h	pointer
;	O
BINTERNAL	struct
*	O
lp	pointer
,	O
*	O
rp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
BTREE	struct
*	O
t	pointer
;	O
DBT	struct
dbt	struct
;	O
db_indx_t	short
last	short
;	O
int	O
(	O
*	O
func	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
int	O
ret	int
,	O
cmp	int
;	O
memset	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
F_SET	O
(	O
&	O
dbt	struct
,	O
DB_DBT_MALLOC	int
)	O
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
func	pointer
=	O
(	O
t	pointer
->	O
bt_compare	pointer
!=	O
NULL	O
)	O
?	O
t	pointer
->	O
bt_compare	pointer
:	O
CDB___bam_defcmp	function
;	O
ret	int
=	O
0	int
;	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_LDUP	int
:	O
last	short
=	O
NUM_ENT	O
(	O
h	pointer
)	O
-	O
O_INDX	int
;	O
break	O
;	O
case	O
P_LBTREE	int
:	O
last	short
=	O
NUM_ENT	O
(	O
h	pointer
)	O
-	O
P_INDX	int
;	O
break	O
;	O
default	O
:	O
TYPE_ERR_PRINT	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__bam_vrfy_treeorder"	pointer
,	O
pgno	int
,	O
TYPE	O
(	O
h	pointer
)	O
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
lp	pointer
!=	O
NULL	O
&&	O
TYPE	O
(	O
h	pointer
)	O
!=	O
P_IBTREE	int
)	O
{	O
if	O
(	O
lp	pointer
->	O
type	enum
==	O
B_KEYDATA	int
)	O
{	O
dbt	struct
.	O
data	pointer
=	O
lp	pointer
->	O
data	pointer
;	O
dbt	struct
.	O
size	int
=	O
lp	pointer
->	O
len	short
;	O
}	O
else	O
if	O
(	O
lp	pointer
->	O
type	enum
==	O
B_OVERFLOW	int
)	O
{	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
lp	pointer
->	O
data	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_goff	function
(	O
dbp	pointer
,	O
&	O
dbt	struct
,	O
bo	pointer
->	O
tlen	int
,	O
bo	pointer
->	O
pgno	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Unknown type for internal record"	pointer
)	O
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
&	O
dbt	struct
,	O
h	pointer
,	O
0	int
,	O
func	pointer
,	O
&	O
cmp	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
cmp	int
>	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"First item on page %lu sorted greater than parent entry"	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
}	O
}	O
else	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"First item on page %lu had comparison error"	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
)	O
)	O
;	O
if	O
(	O
dbt	struct
.	O
data	pointer
!=	O
lp	pointer
->	O
data	pointer
)	O
CDB___os_free	function
(	O
dbt	struct
.	O
data	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
rp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
rp	pointer
->	O
type	enum
==	O
B_KEYDATA	int
)	O
{	O
dbt	struct
.	O
data	pointer
=	O
rp	pointer
->	O
data	pointer
;	O
dbt	struct
.	O
size	int
=	O
rp	pointer
->	O
len	short
;	O
}	O
else	O
if	O
(	O
rp	pointer
->	O
type	enum
==	O
B_OVERFLOW	int
)	O
{	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
rp	pointer
->	O
data	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_goff	function
(	O
dbp	pointer
,	O
&	O
dbt	struct
,	O
bo	pointer
->	O
tlen	int
,	O
bo	pointer
->	O
pgno	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Unknown type for internal record"	pointer
)	O
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
&	O
dbt	struct
,	O
h	pointer
,	O
last	short
,	O
func	pointer
,	O
&	O
cmp	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
cmp	int
<	O
0	int
)	O
{	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Last item on page %lu sorted greater than parent entry"	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
)	O
)	O
;	O
ret	int
=	O
DB_VERIFY_BAD	O
;	O
}	O
}	O
else	O
EPRINT	O
(	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Last item on page %lu had comparison error"	pointer
,	O
PGNO	O
(	O
h	pointer
)	O
)	O
)	O
;	O
if	O
(	O
dbt	struct
.	O
data	pointer
!=	O
rp	pointer
->	O
data	pointer
)	O
CDB___os_free	function
(	O
dbt	struct
.	O
data	pointer
,	O
0	int
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_salvage	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
pgno	int
,	O
pgtype	int
,	O
h	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
key	struct
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
pgtype	int
;	O
PAGE	struct
*	O
h	pointer
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
flags	int
;	O
{	O
DBT	struct
dbt	struct
,	O
unkdbt	struct
;	O
BKEYDATA	struct
*	O
bk	pointer
;	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
db_indx_t	short
i	short
,	O
beg	short
,	O
end	short
;	O
u_int32_t	int
himark	short
;	O
u_int8_t	char
*	O
pgmap	pointer
;	O
void	O
*	O
ovflbuf	pointer
;	O
int	O
t_ret	int
,	O
ret	int
,	O
err_ret	int
;	O
COMPQUIET	O
(	O
end	short
,	O
0	int
)	O
;	O
ovflbuf	pointer
=	O
pgmap	pointer
=	O
NULL	O
;	O
err_ret	int
=	O
ret	int
=	O
0	int
;	O
memset	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
dbt	struct
.	O
flags	int
=	O
DB_DBT_REALLOC	int
;	O
memset	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
unkdbt	struct
.	O
size	int
=	O
strlen	function
(	O
"UNKNOWN"	pointer
)	O
+	O
1	int
;	O
unkdbt	struct
.	O
data	pointer
=	O
"UNKNOWN"	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
ovflbuf	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
pgmap	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memset	function
(	O
pgmap	pointer
,	O
0	int
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
}	O
i	short
=	O
0	int
;	O
himark	short
=	O
dbp	pointer
->	O
pgsize	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
&&	O
i	short
>=	O
NUM_ENT	O
(	O
h	pointer
)	O
)	O
break	O
;	O
ret	int
=	O
CDB___db_vrfy_inpitem	function
(	O
dbp	pointer
,	O
h	pointer
,	O
pgno	int
,	O
i	short
,	O
1	int
,	O
flags	int
,	O
&	O
himark	short
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	int
==	O
DB_VERIFY_FATAL	O
)	O
break	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
key	struct
!=	O
NULL	O
&&	O
(	O
i	short
!=	O
0	int
||	O
!	O
LF_ISSET	O
(	O
SA_SKIPFIRSTKEY	int
)	O
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
key	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	short
)	O
;	O
beg	short
=	O
h	pointer
->	O
inp	array
[	O
i	short
]	O
;	O
switch	O
(	O
bk	pointer
->	O
type	enum
)	O
{	O
case	O
B_DUPLICATE	int
:	O
end	short
=	O
beg	short
+	O
BOVERFLOW_SIZE	O
-	O
1	int
;	O
if	O
(	O
pgtype	int
!=	O
P_LBTREE	int
)	O
break	O
;	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
;	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
bo	pointer
->	O
pgno	int
)	O
||	O
(	O
i	short
%	O
P_INDX	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_salvage_duptree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
bo	pointer
->	O
pgno	int
,	O
&	O
dbt	struct
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
|	O
SA_SKIPFIRSTKEY	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
)	O
break	O
;	O
case	O
B_KEYDATA	int
:	O
end	short
=	O
ALIGN	O
(	O
beg	short
+	O
bk	pointer
->	O
len	short
,	O
4	int
)	O
-	O
1	int
;	O
dbt	struct
.	O
data	pointer
=	O
bk	pointer
->	O
data	pointer
;	O
dbt	struct
.	O
size	int
=	O
bk	pointer
->	O
len	short
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
case	O
B_OVERFLOW	int
:	O
end	short
=	O
beg	short
+	O
BOVERFLOW_SIZE	O
-	O
1	int
;	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_safe_goff	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
bo	pointer
->	O
pgno	int
,	O
&	O
dbt	struct
,	O
&	O
ovflbuf	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
(	O
void	O
)	O
CDB___db_prdbt	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
dbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_AGGRESSIVE	int
)	O
)	O
{	O
pgmap	pointer
[	O
beg	short
]	O
=	O
ITEM_BEGIN	int
;	O
pgmap	pointer
[	O
end	short
]	O
=	O
ITEM_END	int
;	O
}	O
}	O
i	short
+=	O
O_INDX	int
;	O
}	O
if	O
(	O
pgtype	int
==	O
P_LBTREE	int
&&	O
(	O
i	short
%	O
P_INDX	int
==	O
1	int
)	O
&&	O
(	O
(	O
ret	int
=	O
CDB___db_prdbt	function
(	O
&	O
unkdbt	struct
,	O
0	int
,	O
" "	pointer
,	O
handle	pointer
,	O
callback	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
)	O
err_ret	int
=	O
ret	int
;	O
err	pointer
:	O
if	O
(	O
pgmap	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
pgmap	pointer
,	O
0	int
)	O
;	O
CDB___os_free	function
(	O
ovflbuf	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_salvage_markdone	function
(	O
vdp	pointer
,	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
t_ret	int
)	O
;	O
return	O
(	O
(	O
err_ret	int
!=	O
0	int
)	O
?	O
err_ret	int
:	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_salvage_walkdupint	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
key	struct
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
DBT	struct
*	O
key	struct
;	O
void	O
*	O
handle	pointer
;	O
int	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
u_int32_t	int
flags	int
;	O
{	O
RINTERNAL	struct
*	O
ri	pointer
;	O
BINTERNAL	struct
*	O
bi	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
db_indx_t	short
i	short
;	O
ret	int
=	O
0	int
;	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
NUM_ENT	O
(	O
h	pointer
)	O
;	O
i	short
++	O
)	O
{	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
bi	pointer
=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
i	short
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_salvage_duptree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
bi	pointer
->	O
pgno	int
,	O
key	struct
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
case	O
P_IRECNO	int
:	O
ri	pointer
=	O
GET_RINTERNAL	O
(	O
h	pointer
,	O
i	short
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_salvage_duptree	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
ri	pointer
->	O
pgno	int
,	O
key	struct
,	O
handle	pointer
,	O
callback	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
break	O
;	O
default	O
:	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___bam_salvage_walkdupint called on non-int. page"	pointer
)	O
;	O
DB_ASSERT	O
(	O
0	int
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
flags	int
&=	O
~	O
LF_ISSET	O
(	O
SA_SKIPFIRSTKEY	int
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_meta2pgset	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
btmeta	pointer
,	O
flags	int
,	O
pgset	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
VRFY_DBINFO	struct
*	O
vdp	pointer
;	O
BTMETA	struct
*	O
btmeta	pointer
;	O
u_int32_t	int
flags	int
;	O
DB	struct
*	O
pgset	pointer
;	O
{	O
BINTERNAL	struct
*	O
bi	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
RINTERNAL	struct
*	O
ri	pointer
;	O
db_pgno_t	int
current	int
,	O
p	pointer
;	O
int	O
err_ret	int
,	O
ret	int
;	O
h	pointer
=	O
NULL	O
;	O
ret	int
=	O
err_ret	int
=	O
0	int
;	O
DB_ASSERT	O
(	O
pgset	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
current	int
=	O
btmeta	pointer
->	O
root	int
;	O
;	O
)	O
{	O
if	O
(	O
!	O
IS_VALID_PGNO	O
(	O
current	int
)	O
||	O
current	int
==	O
PGNO	O
(	O
btmeta	pointer
)	O
)	O
{	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
current	int
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
goto	O
err	pointer
;	O
}	O
switch	O
(	O
TYPE	O
(	O
h	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
case	O
P_IRECNO	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_vrfy	function
(	O
dbp	pointer
,	O
vdp	pointer
,	O
h	pointer
,	O
current	int
,	O
flags	int
|	O
DB_NOORDERCHK	int
)	O
)	O
!=	O
0	int
)	O
{	O
err_ret	int
=	O
ret	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_IBTREE	int
)	O
{	O
bi	pointer
=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
0	int
)	O
;	O
current	int
=	O
bi	pointer
->	O
pgno	int
;	O
}	O
else	O
{	O
ri	pointer
=	O
GET_RINTERNAL	O
(	O
h	pointer
,	O
0	int
)	O
;	O
current	int
=	O
ri	pointer
->	O
pgno	int
;	O
}	O
break	O
;	O
case	O
P_LBTREE	int
:	O
case	O
P_LRECNO	int
:	O
goto	O
traverse	O
;	O
default	O
:	O
err_ret	int
=	O
DB_VERIFY_BAD	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
h	pointer
=	O
NULL	O
;	O
}	O
traverse	O
:	O
while	O
(	O
IS_VALID_PGNO	O
(	O
current	int
)	O
&&	O
current	int
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
h	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
current	int
,	O
0	int
,	O
&	O
h	pointer
)	O
!=	O
0	int
)	O
)	O
{	O
err_ret	int
=	O
ret	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_get	function
(	O
pgset	pointer
,	O
current	int
,	O
(	O
int	O
*	O
)	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
p	pointer
!=	O
0	int
)	O
{	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_vrfy_pgset_inc	function
(	O
pgset	pointer
,	O
current	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
current	int
=	O
NEXT_PGNO	O
(	O
h	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
err_ret	int
=	O
ret	int
;	O
h	pointer
=	O
NULL	O
;	O
}	O
err	pointer
:	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
==	O
0	int
?	O
err_ret	int
:	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_safe_getdata	function
(	O
dbp	pointer
,	O
h	pointer
,	O
i	short
,	O
ovflok	int
,	O
dbt	struct
,	O
freedbtp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
u_int32_t	int
i	short
;	O
int	O
ovflok	int
;	O
DBT	struct
*	O
dbt	struct
;	O
int	O
*	O
freedbtp	pointer
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
;	O
BOVERFLOW	struct
*	O
bo	pointer
;	O
memset	function
(	O
dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
DBT	struct
)	O
)	O
;	O
*	O
freedbtp	pointer
=	O
0	int
;	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
i	short
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
{	O
if	O
(	O
!	O
ovflok	int
)	O
return	O
(	O
0	int
)	O
;	O
bo	pointer
=	O
(	O
BOVERFLOW	struct
*	O
)	O
bk	pointer
;	O
F_SET	O
(	O
dbt	struct
,	O
DB_DBT_MALLOC	int
)	O
;	O
*	O
freedbtp	pointer
=	O
1	int
;	O
return	O
(	O
CDB___db_goff	function
(	O
dbp	pointer
,	O
dbt	struct
,	O
bo	pointer
->	O
tlen	int
,	O
bo	pointer
->	O
pgno	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
;	O
}	O
else	O
{	O
dbt	struct
->	O
data	pointer
=	O
bk	pointer
->	O
data	pointer
;	O
dbt	struct
->	O
size	int
=	O
bk	pointer
->	O
len	short
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
