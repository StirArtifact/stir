struct	O
_mu_acl_entry	struct
{	O
mu_acl_action_t	enum
action	enum
;	O
void	O
*	O
arg	pointer
;	O
struct	O
mu_cidr	struct
cidr	pointer
;	O
}	O
;	O
struct	O
_mu_acl	struct
{	O
mu_list_t	pointer
aclist	pointer
;	O
char	O
*	O
*	O
envv	pointer
;	O
size_t	long
envc	long
;	O
size_t	long
envn	long
;	O
}	O
;	O
struct	O
run_closure	struct
{	O
unsigned	O
idx	int
;	O
struct	O
mu_cidr	struct
addr	int
;	O
char	O
*	O
*	O
env	pointer
;	O
char	O
ipstr	array
[	O
40	int
]	O
;	O
char	O
*	O
addrstr	pointer
;	O
mu_acl_result_t	enum
*	O
result	pointer
;	O
}	O
;	O
static	O
void	O
_destroy_acl_entry	function
(	O
void	O
*	O
item	pointer
)	O
{	O
struct	O
_mu_acl_entry	struct
*	O
p	pointer
=	O
item	pointer
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
int	O
mu_acl_entry_create	function
(	O
struct	O
_mu_acl_entry	struct
*	O
*	O
pent	pointer
,	O
mu_acl_action_t	enum
action	enum
,	O
void	O
*	O
data	pointer
,	O
struct	O
mu_cidr	struct
*	O
cidr	pointer
)	O
{	O
struct	O
_mu_acl_entry	struct
*	O
p	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
EINVAL	int
;	O
p	pointer
->	O
action	enum
=	O
action	enum
;	O
p	pointer
->	O
arg	pointer
=	O
data	pointer
;	O
memcpy	function
(	O
&	O
p	pointer
->	O
cidr	pointer
,	O
cidr	pointer
,	O
sizeof	O
(	O
p	pointer
->	O
cidr	pointer
)	O
)	O
;	O
*	O
pent	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_acl_create	function
(	O
mu_acl_t	pointer
*	O
pacl	pointer
)	O
{	O
int	O
rc	int
;	O
mu_acl_t	pointer
acl	pointer
;	O
acl	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
acl	pointer
)	O
)	O
;	O
if	O
(	O
!	O
acl	pointer
)	O
return	O
errno	O
;	O
rc	int
=	O
mu_list_create	function
(	O
&	O
acl	pointer
->	O
aclist	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
free	function
(	O
acl	pointer
)	O
;	O
else	O
*	O
pacl	pointer
=	O
acl	pointer
;	O
mu_list_set_destroy_item	function
(	O
acl	pointer
->	O
aclist	pointer
,	O
_destroy_acl_entry	function
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_acl_count	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
if	O
(	O
!	O
acl	pointer
)	O
return	O
EINVAL	int
;	O
return	O
mu_list_count	function
(	O
acl	pointer
->	O
aclist	pointer
,	O
pcount	pointer
)	O
;	O
}	O
int	O
mu_acl_destroy	function
(	O
mu_acl_t	pointer
*	O
pacl	pointer
)	O
{	O
size_t	long
i	long
;	O
mu_acl_t	pointer
acl	pointer
;	O
if	O
(	O
!	O
pacl	pointer
||	O
!	O
*	O
pacl	pointer
)	O
return	O
EINVAL	int
;	O
acl	pointer
=	O
*	O
pacl	pointer
;	O
mu_list_destroy	function
(	O
&	O
acl	pointer
->	O
aclist	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
acl	pointer
->	O
envc	long
&&	O
acl	pointer
->	O
envv	pointer
[	O
i	long
]	O
;	O
i	long
++	O
)	O
free	function
(	O
acl	pointer
->	O
envv	pointer
[	O
i	long
]	O
)	O
;	O
free	function
(	O
acl	pointer
->	O
envv	pointer
)	O
;	O
free	function
(	O
acl	pointer
)	O
;	O
*	O
pacl	pointer
=	O
acl	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_acl_get_iterator	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
mu_iterator_t	pointer
*	O
pitr	pointer
)	O
{	O
if	O
(	O
!	O
acl	pointer
)	O
return	O
EINVAL	int
;	O
return	O
mu_list_get_iterator	function
(	O
acl	pointer
->	O
aclist	pointer
,	O
pitr	pointer
)	O
;	O
}	O
int	O
mu_acl_append	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
mu_acl_action_t	enum
act	enum
,	O
void	O
*	O
data	pointer
,	O
struct	O
mu_cidr	struct
*	O
cidr	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
_mu_acl_entry	struct
*	O
ent	pointer
;	O
if	O
(	O
!	O
acl	pointer
)	O
return	O
EINVAL	int
;	O
rc	int
=	O
mu_acl_entry_create	function
(	O
&	O
ent	pointer
,	O
act	enum
,	O
data	pointer
,	O
cidr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot allocate ACL entry: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_list_append	function
(	O
acl	pointer
->	O
aclist	pointer
,	O
ent	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot append ACL entry: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
free	function
(	O
ent	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_acl_prepend	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
mu_acl_action_t	enum
act	enum
,	O
void	O
*	O
data	pointer
,	O
struct	O
mu_cidr	struct
*	O
cidr	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
_mu_acl_entry	struct
*	O
ent	pointer
;	O
if	O
(	O
!	O
acl	pointer
)	O
return	O
EINVAL	int
;	O
rc	int
=	O
mu_acl_entry_create	function
(	O
&	O
ent	pointer
,	O
act	enum
,	O
data	pointer
,	O
cidr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot allocate ACL entry: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_list_prepend	function
(	O
acl	pointer
->	O
aclist	pointer
,	O
ent	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot prepend ACL entry: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
free	function
(	O
ent	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_acl_insert	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
size_t	long
pos	long
,	O
int	O
before	int
,	O
mu_acl_action_t	enum
act	enum
,	O
void	O
*	O
data	pointer
,	O
struct	O
mu_cidr	struct
*	O
cidr	pointer
)	O
{	O
int	O
rc	int
;	O
void	O
*	O
ptr	pointer
;	O
struct	O
_mu_acl_entry	struct
*	O
ent	pointer
;	O
if	O
(	O
!	O
acl	pointer
)	O
return	O
EINVAL	int
;	O
rc	int
=	O
mu_list_get	function
(	O
acl	pointer
->	O
aclist	pointer
,	O
pos	long
,	O
&	O
ptr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"No such entry %lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
pos	long
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_acl_entry_create	function
(	O
&	O
ent	pointer
,	O
act	enum
,	O
data	pointer
,	O
cidr	pointer
)	O
;	O
if	O
(	O
!	O
ent	pointer
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot allocate ACL entry: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_list_insert	function
(	O
acl	pointer
->	O
aclist	pointer
,	O
ptr	pointer
,	O
ent	pointer
,	O
before	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot insert ACL entry: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
free	function
(	O
ent	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
mu_kwd_t	struct
action_tab	array
[	O
]	O
=	O
{	O
{	O
"accept"	pointer
,	O
mu_acl_accept	int
}	O
,	O
{	O
"deny"	pointer
,	O
mu_acl_deny	int
}	O
,	O
{	O
"log"	pointer
,	O
mu_acl_log	int
}	O
,	O
{	O
"exec"	pointer
,	O
mu_acl_exec	int
}	O
,	O
{	O
"ifexec"	pointer
,	O
mu_acl_ifexec	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
mu_acl_action_to_string	function
(	O
mu_acl_action_t	enum
act	enum
,	O
const	O
char	O
*	O
*	O
pstr	pointer
)	O
{	O
return	O
mu_kwd_xlat_tok	function
(	O
action_tab	array
,	O
act	enum
,	O
pstr	pointer
)	O
;	O
}	O
int	O
mu_acl_string_to_action	function
(	O
const	O
char	O
*	O
str	pointer
,	O
mu_acl_action_t	enum
*	O
pres	pointer
)	O
{	O
int	O
x	int
;	O
int	O
rc	int
=	O
mu_kwd_xlat_name	function
(	O
action_tab	array
,	O
str	pointer
,	O
&	O
x	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
pres	pointer
=	O
x	int
;	O
return	O
rc	int
;	O
}	O
int	O
_acl_match	function
(	O
struct	O
_mu_acl_entry	struct
*	O
ent	pointer
,	O
struct	O
run_closure	struct
*	O
rp	pointer
)	O
{	O
if	O
(	O
mu_debug_level_p	function
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE9	int
)	O
)	O
{	O
char	O
*	O
s	pointer
=	O
NULL	O
;	O
int	O
rc	int
;	O
if	O
(	O
ent	pointer
->	O
cidr	pointer
.	O
len	long
&&	O
(	O
rc	int
=	O
mu_cidr_format	function
(	O
&	O
ent	pointer
->	O
cidr	pointer
,	O
0	int
,	O
&	O
s	pointer
)	O
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"mu_cidr_format: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
rp	pointer
->	O
addrstr	pointer
)	O
mu_cidr_format	function
(	O
&	O
rp	pointer
->	O
addr	int
,	O
MU_CIDR_FMT_ADDRONLY	int
,	O
&	O
rp	pointer
->	O
addrstr	pointer
)	O
;	O
mu_debug_log_begin	function
(	O
"Does %s match %s? "	pointer
,	O
s	pointer
?	O
s	pointer
:	O
"any"	pointer
,	O
rp	pointer
->	O
addrstr	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
if	O
(	O
ent	pointer
->	O
cidr	pointer
.	O
len	long
>	O
0	int
&&	O
mu_cidr_match	function
(	O
&	O
ent	pointer
->	O
cidr	pointer
,	O
&	O
rp	pointer
->	O
addr	int
)	O
)	O
{	O
RESMATCH	O
(	O
"no"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
RESMATCH	O
(	O
"yes"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
acl_getvar	function
(	O
char	O
*	O
*	O
ret	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
nlen	long
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
run_closure	struct
*	O
rp	pointer
=	O
data	pointer
;	O
if	O
(	O
SEQ	O
(	O
"aclno"	pointer
,	O
name	pointer
,	O
nlen	long
)	O
)	O
{	O
if	O
(	O
mu_asprintf	function
(	O
ret	pointer
,	O
"%u"	pointer
,	O
rp	pointer
->	O
idx	int
)	O
)	O
return	O
MU_WRDSE_NOSPACE	O
;	O
return	O
MU_WRDSE_OK	O
;	O
}	O
else	O
if	O
(	O
SEQ	O
(	O
"address"	pointer
,	O
name	pointer
,	O
nlen	long
)	O
)	O
{	O
if	O
(	O
mu_cidr_format	function
(	O
&	O
rp	pointer
->	O
addr	int
,	O
MU_CIDR_FMT_ADDRONLY	int
,	O
ret	pointer
)	O
)	O
return	O
MU_WRDSE_NOSPACE	O
;	O
return	O
MU_WRDSE_OK	O
;	O
}	O
else	O
if	O
(	O
SEQ	O
(	O
"family"	pointer
,	O
name	pointer
,	O
nlen	long
)	O
)	O
{	O
char	O
*	O
s	pointer
;	O
switch	O
(	O
rp	pointer
->	O
addr	int
.	O
family	int
)	O
{	O
case	O
AF_INET	O
:	O
s	pointer
=	O
"AF_INET"	pointer
;	O
break	O
;	O
case	O
AF_INET6	O
:	O
s	pointer
=	O
"AF_INET6"	pointer
;	O
break	O
;	O
case	O
AF_UNIX	O
:	O
s	pointer
=	O
"AF_UNIX"	pointer
;	O
break	O
;	O
default	O
:	O
return	O
MU_WRDSE_UNDEF	O
;	O
}	O
*	O
ret	pointer
=	O
strdup	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
*	O
ret	pointer
)	O
return	O
MU_WRDSE_NOSPACE	O
;	O
return	O
MU_WRDSE_OK	O
;	O
}	O
return	O
MU_WRDSE_UNDEF	O
;	O
}	O
static	O
int	O
expand_arg	function
(	O
const	O
char	O
*	O
cmdline	pointer
,	O
struct	O
run_closure	struct
*	O
rp	pointer
,	O
char	O
*	O
*	O
s	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
int	O
envflag	int
=	O
0	int
;	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE	O
,	O
(	O
"Expanding \"%s\""	pointer
,	O
cmdline	pointer
)	O
)	O
;	O
if	O
(	O
rp	pointer
->	O
env	pointer
)	O
{	O
ws	pointer
.	O
ws_env	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
rp	pointer
->	O
env	pointer
;	O
envflag	int
=	O
MU_WRDSF_ENV	O
;	O
}	O
ws	pointer
.	O
ws_getvar	pointer
=	O
acl_getvar	function
;	O
ws	pointer
.	O
ws_closure	pointer
=	O
rp	pointer
;	O
rc	int
=	O
mu_wordsplit	struct
(	O
cmdline	pointer
,	O
&	O
ws	pointer
,	O
MU_WRDSF_NOSPLIT	O
|	O
MU_WRDSF_NOCMD	O
|	O
envflag	int
|	O
MU_WRDSF_ENV_KV	O
|	O
MU_WRDSF_GETVAR	O
|	O
MU_WRDSF_CLOSURE	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
*	O
s	pointer
=	O
strdup	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
)	O
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
if	O
(	O
!	O
*	O
s	pointer
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"failed: not enough memory."	pointer
)	O
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE	O
,	O
(	O
"Expansion: \"%s\". "	pointer
,	O
*	O
s	pointer
)	O
)	O
;	O
}	O
else	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"failed: %s"	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
)	O
;	O
rc	int
=	O
errno	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
spawn_prog	function
(	O
const	O
char	O
*	O
cmdline	pointer
,	O
int	O
*	O
pstatus	pointer
,	O
struct	O
run_closure	struct
*	O
rp	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
pid_t	int
pid	int
;	O
if	O
(	O
expand_arg	function
(	O
cmdline	pointer
,	O
rp	pointer
,	O
&	O
s	pointer
)	O
)	O
{	O
s	pointer
=	O
strdup	function
(	O
cmdline	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
ENOMEM	int
;	O
}	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
int	O
i	long
;	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
if	O
(	O
mu_wordsplit	struct
(	O
s	pointer
,	O
&	O
ws	pointer
,	O
MU_WRDSF_DEFFLAGS	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot split line `%s': %s"	pointer
)	O
,	O
s	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
mu_getmaxfd	function
(	O
)	O
;	O
i	long
>	O
2	int
;	O
i	long
--	O
)	O
close	function
(	O
i	long
)	O
;	O
execvp	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
,	O
ws	pointer
.	O
ws_wordv	pointer
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
free	function
(	O
s	pointer
)	O
;	O
if	O
(	O
pid	int
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"cannot fork: %s"	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
if	O
(	O
pstatus	pointer
)	O
{	O
int	O
status	int
;	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
status	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE	O
,	O
(	O
"Program finished with code %d."	pointer
,	O
status	int
)	O
)	O
;	O
*	O
pstatus	pointer
=	O
status	int
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Program terminated on signal %d."	pointer
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
)	O
;	O
return	O
MU_ERR_PROCESS_SIGNALED	O
;	O
}	O
else	O
return	O
MU_ERR_PROCESS_UNKNOWN_FAILURE	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_run_entry	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
status	int
=	O
0	int
;	O
struct	O
_mu_acl_entry	struct
*	O
ent	pointer
=	O
item	pointer
;	O
struct	O
run_closure	struct
*	O
rp	pointer
=	O
data	pointer
;	O
rp	pointer
->	O
idx	int
++	O
;	O
if	O
(	O
mu_debug_level_p	function
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE9	int
)	O
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
"undefined"	pointer
;	O
mu_acl_action_to_string	function
(	O
ent	pointer
->	O
action	enum
,	O
&	O
s	pointer
)	O
;	O
mu_debug_log_begin	function
(	O
"%d:%s: "	pointer
,	O
rp	pointer
->	O
idx	int
,	O
s	pointer
)	O
;	O
}	O
if	O
(	O
_acl_match	function
(	O
ent	pointer
,	O
rp	pointer
)	O
==	O
0	int
)	O
{	O
switch	O
(	O
ent	pointer
->	O
action	enum
)	O
{	O
case	O
mu_acl_accept	int
:	O
*	O
rp	pointer
->	O
result	pointer
=	O
mu_acl_result_accept	int
;	O
status	int
=	O
MU_ERR_USER0	O
;	O
break	O
;	O
case	O
mu_acl_deny	int
:	O
*	O
rp	pointer
->	O
result	pointer
=	O
mu_acl_result_deny	int
;	O
status	int
=	O
MU_ERR_USER0	O
;	O
break	O
;	O
case	O
mu_acl_log	int
:	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
ent	pointer
->	O
arg	pointer
&&	O
expand_arg	function
(	O
ent	pointer
->	O
arg	pointer
,	O
rp	pointer
,	O
&	O
s	pointer
)	O
==	O
0	int
)	O
{	O
mu_diag_output	function
(	O
MU_DIAG_INFO	O
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
rp	pointer
->	O
addrstr	pointer
)	O
mu_cidr_format	function
(	O
&	O
rp	pointer
->	O
addr	int
,	O
MU_CIDR_FMT_ADDRONLY	int
,	O
&	O
rp	pointer
->	O
addrstr	pointer
)	O
;	O
mu_diag_output	function
(	O
MU_DIAG_INFO	O
,	O
"%s"	pointer
,	O
rp	pointer
->	O
addrstr	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
mu_acl_exec	int
:	O
spawn_prog	function
(	O
ent	pointer
->	O
arg	pointer
,	O
NULL	O
,	O
rp	pointer
)	O
;	O
break	O
;	O
case	O
mu_acl_ifexec	int
:	O
{	O
int	O
prog_status	int
;	O
int	O
rc	int
=	O
spawn_prog	function
(	O
ent	pointer
->	O
arg	pointer
,	O
&	O
prog_status	int
,	O
rp	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
switch	O
(	O
prog_status	int
)	O
{	O
case	O
0	int
:	O
*	O
rp	pointer
->	O
result	pointer
=	O
mu_acl_result_accept	int
;	O
status	int
=	O
MU_ERR_USER0	O
;	O
break	O
;	O
case	O
1	int
:	O
*	O
rp	pointer
->	O
result	pointer
=	O
mu_acl_result_deny	int
;	O
status	int
=	O
MU_ERR_USER0	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
mu_debug_level_p	function
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE9	int
)	O
)	O
mu_stream_flush	function
(	O
mu_strerr	pointer
)	O
;	O
return	O
status	int
;	O
}	O
int	O
mu_acl_check_sockaddr	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
const	O
struct	O
sockaddr	struct
*	O
sa	pointer
,	O
int	O
salen	int
,	O
mu_acl_result_t	enum
*	O
pres	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
run_closure	struct
r	struct
;	O
if	O
(	O
!	O
acl	pointer
)	O
return	O
EINVAL	int
;	O
memset	function
(	O
&	O
r	struct
,	O
0	int
,	O
sizeof	O
(	O
r	struct
)	O
)	O
;	O
if	O
(	O
sa	pointer
->	O
sa_family	short
==	O
AF_UNIX	O
)	O
{	O
*	O
pres	pointer
=	O
mu_acl_result_accept	int
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_cidr_from_sockaddr	function
(	O
&	O
r	struct
.	O
addr	int
,	O
sa	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
mu_debug_level_p	function
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_TRACE9	int
)	O
)	O
{	O
mu_cidr_format	function
(	O
&	O
r	struct
.	O
addr	int
,	O
MU_CIDR_FMT_ADDRONLY	int
,	O
&	O
r	struct
.	O
addrstr	pointer
)	O
;	O
mu_debug_log_begin	function
(	O
"Checking sockaddr %s"	pointer
,	O
r	struct
.	O
addrstr	pointer
)	O
;	O
mu_debug_log_nl	function
(	O
)	O
;	O
}	O
r	struct
.	O
idx	int
=	O
0	int
;	O
r	struct
.	O
result	pointer
=	O
pres	pointer
;	O
r	struct
.	O
env	pointer
=	O
acl	pointer
->	O
envv	pointer
;	O
*	O
r	struct
.	O
result	pointer
=	O
mu_acl_result_undefined	int
;	O
rc	int
=	O
mu_list_foreach	function
(	O
acl	pointer
->	O
aclist	pointer
,	O
_run_entry	function
,	O
&	O
r	struct
)	O
;	O
free	function
(	O
r	struct
.	O
addrstr	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_USER0	O
)	O
rc	int
=	O
0	int
;	O
return	O
rc	int
;	O
}	O
int	O
mu_acl_check_inaddr	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
const	O
struct	O
in_addr	struct
*	O
inp	pointer
,	O
mu_acl_result_t	enum
*	O
pres	pointer
)	O
{	O
struct	O
sockaddr_in	struct
cs	short
;	O
int	O
len	long
=	O
sizeof	O
cs	short
;	O
cs	short
.	O
sin_family	short
=	O
AF_INET	O
;	O
cs	short
.	O
sin_addr	struct
=	O
*	O
inp	pointer
;	O
cs	short
.	O
sin_addr	struct
.	O
s_addr	int
=	O
ntohl	function
(	O
cs	short
.	O
sin_addr	struct
.	O
s_addr	int
)	O
;	O
return	O
mu_acl_check_sockaddr	function
(	O
acl	pointer
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
cs	short
,	O
len	long
,	O
pres	pointer
)	O
;	O
}	O
int	O
mu_acl_check_ipv4	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
unsigned	O
int	O
addr	int
,	O
mu_acl_result_t	enum
*	O
pres	pointer
)	O
{	O
struct	O
in_addr	struct
in	pointer
;	O
in	pointer
.	O
s_addr	int
=	O
addr	int
;	O
return	O
mu_acl_check_inaddr	function
(	O
acl	pointer
,	O
&	O
in	pointer
,	O
pres	pointer
)	O
;	O
}	O
int	O
mu_acl_check_fd	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
int	O
fd	int
,	O
mu_acl_result_t	enum
*	O
pres	pointer
)	O
{	O
union	O
{	O
struct	O
sockaddr	struct
sa	pointer
;	O
struct	O
sockaddr_in	struct
in	pointer
;	O
struct	O
sockaddr_in6	struct
in6	struct
;	O
}	O
addr	int
;	O
socklen_t	int
len	long
=	O
sizeof	O
addr	int
;	O
if	O
(	O
getpeername	function
(	O
fd	int
,	O
&	O
addr	int
.	O
sa	pointer
,	O
&	O
len	long
)	O
<	O
0	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_ACL	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"Cannot obtain IP address of client: %s"	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
return	O
mu_acl_check_sockaddr	function
(	O
acl	pointer
,	O
&	O
addr	int
.	O
sa	pointer
,	O
len	long
,	O
pres	pointer
)	O
;	O
}	O
static	O
int	O
_acl_getenv	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
*	O
pres	pointer
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
!	O
acl	pointer
->	O
envv	pointer
)	O
return	O
MU_ERR_NOENT	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
acl	pointer
->	O
envc	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
acl	pointer
->	O
envv	pointer
[	O
i	long
]	O
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
*	O
pres	pointer
=	O
i	long
;	O
return	O
0	int
;	O
}	O
return	O
MU_ERR_NOENT	O
;	O
}	O
const	O
char	O
*	O
mu_acl_getenv	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
_acl_getenv	function
(	O
acl	pointer
,	O
name	pointer
,	O
&	O
i	long
)	O
==	O
0	int
)	O
{	O
return	O
acl	pointer
->	O
envv	pointer
[	O
i	long
+	O
1	int
]	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
_acl_env_store	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
int	O
i	long
,	O
const	O
char	O
*	O
val	array
)	O
{	O
char	O
*	O
copy	pointer
=	O
strdup	function
(	O
val	array
)	O
;	O
if	O
(	O
!	O
copy	pointer
)	O
return	O
ENOMEM	int
;	O
free	function
(	O
acl	pointer
->	O
envv	pointer
[	O
i	long
]	O
)	O
;	O
acl	pointer
->	O
envv	pointer
[	O
i	long
]	O
=	O
copy	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_acl_setenv	function
(	O
mu_acl_t	pointer
acl	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
val	array
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
_acl_getenv	function
(	O
acl	pointer
,	O
name	pointer
,	O
&	O
i	long
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
val	array
)	O
{	O
free	function
(	O
acl	pointer
->	O
envv	pointer
[	O
i	long
]	O
)	O
;	O
free	function
(	O
acl	pointer
->	O
envv	pointer
[	O
i	long
+	O
1	int
]	O
)	O
;	O
memmove	function
(	O
acl	pointer
->	O
envv	pointer
+	O
i	long
,	O
acl	pointer
->	O
envv	pointer
+	O
i	long
+	O
3	int
,	O
(	O
acl	pointer
->	O
envn	long
+	O
1	int
-	O
(	O
i	long
+	O
3	int
)	O
)	O
*	O
sizeof	O
(	O
acl	pointer
->	O
envv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
acl	pointer
->	O
envn	long
-=	O
2	int
;	O
return	O
0	int
;	O
}	O
return	O
_acl_env_store	function
(	O
acl	pointer
,	O
i	long
+	O
1	int
,	O
val	array
)	O
;	O
}	O
if	O
(	O
!	O
acl	pointer
->	O
envv	pointer
||	O
acl	pointer
->	O
envn	long
+	O
1	int
==	O
acl	pointer
->	O
envc	long
)	O
{	O
char	O
*	O
*	O
p	pointer
;	O
if	O
(	O
!	O
val	array
)	O
return	O
0	int
;	O
if	O
(	O
acl	pointer
->	O
envv	pointer
==	O
NULL	O
)	O
p	pointer
=	O
calloc	function
(	O
3	int
,	O
sizeof	O
(	O
acl	pointer
->	O
envv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
else	O
{	O
p	pointer
=	O
realloc	function
(	O
acl	pointer
->	O
envv	pointer
,	O
(	O
acl	pointer
->	O
envc	long
+	O
3	int
)	O
*	O
sizeof	O
(	O
acl	pointer
->	O
envv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ENOMEM	int
;	O
p	pointer
[	O
acl	pointer
->	O
envc	long
]	O
=	O
NULL	O
;	O
}	O
acl	pointer
->	O
envv	pointer
=	O
p	pointer
;	O
acl	pointer
->	O
envc	long
+=	O
3	int
;	O
}	O
if	O
(	O
_acl_env_store	function
(	O
acl	pointer
,	O
acl	pointer
->	O
envn	long
,	O
name	pointer
)	O
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
_acl_env_store	function
(	O
acl	pointer
,	O
acl	pointer
->	O
envn	long
+	O
1	int
,	O
val	array
)	O
)	O
{	O
free	function
(	O
acl	pointer
->	O
envv	pointer
[	O
acl	pointer
->	O
envn	long
]	O
)	O
;	O
acl	pointer
->	O
envv	pointer
[	O
acl	pointer
->	O
envn	long
]	O
=	O
NULL	O
;	O
return	O
ENOMEM	int
;	O
}	O
acl	pointer
->	O
envn	long
+=	O
2	int
;	O
return	O
0	int
;	O
}	O
