symbol	struct
*	O
*	O
symtab	pointer
;	O
void	O
symtab_init	function
(	O
void	O
)	O
{	O
size_t	long
i	long
;	O
symbol	struct
*	O
*	O
s	long
;	O
s	long
=	O
symtab	pointer
=	O
(	O
symbol	struct
*	O
*	O
)	O
xnmalloc	function
(	O
hash_table_size	long
,	O
sizeof	O
(	O
symbol	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
hash_table_size	long
;	O
i	long
++	O
)	O
s	long
[	O
i	long
]	O
=	O
NULL	O
;	O
}	O
static	O
size_t	long
M4_GNUC_PURE	O
hash	function
(	O
const	O
char	O
*	O
s	long
)	O
{	O
register	O
size_t	long
val	array
=	O
0	int
;	O
register	O
const	O
char	O
*	O
ptr	pointer
=	O
s	long
;	O
register	O
char	O
ch	char
;	O
while	O
(	O
(	O
ch	char
=	O
*	O
ptr	pointer
++	O
)	O
!=	O
'\0'	O
)	O
val	array
=	O
(	O
val	array
<<	O
7	int
)	O
+	O
(	O
val	array
>>	O
(	O
sizeof	O
(	O
val	array
)	O
*	O
CHAR_BIT	O
-	O
7	int
)	O
)	O
+	O
ch	char
;	O
return	O
val	array
;	O
}	O
void	O
free_symbol	function
(	O
symbol	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	pointer
)	O
>	O
0	int
)	O
SYMBOL_DELETED	O
(	O
sym	pointer
)	O
=	O
true	int
;	O
else	O
{	O
free	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
)	O
;	O
if	O
(	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
==	O
TOKEN_TEXT	int
)	O
free	function
(	O
SYMBOL_TEXT	O
(	O
sym	pointer
)	O
)	O
;	O
free	function
(	O
sym	pointer
)	O
;	O
}	O
}	O
symbol	struct
*	O
lookup_symbol	function
(	O
const	O
char	O
*	O
name	pointer
,	O
symbol_lookup	enum
mode	int
)	O
{	O
size_t	long
h	long
;	O
int	O
cmp	int
=	O
1	int
;	O
symbol	struct
*	O
sym	pointer
,	O
*	O
prev	pointer
;	O
symbol	struct
*	O
*	O
spp	pointer
;	O
h	long
=	O
hash	function
(	O
name	pointer
)	O
;	O
sym	pointer
=	O
symtab	pointer
[	O
h	long
%	O
hash_table_size	long
]	O
;	O
for	O
(	O
prev	pointer
=	O
NULL	O
;	O
sym	pointer
!=	O
NULL	O
;	O
prev	pointer
=	O
sym	pointer
,	O
sym	pointer
=	O
sym	pointer
->	O
next	pointer
)	O
{	O
cmp	int
=	O
strcmp	function
(	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
,	O
name	pointer
)	O
;	O
if	O
(	O
cmp	int
>=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
mode	int
==	O
SYMBOL_LOOKUP	int
)	O
return	O
cmp	int
==	O
0	int
?	O
sym	pointer
:	O
NULL	O
;	O
spp	pointer
=	O
(	O
prev	pointer
!=	O
NULL	O
)	O
?	O
&	O
prev	pointer
->	O
next	pointer
:	O
&	O
symtab	pointer
[	O
h	long
%	O
hash_table_size	long
]	O
;	O
switch	O
(	O
mode	int
)	O
{	O
case	O
SYMBOL_INSERT	int
:	O
if	O
(	O
cmp	int
==	O
0	int
&&	O
sym	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	pointer
)	O
>	O
0	int
)	O
{	O
symbol	struct
*	O
old	pointer
=	O
sym	pointer
;	O
SYMBOL_DELETED	O
(	O
old	pointer
)	O
=	O
true	int
;	O
sym	pointer
=	O
(	O
symbol	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
symbol	struct
)	O
)	O
;	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
=	O
TOKEN_VOID	int
;	O
SYMBOL_TRACED	O
(	O
sym	pointer
)	O
=	O
SYMBOL_TRACED	O
(	O
old	pointer
)	O
;	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
SYMBOL_SHADOWED	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_MACRO_ARGS	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_DELETED	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	pointer
)	O
=	O
0	int
;	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
=	O
SYMBOL_NEXT	O
(	O
old	pointer
)	O
;	O
SYMBOL_NEXT	O
(	O
old	pointer
)	O
=	O
NULL	O
;	O
(	O
*	O
spp	pointer
)	O
=	O
sym	pointer
;	O
}	O
return	O
sym	pointer
;	O
}	O
case	O
SYMBOL_PUSHDEF	int
:	O
sym	pointer
=	O
(	O
symbol	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
symbol	struct
)	O
)	O
;	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
=	O
TOKEN_VOID	int
;	O
SYMBOL_TRACED	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
SYMBOL_SHADOWED	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_MACRO_ARGS	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_DELETED	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	pointer
)	O
=	O
0	int
;	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
=	O
*	O
spp	pointer
;	O
(	O
*	O
spp	pointer
)	O
=	O
sym	pointer
;	O
if	O
(	O
mode	int
==	O
SYMBOL_PUSHDEF	int
&&	O
cmp	int
==	O
0	int
)	O
{	O
SYMBOL_SHADOWED	O
(	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
)	O
=	O
true	int
;	O
SYMBOL_TRACED	O
(	O
sym	pointer
)	O
=	O
SYMBOL_TRACED	O
(	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
)	O
;	O
}	O
return	O
sym	pointer
;	O
case	O
SYMBOL_DELETE	int
:	O
case	O
SYMBOL_POPDEF	int
:	O
if	O
(	O
cmp	int
!=	O
0	int
||	O
sym	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
{	O
bool	bool
traced	bool
=	O
false	int
;	O
if	O
(	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
!=	O
NULL	O
&&	O
SYMBOL_SHADOWED	O
(	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
)	O
&&	O
mode	int
==	O
SYMBOL_POPDEF	int
)	O
{	O
SYMBOL_SHADOWED	O
(	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
)	O
=	O
false	int
;	O
SYMBOL_TRACED	O
(	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
)	O
=	O
SYMBOL_TRACED	O
(	O
sym	pointer
)	O
;	O
}	O
else	O
traced	bool
=	O
SYMBOL_TRACED	O
(	O
sym	pointer
)	O
;	O
do	O
{	O
*	O
spp	pointer
=	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
;	O
free_symbol	function
(	O
sym	pointer
)	O
;	O
sym	pointer
=	O
*	O
spp	pointer
;	O
}	O
while	O
(	O
*	O
spp	pointer
!=	O
NULL	O
&&	O
SYMBOL_SHADOWED	O
(	O
*	O
spp	pointer
)	O
&&	O
mode	int
==	O
SYMBOL_DELETE	int
)	O
;	O
if	O
(	O
traced	bool
)	O
{	O
sym	pointer
=	O
(	O
symbol	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
symbol	struct
)	O
)	O
;	O
SYMBOL_TYPE	O
(	O
sym	pointer
)	O
=	O
TOKEN_VOID	int
;	O
SYMBOL_TRACED	O
(	O
sym	pointer
)	O
=	O
true	int
;	O
SYMBOL_NAME	O
(	O
sym	pointer
)	O
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
SYMBOL_SHADOWED	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_MACRO_ARGS	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_BLIND_NO_ARGS	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_DELETED	O
(	O
sym	pointer
)	O
=	O
false	int
;	O
SYMBOL_PENDING_EXPANSIONS	O
(	O
sym	pointer
)	O
=	O
0	int
;	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
=	O
*	O
spp	pointer
;	O
(	O
*	O
spp	pointer
)	O
=	O
sym	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
case	O
SYMBOL_LOOKUP	int
:	O
default	O
:	O
M4ERROR	O
(	O
(	O
warning_status	int
,	O
0	int
,	O
"INTERNAL ERROR: invalid mode to symbol_lookup ()"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
}	O
void	O
hack_all_symbols	function
(	O
hack_symbol	function
*	O
func	pointer
,	O
void	O
*	O
data	struct
)	O
{	O
size_t	long
h	long
;	O
symbol	struct
*	O
sym	pointer
;	O
symbol	struct
*	O
next	pointer
;	O
for	O
(	O
h	long
=	O
0	int
;	O
h	long
<	O
hash_table_size	long
;	O
h	long
++	O
)	O
{	O
for	O
(	O
sym	pointer
=	O
symtab	pointer
[	O
h	long
]	O
;	O
sym	pointer
!=	O
NULL	O
;	O
sym	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
SYMBOL_NEXT	O
(	O
sym	pointer
)	O
;	O
func	pointer
(	O
sym	pointer
,	O
data	struct
)	O
;	O
}	O
}	O
}	O
