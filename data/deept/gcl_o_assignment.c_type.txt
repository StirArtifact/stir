static	O
object	O
setf	function
(	O
object	O
,	O
object	O
)	O
;	O
object	O
sLsetf	int
;	O
object	O
sLget	int
;	O
object	O
sLgetf	int
;	O
object	O
sLaref	int
;	O
object	O
sLsvref	int
;	O
object	O
sLelt	int
;	O
object	O
sLchar	int
;	O
object	O
sLschar	int
;	O
object	O
sLfill_pointer	int
;	O
object	O
sLgethash	int
;	O
object	O
sLcar	int
;	O
object	O
sLcdr	int
;	O
object	O
sLpush	int
;	O
object	O
sLpop	int
;	O
object	O
sLincf	int
;	O
object	O
sLdecf	int
;	O
object	O
sSstructure_access	int
;	O
object	O
sSsetf_lambda	int
;	O
object	O
sSclear_compiler_properties	int
;	O
object	O
sLwarn	int
;	O
object	O
sSAinhibit_macro_specialA	int
;	O
void	O
setq	function
(	O
object	O
sym	int
,	O
object	O
val	int
)	O
{	O
object	O
vd	O
;	O
enum	O
stype	O
type	enum
;	O
if	O
(	O
type_of	function
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	function
(	O
sym	int
)	O
;	O
type	enum
=	O
(	O
enum	O
stype	O
)	O
sym	int
->	O
s	O
.	O
s_stype	O
;	O
if	O
(	O
type	enum
==	O
stp_special	O
)	O
sym	int
->	O
s	O
.	O
s_dbind	O
=	O
val	int
;	O
else	O
if	O
(	O
type	enum
==	O
stp_constant	O
)	O
FEinvalid_variable	function
(	O
"Cannot assign to the constant ~S."	pointer
,	O
sym	int
)	O
;	O
else	O
{	O
vd	O
=	O
lex_var_sch	function
(	O
sym	int
)	O
;	O
if	O
(	O
MMnull	function
(	O
vd	O
)	O
||	O
endp	function
(	O
MMcdr	function
(	O
vd	O
)	O
)	O
)	O
sym	int
->	O
s	O
.	O
s_dbind	O
=	O
val	int
;	O
else	O
MMcadr	function
(	O
vd	O
)	O
=	O
val	int
;	O
}	O
}	O
static	O
void	O
FFN	function
(	O
Fsetq	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
ans	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
if	O
(	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
FEinvalid_form	function
(	O
"No value for ~S."	pointer
,	O
form	int
->	O
c	O
.	O
c_car	O
)	O
;	O
setq	function
(	O
MMcar	function
(	O
form	int
)	O
,	O
ans	O
=	O
Ieval	function
(	O
MMcadr	function
(	O
form	int
)	O
)	O
)	O
;	O
form	int
=	O
MMcddr	function
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
form	int
)	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
ans	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
}	O
}	O
static	O
void	O
FFN	function
(	O
Fpsetq	int
)	O
(	O
object	O
arg	int
)	O
{	O
object	O
*	O
old_top	O
=	O
vs_top	O
;	O
object	O
*	O
top	O
;	O
object	O
argsv	O
=	O
arg	int
;	O
for	O
(	O
top	O
=	O
old_top	O
;	O
!	O
endp	function
(	O
arg	int
)	O
;	O
arg	int
=	O
MMcddr	function
(	O
arg	int
)	O
,	O
top	O
++	O
)	O
{	O
if	O
(	O
endp	function
(	O
MMcdr	function
(	O
arg	int
)	O
)	O
)	O
FEinvalid_form	function
(	O
"No value for ~S."	pointer
,	O
arg	int
->	O
c	O
.	O
c_car	O
)	O
;	O
top	O
[	O
0	int
]	O
=	O
Ieval	function
(	O
MMcadr	function
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
}	O
for	O
(	O
arg	int
=	O
argsv	O
,	O
top	O
=	O
old_top	O
;	O
!	O
endp	function
(	O
arg	int
)	O
;	O
arg	int
=	O
MMcddr	function
(	O
arg	int
)	O
,	O
top	O
++	O
)	O
setq	function
(	O
MMcar	function
(	O
arg	int
)	O
,	O
top	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
=	O
vs_top	O
=	O
old_top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"SET"	pointer
,	O
object	O
,	O
fLset	O
,	O
LISP	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lset	O
,	O
(	O
object	O
symbol	O
,	O
object	O
value	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
symbol	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	function
(	O
symbol	O
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
symbol	O
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
FEinvalid_variable	function
(	O
"Cannot assign to the constant ~S."	pointer
,	O
symbol	O
)	O
;	O
symbol	O
->	O
s	O
.	O
s_dbind	O
=	O
value	O
;	O
RETURN1	function
(	O
value	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"FSET"	pointer
,	O
object	O
,	O
fSfset	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
siLfset	O
,	O
(	O
object	O
sym	int
,	O
object	O
function	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	function
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_mflag	O
)	O
{	O
if	O
(	O
symbol_value	function
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
sym	int
->	O
s	O
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
}	O
else	O
if	O
(	O
symbol_value	function
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
FEerror	function
(	O
"~S, a special form, cannot be redefined."	pointer
,	O
1	int
,	O
sym	int
)	O
;	O
}	O
sym	int
=	O
clear_compiler_properties	function
(	O
sym	int
,	O
function	O
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_hpack	O
==	O
lisp_package	O
&&	O
sym	int
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
!	O
raw_image	O
)	O
{	O
ifuncall2	function
(	O
sLwarn	int
,	O
make_simple_string	function
(	O
"~S is being redefined."	pointer
)	O
,	O
sym	int
)	O
;	O
}	O
if	O
(	O
type_of	function
(	O
function	O
)	O
==	O
t_cfun	O
||	O
type_of	function
(	O
function	O
)	O
==	O
t_sfun	O
||	O
type_of	function
(	O
function	O
)	O
==	O
t_vfun	O
||	O
type_of	function
(	O
function	O
)	O
==	O
t_gfun	O
||	O
type_of	function
(	O
function	O
)	O
==	O
t_cclosure	O
||	O
type_of	function
(	O
function	O
)	O
==	O
t_closure	O
||	O
type_of	function
(	O
function	O
)	O
==	O
t_afun	O
)	O
{	O
sym	int
->	O
s	O
.	O
s_gfdef	O
=	O
function	O
;	O
sym	int
->	O
s	O
.	O
s_mflag	O
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
car	function
(	O
function	O
)	O
==	O
sLspecial	O
)	O
FEerror	function
(	O
"Cannot define a special form."	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
function	O
->	O
c	O
.	O
c_car	O
==	O
sLmacro	O
)	O
{	O
sym	int
->	O
s	O
.	O
s_gfdef	O
=	O
function	O
->	O
c	O
.	O
c_cdr	O
;	O
sym	int
->	O
s	O
.	O
s_mflag	O
=	O
TRUE	O
;	O
}	O
else	O
{	O
sym	int
->	O
s	O
.	O
s_gfdef	O
=	O
function	O
;	O
sym	int
->	O
s	O
.	O
s_mflag	O
=	O
FALSE	O
;	O
}	O
RETURN1	function
(	O
function	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fmultiple_value_setq	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
vars	O
;	O
int	O
n	int
,	O
i	int
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
||	O
endp	function
(	O
form	int
->	O
c	O
.	O
c_cdr	O
)	O
||	O
!	O
endp	function
(	O
form	int
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_cdr	O
)	O
)	O
FEinvalid_form	function
(	O
"~S is an illegal argument to MULTIPLE-VALUE-SETQ"	pointer
,	O
form	int
)	O
;	O
vars	O
=	O
form	int
->	O
c	O
.	O
c_car	O
;	O
fcall	O
.	O
values	O
[	O
0	int
]	O
=	O
Ieval	function
(	O
form	int
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_car	O
)	O
;	O
n	int
=	O
fcall	O
.	O
nvalues	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
endp	function
(	O
vars	O
)	O
;	O
i	int
++	O
,	O
vars	O
=	O
vars	O
->	O
c	O
.	O
c_cdr	O
)	O
if	O
(	O
i	int
<	O
n	int
)	O
setq	function
(	O
vars	O
->	O
c	O
.	O
c_car	O
,	O
fcall	O
.	O
values	O
[	O
i	int
]	O
)	O
;	O
else	O
setq	function
(	O
vars	O
->	O
c	O
.	O
c_car	O
,	O
Cnil	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
fcall	O
.	O
values	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
DEFUNO_NEW	function
(	O
"MAKUNBOUND"	pointer
,	O
object	O
,	O
fLmakunbound	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lmakunbound	O
,	O
(	O
object	O
sym	int
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	function
(	O
sym	int
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
sym	int
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
FEinvalid_variable	function
(	O
"Cannot unbind the constant ~S."	pointer
,	O
sym	int
)	O
;	O
sym	int
->	O
s	O
.	O
s_dbind	O
=	O
OBJNULL	O
;	O
RETURN1	function
(	O
sym	int
)	O
;	O
}	O
object	O
sStraced	int
;	O
DEFUNO_NEW	function
(	O
"FMAKUNBOUND"	pointer
,	O
object	O
,	O
fLfmakunbound	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lfmakunbound	O
,	O
(	O
object	O
sym	int
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
sym	int
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	function
(	O
sym	int
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_mflag	O
)	O
{	O
if	O
(	O
symbol_value	function
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
sym	int
->	O
s	O
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
}	O
else	O
if	O
(	O
symbol_value	function
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
FEerror	function
(	O
"~S, a special form, cannot be redefined."	pointer
,	O
1	int
,	O
sym	int
)	O
;	O
}	O
remf	function
(	O
&	O
(	O
sym	int
->	O
s	O
.	O
s_plist	O
)	O
,	O
sStraced	int
)	O
;	O
clear_compiler_properties	function
(	O
sym	int
,	O
Cnil	O
)	O
;	O
if	O
(	O
sym	int
->	O
s	O
.	O
s_hpack	O
==	O
lisp_package	O
&&	O
sym	int
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
!	O
raw_image	O
)	O
{	O
ifuncall2	function
(	O
sLwarn	int
,	O
make_simple_string	function
(	O
"~S is being redefined."	pointer
)	O
,	O
sym	int
)	O
;	O
}	O
sym	int
->	O
s	O
.	O
s_gfdef	O
=	O
OBJNULL	O
;	O
sym	int
->	O
s	O
.	O
s_mflag	O
=	O
FALSE	O
;	O
RETURN1	function
(	O
sym	int
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fsetf	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
result	O
,	O
*	O
t	O
,	O
*	O
t1	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
if	O
(	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
FEinvalid_form	function
(	O
"No value for ~S."	pointer
,	O
form	int
->	O
c	O
.	O
c_car	O
)	O
;	O
result	O
=	O
setf	function
(	O
MMcar	function
(	O
form	int
)	O
,	O
MMcadr	function
(	O
form	int
)	O
)	O
;	O
form	int
=	O
MMcddr	function
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
form	int
)	O
)	O
;	O
t	O
=	O
vs_base	O
;	O
t1	O
=	O
vs_top	O
;	O
vs_top	O
=	O
vs_base	O
=	O
top	O
;	O
for	O
(	O
;	O
t	O
<	O
t1	O
;	O
t	O
++	O
)	O
vs_push	function
(	O
*	O
t	O
)	O
;	O
}	O
}	O
static	O
object	O
setf	function
(	O
object	O
place	int
,	O
object	O
form	int
)	O
{	O
object	O
fun	O
;	O
object	O
*	O
vs	O
=	O
vs_top	O
;	O
void	O
(	O
*	O
f	pointer
)	O
(	O
)	O
;	O
object	O
args	O
;	O
object	O
x	O
,	O
result	O
,	O
y	O
;	O
int	O
i	int
;	O
extern	O
void	O
siLelt_set	function
(	O
)	O
;	O
extern	O
void	O
siLchar_set	function
(	O
)	O
;	O
extern	O
void	O
siLhash_set	function
(	O
)	O
;	O
if	O
(	O
type_of	function
(	O
place	int
)	O
!=	O
t_cons	O
)	O
{	O
setq	function
(	O
place	int
,	O
result	O
=	O
Ieval	function
(	O
form	int
)	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
return	O
result	O
;	O
}	O
fun	O
=	O
place	int
->	O
c	O
.	O
c_car	O
;	O
if	O
(	O
type_of	function
(	O
fun	O
)	O
!=	O
t_symbol	O
)	O
goto	O
OTHERWISE	O
;	O
args	O
=	O
place	int
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
fun	O
==	O
sLget	int
)	O
{	O
object	O
sym	int
,	O
val	int
,	O
key	O
;	O
sym	int
=	O
Ieval	function
(	O
car	function
(	O
args	O
)	O
)	O
;	O
key	O
=	O
Ieval	function
(	O
car	function
(	O
Mcdr	function
(	O
args	O
)	O
)	O
)	O
;	O
val	int
=	O
Ieval	function
(	O
form	int
)	O
;	O
return	O
putprop	function
(	O
sym	int
,	O
val	int
,	O
key	O
)	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLgetf	int
)	O
Ieval	function
(	O
Mcaddr	function
(	O
args	O
)	O
)	O
;	O
if	O
(	O
fun	O
==	O
sLaref	int
)	O
{	O
f	pointer
=	O
siLaset	O
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLsvref	int
)	O
{	O
f	pointer
=	O
siLsvset	O
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLelt	int
)	O
{	O
f	pointer
=	O
siLelt_set	function
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLchar	int
)	O
{	O
f	pointer
=	O
siLchar_set	function
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLschar	int
)	O
{	O
f	pointer
=	O
siLchar_set	function
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLfill_pointer	int
)	O
{	O
f	pointer
=	O
siLfill_pointer_set	O
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLgethash	int
)	O
{	O
f	pointer
=	O
siLhash_set	function
;	O
goto	O
EVAL	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLcar	int
)	O
{	O
x	O
=	O
Ieval	function
(	O
Mcar	function
(	O
args	O
)	O
)	O
;	O
result	O
=	O
Ieval	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
x	O
)	O
!=	O
t_cons	O
)	O
FEerror	function
(	O
"~S is not a cons."	pointer
,	O
1	int
,	O
x	O
)	O
;	O
Mcar	function
(	O
x	O
)	O
=	O
result	O
;	O
return	O
result	O
;	O
}	O
if	O
(	O
fun	O
==	O
sLcdr	int
)	O
{	O
x	O
=	O
Ieval	function
(	O
Mcar	function
(	O
args	O
)	O
)	O
;	O
result	O
=	O
Ieval	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
x	O
)	O
!=	O
t_cons	O
)	O
FEerror	function
(	O
"~S is not a cons."	pointer
,	O
1	int
,	O
x	O
)	O
;	O
Mcdr	function
(	O
x	O
)	O
=	O
result	O
;	O
return	O
result	O
;	O
}	O
x	O
=	O
getf	function
(	O
fun	O
->	O
s	O
.	O
s_plist	O
,	O
sSstructure_access	int
,	O
Cnil	O
)	O
;	O
if	O
(	O
x	O
==	O
Cnil	O
||	O
type_of	function
(	O
x	O
)	O
!=	O
t_cons	O
)	O
goto	O
OTHERWISE	O
;	O
if	O
(	O
getf	function
(	O
fun	O
->	O
s	O
.	O
s_plist	O
,	O
sSsetf_lambda	int
,	O
Cnil	O
)	O
==	O
Cnil	O
)	O
goto	O
OTHERWISE	O
;	O
if	O
(	O
type_of	function
(	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
!=	O
t_fixnum	O
)	O
goto	O
OTHERWISE	O
;	O
i	int
=	O
fix	function
(	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
;	O
x	O
=	O
x	O
->	O
c	O
.	O
c_car	O
;	O
y	O
=	O
Ieval	function
(	O
Mcar	function
(	O
args	O
)	O
)	O
;	O
result	O
=	O
Ieval	function
(	O
form	int
)	O
;	O
if	O
(	O
x	O
==	O
sLvector	O
)	O
{	O
if	O
(	O
type_of	function
(	O
y	O
)	O
!=	O
t_vector	O
||	O
i	int
>=	O
y	O
->	O
v	O
.	O
v_fillp	O
)	O
goto	O
OTHERWISE	O
;	O
y	O
->	O
v	O
.	O
v_self	O
[	O
i	int
]	O
=	O
result	O
;	O
}	O
else	O
if	O
(	O
x	O
==	O
sLlist	O
)	O
{	O
for	O
(	O
x	O
=	O
y	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
x	O
=	O
cdr	function
(	O
x	O
)	O
;	O
if	O
(	O
type_of	function
(	O
x	O
)	O
!=	O
t_cons	O
)	O
goto	O
OTHERWISE	O
;	O
x	O
->	O
c	O
.	O
c_car	O
=	O
result	O
;	O
}	O
else	O
{	O
structure_set	function
(	O
y	O
,	O
x	O
,	O
i	int
,	O
result	O
)	O
;	O
}	O
return	O
result	O
;	O
EVAL	O
:	O
for	O
(	O
;	O
!	O
endp	function
(	O
args	O
)	O
;	O
args	O
=	O
args	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
eval_push	O
(	O
args	O
->	O
c	O
.	O
c_car	O
)	O
;	O
}	O
eval_push	O
(	O
form	int
)	O
;	O
vs_base	O
=	O
vs	O
;	O
(	O
*	O
f	pointer
)	O
(	O
)	O
;	O
return	O
vs_base	O
[	O
0	int
]	O
;	O
OTHERWISE	O
:	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
sLsetf	int
)	O
;	O
vs_push	function
(	O
place	int
)	O
;	O
vs_push	function
(	O
form	int
)	O
;	O
result	O
=	O
vs_top	O
[	O
-	O
1	int
]	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
stack_cons	function
(	O
)	O
;	O
stack_cons	function
(	O
)	O
;	O
stack_cons	function
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLsetf	int
->	O
s	O
.	O
s_mflag	O
||	O
sLsetf	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	function
(	O
"Where is SETF?"	pointer
,	O
0	int
)	O
;	O
funcall	function
(	O
sLsetf	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
return	O
Ieval	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fpush	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
var	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
||	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	function
(	O
MMcddr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	function
(	O
form	int
)	O
;	O
var	O
=	O
MMcadr	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
var	O
)	O
!=	O
t_cons	O
)	O
{	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
form	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
eval	function
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	function
(	O
form	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
setq	function
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
sLpush	int
)	O
;	O
vs_push	function
(	O
form	int
)	O
;	O
stack_cons	function
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLpush	int
->	O
s	O
.	O
s_mflag	O
||	O
sLpush	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	function
(	O
"Where is PUSH?"	pointer
,	O
0	int
)	O
;	O
funcall	function
(	O
sLpush	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
eval	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fpop	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
var	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	function
(	O
form	int
)	O
;	O
var	O
=	O
MMcar	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
var	O
)	O
!=	O
t_cons	O
)	O
{	O
eval	function
(	O
var	O
)	O
;	O
setq	function
(	O
var	O
,	O
cdr	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
car	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
sLpop	int
)	O
;	O
vs_push	function
(	O
form	int
)	O
;	O
stack_cons	function
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLpop	int
->	O
s	O
.	O
s_mflag	O
||	O
sLpop	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	function
(	O
"Where is POP?"	pointer
,	O
0	int
)	O
;	O
funcall	function
(	O
sLpop	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
eval	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fincf	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
var	O
;	O
object	O
one_plus	function
(	O
object	O
x	O
)	O
,	O
number_plus	function
(	O
object	O
x	O
,	O
object	O
y	O
)	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
&&	O
!	O
endp	function
(	O
MMcddr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	function
(	O
form	int
)	O
;	O
var	O
=	O
MMcar	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
var	O
)	O
!=	O
t_cons	O
)	O
{	O
if	O
(	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
{	O
eval	function
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
one_plus	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
setq	function
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
eval	function
(	O
MMcadr	function
(	O
form	int
)	O
)	O
;	O
form	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
eval	function
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_plus	function
(	O
vs_base	O
[	O
0	int
]	O
,	O
form	int
)	O
;	O
setq	function
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
sLincf	int
)	O
;	O
vs_push	function
(	O
form	int
)	O
;	O
stack_cons	function
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLincf	int
->	O
s	O
.	O
s_mflag	O
||	O
sLincf	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	function
(	O
"Where is INCF?"	pointer
,	O
0	int
)	O
;	O
funcall	function
(	O
sLincf	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
eval	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fdecf	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
var	O
;	O
object	O
one_minus	function
(	O
object	O
x	O
)	O
,	O
number_minus	function
(	O
object	O
x	O
,	O
object	O
y	O
)	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
&&	O
!	O
endp	function
(	O
MMcddr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	function
(	O
form	int
)	O
;	O
var	O
=	O
MMcar	function
(	O
form	int
)	O
;	O
if	O
(	O
type_of	function
(	O
var	O
)	O
!=	O
t_cons	O
)	O
{	O
if	O
(	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
{	O
eval	function
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
one_minus	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
setq	function
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
eval	function
(	O
MMcadr	function
(	O
form	int
)	O
)	O
;	O
form	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
eval	function
(	O
var	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
number_minus	function
(	O
vs_base	O
[	O
0	int
]	O
,	O
form	int
)	O
;	O
setq	function
(	O
var	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
sLdecf	int
)	O
;	O
vs_push	function
(	O
form	int
)	O
;	O
stack_cons	function
(	O
)	O
;	O
VS_PUSH_ENV	O
;	O
if	O
(	O
!	O
sLdecf	int
->	O
s	O
.	O
s_mflag	O
||	O
sLdecf	int
->	O
s	O
.	O
s_gfdef	O
==	O
OBJNULL	O
)	O
FEerror	function
(	O
"Where is DECF?"	pointer
,	O
0	int
)	O
;	O
funcall	function
(	O
sLdecf	int
->	O
s	O
.	O
s_gfdef	O
)	O
;	O
eval	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
DEF_ORDINARY	function
(	O
"CLEAR-COMPILER-PROPERTIES"	pointer
,	O
sSclear_compiler_properties	int
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEFUN_NEW	function
(	O
"CLEAR-COMPILER-PROPERTIES"	pointer
,	O
object	O
,	O
fSclear_compiler_properties	O
,	O
SI	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
,	O
object	O
x1	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
Cnil	O
)	O
;	O
}	O
DEF_ORDINARY	function
(	O
"AREF"	pointer
,	O
sLaref	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"CAR"	pointer
,	O
sLcar	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"CDR"	pointer
,	O
sLcdr	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"CHAR"	pointer
,	O
sLchar	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"DECF"	pointer
,	O
sLdecf	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"ELT"	pointer
,	O
sLelt	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"FILL-POINTER"	pointer
,	O
sLfill_pointer	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"GET"	pointer
,	O
sLget	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"GETF"	pointer
,	O
sLgetf	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"GETHASH"	pointer
,	O
sLgethash	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"INCF"	pointer
,	O
sLincf	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"POP"	pointer
,	O
sLpop	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"PUSH"	pointer
,	O
sLpush	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"SCHAR"	pointer
,	O
sLschar	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"SETF"	pointer
,	O
sLsetf	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"SETF-LAMBDA"	pointer
,	O
sSsetf_lambda	int
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"STRUCTURE-ACCESS"	pointer
,	O
sSstructure_access	int
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"SVREF"	pointer
,	O
sLsvref	int
,	O
LISP	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"TRACED"	pointer
,	O
sStraced	int
,	O
SI	O
,	O
""	pointer
)	O
;	O
DEF_ORDINARY	function
(	O
"VECTOR"	pointer
,	O
sLvector	O
,	O
LISP	O
,	O
""	pointer
)	O
;	O
void	O
gcl_init_assignment	function
(	O
void	O
)	O
{	O
make_special_form	function
(	O
"SETQ"	pointer
,	O
Fsetq	int
)	O
;	O
make_special_form	function
(	O
"PSETQ"	pointer
,	O
Fpsetq	int
)	O
;	O
make_special_form	function
(	O
"MULTIPLE-VALUE-SETQ"	pointer
,	O
Fmultiple_value_setq	int
)	O
;	O
sLsetf	int
=	O
make_special_form	function
(	O
"SETF"	pointer
,	O
Fsetf	int
)	O
;	O
sLpush	int
=	O
make_special_form	function
(	O
"PUSH"	pointer
,	O
Fpush	int
)	O
;	O
sLpop	int
=	O
make_special_form	function
(	O
"POP"	pointer
,	O
Fpop	int
)	O
;	O
sLincf	int
=	O
make_special_form	function
(	O
"INCF"	pointer
,	O
Fincf	int
)	O
;	O
sLdecf	int
=	O
make_special_form	function
(	O
"DECF"	pointer
,	O
Fdecf	int
)	O
;	O
}	O
