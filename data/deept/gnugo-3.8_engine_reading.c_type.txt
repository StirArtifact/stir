struct	O
reading_moves	struct
{	O
int	O
pos	int
[	O
MAX_MOVES	int
]	O
;	O
int	O
score	float
[	O
MAX_MOVES	int
]	O
;	O
const	O
char	O
*	O
message	pointer
[	O
MAX_MOVES	int
]	O
;	O
int	O
num	int
;	O
int	O
num_tried	int
;	O
}	O
;	O
static	O
int	O
do_find_defense	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
defend1	pointer
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
defend2	pointer
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
defend3	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
defend4	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
void	O
special_rescue_moves	function
(	O
int	O
str	int
,	O
int	O
lib	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
bamboo_rescue_moves	function
(	O
int	O
str	int
,	O
int	O
num_libs	int
,	O
int	O
libs	pointer
[	O
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
special_rescue2_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
special_rescue3_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
special_rescue4_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
hane_rescue_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
4	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
special_rescue5_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
special_rescue6_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
set_up_snapback_moves	function
(	O
int	O
str	int
,	O
int	O
lib	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
edge_clamp_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
int	O
do_attack	int
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
attack1	pointer
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
attack2	pointer
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
attack3	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
attack4	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
void	O
find_cap_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
special_attack2_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
special_attack3_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
special_attack4_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
draw_back_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
edge_closing_backfill_moves	function
(	O
int	O
str	int
,	O
int	O
apos	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
edge_block_moves	function
(	O
int	O
str	int
,	O
int	O
apos	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
propose_edge_moves	function
(	O
int	O
str	int
,	O
int	O
*	O
libs	pointer
,	O
int	O
liberties	pointer
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
color	int
)	O
;	O
static	O
void	O
break_chain_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
int	O
defend_secondary_chain1_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
min_liberties	int
)	O
;	O
static	O
void	O
defend_secondary_chain2_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
min_liberties	int
)	O
;	O
static	O
void	O
break_chain2_efficient_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
do_find_break_chain2_efficient_moves	function
(	O
int	O
str	int
,	O
int	O
adj	array
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
break_chain2_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
require_safe	int
,	O
int	O
be_aggressive	int
)	O
;	O
static	O
void	O
break_chain2_defense_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
be_aggressive	int
)	O
;	O
static	O
void	O
break_chain3_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
be_aggressive	int
)	O
;	O
static	O
void	O
break_chain4_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
be_aggressive	int
)	O
;	O
static	O
void	O
superstring_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
liberty_cap	int
,	O
int	O
does_attack	function
)	O
;	O
static	O
void	O
squeeze_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
superstring_break_chain_moves	function
(	O
int	O
str	int
,	O
int	O
liberty_cap	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
;	O
static	O
void	O
double_atari_chain2_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
generate_more_moves	int
)	O
;	O
static	O
void	O
order_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
color	int
,	O
const	O
char	O
*	O
funcname	pointer
,	O
int	O
killer	int
)	O
;	O
static	O
int	O
simple_ladder_defend	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
;	O
static	O
int	O
in_list	function
(	O
int	O
move	pointer
,	O
int	O
num_moves	int
,	O
int	O
*	O
moves	array
)	O
;	O
static	O
int	O
reading_node_counter	int
=	O
0	int
;	O
static	O
int	O
nodes_when_called	int
=	O
0	int
;	O
int	O
attack	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
result	int
;	O
int	O
nodes	int
;	O
int	O
origin	int
;	O
int	O
the_move	int
=	O
NO_MOVE	O
;	O
int	O
liberties	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
nodes_when_called	int
=	O
reading_node_counter	int
;	O
if	O
(	O
liberties	pointer
>	O
4	int
||	O
(	O
liberties	pointer
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
||	O
(	O
liberties	pointer
==	O
3	int
&&	O
stackp	int
>	O
depth	int
)	O
)	O
return	O
0	int
;	O
origin	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
if	O
(	O
search_persistent_reading_cache	function
(	O
ATTACK	int
,	O
origin	int
,	O
&	O
result	int
,	O
&	O
the_move	int
)	O
)	O
{	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
the_move	int
;	O
return	O
result	int
;	O
}	O
memset	function
(	O
shadow	array
,	O
0	int
,	O
sizeof	O
(	O
shadow	array
)	O
)	O
;	O
result	int
=	O
do_attack	int
(	O
str	int
,	O
&	O
the_move	int
)	O
;	O
nodes	int
=	O
reading_node_counter	int
-	O
nodes_when_called	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_READING_PERFORMANCE	int
)	O
{	O
if	O
(	O
reading_node_counter	int
-	O
nodes_when_called	int
>=	O
MIN_READING_NODES_TO_REPORT	int
)	O
{	O
if	O
(	O
result	int
!=	O
0	int
)	O
gprintf	function
(	O
"%oattack %1m(%1m) = %d %1M, %d nodes "	pointer
,	O
str	int
,	O
origin	int
,	O
result	int
,	O
the_move	int
,	O
nodes	int
)	O
;	O
else	O
gprintf	function
(	O
"%oattack %1m(%1m) = %d, %d nodes "	pointer
,	O
str	int
,	O
origin	int
,	O
result	int
,	O
nodes	int
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
}	O
store_persistent_reading_cache	function
(	O
ATTACK	int
,	O
origin	int
,	O
result	int
,	O
the_move	int
,	O
nodes	int
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
the_move	int
;	O
return	O
result	int
;	O
}	O
int	O
find_defense	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
result	int
;	O
int	O
nodes	int
;	O
int	O
origin	int
;	O
int	O
the_move	int
=	O
NO_MOVE	O
;	O
int	O
liberties	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
nodes_when_called	int
=	O
reading_node_counter	int
;	O
if	O
(	O
liberties	pointer
>	O
4	int
||	O
(	O
liberties	pointer
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
)	O
{	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
NO_MOVE	O
;	O
return	O
WIN	int
;	O
}	O
origin	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
if	O
(	O
search_persistent_reading_cache	function
(	O
FIND_DEFENSE	int
,	O
origin	int
,	O
&	O
result	int
,	O
&	O
the_move	int
)	O
)	O
{	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
the_move	int
;	O
return	O
result	int
;	O
}	O
memset	function
(	O
shadow	array
,	O
0	int
,	O
sizeof	O
(	O
shadow	array
)	O
)	O
;	O
result	int
=	O
do_find_defense	function
(	O
str	int
,	O
&	O
the_move	int
)	O
;	O
nodes	int
=	O
reading_node_counter	int
-	O
nodes_when_called	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_READING_PERFORMANCE	int
)	O
{	O
if	O
(	O
reading_node_counter	int
-	O
nodes_when_called	int
>=	O
MIN_READING_NODES_TO_REPORT	int
)	O
{	O
if	O
(	O
result	int
!=	O
0	int
)	O
gprintf	function
(	O
"%odefend %1m(%1m) = %d %1M, %d nodes "	pointer
,	O
str	int
,	O
origin	int
,	O
result	int
,	O
the_move	int
,	O
nodes	int
)	O
;	O
else	O
gprintf	function
(	O
"%odefend %1m(%1m) = %d, %d nodes "	pointer
,	O
str	int
,	O
origin	int
,	O
result	int
,	O
nodes	int
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
}	O
store_persistent_reading_cache	function
(	O
FIND_DEFENSE	int
,	O
origin	int
,	O
result	int
,	O
the_move	int
,	O
nodes	int
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
the_move	int
;	O
return	O
result	int
;	O
}	O
int	O
attack_and_defend	function
(	O
int	O
str	int
,	O
int	O
*	O
attack_code	pointer
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defend_code	pointer
,	O
int	O
*	O
defense_point	pointer
)	O
{	O
int	O
acode	int
=	O
0	int
;	O
int	O
apos	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
dpos	int
=	O
NO_MOVE	O
;	O
acode	int
=	O
attack	function
(	O
str	int
,	O
&	O
apos	int
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
dcode	int
=	O
find_defense	function
(	O
str	int
,	O
&	O
dpos	int
)	O
;	O
ASSERT1	O
(	O
!	O
(	O
acode	int
!=	O
0	int
&&	O
dcode	int
==	O
WIN	int
&&	O
dpos	int
==	O
NO_MOVE	O
)	O
,	O
str	int
)	O
;	O
if	O
(	O
attack_code	pointer
)	O
*	O
attack_code	pointer
=	O
acode	int
;	O
if	O
(	O
attack_point	pointer
)	O
*	O
attack_point	pointer
=	O
apos	int
;	O
if	O
(	O
defend_code	pointer
)	O
*	O
defend_code	pointer
=	O
dcode	int
;	O
if	O
(	O
defense_point	pointer
)	O
*	O
defense_point	pointer
=	O
dpos	int
;	O
return	O
acode	int
!=	O
0	int
&&	O
dcode	int
!=	O
0	int
;	O
}	O
int	O
attack_either	function
(	O
int	O
astr	int
,	O
int	O
bstr	int
)	O
{	O
int	O
asuccess	int
=	O
0	int
;	O
int	O
bsuccess	int
=	O
0	int
;	O
int	O
color	int
=	O
board	pointer
[	O
astr	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
astr	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
board	pointer
[	O
bstr	int
]	O
,	O
bstr	int
)	O
;	O
if	O
(	O
countlib	function
(	O
astr	int
)	O
>	O
countlib	function
(	O
bstr	int
)	O
)	O
{	O
int	O
t	int
=	O
astr	int
;	O
astr	int
=	O
bstr	int
;	O
bstr	int
=	O
t	int
;	O
}	O
asuccess	int
=	O
attack	function
(	O
astr	int
,	O
NULL	O
)	O
;	O
if	O
(	O
asuccess	int
==	O
WIN	int
)	O
return	O
asuccess	int
;	O
bsuccess	int
=	O
attack	function
(	O
bstr	int
,	O
NULL	O
)	O
;	O
if	O
(	O
asuccess	int
||	O
bsuccess	int
)	O
{	O
return	O
(	O
asuccess	int
>	O
bsuccess	int
)	O
?	O
asuccess	int
:	O
bsuccess	int
;	O
}	O
{	O
int	O
alibs	array
[	O
2	int
]	O
;	O
int	O
blibs	array
[	O
2	int
]	O
;	O
int	O
alib	int
=	O
findlib	function
(	O
astr	int
,	O
2	int
,	O
alibs	array
)	O
;	O
int	O
defended0	int
=	O
WIN	int
;	O
int	O
defended1	int
=	O
WIN	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
alib	int
==	O
2	int
)	O
{	O
if	O
(	O
trymove	function
(	O
alibs	array
[	O
0	int
]	O
,	O
other	int
,	O
"attack_either-A"	pointer
,	O
astr	int
)	O
)	O
{	O
defended0	int
=	O
defend_both	function
(	O
astr	int
,	O
bstr	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
defended0	int
&&	O
trymove	function
(	O
alibs	array
[	O
1	int
]	O
,	O
other	int
,	O
"attack_either-B"	pointer
,	O
astr	int
)	O
)	O
{	O
defended1	int
=	O
defend_both	function
(	O
astr	int
,	O
bstr	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
defended0	int
>	O
0	int
&&	O
defended1	int
>	O
0	int
&&	O
findlib	function
(	O
bstr	int
,	O
2	int
,	O
blibs	array
)	O
==	O
2	int
)	O
{	O
defended0	int
=	O
gg_min	O
(	O
defended0	int
,	O
defended1	int
)	O
;	O
defended1	int
=	O
defended0	int
;	O
if	O
(	O
alib	int
==	O
1	int
)	O
alibs	array
[	O
1	int
]	O
=	O
NO_MOVE	O
;	O
if	O
(	O
blibs	array
[	O
0	int
]	O
!=	O
alibs	array
[	O
0	int
]	O
&&	O
blibs	array
[	O
0	int
]	O
!=	O
alibs	array
[	O
1	int
]	O
&&	O
trymove	function
(	O
blibs	array
[	O
0	int
]	O
,	O
other	int
,	O
"attack_either-C"	pointer
,	O
bstr	int
)	O
)	O
{	O
int	O
defended	int
=	O
defend_both	function
(	O
astr	int
,	O
bstr	int
)	O
;	O
defended0	int
=	O
gg_min	O
(	O
defended0	int
,	O
defended	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
defended0	int
&&	O
blibs	array
[	O
1	int
]	O
!=	O
alibs	array
[	O
0	int
]	O
&&	O
blibs	array
[	O
1	int
]	O
!=	O
alibs	array
[	O
1	int
]	O
&&	O
trymove	function
(	O
blibs	array
[	O
1	int
]	O
,	O
other	int
,	O
"attack_either-D"	pointer
,	O
bstr	int
)	O
)	O
{	O
int	O
defended	int
=	O
defend_both	function
(	O
astr	int
,	O
bstr	int
)	O
;	O
defended1	int
=	O
gg_min	O
(	O
defended1	int
,	O
defended	int
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
return	O
REVERSE_RESULT	O
(	O
gg_min	O
(	O
defended0	int
,	O
defended1	int
)	O
)	O
;	O
}	O
}	O
int	O
defend_both	function
(	O
int	O
astr	int
,	O
int	O
bstr	int
)	O
{	O
int	O
a_threatened	int
=	O
0	int
;	O
int	O
b_threatened	int
=	O
0	int
;	O
int	O
a_savepos	int
;	O
int	O
b_savepos	int
;	O
int	O
acode	int
=	O
0	int
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
color	int
=	O
board	pointer
[	O
astr	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
astr	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
board	pointer
[	O
bstr	int
]	O
,	O
bstr	int
)	O
;	O
if	O
(	O
countlib	function
(	O
astr	int
)	O
>	O
countlib	function
(	O
bstr	int
)	O
)	O
{	O
int	O
t	int
=	O
astr	int
;	O
astr	int
=	O
bstr	int
;	O
bstr	int
=	O
t	int
;	O
}	O
attack_and_defend	function
(	O
astr	int
,	O
&	O
acode	int
,	O
NULL	O
,	O
&	O
dcode	int
,	O
&	O
a_savepos	int
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
a_threatened	int
=	O
1	int
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
)	O
return	O
0	int
;	O
}	O
attack_and_defend	function
(	O
bstr	int
,	O
&	O
acode	int
,	O
NULL	O
,	O
&	O
dcode	int
,	O
&	O
b_savepos	int
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
b_threatened	int
=	O
1	int
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
)	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
a_threatened	int
||	O
!	O
b_threatened	int
)	O
return	O
WIN	int
;	O
if	O
(	O
a_savepos	int
==	O
b_savepos	int
)	O
return	O
WIN	int
;	O
if	O
(	O
trymove	function
(	O
a_savepos	int
,	O
color	int
,	O
"defend_both-A"	pointer
,	O
astr	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
bstr	int
]	O
&&	O
!	O
attack	function
(	O
bstr	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
return	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
trymove	function
(	O
b_savepos	int
,	O
color	int
,	O
"defend_both-B"	pointer
,	O
bstr	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
astr	int
]	O
&&	O
!	O
attack	function
(	O
astr	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
return	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
{	O
int	O
adjs1	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighbors1	int
;	O
int	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighbors2	int
;	O
int	O
r	int
;	O
int	O
s	int
;	O
int	O
epos	int
;	O
int	O
fpos	int
;	O
neighbors1	int
=	O
chainlinks	function
(	O
astr	int
,	O
adjs1	array
)	O
;	O
neighbors2	int
=	O
chainlinks	function
(	O
bstr	int
,	O
adjs2	array
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
neighbors1	int
;	O
r	int
++	O
)	O
{	O
epos	int
=	O
adjs1	array
[	O
r	int
]	O
;	O
if	O
(	O
countlib	function
(	O
epos	int
)	O
<=	O
4	int
&&	O
(	O
epos	int
!=	O
a_savepos	int
)	O
&&	O
(	O
epos	int
!=	O
b_savepos	int
)	O
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
neighbors2	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
adjs2	array
[	O
s	int
]	O
==	O
adjs1	array
[	O
r	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
s	int
==	O
neighbors2	int
)	O
continue	O
;	O
if	O
(	O
attack	function
(	O
epos	int
,	O
&	O
fpos	int
)	O
)	O
{	O
if	O
(	O
trymove	function
(	O
fpos	int
,	O
color	int
,	O
"defend_both-C"	pointer
,	O
astr	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
astr	int
]	O
&&	O
board	pointer
[	O
bstr	int
]	O
&&	O
!	O
attack	function
(	O
astr	int
,	O
NULL	O
)	O
&&	O
!	O
attack	function
(	O
bstr	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
return	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
break_through_helper	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
dpos	int
,	O
int	O
epos	int
,	O
int	O
Fpos	int
,	O
int	O
color	int
,	O
int	O
other	int
)	O
;	O
int	O
break_through	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
apos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
dpos	int
;	O
int	O
epos	int
;	O
int	O
Fpos	int
;	O
int	O
gpos	int
;	O
int	O
success	int
=	O
0	int
;	O
int	O
success2	int
=	O
0	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
apos	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
board	pointer
[	O
bpos	int
]	O
,	O
bpos	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
board	pointer
[	O
cpos	int
]	O
,	O
cpos	int
)	O
;	O
Fpos	int
=	O
(	O
apos	int
+	O
cpos	int
)	O
/	O
2	int
;	O
dpos	int
=	O
apos	int
+	O
bpos	int
-	O
Fpos	int
;	O
epos	int
=	O
bpos	int
+	O
cpos	int
-	O
Fpos	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
dpos	int
]	O
==	O
EMPTY	int
,	O
dpos	int
)	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
epos	int
]	O
==	O
EMPTY	int
,	O
epos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
Fpos	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
Fpos	int
]	O
==	O
other	int
,	O
Fpos	int
)	O
;	O
success	int
=	O
break_through_helper	function
(	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
dpos	int
,	O
epos	int
,	O
Fpos	int
,	O
color	int
,	O
other	int
)	O
;	O
if	O
(	O
success	int
==	O
WIN	int
)	O
return	O
WIN	int
;	O
success2	int
=	O
break_through_helper	function
(	O
cpos	int
,	O
bpos	int
,	O
apos	int
,	O
epos	int
,	O
dpos	int
,	O
Fpos	int
,	O
color	int
,	O
other	int
)	O
;	O
if	O
(	O
success2	int
==	O
WIN	int
)	O
return	O
WIN	int
;	O
if	O
(	O
success2	int
==	O
CUT	int
)	O
success	int
=	O
CUT	int
;	O
success2	int
=	O
0	int
;	O
if	O
(	O
attack_and_defend	function
(	O
Fpos	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
gpos	int
)	O
)	O
{	O
if	O
(	O
trymove	function
(	O
gpos	int
,	O
other	int
,	O
"break_through-A"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
trymove	function
(	O
dpos	int
,	O
color	int
,	O
"break_through-B"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
safe_move	function
(	O
epos	int
,	O
other	int
)	O
)	O
{	O
success2	int
=	O
CUT	int
;	O
if	O
(	O
!	O
board	pointer
[	O
cpos	int
]	O
||	O
attack	function
(	O
cpos	int
,	O
NULL	O
)	O
)	O
success2	int
=	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
success2	int
>	O
0	int
&&	O
trymove	function
(	O
epos	int
,	O
color	int
,	O
"break_through-C"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
safe_move	function
(	O
dpos	int
,	O
other	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
&&	O
!	O
attack	function
(	O
apos	int
,	O
NULL	O
)	O
)	O
success2	int
=	O
CUT	int
;	O
}	O
else	O
success2	int
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
success2	int
>	O
0	int
)	O
return	O
success2	int
;	O
return	O
success	int
;	O
}	O
static	O
int	O
break_through_helper	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
cpos	int
,	O
int	O
dpos	int
,	O
int	O
epos	int
,	O
int	O
Fpos	int
,	O
int	O
color	int
,	O
int	O
other	int
)	O
{	O
int	O
success	int
=	O
0	int
;	O
int	O
gpos	int
;	O
if	O
(	O
trymove	function
(	O
dpos	int
,	O
other	int
,	O
"break_through_helper-A"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
!	O
attack	function
(	O
Fpos	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
attack	function
(	O
dpos	int
,	O
&	O
gpos	int
)	O
)	O
success	int
=	O
CUT	int
;	O
else	O
{	O
if	O
(	O
trymove	function
(	O
epos	int
,	O
color	int
,	O
"break_through_helper-E"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
!	O
board	pointer
[	O
dpos	int
]	O
||	O
!	O
find_defense	function
(	O
dpos	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
gpos	int
==	O
epos	int
)	O
{	O
popgo	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
trymove	function
(	O
gpos	int
,	O
color	int
,	O
"break_through_helper-F"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
trymove	function
(	O
epos	int
,	O
other	int
,	O
"break_through_helper-G"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
!	O
attack	function
(	O
epos	int
,	O
NULL	O
)	O
)	O
{	O
success	int
=	O
CUT	int
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
&&	O
board	pointer
[	O
cpos	int
]	O
&&	O
defend_both	function
(	O
bpos	int
,	O
cpos	int
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
return	O
CUT	int
;	O
}	O
}	O
else	O
{	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
else	O
{	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
board	pointer
[	O
apos	int
]	O
||	O
!	O
board	pointer
[	O
bpos	int
]	O
||	O
!	O
defend_both	function
(	O
apos	int
,	O
bpos	int
)	O
)	O
success	int
=	O
WIN	int
;	O
else	O
{	O
int	O
attack_on_b	int
=	O
0	int
;	O
int	O
attack_on_a	int
=	O
0	int
;	O
if	O
(	O
trymove	function
(	O
epos	int
,	O
color	int
,	O
"break_through_helper-B"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
attack	function
(	O
bpos	int
,	O
NULL	O
)	O
)	O
attack_on_b	int
=	O
1	int
;	O
else	O
if	O
(	O
attack	function
(	O
apos	int
,	O
NULL	O
)	O
)	O
attack_on_a	int
=	O
1	int
;	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
attack_on_a	int
||	O
attack_on_b	int
)	O
{	O
int	O
hpos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
(	O
(	O
attack_on_a	int
&&	O
find_defense	function
(	O
apos	int
,	O
&	O
hpos	int
)	O
)	O
||	O
(	O
attack_on_b	int
&&	O
find_defense	function
(	O
bpos	int
,	O
&	O
hpos	int
)	O
)	O
)	O
&&	O
hpos	int
!=	O
NO_MOVE	O
&&	O
trymove	function
(	O
hpos	int
,	O
color	int
,	O
"break_through_helper-C"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
trymove	function
(	O
epos	int
,	O
other	int
,	O
"break_through_helper-D"	pointer
,	O
Fpos	int
)	O
)	O
{	O
if	O
(	O
!	O
board	pointer
[	O
bpos	int
]	O
||	O
!	O
board	pointer
[	O
cpos	int
]	O
||	O
!	O
defend_both	function
(	O
bpos	int
,	O
cpos	int
)	O
)	O
success	int
=	O
WIN	int
;	O
popgo	function
(	O
)	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
else	O
success	int
=	O
WIN	int
;	O
}	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
return	O
success	int
;	O
}	O
int	O
attack_threats	function
(	O
int	O
str	int
,	O
int	O
max_points	int
,	O
int	O
moves	array
[	O
]	O
,	O
int	O
codes	array
[	O
]	O
)	O
{	O
int	O
other	int
;	O
int	O
num_threats	int
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
num_adj	pointer
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
k	int
;	O
int	O
l	int
;	O
int	O
r	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
other	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
;	O
if	O
(	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
if	O
(	O
liberties	pointer
>	O
1	int
&&	O
liberties	pointer
<	O
6	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
int	O
aa	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
if	O
(	O
trymove	function
(	O
aa	int
,	O
other	int
,	O
"attack_threats-A"	pointer
,	O
str	int
)	O
)	O
{	O
int	O
acode	int
=	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
movelist_change_point	function
(	O
aa	int
,	O
acode	int
,	O
max_points	int
,	O
moves	array
,	O
codes	array
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
4	int
;	O
l	int
++	O
)	O
{	O
int	O
bb	int
=	O
libs	pointer
[	O
k	int
]	O
+	O
delta	array
[	O
l	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
bb	int
)	O
||	O
IS_STONE	O
(	O
board	pointer
[	O
bb	int
]	O
)	O
||	O
liberty_of_string	function
(	O
bb	int
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
trymove	function
(	O
bb	int
,	O
other	int
,	O
"attack_threats-B"	pointer
,	O
str	int
)	O
)	O
{	O
int	O
acode	int
=	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
movelist_change_point	function
(	O
bb	int
,	O
acode	int
,	O
max_points	int
,	O
moves	array
,	O
codes	array
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
num_adj	pointer
=	O
chainlinks	function
(	O
str	int
,	O
adjs	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_adj	pointer
;	O
k	int
++	O
)	O
{	O
int	O
bb	int
;	O
int	O
dd	int
;	O
int	O
acode	int
;	O
int	O
dcode	int
;	O
attack_and_defend	function
(	O
adjs	array
[	O
k	int
]	O
,	O
&	O
acode	int
,	O
NULL	O
,	O
&	O
dcode	int
,	O
&	O
dd	int
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
||	O
dcode	int
==	O
0	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
-	O
1	int
;	O
r	int
<	O
max_points	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
stackp	int
==	O
0	int
)	O
{	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
continue	O
;	O
if	O
(	O
worm	array
[	O
adjs	array
[	O
k	int
]	O
]	O
.	O
defense_codes	array
[	O
r	int
]	O
==	O
0	int
)	O
break	O
;	O
bb	int
=	O
worm	array
[	O
adjs	array
[	O
k	int
]	O
]	O
.	O
defense_points	array
[	O
r	int
]	O
;	O
}	O
else	O
{	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
bb	int
=	O
dd	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
trymove	function
(	O
bb	int
,	O
other	int
,	O
"attack_threats-C"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
acode	int
=	O
WIN	int
;	O
else	O
acode	int
=	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
movelist_change_point	function
(	O
bb	int
,	O
acode	int
,	O
max_points	int
,	O
moves	array
,	O
codes	array
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
codes	array
[	O
max_points	int
-	O
1	int
]	O
>	O
0	int
)	O
return	O
max_points	int
;	O
for	O
(	O
num_threats	int
=	O
0	int
;	O
num_threats	int
<	O
max_points	int
;	O
num_threats	int
++	O
)	O
if	O
(	O
codes	array
[	O
num_threats	int
]	O
==	O
0	int
)	O
break	O
;	O
return	O
num_threats	int
;	O
}	O
static	O
int	O
do_find_defense	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
liberties	pointer
;	O
int	O
retval	int
;	O
SETUP_TRACE_INFO	O
(	O
"find_defense"	pointer
,	O
str	int
)	O
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
liberties	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
if	O
(	O
liberties	pointer
>	O
4	int
||	O
(	O
liberties	pointer
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
||	O
(	O
liberties	pointer
==	O
3	int
&&	O
stackp	int
>	O
depth	int
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
WIN	int
,	O
"too many liberties or stackp > depth"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
0	int
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
liberties	pointer
>	O
2	int
&&	O
move	pointer
)	O
xpos	int
=	O
*	O
move	pointer
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
tt_get	function
(	O
&	O
ttable	struct
,	O
FIND_DEFENSE	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
retval	int
,	O
NULL	O
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
retval	int
,	O
xpos	int
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
retval	int
,	O
"cached"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
return	O
retval	int
;	O
}	O
if	O
(	O
liberties	pointer
==	O
1	int
)	O
dcode	int
=	O
defend1	pointer
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	pointer
==	O
2	int
)	O
dcode	int
=	O
defend2	pointer
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	pointer
==	O
3	int
)	O
dcode	int
=	O
defend3	function
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	pointer
==	O
4	int
)	O
dcode	int
=	O
defend4	function
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
dcode	int
)	O
{	O
READ_RETURN	O
(	O
FIND_DEFENSE	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
xpos	int
,	O
dcode	int
)	O
;	O
}	O
READ_RETURN0	O
(	O
FIND_DEFENSE	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
)	O
;	O
}	O
static	O
int	O
allows_under_the_stones_tesuji	function
(	O
int	O
move	pointer
,	O
int	O
color	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
;	O
if	O
(	O
accuratelib	function
(	O
move	pointer
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
!=	O
2	int
)	O
return	O
0	int
;	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"allows_under_the_stones_tesuji"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
findlib	function
(	O
move	pointer
,	O
2	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
(	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
color	int
)	O
&&	O
accuratelib	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
||	O
(	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
color	int
)	O
&&	O
accuratelib	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
)	O
result	int
=	O
1	int
;	O
popgo	function
(	O
)	O
;	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
fast_defense	function
(	O
int	O
str	int
,	O
int	O
liberties	pointer
,	O
int	O
*	O
libs	pointer
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
j	int
,	O
k	int
,	O
l	int
;	O
int	O
goal_liberties	int
=	O
(	O
stackp	int
<	O
fourlib_depth	int
?	O
5	int
:	O
4	int
)	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
static	O
unsigned	O
liberty_mark	int
=	O
~	O
0U	int
;	O
static	O
unsigned	O
lm	array
[	O
BOARDMAX	O
]	O
;	O
ASSERT1	O
(	O
libs	pointer
!=	O
NULL	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
move	pointer
!=	O
NULL	O
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
if	O
(	O
accuratelib	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
color	int
,	O
goal_liberties	int
,	O
NULL	O
)	O
>=	O
goal_liberties	int
)	O
{	O
*	O
move	pointer
=	O
libs	pointer
[	O
k	int
]	O
;	O
return	O
1	int
;	O
}	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
adj	array
;	O
j	int
++	O
)	O
{	O
int	O
lib	int
;	O
int	O
missing	int
=	O
goal_liberties	int
-	O
liberties	pointer
;	O
int	O
total	int
=	O
0	int
;	O
int	O
adj2	int
,	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
alib	int
,	O
alibs	array
[	O
MAXLIBS	O
]	O
;	O
int	O
num_adjacent_stones	int
;	O
findlib	function
(	O
adjs	array
[	O
j	int
]	O
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
if	O
(	O
(	O
liberties	pointer
==	O
1	int
&&	O
lib	int
==	O
libs	pointer
[	O
0	int
]	O
&&	O
countstones	function
(	O
adjs	array
[	O
j	int
]	O
)	O
<=	O
2	int
)	O
||	O
is_ko	function
(	O
lib	int
,	O
color	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
num_adjacent_stones	int
=	O
count_adjacent_stones	function
(	O
adjs	array
[	O
j	int
]	O
,	O
str	int
,	O
missing	int
)	O
;	O
if	O
(	O
!	O
liberty_of_string	function
(	O
lib	int
,	O
str	int
)	O
&&	O
num_adjacent_stones	int
>=	O
missing	int
)	O
{	O
*	O
move	pointer
=	O
lib	int
;	O
return	O
1	int
;	O
}	O
ASSERT1	O
(	O
num_adjacent_stones	int
>=	O
1	int
,	O
str	int
)	O
;	O
if	O
(	O
++	O
liberty_mark	int
==	O
0	int
)	O
{	O
memset	function
(	O
lm	array
,	O
0	int
,	O
sizeof	O
(	O
lm	array
)	O
)	O
;	O
liberty_mark	int
++	O
;	O
}	O
adj2	int
=	O
chainlinks	function
(	O
adjs	array
[	O
j	int
]	O
,	O
adjs2	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj2	int
;	O
k	int
++	O
)	O
{	O
alib	int
=	O
findlib	function
(	O
adjs2	array
[	O
k	int
]	O
,	O
MAXLIBS	O
,	O
alibs	array
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
alib	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
lm	array
[	O
alibs	array
[	O
l	int
]	O
]	O
!=	O
liberty_mark	int
)	O
{	O
lm	array
[	O
alibs	array
[	O
l	int
]	O
]	O
=	O
liberty_mark	int
;	O
total	int
++	O
;	O
}	O
}	O
}	O
total	int
+=	O
countstones	function
(	O
adjs	array
[	O
j	int
]	O
)	O
-	O
2	int
;	O
if	O
(	O
lm	array
[	O
lib	int
]	O
==	O
liberty_mark	int
)	O
total	int
--	O
;	O
if	O
(	O
num_adjacent_stones	int
==	O
1	int
)	O
total	int
--	O
;	O
if	O
(	O
total	int
>=	O
goal_liberties	int
)	O
{	O
if	O
(	O
liberties	pointer
==	O
1	int
&&	O
lib	int
==	O
libs	pointer
[	O
0	int
]	O
&&	O
allows_under_the_stones_tesuji	function
(	O
lib	int
,	O
color	int
)	O
)	O
{	O
continue	O
;	O
}	O
*	O
move	pointer
=	O
lib	int
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
defend1	pointer
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
lib	int
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
liberties	pointer
;	O
int	O
k	int
;	O
SETUP_TRACE_INFO	O
(	O
"defend1"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
1	int
,	O
str	int
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
ASSERT1	O
(	O
liberties	pointer
==	O
1	int
,	O
str	int
)	O
;	O
if	O
(	O
fast_defense	function
(	O
str	int
,	O
liberties	pointer
,	O
&	O
lib	int
,	O
&	O
xpos	int
)	O
)	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	pointer
,	O
"fast defense"	pointer
)	O
;	O
moves	array
.	O
pos	int
[	O
0	int
]	O
=	O
lib	int
;	O
moves	array
.	O
score	float
[	O
0	int
]	O
=	O
0	int
;	O
moves	array
.	O
message	pointer
[	O
0	int
]	O
=	O
"liberty"	pointer
;	O
moves	array
.	O
num	int
=	O
1	int
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
set_up_snapback_moves	function
(	O
str	int
,	O
lib	int
,	O
&	O
moves	array
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
&&	O
countstones	function
(	O
str	int
)	O
==	O
1	int
&&	O
is_ko	function
(	O
lib	int
,	O
other	int
,	O
NULL	O
)	O
)	O
{	O
int	O
libs2	array
[	O
6	int
]	O
;	O
liberties	pointer
=	O
approxlib	function
(	O
lib	int
,	O
color	int
,	O
6	int
,	O
libs2	array
)	O
;	O
if	O
(	O
liberties	pointer
<=	O
5	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
libs2	array
[	O
k	int
]	O
;	O
if	O
(	O
(	O
liberties	pointer
==	O
1	int
||	O
!	O
is_self_atari	function
(	O
apos	int
,	O
other	int
)	O
)	O
&&	O
trymove	function
(	O
apos	int
,	O
color	int
,	O
"defend1-C"	pointer
,	O
str	int
)	O
)	O
{	O
int	O
acode	int
=	O
do_attack	int
(	O
str	int
,	O
NULL	O
)	O
;	O
popgo	function
(	O
)	O
;	O
CHECK_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
apos	int
,	O
move	pointer
,	O
"backfilling"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
int	O
defend2	pointer
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
,	O
other	int
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
liberties2	int
;	O
int	O
libs2	array
[	O
6	int
]	O
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
int	O
string_size	int
;	O
int	O
be_aggressive	int
;	O
SETUP_TRACE_INFO	O
(	O
"defend2"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
fast_defense	function
(	O
str	int
,	O
liberties	pointer
,	O
libs	pointer
,	O
&	O
xpos	int
)	O
)	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	pointer
,	O
"fast defense"	pointer
)	O
;	O
moves	array
.	O
num	int
=	O
0	int
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
string_size	int
=	O
countstones	function
(	O
str	int
)	O
;	O
if	O
(	O
string_size	int
==	O
1	int
||	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
0	int
]	O
,	O
0	int
,	O
moves	array
,	O
"liberty"	pointer
)	O
;	O
if	O
(	O
string_size	int
==	O
1	int
||	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
1	int
]	O
,	O
0	int
,	O
moves	array
,	O
"liberty"	pointer
)	O
;	O
break_chain_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
break_chain2_efficient_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
propose_edge_moves	function
(	O
str	int
,	O
libs	pointer
,	O
liberties	pointer
,	O
&	O
moves	array
,	O
color	int
)	O
;	O
edge_clamp_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
special_rescue_moves	function
(	O
str	int
,	O
libs	pointer
[	O
k	int
]	O
,	O
&	O
moves	array
)	O
;	O
bamboo_rescue_moves	function
(	O
str	int
,	O
liberties	pointer
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
}	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
special_rescue2_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
0	int
,	O
&	O
suggest_move	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
if	O
(	O
is_self_atari	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
)	O
)	O
{	O
liberties2	int
=	O
approxlib	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
color	int
,	O
6	int
,	O
libs2	array
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties2	int
;	O
r	int
++	O
)	O
{	O
xpos	int
=	O
libs2	array
[	O
r	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
xpos	int
,	O
color	int
)	O
&&	O
has_neighbor	function
(	O
xpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
moves	array
,	O
"backfill-A"	pointer
)	O
;	O
}	O
}	O
liberties2	int
=	O
approxlib	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
,	O
3	int
,	O
libs2	array
)	O
;	O
if	O
(	O
liberties2	int
<=	O
2	int
)	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties2	int
;	O
r	int
++	O
)	O
{	O
xpos	int
=	O
libs2	array
[	O
r	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
xpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
moves	array
,	O
"backfill-B"	pointer
)	O
;	O
}	O
}	O
}	O
special_rescue4_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
0	int
,	O
&	O
suggest_move	int
)	O
;	O
be_aggressive	int
=	O
(	O
moves	array
.	O
num	int
==	O
0	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
superstring_depth	int
)	O
superstring_break_chain_moves	function
(	O
str	int
,	O
4	int
,	O
&	O
moves	array
)	O
;	O
if	O
(	O
stackp	int
<=	O
superstring_depth	int
)	O
{	O
superstring_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
3	int
,	O
0	int
)	O
;	O
squeeze_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
}	O
break_chain2_defense_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
be_aggressive	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
special_rescue5_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
)	O
break_chain3_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
be_aggressive	int
)	O
;	O
if	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
break_chain4_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
be_aggressive	int
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
0	int
,	O
&	O
suggest_move	int
)	O
;	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
int	O
defend3	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
3	int
]	O
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"defend3"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
3	int
,	O
str	int
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
3	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
fast_defense	function
(	O
str	int
,	O
liberties	pointer
,	O
libs	pointer
,	O
&	O
xpos	int
)	O
)	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	pointer
,	O
"fast defense"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
moves	array
.	O
pos	int
[	O
k	int
]	O
=	O
libs	pointer
[	O
k	int
]	O
;	O
moves	array
.	O
score	float
[	O
k	int
]	O
=	O
0	int
;	O
moves	array
.	O
message	pointer
[	O
k	int
]	O
=	O
"liberty"	pointer
;	O
}	O
moves	array
.	O
num	int
=	O
liberties	pointer
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
break_chain2_efficient_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
propose_edge_moves	function
(	O
str	int
,	O
libs	pointer
,	O
liberties	pointer
,	O
&	O
moves	array
,	O
color	int
)	O
;	O
edge_clamp_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
)	O
hane_rescue_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
special_rescue3_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
special_rescue_moves	function
(	O
str	int
,	O
libs	pointer
[	O
k	int
]	O
,	O
&	O
moves	array
)	O
;	O
bamboo_rescue_moves	function
(	O
str	int
,	O
liberties	pointer
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
}	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
&&	O
stackp	int
<=	O
backfill2_depth	int
)	O
superstring_break_chain_moves	function
(	O
str	int
,	O
4	int
,	O
&	O
moves	array
)	O
;	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
)	O
break_chain2_defense_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
0	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
{	O
special_rescue5_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
special_rescue6_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
}	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
&&	O
stackp	int
<=	O
backfill2_depth	int
)	O
{	O
superstring_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
3	int
,	O
0	int
)	O
;	O
squeeze_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
}	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
)	O
break_chain3_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
0	int
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
int	O
defend4	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"defend4"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
4	int
,	O
str	int
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
4	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
fast_defense	function
(	O
str	int
,	O
liberties	pointer
,	O
libs	pointer
,	O
&	O
xpos	int
)	O
)	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	pointer
,	O
"fast defense"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
moves	array
.	O
pos	int
[	O
k	int
]	O
=	O
libs	pointer
[	O
k	int
]	O
;	O
moves	array
.	O
score	float
[	O
k	int
]	O
=	O
0	int
;	O
moves	array
.	O
message	pointer
[	O
k	int
]	O
=	O
"liberty"	pointer
;	O
}	O
moves	array
.	O
num	int
=	O
liberties	pointer
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
break_chain2_efficient_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
{	O
break_chain2_defense_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
0	int
)	O
;	O
break_chain3_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
0	int
)	O
;	O
break_chain4_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
0	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
superstring_depth	int
)	O
superstring_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
4	int
,	O
0	int
)	O
;	O
squeeze_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
}	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
depth	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
special_rescue_moves	function
(	O
str	int
,	O
libs	pointer
[	O
k	int
]	O
,	O
&	O
moves	array
)	O
;	O
bamboo_rescue_moves	function
(	O
str	int
,	O
liberties	pointer
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
}	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
DEFEND_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
void	O
special_rescue_moves	function
(	O
int	O
str	int
,	O
int	O
lib	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
otherlib	int
;	O
int	O
k	int
;	O
otherlib	int
=	O
approxlib	function
(	O
lib	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
;	O
if	O
(	O
otherlib	int
>	O
2	int
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
lib	int
+	O
d	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
is_self_atari	function
(	O
lib	int
+	O
d	int
,	O
color	int
)	O
&&	O
otherlib	int
>	O
1	int
)	O
continue	O
;	O
if	O
(	O
countlib	function
(	O
str	int
)	O
>	O
3	int
)	O
{	O
int	O
r	int
;	O
int	O
number_protected	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
lib	int
+	O
d	int
+	O
delta	array
[	O
r	int
]	O
]	O
==	O
EMPTY	int
&&	O
approxlib	function
(	O
lib	int
+	O
d	int
+	O
delta	array
[	O
r	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<	O
3	int
)	O
number_protected	int
++	O
;	O
if	O
(	O
number_protected	int
==	O
2	int
)	O
break	O
;	O
}	O
if	O
(	O
number_protected	int
<	O
2	int
)	O
continue	O
;	O
}	O
ADD_CANDIDATE_MOVE	O
(	O
lib	int
+	O
d	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
bamboo_rescue_moves	function
(	O
int	O
str	int
,	O
int	O
num_libs	int
,	O
int	O
libs	pointer
[	O
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
l1	int
,	O
l2	int
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
num_libs	int
;	O
l1	int
++	O
)	O
for	O
(	O
l2	int
=	O
0	int
;	O
l2	int
<	O
num_libs	int
;	O
l2	int
++	O
)	O
{	O
if	O
(	O
l1	int
==	O
l2	int
)	O
continue	O
;	O
if	O
(	O
libs	pointer
[	O
l1	int
]	O
==	O
WEST	O
(	O
libs	pointer
[	O
l2	int
]	O
)	O
||	O
libs	pointer
[	O
l1	int
]	O
==	O
EAST	O
(	O
libs	pointer
[	O
l2	int
]	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
SOUTH	O
(	O
libs	pointer
[	O
l2	int
]	O
)	O
]	O
==	O
color	int
&&	O
!	O
is_self_atari	function
(	O
SOUTH	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
SOUTH	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
,	O
0	int
,	O
*	O
moves	array
,	O
"bamboo_rescue"	pointer
)	O
;	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
NORTH	O
(	O
libs	pointer
[	O
l2	int
]	O
)	O
]	O
==	O
color	int
&&	O
!	O
is_self_atari	function
(	O
NORTH	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
NORTH	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
,	O
0	int
,	O
*	O
moves	array
,	O
"bamboo_rescue"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
libs	pointer
[	O
l1	int
]	O
==	O
NORTH	O
(	O
libs	pointer
[	O
l2	int
]	O
)	O
||	O
libs	pointer
[	O
l1	int
]	O
==	O
SOUTH	O
(	O
libs	pointer
[	O
l2	int
]	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
WEST	O
(	O
libs	pointer
[	O
l2	int
]	O
)	O
]	O
==	O
color	int
&&	O
!	O
is_self_atari	function
(	O
WEST	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
WEST	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
,	O
0	int
,	O
*	O
moves	array
,	O
"bamboo_rescue"	pointer
)	O
;	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
EAST	O
(	O
libs	pointer
[	O
l2	int
]	O
)	O
]	O
==	O
color	int
&&	O
!	O
is_self_atari	function
(	O
EAST	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
EAST	O
(	O
libs	pointer
[	O
l1	int
]	O
)	O
,	O
0	int
,	O
*	O
moves	array
,	O
"bamboo_rescue"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
special_rescue2_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
newlibs	array
[	O
4	int
]	O
;	O
int	O
liberties	pointer
;	O
int	O
newstr	int
;	O
int	O
k	int
,	O
r	int
,	O
s	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
2	int
;	O
r	int
++	O
)	O
{	O
int	O
alib	int
=	O
libs	pointer
[	O
r	int
]	O
;	O
if	O
(	O
!	O
is_suicide	function
(	O
alib	int
,	O
other	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
alib	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
!	O
same_string	function
(	O
alib	int
+	O
delta	array
[	O
k	int
]	O
,	O
str	int
)	O
)	O
{	O
newstr	int
=	O
alib	int
+	O
delta	array
[	O
k	int
]	O
;	O
liberties	pointer
=	O
findlib	function
(	O
newstr	int
,	O
4	int
,	O
newlibs	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
&&	O
s	int
<	O
4	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
!	O
is_self_atari	function
(	O
newlibs	array
[	O
s	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
newlibs	array
[	O
s	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue2"	pointer
)	O
;	O
}	O
break_chain_moves	function
(	O
newstr	int
,	O
moves	array
)	O
;	O
break_chain2_efficient_moves	function
(	O
newstr	int
,	O
moves	array
)	O
;	O
edge_clamp_moves	function
(	O
newstr	int
,	O
moves	array
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_rescue3_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
dpos	int
,	O
epos	int
,	O
fpos	int
,	O
gpos	int
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
3	int
,	O
str	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
3	int
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
bpos	int
=	O
apos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
bpos	int
)	O
)	O
continue	O
;	O
cpos	int
=	O
apos	int
-	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
!=	O
color	int
)	O
continue	O
;	O
if	O
(	O
!	O
same_string	function
(	O
cpos	int
,	O
str	int
)	O
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
normal	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
normal	int
=	O
-	O
normal	int
;	O
dpos	int
=	O
cpos	int
+	O
normal	int
;	O
if	O
(	O
board	pointer
[	O
dpos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
epos	int
=	O
dpos	int
+	O
normal	int
;	O
if	O
(	O
board	pointer
[	O
epos	int
]	O
!=	O
color	int
)	O
continue	O
;	O
fpos	int
=	O
apos	int
+	O
normal	int
;	O
if	O
(	O
board	pointer
[	O
fpos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
gpos	int
=	O
fpos	int
+	O
normal	int
;	O
if	O
(	O
board	pointer
[	O
gpos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
approxlib	function
(	O
apos	int
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
>	O
3	int
)	O
continue	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
fpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue3"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_rescue4_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
libs2	array
[	O
2	int
]	O
;	O
int	O
k	int
;	O
int	O
r	int
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
bpos	int
=	O
libs	pointer
[	O
1	int
-	O
k	int
]	O
;	O
if	O
(	O
apos	int
==	O
SOUTH	O
(	O
bpos	int
)	O
||	O
apos	int
==	O
NORTH	O
(	O
bpos	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
apos	int
)	O
]	O
==	O
other	int
)	O
xpos	int
=	O
WEST	O
(	O
apos	int
)	O
;	O
else	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
apos	int
)	O
]	O
==	O
other	int
)	O
xpos	int
=	O
EAST	O
(	O
apos	int
)	O
;	O
else	O
continue	O
;	O
}	O
else	O
if	O
(	O
apos	int
==	O
WEST	O
(	O
bpos	int
)	O
||	O
apos	int
==	O
EAST	O
(	O
bpos	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
apos	int
)	O
]	O
==	O
other	int
)	O
xpos	int
=	O
SOUTH	O
(	O
apos	int
)	O
;	O
else	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
apos	int
)	O
]	O
==	O
other	int
)	O
xpos	int
=	O
NORTH	O
(	O
apos	int
)	O
;	O
else	O
continue	O
;	O
}	O
else	O
return	O
;	O
if	O
(	O
findlib	function
(	O
xpos	int
,	O
2	int
,	O
libs2	array
)	O
==	O
2	int
)	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
2	int
;	O
r	int
++	O
)	O
if	O
(	O
libs2	array
[	O
r	int
]	O
!=	O
apos	int
&&	O
libs2	array
[	O
r	int
]	O
!=	O
bpos	int
&&	O
!	O
is_self_atari	function
(	O
libs2	array
[	O
r	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array
[	O
r	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue4"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
hane_rescue_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
4	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
,	O
bpos	int
,	O
cpos	int
,	O
dpos	int
;	O
int	O
num_libs	int
=	O
countlib	function
(	O
str	int
)	O
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
ASSERT1	O
(	O
num_libs	int
<=	O
4	int
,	O
str	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_libs	int
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
bpos	int
=	O
apos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
!=	O
color	int
)	O
continue	O
;	O
if	O
(	O
!	O
same_string	function
(	O
bpos	int
,	O
str	int
)	O
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
normal	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
normal	int
=	O
-	O
normal	int
;	O
cpos	int
=	O
apos	int
+	O
normal	int
;	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
dpos	int
=	O
bpos	int
+	O
normal	int
;	O
if	O
(	O
board	pointer
[	O
dpos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
{	O
int	O
dlibs	int
=	O
countlib	function
(	O
dpos	int
)	O
;	O
if	O
(	O
dlibs	int
>	O
num_libs	int
||	O
dlibs	int
>	O
accuratelib	function
(	O
cpos	int
,	O
color	int
,	O
dlibs	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
}	O
if	O
(	O
0	int
&&	O
!	O
in_list	function
(	O
cpos	int
,	O
moves	array
->	O
num	int
,	O
moves	array
->	O
pos	int
)	O
)	O
{	O
gprintf	function
(	O
"hane_rescue_move added for %1m at %1m\n"	pointer
,	O
str	int
,	O
cpos	int
)	O
;	O
dump_stack	function
(	O
)	O
;	O
showboard	function
(	O
0	int
)	O
;	O
}	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"hane_rescue"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_rescue5_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
,	O
bpos	int
;	O
int	O
k	int
,	O
r	int
,	O
s	int
;	O
int	O
liberties	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
int	O
libs2	array
[	O
4	int
]	O
;	O
int	O
liberties2	int
;	O
ASSERT1	O
(	O
liberties	pointer
==	O
2	int
||	O
liberties	pointer
==	O
3	int
,	O
str	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
bpos	int
=	O
apos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
if	O
(	O
countlib	function
(	O
bpos	int
)	O
>	O
liberties	pointer
+	O
1	int
)	O
continue	O
;	O
if	O
(	O
count_common_libs	function
(	O
str	int
,	O
bpos	int
)	O
<	O
2	int
)	O
continue	O
;	O
liberties2	int
=	O
findlib	function
(	O
bpos	int
,	O
4	int
,	O
libs2	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties2	int
;	O
s	int
++	O
)	O
if	O
(	O
!	O
liberty_of_string	function
(	O
libs2	array
[	O
s	int
]	O
,	O
str	int
)	O
&&	O
!	O
is_self_atari	function
(	O
libs2	array
[	O
s	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array
[	O
s	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue5-A"	pointer
)	O
;	O
if	O
(	O
liberties2	int
<=	O
liberties	pointer
)	O
{	O
int	O
adj	array
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
t	int
;	O
adj	array
=	O
chainlinks2	function
(	O
bpos	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
adj	array
;	O
t	int
++	O
)	O
{	O
int	O
cpos	int
;	O
break_chain_moves	function
(	O
adjs	array
[	O
t	int
]	O
,	O
moves	array
)	O
;	O
findlib	function
(	O
adjs	array
[	O
t	int
]	O
,	O
1	int
,	O
&	O
cpos	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
cpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue5-B"	pointer
)	O
;	O
}	O
double_atari_chain2_moves	function
(	O
bpos	int
,	O
moves	array
,	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_rescue6_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
3	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
,	O
bpos	int
,	O
cpos	int
;	O
int	O
right	int
,	O
up	int
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
int	O
liberties	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
liberties	pointer
==	O
3	int
||	O
liberties	pointer
==	O
4	int
,	O
str	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
right	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
-	O
right	int
)	O
)	O
continue	O
;	O
bpos	int
=	O
apos	int
+	O
right	int
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
!=	O
color	int
||	O
!	O
same_string	function
(	O
str	int
,	O
bpos	int
)	O
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
up	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
up	int
=	O
-	O
up	int
;	O
cpos	int
=	O
bpos	int
+	O
up	int
;	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
up	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
cpos	int
+	O
right	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
up	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
cpos	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
cpos	int
+	O
up	int
+	O
right	int
]	O
==	O
color	int
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
+	O
right	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue6-A"	pointer
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
+	O
up	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue6-B"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
countlib	function
(	O
cpos	int
)	O
<=	O
3	int
&&	O
(	O
board	pointer
[	O
bpos	int
+	O
right	int
]	O
==	O
EMPTY	int
||	O
(	O
board	pointer
[	O
bpos	int
+	O
right	int
]	O
==	O
other	int
&&	O
countlib	function
(	O
bpos	int
+	O
right	int
)	O
<=	O
4	int
)	O
)	O
&&	O
!	O
is_self_atari	function
(	O
cpos	int
+	O
right	int
,	O
color	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
cpos	int
+	O
right	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_rescue6-C"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
set_up_snapback_moves	function
(	O
int	O
str	int
,	O
int	O
lib	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
libs2	array
[	O
2	int
]	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
1	int
,	O
str	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
&&	O
countstones	function
(	O
str	int
)	O
==	O
1	int
&&	O
approxlib	function
(	O
lib	int
,	O
other	int
,	O
2	int
,	O
libs2	array
)	O
==	O
1	int
&&	O
(	O
!	O
is_self_atari	function
(	O
libs2	array
[	O
0	int
]	O
,	O
color	int
)	O
||	O
is_ko	function
(	O
libs2	array
[	O
0	int
]	O
,	O
color	int
,	O
NULL	O
)	O
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array
[	O
0	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"set_up_snapback"	pointer
)	O
;	O
}	O
static	O
void	O
superstring_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
liberty_cap	int
,	O
int	O
does_attack	function
)	O
{	O
int	O
ss_liberties	int
;	O
int	O
ss_libs	array
[	O
MAX_LIBERTIES	int
+	O
4	int
]	O
;	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
find_superstring_liberties	function
(	O
str	int
,	O
&	O
ss_liberties	int
,	O
ss_libs	array
,	O
liberty_cap	int
)	O
;	O
if	O
(	O
ss_liberties	int
<=	O
5	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
ss_liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
ss_libs	array
[	O
k	int
]	O
;	O
int	O
alibs	array
[	O
2	int
]	O
;	O
int	O
alib	int
=	O
accuratelib	function
(	O
apos	int
,	O
other	int
,	O
2	int
,	O
alibs	array
)	O
;	O
if	O
(	O
liberty_of_string	function
(	O
apos	int
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
alib	int
>=	O
2	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"superstring liberty"	pointer
)	O
;	O
else	O
if	O
(	O
alib	int
==	O
1	int
&&	O
does_attack	function
&&	O
board	pointer
[	O
alibs	array
[	O
0	int
]	O
]	O
==	O
EMPTY	int
&&	O
approxlib	function
(	O
alibs	array
[	O
0	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
alibs	array
[	O
0	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"superstring backfill"	pointer
)	O
;	O
if	O
(	O
!	O
does_attack	function
)	O
special_rescue_moves	function
(	O
str	int
,	O
apos	int
,	O
moves	array
)	O
;	O
}	O
}	O
}	O
static	O
void	O
squeeze_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
int	O
num_libs	int
;	O
int	O
libs2	array
[	O
4	int
]	O
;	O
int	O
num_libs2	int
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
potential_move	int
=	O
NO_MOVE	O
;	O
int	O
previous_liberty	int
;	O
num_libs	int
=	O
findlib	function
(	O
str	int
,	O
4	int
,	O
libs	pointer
)	O
;	O
gg_assert	O
(	O
num_libs	int
<=	O
4	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_libs	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
is_suicide	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
)	O
)	O
continue	O
;	O
num_libs2	int
=	O
approxlib	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
color	int
,	O
4	int
,	O
libs2	array
)	O
;	O
if	O
(	O
num_libs2	int
!=	O
num_libs	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_libs2	int
;	O
r	int
++	O
)	O
if	O
(	O
!	O
liberty_of_string	function
(	O
libs2	array
[	O
r	int
]	O
,	O
str	int
)	O
)	O
{	O
potential_move	int
=	O
libs2	array
[	O
r	int
]	O
;	O
break	O
;	O
}	O
previous_liberty	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
while	O
(	O
is_suicide	function
(	O
potential_move	int
,	O
other	int
)	O
)	O
{	O
num_libs2	int
=	O
approxlib	function
(	O
potential_move	int
,	O
color	int
,	O
3	int
,	O
libs2	array
)	O
;	O
if	O
(	O
num_libs2	int
!=	O
2	int
)	O
{	O
potential_move	int
=	O
NO_MOVE	O
;	O
break	O
;	O
}	O
if	O
(	O
libs2	array
[	O
0	int
]	O
==	O
previous_liberty	int
)	O
{	O
previous_liberty	int
=	O
potential_move	int
;	O
potential_move	int
=	O
libs2	array
[	O
1	int
]	O
;	O
}	O
else	O
{	O
previous_liberty	int
=	O
potential_move	int
;	O
potential_move	int
=	O
libs2	array
[	O
0	int
]	O
;	O
}	O
if	O
(	O
liberty_of_string	function
(	O
potential_move	int
,	O
str	int
)	O
)	O
{	O
potential_move	int
=	O
NO_MOVE	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
potential_move	int
==	O
NO_MOVE	O
||	O
!	O
is_self_atari	function
(	O
potential_move	int
,	O
other	int
)	O
)	O
continue	O
;	O
approxlib	function
(	O
potential_move	int
,	O
other	int
,	O
1	int
,	O
libs2	array
)	O
;	O
num_libs2	int
=	O
approxlib	function
(	O
libs2	array
[	O
0	int
]	O
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
;	O
if	O
(	O
num_libs2	int
<	O
3	int
&&	O
num_libs2	int
<	O
approxlib	function
(	O
potential_move	int
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
potential_move	int
,	O
0	int
,	O
*	O
moves	array
,	O
"squeeze move"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
edge_clamp_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
cpos	int
;	O
int	O
dpos	int
;	O
int	O
epos	int
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	pointer
[	O
3	int
]	O
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
3	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
adjs	array
[	O
r	int
]	O
;	O
bpos	int
=	O
NO_MOVE	O
;	O
findlib	function
(	O
apos	int
,	O
3	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
is_edge_vertex	function
(	O
libs	pointer
[	O
k	int
]	O
)	O
)	O
{	O
bpos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
bpos	int
==	O
NO_MOVE	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
up	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
bpos	int
-	O
up	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
bpos	int
+	O
up	int
]	O
!=	O
other	int
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
right	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
right	int
=	O
-	O
right	int
;	O
cpos	int
=	O
bpos	int
+	O
up	int
-	O
right	int
;	O
dpos	int
=	O
bpos	int
+	O
up	int
+	O
right	int
;	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
!=	O
color	int
||	O
!	O
same_string	function
(	O
cpos	int
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
dpos	int
]	O
!=	O
EMPTY	int
||	O
!	O
liberty_of_string	function
(	O
dpos	int
,	O
apos	int
)	O
)	O
continue	O
;	O
epos	int
=	O
dpos	int
+	O
up	int
;	O
if	O
(	O
board	pointer
[	O
epos	int
]	O
!=	O
EMPTY	int
||	O
!	O
liberty_of_string	function
(	O
epos	int
,	O
apos	int
)	O
)	O
continue	O
;	O
if	O
(	O
approxlib	function
(	O
dpos	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
<	O
3	int
)	O
continue	O
;	O
if	O
(	O
approxlib	function
(	O
epos	int
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
>	O
3	int
)	O
continue	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
dpos	int
,	O
10	int
,	O
*	O
moves	array
,	O
"edge_clamp"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
propose_edge_moves	function
(	O
int	O
str	int
,	O
int	O
*	O
libs	pointer
,	O
int	O
liberties	pointer
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
to_move	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
right	int
;	O
int	O
up	int
;	O
int	O
apos	int
;	O
int	O
k	int
,	O
l	int
;	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
up	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
-	O
up	int
)	O
)	O
continue	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
right	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
l	int
==	O
1	int
)	O
right	int
=	O
-	O
right	int
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
up	int
]	O
==	O
other	int
&&	O
countlib	function
(	O
apos	int
+	O
up	int
)	O
>	O
4	int
&&	O
color	int
==	O
to_move	int
)	O
{	O
int	O
xpos	int
=	O
apos	int
;	O
while	O
(	O
ON_BOARD	O
(	O
xpos	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
xpos	int
]	O
==	O
color	int
||	O
board	pointer
[	O
xpos	int
+	O
up	int
]	O
==	O
color	int
)	O
break	O
;	O
xpos	int
+=	O
right	int
;	O
}	O
if	O
(	O
!	O
ON_BOARD	O
(	O
xpos	int
)	O
)	O
{	O
REMOVE_CANDIDATE_MOVE	O
(	O
apos	int
,	O
*	O
moves	array
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
apos	int
-	O
right	int
+	O
up	int
]	O
==	O
other	int
&&	O
board	pointer
[	O
apos	int
+	O
right	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
countlib	function
(	O
apos	int
+	O
up	int
-	O
right	int
)	O
==	O
1	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
+	O
up	int
,	O
10	int
,	O
*	O
moves	array
,	O
"propose_edge-A"	pointer
)	O
;	O
else	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
+	O
up	int
,	O
0	int
,	O
*	O
moves	array
,	O
"propose_edge-B"	pointer
)	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
right	int
+	O
up	int
]	O
==	O
EMPTY	int
&&	O
(	O
liberties	pointer
!=	O
2	int
||	O
color	int
!=	O
to_move	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
+	O
right	int
+	O
up	int
,	O
0	int
,	O
*	O
moves	array
,	O
"propose_edge-C"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
static	O
int	O
do_attack	int
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	pointer
;	O
int	O
result	int
=	O
0	int
;	O
int	O
retval	int
;	O
SETUP_TRACE_INFO	O
(	O
"attack"	pointer
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
color	int
!=	O
0	int
,	O
str	int
)	O
;	O
if	O
(	O
color	int
==	O
0	int
)	O
return	O
0	int
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
liberties	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
if	O
(	O
liberties	pointer
>	O
4	int
||	O
(	O
liberties	pointer
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
||	O
(	O
liberties	pointer
==	O
3	int
&&	O
stackp	int
>	O
depth	int
)	O
)	O
{	O
if	O
(	O
sgf_dumptree	pointer
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"got 4 liberties (stackp:%d>%d)"	pointer
,	O
stackp	int
,	O
fourlib_depth	int
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
buf	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
liberties	pointer
>	O
3	int
&&	O
move	pointer
)	O
xpos	int
=	O
*	O
move	pointer
;	O
if	O
(	O
stackp	int
<=	O
depth	int
&&	O
tt_get	function
(	O
&	O
ttable	struct
,	O
ATTACK	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
retval	int
,	O
NULL	O
,	O
&	O
xpos	int
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
retval	int
,	O
xpos	int
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
retval	int
,	O
"cached"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
return	O
retval	int
;	O
}	O
if	O
(	O
liberties	pointer
==	O
1	int
)	O
result	int
=	O
attack1	pointer
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	pointer
==	O
2	int
)	O
{	O
if	O
(	O
stackp	int
>	O
depth	int
+	O
10	int
)	O
result	int
=	O
simple_ladder	function
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
result	int
=	O
attack2	pointer
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
}	O
else	O
if	O
(	O
liberties	pointer
==	O
3	int
)	O
result	int
=	O
attack3	function
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
else	O
if	O
(	O
liberties	pointer
==	O
4	int
)	O
result	int
=	O
attack4	function
(	O
str	int
,	O
&	O
xpos	int
)	O
;	O
ASSERT1	O
(	O
result	int
>=	O
0	int
&&	O
result	int
<=	O
WIN	int
,	O
str	int
)	O
;	O
if	O
(	O
result	int
)	O
{	O
READ_RETURN	O
(	O
ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	pointer
,	O
xpos	int
,	O
result	int
)	O
;	O
}	O
READ_RETURN0	O
(	O
ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
)	O
;	O
}	O
static	O
int	O
attack1	pointer
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
6	int
]	O
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array
;	O
int	O
apos	int
;	O
SETUP_TRACE_INFO	O
(	O
"attack1"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
findlib	function
(	O
str	int
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
countstones	function
(	O
str	int
)	O
>	O
1	int
)	O
{	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	pointer
,	O
"last liberty"	pointer
)	O
;	O
}	O
if	O
(	O
trymove	function
(	O
xpos	int
,	O
other	int
,	O
"attack1-A"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
countlib	function
(	O
xpos	int
)	O
>	O
1	int
)	O
{	O
popgo	function
(	O
)	O
;	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	pointer
,	O
"last liberty"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
countstones	function
(	O
xpos	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
get_komaster	function
(	O
)	O
!=	O
other	int
)	O
{	O
CHECK_RESULT_UNREVERSED	O
(	O
savecode	int
,	O
savemove	int
,	O
KO_A	int
,	O
xpos	int
,	O
move	pointer
,	O
"last liberty - ko"	pointer
)	O
;	O
}	O
else	O
{	O
popgo	function
(	O
)	O
;	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	pointer
,	O
"last liberty"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
trymove	function
(	O
str	int
,	O
color	int
,	O
"attack1-B"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
countlib	function
(	O
str	int
)	O
>	O
1	int
)	O
{	O
popgo	function
(	O
)	O
;	O
}	O
else	O
{	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
RETURN_RESULT	O
(	O
WIN	int
,	O
xpos	int
,	O
move	pointer
,	O
"last liberty"	pointer
)	O
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
get_komaster	function
(	O
)	O
!=	O
color	int
)	O
{	O
CHECK_RESULT_UNREVERSED	O
(	O
savecode	int
,	O
savemove	int
,	O
KO_B	int
,	O
xpos	int
,	O
move	pointer
,	O
"last liberty - ko"	pointer
)	O
;	O
}	O
}	O
liberties	pointer
=	O
approxlib	function
(	O
xpos	int
,	O
color	int
,	O
6	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
liberties	pointer
<=	O
5	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
apos	int
,	O
other	int
)	O
&&	O
trymove	function
(	O
apos	int
,	O
other	int
,	O
"attack1-C"	pointer
,	O
str	int
)	O
)	O
{	O
int	O
dcode	int
=	O
do_find_defense	function
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
&&	O
do_attack	int
(	O
str	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
RETURN_RESULT	O
(	O
WIN	int
,	O
apos	int
,	O
move	pointer
,	O
"backfilling"	pointer
)	O
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
apos	int
)	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
if	O
(	O
liberty_of_string	function
(	O
xpos	int
,	O
adjs	array
[	O
r	int
]	O
)	O
)	O
{	O
int	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
;	O
adj2	int
=	O
chainlinks2	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjs2	array
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj2	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
if	O
(	O
adjs2	array
[	O
k	int
]	O
==	O
str	int
)	O
continue	O
;	O
findlib	function
(	O
adjs2	array
[	O
k	int
]	O
,	O
1	int
,	O
&	O
apos	int
)	O
;	O
if	O
(	O
komaster_trymove	function
(	O
apos	int
,	O
other	int
,	O
"attack1-D"	pointer
,	O
str	int
,	O
&	O
ko_move	int
,	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
int	O
dcode	int
=	O
do_find_defense	function
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
&&	O
do_attack	int
(	O
str	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
CHECK_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
apos	int
,	O
move	pointer
,	O
"attack effective"	pointer
)	O
;	O
}	O
else	O
popgo	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_find_defense	function
(	O
str	int
,	O
NULL	O
)	O
!=	O
WIN	int
&&	O
do_attack	int
(	O
str	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
savemove	int
=	O
apos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
savecode	int
==	O
0	int
)	O
{	O
RETURN_RESULT	O
(	O
0	int
,	O
0	int
,	O
move	pointer
,	O
NULL	O
)	O
;	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
int	O
attack2	pointer
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
hpos	int
;	O
int	O
xpos	int
=	O
NO_MOVE	O
;	O
int	O
liberties	pointer
,	O
r	int
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
libs2	array
[	O
2	int
]	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
atari_possible	int
=	O
0	int
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
adjacent_liberties	int
=	O
0	int
;	O
int	O
pass	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"attack2"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array
.	O
num	int
=	O
0	int
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
4	int
;	O
pass	int
++	O
)	O
{	O
switch	O
(	O
pass	int
)	O
{	O
case	O
0	int
:	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
if	O
(	O
stackp	int
>	O
depth	int
&&	O
countstones	function
(	O
adjs	array
[	O
r	int
]	O
)	O
>	O
1	int
&&	O
!	O
have_common_lib	function
(	O
str	int
,	O
adjs	array
[	O
r	int
]	O
,	O
NULL	O
)	O
)	O
{	O
RETURN_RESULT	O
(	O
0	int
,	O
0	int
,	O
move	pointer
,	O
"boundary in atari"	pointer
)	O
;	O
}	O
if	O
(	O
stackp	int
<=	O
depth	int
)	O
break_chain_moves	function
(	O
adjs	array
[	O
r	int
]	O
,	O
&	O
moves	array
)	O
;	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
&	O
hpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
hpos	int
,	O
0	int
,	O
moves	array
,	O
"save_boundary"	pointer
)	O
;	O
}	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
ASSERT1	O
(	O
liberties	pointer
==	O
2	int
,	O
str	int
)	O
;	O
if	O
(	O
DIRECT_NEIGHBORS	O
(	O
libs	pointer
[	O
0	int
]	O
,	O
libs	pointer
[	O
1	int
]	O
)	O
)	O
adjacent_liberties	int
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
apos	int
,	O
other	int
)	O
)	O
atari_possible	int
=	O
1	int
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
||	O
(	O
(	O
stackp	int
<=	O
depth	int
||	O
adjacent_liberties	int
)	O
&&	O
!	O
has_neighbor	function
(	O
apos	int
,	O
other	int
)	O
)	O
||	O
!	O
is_self_atari	function
(	O
apos	int
,	O
other	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
moves	array
,	O
"liberty"	pointer
)	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
&&	O
approxlib	function
(	O
apos	int
,	O
other	int
,	O
2	int
,	O
libs2	array
)	O
==	O
1	int
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array
[	O
0	int
]	O
,	O
0	int
,	O
moves	array
,	O
"backfill"	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
bpos	int
=	O
libs2	array
[	O
0	int
]	O
+	O
delta	array
[	O
r	int
]	O
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
other	int
&&	O
chainlinks2	function
(	O
bpos	int
,	O
adjs	array
,	O
1	int
)	O
>	O
0	int
)	O
{	O
findlib	function
(	O
adjs	array
[	O
0	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
moves	array
,	O
"back-capture"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
atari_possible	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
edge_block_moves	function
(	O
str	int
,	O
libs	pointer
[	O
k	int
]	O
,	O
&	O
moves	array
)	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
int	O
apos	int
=	O
adjs	array
[	O
r	int
]	O
;	O
if	O
(	O
liberty_of_string	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
apos	int
)	O
&&	O
liberty_of_string	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
apos	int
)	O
)	O
break_chain_moves	function
(	O
apos	int
,	O
&	O
moves	array
)	O
;	O
}	O
propose_edge_moves	function
(	O
str	int
,	O
libs	pointer
,	O
liberties	pointer
,	O
&	O
moves	array
,	O
other	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
{	O
special_attack2_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
special_attack3_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
special_attack4_moves	function
(	O
str	int
,	O
libs	pointer
,	O
&	O
moves	array
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
find_cap_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
&&	O
stackp	int
<=	O
backfill_depth	int
&&	O
(	O
stackp	int
<=	O
superstring_depth	int
||	O
!	O
atari_possible	int
)	O
)	O
{	O
int	O
liberty_cap	int
=	O
2	int
;	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
)	O
liberty_cap	int
=	O
3	int
;	O
superstring_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
liberty_cap	int
,	O
1	int
)	O
;	O
squeeze_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
other	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
ATTACK_TRY_MOVES	O
(	O
0	int
,	O
&	O
suggest_move	int
)	O
;	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
int	O
attack3	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
3	int
]	O
;	O
int	O
r	int
;	O
int	O
k	int
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
pass	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"attack3"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array
.	O
num	int
=	O
0	int
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
stackp	int
<=	O
depth	int
,	O
str	int
)	O
;	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
4	int
;	O
pass	int
++	O
)	O
{	O
switch	O
(	O
pass	int
)	O
{	O
case	O
0	int
:	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
int	O
hpos	int
;	O
break_chain_moves	function
(	O
adjs	array
[	O
r	int
]	O
,	O
&	O
moves	array
)	O
;	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
&	O
hpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
hpos	int
,	O
0	int
,	O
moves	array
,	O
"save_boundary"	pointer
)	O
;	O
}	O
double_atari_chain2_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
stackp	int
<=	O
superstring_depth	int
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
3	int
,	O
libs	pointer
)	O
;	O
ASSERT1	O
(	O
liberties	pointer
==	O
3	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
||	O
(	O
stackp	int
<=	O
depth	int
&&	O
!	O
has_neighbor	function
(	O
apos	int
,	O
other	int
)	O
)	O
||	O
!	O
is_self_atari	function
(	O
apos	int
,	O
other	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
moves	array
,	O
"liberty"	pointer
)	O
;	O
edge_closing_backfill_moves	function
(	O
str	int
,	O
apos	int
,	O
&	O
moves	array
)	O
;	O
edge_block_moves	function
(	O
str	int
,	O
apos	int
,	O
&	O
moves	array
)	O
;	O
}	O
propose_edge_moves	function
(	O
str	int
,	O
libs	pointer
,	O
liberties	pointer
,	O
&	O
moves	array
,	O
other	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
find_cap_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
if	O
(	O
stackp	int
<=	O
fourlib_depth	int
)	O
draw_back_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
)	O
{	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
int	O
libs2	array
[	O
2	int
]	O
;	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
2	int
,	O
libs2	array
)	O
;	O
if	O
(	O
approxlib	function
(	O
libs2	array
[	O
0	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
>	O
3	int
&&	O
approxlib	function
(	O
libs2	array
[	O
1	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
>	O
3	int
)	O
continue	O
;	O
break_chain_moves	function
(	O
adjs	array
[	O
r	int
]	O
,	O
&	O
moves	array
)	O
;	O
break_chain2_moves	function
(	O
adjs	array
[	O
r	int
]	O
,	O
&	O
moves	array
,	O
1	int
,	O
0	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array
[	O
k	int
]	O
,	O
0	int
,	O
moves	array
,	O
"save_boundary-2"	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
&&	O
stackp	int
<=	O
backfill2_depth	int
)	O
{	O
superstring_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
3	int
,	O
1	int
)	O
;	O
squeeze_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
other	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
ATTACK_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
int	O
attack4	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
r	int
;	O
int	O
k	int
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
pass	int
;	O
int	O
suggest_move	int
=	O
NO_MOVE	O
;	O
SETUP_TRACE_INFO	O
(	O
"attack4"	pointer
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array
.	O
num	int
=	O
0	int
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
if	O
(	O
stackp	int
>	O
depth	int
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
"stackp > depth"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
pass	int
=	O
0	int
;	O
pass	int
<	O
2	int
;	O
pass	int
++	O
)	O
{	O
switch	O
(	O
pass	int
)	O
{	O
case	O
0	int
:	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
int	O
hpos	int
;	O
break_chain_moves	function
(	O
adjs	array
[	O
r	int
]	O
,	O
&	O
moves	array
)	O
;	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
&	O
hpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
hpos	int
,	O
0	int
,	O
moves	array
,	O
"save_boundary"	pointer
)	O
;	O
}	O
double_atari_chain2_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
stackp	int
<=	O
superstring_depth	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
moves	array
.	O
num	int
;	O
k	int
++	O
)	O
moves	array
.	O
score	float
[	O
k	int
]	O
+=	O
5	int
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
4	int
,	O
libs	pointer
)	O
;	O
ASSERT1	O
(	O
liberties	pointer
==	O
4	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
||	O
(	O
stackp	int
<=	O
depth	int
&&	O
!	O
has_neighbor	function
(	O
apos	int
,	O
other	int
)	O
)	O
||	O
!	O
is_self_atari	function
(	O
apos	int
,	O
other	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
moves	array
,	O
"liberty"	pointer
)	O
;	O
edge_closing_backfill_moves	function
(	O
str	int
,	O
apos	int
,	O
&	O
moves	array
)	O
;	O
edge_block_moves	function
(	O
str	int
,	O
apos	int
,	O
&	O
moves	array
)	O
;	O
}	O
propose_edge_moves	function
(	O
str	int
,	O
libs	pointer
,	O
liberties	pointer
,	O
&	O
moves	array
,	O
other	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
find_cap_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
other	int
,	O
read_function_name	pointer
,	O
*	O
move	pointer
)	O
;	O
ATTACK_TRY_MOVES	O
(	O
1	int
,	O
&	O
suggest_move	int
)	O
;	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
void	O
find_cap_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
alib	int
,	O
blib	int
;	O
int	O
numlibs	int
;	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
int	O
i	int
,	O
j	int
;	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	int
,	O
bj	int
;	O
numlibs	int
=	O
findlib	function
(	O
str	int
,	O
4	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
numlibs	int
>	O
4	int
||	O
numlibs	int
<	O
2	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numlibs	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
numlibs	int
;	O
j	int
++	O
)	O
{	O
alib	int
=	O
libs	pointer
[	O
i	int
]	O
;	O
blib	int
=	O
libs	pointer
[	O
j	int
]	O
;	O
if	O
(	O
!	O
DIAGONAL_NEIGHBORS	O
(	O
alib	int
,	O
blib	int
)	O
)	O
continue	O
;	O
ai	int
=	O
I	O
(	O
alib	int
)	O
;	O
aj	int
=	O
J	O
(	O
alib	int
)	O
;	O
bi	int
=	O
I	O
(	O
blib	int
)	O
;	O
bj	int
=	O
J	O
(	O
blib	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
bi	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
POS	O
(	O
bi	int
,	O
aj	int
)	O
,	O
10	int
,	O
*	O
moves	array
,	O
"find_cap"	pointer
)	O
;	O
else	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
bj	int
)	O
==	O
EMPTY	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
POS	O
(	O
ai	int
,	O
bj	int
)	O
,	O
10	int
,	O
*	O
moves	array
,	O
"find_cap"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
special_attack2_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
newlibs	array
[	O
3	int
]	O
;	O
int	O
xpos	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
is_suicide	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
)	O
&&	O
(	O
approxlib	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
color	int
,	O
3	int
,	O
newlibs	array
)	O
==	O
2	int
)	O
)	O
{	O
if	O
(	O
newlibs	array
[	O
0	int
]	O
!=	O
libs	pointer
[	O
1	int
-	O
k	int
]	O
)	O
xpos	int
=	O
newlibs	array
[	O
0	int
]	O
;	O
else	O
xpos	int
=	O
newlibs	array
[	O
1	int
]	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
xpos	int
,	O
other	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_attack2"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
special_attack3_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
k	int
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
bpos	int
=	O
libs	pointer
[	O
1	int
-	O
k	int
]	O
;	O
if	O
(	O
apos	int
==	O
SOUTH	O
(	O
bpos	int
)	O
||	O
apos	int
==	O
NORTH	O
(	O
bpos	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
apos	int
)	O
]	O
==	O
EMPTY	int
)	O
xpos	int
=	O
WEST	O
(	O
apos	int
)	O
;	O
else	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
apos	int
)	O
]	O
==	O
EMPTY	int
)	O
xpos	int
=	O
EAST	O
(	O
apos	int
)	O
;	O
else	O
continue	O
;	O
}	O
else	O
if	O
(	O
apos	int
==	O
WEST	O
(	O
bpos	int
)	O
||	O
apos	int
==	O
EAST	O
(	O
bpos	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
apos	int
)	O
]	O
==	O
EMPTY	int
)	O
xpos	int
=	O
SOUTH	O
(	O
apos	int
)	O
;	O
else	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
apos	int
)	O
]	O
==	O
EMPTY	int
)	O
xpos	int
=	O
NORTH	O
(	O
apos	int
)	O
;	O
else	O
continue	O
;	O
}	O
else	O
return	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
xpos	int
,	O
other	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_attack3"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
special_attack4_moves	function
(	O
int	O
str	int
,	O
int	O
libs	pointer
[	O
2	int
]	O
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj2	int
,	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs2	array
[	O
3	int
]	O
;	O
int	O
apos	int
;	O
int	O
bpos	int
=	O
0	int
;	O
int	O
cpos	int
;	O
int	O
dpos	int
;	O
int	O
epos	int
;	O
int	O
clibs	int
;	O
int	O
dlibs	int
;	O
int	O
elibs	int
;	O
int	O
bc_common_lib	int
;	O
int	O
k	int
,	O
s	int
,	O
t	int
,	O
u	int
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
)	O
||	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
other	int
)	O
)	O
return	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
apos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj	array
;	O
s	int
++	O
)	O
if	O
(	O
liberty_of_string	function
(	O
apos	int
,	O
adjs	array
[	O
s	int
]	O
)	O
)	O
{	O
bpos	int
=	O
adjs	array
[	O
s	int
]	O
;	O
break	O
;	O
}	O
if	O
(	O
s	int
==	O
adj	array
)	O
continue	O
;	O
adj2	int
=	O
chainlinks3	function
(	O
bpos	int
,	O
adjs2	array
,	O
3	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
{	O
cpos	int
=	O
adjs2	array
[	O
s	int
]	O
;	O
if	O
(	O
same_string	function
(	O
cpos	int
,	O
str	int
)	O
)	O
continue	O
;	O
clibs	int
=	O
findlib	function
(	O
cpos	int
,	O
3	int
,	O
libs2	array
)	O
;	O
if	O
(	O
clibs	int
<	O
2	int
)	O
continue	O
;	O
bc_common_lib	int
=	O
have_common_lib	function
(	O
bpos	int
,	O
cpos	int
,	O
NULL	O
)	O
;	O
if	O
(	O
clibs	int
>	O
2	int
&&	O
!	O
bc_common_lib	int
)	O
continue	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
clibs	int
;	O
t	int
++	O
)	O
{	O
dpos	int
=	O
libs2	array
[	O
t	int
]	O
;	O
if	O
(	O
is_self_atari	function
(	O
dpos	int
,	O
other	int
)	O
)	O
continue	O
;	O
for	O
(	O
u	int
=	O
0	int
;	O
u	int
<	O
clibs	int
;	O
u	int
++	O
)	O
{	O
if	O
(	O
t	int
==	O
u	int
)	O
continue	O
;	O
epos	int
=	O
libs2	array
[	O
u	int
]	O
;	O
elibs	int
=	O
approxlib	function
(	O
epos	int
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
elibs	int
>	O
3	int
)	O
break	O
;	O
dlibs	int
=	O
approxlib	function
(	O
dpos	int
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
;	O
if	O
(	O
elibs	int
>	O
dlibs	int
&&	O
!	O
bc_common_lib	int
)	O
break	O
;	O
}	O
if	O
(	O
u	int
>=	O
clibs	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
dpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"special_attack4"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
draw_back_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
r	int
,	O
k	int
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
2	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
liberty_of_string	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
str	int
)	O
&&	O
(	O
(	O
ON_BOARD1	O
(	O
SOUTH	O
(	O
libs	pointer
[	O
k	int
]	O
)	O
)	O
&&	O
liberty_of_string	function
(	O
SOUTH	O
(	O
libs	pointer
[	O
k	int
]	O
)	O
,	O
str	int
)	O
)	O
||	O
(	O
ON_BOARD1	O
(	O
WEST	O
(	O
libs	pointer
[	O
k	int
]	O
)	O
)	O
&&	O
liberty_of_string	function
(	O
WEST	O
(	O
libs	pointer
[	O
k	int
]	O
)	O
,	O
str	int
)	O
)	O
||	O
(	O
ON_BOARD1	O
(	O
NORTH	O
(	O
libs	pointer
[	O
k	int
]	O
)	O
)	O
&&	O
liberty_of_string	function
(	O
NORTH	O
(	O
libs	pointer
[	O
k	int
]	O
)	O
,	O
str	int
)	O
)	O
||	O
(	O
ON_BOARD1	O
(	O
EAST	O
(	O
libs	pointer
[	O
k	int
]	O
)	O
)	O
&&	O
liberty_of_string	function
(	O
EAST	O
(	O
libs	pointer
[	O
k	int
]	O
)	O
,	O
str	int
)	O
)	O
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
k	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"draw_back"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
edge_closing_backfill_moves	function
(	O
int	O
str	int
,	O
int	O
apos	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
int	O
bpos	int
;	O
int	O
cpos	int
;	O
int	O
number_x	int
,	O
number_o	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
up	int
=	O
delta	array
[	O
k	int
]	O
;	O
int	O
right	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
-	O
up	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
up	int
]	O
!=	O
color	int
)	O
return	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
right	int
]	O
==	O
EMPTY	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
apos	int
-	O
right	int
)	O
||	O
board	pointer
[	O
apos	int
-	O
right	int
]	O
==	O
color	int
)	O
)	O
;	O
else	O
if	O
(	O
board	pointer
[	O
apos	int
-	O
right	int
]	O
==	O
EMPTY	int
&&	O
(	O
!	O
ON_BOARD	O
(	O
apos	int
+	O
right	int
)	O
||	O
board	pointer
[	O
apos	int
+	O
right	int
]	O
==	O
color	int
)	O
)	O
{	O
right	int
=	O
-	O
right	int
;	O
}	O
else	O
return	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
up	int
+	O
right	int
]	O
!=	O
other	int
)	O
return	O
;	O
bpos	int
=	O
apos	int
+	O
up	int
+	O
2	int
*	O
right	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
bpos	int
)	O
)	O
return	O
;	O
cpos	int
=	O
apos	int
+	O
2	int
*	O
right	int
;	O
number_x	int
=	O
0	int
;	O
number_o	int
=	O
0	int
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
color	int
)	O
number_x	int
++	O
;	O
else	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
other	int
)	O
number_o	int
++	O
;	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
==	O
color	int
)	O
number_x	int
++	O
;	O
else	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
==	O
other	int
)	O
number_o	int
++	O
;	O
if	O
(	O
number_o	int
>	O
number_x	int
)	O
return	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
+	O
right	int
,	O
0	int
,	O
*	O
moves	array
,	O
"edge_closing_backfill"	pointer
)	O
;	O
return	O
;	O
}	O
}	O
static	O
void	O
edge_block_moves	function
(	O
int	O
str	int
,	O
int	O
apos	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
l	int
;	O
int	O
up	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
apos	int
-	O
up	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
+	O
up	int
]	O
!=	O
color	int
||	O
!	O
same_string	function
(	O
apos	int
+	O
up	int
,	O
str	int
)	O
)	O
return	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
right	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
int	O
cpos	int
;	O
int	O
dpos	int
;	O
int	O
epos	int
;	O
int	O
fpos	int
;	O
if	O
(	O
l	int
==	O
1	int
)	O
right	int
=	O
-	O
right	int
;	O
cpos	int
=	O
apos	int
+	O
right	int
;	O
dpos	int
=	O
apos	int
+	O
right	int
+	O
up	int
;	O
epos	int
=	O
cpos	int
+	O
right	int
;	O
fpos	int
=	O
dpos	int
+	O
right	int
;	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
dpos	int
]	O
==	O
other	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
fpos	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
countlib	function
(	O
dpos	int
)	O
==	O
1	int
)	O
{	O
int	O
gpos	int
=	O
epos	int
+	O
right	int
;	O
if	O
(	O
board	pointer
[	O
gpos	int
]	O
!=	O
color	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
fpos	int
,	O
30	int
,	O
*	O
moves	array
,	O
"edge_block-A"	pointer
)	O
;	O
}	O
else	O
{	O
int	O
edge_scan	int
;	O
for	O
(	O
edge_scan	int
=	O
epos	int
;	O
;	O
edge_scan	int
+=	O
right	int
)	O
{	O
if	O
(	O
board	pointer
[	O
edge_scan	int
]	O
==	O
color	int
||	O
board	pointer
[	O
edge_scan	int
+	O
up	int
]	O
==	O
color	int
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
epos	int
,	O
10	int
,	O
*	O
moves	array
,	O
"edge_block-B"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
board	pointer
[	O
edge_scan	int
]	O
!=	O
EMPTY	int
||	O
board	pointer
[	O
edge_scan	int
+	O
up	int
]	O
!=	O
EMPTY	int
)	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
break_chain_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
r	int
;	O
int	O
xpos	int
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
1	int
,	O
*	O
moves	array
,	O
"break_chain"	pointer
)	O
;	O
}	O
}	O
static	O
int	O
defend_secondary_chain1_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
min_liberties	int
)	O
{	O
int	O
r	int
,	O
s	int
;	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
;	O
int	O
xpos	int
;	O
int	O
adj	array
;	O
int	O
adj2	int
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
approxlib	function
(	O
xpos	int
,	O
color	int
,	O
min_liberties	int
,	O
NULL	O
)	O
+	O
neighbor_of_string	function
(	O
xpos	int
,	O
str	int
)	O
>=	O
min_liberties	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"defend_secondary_chain1-A"	pointer
)	O
;	O
adj2	int
=	O
chainlinks2	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjs2	array
,	O
1	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
{	O
findlib	function
(	O
adjs2	array
[	O
s	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
xpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"defend_secondary_chain1-B"	pointer
)	O
;	O
}	O
}	O
return	O
adj	array
;	O
}	O
static	O
void	O
defend_secondary_chain2_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
min_liberties	int
)	O
{	O
int	O
r	int
,	O
s	int
,	O
t	int
;	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
;	O
int	O
xpos	int
;	O
int	O
adj	array
;	O
int	O
adj2	int
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
if	O
(	O
!	O
have_common_lib	function
(	O
str	int
,	O
adjs	array
[	O
r	int
]	O
,	O
NULL	O
)	O
)	O
continue	O
;	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
2	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
2	int
;	O
t	int
++	O
)	O
{	O
xpos	int
=	O
libs	pointer
[	O
t	int
]	O
;	O
if	O
(	O
approxlib	function
(	O
xpos	int
,	O
color	int
,	O
min_liberties	int
,	O
NULL	O
)	O
+	O
neighbor_of_string	function
(	O
xpos	int
,	O
str	int
)	O
>=	O
min_liberties	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"defend_secondary_chain2-A"	pointer
)	O
;	O
}	O
adj2	int
=	O
chainlinks2	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjs2	array
,	O
1	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
{	O
findlib	function
(	O
adjs2	array
[	O
s	int
]	O
,	O
1	int
,	O
&	O
xpos	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
xpos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"defend_secondary_chain2-B"	pointer
)	O
;	O
}	O
adj2	int
=	O
chainlinks2	function
(	O
adjs	array
[	O
r	int
]	O
,	O
adjs2	array
,	O
2	int
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
adj2	int
;	O
s	int
++	O
)	O
{	O
findlib	function
(	O
adjs2	array
[	O
s	int
]	O
,	O
2	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
2	int
;	O
t	int
++	O
)	O
{	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
1	int
-	O
t	int
]	O
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
3	int
,	O
NULL	O
)	O
<	O
3	int
&&	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
t	int
]	O
,	O
color	int
)	O
)	O
{	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
t	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"defend_secondary_chain2-C"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
break_chain2_efficient_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
r	int
;	O
int	O
adj	array
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
do_find_break_chain2_efficient_moves	function
(	O
str	int
,	O
adjs	array
[	O
r	int
]	O
,	O
moves	array
)	O
;	O
}	O
static	O
void	O
do_find_break_chain2_efficient_moves	function
(	O
int	O
str	int
,	O
int	O
adj	array
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
int	O
adj2	int
,	O
adjs2	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
pos1	int
;	O
int	O
pos2	int
;	O
ASSERT1	O
(	O
countlib	function
(	O
adj	array
)	O
==	O
2	int
,	O
adj	array
)	O
;	O
adj2	int
=	O
chainlinks2	function
(	O
adj	array
,	O
adjs2	array
,	O
1	int
)	O
;	O
if	O
(	O
adj2	int
==	O
1	int
&&	O
countlib	function
(	O
str	int
)	O
>	O
2	int
)	O
{	O
int	O
apos	int
;	O
break_chain_moves	function
(	O
adjs2	array
[	O
0	int
]	O
,	O
moves	array
)	O
;	O
findlib	function
(	O
adjs2	array
[	O
0	int
]	O
,	O
1	int
,	O
&	O
apos	int
)	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
apos	int
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"break_chain2_efficient-A"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
adj2	int
>	O
1	int
)	O
return	O
;	O
findlib	function
(	O
adj	array
,	O
2	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
&&	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
1	int
-	O
k	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
1	int
-	O
k	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"break_chain2_efficient-B"	pointer
)	O
;	O
if	O
(	O
!	O
DIAGONAL_NEIGHBORS	O
(	O
libs	pointer
[	O
0	int
]	O
,	O
libs	pointer
[	O
1	int
]	O
)	O
)	O
return	O
;	O
pos1	int
=	O
NORTH	O
(	O
gg_max	O
(	O
libs	pointer
[	O
0	int
]	O
,	O
libs	pointer
[	O
1	int
]	O
)	O
)	O
;	O
pos2	int
=	O
SOUTH	O
(	O
gg_min	O
(	O
libs	pointer
[	O
0	int
]	O
,	O
libs	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
(	O
board	pointer
[	O
pos1	int
]	O
!=	O
other	int
||	O
!	O
is_edge_vertex	function
(	O
pos2	int
)	O
||	O
!	O
same_string	function
(	O
pos1	int
,	O
adj	array
)	O
)	O
&&	O
(	O
board	pointer
[	O
pos2	int
]	O
!=	O
other	int
||	O
!	O
is_edge_vertex	function
(	O
pos1	int
)	O
||	O
!	O
same_string	function
(	O
pos2	int
,	O
adj	array
)	O
)	O
)	O
return	O
;	O
if	O
(	O
is_edge_vertex	function
(	O
libs	pointer
[	O
0	int
]	O
)	O
&&	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
1	int
]	O
,	O
1	int
,	O
*	O
moves	array
,	O
"break_chain2_efficient-C"	pointer
)	O
;	O
if	O
(	O
is_edge_vertex	function
(	O
libs	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
0	int
]	O
,	O
1	int
,	O
*	O
moves	array
,	O
"break_chain2_efficient-C"	pointer
)	O
;	O
}	O
static	O
void	O
break_chain2_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
require_safe	int
,	O
int	O
be_aggressive	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
r	int
;	O
int	O
adj	array
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
int	O
k	int
;	O
int	O
apos	int
=	O
adjs	array
[	O
r	int
]	O
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
unsafe	array
[	O
2	int
]	O
;	O
int	O
dummy_adjs	array
[	O
MAXCHAIN	int
]	O
;	O
findlib	function
(	O
apos	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
backfill_depth	int
&&	O
chainlinks2	function
(	O
apos	int
,	O
dummy_adjs	array
,	O
1	int
)	O
>	O
0	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
unsafe	array
[	O
k	int
]	O
=	O
is_self_atari	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
color	int
)	O
;	O
if	O
(	O
!	O
unsafe	array
[	O
k	int
]	O
||	O
is_ko	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
color	int
,	O
NULL	O
)	O
||	O
(	O
!	O
require_safe	int
&&	O
approxlib	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
<	O
5	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
k	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"break_chain2-A"	pointer
)	O
;	O
}	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
)	O
{	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
<	O
4	int
&&	O
approxlib	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
<	O
4	int
)	O
{	O
if	O
(	O
!	O
defend_secondary_chain1_moves	function
(	O
adjs	array
[	O
r	int
]	O
,	O
moves	array
,	O
2	int
)	O
)	O
defend_secondary_chain2_moves	function
(	O
adjs	array
[	O
r	int
]	O
,	O
moves	array
,	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
unsafe	array
[	O
0	int
]	O
&&	O
unsafe	array
[	O
1	int
]	O
&&	O
(	O
stackp	int
<=	O
backfill2_depth	int
||	O
have_common_lib	function
(	O
str	int
,	O
apos	int
,	O
NULL	O
)	O
)	O
)	O
{	O
int	O
lib	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
int	O
libs2	array
[	O
3	int
]	O
;	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
,	O
3	int
,	O
libs2	array
)	O
==	O
2	int
)	O
{	O
if	O
(	O
!	O
is_self_atari	function
(	O
libs2	array
[	O
0	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array
[	O
0	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"break_chain2-B"	pointer
)	O
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
libs2	array
[	O
1	int
]	O
,	O
color	int
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs2	array
[	O
1	int
]	O
,	O
0	int
,	O
*	O
moves	array
,	O
"break_chain2-B"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
&&	O
approxlib	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
other	int
,	O
3	int
,	O
NULL	O
)	O
<=	O
2	int
)	O
{	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
color	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
&&	O
approxlib	function
(	O
lib	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
lib	int
,	O
0	int
,	O
*	O
moves	array
,	O
"break_chain2-C"	pointer
)	O
;	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
color	int
,	O
1	int
,	O
&	O
lib	int
)	O
==	O
1	int
&&	O
approxlib	function
(	O
lib	int
,	O
color	int
,	O
3	int
,	O
NULL	O
)	O
>=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
lib	int
,	O
0	int
,	O
*	O
moves	array
,	O
"break_chain2-C"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
break_chain2_defense_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
be_aggressive	int
)	O
{	O
int	O
saved_num_moves	int
=	O
moves	array
->	O
num	int
;	O
int	O
k	int
;	O
break_chain2_moves	function
(	O
str	int
,	O
moves	array
,	O
!	O
(	O
stackp	int
<=	O
backfill_depth	int
)	O
,	O
be_aggressive	int
)	O
;	O
for	O
(	O
k	int
=	O
saved_num_moves	int
;	O
k	int
<	O
moves	array
->	O
num	int
;	O
k	int
++	O
)	O
moves	array
->	O
score	float
[	O
k	int
]	O
=	O
-	O
2	int
;	O
}	O
static	O
void	O
do_find_break_chain3_moves	function
(	O
int	O
*	O
chain_links	pointer
,	O
int	O
num_chain_links	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
be_aggressive	int
,	O
const	O
char	O
*	O
caller_function_name	pointer
)	O
{	O
int	O
other	int
=	O
board	pointer
[	O
chain_links	pointer
[	O
0	int
]	O
]	O
;	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
other	int
)	O
;	O
signed	O
char	O
move_added	array
[	O
BOARDMAX	O
]	O
;	O
int	O
possible_moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
num_possible_moves	int
=	O
0	int
;	O
int	O
r	int
;	O
int	O
k	int
;	O
gg_assert	O
(	O
num_chain_links	int
>	O
0	int
)	O
;	O
memset	function
(	O
move_added	array
,	O
0	int
,	O
sizeof	O
move_added	array
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_chain_links	int
;	O
r	int
++	O
)	O
{	O
int	O
lib1	int
;	O
int	O
lib2	int
;	O
int	O
lib3	int
;	O
int	O
libs	pointer
[	O
3	int
]	O
;	O
findlib	function
(	O
chain_links	pointer
[	O
r	int
]	O
,	O
3	int
,	O
libs	pointer
)	O
;	O
lib1	int
=	O
approxlib	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
;	O
lib2	int
=	O
approxlib	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
lib1	int
>=	O
4	int
&&	O
lib2	int
>=	O
4	int
)	O
continue	O
;	O
lib3	int
=	O
approxlib	function
(	O
libs	pointer
[	O
2	int
]	O
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
lib1	int
>=	O
4	int
||	O
lib2	int
>=	O
4	int
)	O
&&	O
lib3	int
>=	O
4	int
)	O
continue	O
;	O
if	O
(	O
lib1	int
>=	O
4	int
)	O
{	O
if	O
(	O
!	O
move_added	array
[	O
libs	pointer
[	O
0	int
]	O
]	O
)	O
{	O
possible_moves	array
[	O
num_possible_moves	int
++	O
]	O
=	O
libs	pointer
[	O
0	int
]	O
;	O
move_added	array
[	O
libs	pointer
[	O
0	int
]	O
]	O
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
lib2	int
>=	O
4	int
)	O
{	O
if	O
(	O
!	O
move_added	array
[	O
libs	pointer
[	O
1	int
]	O
]	O
)	O
{	O
possible_moves	array
[	O
num_possible_moves	int
++	O
]	O
=	O
libs	pointer
[	O
1	int
]	O
;	O
move_added	array
[	O
libs	pointer
[	O
1	int
]	O
]	O
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
lib3	int
>=	O
4	int
)	O
{	O
if	O
(	O
!	O
move_added	array
[	O
libs	pointer
[	O
2	int
]	O
]	O
)	O
{	O
possible_moves	array
[	O
num_possible_moves	int
++	O
]	O
=	O
libs	pointer
[	O
2	int
]	O
;	O
move_added	array
[	O
libs	pointer
[	O
2	int
]	O
]	O
=	O
1	int
;	O
}	O
continue	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
move_added	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
)	O
{	O
possible_moves	array
[	O
num_possible_moves	int
++	O
]	O
=	O
libs	pointer
[	O
k	int
]	O
;	O
move_added	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
)	O
defend_secondary_chain1_moves	function
(	O
chain_links	pointer
[	O
r	int
]	O
,	O
moves	array
,	O
3	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_possible_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
possible_moves	array
[	O
k	int
]	O
;	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
||	O
approxlib	function
(	O
move	pointer
,	O
color	int
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
move	pointer
,	O
-	O
2	int
,	O
*	O
moves	array
,	O
caller_function_name	pointer
)	O
;	O
}	O
}	O
static	O
void	O
break_chain3_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
be_aggressive	int
)	O
{	O
int	O
chain_links	pointer
[	O
MAXCHAIN	int
]	O
;	O
int	O
num_chain_links	int
=	O
chainlinks2	function
(	O
str	int
,	O
chain_links	pointer
,	O
3	int
)	O
;	O
if	O
(	O
num_chain_links	int
>	O
0	int
)	O
{	O
do_find_break_chain3_moves	function
(	O
chain_links	pointer
,	O
num_chain_links	int
,	O
moves	array
,	O
be_aggressive	int
,	O
"break_chain3"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
break_chain4_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
be_aggressive	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
r	int
;	O
int	O
k	int
;	O
int	O
u	int
=	O
0	int
,	O
v	int
;	O
int	O
apos	int
;	O
int	O
adj	array
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
int	O
possible_moves	array
[	O
MAX_MOVES	int
]	O
;	O
int	O
mw	array
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
mw	array
,	O
0	int
,	O
sizeof	O
(	O
mw	array
)	O
)	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
4	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
int	O
lib1	int
=	O
0	int
,	O
lib2	int
=	O
0	int
,	O
lib3	int
=	O
0	int
,	O
lib4	int
=	O
0	int
;	O
apos	int
=	O
adjs	array
[	O
r	int
]	O
;	O
findlib	function
(	O
apos	int
,	O
4	int
,	O
libs	pointer
)	O
;	O
lib1	int
=	O
approxlib	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
;	O
lib2	int
=	O
approxlib	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
;	O
if	O
(	O
lib1	int
>=	O
5	int
&&	O
lib2	int
>=	O
5	int
)	O
continue	O
;	O
lib3	int
=	O
approxlib	function
(	O
libs	pointer
[	O
2	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
lib1	int
>=	O
5	int
||	O
lib2	int
>=	O
5	int
)	O
&&	O
lib3	int
>=	O
5	int
)	O
continue	O
;	O
lib4	int
=	O
approxlib	function
(	O
libs	pointer
[	O
3	int
]	O
,	O
other	int
,	O
5	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
lib1	int
>=	O
5	int
||	O
lib2	int
>=	O
5	int
||	O
lib3	int
>=	O
5	int
)	O
&&	O
lib4	int
>=	O
5	int
)	O
continue	O
;	O
if	O
(	O
lib1	int
>=	O
5	int
&&	O
!	O
mw	array
[	O
libs	pointer
[	O
0	int
]	O
]	O
)	O
{	O
mw	array
[	O
libs	pointer
[	O
0	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array
[	O
u	int
++	O
]	O
=	O
libs	pointer
[	O
0	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
lib2	int
>=	O
5	int
&&	O
!	O
mw	array
[	O
libs	pointer
[	O
1	int
]	O
]	O
)	O
{	O
mw	array
[	O
libs	pointer
[	O
1	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array
[	O
u	int
++	O
]	O
=	O
libs	pointer
[	O
1	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
lib3	int
>=	O
5	int
&&	O
!	O
mw	array
[	O
libs	pointer
[	O
2	int
]	O
]	O
)	O
{	O
mw	array
[	O
libs	pointer
[	O
2	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array
[	O
u	int
++	O
]	O
=	O
libs	pointer
[	O
2	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
lib4	int
>=	O
5	int
&&	O
!	O
mw	array
[	O
libs	pointer
[	O
3	int
]	O
]	O
)	O
{	O
mw	array
[	O
libs	pointer
[	O
3	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array
[	O
u	int
++	O
]	O
=	O
libs	pointer
[	O
3	int
]	O
;	O
continue	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
mw	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
)	O
{	O
mw	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
=	O
1	int
;	O
possible_moves	array
[	O
u	int
++	O
]	O
=	O
libs	pointer
[	O
k	int
]	O
;	O
}	O
}	O
if	O
(	O
stackp	int
<=	O
backfill2_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
)	O
defend_secondary_chain1_moves	function
(	O
adjs	array
[	O
r	int
]	O
,	O
moves	array
,	O
4	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
u	int
;	O
v	int
++	O
)	O
{	O
int	O
xpos	int
=	O
possible_moves	array
[	O
v	int
]	O
;	O
if	O
(	O
stackp	int
<=	O
break_chain_depth	int
||	O
(	O
be_aggressive	int
&&	O
stackp	int
<=	O
backfill_depth	int
)	O
||	O
approxlib	function
(	O
xpos	int
,	O
color	int
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
xpos	int
,	O
-	O
2	int
,	O
*	O
moves	array
,	O
"break_chain4"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
superstring_break_chain_moves	function
(	O
int	O
str	int
,	O
int	O
liberty_cap	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
)	O
{	O
int	O
adj	array
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
chain_links3	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
num_chain_links3	int
=	O
0	int
;	O
int	O
k	int
;	O
int	O
apos	int
;	O
proper_superstring_chainlinks	function
(	O
str	int
,	O
&	O
adj	array
,	O
adjs	array
,	O
liberty_cap	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj	array
;	O
k	int
++	O
)	O
{	O
int	O
liberties	pointer
=	O
countlib	function
(	O
adjs	array
[	O
k	int
]	O
)	O
;	O
if	O
(	O
liberties	pointer
==	O
1	int
)	O
{	O
findlib	function
(	O
adjs	array
[	O
k	int
]	O
,	O
1	int
,	O
&	O
apos	int
)	O
;	O
ADD_CANDIDATE_MOVE	O
(	O
apos	int
,	O
0	int
,	O
*	O
moves	array
,	O
"superstring_break_chain"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
liberties	pointer
==	O
2	int
)	O
do_find_break_chain2_efficient_moves	function
(	O
str	int
,	O
adjs	array
[	O
k	int
]	O
,	O
moves	array
)	O
;	O
else	O
if	O
(	O
liberties	pointer
==	O
3	int
)	O
chain_links3	array
[	O
num_chain_links3	int
++	O
]	O
=	O
adjs	array
[	O
k	int
]	O
;	O
}	O
if	O
(	O
num_chain_links3	int
>	O
0	int
)	O
{	O
do_find_break_chain3_moves	function
(	O
chain_links3	array
,	O
num_chain_links3	int
,	O
moves	array
,	O
0	int
,	O
"superstring_break_chain-3"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
double_atari_chain2_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
generate_more_moves	int
)	O
{	O
int	O
r	int
,	O
k	int
;	O
int	O
adj	array
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
libs	pointer
[	O
3	int
]	O
;	O
int	O
mw	array
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
mw	array
,	O
0	int
,	O
sizeof	O
(	O
mw	array
)	O
)	O
;	O
adj	array
=	O
chainlinks2	function
(	O
str	int
,	O
adjs	array
,	O
2	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj	array
;	O
r	int
++	O
)	O
{	O
findlib	function
(	O
adjs	array
[	O
r	int
]	O
,	O
2	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
mw	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
++	O
;	O
if	O
(	O
mw	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
==	O
2	int
)	O
{	O
if	O
(	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
board	pointer
[	O
str	int
]	O
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
k	int
]	O
,	O
1	int
,	O
*	O
moves	array
,	O
"double_atari_chain2-A"	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
generate_more_moves	int
)	O
{	O
int	O
adj3	int
;	O
int	O
adjs3	array
[	O
MAXCHAIN	int
]	O
;	O
adj3	int
=	O
chainlinks2	function
(	O
str	int
,	O
adjs3	array
,	O
3	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
adj3	int
;	O
r	int
++	O
)	O
{	O
findlib	function
(	O
adjs3	array
[	O
r	int
]	O
,	O
3	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
3	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
mw	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
==	O
1	int
)	O
{	O
mw	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
=	O
2	int
;	O
if	O
(	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
board	pointer
[	O
str	int
]	O
)	O
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
k	int
]	O
,	O
-	O
3	int
,	O
*	O
moves	array
,	O
"double_atari_chain2-B"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
}	O
int	O
restricted_defend1	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
,	O
int	O
num_forbidden_moves	int
,	O
int	O
*	O
forbidden_moves	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
xpos	int
;	O
int	O
lib	int
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
liberties	pointer
;	O
int	O
k	int
;	O
SETUP_TRACE_INFO	O
(	O
"restricted_defend1"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array
.	O
num	int
=	O
0	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
1	int
,	O
str	int
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
ASSERT1	O
(	O
liberties	pointer
==	O
1	int
,	O
str	int
)	O
;	O
moves	array
.	O
pos	int
[	O
0	int
]	O
=	O
lib	int
;	O
moves	array
.	O
score	float
[	O
0	int
]	O
=	O
0	int
;	O
moves	array
.	O
message	pointer
[	O
0	int
]	O
=	O
"liberty"	pointer
;	O
moves	array
.	O
num	int
=	O
1	int
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
set_up_snapback_moves	function
(	O
str	int
,	O
lib	int
,	O
&	O
moves	array
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
NO_MOVE	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
moves	array
.	O
num	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_capture	int
;	O
xpos	int
=	O
moves	array
.	O
pos	int
[	O
k	int
]	O
;	O
if	O
(	O
in_list	function
(	O
xpos	int
,	O
num_forbidden_moves	int
,	O
forbidden_moves	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
is_ko	function
(	O
xpos	int
,	O
color	int
,	O
NULL	O
)	O
)	O
ko_capture	int
=	O
1	int
;	O
else	O
ko_capture	int
=	O
0	int
;	O
if	O
(	O
(	O
get_komaster	function
(	O
)	O
!=	O
other	int
||	O
!	O
ko_capture	int
)	O
&&	O
trymove	function
(	O
xpos	int
,	O
color	int
,	O
moves	array
.	O
message	pointer
[	O
k	int
]	O
,	O
str	int
)	O
)	O
{	O
int	O
libs	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
if	O
(	O
libs	pointer
>	O
2	int
)	O
{	O
popgo	function
(	O
)	O
;	O
SGFTRACE	O
(	O
xpos	int
,	O
WIN	int
,	O
"defense effective"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
return	O
WIN	int
;	O
}	O
if	O
(	O
libs	pointer
==	O
2	int
)	O
{	O
int	O
acode	int
;	O
if	O
(	O
!	O
ko_capture	int
)	O
acode	int
=	O
restricted_attack2	function
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	pointer
)	O
;	O
else	O
acode	int
=	O
restricted_attack2	function
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
SGFTRACE	O
(	O
xpos	int
,	O
WIN	int
,	O
"defense effective"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
xpos	int
;	O
return	O
WIN	int
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
xpos	int
)	O
;	O
}	O
else	O
popgo	function
(	O
)	O
;	O
}	O
else	O
{	O
int	O
ko_pos	int
;	O
if	O
(	O
stackp	int
<=	O
ko_depth	int
&&	O
savecode	int
==	O
0	int
&&	O
(	O
get_komaster	function
(	O
)	O
==	O
EMPTY	int
||	O
(	O
get_komaster	function
(	O
)	O
==	O
color	int
&&	O
get_kom_pos	function
(	O
)	O
==	O
xpos	int
)	O
)	O
&&	O
is_ko	function
(	O
xpos	int
,	O
color	int
,	O
&	O
ko_pos	int
)	O
&&	O
tryko	function
(	O
xpos	int
,	O
color	int
,	O
"restricted_defend1-B"	pointer
)	O
)	O
{	O
int	O
libs	pointer
=	O
countlib	function
(	O
str	int
)	O
;	O
if	O
(	O
libs	pointer
>	O
2	int
)	O
{	O
popgo	function
(	O
)	O
;	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
2	int
,	O
xpos	int
)	O
;	O
}	O
else	O
if	O
(	O
libs	pointer
==	O
2	int
)	O
{	O
int	O
acode	int
;	O
acode	int
=	O
restricted_attack2	function
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
xpos	int
)	O
;	O
}	O
else	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
savecode	int
!=	O
0	int
)	O
{	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
savemove	int
;	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"saved move"	pointer
)	O
;	O
return	O
savecode	int
;	O
}	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
restricted_attack2	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
,	O
int	O
num_forbidden_moves	int
,	O
int	O
*	O
forbidden_moves	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
SETUP_TRACE_INFO	O
(	O
"restricted_attack2"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
ASSERT1	O
(	O
liberties	pointer
==	O
2	int
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_pos	int
;	O
int	O
ko_capture	int
;	O
apos	int
=	O
libs	pointer
[	O
k	int
]	O
;	O
if	O
(	O
in_list	function
(	O
apos	int
,	O
num_forbidden_moves	int
,	O
forbidden_moves	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
is_ko	function
(	O
apos	int
,	O
other	int
,	O
&	O
ko_pos	int
)	O
)	O
ko_capture	int
=	O
1	int
;	O
else	O
ko_capture	int
=	O
0	int
;	O
if	O
(	O
(	O
get_komaster	function
(	O
)	O
!=	O
color	int
||	O
!	O
ko_capture	int
)	O
&&	O
trymove	function
(	O
apos	int
,	O
other	int
,	O
"restricted_attack2"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
(	O
!	O
ko_capture	int
&&	O
!	O
restricted_defend1	function
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	pointer
)	O
)	O
||	O
(	O
ko_capture	int
&&	O
!	O
restricted_defend1	function
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	pointer
)	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
SGFTRACE	O
(	O
apos	int
,	O
WIN	int
,	O
"attack effective"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
apos	int
;	O
return	O
WIN	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
savecode	int
==	O
0	int
&&	O
(	O
get_komaster	function
(	O
)	O
==	O
EMPTY	int
||	O
(	O
get_komaster	function
(	O
)	O
==	O
other	int
&&	O
get_kom_pos	function
(	O
)	O
==	O
apos	int
)	O
)	O
&&	O
tryko	function
(	O
apos	int
,	O
other	int
,	O
"restricted_attack2"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
restricted_defend1	function
(	O
str	int
,	O
NULL	O
,	O
num_forbidden_moves	int
,	O
forbidden_moves	pointer
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
savecode	int
=	O
KO_B	int
;	O
savemove	int
=	O
apos	int
;	O
}	O
else	O
popgo	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
savecode	int
!=	O
0	int
)	O
{	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
savemove	int
;	O
SGFTRACE	O
(	O
savemove	int
,	O
savecode	int
,	O
"saved move"	pointer
)	O
;	O
return	O
savecode	int
;	O
}	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
in_list	function
(	O
int	O
move	pointer
,	O
int	O
num_moves	int
,	O
int	O
*	O
moves	array
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
if	O
(	O
moves	array
[	O
k	int
]	O
==	O
move	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
defend_lib_score	array
[	O
6	int
]	O
=	O
{	O
-	O
5	int
,	O
-	O
4	int
,	O
0	int
,	O
3	int
,	O
5	int
,	O
50	int
}	O
;	O
static	O
int	O
defend_not_adjacent_lib_score	array
[	O
5	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
2	int
,	O
3	int
,	O
5	int
}	O
;	O
static	O
int	O
defend_capture_score	array
[	O
6	int
]	O
=	O
{	O
0	int
,	O
6	int
,	O
9	int
,	O
13	int
,	O
18	int
,	O
24	int
}	O
;	O
static	O
int	O
defend_atari_score	array
[	O
6	int
]	O
=	O
{	O
0	int
,	O
2	int
,	O
4	int
,	O
6	int
,	O
7	int
,	O
8	int
}	O
;	O
static	O
int	O
defend_save_score	array
[	O
6	int
]	O
=	O
{	O
0	int
,	O
3	int
,	O
6	int
,	O
8	int
,	O
10	int
,	O
12	int
}	O
;	O
static	O
int	O
defend_open_score	array
[	O
5	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
}	O
;	O
static	O
int	O
attack_own_lib_score	array
[	O
5	int
]	O
=	O
{	O
10	int
,	O
-	O
4	int
,	O
2	int
,	O
3	int
,	O
4	int
}	O
;	O
static	O
int	O
attack_string_lib_score	array
[	O
6	int
]	O
=	O
{	O
-	O
5	int
,	O
2	int
,	O
3	int
,	O
7	int
,	O
10	int
,	O
19	int
}	O
;	O
static	O
int	O
attack_capture_score	array
[	O
6	int
]	O
=	O
{	O
-	O
4	int
,	O
4	int
,	O
10	int
,	O
15	int
,	O
20	int
,	O
25	int
}	O
;	O
static	O
int	O
attack_save_score	array
[	O
6	int
]	O
=	O
{	O
0	int
,	O
10	int
,	O
13	int
,	O
18	int
,	O
21	int
,	O
24	int
}	O
;	O
static	O
int	O
attack_open_score	array
[	O
5	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
2	int
,	O
4	int
,	O
4	int
}	O
;	O
static	O
int	O
defend_not_edge_score	int
=	O
5	int
;	O
static	O
int	O
attack_not_edge_score	int
=	O
1	int
;	O
static	O
int	O
attack_ko_score	int
=	O
-	O
15	int
;	O
static	O
int	O
cannot_defend_penalty	int
=	O
-	O
20	int
;	O
static	O
int	O
safe_atari_score	int
=	O
8	int
;	O
static	O
void	O
sgf_dumpmoves	function
(	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
const	O
char	O
*	O
funcname	pointer
)	O
{	O
char	O
buf	pointer
[	O
500	int
]	O
;	O
char	O
*	O
pos	int
;	O
int	O
i	int
,	O
chars	int
;	O
sprintf	function
(	O
buf	pointer
,	O
"Move order for %s: %n"	pointer
,	O
funcname	pointer
,	O
&	O
chars	int
)	O
;	O
pos	int
=	O
buf	pointer
+	O
chars	int
;	O
for	O
(	O
i	int
=	O
moves	array
->	O
num_tried	int
;	O
i	int
<	O
moves	array
->	O
num	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
pos	int
,	O
"%c%d (%d) %n"	pointer
,	O
J	O
(	O
moves	array
->	O
pos	int
[	O
i	int
]	O
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
moves	array
->	O
pos	int
[	O
i	int
]	O
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
moves	array
->	O
pos	int
[	O
i	int
]	O
)	O
,	O
moves	array
->	O
score	float
[	O
i	int
]	O
,	O
&	O
chars	int
)	O
;	O
pos	int
+=	O
chars	int
;	O
}	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
order_moves	function
(	O
int	O
str	int
,	O
struct	O
reading_moves	struct
*	O
moves	array
,	O
int	O
color	int
,	O
const	O
char	O
*	O
funcname	pointer
,	O
int	O
killer	int
)	O
{	O
int	O
string_color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
string_libs	int
=	O
countlib	function
(	O
str	int
)	O
;	O
int	O
r	int
;	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
moves	array
->	O
num	int
-	O
moves	array
->	O
num_tried	int
<	O
2	int
)	O
{	O
if	O
(	O
sgf_dumptree	pointer
&&	O
moves	array
->	O
num	int
>	O
moves	array
->	O
num_tried	int
)	O
sgf_dumpmoves	function
(	O
moves	array
,	O
funcname	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
r	int
=	O
moves	array
->	O
num_tried	int
;	O
r	int
<	O
moves	array
->	O
num	int
;	O
r	int
++	O
)	O
{	O
int	O
move	pointer
=	O
moves	array
->	O
pos	int
[	O
r	int
]	O
;	O
int	O
number_edges	pointer
=	O
0	int
;	O
int	O
number_same_string	pointer
=	O
0	int
;	O
int	O
number_own	pointer
=	O
0	int
;	O
int	O
number_opponent	pointer
=	O
0	int
;	O
int	O
captured_stones	pointer
=	O
0	int
;	O
int	O
threatened_stones	pointer
=	O
0	int
;	O
int	O
saved_stones	pointer
=	O
0	int
;	O
int	O
number_open	pointer
=	O
0	int
;	O
incremental_order_moves	function
(	O
move	pointer
,	O
color	int
,	O
str	int
,	O
&	O
number_edges	pointer
,	O
&	O
number_same_string	pointer
,	O
&	O
number_own	pointer
,	O
&	O
number_opponent	pointer
,	O
&	O
captured_stones	pointer
,	O
&	O
threatened_stones	pointer
,	O
&	O
saved_stones	pointer
,	O
&	O
number_open	pointer
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"%o %1m values: %d %d %d %d %d %d %d %d\n"	pointer
,	O
move	pointer
,	O
number_edges	pointer
,	O
number_same_string	pointer
,	O
number_own	pointer
,	O
number_opponent	pointer
,	O
captured_stones	pointer
,	O
threatened_stones	pointer
,	O
saved_stones	pointer
,	O
number_open	pointer
)	O
;	O
if	O
(	O
color	int
==	O
string_color	int
)	O
{	O
int	O
libs	pointer
=	O
approxlib	function
(	O
move	pointer
,	O
color	int
,	O
10	int
,	O
NULL	O
)	O
;	O
if	O
(	O
number_same_string	pointer
>	O
0	int
)	O
{	O
if	O
(	O
libs	pointer
>	O
5	int
||	O
(	O
libs	pointer
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_lib_score	array
[	O
5	int
]	O
+	O
(	O
libs	pointer
-	O
4	int
)	O
;	O
else	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_lib_score	array
[	O
libs	pointer
]	O
;	O
}	O
else	O
{	O
if	O
(	O
libs	pointer
>	O
4	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_not_adjacent_lib_score	array
[	O
4	int
]	O
;	O
else	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_not_adjacent_lib_score	array
[	O
libs	pointer
]	O
;	O
}	O
gg_assert	O
(	O
number_open	pointer
<=	O
4	int
)	O
;	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_open_score	array
[	O
number_open	pointer
]	O
;	O
if	O
(	O
number_edges	pointer
==	O
0	int
||	O
captured_stones	pointer
>	O
0	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_not_edge_score	int
;	O
if	O
(	O
captured_stones	pointer
<=	O
5	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_capture_score	array
[	O
captured_stones	pointer
]	O
;	O
else	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_capture_score	array
[	O
5	int
]	O
+	O
captured_stones	pointer
;	O
if	O
(	O
libs	pointer
+	O
captured_stones	pointer
>	O
1	int
)	O
{	O
if	O
(	O
threatened_stones	pointer
<=	O
5	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_atari_score	array
[	O
threatened_stones	pointer
]	O
;	O
else	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_atari_score	array
[	O
5	int
]	O
+	O
threatened_stones	pointer
;	O
}	O
if	O
(	O
saved_stones	pointer
<=	O
5	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_save_score	array
[	O
saved_stones	pointer
]	O
;	O
else	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
defend_save_score	array
[	O
5	int
]	O
;	O
}	O
else	O
{	O
int	O
libs	pointer
=	O
approxlib	function
(	O
move	pointer
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
libs	pointer
>	O
4	int
)	O
libs	pointer
=	O
4	int
;	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_own_lib_score	array
[	O
libs	pointer
]	O
;	O
if	O
(	O
libs	pointer
==	O
0	int
&&	O
captured_stones	pointer
==	O
1	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_ko_score	int
;	O
if	O
(	O
(	O
libs	pointer
+	O
captured_stones	pointer
>	O
1	int
||	O
(	O
string_libs	int
<=	O
2	int
&&	O
number_own	pointer
==	O
0	int
)	O
)	O
&&	O
number_same_string	pointer
>	O
0	int
)	O
{	O
int	O
safe_atari	int
;	O
int	O
liberties	pointer
=	O
approxlib	function
(	O
move	pointer
,	O
string_color	int
,	O
5	int
,	O
NULL	O
)	O
;	O
if	O
(	O
liberties	pointer
>	O
5	int
||	O
(	O
liberties	pointer
==	O
4	int
&&	O
stackp	int
>	O
fourlib_depth	int
)	O
)	O
liberties	pointer
=	O
5	int
;	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_string_lib_score	array
[	O
liberties	pointer
]	O
;	O
safe_atari	int
=	O
(	O
string_libs	int
<=	O
2	int
&&	O
libs	pointer
+	O
captured_stones	pointer
>	O
1	int
)	O
;	O
if	O
(	O
liberties	pointer
==	O
1	int
&&	O
saved_stones	pointer
==	O
0	int
&&	O
!	O
safe_atari	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
cannot_defend_penalty	int
;	O
if	O
(	O
safe_atari	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
safe_atari_score	int
;	O
}	O
gg_assert	O
(	O
number_open	pointer
<=	O
4	int
)	O
;	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_open_score	array
[	O
number_open	pointer
]	O
;	O
if	O
(	O
number_edges	pointer
==	O
0	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_not_edge_score	int
;	O
if	O
(	O
captured_stones	pointer
<=	O
5	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_capture_score	array
[	O
captured_stones	pointer
]	O
;	O
else	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_capture_score	array
[	O
5	int
]	O
;	O
if	O
(	O
saved_stones	pointer
<=	O
5	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_save_score	array
[	O
saved_stones	pointer
]	O
;	O
else	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
attack_save_score	array
[	O
5	int
]	O
;	O
}	O
if	O
(	O
moves	array
->	O
pos	int
[	O
r	int
]	O
==	O
killer	int
)	O
moves	array
->	O
score	float
[	O
r	int
]	O
+=	O
50	int
;	O
}	O
for	O
(	O
i	int
=	O
moves	array
->	O
num_tried	int
;	O
i	int
<	O
moves	array
->	O
num	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
int	O
maxscore	int
=	O
moves	array
->	O
score	float
[	O
i	int
]	O
;	O
int	O
max_at	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
moves	array
->	O
num	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
moves	array
->	O
score	float
[	O
j	int
]	O
>	O
maxscore	int
)	O
{	O
maxscore	int
=	O
moves	array
->	O
score	float
[	O
j	int
]	O
;	O
max_at	int
=	O
j	int
;	O
}	O
}	O
if	O
(	O
max_at	int
!=	O
0	int
)	O
{	O
int	O
temp	int
=	O
moves	array
->	O
pos	int
[	O
max_at	int
]	O
;	O
const	O
char	O
*	O
temp_message	pointer
=	O
moves	array
->	O
message	pointer
[	O
max_at	int
]	O
;	O
moves	array
->	O
pos	int
[	O
max_at	int
]	O
=	O
moves	array
->	O
pos	int
[	O
i	int
]	O
;	O
moves	array
->	O
score	float
[	O
max_at	int
]	O
=	O
moves	array
->	O
score	float
[	O
i	int
]	O
;	O
moves	array
->	O
message	pointer
[	O
max_at	int
]	O
=	O
moves	array
->	O
message	pointer
[	O
i	int
]	O
;	O
moves	array
->	O
pos	int
[	O
i	int
]	O
=	O
temp	int
;	O
moves	array
->	O
score	float
[	O
i	int
]	O
=	O
maxscore	int
;	O
moves	array
->	O
message	pointer
[	O
i	int
]	O
=	O
temp_message	pointer
;	O
}	O
}	O
if	O
(	O
0	int
)	O
{	O
gprintf	function
(	O
"%oVariation %d:\n"	pointer
,	O
count_variations	int
)	O
;	O
for	O
(	O
i	int
=	O
moves	array
->	O
num_tried	int
;	O
i	int
<	O
moves	array
->	O
num	int
;	O
i	int
++	O
)	O
gprintf	function
(	O
"%o  %1M %d\n"	pointer
,	O
moves	array
->	O
pos	int
[	O
i	int
]	O
,	O
moves	array
->	O
score	float
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgf_dumpmoves	function
(	O
moves	array
,	O
funcname	pointer
)	O
;	O
}	O
void	O
tune_move_ordering	function
(	O
int	O
params	array
[	O
MOVE_ORDERING_PARAMETERS	int
]	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
6	int
;	O
k	int
++	O
)	O
{	O
defend_lib_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
]	O
;	O
if	O
(	O
k	int
<	O
5	int
)	O
defend_not_adjacent_lib_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
6	int
]	O
;	O
defend_capture_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
11	int
]	O
;	O
defend_atari_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
17	int
]	O
;	O
defend_save_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
23	int
]	O
;	O
if	O
(	O
k	int
<	O
5	int
)	O
{	O
defend_open_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
29	int
]	O
;	O
attack_own_lib_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
34	int
]	O
;	O
}	O
attack_string_lib_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
39	int
]	O
;	O
attack_capture_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
45	int
]	O
;	O
attack_save_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
51	int
]	O
;	O
if	O
(	O
k	int
<	O
5	int
)	O
attack_open_score	array
[	O
k	int
]	O
=	O
params	array
[	O
k	int
+	O
57	int
]	O
;	O
}	O
defend_not_edge_score	int
=	O
params	array
[	O
62	int
]	O
;	O
attack_not_edge_score	int
=	O
params	array
[	O
63	int
]	O
;	O
attack_ko_score	int
=	O
params	array
[	O
64	int
]	O
;	O
cannot_defend_penalty	int
=	O
params	array
[	O
65	int
]	O
;	O
safe_atari_score	int
=	O
params	array
[	O
66	int
]	O
;	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	function
(	O
"static int defend_lib_score[6]              = {%d, %d, %d, %d, %d, %d};\n"	pointer
,	O
defend_lib_score	array
[	O
0	int
]	O
,	O
defend_lib_score	array
[	O
1	int
]	O
,	O
defend_lib_score	array
[	O
2	int
]	O
,	O
defend_lib_score	array
[	O
3	int
]	O
,	O
defend_lib_score	array
[	O
4	int
]	O
,	O
defend_lib_score	array
[	O
5	int
]	O
)	O
;	O
gprintf	function
(	O
"static int defend_not_adjacent_lib_score[5] = {%d, %d, %d, %d, %d};\n"	pointer
,	O
defend_not_adjacent_lib_score	array
[	O
0	int
]	O
,	O
defend_not_adjacent_lib_score	array
[	O
1	int
]	O
,	O
defend_not_adjacent_lib_score	array
[	O
2	int
]	O
,	O
defend_not_adjacent_lib_score	array
[	O
3	int
]	O
,	O
defend_not_adjacent_lib_score	array
[	O
4	int
]	O
)	O
;	O
gprintf	function
(	O
"static int defend_capture_score[6]          = {%d, %d, %d, %d, %d, %d};\n"	pointer
,	O
defend_capture_score	array
[	O
0	int
]	O
,	O
defend_capture_score	array
[	O
1	int
]	O
,	O
defend_capture_score	array
[	O
2	int
]	O
,	O
defend_capture_score	array
[	O
3	int
]	O
,	O
defend_capture_score	array
[	O
4	int
]	O
,	O
defend_capture_score	array
[	O
5	int
]	O
)	O
;	O
gprintf	function
(	O
"static int defend_atari_score[6]            = {%d, %d, %d, %d, %d, %d};\n"	pointer
,	O
defend_atari_score	array
[	O
0	int
]	O
,	O
defend_atari_score	array
[	O
1	int
]	O
,	O
defend_atari_score	array
[	O
2	int
]	O
,	O
defend_atari_score	array
[	O
3	int
]	O
,	O
defend_atari_score	array
[	O
4	int
]	O
,	O
defend_atari_score	array
[	O
5	int
]	O
)	O
;	O
gprintf	function
(	O
"static int defend_save_score[6]             = {%d, %d, %d, %d, %d, %d};\n"	pointer
,	O
defend_save_score	array
[	O
0	int
]	O
,	O
defend_save_score	array
[	O
1	int
]	O
,	O
defend_save_score	array
[	O
2	int
]	O
,	O
defend_save_score	array
[	O
3	int
]	O
,	O
defend_save_score	array
[	O
4	int
]	O
,	O
defend_save_score	array
[	O
5	int
]	O
)	O
;	O
gprintf	function
(	O
"static int defend_open_score[5]             = {%d, %d, %d, %d, %d};\n"	pointer
,	O
defend_open_score	array
[	O
0	int
]	O
,	O
defend_open_score	array
[	O
1	int
]	O
,	O
defend_open_score	array
[	O
2	int
]	O
,	O
defend_open_score	array
[	O
3	int
]	O
,	O
defend_open_score	array
[	O
4	int
]	O
)	O
;	O
gprintf	function
(	O
"static int attack_own_lib_score[5]          = {%d, %d, %d, %d, %d};\n"	pointer
,	O
attack_own_lib_score	array
[	O
0	int
]	O
,	O
attack_own_lib_score	array
[	O
1	int
]	O
,	O
attack_own_lib_score	array
[	O
2	int
]	O
,	O
attack_own_lib_score	array
[	O
3	int
]	O
,	O
attack_own_lib_score	array
[	O
4	int
]	O
)	O
;	O
gprintf	function
(	O
"static int attack_string_lib_score[6]       = {%d, %d, %d, %d, %d, %d};\n"	pointer
,	O
attack_string_lib_score	array
[	O
0	int
]	O
,	O
attack_string_lib_score	array
[	O
1	int
]	O
,	O
attack_string_lib_score	array
[	O
2	int
]	O
,	O
attack_string_lib_score	array
[	O
3	int
]	O
,	O
attack_string_lib_score	array
[	O
4	int
]	O
,	O
attack_string_lib_score	array
[	O
5	int
]	O
)	O
;	O
gprintf	function
(	O
"static int attack_capture_score[6]          = {%d, %d, %d, %d, %d, %d};\n"	pointer
,	O
attack_capture_score	array
[	O
0	int
]	O
,	O
attack_capture_score	array
[	O
1	int
]	O
,	O
attack_capture_score	array
[	O
2	int
]	O
,	O
attack_capture_score	array
[	O
3	int
]	O
,	O
attack_capture_score	array
[	O
4	int
]	O
,	O
attack_capture_score	array
[	O
5	int
]	O
)	O
;	O
gprintf	function
(	O
"static int attack_save_score[6]             = {%d, %d, %d, %d, %d, %d};\n"	pointer
,	O
attack_save_score	array
[	O
0	int
]	O
,	O
attack_save_score	array
[	O
1	int
]	O
,	O
attack_save_score	array
[	O
2	int
]	O
,	O
attack_save_score	array
[	O
3	int
]	O
,	O
attack_save_score	array
[	O
4	int
]	O
,	O
attack_save_score	array
[	O
5	int
]	O
)	O
;	O
gprintf	function
(	O
"static int attack_open_score[5]             = {%d, %d, %d, %d, %d};\n"	pointer
,	O
attack_open_score	array
[	O
0	int
]	O
,	O
attack_open_score	array
[	O
1	int
]	O
,	O
attack_open_score	array
[	O
2	int
]	O
,	O
attack_open_score	array
[	O
3	int
]	O
,	O
attack_open_score	array
[	O
4	int
]	O
)	O
;	O
gprintf	function
(	O
"static int defend_not_edge_score            = %d;\n"	pointer
,	O
defend_not_edge_score	int
)	O
;	O
gprintf	function
(	O
"static int attack_not_edge_score            = %d;\n"	pointer
,	O
attack_not_edge_score	int
)	O
;	O
gprintf	function
(	O
"static int attack_ko_score                  = %d;\n"	pointer
,	O
attack_ko_score	int
)	O
;	O
gprintf	function
(	O
"static int cannot_defend_penalty            = %d;\n"	pointer
,	O
cannot_defend_penalty	int
)	O
;	O
gprintf	function
(	O
"static int safe_atari_score                 = %d;\n"	pointer
,	O
safe_atari_score	int
)	O
;	O
}	O
}	O
static	O
int	O
safe_move_cache	array
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
static	O
int	O
safe_move_cache_when	array
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
static	O
void	O
clear_safe_move_cache	function
(	O
void	O
)	O
;	O
static	O
void	O
clear_safe_move_cache	function
(	O
void	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
BOARDMIN	O
;	O
k	int
<	O
BOARDMAX	O
;	O
k	int
++	O
)	O
{	O
safe_move_cache_when	array
[	O
k	int
]	O
[	O
0	int
]	O
=	O
-	O
1	int
;	O
safe_move_cache_when	array
[	O
k	int
]	O
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
int	O
safe_move	function
(	O
int	O
move	pointer
,	O
int	O
color	int
)	O
{	O
int	O
safe	int
=	O
0	int
;	O
static	O
int	O
initialized	int
=	O
0	int
;	O
int	O
ko_move	int
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
clear_safe_move_cache	function
(	O
)	O
;	O
initialized	int
=	O
1	int
;	O
}	O
if	O
(	O
stackp	int
==	O
0	int
&&	O
depth_offset	int
==	O
0	int
&&	O
safe_move_cache_when	array
[	O
move	pointer
]	O
[	O
color	int
==	O
BLACK	int
]	O
==	O
position_number	int
)	O
return	O
safe_move_cache	array
[	O
move	pointer
]	O
[	O
color	int
==	O
BLACK	int
]	O
;	O
if	O
(	O
komaster_trymove	function
(	O
move	pointer
,	O
color	int
,	O
"safe_move"	pointer
,	O
0	int
,	O
&	O
ko_move	int
,	O
1	int
)	O
)	O
{	O
safe	int
=	O
REVERSE_RESULT	O
(	O
attack	function
(	O
move	pointer
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
ko_move	int
&&	O
safe	int
!=	O
0	int
)	O
safe	int
=	O
KO_B	int
;	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
stackp	int
==	O
0	int
&&	O
depth_offset	int
==	O
0	int
)	O
{	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Safe move at %1m for %s cached when depth=%d, position number=%d\n"	pointer
,	O
move	pointer
,	O
color_to_string	function
(	O
color	int
)	O
,	O
depth	int
,	O
position_number	int
)	O
;	O
safe_move_cache_when	array
[	O
move	pointer
]	O
[	O
color	int
==	O
BLACK	int
]	O
=	O
position_number	int
;	O
safe_move_cache	array
[	O
move	pointer
]	O
[	O
color	int
==	O
BLACK	int
]	O
=	O
safe	int
;	O
}	O
return	O
safe	int
;	O
}	O
int	O
does_secure	function
(	O
int	O
color	int
,	O
int	O
move	pointer
,	O
int	O
pos	int
)	O
{	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
is_self_atari	function
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
result	int
=	O
1	int
;	O
popgo	function
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
void	O
reset_reading_node_counter	function
(	O
)	O
{	O
reading_node_counter	int
=	O
0	int
;	O
}	O
int	O
get_reading_node_counter	function
(	O
)	O
{	O
return	O
reading_node_counter	int
;	O
}	O
void	O
draw_reading_shadow	function
(	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
c	char
=	O
' '	O
;	O
int	O
pos	int
;	O
start_draw_board	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n%2d"	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
pos	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
!	O
shadow	array
[	O
pos	int
]	O
&&	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
c	char
=	O
'.'	O
;	O
else	O
if	O
(	O
!	O
shadow	array
[	O
pos	int
]	O
&&	O
board	pointer
[	O
pos	int
]	O
==	O
WHITE	int
)	O
c	char
=	O
'O'	O
;	O
else	O
if	O
(	O
!	O
shadow	array
[	O
pos	int
]	O
&&	O
board	pointer
[	O
pos	int
]	O
==	O
BLACK	int
)	O
c	char
=	O
'X'	O
;	O
if	O
(	O
shadow	array
[	O
pos	int
]	O
&&	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
c	char
=	O
','	O
;	O
else	O
if	O
(	O
shadow	array
[	O
pos	int
]	O
&&	O
board	pointer
[	O
pos	int
]	O
==	O
WHITE	int
)	O
c	char
=	O
'o'	O
;	O
else	O
if	O
(	O
shadow	array
[	O
pos	int
]	O
&&	O
board	pointer
[	O
pos	int
]	O
==	O
BLACK	int
)	O
c	char
=	O
'x'	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" %c"	pointer
,	O
c	char
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
" %d"	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
}	O
end_draw_board	function
(	O
)	O
;	O
}	O
int	O
simple_ladder	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
;	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
dcode	int
;	O
int	O
k	int
;	O
struct	O
reading_moves	struct
moves	array
;	O
SETUP_TRACE_INFO	O
(	O
"simple_ladder"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
moves	array
.	O
num	int
=	O
0	int
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
str	int
=	O
find_origin	function
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
2	int
,	O
str	int
)	O
;	O
if	O
(	O
stackp	int
>	O
depth	int
+	O
20	int
&&	O
get_komaster	function
(	O
)	O
==	O
OTHER_COLOR	O
(	O
board	pointer
[	O
str	int
]	O
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
return	O
0	int
;	O
}	O
findlib	function
(	O
str	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
<=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
1	int
]	O
,	O
0	int
,	O
moves	array
,	O
"simple_ladder"	pointer
)	O
;	O
if	O
(	O
approxlib	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
<=	O
3	int
)	O
ADD_CANDIDATE_MOVE	O
(	O
libs	pointer
[	O
0	int
]	O
,	O
0	int
,	O
moves	array
,	O
"simple_ladder"	pointer
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
other	int
,	O
read_function_name	pointer
,	O
NO_MOVE	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
moves	array
.	O
num	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
apos	int
=	O
moves	array
.	O
pos	int
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	function
(	O
apos	int
,	O
other	int
,	O
moves	array
.	O
message	pointer
[	O
k	int
]	O
,	O
str	int
,	O
&	O
ko_move	int
,	O
savecode	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
dcode	int
=	O
simple_ladder_defend	function
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
!=	O
WIN	int
)	O
{	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
SGFTRACE	O
(	O
apos	int
,	O
WIN	int
,	O
"attack effective"	pointer
)	O
;	O
if	O
(	O
move	pointer
)	O
*	O
move	pointer
=	O
apos	int
;	O
return	O
WIN	int
;	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
dcode	int
,	O
apos	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
simple_ladder_defend	function
(	O
str	int
,	O
NULL	O
)	O
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
apos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
static	O
int	O
simple_ladder_defend	function
(	O
int	O
str	int
,	O
int	O
*	O
move	pointer
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
xpos	int
;	O
int	O
lib	int
;	O
struct	O
reading_moves	struct
moves	array
;	O
int	O
savemove	int
=	O
0	int
;	O
int	O
savecode	int
=	O
0	int
;	O
int	O
k	int
;	O
SETUP_TRACE_INFO	O
(	O
"simple_ladder_defend"	pointer
,	O
str	int
)	O
;	O
reading_node_counter	int
++	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
countlib	function
(	O
str	int
)	O
==	O
1	int
,	O
str	int
)	O
;	O
findlib	function
(	O
str	int
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
moves	array
.	O
pos	int
[	O
0	int
]	O
=	O
lib	int
;	O
moves	array
.	O
score	float
[	O
0	int
]	O
=	O
0	int
;	O
moves	array
.	O
message	pointer
[	O
0	int
]	O
=	O
"liberty"	pointer
;	O
moves	array
.	O
num	int
=	O
1	int
;	O
moves	array
.	O
num_tried	int
=	O
0	int
;	O
break_chain_moves	function
(	O
str	int
,	O
&	O
moves	array
)	O
;	O
order_moves	function
(	O
str	int
,	O
&	O
moves	array
,	O
color	int
,	O
read_function_name	pointer
,	O
NO_MOVE	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
moves	array
.	O
num	int
;	O
k	int
++	O
)	O
{	O
int	O
ko_move	int
;	O
xpos	int
=	O
moves	array
.	O
pos	int
[	O
k	int
]	O
;	O
if	O
(	O
komaster_trymove	function
(	O
xpos	int
,	O
color	int
,	O
moves	array
.	O
message	pointer
[	O
k	int
]	O
,	O
str	int
,	O
&	O
ko_move	int
,	O
savecode	int
==	O
0	int
)	O
)	O
{	O
int	O
acode	int
;	O
int	O
new_libs	int
=	O
countlib	function
(	O
str	int
)	O
;	O
if	O
(	O
new_libs	int
>	O
2	int
)	O
acode	int
=	O
0	int
;	O
else	O
if	O
(	O
new_libs	int
<	O
2	int
)	O
acode	int
=	O
WIN	int
;	O
else	O
acode	int
=	O
simple_ladder	function
(	O
str	int
,	O
NULL	O
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
!	O
ko_move	int
)	O
CHECK_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
acode	int
,	O
xpos	int
,	O
move	pointer
,	O
"defense effective"	pointer
)	O
;	O
else	O
{	O
if	O
(	O
acode	int
!=	O
WIN	int
)	O
{	O
savemove	int
=	O
xpos	int
;	O
savecode	int
=	O
KO_B	int
;	O
}	O
}	O
}	O
}	O
RETURN_RESULT	O
(	O
savecode	int
,	O
savemove	int
,	O
move	pointer
,	O
"saved move"	pointer
)	O
;	O
}	O
