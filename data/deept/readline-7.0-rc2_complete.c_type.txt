typedef	O
int	O
QSFUNC	function
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
;	O
extern	O
struct	O
passwd	struct
*	O
getpwent	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
rl_compdisp_func_t	function
*	O
rl_completion_display_matches_hook	pointer
=	O
(	O
rl_compdisp_func_t	function
*	O
)	O
NULL	O
;	O
static	O
int	O
stat_char	function
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
colored_stat_start	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
colored_stat_end	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
colored_prefix_start	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
colored_prefix_end	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
path_isdir	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
rl_quote_filename	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
_rl_complete_sigcleanup	function
PARAMS	O
(	O
(	O
int	O
,	O
void	O
*	O
)	O
)	O
;	O
static	O
void	O
set_completion_defaults	function
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
get_y_or_n	function
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_internal_pager	function
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
char	O
*	O
printable_part	function
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
fnwidth	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
fnprint	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
print_filename	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
char	O
*	O
*	O
gen_completion_matches	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
rl_compentry_func_t	function
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
char	O
*	O
*	O
remove_duplicate_matches	function
PARAMS	O
(	O
(	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
void	O
insert_match	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
append_to_match	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
insert_all_matches	function
PARAMS	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
complete_fncmp	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
display_matches	function
PARAMS	O
(	O
(	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
int	O
compute_lcd_of_matches	function
PARAMS	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
postprocess_matches	function
PARAMS	O
(	O
(	O
char	O
*	O
*	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
complete_get_screenwidth	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
char	O
*	O
make_quoted_replacement	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
int	O
_rl_complete_show_all	int
=	O
0	int
;	O
int	O
_rl_complete_show_unmodified	int
=	O
0	int
;	O
int	O
_rl_complete_mark_directories	int
=	O
1	int
;	O
int	O
_rl_complete_mark_symlink_dirs	int
=	O
0	int
;	O
int	O
_rl_print_completions_horizontally	int
;	O
int	O
_rl_completion_case_fold	int
=	O
0	int
;	O
int	O
_rl_completion_case_map	int
=	O
0	int
;	O
int	O
_rl_match_hidden_files	int
=	O
1	int
;	O
int	O
_rl_completion_prefix_display_length	int
=	O
0	int
;	O
int	O
_rl_completion_columns	int
=	O
-	O
1	int
;	O
int	O
rl_visible_stats	int
=	O
0	int
;	O
int	O
_rl_colored_stats	int
=	O
0	int
;	O
int	O
_rl_colored_completion_prefix	int
=	O
0	int
;	O
int	O
_rl_skip_completed_text	int
=	O
0	int
;	O
int	O
_rl_menu_complete_prefix_first	int
=	O
0	int
;	O
rl_icppfunc_t	function
*	O
rl_directory_completion_hook	pointer
=	O
(	O
rl_icppfunc_t	function
*	O
)	O
NULL	O
;	O
rl_icppfunc_t	function
*	O
rl_directory_rewrite_hook	pointer
=	O
(	O
rl_icppfunc_t	function
*	O
)	O
NULL	O
;	O
rl_icppfunc_t	function
*	O
rl_filename_stat_hook	pointer
=	O
(	O
rl_icppfunc_t	function
*	O
)	O
NULL	O
;	O
rl_dequote_func_t	function
*	O
rl_filename_rewrite_hook	pointer
=	O
(	O
rl_dequote_func_t	function
*	O
)	O
NULL	O
;	O
int	O
rl_complete_with_tilde_expansion	int
=	O
0	int
;	O
rl_compentry_func_t	function
*	O
rl_completion_entry_function	pointer
=	O
(	O
rl_compentry_func_t	function
*	O
)	O
NULL	O
;	O
rl_compentry_func_t	function
*	O
rl_menu_completion_entry_function	pointer
=	O
(	O
rl_compentry_func_t	function
*	O
)	O
NULL	O
;	O
rl_completion_func_t	function
*	O
rl_attempted_completion_function	pointer
=	O
(	O
rl_completion_func_t	function
*	O
)	O
NULL	O
;	O
int	O
rl_attempted_completion_over	int
=	O
0	int
;	O
int	O
rl_completion_type	int
=	O
0	int
;	O
int	O
rl_completion_query_items	int
=	O
100	int
;	O
int	O
_rl_page_completions	int
=	O
1	int
;	O
const	O
char	O
*	O
rl_basic_word_break_characters	pointer
=	O
" \t\n\"\\'`@$><=;|&{("	pointer
;	O
const	O
char	O
*	O
rl_basic_quote_characters	pointer
=	O
"\"'"	pointer
;	O
char	O
*	O
rl_completer_word_break_characters	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
rl_cpvfunc_t	function
*	O
rl_completion_word_break_hook	pointer
=	O
(	O
rl_cpvfunc_t	function
*	O
)	O
NULL	O
;	O
const	O
char	O
*	O
rl_completer_quote_characters	pointer
=	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
const	O
char	O
*	O
rl_filename_quote_characters	pointer
=	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
const	O
char	O
*	O
rl_special_prefixes	pointer
=	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
int	O
rl_ignore_completion_duplicates	int
=	O
1	int
;	O
int	O
rl_filename_completion_desired	int
=	O
0	int
;	O
int	O
rl_filename_quoting_desired	int
=	O
1	int
;	O
rl_compignore_func_t	function
*	O
rl_ignore_some_completions_function	pointer
=	O
(	O
rl_compignore_func_t	function
*	O
)	O
NULL	O
;	O
rl_quote_func_t	function
*	O
rl_filename_quoting_function	pointer
=	O
rl_quote_filename	function
;	O
rl_dequote_func_t	function
*	O
rl_filename_dequoting_function	pointer
=	O
(	O
rl_dequote_func_t	function
*	O
)	O
NULL	O
;	O
rl_linebuf_func_t	function
*	O
rl_char_is_quoted_p	pointer
=	O
(	O
rl_linebuf_func_t	function
*	O
)	O
NULL	O
;	O
int	O
rl_completion_suppress_append	int
=	O
0	int
;	O
int	O
rl_completion_append_character	int
=	O
' '	O
;	O
int	O
rl_completion_suppress_quote	int
=	O
0	int
;	O
int	O
rl_completion_quote_character	int
;	O
int	O
rl_completion_found_quote	int
;	O
int	O
rl_completion_mark_symlink_dirs	int
;	O
int	O
rl_inhibit_completion	int
;	O
int	O
rl_completion_invoking_key	int
;	O
int	O
rl_sort_completion_matches	int
=	O
1	int
;	O
static	O
int	O
completion_changed_buffer	int
;	O
static	O
int	O
completion_y_or_n	int
;	O
static	O
int	O
_rl_complete_display_matches_interrupt	int
=	O
0	int
;	O
int	O
rl_complete	function
(	O
ignore	int
,	O
invoking_key	int
)	O
int	O
ignore	int
,	O
invoking_key	int
;	O
{	O
rl_completion_invoking_key	int
=	O
invoking_key	int
;	O
if	O
(	O
rl_inhibit_completion	int
)	O
return	O
(	O
_rl_insert_char	function
(	O
ignore	int
,	O
invoking_key	int
)	O
)	O
;	O
else	O
if	O
(	O
rl_last_func	pointer
==	O
rl_complete	function
&&	O
!	O
completion_changed_buffer	int
)	O
return	O
(	O
rl_complete_internal	function
(	O
'?'	O
)	O
)	O
;	O
else	O
if	O
(	O
_rl_complete_show_all	int
)	O
return	O
(	O
rl_complete_internal	function
(	O
'!'	O
)	O
)	O
;	O
else	O
if	O
(	O
_rl_complete_show_unmodified	int
)	O
return	O
(	O
rl_complete_internal	function
(	O
'@'	O
)	O
)	O
;	O
else	O
return	O
(	O
rl_complete_internal	function
(	O
TAB	char
)	O
)	O
;	O
}	O
int	O
rl_possible_completions	function
(	O
ignore	int
,	O
invoking_key	int
)	O
int	O
ignore	int
,	O
invoking_key	int
;	O
{	O
rl_completion_invoking_key	int
=	O
invoking_key	int
;	O
return	O
(	O
rl_complete_internal	function
(	O
'?'	O
)	O
)	O
;	O
}	O
int	O
rl_insert_completions	function
(	O
ignore	int
,	O
invoking_key	int
)	O
int	O
ignore	int
,	O
invoking_key	int
;	O
{	O
rl_completion_invoking_key	int
=	O
invoking_key	int
;	O
return	O
(	O
rl_complete_internal	function
(	O
'*'	O
)	O
)	O
;	O
}	O
int	O
rl_completion_mode	function
(	O
cfunc	pointer
)	O
rl_command_func_t	function
*	O
cfunc	pointer
;	O
{	O
if	O
(	O
rl_last_func	pointer
==	O
cfunc	pointer
&&	O
!	O
completion_changed_buffer	int
)	O
return	O
'?'	O
;	O
else	O
if	O
(	O
_rl_complete_show_all	int
)	O
return	O
'!'	O
;	O
else	O
if	O
(	O
_rl_complete_show_unmodified	int
)	O
return	O
'@'	O
;	O
else	O
return	O
TAB	char
;	O
}	O
void	O
_rl_reset_completion_state	function
(	O
)	O
{	O
rl_completion_found_quote	int
=	O
0	int
;	O
rl_completion_quote_character	int
=	O
0	int
;	O
}	O
static	O
void	O
_rl_complete_sigcleanup	function
(	O
sig	int
,	O
ptr	pointer
)	O
int	O
sig	int
;	O
void	O
*	O
ptr	pointer
;	O
{	O
if	O
(	O
sig	int
==	O
SIGINT	int
)	O
{	O
_rl_free_match_list	function
(	O
(	O
char	O
*	O
*	O
)	O
ptr	pointer
)	O
;	O
_rl_complete_display_matches_interrupt	int
=	O
1	int
;	O
}	O
}	O
static	O
void	O
set_completion_defaults	function
(	O
what_to_do	int
)	O
int	O
what_to_do	int
;	O
{	O
rl_filename_completion_desired	int
=	O
0	int
;	O
rl_filename_quoting_desired	int
=	O
1	int
;	O
rl_completion_type	int
=	O
what_to_do	int
;	O
rl_completion_suppress_append	int
=	O
rl_completion_suppress_quote	int
=	O
0	int
;	O
rl_completion_append_character	int
=	O
' '	O
;	O
rl_completion_mark_symlink_dirs	int
=	O
_rl_complete_mark_symlink_dirs	int
;	O
_rl_complete_display_matches_interrupt	int
=	O
0	int
;	O
}	O
static	O
int	O
get_y_or_n	function
(	O
for_pager	int
)	O
int	O
for_pager	int
;	O
{	O
int	O
c	int
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
c	int
==	O
'y'	O
||	O
c	int
==	O
'Y'	O
||	O
c	int
==	O
' '	O
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
c	int
==	O
'n'	O
||	O
c	int
==	O
'N'	O
||	O
c	int
==	O
RUBOUT	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
c	int
==	O
ABORT_CHAR	O
||	O
c	int
<	O
0	int
)	O
_rl_abort_internal	function
(	O
)	O
;	O
if	O
(	O
for_pager	int
&&	O
(	O
c	int
==	O
NEWLINE	char
||	O
c	int
==	O
RETURN	O
)	O
)	O
return	O
(	O
2	int
)	O
;	O
if	O
(	O
for_pager	int
&&	O
(	O
c	int
==	O
'q'	O
||	O
c	int
==	O
'Q'	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
rl_ding	function
(	O
)	O
;	O
}	O
}	O
static	O
int	O
_rl_internal_pager	function
(	O
lines	pointer
)	O
int	O
lines	pointer
;	O
{	O
int	O
i	int
;	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"--More--"	pointer
)	O
;	O
fflush	function
(	O
rl_outstream	pointer
)	O
;	O
i	int
=	O
get_y_or_n	function
(	O
1	int
)	O
;	O
_rl_erase_entire_line	function
(	O
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
i	int
==	O
2	int
)	O
return	O
(	O
lines	pointer
-	O
1	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
static	O
int	O
path_isdir	function
(	O
filename	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
struct	O
stat	struct
finfo	struct
;	O
return	O
(	O
stat	struct
(	O
filename	pointer
,	O
&	O
finfo	struct
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
;	O
}	O
static	O
int	O
stat_char	function
(	O
filename	pointer
)	O
char	O
*	O
filename	pointer
;	O
{	O
struct	O
stat	struct
finfo	struct
;	O
int	O
character	int
,	O
r	int
;	O
char	O
*	O
f	pointer
;	O
const	O
char	O
*	O
fn	pointer
;	O
f	pointer
=	O
0	int
;	O
if	O
(	O
rl_filename_stat_hook	pointer
)	O
{	O
f	pointer
=	O
savestring	O
(	O
filename	pointer
)	O
;	O
(	O
*	O
rl_filename_stat_hook	pointer
)	O
(	O
&	O
f	pointer
)	O
;	O
fn	pointer
=	O
f	pointer
;	O
}	O
else	O
fn	pointer
=	O
filename	pointer
;	O
r	int
=	O
lstat	function
(	O
fn	pointer
,	O
&	O
finfo	struct
)	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
return	O
(	O
0	int
)	O
;	O
character	int
=	O
0	int
;	O
if	O
(	O
S_ISDIR	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
character	int
=	O
'/'	O
;	O
else	O
if	O
(	O
S_ISCHR	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
character	int
=	O
'%'	O
;	O
else	O
if	O
(	O
S_ISBLK	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
character	int
=	O
'#'	O
;	O
else	O
if	O
(	O
S_ISLNK	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
character	int
=	O
'@'	O
;	O
else	O
if	O
(	O
S_ISSOCK	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
character	int
=	O
'='	O
;	O
else	O
if	O
(	O
S_ISFIFO	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
character	int
=	O
'|'	O
;	O
else	O
if	O
(	O
S_ISREG	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
access	function
(	O
filename	pointer
,	O
X_OK	int
)	O
==	O
0	int
)	O
character	int
=	O
'*'	O
;	O
}	O
xfree	function
(	O
f	pointer
)	O
;	O
return	O
(	O
character	int
)	O
;	O
}	O
static	O
int	O
colored_stat_start	function
(	O
filename	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
_rl_set_normal_color	function
(	O
)	O
;	O
return	O
(	O
_rl_print_color_indicator	function
(	O
filename	pointer
)	O
)	O
;	O
}	O
static	O
void	O
colored_stat_end	function
(	O
)	O
{	O
_rl_prep_non_filename_text	function
(	O
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_CLR_TO_EOL	int
]	O
)	O
;	O
}	O
static	O
int	O
colored_prefix_start	function
(	O
)	O
{	O
_rl_set_normal_color	function
(	O
)	O
;	O
return	O
(	O
_rl_print_prefix_color	function
(	O
)	O
)	O
;	O
}	O
static	O
void	O
colored_prefix_end	function
(	O
)	O
{	O
colored_stat_end	function
(	O
)	O
;	O
}	O
static	O
char	O
*	O
printable_part	function
(	O
pathname	pointer
)	O
char	O
*	O
pathname	pointer
;	O
{	O
char	O
*	O
temp	pointer
,	O
*	O
x	pointer
;	O
if	O
(	O
rl_filename_completion_desired	int
==	O
0	int
)	O
return	O
(	O
pathname	pointer
)	O
;	O
temp	pointer
=	O
strrchr	function
(	O
pathname	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
temp	pointer
==	O
0	int
||	O
*	O
temp	pointer
==	O
'\0'	O
)	O
return	O
(	O
pathname	pointer
)	O
;	O
else	O
if	O
(	O
temp	pointer
[	O
1	int
]	O
==	O
0	int
&&	O
temp	pointer
==	O
pathname	pointer
)	O
return	O
(	O
pathname	pointer
)	O
;	O
else	O
if	O
(	O
temp	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
for	O
(	O
x	pointer
=	O
temp	pointer
-	O
1	int
;	O
x	pointer
>	O
pathname	pointer
;	O
x	pointer
--	O
)	O
if	O
(	O
*	O
x	pointer
==	O
'/'	O
)	O
break	O
;	O
return	O
(	O
(	O
*	O
x	pointer
==	O
'/'	O
)	O
?	O
x	pointer
+	O
1	int
:	O
pathname	pointer
)	O
;	O
}	O
else	O
return	O
++	O
temp	pointer
;	O
}	O
static	O
int	O
fnwidth	function
(	O
string	pointer
)	O
const	O
char	O
*	O
string	pointer
;	O
{	O
int	O
width	int
,	O
pos	int
;	O
mbstate_t	struct
ps	struct
;	O
int	O
left	int
,	O
w	int
;	O
size_t	long
clen	long
;	O
wchar_t	int
wc	int
;	O
left	int
=	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
width	int
=	O
pos	int
=	O
0	int
;	O
while	O
(	O
string	pointer
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
CTRL_CHAR	O
(	O
string	pointer
[	O
pos	int
]	O
)	O
||	O
string	pointer
[	O
pos	int
]	O
==	O
RUBOUT	int
)	O
{	O
width	int
+=	O
2	int
;	O
pos	int
++	O
;	O
}	O
else	O
{	O
clen	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
string	pointer
+	O
pos	int
,	O
left	int
-	O
pos	int
,	O
&	O
ps	struct
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
clen	long
)	O
)	O
{	O
width	int
++	O
;	O
pos	int
++	O
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
clen	long
)	O
)	O
break	O
;	O
else	O
{	O
pos	int
+=	O
clen	long
;	O
w	int
=	O
WCWIDTH	O
(	O
wc	int
)	O
;	O
width	int
+=	O
(	O
w	int
>=	O
0	int
)	O
?	O
w	int
:	O
1	int
;	O
}	O
}	O
}	O
return	O
width	int
;	O
}	O
static	O
int	O
fnprint	function
(	O
to_print	pointer
,	O
prefix_bytes	int
,	O
real_pathname	pointer
)	O
const	O
char	O
*	O
to_print	pointer
;	O
int	O
prefix_bytes	int
;	O
const	O
char	O
*	O
real_pathname	pointer
;	O
{	O
int	O
printed_len	int
,	O
w	int
;	O
const	O
char	O
*	O
s	pointer
;	O
int	O
common_prefix_len	int
,	O
print_len	int
;	O
mbstate_t	struct
ps	struct
;	O
const	O
char	O
*	O
end	int
;	O
size_t	long
tlen	long
;	O
int	O
width	int
;	O
wchar_t	int
wc	int
;	O
print_len	int
=	O
strlen	function
(	O
to_print	pointer
)	O
;	O
end	int
=	O
to_print	pointer
+	O
print_len	int
+	O
1	int
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
printed_len	int
=	O
common_prefix_len	int
=	O
0	int
;	O
if	O
(	O
_rl_completion_prefix_display_length	int
>	O
0	int
&&	O
prefix_bytes	int
>=	O
print_len	int
)	O
prefix_bytes	int
=	O
0	int
;	O
if	O
(	O
_rl_colored_stats	int
&&	O
(	O
prefix_bytes	int
==	O
0	int
||	O
_rl_colored_completion_prefix	int
<=	O
0	int
)	O
)	O
colored_stat_start	function
(	O
real_pathname	pointer
)	O
;	O
if	O
(	O
prefix_bytes	int
&&	O
_rl_completion_prefix_display_length	int
>	O
0	int
)	O
{	O
char	O
ellipsis	char
;	O
ellipsis	char
=	O
(	O
to_print	pointer
[	O
prefix_bytes	int
]	O
==	O
'.'	O
)	O
?	O
'_'	O
:	O
'.'	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
ELLIPSIS_LEN	int
;	O
w	int
++	O
)	O
putc	function
(	O
ellipsis	char
,	O
rl_outstream	pointer
)	O
;	O
printed_len	int
=	O
ELLIPSIS_LEN	int
;	O
}	O
else	O
if	O
(	O
prefix_bytes	int
&&	O
_rl_colored_completion_prefix	int
>	O
0	int
)	O
{	O
common_prefix_len	int
=	O
prefix_bytes	int
;	O
prefix_bytes	int
=	O
0	int
;	O
colored_prefix_start	function
(	O
)	O
;	O
}	O
s	pointer
=	O
to_print	pointer
+	O
prefix_bytes	int
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
CTRL_CHAR	O
(	O
*	O
s	pointer
)	O
)	O
{	O
putc	function
(	O
'^'	O
,	O
rl_outstream	pointer
)	O
;	O
putc	function
(	O
UNCTRL	O
(	O
*	O
s	pointer
)	O
,	O
rl_outstream	pointer
)	O
;	O
printed_len	int
+=	O
2	int
;	O
s	pointer
++	O
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
RUBOUT	int
)	O
{	O
putc	function
(	O
'^'	O
,	O
rl_outstream	pointer
)	O
;	O
putc	function
(	O
'?'	O
,	O
rl_outstream	pointer
)	O
;	O
printed_len	int
+=	O
2	int
;	O
s	pointer
++	O
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
}	O
else	O
{	O
tlen	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
s	pointer
,	O
end	int
-	O
s	pointer
,	O
&	O
ps	struct
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
tlen	long
)	O
)	O
{	O
tlen	long
=	O
1	int
;	O
width	int
=	O
1	int
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
tlen	long
)	O
)	O
break	O
;	O
else	O
{	O
w	int
=	O
WCWIDTH	O
(	O
wc	int
)	O
;	O
width	int
=	O
(	O
w	int
>=	O
0	int
)	O
?	O
w	int
:	O
1	int
;	O
}	O
fwrite	function
(	O
s	pointer
,	O
1	int
,	O
tlen	long
,	O
rl_outstream	pointer
)	O
;	O
s	pointer
+=	O
tlen	long
;	O
printed_len	int
+=	O
width	int
;	O
}	O
if	O
(	O
common_prefix_len	int
>	O
0	int
&&	O
(	O
s	pointer
-	O
to_print	pointer
)	O
>=	O
common_prefix_len	int
)	O
{	O
colored_prefix_end	function
(	O
)	O
;	O
if	O
(	O
_rl_colored_stats	int
)	O
colored_stat_start	function
(	O
real_pathname	pointer
)	O
;	O
common_prefix_len	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
_rl_colored_stats	int
)	O
colored_stat_end	function
(	O
)	O
;	O
return	O
printed_len	int
;	O
}	O
static	O
int	O
print_filename	function
(	O
to_print	pointer
,	O
full_pathname	pointer
,	O
prefix_bytes	int
)	O
char	O
*	O
to_print	pointer
,	O
*	O
full_pathname	pointer
;	O
int	O
prefix_bytes	int
;	O
{	O
int	O
printed_len	int
,	O
extension_char	int
,	O
slen	int
,	O
tlen	long
;	O
char	O
*	O
s	pointer
,	O
c	int
,	O
*	O
new_full_pathname	pointer
,	O
*	O
dn	pointer
;	O
extension_char	int
=	O
0	int
;	O
if	O
(	O
_rl_colored_stats	int
==	O
0	int
||	O
rl_filename_completion_desired	int
==	O
0	int
)	O
printed_len	int
=	O
fnprint	function
(	O
to_print	pointer
,	O
prefix_bytes	int
,	O
to_print	pointer
)	O
;	O
if	O
(	O
rl_filename_completion_desired	int
&&	O
(	O
rl_visible_stats	int
||	O
_rl_colored_stats	int
||	O
_rl_complete_mark_directories	int
)	O
)	O
{	O
if	O
(	O
to_print	pointer
!=	O
full_pathname	pointer
)	O
{	O
c	int
=	O
to_print	pointer
[	O
-	O
1	int
]	O
;	O
to_print	pointer
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
full_pathname	pointer
==	O
0	int
||	O
*	O
full_pathname	pointer
==	O
0	int
)	O
dn	pointer
=	O
"/"	pointer
;	O
else	O
if	O
(	O
full_pathname	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
dn	pointer
=	O
full_pathname	pointer
;	O
else	O
if	O
(	O
full_pathname	pointer
[	O
1	int
]	O
==	O
0	int
)	O
dn	pointer
=	O
"//"	pointer
;	O
else	O
if	O
(	O
full_pathname	pointer
[	O
1	int
]	O
==	O
'/'	O
&&	O
full_pathname	pointer
[	O
2	int
]	O
==	O
0	int
)	O
dn	pointer
=	O
"/"	pointer
;	O
else	O
dn	pointer
=	O
full_pathname	pointer
;	O
s	pointer
=	O
tilde_expand	function
(	O
dn	pointer
)	O
;	O
if	O
(	O
rl_directory_completion_hook	pointer
)	O
(	O
*	O
rl_directory_completion_hook	pointer
)	O
(	O
&	O
s	pointer
)	O
;	O
slen	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
tlen	long
=	O
strlen	function
(	O
to_print	pointer
)	O
;	O
new_full_pathname	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
slen	int
+	O
tlen	long
+	O
2	int
)	O
;	O
strcpy	function
(	O
new_full_pathname	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
[	O
slen	int
-	O
1	int
]	O
==	O
'/'	O
)	O
slen	int
--	O
;	O
else	O
new_full_pathname	pointer
[	O
slen	int
]	O
=	O
'/'	O
;	O
new_full_pathname	pointer
[	O
slen	int
]	O
=	O
'/'	O
;	O
strcpy	function
(	O
new_full_pathname	pointer
+	O
slen	int
+	O
1	int
,	O
to_print	pointer
)	O
;	O
if	O
(	O
rl_visible_stats	int
)	O
extension_char	int
=	O
stat_char	function
(	O
new_full_pathname	pointer
)	O
;	O
else	O
if	O
(	O
_rl_complete_mark_directories	int
)	O
{	O
dn	pointer
=	O
0	int
;	O
if	O
(	O
rl_directory_completion_hook	pointer
==	O
0	int
&&	O
rl_filename_stat_hook	pointer
)	O
{	O
dn	pointer
=	O
savestring	O
(	O
new_full_pathname	pointer
)	O
;	O
(	O
*	O
rl_filename_stat_hook	pointer
)	O
(	O
&	O
dn	pointer
)	O
;	O
xfree	function
(	O
new_full_pathname	pointer
)	O
;	O
new_full_pathname	pointer
=	O
dn	pointer
;	O
}	O
if	O
(	O
path_isdir	function
(	O
new_full_pathname	pointer
)	O
)	O
extension_char	int
=	O
'/'	O
;	O
}	O
if	O
(	O
_rl_colored_stats	int
)	O
printed_len	int
=	O
fnprint	function
(	O
to_print	pointer
,	O
prefix_bytes	int
,	O
new_full_pathname	pointer
)	O
;	O
xfree	function
(	O
new_full_pathname	pointer
)	O
;	O
to_print	pointer
[	O
-	O
1	int
]	O
=	O
c	int
;	O
}	O
else	O
{	O
s	pointer
=	O
tilde_expand	function
(	O
full_pathname	pointer
)	O
;	O
if	O
(	O
rl_visible_stats	int
)	O
extension_char	int
=	O
stat_char	function
(	O
s	pointer
)	O
;	O
else	O
if	O
(	O
_rl_complete_mark_directories	int
&&	O
path_isdir	function
(	O
s	pointer
)	O
)	O
extension_char	int
=	O
'/'	O
;	O
if	O
(	O
_rl_colored_stats	int
)	O
printed_len	int
=	O
fnprint	function
(	O
to_print	pointer
,	O
prefix_bytes	int
,	O
s	pointer
)	O
;	O
}	O
xfree	function
(	O
s	pointer
)	O
;	O
if	O
(	O
extension_char	int
)	O
{	O
putc	function
(	O
extension_char	int
,	O
rl_outstream	pointer
)	O
;	O
printed_len	int
++	O
;	O
}	O
}	O
return	O
printed_len	int
;	O
}	O
static	O
char	O
*	O
rl_quote_filename	function
(	O
s	pointer
,	O
rtype	int
,	O
qcp	pointer
)	O
char	O
*	O
s	pointer
;	O
int	O
rtype	int
;	O
char	O
*	O
qcp	pointer
;	O
{	O
char	O
*	O
r	int
;	O
r	int
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
s	pointer
)	O
+	O
2	int
)	O
;	O
*	O
r	int
=	O
*	O
rl_completer_quote_characters	pointer
;	O
strcpy	function
(	O
r	int
+	O
1	int
,	O
s	pointer
)	O
;	O
if	O
(	O
qcp	pointer
)	O
*	O
qcp	pointer
=	O
*	O
rl_completer_quote_characters	pointer
;	O
return	O
r	int
;	O
}	O
char	O
_rl_find_completion_word	function
(	O
fp	pointer
,	O
dp	pointer
)	O
int	O
*	O
fp	pointer
,	O
*	O
dp	pointer
;	O
{	O
int	O
scan	int
,	O
end	int
,	O
found_quote	int
,	O
delimiter	int
,	O
pass_next	int
,	O
isbrk	int
;	O
char	O
quote_char	char
,	O
*	O
brkchars	pointer
;	O
end	int
=	O
rl_point	int
;	O
found_quote	int
=	O
delimiter	int
=	O
0	int
;	O
quote_char	char
=	O
'\0'	O
;	O
brkchars	pointer
=	O
0	int
;	O
if	O
(	O
rl_completion_word_break_hook	pointer
)	O
brkchars	pointer
=	O
(	O
*	O
rl_completion_word_break_hook	pointer
)	O
(	O
)	O
;	O
if	O
(	O
brkchars	pointer
==	O
0	int
)	O
brkchars	pointer
=	O
rl_completer_word_break_characters	pointer
;	O
if	O
(	O
rl_completer_quote_characters	pointer
)	O
{	O
for	O
(	O
scan	int
=	O
pass_next	int
=	O
0	int
;	O
scan	int
<	O
end	int
;	O
scan	int
=	O
MB_NEXTCHAR	O
(	O
rl_line_buffer	pointer
,	O
scan	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
)	O
{	O
if	O
(	O
pass_next	int
)	O
{	O
pass_next	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
quote_char	char
!=	O
'\''	O
&&	O
rl_line_buffer	pointer
[	O
scan	int
]	O
==	O
'\\'	O
)	O
{	O
pass_next	int
=	O
1	int
;	O
found_quote	int
|=	O
RL_QF_BACKSLASH	int
;	O
continue	O
;	O
}	O
if	O
(	O
quote_char	char
!=	O
'\0'	O
)	O
{	O
if	O
(	O
rl_line_buffer	pointer
[	O
scan	int
]	O
==	O
quote_char	char
)	O
{	O
quote_char	char
=	O
'\0'	O
;	O
rl_point	int
=	O
end	int
;	O
}	O
}	O
else	O
if	O
(	O
strchr	function
(	O
rl_completer_quote_characters	pointer
,	O
rl_line_buffer	pointer
[	O
scan	int
]	O
)	O
)	O
{	O
quote_char	char
=	O
rl_line_buffer	pointer
[	O
scan	int
]	O
;	O
rl_point	int
=	O
scan	int
+	O
1	int
;	O
if	O
(	O
quote_char	char
==	O
'\''	O
)	O
found_quote	int
|=	O
RL_QF_SINGLE_QUOTE	int
;	O
else	O
if	O
(	O
quote_char	char
==	O
'"'	O
)	O
found_quote	int
|=	O
RL_QF_DOUBLE_QUOTE	int
;	O
else	O
found_quote	int
|=	O
RL_QF_OTHER_QUOTE	int
;	O
}	O
}	O
}	O
if	O
(	O
rl_point	int
==	O
end	int
&&	O
quote_char	char
==	O
'\0'	O
)	O
{	O
while	O
(	O
rl_point	int
=	O
MB_PREVCHAR	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_ANY	int
)	O
)	O
{	O
scan	int
=	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
;	O
if	O
(	O
strchr	function
(	O
brkchars	pointer
,	O
scan	int
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
rl_char_is_quoted_p	pointer
&&	O
found_quote	int
&&	O
(	O
*	O
rl_char_is_quoted_p	pointer
)	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
)	O
)	O
continue	O
;	O
break	O
;	O
}	O
}	O
scan	int
=	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
;	O
if	O
(	O
scan	int
)	O
{	O
if	O
(	O
rl_char_is_quoted_p	pointer
)	O
isbrk	int
=	O
(	O
found_quote	int
==	O
0	int
||	O
(	O
*	O
rl_char_is_quoted_p	pointer
)	O
(	O
rl_line_buffer	pointer
,	O
rl_point	int
)	O
==	O
0	int
)	O
&&	O
strchr	function
(	O
brkchars	pointer
,	O
scan	int
)	O
!=	O
0	int
;	O
else	O
isbrk	int
=	O
strchr	function
(	O
brkchars	pointer
,	O
scan	int
)	O
!=	O
0	int
;	O
if	O
(	O
isbrk	int
)	O
{	O
if	O
(	O
rl_basic_quote_characters	pointer
&&	O
strchr	function
(	O
rl_basic_quote_characters	pointer
,	O
scan	int
)	O
&&	O
(	O
end	int
-	O
rl_point	int
)	O
>	O
1	int
)	O
delimiter	int
=	O
scan	int
;	O
if	O
(	O
rl_special_prefixes	pointer
==	O
0	int
||	O
strchr	function
(	O
rl_special_prefixes	pointer
,	O
scan	int
)	O
==	O
0	int
)	O
rl_point	int
++	O
;	O
}	O
}	O
if	O
(	O
fp	pointer
)	O
*	O
fp	pointer
=	O
found_quote	int
;	O
if	O
(	O
dp	pointer
)	O
*	O
dp	pointer
=	O
delimiter	int
;	O
return	O
(	O
quote_char	char
)	O
;	O
}	O
static	O
char	O
*	O
*	O
gen_completion_matches	function
(	O
text	pointer
,	O
start	int
,	O
end	int
,	O
our_func	pointer
,	O
found_quote	int
,	O
quote_char	char
)	O
char	O
*	O
text	pointer
;	O
int	O
start	int
,	O
end	int
;	O
rl_compentry_func_t	function
*	O
our_func	pointer
;	O
int	O
found_quote	int
,	O
quote_char	char
;	O
{	O
char	O
*	O
*	O
matches	pointer
;	O
rl_completion_found_quote	int
=	O
found_quote	int
;	O
rl_completion_quote_character	int
=	O
quote_char	char
;	O
if	O
(	O
rl_attempted_completion_function	pointer
)	O
{	O
matches	pointer
=	O
(	O
*	O
rl_attempted_completion_function	pointer
)	O
(	O
text	pointer
,	O
start	int
,	O
end	int
)	O
;	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
)	O
{	O
_rl_free_match_list	function
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
0	int
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
if	O
(	O
matches	pointer
||	O
rl_attempted_completion_over	int
)	O
{	O
rl_attempted_completion_over	int
=	O
0	int
;	O
return	O
(	O
matches	pointer
)	O
;	O
}	O
}	O
matches	pointer
=	O
rl_completion_matches	function
(	O
text	pointer
,	O
our_func	pointer
)	O
;	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
)	O
{	O
_rl_free_match_list	function
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
0	int
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
return	O
matches	pointer
;	O
}	O
static	O
char	O
*	O
*	O
remove_duplicate_matches	function
(	O
matches	pointer
)	O
char	O
*	O
*	O
matches	pointer
;	O
{	O
char	O
*	O
lowest_common	pointer
;	O
int	O
i	int
,	O
j	int
,	O
newlen	int
;	O
char	O
dead_slot	char
;	O
char	O
*	O
*	O
temp_array	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
matches	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
&&	O
rl_sort_completion_matches	int
)	O
qsort	function
(	O
matches	pointer
+	O
1	int
,	O
i	int
-	O
1	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
(	O
QSFUNC	function
*	O
)	O
_rl_qsort_string_compare	function
)	O
;	O
lowest_common	pointer
=	O
savestring	O
(	O
matches	pointer
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
newlen	int
=	O
0	int
;	O
matches	pointer
[	O
i	int
+	O
1	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
matches	pointer
[	O
i	int
]	O
,	O
matches	pointer
[	O
i	int
+	O
1	int
]	O
)	O
==	O
0	int
)	O
{	O
xfree	function
(	O
matches	pointer
[	O
i	int
]	O
)	O
;	O
matches	pointer
[	O
i	int
]	O
=	O
(	O
char	O
*	O
)	O
&	O
dead_slot	char
;	O
}	O
else	O
newlen	int
++	O
;	O
}	O
temp_array	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
(	O
3	int
+	O
newlen	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
j	int
=	O
1	int
;	O
matches	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
matches	pointer
[	O
i	int
]	O
!=	O
(	O
char	O
*	O
)	O
&	O
dead_slot	char
)	O
temp_array	pointer
[	O
j	int
++	O
]	O
=	O
matches	pointer
[	O
i	int
]	O
;	O
}	O
temp_array	pointer
[	O
j	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
matches	pointer
[	O
0	int
]	O
!=	O
(	O
char	O
*	O
)	O
&	O
dead_slot	char
)	O
xfree	function
(	O
matches	pointer
[	O
0	int
]	O
)	O
;	O
temp_array	pointer
[	O
0	int
]	O
=	O
lowest_common	pointer
;	O
if	O
(	O
j	int
==	O
2	int
&&	O
strcmp	function
(	O
temp_array	pointer
[	O
0	int
]	O
,	O
temp_array	pointer
[	O
1	int
]	O
)	O
==	O
0	int
)	O
{	O
xfree	function
(	O
temp_array	pointer
[	O
1	int
]	O
)	O
;	O
temp_array	pointer
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
return	O
(	O
temp_array	pointer
)	O
;	O
}	O
static	O
int	O
compute_lcd_of_matches	function
(	O
match_list	pointer
,	O
matches	pointer
,	O
text	pointer
)	O
char	O
*	O
*	O
match_list	pointer
;	O
int	O
matches	pointer
;	O
const	O
char	O
*	O
text	pointer
;	O
{	O
register	O
int	O
i	int
,	O
c1	int
,	O
c2	int
,	O
si	int
;	O
int	O
low	int
;	O
int	O
lx	int
;	O
char	O
*	O
dtext	pointer
;	O
int	O
v	int
;	O
size_t	long
v1	long
,	O
v2	long
;	O
mbstate_t	struct
ps1	struct
,	O
ps2	struct
;	O
wchar_t	int
wc1	int
,	O
wc2	int
;	O
if	O
(	O
matches	pointer
==	O
1	int
)	O
{	O
match_list	pointer
[	O
0	int
]	O
=	O
match_list	pointer
[	O
1	int
]	O
;	O
match_list	pointer
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
,	O
low	int
=	O
100000	int
;	O
i	int
<	O
matches	pointer
;	O
i	int
++	O
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
memset	function
(	O
&	O
ps1	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
memset	function
(	O
&	O
ps2	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
}	O
if	O
(	O
_rl_completion_case_fold	int
)	O
{	O
for	O
(	O
si	int
=	O
0	int
;	O
(	O
c1	int
=	O
_rl_to_lower	function
(	O
match_list	pointer
[	O
i	int
]	O
[	O
si	int
]	O
)	O
)	O
&&	O
(	O
c2	int
=	O
_rl_to_lower	function
(	O
match_list	pointer
[	O
i	int
+	O
1	int
]	O
[	O
si	int
]	O
)	O
)	O
;	O
si	int
++	O
)	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
v1	long
=	O
mbrtowc	function
(	O
&	O
wc1	int
,	O
match_list	pointer
[	O
i	int
]	O
+	O
si	int
,	O
strlen	function
(	O
match_list	pointer
[	O
i	int
]	O
+	O
si	int
)	O
,	O
&	O
ps1	struct
)	O
;	O
v2	long
=	O
mbrtowc	function
(	O
&	O
wc2	int
,	O
match_list	pointer
[	O
i	int
+	O
1	int
]	O
+	O
si	int
,	O
strlen	function
(	O
match_list	pointer
[	O
i	int
+	O
1	int
]	O
+	O
si	int
)	O
,	O
&	O
ps2	struct
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
v1	long
)	O
||	O
MB_INVALIDCH	O
(	O
v2	long
)	O
)	O
{	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
continue	O
;	O
}	O
wc1	int
=	O
towlower	function
(	O
wc1	int
)	O
;	O
wc2	int
=	O
towlower	function
(	O
wc2	int
)	O
;	O
if	O
(	O
wc1	int
!=	O
wc2	int
)	O
break	O
;	O
else	O
if	O
(	O
v1	long
>	O
1	int
)	O
si	int
+=	O
v1	long
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
}	O
else	O
{	O
for	O
(	O
si	int
=	O
0	int
;	O
(	O
c1	int
=	O
match_list	pointer
[	O
i	int
]	O
[	O
si	int
]	O
)	O
&&	O
(	O
c2	int
=	O
match_list	pointer
[	O
i	int
+	O
1	int
]	O
[	O
si	int
]	O
)	O
;	O
si	int
++	O
)	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
mbstate_t	struct
ps_back	struct
;	O
ps_back	struct
=	O
ps1	struct
;	O
if	O
(	O
!	O
_rl_compare_chars	function
(	O
match_list	pointer
[	O
i	int
]	O
,	O
si	int
,	O
&	O
ps1	struct
,	O
match_list	pointer
[	O
i	int
+	O
1	int
]	O
,	O
si	int
,	O
&	O
ps2	struct
)	O
)	O
break	O
;	O
else	O
if	O
(	O
(	O
v	int
=	O
_rl_get_char_len	function
(	O
&	O
match_list	pointer
[	O
i	int
]	O
[	O
si	int
]	O
,	O
&	O
ps_back	struct
)	O
)	O
>	O
1	int
)	O
si	int
+=	O
v	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
}	O
if	O
(	O
low	int
>	O
si	int
)	O
low	int
=	O
si	int
;	O
}	O
if	O
(	O
low	int
==	O
0	int
&&	O
text	pointer
&&	O
*	O
text	pointer
)	O
{	O
match_list	pointer
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
text	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
match_list	pointer
[	O
0	int
]	O
,	O
text	pointer
)	O
;	O
}	O
else	O
{	O
match_list	pointer
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
low	int
+	O
1	int
)	O
;	O
if	O
(	O
_rl_completion_case_fold	int
)	O
{	O
dtext	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
rl_filename_completion_desired	int
&&	O
rl_filename_dequoting_function	pointer
&&	O
rl_completion_found_quote	int
&&	O
rl_filename_quoting_desired	int
)	O
{	O
dtext	pointer
=	O
(	O
*	O
rl_filename_dequoting_function	pointer
)	O
(	O
(	O
char	O
*	O
)	O
text	pointer
,	O
rl_completion_quote_character	int
)	O
;	O
text	pointer
=	O
dtext	pointer
;	O
}	O
qsort	function
(	O
match_list	pointer
+	O
1	int
,	O
matches	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
(	O
QSFUNC	function
*	O
)	O
_rl_qsort_string_compare	function
)	O
;	O
si	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
lx	int
=	O
(	O
si	int
<=	O
low	int
)	O
?	O
si	int
:	O
low	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
matches	pointer
;	O
i	int
++	O
)	O
if	O
(	O
strncmp	function
(	O
match_list	pointer
[	O
i	int
]	O
,	O
text	pointer
,	O
lx	int
)	O
==	O
0	int
)	O
{	O
strncpy	function
(	O
match_list	pointer
[	O
0	int
]	O
,	O
match_list	pointer
[	O
i	int
]	O
,	O
low	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
i	int
>	O
matches	pointer
)	O
strncpy	function
(	O
match_list	pointer
[	O
0	int
]	O
,	O
match_list	pointer
[	O
1	int
]	O
,	O
low	int
)	O
;	O
FREE	O
(	O
dtext	pointer
)	O
;	O
}	O
else	O
strncpy	function
(	O
match_list	pointer
[	O
0	int
]	O
,	O
match_list	pointer
[	O
1	int
]	O
,	O
low	int
)	O
;	O
match_list	pointer
[	O
0	int
]	O
[	O
low	int
]	O
=	O
'\0'	O
;	O
}	O
return	O
matches	pointer
;	O
}	O
static	O
int	O
postprocess_matches	function
(	O
matchesp	pointer
,	O
matching_filenames	int
)	O
char	O
*	O
*	O
*	O
matchesp	pointer
;	O
int	O
matching_filenames	int
;	O
{	O
char	O
*	O
t	pointer
,	O
*	O
*	O
matches	pointer
,	O
*	O
*	O
temp_matches	pointer
;	O
int	O
nmatch	int
,	O
i	int
;	O
matches	pointer
=	O
*	O
matchesp	pointer
;	O
if	O
(	O
matches	pointer
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
rl_ignore_completion_duplicates	int
)	O
{	O
temp_matches	pointer
=	O
remove_duplicate_matches	function
(	O
matches	pointer
)	O
;	O
xfree	function
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
temp_matches	pointer
;	O
}	O
if	O
(	O
rl_ignore_some_completions_function	pointer
&&	O
matching_filenames	int
)	O
{	O
for	O
(	O
nmatch	int
=	O
1	int
;	O
matches	pointer
[	O
nmatch	int
]	O
;	O
nmatch	int
++	O
)	O
;	O
(	O
void	O
)	O
(	O
*	O
rl_ignore_some_completions_function	pointer
)	O
(	O
matches	pointer
)	O
;	O
if	O
(	O
matches	pointer
==	O
0	int
||	O
matches	pointer
[	O
0	int
]	O
==	O
0	int
)	O
{	O
FREE	O
(	O
matches	pointer
)	O
;	O
*	O
matchesp	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
matches	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
>	O
1	int
&&	O
i	int
<	O
nmatch	int
)	O
{	O
t	pointer
=	O
matches	pointer
[	O
0	int
]	O
;	O
compute_lcd_of_matches	function
(	O
matches	pointer
,	O
i	int
-	O
1	int
,	O
t	pointer
)	O
;	O
FREE	O
(	O
t	pointer
)	O
;	O
}	O
}	O
}	O
*	O
matchesp	pointer
=	O
matches	pointer
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
complete_get_screenwidth	function
(	O
)	O
{	O
int	O
cols	int
;	O
char	O
*	O
envcols	pointer
;	O
cols	int
=	O
_rl_completion_columns	int
;	O
if	O
(	O
cols	int
>=	O
0	int
&&	O
cols	int
<=	O
_rl_screenwidth	int
)	O
return	O
cols	int
;	O
envcols	pointer
=	O
getenv	function
(	O
"COLUMNS"	pointer
)	O
;	O
if	O
(	O
envcols	pointer
&&	O
*	O
envcols	pointer
)	O
cols	int
=	O
atoi	function
(	O
envcols	pointer
)	O
;	O
if	O
(	O
cols	int
>=	O
0	int
&&	O
cols	int
<=	O
_rl_screenwidth	int
)	O
return	O
cols	int
;	O
return	O
_rl_screenwidth	int
;	O
}	O
void	O
rl_display_match_list	function
(	O
matches	pointer
,	O
len	long
,	O
max	int
)	O
char	O
*	O
*	O
matches	pointer
;	O
int	O
len	long
,	O
max	int
;	O
{	O
int	O
count	int
,	O
limit	int
,	O
printed_len	int
,	O
lines	pointer
,	O
cols	int
;	O
int	O
i	int
,	O
j	int
,	O
k	int
,	O
l	int
,	O
common_length	int
,	O
sind	int
;	O
char	O
*	O
temp	pointer
,	O
*	O
t	pointer
;	O
common_length	int
=	O
sind	int
=	O
0	int
;	O
if	O
(	O
_rl_completion_prefix_display_length	int
>	O
0	int
)	O
{	O
t	pointer
=	O
printable_part	function
(	O
matches	pointer
[	O
0	int
]	O
)	O
;	O
temp	pointer
=	O
rl_filename_completion_desired	int
?	O
strrchr	function
(	O
t	pointer
,	O
'/'	O
)	O
:	O
0	int
;	O
common_length	int
=	O
temp	pointer
?	O
fnwidth	function
(	O
temp	pointer
)	O
:	O
fnwidth	function
(	O
t	pointer
)	O
;	O
sind	int
=	O
temp	pointer
?	O
strlen	function
(	O
temp	pointer
)	O
:	O
strlen	function
(	O
t	pointer
)	O
;	O
if	O
(	O
common_length	int
>	O
max	int
||	O
sind	int
>	O
max	int
)	O
common_length	int
=	O
sind	int
=	O
0	int
;	O
if	O
(	O
common_length	int
>	O
_rl_completion_prefix_display_length	int
&&	O
common_length	int
>	O
ELLIPSIS_LEN	int
)	O
max	int
-=	O
common_length	int
-	O
ELLIPSIS_LEN	int
;	O
else	O
common_length	int
=	O
sind	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
_rl_colored_completion_prefix	int
>	O
0	int
)	O
{	O
t	pointer
=	O
printable_part	function
(	O
matches	pointer
[	O
0	int
]	O
)	O
;	O
temp	pointer
=	O
rl_filename_completion_desired	int
?	O
strrchr	function
(	O
t	pointer
,	O
'/'	O
)	O
:	O
0	int
;	O
common_length	int
=	O
temp	pointer
?	O
fnwidth	function
(	O
temp	pointer
)	O
:	O
fnwidth	function
(	O
t	pointer
)	O
;	O
sind	int
=	O
temp	pointer
?	O
RL_STRLEN	O
(	O
temp	pointer
+	O
1	int
)	O
:	O
RL_STRLEN	O
(	O
t	pointer
)	O
;	O
if	O
(	O
common_length	int
>	O
max	int
||	O
sind	int
>	O
max	int
)	O
common_length	int
=	O
sind	int
=	O
0	int
;	O
}	O
cols	int
=	O
complete_get_screenwidth	function
(	O
)	O
;	O
max	int
+=	O
2	int
;	O
limit	int
=	O
cols	int
/	O
max	int
;	O
if	O
(	O
limit	int
!=	O
1	int
&&	O
(	O
limit	int
*	O
max	int
==	O
cols	int
)	O
)	O
limit	int
--	O
;	O
if	O
(	O
cols	int
<	O
_rl_screenwidth	int
&&	O
limit	int
<	O
0	int
)	O
limit	int
=	O
1	int
;	O
if	O
(	O
limit	int
==	O
0	int
)	O
limit	int
=	O
1	int
;	O
count	int
=	O
(	O
len	long
+	O
(	O
limit	int
-	O
1	int
)	O
)	O
/	O
limit	int
;	O
if	O
(	O
rl_ignore_completion_duplicates	int
==	O
0	int
&&	O
rl_sort_completion_matches	int
)	O
qsort	function
(	O
matches	pointer
+	O
1	int
,	O
len	long
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
(	O
QSFUNC	function
*	O
)	O
_rl_qsort_string_compare	function
)	O
;	O
rl_crlf	function
(	O
)	O
;	O
lines	pointer
=	O
0	int
;	O
if	O
(	O
_rl_print_completions_horizontally	int
==	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
count	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
,	O
l	int
=	O
i	int
;	O
j	int
<	O
limit	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
l	int
>	O
len	long
||	O
matches	pointer
[	O
l	int
]	O
==	O
0	int
)	O
break	O
;	O
else	O
{	O
temp	pointer
=	O
printable_part	function
(	O
matches	pointer
[	O
l	int
]	O
)	O
;	O
printed_len	int
=	O
print_filename	function
(	O
temp	pointer
,	O
matches	pointer
[	O
l	int
]	O
,	O
sind	int
)	O
;	O
if	O
(	O
j	int
+	O
1	int
<	O
limit	int
)	O
{	O
if	O
(	O
max	int
<=	O
printed_len	int
)	O
putc	function
(	O
' '	O
,	O
rl_outstream	pointer
)	O
;	O
else	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max	int
-	O
printed_len	int
;	O
k	int
++	O
)	O
putc	function
(	O
' '	O
,	O
rl_outstream	pointer
)	O
;	O
}	O
}	O
l	int
+=	O
count	int
;	O
}	O
rl_crlf	function
(	O
)	O
;	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
&&	O
RL_SIGWINCH_RECEIVED	O
(	O
)	O
==	O
0	int
)	O
return	O
;	O
lines	pointer
++	O
;	O
if	O
(	O
_rl_page_completions	int
&&	O
lines	pointer
>=	O
(	O
_rl_screenheight	int
-	O
1	int
)	O
&&	O
i	int
<	O
count	int
)	O
{	O
lines	pointer
=	O
_rl_internal_pager	function
(	O
lines	pointer
)	O
;	O
if	O
(	O
lines	pointer
<	O
0	int
)	O
return	O
;	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
matches	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
temp	pointer
=	O
printable_part	function
(	O
matches	pointer
[	O
i	int
]	O
)	O
;	O
printed_len	int
=	O
print_filename	function
(	O
temp	pointer
,	O
matches	pointer
[	O
i	int
]	O
,	O
sind	int
)	O
;	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
&&	O
RL_SIGWINCH_RECEIVED	O
(	O
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
matches	pointer
[	O
i	int
+	O
1	int
]	O
)	O
{	O
if	O
(	O
limit	int
==	O
1	int
||	O
(	O
i	int
&&	O
(	O
limit	int
>	O
1	int
)	O
&&	O
(	O
i	int
%	O
limit	int
)	O
==	O
0	int
)	O
)	O
{	O
rl_crlf	function
(	O
)	O
;	O
lines	pointer
++	O
;	O
if	O
(	O
_rl_page_completions	int
&&	O
lines	pointer
>=	O
_rl_screenheight	int
-	O
1	int
)	O
{	O
lines	pointer
=	O
_rl_internal_pager	function
(	O
lines	pointer
)	O
;	O
if	O
(	O
lines	pointer
<	O
0	int
)	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
max	int
<=	O
printed_len	int
)	O
putc	function
(	O
' '	O
,	O
rl_outstream	pointer
)	O
;	O
else	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max	int
-	O
printed_len	int
;	O
k	int
++	O
)	O
putc	function
(	O
' '	O
,	O
rl_outstream	pointer
)	O
;	O
}	O
}	O
rl_crlf	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
display_matches	function
(	O
matches	pointer
)	O
char	O
*	O
*	O
matches	pointer
;	O
{	O
int	O
len	long
,	O
max	int
,	O
i	int
;	O
char	O
*	O
temp	pointer
;	O
_rl_move_vert	function
(	O
_rl_vis_botlin	int
)	O
;	O
if	O
(	O
matches	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
temp	pointer
=	O
printable_part	function
(	O
matches	pointer
[	O
0	int
]	O
)	O
;	O
rl_crlf	function
(	O
)	O
;	O
print_filename	function
(	O
temp	pointer
,	O
matches	pointer
[	O
0	int
]	O
,	O
0	int
)	O
;	O
rl_crlf	function
(	O
)	O
;	O
rl_forced_update_display	function
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
;	O
}	O
for	O
(	O
max	int
=	O
0	int
,	O
i	int
=	O
1	int
;	O
matches	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
temp	pointer
=	O
printable_part	function
(	O
matches	pointer
[	O
i	int
]	O
)	O
;	O
len	long
=	O
fnwidth	function
(	O
temp	pointer
)	O
;	O
if	O
(	O
len	long
>	O
max	int
)	O
max	int
=	O
len	long
;	O
}	O
len	long
=	O
i	int
-	O
1	int
;	O
if	O
(	O
rl_completion_display_matches_hook	pointer
)	O
{	O
(	O
*	O
rl_completion_display_matches_hook	pointer
)	O
(	O
matches	pointer
,	O
len	long
,	O
max	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
rl_completion_query_items	int
>	O
0	int
&&	O
len	long
>=	O
rl_completion_query_items	int
)	O
{	O
rl_crlf	function
(	O
)	O
;	O
fprintf	function
(	O
rl_outstream	pointer
,	O
"Display all %d possibilities? (y or n)"	pointer
,	O
len	long
)	O
;	O
fflush	function
(	O
rl_outstream	pointer
)	O
;	O
if	O
(	O
(	O
completion_y_or_n	int
=	O
get_y_or_n	function
(	O
0	int
)	O
)	O
==	O
0	int
)	O
{	O
rl_crlf	function
(	O
)	O
;	O
rl_forced_update_display	function
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
return	O
;	O
}	O
}	O
rl_display_match_list	function
(	O
matches	pointer
,	O
len	long
,	O
max	int
)	O
;	O
rl_forced_update_display	function
(	O
)	O
;	O
rl_display_fixed	int
=	O
1	int
;	O
}	O
static	O
char	O
*	O
make_quoted_replacement	function
(	O
match	pointer
,	O
mtype	int
,	O
qc	pointer
)	O
char	O
*	O
match	pointer
;	O
int	O
mtype	int
;	O
char	O
*	O
qc	pointer
;	O
{	O
int	O
should_quote	int
,	O
do_replace	int
;	O
char	O
*	O
replacement	pointer
;	O
replacement	pointer
=	O
match	pointer
;	O
should_quote	int
=	O
match	pointer
&&	O
rl_completer_quote_characters	pointer
&&	O
rl_filename_completion_desired	int
&&	O
rl_filename_quoting_desired	int
;	O
if	O
(	O
should_quote	int
)	O
should_quote	int
=	O
should_quote	int
&&	O
(	O
!	O
qc	pointer
||	O
!	O
*	O
qc	pointer
||	O
(	O
rl_completer_quote_characters	pointer
&&	O
strchr	function
(	O
rl_completer_quote_characters	pointer
,	O
*	O
qc	pointer
)	O
)	O
)	O
;	O
if	O
(	O
should_quote	int
)	O
{	O
should_quote	int
=	O
rl_filename_quote_characters	pointer
?	O
(	O
_rl_strpbrk	O
(	O
match	pointer
,	O
rl_filename_quote_characters	pointer
)	O
!=	O
0	int
)	O
:	O
0	int
;	O
do_replace	int
=	O
should_quote	int
?	O
mtype	int
:	O
NO_MATCH	int
;	O
if	O
(	O
do_replace	int
!=	O
NO_MATCH	int
&&	O
rl_filename_quoting_function	pointer
)	O
replacement	pointer
=	O
(	O
*	O
rl_filename_quoting_function	pointer
)	O
(	O
match	pointer
,	O
do_replace	int
,	O
qc	pointer
)	O
;	O
}	O
return	O
(	O
replacement	pointer
)	O
;	O
}	O
static	O
void	O
insert_match	function
(	O
match	pointer
,	O
start	int
,	O
mtype	int
,	O
qc	pointer
)	O
char	O
*	O
match	pointer
;	O
int	O
start	int
,	O
mtype	int
;	O
char	O
*	O
qc	pointer
;	O
{	O
char	O
*	O
replacement	pointer
,	O
*	O
r	int
;	O
char	O
oqc	char
;	O
int	O
end	int
,	O
rlen	int
;	O
oqc	char
=	O
qc	pointer
?	O
*	O
qc	pointer
:	O
'\0'	O
;	O
replacement	pointer
=	O
make_quoted_replacement	function
(	O
match	pointer
,	O
mtype	int
,	O
qc	pointer
)	O
;	O
if	O
(	O
replacement	pointer
)	O
{	O
rlen	int
=	O
strlen	function
(	O
replacement	pointer
)	O
;	O
if	O
(	O
qc	pointer
&&	O
*	O
qc	pointer
&&	O
start	int
&&	O
rl_line_buffer	pointer
[	O
start	int
-	O
1	int
]	O
==	O
*	O
qc	pointer
&&	O
replacement	pointer
[	O
0	int
]	O
==	O
*	O
qc	pointer
)	O
start	int
--	O
;	O
else	O
if	O
(	O
qc	pointer
&&	O
(	O
*	O
qc	pointer
!=	O
oqc	char
)	O
&&	O
start	int
&&	O
rl_line_buffer	pointer
[	O
start	int
-	O
1	int
]	O
==	O
oqc	char
&&	O
replacement	pointer
[	O
0	int
]	O
!=	O
oqc	char
)	O
start	int
--	O
;	O
end	int
=	O
rl_point	int
-	O
1	int
;	O
if	O
(	O
qc	pointer
&&	O
*	O
qc	pointer
&&	O
end	int
&&	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
==	O
*	O
qc	pointer
&&	O
replacement	pointer
[	O
rlen	int
-	O
1	int
]	O
==	O
*	O
qc	pointer
)	O
end	int
++	O
;	O
if	O
(	O
_rl_skip_completed_text	int
)	O
{	O
r	int
=	O
replacement	pointer
;	O
while	O
(	O
start	int
<	O
rl_end	int
&&	O
*	O
r	int
&&	O
rl_line_buffer	pointer
[	O
start	int
]	O
==	O
*	O
r	int
)	O
{	O
start	int
++	O
;	O
r	int
++	O
;	O
}	O
if	O
(	O
start	int
<=	O
end	int
||	O
*	O
r	int
)	O
_rl_replace_text	function
(	O
r	int
,	O
start	int
,	O
end	int
)	O
;	O
rl_point	int
=	O
start	int
+	O
strlen	function
(	O
r	int
)	O
;	O
}	O
else	O
_rl_replace_text	function
(	O
replacement	pointer
,	O
start	int
,	O
end	int
)	O
;	O
if	O
(	O
replacement	pointer
!=	O
match	pointer
)	O
xfree	function
(	O
replacement	pointer
)	O
;	O
}	O
}	O
static	O
int	O
append_to_match	function
(	O
text	pointer
,	O
delimiter	int
,	O
quote_char	char
,	O
nontrivial_match	int
)	O
char	O
*	O
text	pointer
;	O
int	O
delimiter	int
,	O
quote_char	char
,	O
nontrivial_match	int
;	O
{	O
char	O
temp_string	array
[	O
4	int
]	O
,	O
*	O
filename	pointer
,	O
*	O
fn	pointer
;	O
int	O
temp_string_index	int
,	O
s	pointer
;	O
struct	O
stat	struct
finfo	struct
;	O
temp_string_index	int
=	O
0	int
;	O
if	O
(	O
quote_char	char
&&	O
rl_point	int
&&	O
rl_completion_suppress_quote	int
==	O
0	int
&&	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
!=	O
quote_char	char
)	O
temp_string	array
[	O
temp_string_index	int
++	O
]	O
=	O
quote_char	char
;	O
if	O
(	O
delimiter	int
)	O
temp_string	array
[	O
temp_string_index	int
++	O
]	O
=	O
delimiter	int
;	O
else	O
if	O
(	O
rl_completion_suppress_append	int
==	O
0	int
&&	O
rl_completion_append_character	int
)	O
temp_string	array
[	O
temp_string_index	int
++	O
]	O
=	O
rl_completion_append_character	int
;	O
temp_string	array
[	O
temp_string_index	int
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
rl_filename_completion_desired	int
)	O
{	O
filename	pointer
=	O
tilde_expand	function
(	O
text	pointer
)	O
;	O
if	O
(	O
rl_filename_stat_hook	pointer
)	O
{	O
fn	pointer
=	O
savestring	O
(	O
filename	pointer
)	O
;	O
(	O
*	O
rl_filename_stat_hook	pointer
)	O
(	O
&	O
fn	pointer
)	O
;	O
xfree	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
fn	pointer
;	O
}	O
s	pointer
=	O
(	O
nontrivial_match	int
&&	O
rl_completion_mark_symlink_dirs	int
==	O
0	int
)	O
?	O
LSTAT	O
(	O
filename	pointer
,	O
&	O
finfo	struct
)	O
:	O
stat	struct
(	O
filename	pointer
,	O
&	O
finfo	struct
)	O
;	O
if	O
(	O
s	pointer
==	O
0	int
&&	O
S_ISDIR	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
_rl_complete_mark_directories	int
)	O
{	O
if	O
(	O
rl_point	int
&&	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
==	O
'\0'	O
&&	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
==	O
'/'	O
)	O
;	O
else	O
if	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
!=	O
'/'	O
)	O
rl_insert_text	function
(	O
"/"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
s	pointer
==	O
0	int
&&	O
S_ISLNK	O
(	O
finfo	struct
.	O
st_mode	int
)	O
&&	O
path_isdir	function
(	O
filename	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
temp_string_index	int
)	O
rl_insert_text	function
(	O
temp_string	array
)	O
;	O
}	O
xfree	function
(	O
filename	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
temp_string_index	int
)	O
rl_insert_text	function
(	O
temp_string	array
)	O
;	O
}	O
return	O
(	O
temp_string_index	int
)	O
;	O
}	O
static	O
void	O
insert_all_matches	function
(	O
matches	pointer
,	O
point	int
,	O
qc	pointer
)	O
char	O
*	O
*	O
matches	pointer
;	O
int	O
point	int
;	O
char	O
*	O
qc	pointer
;	O
{	O
int	O
i	int
;	O
char	O
*	O
rp	pointer
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
if	O
(	O
qc	pointer
&&	O
*	O
qc	pointer
&&	O
point	int
&&	O
rl_line_buffer	pointer
[	O
point	int
-	O
1	int
]	O
==	O
*	O
qc	pointer
)	O
point	int
--	O
;	O
rl_delete_text	function
(	O
point	int
,	O
rl_point	int
)	O
;	O
rl_point	int
=	O
point	int
;	O
if	O
(	O
matches	pointer
[	O
1	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
matches	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
rp	pointer
=	O
make_quoted_replacement	function
(	O
matches	pointer
[	O
i	int
]	O
,	O
SINGLE_MATCH	int
,	O
qc	pointer
)	O
;	O
rl_insert_text	function
(	O
rp	pointer
)	O
;	O
rl_insert_text	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
rp	pointer
!=	O
matches	pointer
[	O
i	int
]	O
)	O
xfree	function
(	O
rp	pointer
)	O
;	O
}	O
}	O
else	O
{	O
rp	pointer
=	O
make_quoted_replacement	function
(	O
matches	pointer
[	O
0	int
]	O
,	O
SINGLE_MATCH	int
,	O
qc	pointer
)	O
;	O
rl_insert_text	function
(	O
rp	pointer
)	O
;	O
rl_insert_text	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
rp	pointer
!=	O
matches	pointer
[	O
0	int
]	O
)	O
xfree	function
(	O
rp	pointer
)	O
;	O
}	O
rl_end_undo_group	function
(	O
)	O
;	O
}	O
void	O
_rl_free_match_list	function
(	O
matches	pointer
)	O
char	O
*	O
*	O
matches	pointer
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
matches	pointer
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
matches	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
xfree	function
(	O
matches	pointer
[	O
i	int
]	O
)	O
;	O
xfree	function
(	O
matches	pointer
)	O
;	O
}	O
int	O
rl_complete_internal	function
(	O
what_to_do	int
)	O
int	O
what_to_do	int
;	O
{	O
char	O
*	O
*	O
matches	pointer
;	O
rl_compentry_func_t	function
*	O
our_func	pointer
;	O
int	O
start	int
,	O
end	int
,	O
delimiter	int
,	O
found_quote	int
,	O
i	int
,	O
nontrivial_lcd	int
;	O
char	O
*	O
text	pointer
,	O
*	O
saved_line_buffer	pointer
;	O
char	O
quote_char	char
;	O
int	O
tlen	long
,	O
mlen	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
set_completion_defaults	function
(	O
what_to_do	int
)	O
;	O
saved_line_buffer	pointer
=	O
rl_line_buffer	pointer
?	O
savestring	O
(	O
rl_line_buffer	pointer
)	O
:	O
(	O
char	O
*	O
)	O
NULL	O
;	O
our_func	pointer
=	O
rl_completion_entry_function	pointer
?	O
rl_completion_entry_function	pointer
:	O
rl_filename_completion_function	function
;	O
end	int
=	O
rl_point	int
;	O
found_quote	int
=	O
delimiter	int
=	O
0	int
;	O
quote_char	char
=	O
'\0'	O
;	O
if	O
(	O
rl_point	int
)	O
quote_char	char
=	O
_rl_find_completion_word	function
(	O
&	O
found_quote	int
,	O
&	O
delimiter	int
)	O
;	O
start	int
=	O
rl_point	int
;	O
rl_point	int
=	O
end	int
;	O
text	pointer
=	O
rl_copy_text	function
(	O
start	int
,	O
end	int
)	O
;	O
matches	pointer
=	O
gen_completion_matches	function
(	O
text	pointer
,	O
start	int
,	O
end	int
,	O
our_func	pointer
,	O
found_quote	int
,	O
quote_char	char
)	O
;	O
nontrivial_lcd	int
=	O
matches	pointer
&&	O
strcmp	function
(	O
text	pointer
,	O
matches	pointer
[	O
0	int
]	O
)	O
!=	O
0	int
;	O
if	O
(	O
what_to_do	int
==	O
'!'	O
||	O
what_to_do	int
==	O
'@'	O
)	O
tlen	long
=	O
strlen	function
(	O
text	pointer
)	O
;	O
xfree	function
(	O
text	pointer
)	O
;	O
if	O
(	O
matches	pointer
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
saved_line_buffer	pointer
)	O
;	O
completion_changed_buffer	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
_rl_reset_completion_state	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
i	int
=	O
rl_filename_completion_desired	int
;	O
if	O
(	O
postprocess_matches	function
(	O
&	O
matches	pointer
,	O
i	int
)	O
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
saved_line_buffer	pointer
)	O
;	O
completion_changed_buffer	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
_rl_reset_completion_state	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
switch	O
(	O
what_to_do	int
)	O
{	O
case	O
TAB	char
:	O
case	O
'!'	O
:	O
case	O
'@'	O
:	O
if	O
(	O
what_to_do	int
==	O
TAB	char
)	O
{	O
if	O
(	O
*	O
matches	pointer
[	O
0	int
]	O
)	O
insert_match	function
(	O
matches	pointer
[	O
0	int
]	O
,	O
start	int
,	O
matches	pointer
[	O
1	int
]	O
?	O
MULT_MATCH	int
:	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
}	O
else	O
if	O
(	O
*	O
matches	pointer
[	O
0	int
]	O
&&	O
matches	pointer
[	O
1	int
]	O
==	O
0	int
)	O
insert_match	function
(	O
matches	pointer
[	O
0	int
]	O
,	O
start	int
,	O
matches	pointer
[	O
1	int
]	O
?	O
MULT_MATCH	int
:	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
else	O
if	O
(	O
*	O
matches	pointer
[	O
0	int
]	O
)	O
{	O
mlen	int
=	O
*	O
matches	pointer
[	O
0	int
]	O
?	O
strlen	function
(	O
matches	pointer
[	O
0	int
]	O
)	O
:	O
0	int
;	O
if	O
(	O
mlen	int
>=	O
tlen	long
)	O
insert_match	function
(	O
matches	pointer
[	O
0	int
]	O
,	O
start	int
,	O
matches	pointer
[	O
1	int
]	O
?	O
MULT_MATCH	int
:	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
}	O
if	O
(	O
matches	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
what_to_do	int
==	O
'!'	O
)	O
{	O
display_matches	function
(	O
matches	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
what_to_do	int
==	O
'@'	O
)	O
{	O
if	O
(	O
nontrivial_lcd	int
==	O
0	int
)	O
display_matches	function
(	O
matches	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
rl_editing_mode	int
!=	O
vi_mode	int
)	O
rl_ding	function
(	O
)	O
;	O
}	O
else	O
append_to_match	function
(	O
matches	pointer
[	O
0	int
]	O
,	O
delimiter	int
,	O
quote_char	char
,	O
nontrivial_lcd	int
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
insert_all_matches	function
(	O
matches	pointer
,	O
start	int
,	O
&	O
quote_char	char
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
if	O
(	O
rl_completion_display_matches_hook	pointer
==	O
0	int
)	O
{	O
_rl_sigcleanup	pointer
=	O
_rl_complete_sigcleanup	function
;	O
_rl_sigcleanarg	pointer
=	O
matches	pointer
;	O
_rl_complete_display_matches_interrupt	int
=	O
0	int
;	O
}	O
display_matches	function
(	O
matches	pointer
)	O
;	O
if	O
(	O
_rl_complete_display_matches_interrupt	int
)	O
{	O
matches	pointer
=	O
0	int
;	O
_rl_complete_display_matches_interrupt	int
=	O
0	int
;	O
if	O
(	O
rl_signal_event_hook	pointer
)	O
(	O
*	O
rl_signal_event_hook	pointer
)	O
(	O
)	O
;	O
}	O
_rl_sigcleanup	pointer
=	O
0	int
;	O
_rl_sigcleanarg	pointer
=	O
0	int
;	O
break	O
;	O
default	O
:	O
_rl_ttymsg	function
(	O
"bad value %d for what_to_do in rl_complete"	pointer
,	O
what_to_do	int
)	O
;	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
saved_line_buffer	pointer
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
_rl_free_match_list	function
(	O
matches	pointer
)	O
;	O
_rl_reset_completion_state	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
_rl_free_match_list	function
(	O
matches	pointer
)	O
;	O
if	O
(	O
saved_line_buffer	pointer
)	O
{	O
completion_changed_buffer	int
=	O
strcmp	function
(	O
rl_line_buffer	pointer
,	O
saved_line_buffer	pointer
)	O
!=	O
0	int
;	O
xfree	function
(	O
saved_line_buffer	pointer
)	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
_rl_reset_completion_state	function
(	O
)	O
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
*	O
rl_completion_matches	function
(	O
text	pointer
,	O
entry_function	pointer
)	O
const	O
char	O
*	O
text	pointer
;	O
rl_compentry_func_t	function
*	O
entry_function	pointer
;	O
{	O
register	O
int	O
i	int
;	O
int	O
match_list_size	int
;	O
char	O
*	O
*	O
match_list	pointer
;	O
int	O
matches	pointer
;	O
char	O
*	O
string	pointer
;	O
matches	pointer
=	O
0	int
;	O
match_list_size	int
=	O
10	int
;	O
match_list	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
(	O
match_list_size	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
match_list	pointer
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
while	O
(	O
string	pointer
=	O
(	O
*	O
entry_function	pointer
)	O
(	O
text	pointer
,	O
matches	pointer
)	O
)	O
{	O
if	O
(	O
RL_SIG_RECEIVED	O
(	O
)	O
)	O
{	O
if	O
(	O
entry_function	pointer
==	O
rl_filename_completion_function	function
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
match_list	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
xfree	function
(	O
match_list	pointer
[	O
i	int
]	O
)	O
;	O
}	O
xfree	function
(	O
match_list	pointer
)	O
;	O
match_list	pointer
=	O
0	int
;	O
match_list_size	int
=	O
0	int
;	O
matches	pointer
=	O
0	int
;	O
RL_CHECK_SIGNALS	O
(	O
)	O
;	O
}	O
if	O
(	O
matches	pointer
+	O
1	int
>=	O
match_list_size	int
)	O
match_list	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
match_list	pointer
,	O
(	O
(	O
match_list_size	int
+=	O
10	int
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
match_list	pointer
==	O
0	int
)	O
return	O
(	O
match_list	pointer
)	O
;	O
match_list	pointer
[	O
++	O
matches	pointer
]	O
=	O
string	pointer
;	O
match_list	pointer
[	O
matches	pointer
+	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
matches	pointer
)	O
compute_lcd_of_matches	function
(	O
match_list	pointer
,	O
matches	pointer
,	O
text	pointer
)	O
;	O
else	O
{	O
xfree	function
(	O
match_list	pointer
)	O
;	O
match_list	pointer
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
}	O
return	O
(	O
match_list	pointer
)	O
;	O
}	O
char	O
*	O
rl_username_completion_function	function
(	O
text	pointer
,	O
state	pointer
)	O
const	O
char	O
*	O
text	pointer
;	O
int	O
state	pointer
;	O
{	O
static	O
char	O
*	O
username	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
struct	O
passwd	struct
*	O
entry	pointer
;	O
static	O
int	O
namelen	int
,	O
first_char	int
,	O
first_char_loc	int
;	O
char	O
*	O
value	pointer
;	O
if	O
(	O
state	pointer
==	O
0	int
)	O
{	O
FREE	O
(	O
username	pointer
)	O
;	O
first_char	int
=	O
*	O
text	pointer
;	O
first_char_loc	int
=	O
first_char	int
==	O
'~'	O
;	O
username	pointer
=	O
savestring	O
(	O
&	O
text	pointer
[	O
first_char_loc	int
]	O
)	O
;	O
namelen	int
=	O
strlen	function
(	O
username	pointer
)	O
;	O
setpwent	function
(	O
)	O
;	O
}	O
while	O
(	O
entry	pointer
=	O
getpwent	function
(	O
)	O
)	O
{	O
if	O
(	O
namelen	int
==	O
0	int
||	O
(	O
STREQN	O
(	O
username	pointer
,	O
entry	pointer
->	O
pw_name	pointer
,	O
namelen	int
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
entry	pointer
==	O
0	int
)	O
{	O
endpwent	function
(	O
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
{	O
value	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
2	int
+	O
strlen	function
(	O
entry	pointer
->	O
pw_name	pointer
)	O
)	O
;	O
*	O
value	pointer
=	O
*	O
text	pointer
;	O
strcpy	function
(	O
value	pointer
+	O
first_char_loc	int
,	O
entry	pointer
->	O
pw_name	pointer
)	O
;	O
if	O
(	O
first_char	int
==	O
'~'	O
)	O
rl_filename_completion_desired	int
=	O
1	int
;	O
return	O
(	O
value	pointer
)	O
;	O
}	O
}	O
static	O
int	O
complete_fncmp	function
(	O
convfn	pointer
,	O
convlen	int
,	O
filename	pointer
,	O
filename_len	int
)	O
const	O
char	O
*	O
convfn	pointer
;	O
int	O
convlen	int
;	O
const	O
char	O
*	O
filename	pointer
;	O
int	O
filename_len	int
;	O
{	O
register	O
char	O
*	O
s1	pointer
,	O
*	O
s2	pointer
;	O
int	O
d	int
,	O
len	long
;	O
size_t	long
v1	long
,	O
v2	long
;	O
mbstate_t	struct
ps1	struct
,	O
ps2	struct
;	O
wchar_t	int
wc1	int
,	O
wc2	int
;	O
memset	function
(	O
&	O
ps1	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
memset	function
(	O
&	O
ps2	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
if	O
(	O
filename_len	int
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
convlen	int
<	O
filename_len	int
)	O
return	O
0	int
;	O
len	long
=	O
filename_len	int
;	O
s1	pointer
=	O
(	O
char	O
*	O
)	O
convfn	pointer
;	O
s2	pointer
=	O
(	O
char	O
*	O
)	O
filename	pointer
;	O
if	O
(	O
_rl_completion_case_fold	int
&&	O
_rl_completion_case_map	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
do	O
{	O
v1	long
=	O
mbrtowc	function
(	O
&	O
wc1	int
,	O
s1	pointer
,	O
convlen	int
,	O
&	O
ps1	struct
)	O
;	O
v2	long
=	O
mbrtowc	function
(	O
&	O
wc2	int
,	O
s2	pointer
,	O
filename_len	int
,	O
&	O
ps2	struct
)	O
;	O
if	O
(	O
v1	long
==	O
0	int
&&	O
v2	long
==	O
0	int
)	O
return	O
1	int
;	O
else	O
if	O
(	O
MB_INVALIDCH	O
(	O
v1	long
)	O
||	O
MB_INVALIDCH	O
(	O
v2	long
)	O
)	O
{	O
if	O
(	O
*	O
s1	pointer
!=	O
*	O
s2	pointer
)	O
return	O
0	int
;	O
else	O
if	O
(	O
(	O
*	O
s1	pointer
==	O
'-'	O
||	O
*	O
s1	pointer
==	O
'_'	O
)	O
&&	O
(	O
*	O
s2	pointer
==	O
'-'	O
||	O
*	O
s2	pointer
==	O
'_'	O
)	O
)	O
return	O
0	int
;	O
s1	pointer
++	O
;	O
s2	pointer
++	O
;	O
len	long
--	O
;	O
continue	O
;	O
}	O
wc1	int
=	O
towlower	function
(	O
wc1	int
)	O
;	O
wc2	int
=	O
towlower	function
(	O
wc2	int
)	O
;	O
s1	pointer
+=	O
v1	long
;	O
s2	pointer
+=	O
v1	long
;	O
len	long
-=	O
v1	long
;	O
if	O
(	O
(	O
wc1	int
==	O
L'-'	O
||	O
wc1	int
==	O
L'_'	O
)	O
&&	O
(	O
wc2	int
==	O
L'-'	O
||	O
wc2	int
==	O
L'_'	O
)	O
)	O
continue	O
;	O
if	O
(	O
wc1	int
!=	O
wc2	int
)	O
return	O
0	int
;	O
}	O
while	O
(	O
len	long
!=	O
0	int
)	O
;	O
}	O
else	O
{	O
do	O
{	O
d	int
=	O
_rl_to_lower	function
(	O
*	O
s1	pointer
)	O
-	O
_rl_to_lower	function
(	O
*	O
s2	pointer
)	O
;	O
if	O
(	O
(	O
*	O
s1	pointer
==	O
'-'	O
||	O
*	O
s1	pointer
==	O
'_'	O
)	O
&&	O
(	O
*	O
s2	pointer
==	O
'-'	O
||	O
*	O
s2	pointer
==	O
'_'	O
)	O
)	O
d	int
=	O
0	int
;	O
if	O
(	O
d	int
!=	O
0	int
)	O
return	O
0	int
;	O
s1	pointer
++	O
;	O
s2	pointer
++	O
;	O
}	O
while	O
(	O
--	O
len	long
!=	O
0	int
)	O
;	O
}	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
_rl_completion_case_fold	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
do	O
{	O
v1	long
=	O
mbrtowc	function
(	O
&	O
wc1	int
,	O
s1	pointer
,	O
convlen	int
,	O
&	O
ps1	struct
)	O
;	O
v2	long
=	O
mbrtowc	function
(	O
&	O
wc2	int
,	O
s2	pointer
,	O
filename_len	int
,	O
&	O
ps2	struct
)	O
;	O
if	O
(	O
v1	long
==	O
0	int
&&	O
v2	long
==	O
0	int
)	O
return	O
1	int
;	O
else	O
if	O
(	O
MB_INVALIDCH	O
(	O
v1	long
)	O
||	O
MB_INVALIDCH	O
(	O
v2	long
)	O
)	O
{	O
if	O
(	O
*	O
s1	pointer
!=	O
*	O
s2	pointer
)	O
return	O
0	int
;	O
s1	pointer
++	O
;	O
s2	pointer
++	O
;	O
len	long
--	O
;	O
continue	O
;	O
}	O
wc1	int
=	O
towlower	function
(	O
wc1	int
)	O
;	O
wc2	int
=	O
towlower	function
(	O
wc2	int
)	O
;	O
if	O
(	O
wc1	int
!=	O
wc2	int
)	O
return	O
0	int
;	O
s1	pointer
+=	O
v1	long
;	O
s2	pointer
+=	O
v1	long
;	O
len	long
-=	O
v1	long
;	O
}	O
while	O
(	O
len	long
!=	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
_rl_to_lower	function
(	O
convfn	pointer
[	O
0	int
]	O
)	O
==	O
_rl_to_lower	function
(	O
filename	pointer
[	O
0	int
]	O
)	O
)	O
&&	O
(	O
convlen	int
>=	O
filename_len	int
)	O
&&	O
(	O
_rl_strnicmp	O
(	O
filename	pointer
,	O
convfn	pointer
,	O
filename_len	int
)	O
==	O
0	int
)	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
convfn	pointer
[	O
0	int
]	O
==	O
filename	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
convlen	int
>=	O
filename_len	int
)	O
&&	O
(	O
strncmp	function
(	O
filename	pointer
,	O
convfn	pointer
,	O
filename_len	int
)	O
==	O
0	int
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
rl_filename_completion_function	function
(	O
text	pointer
,	O
state	pointer
)	O
const	O
char	O
*	O
text	pointer
;	O
int	O
state	pointer
;	O
{	O
static	O
DIR	struct
*	O
directory	int
=	O
(	O
DIR	struct
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
dirname	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
users_dirname	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
filename_len	int
;	O
char	O
*	O
temp	pointer
,	O
*	O
dentry	pointer
,	O
*	O
convfn	pointer
;	O
int	O
dirlen	int
,	O
dentlen	int
,	O
convlen	int
;	O
int	O
tilde_dirname	int
;	O
struct	O
dirent	struct
*	O
entry	pointer
;	O
if	O
(	O
state	pointer
==	O
0	int
)	O
{	O
if	O
(	O
directory	int
)	O
{	O
closedir	function
(	O
directory	int
)	O
;	O
directory	int
=	O
(	O
DIR	struct
*	O
)	O
NULL	O
;	O
}	O
FREE	O
(	O
dirname	pointer
)	O
;	O
FREE	O
(	O
filename	pointer
)	O
;	O
FREE	O
(	O
users_dirname	pointer
)	O
;	O
filename	pointer
=	O
savestring	O
(	O
text	pointer
)	O
;	O
if	O
(	O
*	O
text	pointer
==	O
0	int
)	O
text	pointer
=	O
"."	pointer
;	O
dirname	pointer
=	O
savestring	O
(	O
text	pointer
)	O
;	O
temp	pointer
=	O
strrchr	function
(	O
dirname	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
temp	pointer
)	O
{	O
strcpy	function
(	O
filename	pointer
,	O
++	O
temp	pointer
)	O
;	O
*	O
temp	pointer
=	O
'\0'	O
;	O
}	O
else	O
{	O
dirname	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
dirname	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
rl_completion_found_quote	int
&&	O
rl_filename_dequoting_function	pointer
)	O
users_dirname	pointer
=	O
(	O
*	O
rl_filename_dequoting_function	pointer
)	O
(	O
dirname	pointer
,	O
rl_completion_quote_character	int
)	O
;	O
else	O
users_dirname	pointer
=	O
savestring	O
(	O
dirname	pointer
)	O
;	O
tilde_dirname	int
=	O
0	int
;	O
if	O
(	O
*	O
dirname	pointer
==	O
'~'	O
)	O
{	O
temp	pointer
=	O
tilde_expand	function
(	O
dirname	pointer
)	O
;	O
xfree	function
(	O
dirname	pointer
)	O
;	O
dirname	pointer
=	O
temp	pointer
;	O
tilde_dirname	int
=	O
1	int
;	O
}	O
if	O
(	O
rl_directory_rewrite_hook	pointer
)	O
(	O
*	O
rl_directory_rewrite_hook	pointer
)	O
(	O
&	O
dirname	pointer
)	O
;	O
else	O
if	O
(	O
rl_directory_completion_hook	pointer
&&	O
(	O
*	O
rl_directory_completion_hook	pointer
)	O
(	O
&	O
dirname	pointer
)	O
)	O
{	O
xfree	function
(	O
users_dirname	pointer
)	O
;	O
users_dirname	pointer
=	O
savestring	O
(	O
dirname	pointer
)	O
;	O
}	O
else	O
if	O
(	O
tilde_dirname	int
==	O
0	int
&&	O
rl_completion_found_quote	int
&&	O
rl_filename_dequoting_function	pointer
)	O
{	O
xfree	function
(	O
dirname	pointer
)	O
;	O
dirname	pointer
=	O
savestring	O
(	O
users_dirname	pointer
)	O
;	O
}	O
directory	int
=	O
opendir	function
(	O
dirname	pointer
)	O
;	O
if	O
(	O
*	O
filename	pointer
&&	O
rl_completion_found_quote	int
&&	O
rl_filename_dequoting_function	pointer
)	O
{	O
temp	pointer
=	O
(	O
*	O
rl_filename_dequoting_function	pointer
)	O
(	O
filename	pointer
,	O
rl_completion_quote_character	int
)	O
;	O
xfree	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
temp	pointer
;	O
}	O
filename_len	int
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
rl_filename_completion_desired	int
=	O
1	int
;	O
}	O
entry	pointer
=	O
(	O
struct	O
dirent	struct
*	O
)	O
NULL	O
;	O
while	O
(	O
directory	int
&&	O
(	O
entry	pointer
=	O
readdir	function
(	O
directory	int
)	O
)	O
)	O
{	O
convfn	pointer
=	O
dentry	pointer
=	O
entry	pointer
->	O
d_name	array
;	O
convlen	int
=	O
dentlen	int
=	O
D_NAMLEN	O
(	O
entry	pointer
)	O
;	O
if	O
(	O
rl_filename_rewrite_hook	pointer
)	O
{	O
convfn	pointer
=	O
(	O
*	O
rl_filename_rewrite_hook	pointer
)	O
(	O
dentry	pointer
,	O
dentlen	int
)	O
;	O
convlen	int
=	O
(	O
convfn	pointer
==	O
dentry	pointer
)	O
?	O
dentlen	int
:	O
strlen	function
(	O
convfn	pointer
)	O
;	O
}	O
if	O
(	O
filename_len	int
==	O
0	int
)	O
{	O
if	O
(	O
_rl_match_hidden_files	int
==	O
0	int
&&	O
HIDDEN_FILE	O
(	O
convfn	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
convfn	pointer
[	O
0	int
]	O
!=	O
'.'	O
||	O
(	O
convfn	pointer
[	O
1	int
]	O
&&	O
(	O
convfn	pointer
[	O
1	int
]	O
!=	O
'.'	O
||	O
convfn	pointer
[	O
2	int
]	O
)	O
)	O
)	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
complete_fncmp	function
(	O
convfn	pointer
,	O
convlen	int
,	O
filename	pointer
,	O
filename_len	int
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
entry	pointer
==	O
0	int
)	O
{	O
if	O
(	O
directory	int
)	O
{	O
closedir	function
(	O
directory	int
)	O
;	O
directory	int
=	O
(	O
DIR	struct
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
dirname	pointer
)	O
{	O
xfree	function
(	O
dirname	pointer
)	O
;	O
dirname	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
filename	pointer
)	O
{	O
xfree	function
(	O
filename	pointer
)	O
;	O
filename	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
users_dirname	pointer
)	O
{	O
xfree	function
(	O
users_dirname	pointer
)	O
;	O
users_dirname	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
dirname	pointer
&&	O
(	O
dirname	pointer
[	O
0	int
]	O
!=	O
'.'	O
||	O
dirname	pointer
[	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
rl_complete_with_tilde_expansion	int
&&	O
*	O
users_dirname	pointer
==	O
'~'	O
)	O
{	O
dirlen	int
=	O
strlen	function
(	O
dirname	pointer
)	O
;	O
temp	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
2	int
+	O
dirlen	int
+	O
D_NAMLEN	O
(	O
entry	pointer
)	O
)	O
;	O
strcpy	function
(	O
temp	pointer
,	O
dirname	pointer
)	O
;	O
if	O
(	O
dirname	pointer
[	O
dirlen	int
-	O
1	int
]	O
!=	O
'/'	O
)	O
{	O
temp	pointer
[	O
dirlen	int
++	O
]	O
=	O
'/'	O
;	O
temp	pointer
[	O
dirlen	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
dirlen	int
=	O
strlen	function
(	O
users_dirname	pointer
)	O
;	O
temp	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
2	int
+	O
dirlen	int
+	O
D_NAMLEN	O
(	O
entry	pointer
)	O
)	O
;	O
strcpy	function
(	O
temp	pointer
,	O
users_dirname	pointer
)	O
;	O
if	O
(	O
users_dirname	pointer
[	O
dirlen	int
-	O
1	int
]	O
!=	O
'/'	O
)	O
temp	pointer
[	O
dirlen	int
++	O
]	O
=	O
'/'	O
;	O
}	O
strcpy	function
(	O
temp	pointer
+	O
dirlen	int
,	O
convfn	pointer
)	O
;	O
}	O
else	O
temp	pointer
=	O
savestring	O
(	O
convfn	pointer
)	O
;	O
if	O
(	O
convfn	pointer
!=	O
dentry	pointer
)	O
xfree	function
(	O
convfn	pointer
)	O
;	O
return	O
(	O
temp	pointer
)	O
;	O
}	O
}	O
int	O
rl_old_menu_complete	function
(	O
count	int
,	O
invoking_key	int
)	O
int	O
count	int
,	O
invoking_key	int
;	O
{	O
rl_compentry_func_t	function
*	O
our_func	pointer
;	O
int	O
matching_filenames	int
,	O
found_quote	int
;	O
static	O
char	O
*	O
orig_text	pointer
;	O
static	O
char	O
*	O
*	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
static	O
int	O
match_list_index	int
=	O
0	int
;	O
static	O
int	O
match_list_size	int
=	O
0	int
;	O
static	O
int	O
orig_start	int
,	O
orig_end	int
;	O
static	O
char	O
quote_char	char
;	O
static	O
int	O
delimiter	int
;	O
if	O
(	O
rl_last_func	pointer
!=	O
rl_old_menu_complete	function
)	O
{	O
FREE	O
(	O
orig_text	pointer
)	O
;	O
if	O
(	O
matches	pointer
)	O
_rl_free_match_list	function
(	O
matches	pointer
)	O
;	O
match_list_index	int
=	O
match_list_size	int
=	O
0	int
;	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
rl_completion_invoking_key	int
=	O
invoking_key	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
set_completion_defaults	function
(	O
'%'	O
)	O
;	O
our_func	pointer
=	O
rl_menu_completion_entry_function	pointer
;	O
if	O
(	O
our_func	pointer
==	O
0	int
)	O
our_func	pointer
=	O
rl_completion_entry_function	pointer
?	O
rl_completion_entry_function	pointer
:	O
rl_filename_completion_function	function
;	O
orig_end	int
=	O
rl_point	int
;	O
found_quote	int
=	O
delimiter	int
=	O
0	int
;	O
quote_char	char
=	O
'\0'	O
;	O
if	O
(	O
rl_point	int
)	O
quote_char	char
=	O
_rl_find_completion_word	function
(	O
&	O
found_quote	int
,	O
&	O
delimiter	int
)	O
;	O
orig_start	int
=	O
rl_point	int
;	O
rl_point	int
=	O
orig_end	int
;	O
orig_text	pointer
=	O
rl_copy_text	function
(	O
orig_start	int
,	O
orig_end	int
)	O
;	O
matches	pointer
=	O
gen_completion_matches	function
(	O
orig_text	pointer
,	O
orig_start	int
,	O
orig_end	int
,	O
our_func	pointer
,	O
found_quote	int
,	O
quote_char	char
)	O
;	O
matching_filenames	int
=	O
rl_filename_completion_desired	int
;	O
if	O
(	O
matches	pointer
==	O
0	int
||	O
postprocess_matches	function
(	O
&	O
matches	pointer
,	O
matching_filenames	int
)	O
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
FREE	O
(	O
orig_text	pointer
)	O
;	O
orig_text	pointer
=	O
(	O
char	O
*	O
)	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
for	O
(	O
match_list_size	int
=	O
0	int
;	O
matches	pointer
[	O
match_list_size	int
]	O
;	O
match_list_size	int
++	O
)	O
;	O
if	O
(	O
match_list_size	int
>	O
1	int
&&	O
_rl_complete_show_all	int
)	O
display_matches	function
(	O
matches	pointer
)	O
;	O
}	O
if	O
(	O
matches	pointer
==	O
0	int
||	O
match_list_size	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
match_list_index	int
+=	O
count	int
;	O
if	O
(	O
match_list_index	int
<	O
0	int
)	O
{	O
while	O
(	O
match_list_index	int
<	O
0	int
)	O
match_list_index	int
+=	O
match_list_size	int
;	O
}	O
else	O
match_list_index	int
%=	O
match_list_size	int
;	O
if	O
(	O
match_list_index	int
==	O
0	int
&&	O
match_list_size	int
>	O
1	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
insert_match	function
(	O
orig_text	pointer
,	O
orig_start	int
,	O
MULT_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
}	O
else	O
{	O
insert_match	function
(	O
matches	pointer
[	O
match_list_index	int
]	O
,	O
orig_start	int
,	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
append_to_match	function
(	O
matches	pointer
[	O
match_list_index	int
]	O
,	O
delimiter	int
,	O
quote_char	char
,	O
strcmp	function
(	O
orig_text	pointer
,	O
matches	pointer
[	O
match_list_index	int
]	O
)	O
)	O
;	O
}	O
completion_changed_buffer	int
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_menu_complete	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
rl_compentry_func_t	function
*	O
our_func	pointer
;	O
int	O
matching_filenames	int
,	O
found_quote	int
;	O
static	O
char	O
*	O
orig_text	pointer
;	O
static	O
char	O
*	O
*	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
static	O
int	O
match_list_index	int
=	O
0	int
;	O
static	O
int	O
match_list_size	int
=	O
0	int
;	O
static	O
int	O
nontrivial_lcd	int
=	O
0	int
;	O
static	O
int	O
full_completion	int
=	O
0	int
;	O
static	O
int	O
orig_start	int
,	O
orig_end	int
;	O
static	O
char	O
quote_char	char
;	O
static	O
int	O
delimiter	int
,	O
cstate	int
;	O
if	O
(	O
(	O
rl_last_func	pointer
!=	O
rl_menu_complete	function
&&	O
rl_last_func	pointer
!=	O
rl_backward_menu_complete	function
)	O
||	O
full_completion	int
)	O
{	O
FREE	O
(	O
orig_text	pointer
)	O
;	O
if	O
(	O
matches	pointer
)	O
_rl_free_match_list	function
(	O
matches	pointer
)	O
;	O
match_list_index	int
=	O
match_list_size	int
=	O
0	int
;	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
full_completion	int
=	O
0	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
set_completion_defaults	function
(	O
'%'	O
)	O
;	O
our_func	pointer
=	O
rl_menu_completion_entry_function	pointer
;	O
if	O
(	O
our_func	pointer
==	O
0	int
)	O
our_func	pointer
=	O
rl_completion_entry_function	pointer
?	O
rl_completion_entry_function	pointer
:	O
rl_filename_completion_function	function
;	O
orig_end	int
=	O
rl_point	int
;	O
found_quote	int
=	O
delimiter	int
=	O
0	int
;	O
quote_char	char
=	O
'\0'	O
;	O
if	O
(	O
rl_point	int
)	O
quote_char	char
=	O
_rl_find_completion_word	function
(	O
&	O
found_quote	int
,	O
&	O
delimiter	int
)	O
;	O
orig_start	int
=	O
rl_point	int
;	O
rl_point	int
=	O
orig_end	int
;	O
orig_text	pointer
=	O
rl_copy_text	function
(	O
orig_start	int
,	O
orig_end	int
)	O
;	O
matches	pointer
=	O
gen_completion_matches	function
(	O
orig_text	pointer
,	O
orig_start	int
,	O
orig_end	int
,	O
our_func	pointer
,	O
found_quote	int
,	O
quote_char	char
)	O
;	O
nontrivial_lcd	int
=	O
matches	pointer
&&	O
strcmp	function
(	O
orig_text	pointer
,	O
matches	pointer
[	O
0	int
]	O
)	O
!=	O
0	int
;	O
matching_filenames	int
=	O
rl_filename_completion_desired	int
;	O
if	O
(	O
matches	pointer
==	O
0	int
||	O
postprocess_matches	function
(	O
&	O
matches	pointer
,	O
matching_filenames	int
)	O
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
FREE	O
(	O
orig_text	pointer
)	O
;	O
orig_text	pointer
=	O
(	O
char	O
*	O
)	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_COMPLETING	int
)	O
;	O
for	O
(	O
match_list_size	int
=	O
0	int
;	O
matches	pointer
[	O
match_list_size	int
]	O
;	O
match_list_size	int
++	O
)	O
;	O
if	O
(	O
match_list_size	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
match_list_index	int
=	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
*	O
matches	pointer
[	O
0	int
]	O
)	O
{	O
insert_match	function
(	O
matches	pointer
[	O
0	int
]	O
,	O
orig_start	int
,	O
matches	pointer
[	O
1	int
]	O
?	O
MULT_MATCH	int
:	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
orig_end	int
=	O
orig_start	int
+	O
strlen	function
(	O
matches	pointer
[	O
0	int
]	O
)	O
;	O
completion_changed_buffer	int
=	O
STREQ	O
(	O
orig_text	pointer
,	O
matches	pointer
[	O
0	int
]	O
)	O
==	O
0	int
;	O
}	O
if	O
(	O
match_list_size	int
>	O
1	int
&&	O
_rl_complete_show_all	int
)	O
{	O
display_matches	function
(	O
matches	pointer
)	O
;	O
if	O
(	O
rl_completion_query_items	int
>	O
0	int
&&	O
match_list_size	int
>=	O
rl_completion_query_items	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
full_completion	int
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
_rl_menu_complete_prefix_first	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
match_list_size	int
<=	O
1	int
)	O
{	O
append_to_match	function
(	O
matches	pointer
[	O
0	int
]	O
,	O
delimiter	int
,	O
quote_char	char
,	O
nontrivial_lcd	int
)	O
;	O
full_completion	int
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
_rl_menu_complete_prefix_first	int
&&	O
match_list_size	int
>	O
1	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
matches	pointer
==	O
0	int
||	O
match_list_size	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
FREE	O
(	O
matches	pointer
)	O
;	O
matches	pointer
=	O
(	O
char	O
*	O
*	O
)	O
0	int
;	O
completion_changed_buffer	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
match_list_index	int
+=	O
count	int
;	O
if	O
(	O
match_list_index	int
<	O
0	int
)	O
{	O
while	O
(	O
match_list_index	int
<	O
0	int
)	O
match_list_index	int
+=	O
match_list_size	int
;	O
}	O
else	O
match_list_index	int
%=	O
match_list_size	int
;	O
if	O
(	O
match_list_index	int
==	O
0	int
&&	O
match_list_size	int
>	O
1	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
insert_match	function
(	O
matches	pointer
[	O
0	int
]	O
,	O
orig_start	int
,	O
MULT_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
}	O
else	O
{	O
insert_match	function
(	O
matches	pointer
[	O
match_list_index	int
]	O
,	O
orig_start	int
,	O
SINGLE_MATCH	int
,	O
&	O
quote_char	char
)	O
;	O
append_to_match	function
(	O
matches	pointer
[	O
match_list_index	int
]	O
,	O
delimiter	int
,	O
quote_char	char
,	O
strcmp	function
(	O
orig_text	pointer
,	O
matches	pointer
[	O
match_list_index	int
]	O
)	O
)	O
;	O
}	O
completion_changed_buffer	int
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_backward_menu_complete	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_menu_complete	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
