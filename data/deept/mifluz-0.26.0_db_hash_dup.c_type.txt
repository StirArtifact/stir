static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: hash_dup.c,v 1.6 2014/04/17 20:27:29 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__ham_check_move	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ham_dcursor	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_pgno_t	int
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
CDB___ham_add_dup	function
(	O
dbc	pointer
,	O
nval	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
nval	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
DBT	struct
pval	struct
,	O
tmp_val	struct
;	O
u_int32_t	int
add_bytes	int
,	O
new_size	int
;	O
int	O
cmp	int
,	O
ret	int
;	O
u_int8_t	char
*	O
hk	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
DB_ASSERT	O
(	O
flags	int
!=	O
DB_CURRENT	O
)	O
;	O
add_bytes	int
=	O
nval	pointer
->	O
size	int
+	O
(	O
F_ISSET	O
(	O
nval	pointer
,	O
DB_DBT_PARTIAL	int
)	O
?	O
nval	pointer
->	O
doff	int
:	O
0	int
)	O
;	O
add_bytes	int
=	O
DUP_SIZE	O
(	O
add_bytes	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__ham_check_move	function
(	O
dbc	pointer
,	O
add_bytes	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hk	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
new_size	int
=	O
LEN_HKEYDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
)	O
+	O
add_bytes	int
;	O
if	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
!=	O
H_OFFDUP	int
&&	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
==	O
H_OFFPAGE	int
||	O
ISBIG	O
(	O
hcp	pointer
,	O
new_size	int
)	O
||	O
add_bytes	int
>	O
P_FREESPACE	O
(	O
hcp	pointer
->	O
page	pointer
)	O
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_dup_convert	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
hcp	pointer
->	O
opd	pointer
->	O
c_am_put	pointer
(	O
hcp	pointer
->	O
opd	pointer
,	O
NULL	O
,	O
nval	pointer
,	O
flags	int
,	O
NULL	O
)	O
)	O
;	O
}	O
if	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
!=	O
H_OFFDUP	int
)	O
{	O
if	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
!=	O
H_DUPLICATE	int
)	O
{	O
pval	struct
.	O
flags	int
=	O
0	int
;	O
pval	struct
.	O
data	pointer
=	O
HKEYDATA_DATA	O
(	O
hk	pointer
)	O
;	O
pval	struct
.	O
size	int
=	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_make_dup	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
&	O
pval	struct
,	O
&	O
tmp_val	struct
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB___ham_replpair	function
(	O
dbc	pointer
,	O
&	O
tmp_val	struct
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hk	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
=	O
H_DUPLICATE	int
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
hcp	pointer
->	O
dup_off	short
=	O
0	int
;	O
hcp	pointer
->	O
dup_len	short
=	O
pval	struct
.	O
size	int
;	O
hcp	pointer
->	O
dup_tlen	short
=	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_make_dup	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
nval	pointer
,	O
&	O
tmp_val	struct
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
tmp_val	struct
.	O
dlen	int
=	O
0	int
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_KEYFIRST	int
:	O
case	O
DB_KEYLAST	int
:	O
case	O
DB_NODUPDATA	int
:	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
)	O
{	O
CDB___ham_dsearch	function
(	O
dbc	pointer
,	O
nval	pointer
,	O
&	O
tmp_val	struct
.	O
doff	int
,	O
&	O
cmp	int
)	O
;	O
if	O
(	O
cmp	int
==	O
0	int
)	O
return	O
(	O
CDB___db_duperr	function
(	O
dbp	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
else	O
{	O
hcp	pointer
->	O
dup_tlen	short
=	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
hcp	pointer
->	O
dup_len	short
=	O
nval	pointer
->	O
size	int
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
if	O
(	O
flags	int
==	O
DB_KEYFIRST	int
)	O
hcp	pointer
->	O
dup_off	short
=	O
tmp_val	struct
.	O
doff	int
=	O
0	int
;	O
else	O
hcp	pointer
->	O
dup_off	short
=	O
tmp_val	struct
.	O
doff	int
=	O
hcp	pointer
->	O
dup_tlen	short
;	O
}	O
break	O
;	O
case	O
DB_BEFORE	int
:	O
tmp_val	struct
.	O
doff	int
=	O
hcp	pointer
->	O
dup_off	short
;	O
break	O
;	O
case	O
DB_AFTER	int
:	O
tmp_val	struct
.	O
doff	int
=	O
hcp	pointer
->	O
dup_off	short
+	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
break	O
;	O
}	O
ret	int
=	O
CDB___ham_replpair	function
(	O
dbc	pointer
,	O
&	O
tmp_val	struct
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
CDB___ham_dirty_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
)	O
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_AFTER	int
:	O
hcp	pointer
->	O
dup_off	short
+=	O
DUP_SIZE	O
(	O
hcp	pointer
->	O
dup_len	short
)	O
;	O
hcp	pointer
->	O
dup_len	short
=	O
nval	pointer
->	O
size	int
;	O
hcp	pointer
->	O
dup_tlen	short
+=	O
DUP_SIZE	O
(	O
nval	pointer
->	O
size	int
)	O
;	O
break	O
;	O
case	O
DB_KEYFIRST	int
:	O
case	O
DB_KEYLAST	int
:	O
case	O
DB_BEFORE	int
:	O
hcp	pointer
->	O
dup_tlen	short
+=	O
DUP_SIZE	O
(	O
nval	pointer
->	O
size	int
)	O
;	O
hcp	pointer
->	O
dup_len	short
=	O
nval	pointer
->	O
size	int
;	O
break	O
;	O
}	O
CDB___ham_c_update	function
(	O
dbc	pointer
,	O
hcp	pointer
->	O
pgno	int
,	O
tmp_val	struct
.	O
size	int
,	O
1	int
,	O
1	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
memcpy	function
(	O
pgnop	pointer
,	O
HOFFDUP_PGNO	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_dup_convert	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
*	O
hcs	pointer
;	O
PAGE	struct
*	O
dp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
BOVERFLOW	struct
bo	struct
;	O
DBT	struct
dbt	struct
;	O
HOFFPAGE	struct
ho	struct
;	O
db_indx_t	short
i	short
,	O
len	short
,	O
off	long
;	O
int	O
c	int
,	O
ret	int
,	O
t_ret	int
;	O
u_int8_t	char
*	O
p	pointer
,	O
*	O
pend	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_new	function
(	O
dbc	pointer
,	O
(	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
?	O
P_LRECNO	int
:	O
P_LDUP	int
)	O
|	O
dbp	pointer
->	O
tags	char
)	O
,	O
&	O
dp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
P_INIT	O
(	O
dp	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
dp	pointer
->	O
pgno	int
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
LEAFLEVEL	int
,	O
TYPE	O
(	O
dp	pointer
)	O
,	O
TAGS	O
(	O
dp	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_clist	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
hcp	pointer
->	O
indx	short
,	O
&	O
hcs	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbt	struct
.	O
flags	int
=	O
0	int
;	O
switch	O
(	O
HPAGE_PTYPE	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
)	O
{	O
case	O
H_KEYDATA	int
:	O
dbt	struct
.	O
size	int
=	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
dbt	struct
.	O
data	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
dp	pointer
,	O
0	int
,	O
BKEYDATA_SIZE	O
(	O
dbt	struct
.	O
size	int
)	O
,	O
NULL	O
,	O
&	O
dbt	struct
)	O
;	O
goto	O
finish	O
;	O
case	O
H_OFFPAGE	int
:	O
memcpy	function
(	O
&	O
ho	struct
,	O
P_ENTRY	O
(	O
hcp	pointer
->	O
page	pointer
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
)	O
,	O
HOFFPAGE_SIZE	O
)	O
;	O
UMRW	O
(	O
bo	struct
.	O
unused1	array
)	O
;	O
B_TSET	O
(	O
bo	struct
.	O
type	enum
,	O
ho	struct
.	O
type	enum
,	O
0	int
)	O
;	O
UMRW	O
(	O
bo	struct
.	O
unused2	array
)	O
;	O
bo	struct
.	O
pgno	int
=	O
ho	struct
.	O
pgno	int
;	O
bo	struct
.	O
tlen	int
=	O
ho	struct
.	O
tlen	int
;	O
dbt	struct
.	O
size	int
=	O
BOVERFLOW_SIZE	O
;	O
dbt	struct
.	O
data	pointer
=	O
&	O
bo	struct
;	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
dp	pointer
,	O
0	int
,	O
dbt	struct
.	O
size	int
,	O
&	O
dbt	struct
,	O
NULL	O
)	O
;	O
finish	O
:	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
CDB___ham_dirty_page	function
(	O
dbp	pointer
,	O
dp	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
hcs	pointer
!=	O
NULL	O
&&	O
hcs	pointer
[	O
c	int
]	O
!=	O
NULL	O
;	O
c	int
++	O
)	O
if	O
(	O
(	O
ret	int
=	O
__ham_dcursor	function
(	O
hcs	pointer
[	O
c	int
]	O
,	O
PGNO	O
(	O
dp	pointer
)	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
}	O
break	O
;	O
case	O
H_DUPLICATE	int
:	O
p	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
pend	pointer
=	O
p	pointer
+	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
for	O
(	O
off	long
=	O
0	int
,	O
i	short
=	O
0	int
;	O
p	pointer
<	O
pend	pointer
;	O
i	short
++	O
)	O
{	O
memcpy	function
(	O
&	O
len	short
,	O
p	pointer
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
dbt	struct
.	O
size	int
=	O
len	short
;	O
p	pointer
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
dbt	struct
.	O
data	pointer
=	O
p	pointer
;	O
p	pointer
+=	O
len	short
+	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
dp	pointer
,	O
i	short
,	O
BKEYDATA_SIZE	O
(	O
dbt	struct
.	O
size	int
)	O
,	O
NULL	O
,	O
&	O
dbt	struct
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
hcs	pointer
!=	O
NULL	O
&&	O
hcs	pointer
[	O
c	int
]	O
!=	O
NULL	O
;	O
c	int
++	O
)	O
if	O
(	O
(	O
(	O
HASH_CURSOR	struct
*	O
)	O
(	O
hcs	pointer
[	O
c	int
]	O
->	O
internal	pointer
)	O
)	O
->	O
dup_off	short
==	O
off	long
&&	O
(	O
ret	int
=	O
__ham_dcursor	function
(	O
hcs	pointer
[	O
c	int
]	O
,	O
PGNO	O
(	O
dp	pointer
)	O
,	O
i	short
)	O
)	O
!=	O
0	int
)	O
goto	O
out	O
;	O
off	long
+=	O
len	short
+	O
2	int
*	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
}	O
out	O
:	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
(	O
u_long	long
)	O
hcp	pointer
->	O
pgno	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
CDB___ham_move_offpage	function
(	O
dbc	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
(	O
u_int32_t	int
)	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
,	O
PGNO	O
(	O
dp	pointer
)	O
)	O
;	O
ret	int
=	O
CDB___ham_dirty_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
dp	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
hcp	pointer
->	O
dup_tlen	short
=	O
hcp	pointer
->	O
dup_off	short
=	O
hcp	pointer
->	O
dup_len	short
=	O
0	int
;	O
}	O
else	O
(	O
void	O
)	O
CDB___db_free	function
(	O
dbc	pointer
,	O
dp	pointer
)	O
;	O
if	O
(	O
hcs	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
hcs	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___ham_make_dup	function
(	O
dbenv	pointer
,	O
notdup	pointer
,	O
duplicate	pointer
,	O
bufp	pointer
,	O
sizep	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
DBT	struct
*	O
notdup	pointer
;	O
DBT	struct
*	O
duplicate	pointer
;	O
void	O
*	O
*	O
bufp	pointer
;	O
u_int32_t	int
*	O
sizep	pointer
;	O
{	O
db_indx_t	short
tsize	short
,	O
item_size	short
;	O
int	O
ret	int
;	O
u_int8_t	char
*	O
p	pointer
;	O
item_size	short
=	O
(	O
db_indx_t	short
)	O
notdup	pointer
->	O
size	int
;	O
if	O
(	O
F_ISSET	O
(	O
notdup	pointer
,	O
DB_DBT_PARTIAL	int
)	O
)	O
item_size	short
+=	O
notdup	pointer
->	O
doff	int
;	O
tsize	short
=	O
DUP_SIZE	O
(	O
item_size	short
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_init_dbt	function
(	O
dbenv	pointer
,	O
duplicate	pointer
,	O
tsize	short
,	O
bufp	pointer
,	O
sizep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
duplicate	pointer
->	O
dlen	int
=	O
0	int
;	O
duplicate	pointer
->	O
flags	int
=	O
notdup	pointer
->	O
flags	int
;	O
F_SET	O
(	O
duplicate	pointer
,	O
DB_DBT_PARTIAL	int
)	O
;	O
p	pointer
=	O
duplicate	pointer
->	O
data	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
&	O
item_size	short
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
notdup	pointer
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
notdup	pointer
->	O
doff	int
)	O
;	O
p	pointer
+=	O
notdup	pointer
->	O
doff	int
;	O
}	O
memcpy	function
(	O
p	pointer
,	O
notdup	pointer
->	O
data	pointer
,	O
notdup	pointer
->	O
size	int
)	O
;	O
p	pointer
+=	O
notdup	pointer
->	O
size	int
;	O
memcpy	function
(	O
p	pointer
,	O
&	O
item_size	short
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
duplicate	pointer
->	O
doff	int
=	O
0	int
;	O
duplicate	pointer
->	O
dlen	int
=	O
notdup	pointer
->	O
size	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ham_check_move	function
(	O
dbc	pointer
,	O
add_len	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
add_len	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
DBT	struct
k	struct
,	O
d	pointer
;	O
DB_LSN	struct
new_lsn	struct
;	O
PAGE	struct
*	O
next_pagep	pointer
;	O
db_pgno_t	int
next_pgno	int
;	O
u_int32_t	int
new_datalen	int
,	O
old_len	int
,	O
rectype	int
;	O
u_int8_t	char
*	O
hk	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
hk	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
==	O
H_OFFDUP	int
||	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
==	O
H_OFFPAGE	int
)	O
return	O
(	O
0	int
)	O
;	O
old_len	int
=	O
LEN_HITEM	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
new_datalen	int
=	O
old_len	int
-	O
HKEYDATA_SIZE	O
(	O
0	int
)	O
+	O
add_len	int
;	O
if	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
!=	O
H_DUPLICATE	int
)	O
new_datalen	int
+=	O
DUP_SIZE	O
(	O
0	int
)	O
;	O
if	O
(	O
ISBIG	O
(	O
hcp	pointer
,	O
new_datalen	int
)	O
&&	O
(	O
old_len	int
>	O
HOFFDUP_SIZE	O
||	O
HOFFDUP_SIZE	O
-	O
old_len	int
<=	O
P_FREESPACE	O
(	O
hcp	pointer
->	O
page	pointer
)	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
!	O
ISBIG	O
(	O
hcp	pointer
,	O
new_datalen	int
)	O
&&	O
add_len	int
<=	O
P_FREESPACE	O
(	O
hcp	pointer
->	O
page	pointer
)	O
)	O
return	O
(	O
0	int
)	O
;	O
new_datalen	int
=	O
ISBIG	O
(	O
hcp	pointer
,	O
new_datalen	int
)	O
?	O
(	O
size_t	long
)	O
HOFFDUP_SIZE	O
:	O
(	O
size_t	long
)	O
HKEYDATA_SIZE	O
(	O
new_datalen	int
)	O
;	O
next_pagep	pointer
=	O
NULL	O
;	O
for	O
(	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
next_pgno	int
!=	O
PGNO_INVALID	int
;	O
next_pgno	int
=	O
NEXT_PGNO	O
(	O
next_pagep	pointer
)	O
)	O
{	O
if	O
(	O
next_pagep	pointer
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
next_pagep	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_get_page	function
(	O
dbp	pointer
,	O
next_pgno	int
,	O
&	O
next_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
P_FREESPACE	O
(	O
next_pagep	pointer
)	O
>=	O
new_datalen	int
)	O
break	O
;	O
}	O
if	O
(	O
next_pagep	pointer
==	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB___ham_add_ovflpage	function
(	O
dbc	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
0	int
,	O
&	O
next_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
P_FREESPACE	O
(	O
next_pagep	pointer
)	O
<	O
new_datalen	int
&&	O
(	O
ret	int
=	O
CDB___ham_add_ovflpage	function
(	O
dbc	pointer
,	O
next_pagep	pointer
,	O
1	int
,	O
&	O
next_pagep	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
next_pagep	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
rectype	int
=	O
PUTPAIR	int
;	O
k	struct
.	O
flags	int
=	O
0	int
;	O
d	pointer
.	O
flags	int
=	O
0	int
;	O
if	O
(	O
HPAGE_PTYPE	O
(	O
H_PAIRKEY	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
==	O
H_OFFPAGE	int
)	O
{	O
rectype	int
|=	O
PAIR_KEYMASK	int
;	O
k	struct
.	O
data	pointer
=	O
H_PAIRKEY	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
k	struct
.	O
size	int
=	O
HOFFPAGE_SIZE	O
;	O
}	O
else	O
{	O
k	struct
.	O
data	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRKEY	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
k	struct
.	O
size	int
=	O
LEN_HKEY	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
}	O
if	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
==	O
H_OFFPAGE	int
)	O
{	O
rectype	int
|=	O
PAIR_DATAMASK	int
;	O
d	pointer
.	O
data	pointer
=	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
d	pointer
.	O
size	int
=	O
HOFFPAGE_SIZE	O
;	O
}	O
else	O
{	O
if	O
(	O
HPAGE_PTYPE	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
==	O
H_DUPLICATE	int
)	O
rectype	int
|=	O
PAIR_DUPMASK	int
;	O
d	pointer
.	O
data	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
;	O
d	pointer
.	O
size	int
=	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_insdel_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
rectype	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
next_pagep	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
NUM_ENT	O
(	O
next_pagep	pointer
)	O
,	O
&	O
LSN	O
(	O
next_pagep	pointer
)	O
,	O
&	O
k	struct
,	O
&	O
d	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
LSN	O
(	O
next_pagep	pointer
)	O
=	O
new_lsn	struct
;	O
}	O
CDB___ham_copy_item	function
(	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
page	pointer
,	O
H_KEYINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
,	O
next_pagep	pointer
)	O
;	O
CDB___ham_copy_item	function
(	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
page	pointer
,	O
H_DATAINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
,	O
next_pagep	pointer
)	O
;	O
CDB___ham_c_chgpg	function
(	O
dbc	pointer
,	O
PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
,	O
H_KEYINDEX	O
(	O
hcp	pointer
->	O
indx	short
)	O
,	O
PGNO	O
(	O
next_pagep	pointer
)	O
,	O
NUM_ENT	O
(	O
next_pagep	pointer
)	O
-	O
2	int
)	O
;	O
ret	int
=	O
CDB___ham_del_pair	function
(	O
dbc	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
STD_LOCKING	O
(	O
dbc	pointer
)	O
)	O
hcp	pointer
->	O
hdr	pointer
->	O
nelem	int
++	O
;	O
(	O
void	O
)	O
CDB___ham_put_page	function
(	O
dbp	pointer
,	O
hcp	pointer
->	O
page	pointer
,	O
1	int
)	O
;	O
hcp	pointer
->	O
page	pointer
=	O
next_pagep	pointer
;	O
hcp	pointer
->	O
pgno	int
=	O
PGNO	O
(	O
hcp	pointer
->	O
page	pointer
)	O
;	O
hcp	pointer
->	O
indx	short
=	O
NUM_ENT	O
(	O
hcp	pointer
->	O
page	pointer
)	O
-	O
2	int
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_EXPAND	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
void	O
CDB___ham_move_offpage	function
(	O
dbc	pointer
,	O
pagep	pointer
,	O
ndx	int
,	O
pgno	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
pagep	pointer
;	O
u_int32_t	int
ndx	int
;	O
db_pgno_t	int
pgno	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
new_dbt	struct
;	O
DBT	struct
old_dbt	struct
;	O
HOFFDUP	struct
od	struct
;	O
db_indx_t	short
i	short
;	O
int32_t	int
shrink	int
;	O
u_int8_t	char
*	O
src	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
od	struct
.	O
type	enum
=	O
H_OFFDUP	int
;	O
UMRW	O
(	O
od	struct
.	O
unused	array
[	O
0	int
]	O
)	O
;	O
UMRW	O
(	O
od	struct
.	O
unused	array
[	O
1	int
]	O
)	O
;	O
UMRW	O
(	O
od	struct
.	O
unused	array
[	O
2	int
]	O
)	O
;	O
od	struct
.	O
pgno	int
=	O
pgno	int
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
new_dbt	struct
.	O
data	pointer
=	O
&	O
od	struct
;	O
new_dbt	struct
.	O
size	int
=	O
HOFFDUP_SIZE	O
;	O
old_dbt	struct
.	O
data	pointer
=	O
P_ENTRY	O
(	O
pagep	pointer
,	O
ndx	int
)	O
;	O
old_dbt	struct
.	O
size	int
=	O
LEN_HITEM	O
(	O
pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
ndx	int
)	O
;	O
(	O
void	O
)	O
CDB___ham_replace_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
pagep	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
ndx	int
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
-	O
1	int
,	O
&	O
old_dbt	struct
,	O
&	O
new_dbt	struct
,	O
0	int
)	O
;	O
}	O
shrink	int
=	O
LEN_HITEM	O
(	O
pagep	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
ndx	int
)	O
-	O
HOFFDUP_SIZE	O
;	O
if	O
(	O
shrink	int
!=	O
0	int
)	O
{	O
src	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
(	O
pagep	pointer
)	O
+	O
HOFFSET	O
(	O
pagep	pointer
)	O
;	O
memmove	function
(	O
src	pointer
+	O
shrink	int
,	O
src	pointer
,	O
pagep	pointer
->	O
inp	array
[	O
ndx	int
]	O
-	O
HOFFSET	O
(	O
pagep	pointer
)	O
)	O
;	O
HOFFSET	O
(	O
pagep	pointer
)	O
+=	O
shrink	int
;	O
for	O
(	O
i	short
=	O
ndx	int
;	O
i	short
<	O
NUM_ENT	O
(	O
pagep	pointer
)	O
;	O
i	short
++	O
)	O
pagep	pointer
->	O
inp	array
[	O
i	short
]	O
+=	O
shrink	int
;	O
}	O
memcpy	function
(	O
P_ENTRY	O
(	O
pagep	pointer
,	O
ndx	int
)	O
,	O
&	O
od	struct
,	O
HOFFDUP_SIZE	O
)	O
;	O
}	O
void	O
CDB___ham_dsearch	function
(	O
dbc	pointer
,	O
dbt	struct
,	O
offp	pointer
,	O
cmpp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
dbt	struct
;	O
u_int32_t	int
*	O
offp	pointer
;	O
int	O
*	O
cmpp	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
DBT	struct
cur	struct
;	O
db_indx_t	short
i	short
,	O
len	short
;	O
int	O
(	O
*	O
func	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
u_int8_t	char
*	O
data	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
)	O
func	pointer
=	O
CDB___bam_defcmp	function
;	O
else	O
func	pointer
=	O
dbp	pointer
->	O
dup_compare	pointer
;	O
i	short
=	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_CONTINUE	int
)	O
?	O
hcp	pointer
->	O
dup_off	short
:	O
0	int
;	O
data	pointer
=	O
HKEYDATA_DATA	O
(	O
H_PAIRDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
hcp	pointer
->	O
indx	short
)	O
)	O
+	O
i	short
;	O
hcp	pointer
->	O
dup_tlen	short
=	O
LEN_HDATA	O
(	O
hcp	pointer
->	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
hcp	pointer
->	O
indx	short
)	O
;	O
while	O
(	O
i	short
<	O
hcp	pointer
->	O
dup_tlen	short
)	O
{	O
memcpy	function
(	O
&	O
len	short
,	O
data	pointer
,	O
sizeof	O
(	O
db_indx_t	short
)	O
)	O
;	O
data	pointer
+=	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
cur	struct
.	O
data	pointer
=	O
data	pointer
;	O
cur	struct
.	O
size	int
=	O
(	O
u_int32_t	int
)	O
len	short
;	O
*	O
cmpp	pointer
=	O
func	pointer
(	O
dbt	struct
,	O
&	O
cur	struct
)	O
;	O
if	O
(	O
*	O
cmpp	pointer
==	O
0	int
||	O
(	O
*	O
cmpp	pointer
<	O
0	int
&&	O
dbp	pointer
->	O
dup_compare	pointer
!=	O
NULL	O
)	O
)	O
break	O
;	O
i	short
+=	O
len	short
+	O
2	int
*	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
data	pointer
+=	O
len	short
+	O
sizeof	O
(	O
db_indx_t	short
)	O
;	O
}	O
*	O
offp	pointer
=	O
i	short
;	O
hcp	pointer
->	O
dup_off	short
=	O
i	short
;	O
hcp	pointer
->	O
dup_len	short
=	O
len	short
;	O
F_SET	O
(	O
hcp	pointer
,	O
H_ISDUP	int
)	O
;	O
}	O
static	O
int	O
__ham_dcursor	function
(	O
dbc	pointer
,	O
pgno	int
,	O
indx	short
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
pgno	int
;	O
u_int32_t	int
indx	short
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBC	struct
*	O
dbc_nopd	pointer
;	O
HASH_CURSOR	struct
*	O
hcp	pointer
;	O
BTREE_CURSOR	struct
*	O
dcp	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
dbc_nopd	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_icursor	function
(	O
dbp	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
?	O
DB_RECNO	int
:	O
DB_BTREE	int
,	O
pgno	int
,	O
1	int
,	O
&	O
dbc_nopd	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dcp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc_nopd	pointer
->	O
internal	pointer
;	O
dcp	pointer
->	O
pgno	int
=	O
pgno	int
;	O
dcp	pointer
->	O
indx	short
=	O
indx	short
;	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
)	O
{	O
dcp	pointer
->	O
recno	int
=	O
indx	short
+	O
1	int
;	O
}	O
hcp	pointer
=	O
(	O
HASH_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
)	O
{	O
F_SET	O
(	O
dcp	pointer
,	O
C_DELETED	int
)	O
;	O
F_CLR	O
(	O
hcp	pointer
,	O
H_DELETED	int
)	O
;	O
}	O
hcp	pointer
->	O
opd	pointer
=	O
dbc_nopd	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
