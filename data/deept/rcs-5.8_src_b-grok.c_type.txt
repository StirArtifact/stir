struct	O
lockdef	struct
{	O
char	O
const	O
*	O
login	pointer
;	O
char	O
const	O
*	O
revno	pointer
;	O
}	O
;	O
struct	O
notyet	struct
{	O
char	O
const	O
*	O
revno	pointer
;	O
char	O
const	O
*	O
next	pointer
;	O
struct	O
link	function
*	O
branches	pointer
;	O
struct	O
delta	struct
*	O
d	pointer
;	O
}	O
;	O
struct	O
grok	struct
{	O
int	O
c	int
;	O
struct	O
fro	struct
*	O
from	pointer
;	O
struct	O
divvy	struct
*	O
to	pointer
;	O
struct	O
divvy	struct
*	O
systolic	pointer
;	O
struct	O
divvy	struct
*	O
tranquil	pointer
;	O
struct	O
cbuf	struct
xrep	struct
;	O
size_t	long
lno	long
;	O
size_t	long
head_lno	long
;	O
struct	O
cbuf	struct
bor_no	struct
;	O
}	O
;	O
static	O
void	O
ignoble	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
char	O
const	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
args	pointer
;	O
struct	O
cbuf	struct
msg	struct
;	O
struct	O
divvy	struct
*	O
scratch	pointer
=	O
g	pointer
->	O
systolic	pointer
;	O
struct	O
obstack	struct
*	O
o	pointer
=	O
scratch	pointer
->	O
space	pointer
;	O
obstack_free	function
(	O
o	pointer
,	O
obstack_finish	O
(	O
o	pointer
)	O
)	O
;	O
va_start	O
(	O
args	pointer
,	O
fmt	pointer
)	O
;	O
obstack_vprintf	function
(	O
o	pointer
,	O
fmt	pointer
,	O
args	pointer
)	O
;	O
va_end	O
(	O
args	pointer
)	O
;	O
msg	struct
.	O
string	pointer
=	O
finish_string	function
(	O
scratch	pointer
,	O
&	O
msg	struct
.	O
size	long
)	O
;	O
complain	function
(	O
"\n"	pointer
)	O
;	O
fatal_syntax	function
(	O
g	pointer
->	O
lno	long
,	O
"%s"	pointer
,	O
msg	struct
.	O
string	pointer
)	O
;	O
}	O
static	O
void	O
eof_too_soon	function
(	O
struct	O
grok	struct
*	O
g	pointer
)	O
{	O
BUMMER	O
(	O
"unexpected end of file"	pointer
)	O
;	O
}	O
static	O
void	O
skip_whitespace	function
(	O
struct	O
grok	struct
*	O
g	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
'\n'	O
==	O
g	pointer
->	O
c	int
)	O
g	pointer
->	O
lno	long
++	O
;	O
if	O
(	O
!	O
isspace	function
(	O
g	pointer
->	O
c	int
)	O
)	O
return	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
}	O
}	O
static	O
void	O
must_read_keyword	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
struct	O
tinysym	struct
const	O
*	O
kw	pointer
)	O
{	O
CBEG	O
(	O
TINYS	O
(	O
kw	pointer
)	O
)	O
;	O
skip_whitespace	function
(	O
g	pointer
)	O
;	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
kw	pointer
->	O
len	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
TINYS	O
(	O
kw	pointer
)	O
[	O
i	int
]	O
!=	O
g	pointer
->	O
c	int
)	O
BUMMER	O
(	O
"missing `%s' keyword"	pointer
,	O
TINYS	O
(	O
kw	pointer
)	O
)	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
}	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
=	O
TINYS	O
(	O
kw	pointer
)	O
;	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
=	O
kw	pointer
->	O
len	char
;	O
CEND	O
(	O
)	O
;	O
}	O
static	O
bool	bool
probe_keyword	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
struct	O
tinysym	struct
const	O
*	O
kw	pointer
)	O
{	O
off_t	long
was	long
;	O
bool	bool
rv	bool
=	O
true	int
;	O
CBEG	O
(	O
TINYS	O
(	O
kw	pointer
)	O
)	O
;	O
skip_whitespace	function
(	O
g	pointer
)	O
;	O
was	long
=	O
fro_tello	function
(	O
g	pointer
->	O
from	pointer
)	O
;	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
kw	pointer
->	O
len	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
rv	bool
=	O
(	O
TINYS	O
(	O
kw	pointer
)	O
[	O
i	int
]	O
==	O
g	pointer
->	O
c	int
)	O
)	O
)	O
break	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
}	O
if	O
(	O
rv	bool
)	O
{	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
=	O
TINYS	O
(	O
kw	pointer
)	O
;	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
=	O
kw	pointer
->	O
len	char
;	O
}	O
else	O
{	O
fro_move	function
(	O
g	pointer
->	O
from	pointer
,	O
was	long
-	O
1	int
)	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
}	O
CEND	O
(	O
)	O
;	O
return	O
rv	bool
;	O
}	O
static	O
void	O
accb	function
(	O
struct	O
grok	struct
*	O
g	pointer
)	O
{	O
accumulate_byte	function
(	O
g	pointer
->	O
to	pointer
,	O
g	pointer
->	O
c	int
)	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
}	O
static	O
bool	bool
maybe_read_num	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
bool	bool
must_be_delta_p	bool
)	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
dots	long
=	O
0	int
;	O
CBEG	O
(	O
"num"	pointer
)	O
;	O
skip_whitespace	function
(	O
g	pointer
)	O
;	O
while	O
(	O
'.'	O
==	O
g	pointer
->	O
c	int
||	O
isdigit	function
(	O
g	pointer
->	O
c	int
)	O
)	O
{	O
if	O
(	O
must_be_delta_p	bool
)	O
dots	long
+=	O
(	O
'.'	O
==	O
g	pointer
->	O
c	int
)	O
;	O
accb	function
(	O
g	pointer
)	O
;	O
}	O
p	pointer
=	O
finish_string	function
(	O
g	pointer
->	O
to	pointer
,	O
&	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
)	O
;	O
CEND	O
(	O
)	O
;	O
if	O
(	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
)	O
{	O
bool	bool
trailing_garbage	bool
=	O
(	O
';'	O
!=	O
g	pointer
->	O
c	int
&&	O
!	O
isspace	function
(	O
g	pointer
->	O
c	int
)	O
)	O
;	O
if	O
(	O
trailing_garbage	bool
)	O
{	O
accs	O
(	O
g	pointer
->	O
to	pointer
,	O
p	pointer
)	O
;	O
while	O
(	O
';'	O
!=	O
g	pointer
->	O
c	int
&&	O
!	O
isspace	function
(	O
g	pointer
->	O
c	int
)	O
)	O
accb	function
(	O
g	pointer
)	O
;	O
p	pointer
=	O
finish_string	function
(	O
g	pointer
->	O
to	pointer
,	O
&	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
)	O
;	O
}	O
if	O
(	O
trailing_garbage	bool
||	O
(	O
must_be_delta_p	bool
&&	O
!	O
(	O
1	int
&	O
dots	long
)	O
)	O
)	O
BUMMER	O
(	O
"invalid %s: %s"	pointer
,	O
ks_revno	array
,	O
p	pointer
)	O
;	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
=	O
p	pointer
;	O
return	O
true	int
;	O
}	O
brush_off	function
(	O
g	pointer
->	O
to	pointer
,	O
p	pointer
)	O
;	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
=	O
""	pointer
;	O
return	O
false	int
;	O
}	O
static	O
void	O
must_read_num	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
char	O
const	O
*	O
role	pointer
)	O
{	O
if	O
(	O
!	O
maybe_read_num	function
(	O
g	pointer
,	O
ks_revno	array
==	O
role	pointer
)	O
)	O
BUMMER	O
(	O
"missing %s"	pointer
,	O
role	pointer
)	O
;	O
}	O
static	O
bool	bool
maybe_read_snippet	function
(	O
struct	O
grok	struct
*	O
g	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
CBEG	O
(	O
"snippet"	pointer
)	O
;	O
skip_whitespace	function
(	O
g	pointer
)	O
;	O
while	O
(	O
';'	O
!=	O
g	pointer
->	O
c	int
&&	O
':'	O
!=	O
g	pointer
->	O
c	int
&&	O
!	O
isspace	function
(	O
g	pointer
->	O
c	int
)	O
&&	O
UNKN	int
!=	O
ctab	array
[	O
g	pointer
->	O
c	int
]	O
)	O
accb	function
(	O
g	pointer
)	O
;	O
p	pointer
=	O
finish_string	function
(	O
g	pointer
->	O
to	pointer
,	O
&	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
)	O
;	O
CEND	O
(	O
)	O
;	O
if	O
(	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
)	O
{	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
=	O
p	pointer
;	O
return	O
true	int
;	O
}	O
brush_off	function
(	O
g	pointer
->	O
to	pointer
,	O
p	pointer
)	O
;	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
=	O
""	pointer
;	O
return	O
false	int
;	O
}	O
static	O
void	O
must_read_snippet	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
char	O
const	O
*	O
role	pointer
)	O
{	O
if	O
(	O
!	O
maybe_read_snippet	function
(	O
g	pointer
)	O
)	O
BUMMER	O
(	O
"missing %s"	pointer
,	O
role	pointer
)	O
;	O
}	O
static	O
void	O
start_atat	function
(	O
struct	O
divvy	struct
*	O
to	pointer
,	O
bool	bool
blankp	bool
)	O
{	O
struct	O
obstack	struct
*	O
o	pointer
=	O
to	pointer
->	O
space	pointer
;	O
if	O
(	O
blankp	bool
)	O
obstack_blank	O
(	O
o	pointer
,	O
sizeof	O
(	O
struct	O
atat	pointer
)	O
)	O
;	O
}	O
static	O
struct	O
atat	pointer
*	O
finish_atat	function
(	O
struct	O
divvy	struct
*	O
to	pointer
)	O
{	O
struct	O
atat	pointer
*	O
rv	bool
;	O
struct	O
obstack	struct
*	O
o	pointer
=	O
to	pointer
->	O
space	pointer
;	O
size_t	long
hsize	long
=	O
obstack_object_size	O
(	O
o	pointer
)	O
-	O
sizeof	O
(	O
struct	O
atat	pointer
)	O
;	O
rv	bool
=	O
obstack_finish	O
(	O
o	pointer
)	O
;	O
rv	bool
->	O
count	long
=	O
hsize	long
/	O
sizeof	O
(	O
off_t	long
)	O
;	O
return	O
rv	bool
;	O
}	O
static	O
bool	bool
maybe_read_atat	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
struct	O
atat	pointer
*	O
*	O
res	pointer
)	O
{	O
struct	O
atat	pointer
*	O
atat	pointer
;	O
off_t	long
beg	pointer
;	O
size_t	long
lno_start	long
;	O
bool	bool
newlinep	bool
=	O
false	int
;	O
CBEG	O
(	O
"atat"	pointer
)	O
;	O
skip_whitespace	function
(	O
g	pointer
)	O
;	O
lno_start	long
=	O
g	pointer
->	O
lno	long
;	O
beg	pointer
=	O
POS	O
(	O
-	O
1	int
)	O
;	O
start_atat	function
(	O
g	pointer
->	O
systolic	pointer
,	O
true	int
)	O
;	O
while	O
(	O
SDELIM	char
==	O
g	pointer
->	O
c	int
)	O
{	O
off_t	long
hole	long
;	O
bool	bool
needexp	bool
=	O
false	int
;	O
MORE	O
(	O
g	pointer
)	O
;	O
while	O
(	O
SDELIM	char
!=	O
g	pointer
->	O
c	int
)	O
{	O
if	O
(	O
WITH_NEEDEXP	int
&&	O
KDELIM	char
==	O
g	pointer
->	O
c	int
)	O
needexp	bool
=	O
true	int
;	O
else	O
if	O
(	O
(	O
newlinep	bool
=	O
(	O
'\n'	O
==	O
g	pointer
->	O
c	int
)	O
)	O
)	O
g	pointer
->	O
lno	long
++	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
}	O
MORE	O
(	O
g	pointer
)	O
;	O
hole	long
=	O
(	O
needexp	bool
?	O
MASK_OFFMSB	O
:	O
0	int
)	O
|	O
POS	O
(	O
SDELIM	char
==	O
g	pointer
->	O
c	int
?	O
-	O
1	int
:	O
-	O
2	int
)	O
;	O
obstack_grow	O
(	O
g	pointer
->	O
systolic	pointer
->	O
space	pointer
,	O
&	O
hole	long
,	O
sizeof	O
(	O
hole	long
)	O
)	O
;	O
}	O
if	O
(	O
(	O
atat	pointer
=	O
finish_atat	function
(	O
g	pointer
->	O
systolic	pointer
)	O
)	O
)	O
{	O
size_t	long
count	long
=	O
atat	pointer
->	O
count	long
;	O
atat	pointer
->	O
lno	long
=	O
lno_start	long
;	O
atat	pointer
->	O
line_count	long
=	O
g	pointer
->	O
lno	long
-	O
atat	pointer
->	O
lno	long
+	O
!	O
newlinep	bool
;	O
atat	pointer
->	O
beg	pointer
=	O
beg	pointer
;	O
atat	pointer
->	O
from	pointer
=	O
g	pointer
->	O
from	pointer
;	O
start_atat	function
(	O
g	pointer
->	O
to	pointer
,	O
false	int
)	O
;	O
*	O
res	pointer
=	O
obstack_copy	O
(	O
g	pointer
->	O
to	pointer
->	O
space	pointer
,	O
atat	pointer
,	O
(	O
sizeof	O
(	O
struct	O
atat	pointer
)	O
+	O
count	long
*	O
sizeof	O
(	O
off_t	long
)	O
)	O
)	O
;	O
}	O
CEND	O
(	O
)	O
;	O
return	O
atat	pointer
;	O
}	O
static	O
void	O
must_read_atat	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
struct	O
atat	pointer
*	O
*	O
res	pointer
,	O
char	O
const	O
*	O
role	pointer
)	O
{	O
if	O
(	O
!	O
maybe_read_atat	function
(	O
g	pointer
,	O
res	pointer
)	O
)	O
BUMMER	O
(	O
"missing %s"	pointer
,	O
role	pointer
)	O
;	O
}	O
static	O
void	O
must_colon_revno	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
char	O
const	O
*	O
role	pointer
)	O
{	O
CBEG	O
(	O
role	pointer
)	O
;	O
CBEG	O
(	O
"colon"	pointer
)	O
;	O
if	O
(	O
':'	O
!=	O
g	pointer
->	O
c	int
)	O
BUMMER	O
(	O
"missing ':' in %s"	pointer
,	O
role	pointer
)	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
CEND	O
(	O
)	O
;	O
must_read_num	function
(	O
g	pointer
,	O
g	pointer
->	O
bor_no	struct
.	O
string	pointer
)	O
;	O
CEND	O
(	O
)	O
;	O
}	O
static	O
void	O
must_semi	function
(	O
struct	O
grok	struct
*	O
g	pointer
,	O
char	O
const	O
*	O
clause	pointer
)	O
{	O
size_t	long
was	long
;	O
was	long
=	O
g	pointer
->	O
lno	long
;	O
skip_whitespace	function
(	O
g	pointer
)	O
;	O
if	O
(	O
';'	O
!=	O
g	pointer
->	O
c	int
)	O
BUMMER	O
(	O
"missing semicolon after `%s'"	pointer
,	O
clause	pointer
)	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
}	O
struct	O
hash	struct
{	O
size_t	long
sz	long
;	O
struct	O
wlink	struct
*	O
*	O
a	pointer
;	O
}	O
;	O
static	O
struct	O
hash	struct
*	O
make_hash_table	function
(	O
struct	O
divvy	struct
*	O
to	pointer
,	O
size_t	long
sz	long
)	O
{	O
struct	O
hash	struct
*	O
ht	pointer
=	O
alloc	function
(	O
to	pointer
,	O
"hash-table"	pointer
,	O
sizeof	O
(	O
struct	O
hash	struct
)	O
)	O
;	O
ht	pointer
->	O
sz	long
=	O
sz	long
;	O
ht	pointer
->	O
a	pointer
=	O
zlloc	function
(	O
to	pointer
,	O
"hash-table buckets"	pointer
,	O
sz	long
*	O
sizeof	O
(	O
struct	O
wlink	struct
*	O
)	O
)	O
;	O
return	O
ht	pointer
;	O
}	O
static	O
size_t	long
hash	struct
(	O
char	O
const	O
*	O
key	pointer
,	O
struct	O
hash	struct
*	O
ht	pointer
)	O
{	O
return	O
hash_pjw	function
(	O
key	pointer
,	O
ht	pointer
->	O
sz	long
)	O
;	O
}	O
static	O
void	O
puthash	function
(	O
struct	O
divvy	struct
*	O
to	pointer
,	O
struct	O
notyet	struct
*	O
ny	pointer
,	O
struct	O
hash	struct
*	O
ht	pointer
)	O
{	O
size_t	long
slot	long
=	O
hash	struct
(	O
ny	pointer
->	O
revno	pointer
,	O
ht	pointer
)	O
;	O
struct	O
wlink	struct
box	struct
,	O
*	O
tp	pointer
,	O
*	O
cur	pointer
;	O
box	struct
.	O
next	pointer
=	O
ht	pointer
->	O
a	pointer
[	O
slot	long
]	O
;	O
tp	pointer
=	O
&	O
box	struct
;	O
while	O
(	O
(	O
cur	pointer
=	O
tp	pointer
->	O
next	pointer
)	O
)	O
{	O
struct	O
notyet	struct
*	O
maybe	struct
=	O
cur	pointer
->	O
entry	pointer
;	O
if	O
(	O
STR_SAME	O
(	O
ny	pointer
->	O
revno	pointer
,	O
maybe	struct
->	O
revno	pointer
)	O
)	O
{	O
tp	pointer
->	O
entry	pointer
=	O
ny	pointer
;	O
return	O
;	O
}	O
tp	pointer
=	O
tp	pointer
->	O
next	pointer
;	O
}	O
tp	pointer
=	O
wextend	function
(	O
tp	pointer
,	O
ny	pointer
,	O
to	pointer
)	O
;	O
ht	pointer
->	O
a	pointer
[	O
slot	long
]	O
=	O
box	struct
.	O
next	pointer
;	O
}	O
static	O
void	O
*	O
gethash	function
(	O
char	O
const	O
*	O
revno	pointer
,	O
struct	O
hash	struct
*	O
ht	pointer
)	O
{	O
size_t	long
slot	long
=	O
hash	struct
(	O
revno	pointer
,	O
ht	pointer
)	O
;	O
for	O
(	O
struct	O
wlink	struct
*	O
ls	pointer
=	O
ht	pointer
->	O
a	pointer
[	O
slot	long
]	O
;	O
ls	pointer
;	O
ls	pointer
=	O
ls	pointer
->	O
next	pointer
)	O
{	O
struct	O
notyet	struct
*	O
ny	pointer
=	O
ls	pointer
->	O
entry	pointer
;	O
if	O
(	O
STR_SAME	O
(	O
revno	pointer
,	O
ny	pointer
->	O
revno	pointer
)	O
)	O
return	O
ny	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
fwref	struct
{	O
char	O
const	O
*	O
revno	pointer
;	O
size_t	long
lno	long
;	O
}	O
;	O
struct	O
repo	struct
*	O
empty_repo	function
(	O
struct	O
divvy	struct
*	O
to	pointer
)	O
{	O
struct	O
repo	struct
*	O
repo	struct
=	O
zlloc	function
(	O
to	pointer
,	O
"repo"	pointer
,	O
sizeof	O
(	O
struct	O
repo	struct
)	O
)	O
;	O
repo	struct
->	O
strict	bool
=	O
STRICT_LOCKING	O
;	O
repo	struct
->	O
expand	int
=	O
-	O
1	int
;	O
repo	struct
->	O
neck	long
=	O
-	O
1	int
;	O
return	O
repo	struct
;	O
}	O
static	O
const	O
char	O
ks_ner	array
[	O
]	O
=	O
"non-existent revision"	pointer
;	O
static	O
struct	O
repo	struct
*	O
full	function
(	O
struct	O
divvy	struct
*	O
to	pointer
,	O
struct	O
fro	struct
*	O
f	pointer
)	O
{	O
off_t	long
neck	long
;	O
size_t	long
count	long
;	O
struct	O
link	function
box	struct
,	O
*	O
tp	pointer
;	O
struct	O
wlink	struct
*	O
follow	pointer
;	O
struct	O
wlink	struct
*	O
all_br	pointer
=	O
NULL	O
;	O
struct	O
grok	struct
*	O
g	pointer
=	O
FZLLOC	O
(	O
struct	O
grok	struct
)	O
;	O
struct	O
repo	struct
*	O
repo	struct
=	O
empty_repo	function
(	O
to	pointer
)	O
;	O
repo	struct
->	O
ht	pointer
=	O
make_hash_table	function
(	O
to	pointer
,	O
NSLOTS	int
)	O
;	O
g	pointer
->	O
from	pointer
=	O
f	pointer
;	O
g	pointer
->	O
to	pointer
=	O
to	pointer
;	O
g	pointer
->	O
systolic	pointer
=	O
make_space	function
(	O
"systolic"	pointer
)	O
;	O
g	pointer
->	O
tranquil	pointer
=	O
make_space	function
(	O
"tranquil"	pointer
)	O
;	O
g	pointer
->	O
lno	long
=	O
1	int
;	O
accf	function
(	O
g	pointer
->	O
tranquil	pointer
,	O
"branch or %s"	pointer
,	O
ks_revno	array
)	O
;	O
g	pointer
->	O
bor_no	struct
.	O
string	pointer
=	O
finish_string	function
(	O
g	pointer
->	O
tranquil	pointer
,	O
&	O
g	pointer
->	O
bor_no	struct
.	O
size	long
)	O
;	O
MORE	O
(	O
g	pointer
)	O
;	O
CBEG	O
(	O
"admin node"	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
head	pointer
)	O
;	O
if	O
(	O
MAYBE_REVNO	O
(	O
g	pointer
)	O
)	O
g	pointer
->	O
head_lno	long
=	O
g	pointer
->	O
lno	long
,	O
STASH	O
(	O
repo	struct
->	O
head	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
head	pointer
)	O
;	O
if	O
(	O
probe_keyword	function
(	O
g	pointer
,	O
&	O
TINY	O
(	O
branch	pointer
)	O
)	O
)	O
{	O
if	O
(	O
maybe_read_num	function
(	O
g	pointer
,	O
false	int
)	O
)	O
STASH	O
(	O
repo	struct
->	O
branch	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
branch	pointer
)	O
;	O
}	O
SYNCH	O
(	O
g	pointer
,	O
access	pointer
)	O
;	O
for	O
(	O
PREP	O
(	O
access	pointer
)	O
;	O
maybe_read_snippet	function
(	O
g	pointer
)	O
;	O
count	long
++	O
)	O
HANG	O
(	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
)	O
;	O
DONE	O
(	O
access	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
access	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
symbols	pointer
)	O
;	O
for	O
(	O
PREP	O
(	O
symbols	pointer
)	O
;	O
maybe_read_snippet	function
(	O
g	pointer
)	O
;	O
count	long
++	O
)	O
{	O
struct	O
symdef	struct
*	O
sym	pointer
=	O
STRUCTALLOC	O
(	O
to	pointer
,	O
struct	O
symdef	struct
)	O
;	O
STASH	O
(	O
sym	pointer
->	O
meaningful	pointer
)	O
;	O
must_colon_revno	function
(	O
g	pointer
,	O
"symbolic name definition"	pointer
)	O
;	O
STASH	O
(	O
sym	pointer
->	O
underlying	pointer
)	O
;	O
HANG	O
(	O
sym	pointer
)	O
;	O
}	O
DONE	O
(	O
symbols	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
symbols	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
locks	pointer
)	O
;	O
for	O
(	O
PREP	O
(	O
locks	pointer
)	O
;	O
maybe_read_snippet	function
(	O
g	pointer
)	O
;	O
count	long
++	O
)	O
{	O
struct	O
lockdef	struct
*	O
lock	pointer
=	O
STRUCTALLOC	O
(	O
to	pointer
,	O
struct	O
lockdef	struct
)	O
;	O
STASH	O
(	O
lock	pointer
->	O
login	pointer
)	O
;	O
must_colon_revno	function
(	O
g	pointer
,	O
"locker definition"	pointer
)	O
;	O
STASH	O
(	O
lock	pointer
->	O
revno	pointer
)	O
;	O
HANG	O
(	O
lock	pointer
)	O
;	O
}	O
DONE	O
(	O
locks	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
locks	pointer
)	O
;	O
repo	struct
->	O
lockdefs	pointer
=	O
alloc	function
(	O
to	pointer
,	O
"locker definition"	pointer
,	O
count	long
*	O
sizeof	O
(	O
struct	O
lockdef	struct
)	O
)	O
;	O
for	O
(	O
tp	pointer
=	O
repo	struct
->	O
locks	pointer
;	O
count	long
--	O
;	O
tp	pointer
=	O
tp	pointer
->	O
next	pointer
)	O
{	O
struct	O
lockdef	struct
const	O
*	O
orig	pointer
=	O
tp	pointer
->	O
entry	pointer
;	O
repo	struct
->	O
lockdefs	pointer
[	O
count	long
]	O
=	O
*	O
orig	pointer
;	O
}	O
if	O
(	O
(	O
repo	struct
->	O
strict	bool
=	O
probe_keyword	function
(	O
g	pointer
,	O
&	O
TINY	O
(	O
strict	bool
)	O
)	O
)	O
)	O
SEMI	int
(	O
g	pointer
,	O
strict	bool
)	O
;	O
if	O
(	O
probe_keyword	function
(	O
g	pointer
,	O
&	O
TINY	O
(	O
integrity	pointer
)	O
)	O
)	O
{	O
maybe_read_atat	function
(	O
g	pointer
,	O
&	O
repo	struct
->	O
integrity	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
integrity	pointer
)	O
;	O
}	O
if	O
(	O
probe_keyword	function
(	O
g	pointer
,	O
&	O
TINY	O
(	O
comment	pointer
)	O
)	O
)	O
{	O
maybe_read_atat	function
(	O
g	pointer
,	O
&	O
repo	struct
->	O
comment	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
comment	pointer
)	O
;	O
}	O
repo	struct
->	O
expand	int
=	O
-	O
1	int
;	O
if	O
(	O
probe_keyword	function
(	O
g	pointer
,	O
&	O
TINY	O
(	O
expand	int
)	O
)	O
)	O
{	O
struct	O
atat	pointer
*	O
expand	int
;	O
if	O
(	O
maybe_read_atat	function
(	O
g	pointer
,	O
&	O
expand	int
)	O
)	O
{	O
struct	O
cbuf	struct
cb	pointer
=	O
string_from_atat	function
(	O
g	pointer
->	O
systolic	pointer
,	O
expand	int
)	O
;	O
if	O
(	O
PROB	O
(	O
repo	struct
->	O
expand	int
=	O
recognize_kwsub	function
(	O
&	O
cb	pointer
)	O
)	O
)	O
BUMMER	O
(	O
"invalid expand mode: %s"	pointer
,	O
cb	pointer
.	O
string	pointer
)	O
;	O
}	O
SEMI	int
(	O
g	pointer
,	O
expand	int
)	O
;	O
}	O
CBEG	O
(	O
"revisions"	pointer
)	O
;	O
{	O
struct	O
wlink	struct
wbox	struct
,	O
*	O
wtp	pointer
;	O
struct	O
notyet	struct
*	O
prev	struct
=	O
NULL	O
;	O
struct	O
fwref	struct
*	O
fw	pointer
;	O
for	O
(	O
count	long
=	O
0	int
,	O
wbox	struct
.	O
next	pointer
=	O
repo	struct
->	O
deltas	pointer
,	O
wtp	pointer
=	O
&	O
wbox	struct
;	O
MAYBE_REVNO	O
(	O
g	pointer
)	O
;	O
count	long
++	O
)	O
{	O
struct	O
notyet	struct
*	O
ny	pointer
=	O
STRUCTALLOC	O
(	O
to	pointer
,	O
struct	O
notyet	struct
)	O
;	O
struct	O
delta	struct
*	O
d	pointer
=	O
ny	pointer
->	O
d	pointer
=	O
STRUCTALLOC	O
(	O
to	pointer
,	O
struct	O
delta	struct
)	O
;	O
size_t	long
numlen	long
=	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
;	O
STASH	O
(	O
d	pointer
->	O
num	pointer
)	O
;	O
if	O
(	O
prev	struct
&&	O
!	O
prev	struct
->	O
next	pointer
&&	O
2	int
<=	O
countnumflds	function
(	O
d	pointer
->	O
num	pointer
)	O
)	O
{	O
struct	O
wlink	struct
*	O
ls	pointer
;	O
for	O
(	O
ls	pointer
=	O
all_br	pointer
;	O
ls	pointer
;	O
ls	pointer
=	O
ls	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
fw	pointer
=	O
ls	pointer
->	O
entry	pointer
)	O
->	O
lno	long
&&	O
STR_SAME	O
(	O
d	pointer
->	O
num	pointer
,	O
fw	pointer
->	O
revno	pointer
)	O
)	O
{	O
fw	pointer
->	O
lno	long
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
ls	pointer
)	O
BUMMER	O
(	O
"unexpected new branch %s: %s"	pointer
,	O
ks_revno	array
,	O
d	pointer
->	O
num	pointer
)	O
;	O
}	O
d	pointer
->	O
branches	pointer
=	O
NULL	O
;	O
d	pointer
->	O
ilk	pointer
=	O
NULL	O
;	O
d	pointer
->	O
lockedby	pointer
=	O
NULL	O
;	O
d	pointer
->	O
pretty_log	struct
.	O
string	pointer
=	O
NULL	O
;	O
d	pointer
->	O
pretty_log	struct
.	O
size	long
=	O
0	int
;	O
d	pointer
->	O
selector	bool
=	O
true	int
;	O
d	pointer
->	O
log	pointer
=	O
NULL	O
;	O
STASH	O
(	O
ny	pointer
->	O
revno	pointer
)	O
;	O
CBEG	O
(	O
ny	pointer
->	O
revno	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
date	pointer
)	O
;	O
must_read_num	function
(	O
g	pointer
,	O
"date"	pointer
)	O
;	O
STASH	O
(	O
d	pointer
->	O
date	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
date	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
author	pointer
)	O
;	O
MUST_SNIPPET	O
(	O
g	pointer
,	O
author	pointer
)	O
;	O
STASH	O
(	O
d	pointer
->	O
author	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
author	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
state	pointer
)	O
;	O
MUST_SNIPPET	O
(	O
g	pointer
,	O
state	pointer
)	O
;	O
STASH	O
(	O
d	pointer
->	O
state	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
state	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
branches	pointer
)	O
;	O
box	struct
.	O
next	pointer
=	O
NULL	O
,	O
tp	pointer
=	O
&	O
box	struct
;	O
while	O
(	O
MAYBE_REVNO	O
(	O
g	pointer
)	O
)	O
{	O
if	O
(	O
numlen	long
>=	O
XREP	O
(	O
g	pointer
)	O
.	O
size	long
||	O
strncmp	function
(	O
d	pointer
->	O
num	pointer
,	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
,	O
numlen	long
)	O
||	O
'.'	O
!=	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
[	O
numlen	long
]	O
||	O
2	int
!=	O
countnumflds	function
(	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
+	O
numlen	long
+	O
1	int
)	O
)	O
BUMMER	O
(	O
"invalid branch `%s' at branchpoint `%s'"	pointer
,	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
,	O
d	pointer
->	O
num	pointer
)	O
;	O
fw	pointer
=	O
STRUCTALLOC	O
(	O
g	pointer
->	O
tranquil	pointer
,	O
struct	O
fwref	struct
)	O
;	O
fw	pointer
->	O
revno	pointer
=	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
;	O
fw	pointer
->	O
lno	long
=	O
g	pointer
->	O
lno	long
;	O
all_br	pointer
=	O
wprepend	function
(	O
fw	pointer
,	O
all_br	pointer
,	O
g	pointer
->	O
tranquil	pointer
)	O
;	O
HANG	O
(	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
)	O
;	O
}	O
ny	pointer
->	O
branches	pointer
=	O
box	struct
.	O
next	pointer
;	O
SEMI	int
(	O
g	pointer
,	O
branches	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
next	pointer
)	O
;	O
if	O
(	O
MAYBE_REVNO	O
(	O
g	pointer
)	O
)	O
STASH	O
(	O
ny	pointer
->	O
next	pointer
)	O
;	O
else	O
ny	pointer
->	O
next	pointer
=	O
NULL	O
;	O
SEMI	int
(	O
g	pointer
,	O
next	pointer
)	O
;	O
if	O
(	O
probe_keyword	function
(	O
g	pointer
,	O
&	O
TINY	O
(	O
commitid	pointer
)	O
)	O
)	O
{	O
MUST_SNIPPET	O
(	O
g	pointer
,	O
commitid	pointer
)	O
;	O
STASH	O
(	O
d	pointer
->	O
commitid	pointer
)	O
;	O
checkssym	function
(	O
d	pointer
->	O
commitid	pointer
)	O
;	O
SEMI	int
(	O
g	pointer
,	O
commitid	pointer
)	O
;	O
}	O
else	O
d	pointer
->	O
commitid	pointer
=	O
NULL	O
;	O
CEND	O
(	O
)	O
;	O
wtp	pointer
=	O
wextend	function
(	O
wtp	pointer
,	O
ny	pointer
,	O
to	pointer
)	O
;	O
puthash	function
(	O
to	pointer
,	O
ny	pointer
,	O
repo	struct
->	O
ht	pointer
)	O
;	O
prev	struct
=	O
ny	pointer
;	O
}	O
for	O
(	O
;	O
all_br	pointer
;	O
all_br	pointer
=	O
all_br	pointer
->	O
next	pointer
)	O
if	O
(	O
(	O
fw	pointer
=	O
all_br	pointer
->	O
entry	pointer
)	O
->	O
lno	long
)	O
{	O
g	pointer
->	O
lno	long
=	O
fw	pointer
->	O
lno	long
;	O
BUMMER	O
(	O
"branch refers to %s `%s'"	pointer
,	O
ks_ner	array
,	O
fw	pointer
->	O
revno	pointer
)	O
;	O
}	O
repo	struct
->	O
deltas	pointer
=	O
wbox	struct
.	O
next	pointer
;	O
repo	struct
->	O
deltas_count	long
=	O
count	long
;	O
}	O
CEND	O
(	O
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
desc	pointer
)	O
;	O
repo	struct
->	O
neck	long
=	O
fro_tello	function
(	O
g	pointer
->	O
from	pointer
)	O
;	O
MUST_ATAT	O
(	O
g	pointer
,	O
&	O
repo	struct
->	O
desc	pointer
,	O
desc	pointer
)	O
;	O
CEND	O
(	O
)	O
;	O
for	O
(	O
struct	O
lockdef	struct
const	O
*	O
lock	pointer
=	O
repo	struct
->	O
lockdefs	pointer
;	O
lock	pointer
<	O
repo	struct
->	O
lockdefs	pointer
+	O
repo	struct
->	O
locks_count	long
;	O
lock	pointer
++	O
)	O
{	O
struct	O
notyet	struct
*	O
ny	pointer
=	O
FIND_NY	O
(	O
lock	pointer
->	O
revno	pointer
)	O
;	O
if	O
(	O
!	O
ny	pointer
)	O
{	O
RWARN	O
(	O
"user `%s' holds a lock for %s `%s'"	pointer
,	O
lock	pointer
->	O
login	pointer
,	O
ks_ner	array
,	O
lock	pointer
->	O
revno	pointer
)	O
;	O
ny	pointer
=	O
zlloc	function
(	O
to	pointer
,	O
"dummy ny"	pointer
,	O
sizeof	O
(	O
struct	O
notyet	struct
)	O
)	O
;	O
ny	pointer
->	O
d	pointer
=	O
zlloc	function
(	O
to	pointer
,	O
"dummy delta"	pointer
,	O
sizeof	O
(	O
struct	O
delta	struct
)	O
)	O
;	O
ny	pointer
->	O
revno	pointer
=	O
ny	pointer
->	O
d	pointer
->	O
num	pointer
=	O
lock	pointer
->	O
revno	pointer
;	O
puthash	function
(	O
to	pointer
,	O
ny	pointer
,	O
repo	struct
->	O
ht	pointer
)	O
;	O
}	O
}	O
CBEG	O
(	O
"edits"	pointer
)	O
;	O
for	O
(	O
count	long
=	O
0	int
,	O
follow	pointer
=	O
repo	struct
->	O
deltas	pointer
;	O
(	O
neck	long
=	O
fro_tello	function
(	O
g	pointer
->	O
from	pointer
)	O
)	O
&&	O
count	long
<	O
repo	struct
->	O
deltas_count	long
;	O
count	long
++	O
)	O
{	O
char	O
const	O
*	O
revno	pointer
;	O
struct	O
notyet	struct
*	O
ny	pointer
;	O
struct	O
delta	struct
*	O
d	pointer
;	O
MUST_REVNO	O
(	O
g	pointer
)	O
;	O
revno	pointer
=	O
XREP	O
(	O
g	pointer
)	O
.	O
string	pointer
;	O
CBEG	O
(	O
revno	pointer
)	O
;	O
if	O
(	O
!	O
(	O
ny	pointer
=	O
FIND_NY	O
(	O
revno	pointer
)	O
)	O
)	O
BUMMER	O
(	O
"found edits for %s `%s'"	pointer
,	O
ks_ner	array
,	O
revno	pointer
)	O
;	O
follow	pointer
->	O
entry	pointer
=	O
ny	pointer
;	O
follow	pointer
=	O
follow	pointer
->	O
next	pointer
;	O
d	pointer
=	O
ny	pointer
->	O
d	pointer
;	O
if	O
(	O
d	pointer
->	O
log	pointer
)	O
BUMMER	O
(	O
"duplicate delta log for %s `%s'"	pointer
,	O
ks_revno	array
,	O
d	pointer
->	O
num	pointer
)	O
;	O
d	pointer
->	O
neck	long
=	O
neck	long
;	O
SYNCH	O
(	O
g	pointer
,	O
log	pointer
)	O
;	O
MUST_ATAT	O
(	O
g	pointer
,	O
&	O
d	pointer
->	O
log	pointer
,	O
log	pointer
)	O
;	O
SYNCH	O
(	O
g	pointer
,	O
text	pointer
)	O
;	O
MUST_ATAT	O
(	O
g	pointer
,	O
&	O
d	pointer
->	O
text	pointer
,	O
text	pointer
)	O
;	O
CEND	O
(	O
)	O
;	O
}	O
CEND	O
(	O
)	O
;	O
CBEG	O
(	O
"clean tail"	pointer
)	O
;	O
while	O
(	O
isspace	function
(	O
g	pointer
->	O
c	int
)	O
)	O
{	O
if	O
(	O
'\n'	O
==	O
g	pointer
->	O
c	int
)	O
g	pointer
->	O
lno	long
++	O
;	O
GETCHAR_OR	O
(	O
g	pointer
->	O
c	int
,	O
g	pointer
->	O
from	pointer
,	O
goto	O
ok	O
)	O
;	O
}	O
BUMMER	O
(	O
"junk at end of file: '%c'"	pointer
,	O
g	pointer
->	O
c	int
)	O
;	O
ok	O
:	O
CEND	O
(	O
)	O
;	O
if	O
(	O
repo	struct
->	O
head	pointer
&&	O
!	O
FIND_NY	O
(	O
repo	struct
->	O
head	pointer
)	O
)	O
fatal_syntax	function
(	O
g	pointer
->	O
head_lno	long
,	O
"RCS file head names a %s `%s'"	pointer
,	O
ks_ner	array
,	O
repo	struct
->	O
head	pointer
)	O
;	O
for	O
(	O
struct	O
wlink	struct
*	O
ls	pointer
=	O
repo	struct
->	O
deltas	pointer
;	O
ls	pointer
;	O
ls	pointer
=	O
ls	pointer
->	O
next	pointer
)	O
{	O
struct	O
notyet	struct
*	O
ny	pointer
=	O
ls	pointer
->	O
entry	pointer
,	O
*	O
deref	pointer
;	O
struct	O
delta	struct
*	O
d	pointer
=	O
ny	pointer
->	O
d	pointer
;	O
if	O
(	O
ny	pointer
->	O
next	pointer
)	O
d	pointer
->	O
ilk	pointer
=	O
FIND_D	O
(	O
ny	pointer
->	O
next	pointer
)	O
;	O
if	O
(	O
ny	pointer
->	O
branches	pointer
)	O
{	O
struct	O
link	function
*	O
bls	pointer
;	O
struct	O
wlink	struct
wbox	struct
,	O
*	O
wtp	pointer
;	O
for	O
(	O
bls	pointer
=	O
ny	pointer
->	O
branches	pointer
,	O
wbox	struct
.	O
next	pointer
=	O
d	pointer
->	O
branches	pointer
,	O
wtp	pointer
=	O
&	O
wbox	struct
;	O
bls	pointer
;	O
bls	pointer
=	O
bls	pointer
->	O
next	pointer
)	O
wtp	pointer
=	O
wextend	function
(	O
wtp	pointer
,	O
FIND_D	O
(	O
bls	pointer
->	O
entry	pointer
)	O
,	O
to	pointer
)	O
;	O
d	pointer
->	O
branches	pointer
=	O
wbox	struct
.	O
next	pointer
;	O
}	O
ls	pointer
->	O
entry	pointer
=	O
d	pointer
;	O
}	O
close_space	function
(	O
g	pointer
->	O
systolic	pointer
)	O
;	O
close_space	function
(	O
g	pointer
->	O
tranquil	pointer
)	O
;	O
return	O
repo	struct
;	O
}	O
struct	O
repo	struct
*	O
grok_all	function
(	O
struct	O
divvy	struct
*	O
to	pointer
,	O
struct	O
fro	struct
*	O
f	pointer
)	O
{	O
struct	O
repo	struct
*	O
repo	struct
=	O
full	function
(	O
to	pointer
,	O
f	pointer
)	O
;	O
grok_resynch	function
(	O
repo	struct
)	O
;	O
return	O
repo	struct
;	O
}	O
void	O
grok_resynch	function
(	O
struct	O
repo	struct
*	O
repo	struct
)	O
{	O
struct	O
notyet	struct
*	O
ny	pointer
;	O
REPO	O
(	O
tip	pointer
)	O
=	O
repo	struct
->	O
head	pointer
&&	O
(	O
ny	pointer
=	O
FIND_NY	O
(	O
repo	struct
->	O
head	pointer
)	O
)	O
?	O
ny	pointer
->	O
d	pointer
:	O
NULL	O
;	O
repo	struct
->	O
locks	pointer
=	O
NULL	O
;	O
for	O
(	O
struct	O
lockdef	struct
const	O
*	O
orig	pointer
=	O
repo	struct
->	O
lockdefs	pointer
+	O
repo	struct
->	O
locks_count	long
;	O
repo	struct
->	O
lockdefs	pointer
<	O
orig	pointer
--	O
&&	O
(	O
ny	pointer
=	O
FIND_NY	O
(	O
orig	pointer
->	O
revno	pointer
)	O
)	O
;	O
)	O
{	O
struct	O
delta	struct
*	O
d	pointer
=	O
ny	pointer
->	O
d	pointer
;	O
struct	O
rcslock	struct
*	O
rl	pointer
=	O
FALLOC	O
(	O
struct	O
rcslock	struct
)	O
;	O
rl	pointer
->	O
login	pointer
=	O
d	pointer
->	O
lockedby	pointer
=	O
orig	pointer
->	O
login	pointer
;	O
rl	pointer
->	O
delta	struct
=	O
d	pointer
;	O
repo	struct
->	O
locks	pointer
=	O
prepend	function
(	O
rl	pointer
,	O
repo	struct
->	O
locks	pointer
,	O
SINGLE	O
)	O
;	O
}	O
BE	O
(	O
strictly_locking	bool
)	O
=	O
repo	struct
->	O
strict	bool
;	O
if	O
(	O
repo	struct
->	O
comment	pointer
)	O
REPO	O
(	O
log_lead	struct
)	O
=	O
string_from_atat	function
(	O
SINGLE	O
,	O
repo	struct
->	O
comment	pointer
)	O
;	O
else	O
clear_buf	O
(	O
&	O
REPO	O
(	O
log_lead	struct
)	O
)	O
;	O
BE	O
(	O
kws	int
)	O
=	O
PROB	O
(	O
repo	struct
->	O
expand	int
)	O
?	O
kwsub_kv	int
:	O
repo	struct
->	O
expand	int
;	O
}	O
