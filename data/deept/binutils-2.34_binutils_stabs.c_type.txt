struct	O
stab_handle	struct
{	O
bfd	struct
*	O
abfd	pointer
;	O
bfd_boolean	int
sections	pointer
;	O
asymbol	struct
*	O
*	O
syms	pointer
;	O
long	O
symcount	int
;	O
char	O
*	O
so_string	pointer
;	O
bfd_vma	long
so_value	long
;	O
bfd_vma	long
file_start_offset	long
;	O
bfd_vma	long
function_start_offset	long
;	O
int	O
gcc_compiled	int
;	O
bfd_boolean	int
n_opt_found	int
;	O
char	O
*	O
main_filename	pointer
;	O
struct	O
bincl_file	struct
*	O
bincl_stack	pointer
;	O
struct	O
bincl_file	struct
*	O
bincl_list	pointer
;	O
bfd_boolean	int
within_function	int
;	O
bfd_vma	long
function_end	long
;	O
int	O
block_depth	int
;	O
struct	O
stab_pending_var	struct
*	O
pending	pointer
;	O
unsigned	O
int	O
files	int
;	O
struct	O
stab_types	struct
*	O
*	O
file_types	pointer
;	O
debug_type	pointer
xcoff_types	array
[	O
XCOFF_TYPE_COUNT	int
]	O
;	O
struct	O
stab_tag	struct
*	O
tags	pointer
;	O
bfd_boolean	int
self_crossref	int
;	O
}	O
;	O
struct	O
stab_pending_var	struct
{	O
struct	O
stab_pending_var	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
debug_type	pointer
type	enum
;	O
enum	O
debug_var_kind	enum
kind	enum
;	O
bfd_vma	long
val	array
;	O
}	O
;	O
struct	O
stab_types	struct
{	O
struct	O
stab_types	struct
*	O
next	pointer
;	O
debug_type	pointer
types	array
[	O
STAB_TYPES_SLOTS	O
]	O
;	O
}	O
;	O
struct	O
stab_tag	struct
{	O
struct	O
stab_tag	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
enum	O
debug_type_kind	enum
kind	enum
;	O
debug_type	pointer
slot	pointer
;	O
debug_type	pointer
type	enum
;	O
}	O
;	O
static	O
char	O
*	O
savestring	function
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
static	O
void	O
bad_stab	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
warn_stab	function
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_string	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
int	O
,	O
int	O
,	O
bfd_vma	long
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	pointer
parse_stab_type	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	pointer
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_type_number	function
(	O
const	O
char	O
*	O
*	O
,	O
int	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	pointer
parse_stab_range_type	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
int	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	pointer
parse_stab_sun_builtin_type	function
(	O
void	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	pointer
parse_stab_sun_floating_type	function
(	O
void	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	pointer
parse_stab_enum_type	function
(	O
void	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	pointer
parse_stab_struct_type	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
bfd_boolean	int
,	O
const	O
int	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_baseclasses	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_baseclass	pointer
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_struct_fields	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_field	pointer
*	O
*	O
,	O
bfd_boolean	int
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_cpp_abbrev	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_field	pointer
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_one_struct_field	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
,	O
debug_field	pointer
*	O
,	O
bfd_boolean	int
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_members	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
int	O
*	O
,	O
debug_method	pointer
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	pointer
parse_stab_argtypes	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
debug_type	pointer
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
debug_type	pointer
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
,	O
const	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
parse_stab_tilde_field	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
int	O
*	O
,	O
debug_type	pointer
*	O
,	O
bfd_boolean	int
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
debug_type	pointer
parse_stab_array_type	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
bfd_boolean	int
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
push_bincl	function
(	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
const	O
char	O
*	O
pop_bincl	function
(	O
struct	O
stab_handle	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
find_excl	function
(	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
stab_record_variable	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
debug_type	pointer
,	O
enum	O
debug_var_kind	enum
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
stab_emit_pending_vars	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
)	O
;	O
static	O
debug_type	pointer
*	O
stab_find_slot	function
(	O
struct	O
stab_handle	struct
*	O
,	O
const	O
int	O
*	O
)	O
;	O
static	O
debug_type	pointer
stab_find_type	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
int	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_record_type	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
int	O
*	O
,	O
debug_type	pointer
)	O
;	O
static	O
debug_type	pointer
stab_xcoff_builtin_type	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
int	O
)	O
;	O
static	O
debug_type	pointer
stab_find_tagged_type	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
int	O
,	O
enum	O
debug_type_kind	enum
)	O
;	O
static	O
debug_type	pointer
*	O
stab_demangle_argtypes	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
debug_type	pointer
*	O
stab_demangle_v3_argtypes	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
debug_type	pointer
*	O
stab_demangle_v3_arglist	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
struct	O
demangle_component	struct
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
debug_type	pointer
stab_demangle_v3_arg	function
(	O
void	O
*	O
,	O
struct	O
stab_handle	struct
*	O
,	O
struct	O
demangle_component	struct
*	O
,	O
debug_type	pointer
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
int	O
demangle_flags	int
=	O
DMGL_ANSI	O
;	O
static	O
char	O
*	O
savestring	function
(	O
const	O
char	O
*	O
start	pointer
,	O
int	O
len	long
)	O
{	O
char	O
*	O
ret	pointer
;	O
ret	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
ret	pointer
,	O
start	pointer
,	O
len	long
)	O
;	O
ret	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_vma	long
parse_number	function
(	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
bfd_boolean	int
*	O
poverflow	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
unsigned	O
long	O
ul	long
;	O
const	O
char	O
*	O
orig	pointer
;	O
if	O
(	O
poverflow	pointer
!=	O
NULL	O
)	O
*	O
poverflow	pointer
=	O
FALSE	int
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
(	O
bfd_vma	long
)	O
0	int
;	O
if	O
(	O
*	O
orig	pointer
==	O
0	int
)	O
return	O
(	O
bfd_vma	long
)	O
0	int
;	O
errno	O
=	O
0	int
;	O
ul	long
=	O
strtoul	function
(	O
*	O
pp	pointer
,	O
(	O
char	O
*	O
*	O
)	O
pp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ul	long
+	O
1	int
!=	O
0	int
||	O
errno	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
orig	pointer
==	O
'-'	O
)	O
return	O
(	O
bfd_vma	long
)	O
(	O
bfd_signed_vma	long
)	O
(	O
long	O
)	O
ul	long
;	O
return	O
(	O
bfd_vma	long
)	O
ul	long
;	O
}	O
if	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
>	O
sizeof	O
(	O
unsigned	O
long	O
)	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
bfd_boolean	int
neg	int
;	O
int	O
base	int
;	O
bfd_vma	long
over	long
,	O
lastdig	long
;	O
bfd_boolean	int
overflow	int
;	O
bfd_vma	long
v	long
;	O
p	pointer
=	O
orig	pointer
;	O
neg	int
=	O
FALSE	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
)	O
++	O
p	pointer
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'-'	O
)	O
{	O
neg	int
=	O
TRUE	int
;	O
++	O
p	pointer
;	O
}	O
base	int
=	O
10	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'0'	O
)	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'x'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'X'	O
)	O
{	O
base	int
=	O
16	int
;	O
p	pointer
+=	O
2	int
;	O
}	O
else	O
{	O
base	int
=	O
8	int
;	O
++	O
p	pointer
;	O
}	O
}	O
over	long
=	O
(	O
(	O
bfd_vma	long
)	O
(	O
bfd_signed_vma	long
)	O
-	O
1	int
)	O
/	O
(	O
bfd_vma	long
)	O
base	int
;	O
lastdig	long
=	O
(	O
(	O
bfd_vma	long
)	O
(	O
bfd_signed_vma	long
)	O
-	O
1	int
)	O
%	O
(	O
bfd_vma	long
)	O
base	int
;	O
overflow	int
=	O
FALSE	int
;	O
v	long
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
d	int
;	O
d	int
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
ISDIGIT	O
(	O
d	int
)	O
)	O
d	int
-=	O
'0'	O
;	O
else	O
if	O
(	O
ISUPPER	O
(	O
d	int
)	O
)	O
d	int
-=	O
'A'	O
;	O
else	O
if	O
(	O
ISLOWER	O
(	O
d	int
)	O
)	O
d	int
-=	O
'a'	O
;	O
else	O
break	O
;	O
if	O
(	O
d	int
>=	O
base	int
)	O
break	O
;	O
if	O
(	O
v	long
>	O
over	long
||	O
(	O
v	long
==	O
over	long
&&	O
(	O
bfd_vma	long
)	O
d	int
>	O
lastdig	long
)	O
)	O
{	O
overflow	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
overflow	int
)	O
{	O
if	O
(	O
neg	int
)	O
v	long
=	O
-	O
v	long
;	O
return	O
v	long
;	O
}	O
}	O
if	O
(	O
poverflow	pointer
!=	O
NULL	O
)	O
*	O
poverflow	pointer
=	O
TRUE	int
;	O
else	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"numeric overflow"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
bad_stab	function
(	O
const	O
char	O
*	O
p	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Bad stab: %s\n"	pointer
)	O
,	O
p	pointer
)	O
;	O
}	O
static	O
void	O
warn_stab	function
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
err	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Warning: %s: %s\n"	pointer
)	O
,	O
err	pointer
,	O
p	pointer
)	O
;	O
}	O
void	O
*	O
start_stab	function
(	O
void	O
*	O
dhandle	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
sections	pointer
,	O
asymbol	struct
*	O
*	O
syms	pointer
,	O
long	O
symcount	int
)	O
{	O
struct	O
stab_handle	struct
*	O
ret	pointer
;	O
ret	pointer
=	O
(	O
struct	O
stab_handle	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
ret	pointer
)	O
;	O
memset	function
(	O
ret	pointer
,	O
0	int
,	O
sizeof	O
*	O
ret	pointer
)	O
;	O
ret	pointer
->	O
abfd	pointer
=	O
abfd	pointer
;	O
ret	pointer
->	O
sections	pointer
=	O
sections	pointer
;	O
ret	pointer
->	O
syms	pointer
=	O
syms	pointer
;	O
ret	pointer
->	O
symcount	int
=	O
symcount	int
;	O
ret	pointer
->	O
files	int
=	O
1	int
;	O
ret	pointer
->	O
file_types	pointer
=	O
(	O
struct	O
stab_types	struct
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
ret	pointer
->	O
file_types	pointer
)	O
;	O
ret	pointer
->	O
file_types	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
ret	pointer
->	O
function_end	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
return	O
(	O
void	O
*	O
)	O
ret	pointer
;	O
}	O
bfd_boolean	int
finish_stab	function
(	O
void	O
*	O
dhandle	pointer
,	O
void	O
*	O
handle	pointer
)	O
{	O
struct	O
stab_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
stab_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
stab_tag	struct
*	O
st	pointer
;	O
if	O
(	O
info	pointer
->	O
within_function	int
)	O
{	O
if	O
(	O
!	O
stab_emit_pending_vars	function
(	O
dhandle	pointer
,	O
info	pointer
)	O
||	O
!	O
debug_end_function	function
(	O
dhandle	pointer
,	O
info	pointer
->	O
function_end	long
)	O
)	O
return	O
FALSE	int
;	O
info	pointer
->	O
within_function	int
=	O
FALSE	int
;	O
info	pointer
->	O
function_end	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
for	O
(	O
st	pointer
=	O
info	pointer
->	O
tags	pointer
;	O
st	pointer
!=	O
NULL	O
;	O
st	pointer
=	O
st	pointer
->	O
next	pointer
)	O
{	O
enum	O
debug_type_kind	enum
kind	enum
;	O
kind	enum
=	O
st	pointer
->	O
kind	enum
;	O
if	O
(	O
kind	enum
==	O
DEBUG_KIND_ILLEGAL	int
)	O
kind	enum
=	O
DEBUG_KIND_STRUCT	int
;	O
st	pointer
->	O
slot	pointer
=	O
debug_make_undefined_tagged_type	function
(	O
dhandle	pointer
,	O
st	pointer
->	O
name	pointer
,	O
kind	enum
)	O
;	O
if	O
(	O
st	pointer
->	O
slot	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
parse_stab	function
(	O
void	O
*	O
dhandle	pointer
,	O
void	O
*	O
handle	pointer
,	O
int	O
type	enum
,	O
int	O
desc	int
,	O
bfd_vma	long
value	long
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
const	O
char	O
*	O
string_end	pointer
;	O
struct	O
stab_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
stab_handle	struct
*	O
)	O
handle	pointer
;	O
if	O
(	O
info	pointer
->	O
so_string	pointer
!=	O
NULL	O
&&	O
(	O
type	enum
!=	O
N_SO	int
||	O
*	O
string	pointer
==	O
'\0'	O
||	O
value	long
!=	O
info	pointer
->	O
so_value	long
)	O
)	O
{	O
if	O
(	O
!	O
debug_set_filename	function
(	O
dhandle	pointer
,	O
info	pointer
->	O
so_string	pointer
)	O
)	O
return	O
FALSE	int
;	O
info	pointer
->	O
main_filename	pointer
=	O
info	pointer
->	O
so_string	pointer
;	O
info	pointer
->	O
gcc_compiled	int
=	O
0	int
;	O
info	pointer
->	O
n_opt_found	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
info	pointer
->	O
sections	pointer
)	O
info	pointer
->	O
file_start_offset	long
=	O
info	pointer
->	O
so_value	long
;	O
info	pointer
->	O
files	int
=	O
1	int
;	O
info	pointer
->	O
file_types	pointer
=	O
(	O
(	O
struct	O
stab_types	struct
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
info	pointer
->	O
file_types	pointer
)	O
)	O
;	O
info	pointer
->	O
file_types	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
info	pointer
->	O
so_string	pointer
=	O
NULL	O
;	O
}	O
string_end	pointer
=	O
string	pointer
+	O
strlen	function
(	O
string	pointer
)	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
N_FN	int
:	O
case	O
N_FN_SEQ	int
:	O
break	O
;	O
case	O
N_LBRAC	int
:	O
if	O
(	O
info	pointer
->	O
n_opt_found	int
&&	O
desc	int
==	O
1	int
)	O
break	O
;	O
if	O
(	O
!	O
info	pointer
->	O
within_function	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"N_LBRAC not within function\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
debug_start_block	function
(	O
dhandle	pointer
,	O
(	O
value	long
+	O
info	pointer
->	O
file_start_offset	long
+	O
info	pointer
->	O
function_start_offset	long
)	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
stab_emit_pending_vars	function
(	O
dhandle	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
++	O
info	pointer
->	O
block_depth	int
;	O
break	O
;	O
case	O
N_RBRAC	int
:	O
if	O
(	O
info	pointer
->	O
n_opt_found	int
&&	O
desc	int
==	O
1	int
)	O
break	O
;	O
if	O
(	O
!	O
stab_emit_pending_vars	function
(	O
dhandle	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
debug_end_block	function
(	O
dhandle	pointer
,	O
(	O
value	long
+	O
info	pointer
->	O
file_start_offset	long
+	O
info	pointer
->	O
function_start_offset	long
)	O
)	O
)	O
return	O
FALSE	int
;	O
--	O
info	pointer
->	O
block_depth	int
;	O
if	O
(	O
info	pointer
->	O
block_depth	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Too many N_RBRACs\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
N_SO	int
:	O
if	O
(	O
info	pointer
->	O
within_function	int
)	O
{	O
bfd_vma	long
endval	long
;	O
endval	long
=	O
value	long
;	O
if	O
(	O
*	O
string	pointer
!=	O
'\0'	O
&&	O
info	pointer
->	O
function_end	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
info	pointer
->	O
function_end	long
<	O
endval	long
)	O
endval	long
=	O
info	pointer
->	O
function_end	long
;	O
if	O
(	O
!	O
stab_emit_pending_vars	function
(	O
dhandle	pointer
,	O
info	pointer
)	O
||	O
!	O
debug_end_function	function
(	O
dhandle	pointer
,	O
endval	long
)	O
)	O
return	O
FALSE	int
;	O
info	pointer
->	O
within_function	int
=	O
FALSE	int
;	O
info	pointer
->	O
function_end	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
if	O
(	O
*	O
string	pointer
==	O
'\0'	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
info	pointer
->	O
so_string	pointer
==	O
NULL	O
)	O
info	pointer
->	O
so_string	pointer
=	O
xstrdup	function
(	O
string	pointer
)	O
;	O
else	O
{	O
char	O
*	O
f	pointer
;	O
f	pointer
=	O
info	pointer
->	O
so_string	pointer
;	O
if	O
(	O
IS_ABSOLUTE_PATH	O
(	O
string	pointer
)	O
)	O
info	pointer
->	O
so_string	pointer
=	O
xstrdup	function
(	O
string	pointer
)	O
;	O
else	O
info	pointer
->	O
so_string	pointer
=	O
concat	function
(	O
info	pointer
->	O
so_string	pointer
,	O
string	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
free	function
(	O
f	pointer
)	O
;	O
}	O
info	pointer
->	O
so_value	long
=	O
value	long
;	O
break	O
;	O
case	O
N_SOL	int
:	O
if	O
(	O
!	O
debug_start_source	function
(	O
dhandle	pointer
,	O
string	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
N_BINCL	int
:	O
push_bincl	function
(	O
info	pointer
,	O
string	pointer
,	O
value	long
)	O
;	O
if	O
(	O
!	O
debug_start_source	function
(	O
dhandle	pointer
,	O
string	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
N_EINCL	int
:	O
if	O
(	O
!	O
debug_start_source	function
(	O
dhandle	pointer
,	O
pop_bincl	function
(	O
info	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
N_EXCL	int
:	O
if	O
(	O
!	O
find_excl	function
(	O
info	pointer
,	O
string	pointer
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
N_SLINE	int
:	O
if	O
(	O
!	O
debug_record_line	function
(	O
dhandle	pointer
,	O
desc	int
,	O
value	long
+	O
(	O
info	pointer
->	O
within_function	int
?	O
info	pointer
->	O
function_start_offset	long
:	O
0	int
)	O
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
N_BCOMM	int
:	O
if	O
(	O
!	O
debug_start_common_block	function
(	O
dhandle	pointer
,	O
string	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
N_ECOMM	int
:	O
if	O
(	O
!	O
debug_end_common_block	function
(	O
dhandle	pointer
,	O
string	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
N_FUN	int
:	O
if	O
(	O
*	O
string	pointer
==	O
'\0'	O
)	O
{	O
if	O
(	O
info	pointer
->	O
within_function	int
)	O
{	O
if	O
(	O
info	pointer
->	O
sections	pointer
)	O
value	long
+=	O
info	pointer
->	O
function_start_offset	long
;	O
if	O
(	O
!	O
stab_emit_pending_vars	function
(	O
dhandle	pointer
,	O
info	pointer
)	O
||	O
!	O
debug_end_function	function
(	O
dhandle	pointer
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
info	pointer
->	O
within_function	int
=	O
FALSE	int
;	O
info	pointer
->	O
function_end	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
info	pointer
->	O
within_function	int
&&	O
(	O
info	pointer
->	O
function_end	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
value	long
<	O
info	pointer
->	O
function_end	long
)	O
)	O
info	pointer
->	O
function_end	long
=	O
value	long
;	O
default	O
:	O
{	O
const	O
char	O
*	O
colon	pointer
;	O
colon	pointer
=	O
strchr	function
(	O
string	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
colon	pointer
!=	O
NULL	O
&&	O
(	O
colon	pointer
[	O
1	int
]	O
==	O
'f'	O
||	O
colon	pointer
[	O
1	int
]	O
==	O
'F'	O
)	O
)	O
{	O
if	O
(	O
info	pointer
->	O
within_function	int
)	O
{	O
bfd_vma	long
endval	long
;	O
endval	long
=	O
value	long
;	O
if	O
(	O
info	pointer
->	O
function_end	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
info	pointer
->	O
function_end	long
<	O
endval	long
)	O
endval	long
=	O
info	pointer
->	O
function_end	long
;	O
if	O
(	O
!	O
stab_emit_pending_vars	function
(	O
dhandle	pointer
,	O
info	pointer
)	O
||	O
!	O
debug_end_function	function
(	O
dhandle	pointer
,	O
endval	long
)	O
)	O
return	O
FALSE	int
;	O
info	pointer
->	O
function_end	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
if	O
(	O
info	pointer
->	O
sections	pointer
)	O
info	pointer
->	O
function_start_offset	long
=	O
value	long
;	O
info	pointer
->	O
within_function	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
parse_stab_string	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
type	enum
,	O
desc	int
,	O
value	long
,	O
string	pointer
,	O
string_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
N_OPT	int
:	O
if	O
(	O
string	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
string	pointer
,	O
"gcc2_compiled."	pointer
)	O
==	O
0	int
)	O
info	pointer
->	O
gcc_compiled	int
=	O
2	int
;	O
else	O
if	O
(	O
string	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
string	pointer
,	O
"gcc_compiled."	pointer
)	O
==	O
0	int
)	O
info	pointer
->	O
gcc_compiled	int
=	O
1	int
;	O
else	O
info	pointer
->	O
n_opt_found	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
N_OBJ	int
:	O
case	O
N_ENDM	int
:	O
case	O
N_MAIN	int
:	O
case	O
N_WARNING	int
:	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_string	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
int	O
stabtype	int
,	O
int	O
desc	int
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
value	long
,	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
string_end	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
type	enum
;	O
debug_type	pointer
dtype	pointer
;	O
bfd_boolean	int
synonym	int
;	O
bfd_boolean	int
self_crossref	int
;	O
debug_type	pointer
*	O
slot	pointer
;	O
p	pointer
=	O
strchr	function
(	O
string	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
while	O
(	O
p	pointer
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
p	pointer
+=	O
2	int
;	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
bad_stab	function
(	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
name	pointer
=	O
NULL	O
;	O
if	O
(	O
string	pointer
[	O
0	int
]	O
==	O
'$'	O
)	O
{	O
switch	O
(	O
string	pointer
[	O
1	int
]	O
)	O
{	O
case	O
't'	O
:	O
name	pointer
=	O
"this"	pointer
;	O
break	O
;	O
case	O
'v'	O
:	O
break	O
;	O
case	O
'e'	O
:	O
name	pointer
=	O
"eh_throw"	pointer
;	O
break	O
;	O
case	O
'_'	O
:	O
break	O
;	O
case	O
'X'	O
:	O
break	O
;	O
default	O
:	O
warn_stab	function
(	O
string	pointer
,	O
_	O
(	O
"unknown C++ encoded name"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
p	pointer
==	O
string	pointer
||	O
(	O
string	pointer
[	O
0	int
]	O
==	O
' '	O
&&	O
p	pointer
==	O
string	pointer
+	O
1	int
)	O
)	O
name	pointer
=	O
NULL	O
;	O
else	O
name	pointer
=	O
savestring	function
(	O
string	pointer
,	O
p	pointer
-	O
string	pointer
)	O
;	O
}	O
++	O
p	pointer
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
||	O
*	O
p	pointer
==	O
'('	O
||	O
*	O
p	pointer
==	O
'-'	O
)	O
type	enum
=	O
'l'	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
bad_stab	function
(	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
type	enum
=	O
*	O
p	pointer
++	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
'c'	O
:	O
if	O
(	O
*	O
p	pointer
!=	O
'='	O
)	O
{	O
bad_stab	function
(	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
p	pointer
;	O
switch	O
(	O
*	O
p	pointer
++	O
)	O
{	O
case	O
'r'	O
:	O
if	O
(	O
!	O
debug_record_float_const	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
atof	function
(	O
p	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
!	O
debug_record_int_const	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
atoi	function
(	O
p	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'e'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
p	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
debug_record_typed_const	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
atoi	function
(	O
p	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
default	O
:	O
bad_stab	function
(	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
'C'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
debug_record_label	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
debug_record_function	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
type	enum
==	O
'F'	O
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
while	O
(	O
*	O
p	pointer
==	O
';'	O
)	O
{	O
++	O
p	pointer
;	O
if	O
(	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
'G'	O
:	O
{	O
asymbol	struct
*	O
*	O
ps	pointer
;	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
char	O
leading	char
;	O
long	O
c	long
;	O
leading	char
=	O
bfd_get_symbol_leading_char	function
(	O
info	pointer
->	O
abfd	pointer
)	O
;	O
for	O
(	O
c	long
=	O
info	pointer
->	O
symcount	int
,	O
ps	pointer
=	O
info	pointer
->	O
syms	pointer
;	O
c	long
>	O
0	int
;	O
--	O
c	long
,	O
++	O
ps	pointer
)	O
{	O
const	O
char	O
*	O
n	long
;	O
n	long
=	O
bfd_asymbol_name	function
(	O
*	O
ps	pointer
)	O
;	O
if	O
(	O
leading	char
!=	O
'\0'	O
&&	O
*	O
n	long
==	O
leading	char
)	O
++	O
n	long
;	O
if	O
(	O
*	O
n	long
==	O
*	O
name	pointer
&&	O
strcmp	function
(	O
n	long
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
c	long
>	O
0	int
)	O
value	long
=	O
bfd_asymbol_value	function
(	O
*	O
ps	pointer
)	O
;	O
}	O
if	O
(	O
!	O
stab_record_variable	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_GLOBAL	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
'l'	O
:	O
case	O
's'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
stab_record_variable	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_LOCAL	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
*	O
p	pointer
!=	O
'F'	O
)	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
else	O
{	O
++	O
p	pointer
;	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
!=	O
DEBUG_TYPE_NULL	O
)	O
{	O
debug_type	pointer
ftype	pointer
;	O
ftype	pointer
=	O
debug_make_function_type	function
(	O
dhandle	pointer
,	O
dtype	pointer
,	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
,	O
FALSE	int
)	O
;	O
dtype	pointer
=	O
debug_make_pointer_type	function
(	O
dhandle	pointer
,	O
ftype	pointer
)	O
;	O
}	O
}	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
debug_record_parameter	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_PARM_STACK	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
stabtype	int
==	O
N_FUN	int
)	O
{	O
while	O
(	O
*	O
p	pointer
==	O
';'	O
)	O
{	O
++	O
p	pointer
;	O
if	O
(	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
}	O
case	O
'R'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
debug_record_parameter	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_PARM_REG	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'r'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
stab_record_variable	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_REGISTER	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'S'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
stab_record_variable	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_STATIC	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
't'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
name	pointer
,	O
&	O
p	pointer
,	O
&	O
slot	pointer
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
dtype	pointer
=	O
debug_name_type	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
slot	pointer
!=	O
NULL	O
)	O
*	O
slot	pointer
=	O
dtype	pointer
;	O
break	O
;	O
case	O
'T'	O
:	O
if	O
(	O
*	O
p	pointer
!=	O
't'	O
)	O
{	O
synonym	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
synonym	int
=	O
TRUE	int
;	O
++	O
p	pointer
;	O
}	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
name	pointer
,	O
&	O
p	pointer
,	O
&	O
slot	pointer
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
self_crossref	int
=	O
info	pointer
->	O
self_crossref	int
;	O
dtype	pointer
=	O
debug_tag_type	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
slot	pointer
!=	O
NULL	O
)	O
*	O
slot	pointer
=	O
dtype	pointer
;	O
if	O
(	O
!	O
self_crossref	int
)	O
{	O
register	O
struct	O
stab_tag	struct
*	O
*	O
pst	pointer
;	O
for	O
(	O
pst	pointer
=	O
&	O
info	pointer
->	O
tags	pointer
;	O
*	O
pst	pointer
!=	O
NULL	O
;	O
pst	pointer
=	O
&	O
(	O
*	O
pst	pointer
)	O
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
*	O
pst	pointer
)	O
->	O
name	pointer
[	O
0	int
]	O
==	O
name	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
(	O
*	O
pst	pointer
)	O
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
(	O
*	O
pst	pointer
)	O
->	O
slot	pointer
=	O
dtype	pointer
;	O
*	O
pst	pointer
=	O
(	O
*	O
pst	pointer
)	O
->	O
next	pointer
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
synonym	int
)	O
{	O
dtype	pointer
=	O
debug_name_type	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
slot	pointer
!=	O
NULL	O
)	O
*	O
slot	pointer
=	O
dtype	pointer
;	O
}	O
break	O
;	O
case	O
'V'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
stab_record_variable	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_LOCAL_STATIC	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'v'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
debug_record_parameter	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_PARM_REFERENCE	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'a'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
debug_record_parameter	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_PARM_REF_REG	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'X'	O
:	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
&	O
p	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
string_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
stab_record_variable	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
name	pointer
,	O
dtype	pointer
,	O
DEBUG_LOCAL	int
,	O
value	long
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'Y'	O
:	O
if	O
(	O
*	O
(	O
++	O
p	pointer
)	O
==	O
'n'	O
&&	O
*	O
(	O
++	O
p	pointer
)	O
==	O
'0'	O
)	O
{	O
while	O
(	O
*	O
p	pointer
!=	O
';'	O
)	O
++	O
p	pointer
;	O
++	O
p	pointer
;	O
return	O
TRUE	int
;	O
}	O
default	O
:	O
bad_stab	function
(	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	pointer
parse_stab_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
type_name	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_type	pointer
*	O
*	O
slotp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
int	O
typenums	array
[	O
2	int
]	O
;	O
int	O
size	int
;	O
bfd_boolean	int
stringp	int
;	O
int	O
descriptor	int
;	O
debug_type	pointer
dtype	pointer
;	O
if	O
(	O
slotp	pointer
!=	O
NULL	O
)	O
*	O
slotp	pointer
=	O
NULL	O
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
size	int
=	O
-	O
1	int
;	O
stringp	int
=	O
FALSE	int
;	O
info	pointer
->	O
self_crossref	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
&&	O
*	O
*	O
pp	pointer
!=	O
'('	O
&&	O
*	O
*	O
pp	pointer
!=	O
'-'	O
)	O
{	O
typenums	array
[	O
0	int
]	O
=	O
typenums	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
parse_stab_type_number	function
(	O
pp	pointer
,	O
typenums	array
,	O
p_end	pointer
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'='	O
)	O
return	O
stab_find_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
typenums	array
)	O
;	O
if	O
(	O
slotp	pointer
!=	O
NULL	O
&&	O
typenums	array
[	O
0	int
]	O
>=	O
0	int
&&	O
typenums	array
[	O
1	int
]	O
>=	O
0	int
)	O
*	O
slotp	pointer
=	O
stab_find_slot	function
(	O
info	pointer
,	O
typenums	array
)	O
;	O
++	O
*	O
pp	pointer
;	O
while	O
(	O
*	O
*	O
pp	pointer
==	O
'@'	O
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
*	O
pp	pointer
+	O
1	int
;	O
const	O
char	O
*	O
attr	pointer
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
||	O
*	O
p	pointer
==	O
'('	O
||	O
*	O
p	pointer
==	O
'-'	O
)	O
break	O
;	O
attr	pointer
=	O
p	pointer
;	O
for	O
(	O
;	O
*	O
p	pointer
!=	O
';'	O
;	O
++	O
p	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
}	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
switch	O
(	O
*	O
attr	pointer
)	O
{	O
case	O
's'	O
:	O
size	int
=	O
atoi	function
(	O
attr	pointer
+	O
1	int
)	O
;	O
size	int
/=	O
8	int
;	O
if	O
(	O
size	int
<=	O
0	int
)	O
size	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
stringp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
descriptor	int
=	O
*	O
*	O
pp	pointer
;	O
++	O
*	O
pp	pointer
;	O
switch	O
(	O
descriptor	int
)	O
{	O
case	O
'x'	O
:	O
{	O
enum	O
debug_type_kind	enum
code	int
;	O
const	O
char	O
*	O
q1	pointer
,	O
*	O
q2	pointer
,	O
*	O
p	pointer
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
's'	O
:	O
code	int
=	O
DEBUG_KIND_STRUCT	int
;	O
break	O
;	O
case	O
'u'	O
:	O
code	int
=	O
DEBUG_KIND_UNION	int
;	O
break	O
;	O
case	O
'e'	O
:	O
code	int
=	O
DEBUG_KIND_ENUM	int
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
default	O
:	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"unrecognized cross reference type"	pointer
)	O
)	O
;	O
code	int
=	O
DEBUG_KIND_STRUCT	int
;	O
break	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
q1	pointer
=	O
strchr	function
(	O
*	O
pp	pointer
,	O
'<'	O
)	O
;	O
p	pointer
=	O
strchr	function
(	O
*	O
pp	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
q1	pointer
!=	O
NULL	O
&&	O
p	pointer
>	O
q1	pointer
&&	O
p	pointer
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
int	O
nest	int
=	O
0	int
;	O
for	O
(	O
q2	pointer
=	O
q1	pointer
;	O
*	O
q2	pointer
!=	O
'\0'	O
;	O
++	O
q2	pointer
)	O
{	O
if	O
(	O
*	O
q2	pointer
==	O
'<'	O
)	O
++	O
nest	int
;	O
else	O
if	O
(	O
*	O
q2	pointer
==	O
'>'	O
)	O
--	O
nest	int
;	O
else	O
if	O
(	O
*	O
q2	pointer
==	O
':'	O
&&	O
nest	int
==	O
0	int
)	O
break	O
;	O
}	O
p	pointer
=	O
q2	pointer
;	O
if	O
(	O
*	O
p	pointer
!=	O
':'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
}	O
if	O
(	O
type_name	pointer
!=	O
NULL	O
&&	O
strncmp	function
(	O
type_name	pointer
,	O
*	O
pp	pointer
,	O
p	pointer
-	O
*	O
pp	pointer
)	O
==	O
0	int
&&	O
type_name	pointer
[	O
p	pointer
-	O
*	O
pp	pointer
]	O
==	O
'\0'	O
)	O
info	pointer
->	O
self_crossref	int
=	O
TRUE	int
;	O
dtype	pointer
=	O
stab_find_tagged_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
*	O
pp	pointer
,	O
p	pointer
-	O
*	O
pp	pointer
,	O
code	int
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
}	O
break	O
;	O
case	O
'-'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
case	O
'('	O
:	O
{	O
const	O
char	O
*	O
hold	pointer
;	O
int	O
xtypenums	array
[	O
2	int
]	O
;	O
(	O
*	O
pp	pointer
)	O
--	O
;	O
hold	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
parse_stab_type_number	function
(	O
pp	pointer
,	O
xtypenums	array
,	O
p_end	pointer
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
typenums	array
[	O
0	int
]	O
==	O
xtypenums	array
[	O
0	int
]	O
&&	O
typenums	array
[	O
1	int
]	O
==	O
xtypenums	array
[	O
1	int
]	O
)	O
{	O
dtype	pointer
=	O
debug_make_void_type	function
(	O
dhandle	pointer
)	O
;	O
}	O
else	O
{	O
*	O
pp	pointer
=	O
hold	pointer
;	O
dtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
typenums	array
[	O
0	int
]	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
stab_record_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
typenums	array
,	O
dtype	pointer
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
'*'	O
:	O
dtype	pointer
=	O
debug_make_pointer_type	function
(	O
dhandle	pointer
,	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
dtype	pointer
=	O
(	O
debug_make_reference_type	function
(	O
dhandle	pointer
,	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
dtype	pointer
=	O
(	O
debug_make_function_type	function
(	O
dhandle	pointer
,	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
,	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
,	O
FALSE	int
)	O
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
dtype	pointer
=	O
debug_make_const_type	function
(	O
dhandle	pointer
,	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
dtype	pointer
=	O
(	O
debug_make_volatile_type	function
(	O
dhandle	pointer
,	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'@'	O
:	O
{	O
debug_type	pointer
domain	pointer
;	O
debug_type	pointer
memtype	pointer
;	O
domain	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
domain	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
memtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
memtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
dtype	pointer
=	O
debug_make_offset_type	function
(	O
dhandle	pointer
,	O
domain	pointer
,	O
memtype	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'#'	O
:	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'#'	O
)	O
{	O
debug_type	pointer
return_type	pointer
;	O
++	O
*	O
pp	pointer
;	O
return_type	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
return_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
dtype	pointer
=	O
debug_make_method_type	function
(	O
dhandle	pointer
,	O
return_type	pointer
,	O
DEBUG_TYPE_NULL	O
,	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
,	O
FALSE	int
)	O
;	O
}	O
else	O
{	O
debug_type	pointer
domain	pointer
;	O
debug_type	pointer
return_type	pointer
;	O
debug_type	pointer
*	O
args	int
;	O
unsigned	O
int	O
n	long
;	O
unsigned	O
int	O
alloc	int
;	O
bfd_boolean	int
varargs	int
;	O
domain	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
domain	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
return_type	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
return_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
alloc	int
=	O
10	int
;	O
args	int
=	O
(	O
debug_type	pointer
*	O
)	O
xmalloc	function
(	O
alloc	int
*	O
sizeof	O
*	O
args	int
)	O
;	O
n	long
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
n	long
+	O
1	int
>=	O
alloc	int
)	O
{	O
alloc	int
+=	O
10	int
;	O
args	int
=	O
(	O
(	O
debug_type	pointer
*	O
)	O
xrealloc	function
(	O
args	int
,	O
alloc	int
*	O
sizeof	O
*	O
args	int
)	O
)	O
;	O
}	O
args	int
[	O
n	long
]	O
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
args	int
[	O
n	long
]	O
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
++	O
n	long
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
n	long
==	O
0	int
||	O
debug_get_type_kind	function
(	O
dhandle	pointer
,	O
args	int
[	O
n	long
-	O
1	int
]	O
)	O
!=	O
DEBUG_KIND_VOID	int
)	O
varargs	int
=	O
TRUE	int
;	O
else	O
{	O
--	O
n	long
;	O
varargs	int
=	O
FALSE	int
;	O
}	O
args	int
[	O
n	long
]	O
=	O
DEBUG_TYPE_NULL	O
;	O
dtype	pointer
=	O
debug_make_method_type	function
(	O
dhandle	pointer
,	O
return_type	pointer
,	O
domain	pointer
,	O
args	int
,	O
varargs	int
)	O
;	O
}	O
break	O
;	O
case	O
'r'	O
:	O
dtype	pointer
=	O
parse_stab_range_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
type_name	pointer
,	O
pp	pointer
,	O
typenums	array
,	O
p_end	pointer
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
dtype	pointer
=	O
parse_stab_sun_builtin_type	function
(	O
dhandle	pointer
,	O
pp	pointer
,	O
p_end	pointer
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
dtype	pointer
=	O
parse_stab_sun_floating_type	function
(	O
dhandle	pointer
,	O
pp	pointer
,	O
p_end	pointer
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
dtype	pointer
=	O
parse_stab_enum_type	function
(	O
dhandle	pointer
,	O
pp	pointer
,	O
p_end	pointer
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
case	O
'u'	O
:	O
dtype	pointer
=	O
parse_stab_struct_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
type_name	pointer
,	O
pp	pointer
,	O
descriptor	int
==	O
's'	O
,	O
typenums	array
,	O
p_end	pointer
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'r'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
dtype	pointer
=	O
parse_stab_array_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
pp	pointer
,	O
stringp	int
,	O
p_end	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
dtype	pointer
=	O
debug_make_set_type	function
(	O
dhandle	pointer
,	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
,	O
stringp	int
)	O
;	O
break	O
;	O
default	O
:	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
dtype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
typenums	array
[	O
0	int
]	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
stab_record_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
typenums	array
,	O
dtype	pointer
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
size	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
debug_record_type_size	function
(	O
dhandle	pointer
,	O
dtype	pointer
,	O
(	O
unsigned	O
int	O
)	O
size	int
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
return	O
dtype	pointer
;	O
}	O
static	O
bfd_boolean	int
parse_stab_type_number	function
(	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
int	O
*	O
typenums	array
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'('	O
)	O
{	O
typenums	array
[	O
0	int
]	O
=	O
0	int
;	O
typenums	array
[	O
1	int
]	O
=	O
(	O
int	O
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
typenums	array
[	O
0	int
]	O
=	O
(	O
int	O
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
typenums	array
[	O
1	int
]	O
=	O
(	O
int	O
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
')'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	pointer
parse_stab_range_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
type_name	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
int	O
*	O
typenums	array
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
int	O
rangenums	array
[	O
2	int
]	O
;	O
bfd_boolean	int
self_subrange	int
;	O
debug_type	pointer
index_type	pointer
;	O
const	O
char	O
*	O
s2	pointer
,	O
*	O
s3	pointer
;	O
bfd_signed_vma	long
n2	long
,	O
n3	long
;	O
bfd_boolean	int
ov2	int
,	O
ov3	int
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
index_type	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
!	O
parse_stab_type_number	function
(	O
pp	pointer
,	O
rangenums	array
,	O
p_end	pointer
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
self_subrange	int
=	O
(	O
rangenums	array
[	O
0	int
]	O
==	O
typenums	array
[	O
0	int
]	O
&&	O
rangenums	array
[	O
1	int
]	O
==	O
typenums	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'='	O
)	O
{	O
*	O
pp	pointer
=	O
orig	pointer
;	O
index_type	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
index_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
';'	O
)	O
++	O
*	O
pp	pointer
;	O
s2	pointer
=	O
*	O
pp	pointer
;	O
n2	long
=	O
parse_number	function
(	O
pp	pointer
,	O
&	O
ov2	int
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
s3	pointer
=	O
*	O
pp	pointer
;	O
n3	long
=	O
parse_number	function
(	O
pp	pointer
,	O
&	O
ov3	int
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
ov2	int
||	O
ov3	int
)	O
{	O
if	O
(	O
index_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
if	O
(	O
CONST_STRNEQ	O
(	O
s2	pointer
,	O
LLLOW	pointer
)	O
&&	O
CONST_STRNEQ	O
(	O
s3	pointer
,	O
LLHIGH	pointer
)	O
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
!	O
ov2	int
&&	O
n2	long
==	O
0	int
&&	O
CONST_STRNEQ	O
(	O
s3	pointer
,	O
ULLHIGH	pointer
)	O
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
TRUE	int
)	O
;	O
}	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"numeric overflow"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
index_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
if	O
(	O
self_subrange	int
&&	O
n2	long
==	O
0	int
&&	O
n3	long
==	O
0	int
)	O
return	O
debug_make_void_type	function
(	O
dhandle	pointer
)	O
;	O
if	O
(	O
self_subrange	int
&&	O
n3	long
==	O
0	int
&&	O
n2	long
>	O
0	int
)	O
return	O
debug_make_complex_type	function
(	O
dhandle	pointer
,	O
n2	long
)	O
;	O
if	O
(	O
n3	long
==	O
0	int
&&	O
n2	long
>	O
0	int
)	O
return	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
n2	long
)	O
;	O
if	O
(	O
n2	long
==	O
0	int
&&	O
n3	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
type_name	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
type_name	pointer
,	O
"long long int"	pointer
)	O
==	O
0	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
type_name	pointer
,	O
"long long unsigned int"	pointer
)	O
==	O
0	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
TRUE	int
)	O
;	O
}	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
TRUE	int
)	O
;	O
}	O
if	O
(	O
self_subrange	int
&&	O
n2	long
==	O
0	int
&&	O
n3	long
==	O
127	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
n2	long
==	O
0	int
)	O
{	O
if	O
(	O
n3	long
<	O
0	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
-	O
n3	long
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n3	long
==	O
0xff	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n3	long
==	O
0xffff	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
2	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n3	long
==	O
(	O
bfd_signed_vma	long
)	O
0xffffffff	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n3	long
==	O
(	O
bfd_signed_vma	long
)	O
0xffffffffffffffffLL	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
TRUE	int
)	O
;	O
}	O
else	O
if	O
(	O
n3	long
==	O
0	int
&&	O
n2	long
<	O
0	int
&&	O
(	O
self_subrange	int
||	O
n2	long
==	O
-	O
8	int
)	O
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
-	O
n2	long
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
n2	long
==	O
-	O
n3	long
-	O
1	int
||	O
n2	long
==	O
n3	long
+	O
1	int
)	O
{	O
if	O
(	O
n3	long
==	O
0x7f	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
n3	long
==	O
0x7fff	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
2	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
n3	long
==	O
0x7fffffff	int
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
n3	long
==	O
(	O
(	O
(	O
(	O
bfd_vma	long
)	O
0x7fffffff	int
)	O
<<	O
32	int
)	O
|	O
0xffffffff	int
)	O
)	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
FALSE	int
)	O
;	O
}	O
}	O
if	O
(	O
self_subrange	int
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
index_type	pointer
=	O
stab_find_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
rangenums	array
)	O
;	O
if	O
(	O
index_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"missing index type"	pointer
)	O
)	O
;	O
index_type	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
}	O
return	O
debug_make_range_type	function
(	O
dhandle	pointer
,	O
index_type	pointer
,	O
n2	long
,	O
n3	long
)	O
;	O
}	O
static	O
debug_type	pointer
parse_stab_sun_builtin_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
bfd_boolean	int
unsignedp	int
;	O
bfd_vma	long
bits	long
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
's'	O
:	O
unsignedp	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'u'	O
:	O
unsignedp	int
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'c'	O
||	O
*	O
*	O
pp	pointer
==	O
'b'	O
||	O
*	O
*	O
pp	pointer
==	O
'v'	O
)	O
++	O
*	O
pp	pointer
;	O
(	O
void	O
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
(	O
void	O
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
bits	long
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
';'	O
)	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
bits	long
==	O
0	int
)	O
return	O
debug_make_void_type	function
(	O
dhandle	pointer
)	O
;	O
return	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
bits	long
/	O
8	int
,	O
unsignedp	int
)	O
;	O
}	O
static	O
debug_type	pointer
parse_stab_sun_floating_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
bfd_vma	long
details	long
;	O
bfd_vma	long
bytes	long
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
details	long
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
bytes	long
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
details	long
==	O
NF_COMPLEX	int
||	O
details	long
==	O
NF_COMPLEX16	int
||	O
details	long
==	O
NF_COMPLEX32	int
)	O
return	O
debug_make_complex_type	function
(	O
dhandle	pointer
,	O
bytes	long
)	O
;	O
return	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
bytes	long
)	O
;	O
}	O
static	O
debug_type	pointer
parse_stab_enum_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
const	O
char	O
*	O
*	O
names	pointer
;	O
bfd_signed_vma	long
*	O
values	pointer
;	O
unsigned	O
int	O
n	long
;	O
unsigned	O
int	O
alloc	int
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'-'	O
)	O
{	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
':'	O
&&	O
*	O
*	O
pp	pointer
!=	O
0	int
)	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
0	int
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
}	O
alloc	int
=	O
10	int
;	O
names	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
alloc	int
*	O
sizeof	O
*	O
names	pointer
)	O
;	O
values	pointer
=	O
(	O
bfd_signed_vma	long
*	O
)	O
xmalloc	function
(	O
alloc	int
*	O
sizeof	O
*	O
values	pointer
)	O
;	O
n	long
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
'\0'	O
&&	O
*	O
*	O
pp	pointer
!=	O
';'	O
&&	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
name	pointer
;	O
bfd_signed_vma	long
val	array
;	O
p	pointer
=	O
*	O
pp	pointer
;	O
while	O
(	O
*	O
p	pointer
!=	O
':'	O
&&	O
*	O
p	pointer
!=	O
0	int
)	O
++	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
free	function
(	O
names	pointer
)	O
;	O
free	function
(	O
values	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
name	pointer
=	O
savestring	function
(	O
*	O
pp	pointer
,	O
p	pointer
-	O
*	O
pp	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
val	array
=	O
(	O
bfd_signed_vma	long
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
free	function
(	O
names	pointer
)	O
;	O
free	function
(	O
values	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
n	long
+	O
1	int
>=	O
alloc	int
)	O
{	O
alloc	int
+=	O
10	int
;	O
names	pointer
=	O
(	O
(	O
const	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
names	pointer
,	O
alloc	int
*	O
sizeof	O
*	O
names	pointer
)	O
)	O
;	O
values	pointer
=	O
(	O
(	O
bfd_signed_vma	long
*	O
)	O
xrealloc	function
(	O
values	pointer
,	O
alloc	int
*	O
sizeof	O
*	O
values	pointer
)	O
)	O
;	O
}	O
names	pointer
[	O
n	long
]	O
=	O
name	pointer
;	O
values	pointer
[	O
n	long
]	O
=	O
val	array
;	O
++	O
n	long
;	O
}	O
names	pointer
[	O
n	long
]	O
=	O
NULL	O
;	O
values	pointer
[	O
n	long
]	O
=	O
0	int
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
';'	O
)	O
++	O
*	O
pp	pointer
;	O
return	O
debug_make_enum_type	function
(	O
dhandle	pointer
,	O
names	pointer
,	O
values	pointer
)	O
;	O
}	O
static	O
debug_type	pointer
parse_stab_struct_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
tagname	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
bfd_boolean	int
structp	int
,	O
const	O
int	O
*	O
typenums	array
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
bfd_vma	long
size	int
;	O
debug_baseclass	pointer
*	O
baseclasses	pointer
;	O
debug_field	pointer
*	O
fields	pointer
=	O
NULL	O
;	O
bfd_boolean	int
statics	int
;	O
debug_method	pointer
*	O
methods	pointer
;	O
debug_type	pointer
vptrbase	pointer
;	O
bfd_boolean	int
ownvptr	int
;	O
size	int
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
!	O
parse_stab_baseclasses	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
pp	pointer
,	O
&	O
baseclasses	pointer
,	O
p_end	pointer
)	O
||	O
!	O
parse_stab_struct_fields	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
pp	pointer
,	O
&	O
fields	pointer
,	O
&	O
statics	int
,	O
p_end	pointer
)	O
||	O
!	O
parse_stab_members	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
tagname	pointer
,	O
pp	pointer
,	O
typenums	array
,	O
&	O
methods	pointer
,	O
p_end	pointer
)	O
||	O
!	O
parse_stab_tilde_field	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
pp	pointer
,	O
typenums	array
,	O
&	O
vptrbase	pointer
,	O
&	O
ownvptr	int
,	O
p_end	pointer
)	O
)	O
{	O
if	O
(	O
fields	pointer
!=	O
NULL	O
)	O
free	function
(	O
fields	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
!	O
statics	int
&&	O
baseclasses	pointer
==	O
NULL	O
&&	O
methods	pointer
==	O
NULL	O
&&	O
vptrbase	pointer
==	O
DEBUG_TYPE_NULL	O
&&	O
!	O
ownvptr	int
)	O
return	O
debug_make_struct_type	function
(	O
dhandle	pointer
,	O
structp	int
,	O
size	int
,	O
fields	pointer
)	O
;	O
return	O
debug_make_object_type	function
(	O
dhandle	pointer
,	O
structp	int
,	O
size	int
,	O
fields	pointer
,	O
baseclasses	pointer
,	O
methods	pointer
,	O
vptrbase	pointer
,	O
ownvptr	int
)	O
;	O
}	O
static	O
bfd_boolean	int
parse_stab_baseclasses	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_baseclass	pointer
*	O
*	O
retp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
unsigned	O
int	O
c	long
,	O
i	pointer
;	O
debug_baseclass	pointer
*	O
classes	pointer
;	O
*	O
retp	pointer
=	O
NULL	O
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'!'	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
c	long
=	O
(	O
unsigned	O
int	O
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
classes	pointer
=	O
(	O
debug_baseclass	pointer
*	O
)	O
xmalloc	function
(	O
(	O
c	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
*	O
retp	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
c	long
;	O
i	pointer
++	O
)	O
{	O
bfd_boolean	int
is_virtual	int
;	O
enum	O
debug_visibility	enum
visibility	enum
;	O
bfd_vma	long
bitpos	int
;	O
debug_type	pointer
type	enum
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'0'	O
:	O
is_virtual	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'1'	O
:	O
is_virtual	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
default	O
:	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"unknown virtual character for baseclass"	pointer
)	O
)	O
;	O
is_virtual	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'0'	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PRIVATE	int
;	O
break	O
;	O
case	O
'1'	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PROTECTED	int
;	O
break	O
;	O
case	O
'2'	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PUBLIC	int
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
default	O
:	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"unknown visibility character for baseclass"	pointer
)	O
)	O
;	O
visibility	enum
=	O
DEBUG_VISIBILITY_PUBLIC	int
;	O
break	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
bitpos	int
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
type	enum
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
type	enum
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
classes	pointer
[	O
i	pointer
]	O
=	O
debug_make_baseclass	function
(	O
dhandle	pointer
,	O
type	enum
,	O
bitpos	int
,	O
is_virtual	int
,	O
visibility	enum
)	O
;	O
if	O
(	O
classes	pointer
[	O
i	pointer
]	O
==	O
DEBUG_BASECLASS_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
return	O
FALSE	int
;	O
++	O
*	O
pp	pointer
;	O
}	O
classes	pointer
[	O
i	pointer
]	O
=	O
DEBUG_BASECLASS_NULL	O
;	O
*	O
retp	pointer
=	O
classes	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_struct_fields	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_field	pointer
*	O
*	O
retp	pointer
,	O
bfd_boolean	int
*	O
staticsp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
debug_field	pointer
*	O
fields	pointer
;	O
unsigned	O
int	O
c	long
;	O
unsigned	O
int	O
alloc	int
;	O
*	O
retp	pointer
=	O
NULL	O
;	O
*	O
staticsp	pointer
=	O
FALSE	int
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
FALSE	int
;	O
c	long
=	O
0	int
;	O
alloc	int
=	O
10	int
;	O
fields	pointer
=	O
(	O
debug_field	pointer
*	O
)	O
xmalloc	function
(	O
alloc	int
*	O
sizeof	O
*	O
fields	pointer
)	O
;	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
p	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
c	long
+	O
1	int
>=	O
alloc	int
)	O
{	O
alloc	int
+=	O
10	int
;	O
fields	pointer
=	O
(	O
(	O
debug_field	pointer
*	O
)	O
xrealloc	function
(	O
fields	pointer
,	O
alloc	int
*	O
sizeof	O
*	O
fields	pointer
)	O
)	O
;	O
}	O
if	O
(	O
(	O
*	O
p	pointer
==	O
'$'	O
||	O
*	O
p	pointer
==	O
'.'	O
)	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
'_'	O
)	O
{	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
parse_stab_cpp_abbrev	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
pp	pointer
,	O
fields	pointer
+	O
c	long
,	O
p_end	pointer
)	O
)	O
{	O
free	function
(	O
fields	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
c	long
;	O
continue	O
;	O
}	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
free	function
(	O
fields	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
':'	O
)	O
break	O
;	O
if	O
(	O
!	O
parse_stab_one_struct_field	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
pp	pointer
,	O
p	pointer
,	O
fields	pointer
+	O
c	long
,	O
staticsp	pointer
,	O
p_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
++	O
c	long
;	O
}	O
fields	pointer
[	O
c	long
]	O
=	O
DEBUG_FIELD_NULL	O
;	O
*	O
retp	pointer
=	O
fields	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_cpp_abbrev	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_field	pointer
*	O
retp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
int	O
cpp_abbrev	int
;	O
debug_type	pointer
context	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
type_name	pointer
;	O
debug_type	pointer
type	enum
;	O
bfd_vma	long
bitpos	int
;	O
*	O
retp	pointer
=	O
DEBUG_FIELD_NULL	O
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'v'	O
)	O
{	O
bad_stab	function
(	O
*	O
pp	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
cpp_abbrev	int
=	O
*	O
*	O
pp	pointer
;	O
if	O
(	O
cpp_abbrev	int
==	O
0	int
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
context	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
context	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
switch	O
(	O
cpp_abbrev	int
)	O
{	O
case	O
'f'	O
:	O
name	pointer
=	O
"_vptr$"	pointer
;	O
break	O
;	O
case	O
'b'	O
:	O
type_name	pointer
=	O
debug_get_type_name	function
(	O
dhandle	pointer
,	O
context	pointer
)	O
;	O
if	O
(	O
type_name	pointer
==	O
NULL	O
)	O
{	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"unnamed $vb type"	pointer
)	O
)	O
;	O
type_name	pointer
=	O
"FOO"	pointer
;	O
}	O
name	pointer
=	O
concat	function
(	O
"_vb$"	pointer
,	O
type_name	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
default	O
:	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"unrecognized C++ abbreviation"	pointer
)	O
)	O
;	O
name	pointer
=	O
"INVALID_CPLUSPLUS_ABBREV"	pointer
;	O
break	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
':'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
type	enum
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
bitpos	int
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
*	O
retp	pointer
=	O
debug_make_field	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
type	enum
,	O
bitpos	int
,	O
0	int
,	O
DEBUG_VISIBILITY_PRIVATE	int
)	O
;	O
if	O
(	O
*	O
retp	pointer
==	O
DEBUG_FIELD_NULL	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_one_struct_field	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
char	O
*	O
p	pointer
,	O
debug_field	pointer
*	O
retp	pointer
,	O
bfd_boolean	int
*	O
staticsp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
char	O
*	O
name	pointer
;	O
enum	O
debug_visibility	enum
visibility	enum
;	O
debug_type	pointer
type	enum
;	O
bfd_vma	long
bitpos	int
;	O
bfd_vma	long
bitsize	int
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
FALSE	int
;	O
name	pointer
=	O
savestring	function
(	O
*	O
pp	pointer
,	O
p	pointer
-	O
*	O
pp	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'/'	O
)	O
visibility	enum
=	O
DEBUG_VISIBILITY_PUBLIC	int
;	O
else	O
{	O
++	O
*	O
pp	pointer
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'0'	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PRIVATE	int
;	O
break	O
;	O
case	O
'1'	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PROTECTED	int
;	O
break	O
;	O
case	O
'2'	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PUBLIC	int
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
default	O
:	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"unknown visibility character for field"	pointer
)	O
)	O
;	O
visibility	enum
=	O
DEBUG_VISIBILITY_PUBLIC	int
;	O
break	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
}	O
type	enum
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
type	enum
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
':'	O
)	O
{	O
char	O
*	O
varname	pointer
;	O
++	O
*	O
pp	pointer
;	O
p	pointer
=	O
strchr	function
(	O
*	O
pp	pointer
,	O
';'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
varname	pointer
=	O
savestring	function
(	O
*	O
pp	pointer
,	O
p	pointer
-	O
*	O
pp	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
*	O
retp	pointer
=	O
debug_make_static_member	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
type	enum
,	O
varname	pointer
,	O
visibility	enum
)	O
;	O
*	O
staticsp	pointer
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
bitpos	int
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
','	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
bitsize	int
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
bitpos	int
==	O
0	int
&&	O
bitsize	int
==	O
0	int
)	O
{	O
visibility	enum
=	O
DEBUG_VISIBILITY_IGNORE	int
;	O
}	O
*	O
retp	pointer
=	O
debug_make_field	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
type	enum
,	O
bitpos	int
,	O
bitsize	int
,	O
visibility	enum
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
parse_stab_members	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
tagname	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
int	O
*	O
typenums	array
,	O
debug_method	pointer
*	O
*	O
retp	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
debug_method	pointer
*	O
methods	pointer
;	O
unsigned	O
int	O
c	long
;	O
unsigned	O
int	O
alloc	int
;	O
char	O
*	O
name	pointer
=	O
NULL	O
;	O
debug_method_variant	pointer
*	O
variants	pointer
=	O
NULL	O
;	O
char	O
*	O
argtypes	pointer
=	O
NULL	O
;	O
*	O
retp	pointer
=	O
NULL	O
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
FALSE	int
;	O
alloc	int
=	O
0	int
;	O
methods	pointer
=	O
NULL	O
;	O
c	long
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
unsigned	O
int	O
cvars	int
;	O
unsigned	O
int	O
allocvars	int
;	O
debug_type	pointer
look_ahead_type	pointer
;	O
p	pointer
=	O
strchr	function
(	O
*	O
pp	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
p	pointer
[	O
1	int
]	O
!=	O
':'	O
)	O
break	O
;	O
if	O
(	O
(	O
*	O
pp	pointer
)	O
[	O
0	int
]	O
!=	O
'o'	O
||	O
(	O
*	O
pp	pointer
)	O
[	O
1	int
]	O
!=	O
'p'	O
||	O
(	O
*	O
pp	pointer
)	O
[	O
2	int
]	O
!=	O
'$'	O
)	O
{	O
name	pointer
=	O
savestring	function
(	O
*	O
pp	pointer
,	O
p	pointer
-	O
*	O
pp	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
2	int
;	O
}	O
else	O
{	O
*	O
pp	pointer
=	O
p	pointer
+	O
2	int
;	O
for	O
(	O
p	pointer
=	O
*	O
pp	pointer
;	O
*	O
p	pointer
!=	O
'.'	O
&&	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
'.'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
name	pointer
=	O
savestring	function
(	O
*	O
pp	pointer
,	O
p	pointer
-	O
*	O
pp	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
}	O
allocvars	int
=	O
10	int
;	O
variants	pointer
=	O
(	O
(	O
debug_method_variant	pointer
*	O
)	O
xmalloc	function
(	O
allocvars	int
*	O
sizeof	O
*	O
variants	pointer
)	O
)	O
;	O
cvars	int
=	O
0	int
;	O
look_ahead_type	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
do	O
{	O
debug_type	pointer
type	enum
;	O
bfd_boolean	int
stub	int
;	O
enum	O
debug_visibility	enum
visibility	enum
;	O
bfd_boolean	int
constp	int
,	O
volatilep	int
,	O
staticp	int
;	O
bfd_vma	long
voffset	long
;	O
debug_type	pointer
context	pointer
;	O
const	O
char	O
*	O
physname	pointer
;	O
bfd_boolean	int
varargs	int
;	O
if	O
(	O
look_ahead_type	pointer
!=	O
DEBUG_TYPE_NULL	O
)	O
{	O
type	enum
=	O
look_ahead_type	pointer
;	O
look_ahead_type	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
}	O
else	O
{	O
type	enum
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
type	enum
==	O
DEBUG_TYPE_NULL	O
)	O
goto	O
fail	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
':'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
}	O
++	O
*	O
pp	pointer
;	O
p	pointer
=	O
strchr	function
(	O
*	O
pp	pointer
,	O
';'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
stub	int
=	O
FALSE	int
;	O
if	O
(	O
debug_get_type_kind	function
(	O
dhandle	pointer
,	O
type	enum
)	O
==	O
DEBUG_KIND_METHOD	int
&&	O
debug_get_parameter_types	function
(	O
dhandle	pointer
,	O
type	enum
,	O
&	O
varargs	int
)	O
==	O
NULL	O
)	O
stub	int
=	O
TRUE	int
;	O
argtypes	pointer
=	O
savestring	function
(	O
*	O
pp	pointer
,	O
p	pointer
-	O
*	O
pp	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'0'	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PRIVATE	int
;	O
break	O
;	O
case	O
'1'	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PROTECTED	int
;	O
break	O
;	O
case	O
0	int
:	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
goto	O
fail	O
;	O
default	O
:	O
visibility	enum
=	O
DEBUG_VISIBILITY_PUBLIC	int
;	O
break	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
constp	int
=	O
FALSE	int
;	O
volatilep	int
=	O
FALSE	int
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'A'	O
:	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'B'	O
:	O
constp	int
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'C'	O
:	O
volatilep	int
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'D'	O
:	O
constp	int
=	O
TRUE	int
;	O
volatilep	int
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'*'	O
:	O
case	O
'?'	O
:	O
case	O
'.'	O
:	O
break	O
;	O
default	O
:	O
warn_stab	function
(	O
orig	pointer
,	O
_	O
(	O
"const/volatile indicator missing"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
staticp	int
=	O
FALSE	int
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'*'	O
:	O
++	O
*	O
pp	pointer
;	O
voffset	long
=	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
voffset	long
&=	O
0x7fffffff	int
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
';'	O
||	O
*	O
*	O
pp	pointer
==	O
'\0'	O
)	O
{	O
context	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
}	O
else	O
{	O
look_ahead_type	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
':'	O
)	O
{	O
context	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
}	O
else	O
{	O
context	pointer
=	O
look_ahead_type	pointer
;	O
look_ahead_type	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
}	O
}	O
break	O
;	O
case	O
'?'	O
:	O
++	O
*	O
pp	pointer
;	O
staticp	int
=	O
TRUE	int
;	O
voffset	long
=	O
0	int
;	O
context	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
strncmp	function
(	O
argtypes	pointer
,	O
name	pointer
,	O
strlen	function
(	O
name	pointer
)	O
)	O
!=	O
0	int
)	O
stub	int
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
warn_stab	function
(	O
orig	pointer
,	O
"member function type missing"	pointer
)	O
;	O
voffset	long
=	O
0	int
;	O
context	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
break	O
;	O
case	O
'.'	O
:	O
++	O
*	O
pp	pointer
;	O
voffset	long
=	O
0	int
;	O
context	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
break	O
;	O
}	O
physname	pointer
=	O
argtypes	pointer
;	O
if	O
(	O
stub	int
)	O
{	O
debug_type	pointer
class_type	pointer
,	O
return_type	pointer
;	O
class_type	pointer
=	O
stab_find_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
typenums	array
)	O
;	O
if	O
(	O
class_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
goto	O
fail	O
;	O
return_type	pointer
=	O
debug_get_return_type	function
(	O
dhandle	pointer
,	O
type	enum
)	O
;	O
if	O
(	O
return_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
goto	O
fail	O
;	O
}	O
type	enum
=	O
parse_stab_argtypes	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
class_type	pointer
,	O
name	pointer
,	O
tagname	pointer
,	O
return_type	pointer
,	O
argtypes	pointer
,	O
constp	int
,	O
volatilep	int
,	O
&	O
physname	pointer
)	O
;	O
if	O
(	O
type	enum
==	O
DEBUG_TYPE_NULL	O
)	O
goto	O
fail	O
;	O
}	O
if	O
(	O
cvars	int
+	O
1	int
>=	O
allocvars	int
)	O
{	O
allocvars	int
+=	O
10	int
;	O
variants	pointer
=	O
(	O
(	O
debug_method_variant	pointer
*	O
)	O
xrealloc	function
(	O
variants	pointer
,	O
allocvars	int
*	O
sizeof	O
*	O
variants	pointer
)	O
)	O
;	O
}	O
if	O
(	O
!	O
staticp	int
)	O
variants	pointer
[	O
cvars	int
]	O
=	O
debug_make_method_variant	function
(	O
dhandle	pointer
,	O
physname	pointer
,	O
type	enum
,	O
visibility	enum
,	O
constp	int
,	O
volatilep	int
,	O
voffset	long
,	O
context	pointer
)	O
;	O
else	O
variants	pointer
[	O
cvars	int
]	O
=	O
debug_make_static_method_variant	function
(	O
dhandle	pointer
,	O
physname	pointer
,	O
type	enum
,	O
visibility	enum
,	O
constp	int
,	O
volatilep	int
)	O
;	O
if	O
(	O
variants	pointer
[	O
cvars	int
]	O
==	O
DEBUG_METHOD_VARIANT_NULL	O
)	O
goto	O
fail	O
;	O
++	O
cvars	int
;	O
}	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
&&	O
*	O
*	O
pp	pointer
!=	O
'\0'	O
)	O
;	O
variants	pointer
[	O
cvars	int
]	O
=	O
DEBUG_METHOD_VARIANT_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'\0'	O
)	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
c	long
+	O
1	int
>=	O
alloc	int
)	O
{	O
alloc	int
+=	O
10	int
;	O
methods	pointer
=	O
(	O
(	O
debug_method	pointer
*	O
)	O
xrealloc	function
(	O
methods	pointer
,	O
alloc	int
*	O
sizeof	O
*	O
methods	pointer
)	O
)	O
;	O
}	O
methods	pointer
[	O
c	long
]	O
=	O
debug_make_method	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
variants	pointer
)	O
;	O
++	O
c	long
;	O
}	O
if	O
(	O
methods	pointer
!=	O
NULL	O
)	O
methods	pointer
[	O
c	long
]	O
=	O
DEBUG_METHOD_NULL	O
;	O
*	O
retp	pointer
=	O
methods	pointer
;	O
return	O
TRUE	int
;	O
fail	O
:	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
variants	pointer
!=	O
NULL	O
)	O
free	function
(	O
variants	pointer
)	O
;	O
if	O
(	O
argtypes	pointer
!=	O
NULL	O
)	O
free	function
(	O
argtypes	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
debug_type	pointer
parse_stab_argtypes	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
debug_type	pointer
class_type	pointer
,	O
const	O
char	O
*	O
fieldname	pointer
,	O
const	O
char	O
*	O
tagname	pointer
,	O
debug_type	pointer
return_type	pointer
,	O
const	O
char	O
*	O
argtypes	pointer
,	O
bfd_boolean	int
constp	int
,	O
bfd_boolean	int
volatilep	int
,	O
const	O
char	O
*	O
*	O
pphysname	pointer
)	O
{	O
bfd_boolean	int
is_full_physname_constructor	int
;	O
bfd_boolean	int
is_constructor	int
;	O
bfd_boolean	int
is_destructor	int
;	O
bfd_boolean	int
is_v3	int
;	O
debug_type	pointer
*	O
args	int
;	O
bfd_boolean	int
varargs	int
;	O
unsigned	O
int	O
physname_len	int
=	O
0	int
;	O
is_full_physname_constructor	int
=	O
(	O
(	O
argtypes	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
argtypes	pointer
[	O
1	int
]	O
==	O
'_'	O
&&	O
(	O
ISDIGIT	O
(	O
argtypes	pointer
[	O
2	int
]	O
)	O
||	O
argtypes	pointer
[	O
2	int
]	O
==	O
'Q'	O
||	O
argtypes	pointer
[	O
2	int
]	O
==	O
't'	O
)	O
)	O
||	O
CONST_STRNEQ	O
(	O
argtypes	pointer
,	O
"__ct"	pointer
)	O
)	O
;	O
is_constructor	int
=	O
(	O
is_full_physname_constructor	int
||	O
(	O
tagname	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
fieldname	pointer
,	O
tagname	pointer
)	O
==	O
0	int
)	O
)	O
;	O
is_destructor	int
=	O
(	O
(	O
argtypes	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
(	O
argtypes	pointer
[	O
1	int
]	O
==	O
'$'	O
||	O
argtypes	pointer
[	O
1	int
]	O
==	O
'.'	O
)	O
&&	O
argtypes	pointer
[	O
2	int
]	O
==	O
'_'	O
)	O
||	O
CONST_STRNEQ	O
(	O
argtypes	pointer
,	O
"__dt"	pointer
)	O
)	O
;	O
is_v3	int
=	O
argtypes	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
argtypes	pointer
[	O
1	int
]	O
==	O
'Z'	O
;	O
if	O
(	O
!	O
(	O
is_destructor	int
||	O
is_full_physname_constructor	int
||	O
is_v3	int
)	O
)	O
{	O
unsigned	O
int	O
len	long
;	O
const	O
char	O
*	O
const_prefix	pointer
;	O
const	O
char	O
*	O
volatile_prefix	pointer
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
unsigned	O
int	O
mangled_name_len	int
;	O
char	O
*	O
physname	pointer
;	O
len	long
=	O
tagname	pointer
==	O
NULL	O
?	O
0	int
:	O
strlen	function
(	O
tagname	pointer
)	O
;	O
const_prefix	pointer
=	O
constp	int
?	O
"C"	pointer
:	O
""	pointer
;	O
volatile_prefix	pointer
=	O
volatilep	int
?	O
"V"	pointer
:	O
""	pointer
;	O
if	O
(	O
len	long
==	O
0	int
)	O
sprintf	function
(	O
buf	pointer
,	O
"__%s%s"	pointer
,	O
const_prefix	pointer
,	O
volatile_prefix	pointer
)	O
;	O
else	O
if	O
(	O
tagname	pointer
!=	O
NULL	O
&&	O
strchr	function
(	O
tagname	pointer
,	O
'<'	O
)	O
!=	O
NULL	O
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"__%s%s"	pointer
,	O
const_prefix	pointer
,	O
volatile_prefix	pointer
)	O
;	O
tagname	pointer
=	O
NULL	O
;	O
len	long
=	O
0	int
;	O
}	O
else	O
sprintf	function
(	O
buf	pointer
,	O
"__%s%s%d"	pointer
,	O
const_prefix	pointer
,	O
volatile_prefix	pointer
,	O
len	long
)	O
;	O
mangled_name_len	int
=	O
(	O
(	O
is_constructor	int
?	O
0	int
:	O
strlen	function
(	O
fieldname	pointer
)	O
)	O
+	O
strlen	function
(	O
buf	pointer
)	O
+	O
len	long
+	O
strlen	function
(	O
argtypes	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
fieldname	pointer
[	O
0	int
]	O
==	O
'o'	O
&&	O
fieldname	pointer
[	O
1	int
]	O
==	O
'p'	O
&&	O
(	O
fieldname	pointer
[	O
2	int
]	O
==	O
'$'	O
||	O
fieldname	pointer
[	O
2	int
]	O
==	O
'.'	O
)	O
)	O
{	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
physname	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
mangled_name_len	int
)	O
;	O
if	O
(	O
is_constructor	int
)	O
physname	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
strcpy	function
(	O
physname	pointer
,	O
fieldname	pointer
)	O
;	O
physname_len	int
=	O
strlen	function
(	O
physname	pointer
)	O
;	O
strcat	function
(	O
physname	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
tagname	pointer
!=	O
NULL	O
)	O
strcat	function
(	O
physname	pointer
,	O
tagname	pointer
)	O
;	O
strcat	function
(	O
physname	pointer
,	O
argtypes	pointer
)	O
;	O
*	O
pphysname	pointer
=	O
physname	pointer
;	O
}	O
if	O
(	O
*	O
argtypes	pointer
==	O
'\0'	O
||	O
is_destructor	int
)	O
{	O
args	int
=	O
(	O
debug_type	pointer
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
args	int
)	O
;	O
*	O
args	int
=	O
NULL	O
;	O
return	O
debug_make_method_type	function
(	O
dhandle	pointer
,	O
return_type	pointer
,	O
class_type	pointer
,	O
args	int
,	O
FALSE	int
)	O
;	O
}	O
args	int
=	O
stab_demangle_argtypes	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
*	O
pphysname	pointer
,	O
&	O
varargs	int
,	O
physname_len	int
)	O
;	O
if	O
(	O
args	int
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
return	O
debug_make_method_type	function
(	O
dhandle	pointer
,	O
return_type	pointer
,	O
class_type	pointer
,	O
args	int
,	O
varargs	int
)	O
;	O
}	O
static	O
bfd_boolean	int
parse_stab_tilde_field	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
int	O
*	O
typenums	array
,	O
debug_type	pointer
*	O
retvptrbase	pointer
,	O
bfd_boolean	int
*	O
retownvptr	pointer
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
const	O
char	O
*	O
hold	pointer
;	O
int	O
vtypenums	array
[	O
2	int
]	O
;	O
*	O
retvptrbase	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
*	O
retownvptr	pointer
=	O
FALSE	int
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
';'	O
)	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'~'	O
)	O
return	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'='	O
||	O
*	O
*	O
pp	pointer
==	O
'+'	O
||	O
*	O
*	O
pp	pointer
==	O
'-'	O
)	O
{	O
++	O
*	O
pp	pointer
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'%'	O
)	O
return	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
hold	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
parse_stab_type_number	function
(	O
pp	pointer
,	O
vtypenums	array
,	O
p_end	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
vtypenums	array
[	O
0	int
]	O
==	O
typenums	array
[	O
0	int
]	O
&&	O
vtypenums	array
[	O
1	int
]	O
==	O
typenums	array
[	O
1	int
]	O
)	O
*	O
retownvptr	pointer
=	O
TRUE	int
;	O
else	O
{	O
debug_type	pointer
vtype	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
*	O
pp	pointer
=	O
hold	pointer
;	O
vtype	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
*	O
pp	pointer
;	O
*	O
p	pointer
!=	O
';'	O
&&	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
*	O
retvptrbase	pointer
=	O
vtype	pointer
;	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	pointer
parse_stab_array_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
bfd_boolean	int
stringp	int
,	O
const	O
char	O
*	O
p_end	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
int	O
typenums	array
[	O
2	int
]	O
;	O
debug_type	pointer
index_type	pointer
;	O
bfd_boolean	int
adjustable	int
;	O
bfd_signed_vma	long
lower	long
,	O
upper	long
;	O
debug_type	pointer
element_type	pointer
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
orig	pointer
>=	O
p_end	pointer
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
p	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
parse_stab_type_number	function
(	O
&	O
p	pointer
,	O
typenums	array
,	O
p_end	pointer
)	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
typenums	array
[	O
0	int
]	O
==	O
0	int
&&	O
typenums	array
[	O
1	int
]	O
==	O
0	int
&&	O
*	O
*	O
pp	pointer
!=	O
'='	O
)	O
{	O
index_type	pointer
=	O
debug_find_named_type	function
(	O
dhandle	pointer
,	O
"int"	pointer
)	O
;	O
if	O
(	O
index_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
index_type	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
index_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
*	O
pp	pointer
=	O
p	pointer
;	O
}	O
else	O
{	O
index_type	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
adjustable	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
&&	O
*	O
*	O
pp	pointer
!=	O
'-'	O
&&	O
*	O
*	O
pp	pointer
!=	O
0	int
)	O
{	O
++	O
*	O
pp	pointer
;	O
adjustable	int
=	O
TRUE	int
;	O
}	O
lower	long
=	O
(	O
bfd_signed_vma	long
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
&&	O
*	O
*	O
pp	pointer
!=	O
'-'	O
&&	O
*	O
*	O
pp	pointer
!=	O
0	int
)	O
{	O
++	O
*	O
pp	pointer
;	O
adjustable	int
=	O
TRUE	int
;	O
}	O
upper	long
=	O
(	O
bfd_signed_vma	long
)	O
parse_number	function
(	O
pp	pointer
,	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
';'	O
)	O
{	O
bad_stab	function
(	O
orig	pointer
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
element_type	pointer
=	O
parse_stab_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
,	O
p_end	pointer
)	O
;	O
if	O
(	O
element_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
adjustable	int
)	O
{	O
lower	long
=	O
0	int
;	O
upper	long
=	O
-	O
1	int
;	O
}	O
return	O
debug_make_array_type	function
(	O
dhandle	pointer
,	O
element_type	pointer
,	O
index_type	pointer
,	O
lower	long
,	O
upper	long
,	O
stringp	int
)	O
;	O
}	O
struct	O
bincl_file	struct
{	O
struct	O
bincl_file	struct
*	O
next	pointer
;	O
struct	O
bincl_file	struct
*	O
next_stack	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
bfd_vma	long
hash	long
;	O
unsigned	O
int	O
file	pointer
;	O
struct	O
stab_types	struct
*	O
file_types	pointer
;	O
}	O
;	O
static	O
void	O
push_bincl	function
(	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
bfd_vma	long
hash	long
)	O
{	O
struct	O
bincl_file	struct
*	O
n	long
;	O
n	long
=	O
(	O
struct	O
bincl_file	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
n	long
)	O
;	O
n	long
->	O
next	pointer
=	O
info	pointer
->	O
bincl_list	pointer
;	O
n	long
->	O
next_stack	pointer
=	O
info	pointer
->	O
bincl_stack	pointer
;	O
n	long
->	O
name	pointer
=	O
name	pointer
;	O
n	long
->	O
hash	long
=	O
hash	long
;	O
n	long
->	O
file	pointer
=	O
info	pointer
->	O
files	int
;	O
n	long
->	O
file_types	pointer
=	O
NULL	O
;	O
info	pointer
->	O
bincl_list	pointer
=	O
n	long
;	O
info	pointer
->	O
bincl_stack	pointer
=	O
n	long
;	O
++	O
info	pointer
->	O
files	int
;	O
info	pointer
->	O
file_types	pointer
=	O
(	O
(	O
struct	O
stab_types	struct
*	O
*	O
)	O
xrealloc	function
(	O
info	pointer
->	O
file_types	pointer
,	O
(	O
info	pointer
->	O
files	int
*	O
sizeof	O
*	O
info	pointer
->	O
file_types	pointer
)	O
)	O
)	O
;	O
info	pointer
->	O
file_types	pointer
[	O
n	long
->	O
file	pointer
]	O
=	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
pop_bincl	function
(	O
struct	O
stab_handle	struct
*	O
info	pointer
)	O
{	O
struct	O
bincl_file	struct
*	O
o	pointer
;	O
o	pointer
=	O
info	pointer
->	O
bincl_stack	pointer
;	O
if	O
(	O
o	pointer
==	O
NULL	O
)	O
return	O
info	pointer
->	O
main_filename	pointer
;	O
info	pointer
->	O
bincl_stack	pointer
=	O
o	pointer
->	O
next_stack	pointer
;	O
if	O
(	O
o	pointer
->	O
file	pointer
>=	O
info	pointer
->	O
files	int
)	O
return	O
info	pointer
->	O
main_filename	pointer
;	O
o	pointer
->	O
file_types	pointer
=	O
info	pointer
->	O
file_types	pointer
[	O
o	pointer
->	O
file	pointer
]	O
;	O
if	O
(	O
info	pointer
->	O
bincl_stack	pointer
==	O
NULL	O
)	O
return	O
info	pointer
->	O
main_filename	pointer
;	O
return	O
info	pointer
->	O
bincl_stack	pointer
->	O
name	pointer
;	O
}	O
static	O
bfd_boolean	int
find_excl	function
(	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
bfd_vma	long
hash	long
)	O
{	O
struct	O
bincl_file	struct
*	O
l	pointer
;	O
++	O
info	pointer
->	O
files	int
;	O
info	pointer
->	O
file_types	pointer
=	O
(	O
(	O
struct	O
stab_types	struct
*	O
*	O
)	O
xrealloc	function
(	O
info	pointer
->	O
file_types	pointer
,	O
(	O
info	pointer
->	O
files	int
*	O
sizeof	O
*	O
info	pointer
->	O
file_types	pointer
)	O
)	O
)	O
;	O
for	O
(	O
l	pointer
=	O
info	pointer
->	O
bincl_list	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
if	O
(	O
l	pointer
->	O
hash	long
==	O
hash	long
&&	O
strcmp	function
(	O
l	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
l	pointer
==	O
NULL	O
)	O
{	O
warn_stab	function
(	O
name	pointer
,	O
_	O
(	O
"Undefined N_EXCL"	pointer
)	O
)	O
;	O
info	pointer
->	O
file_types	pointer
[	O
info	pointer
->	O
files	int
-	O
1	int
]	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
info	pointer
->	O
file_types	pointer
[	O
info	pointer
->	O
files	int
-	O
1	int
]	O
=	O
l	pointer
->	O
file_types	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_record_variable	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
type	enum
,	O
enum	O
debug_var_kind	enum
kind	enum
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
stab_pending_var	struct
*	O
v	long
;	O
if	O
(	O
(	O
kind	enum
==	O
DEBUG_GLOBAL	int
||	O
kind	enum
==	O
DEBUG_STATIC	int
)	O
||	O
!	O
info	pointer
->	O
within_function	int
||	O
(	O
info	pointer
->	O
gcc_compiled	int
==	O
0	int
&&	O
info	pointer
->	O
n_opt_found	int
)	O
)	O
return	O
debug_record_variable	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
type	enum
,	O
kind	enum
,	O
val	array
)	O
;	O
v	long
=	O
(	O
struct	O
stab_pending_var	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
v	long
)	O
;	O
memset	function
(	O
v	long
,	O
0	int
,	O
sizeof	O
*	O
v	long
)	O
;	O
v	long
->	O
next	pointer
=	O
info	pointer
->	O
pending	pointer
;	O
v	long
->	O
name	pointer
=	O
name	pointer
;	O
v	long
->	O
type	enum
=	O
type	enum
;	O
v	long
->	O
kind	enum
=	O
kind	enum
;	O
v	long
->	O
val	array
=	O
val	array
;	O
info	pointer
->	O
pending	pointer
=	O
v	long
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_emit_pending_vars	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
)	O
{	O
struct	O
stab_pending_var	struct
*	O
v	long
;	O
v	long
=	O
info	pointer
->	O
pending	pointer
;	O
while	O
(	O
v	long
!=	O
NULL	O
)	O
{	O
struct	O
stab_pending_var	struct
*	O
next	pointer
;	O
if	O
(	O
!	O
debug_record_variable	function
(	O
dhandle	pointer
,	O
v	long
->	O
name	pointer
,	O
v	long
->	O
type	enum
,	O
v	long
->	O
kind	enum
,	O
v	long
->	O
val	array
)	O
)	O
return	O
FALSE	int
;	O
next	pointer
=	O
v	long
->	O
next	pointer
;	O
free	function
(	O
v	long
)	O
;	O
v	long
=	O
next	pointer
;	O
}	O
info	pointer
->	O
pending	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	pointer
*	O
stab_find_slot	function
(	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
int	O
*	O
typenums	array
)	O
{	O
int	O
filenum	int
;	O
int	O
tindex	int
;	O
struct	O
stab_types	struct
*	O
*	O
ps	pointer
;	O
filenum	int
=	O
typenums	array
[	O
0	int
]	O
;	O
tindex	int
=	O
typenums	array
[	O
1	int
]	O
;	O
if	O
(	O
filenum	int
<	O
0	int
||	O
(	O
unsigned	O
int	O
)	O
filenum	int
>=	O
info	pointer
->	O
files	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Type file number %d out of range\n"	pointer
)	O
,	O
filenum	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
tindex	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Type index number %d out of range\n"	pointer
)	O
,	O
tindex	int
)	O
;	O
return	O
NULL	O
;	O
}	O
ps	pointer
=	O
info	pointer
->	O
file_types	pointer
+	O
filenum	int
;	O
while	O
(	O
tindex	int
>=	O
STAB_TYPES_SLOTS	O
)	O
{	O
if	O
(	O
*	O
ps	pointer
==	O
NULL	O
)	O
{	O
*	O
ps	pointer
=	O
(	O
struct	O
stab_types	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
*	O
ps	pointer
)	O
;	O
memset	function
(	O
*	O
ps	pointer
,	O
0	int
,	O
sizeof	O
*	O
*	O
ps	pointer
)	O
;	O
}	O
ps	pointer
=	O
&	O
(	O
*	O
ps	pointer
)	O
->	O
next	pointer
;	O
tindex	int
-=	O
STAB_TYPES_SLOTS	O
;	O
}	O
if	O
(	O
*	O
ps	pointer
==	O
NULL	O
)	O
{	O
*	O
ps	pointer
=	O
(	O
struct	O
stab_types	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
*	O
ps	pointer
)	O
;	O
memset	function
(	O
*	O
ps	pointer
,	O
0	int
,	O
sizeof	O
*	O
*	O
ps	pointer
)	O
;	O
}	O
return	O
(	O
*	O
ps	pointer
)	O
->	O
types	array
+	O
tindex	int
;	O
}	O
static	O
debug_type	pointer
stab_find_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
int	O
*	O
typenums	array
)	O
{	O
debug_type	pointer
*	O
slot	pointer
;	O
if	O
(	O
typenums	array
[	O
0	int
]	O
==	O
0	int
&&	O
typenums	array
[	O
1	int
]	O
<	O
0	int
)	O
{	O
return	O
stab_xcoff_builtin_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
typenums	array
[	O
1	int
]	O
)	O
;	O
}	O
slot	pointer
=	O
stab_find_slot	function
(	O
info	pointer
,	O
typenums	array
)	O
;	O
if	O
(	O
slot	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
slot	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
debug_make_indirect_type	function
(	O
dhandle	pointer
,	O
slot	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
return	O
*	O
slot	pointer
;	O
}	O
static	O
bfd_boolean	int
stab_record_type	function
(	O
void	O
*	O
dhandle	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
int	O
*	O
typenums	array
,	O
debug_type	pointer
type	enum
)	O
{	O
debug_type	pointer
*	O
slot	pointer
;	O
slot	pointer
=	O
stab_find_slot	function
(	O
info	pointer
,	O
typenums	array
)	O
;	O
if	O
(	O
slot	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
*	O
slot	pointer
=	O
type	enum
;	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	pointer
stab_xcoff_builtin_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
int	O
typenum	int
)	O
{	O
debug_type	pointer
rettype	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
typenum	int
>=	O
0	int
||	O
typenum	int
<	O
-	O
XCOFF_TYPE_COUNT	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Unrecognized XCOFF type %d\n"	pointer
)	O
,	O
typenum	int
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
info	pointer
->	O
xcoff_types	array
[	O
-	O
typenum	int
]	O
!=	O
NULL	O
)	O
return	O
info	pointer
->	O
xcoff_types	array
[	O
-	O
typenum	int
]	O
;	O
switch	O
(	O
-	O
typenum	int
)	O
{	O
case	O
1	int
:	O
name	pointer
=	O
"int"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
name	pointer
=	O
"char"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
3	int
:	O
name	pointer
=	O
"short"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
2	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
4	int
:	O
name	pointer
=	O
"long"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
5	int
:	O
name	pointer
=	O
"unsigned char"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
6	int
:	O
name	pointer
=	O
"signed char"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
7	int
:	O
name	pointer
=	O
"unsigned short"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
2	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
8	int
:	O
name	pointer
=	O
"unsigned int"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
9	int
:	O
name	pointer
=	O
"unsigned"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
10	int
:	O
name	pointer
=	O
"unsigned long"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
11	int
:	O
name	pointer
=	O
"void"	pointer
;	O
rettype	pointer
=	O
debug_make_void_type	function
(	O
dhandle	pointer
)	O
;	O
break	O
;	O
case	O
12	int
:	O
name	pointer
=	O
"float"	pointer
;	O
rettype	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
4	int
)	O
;	O
break	O
;	O
case	O
13	int
:	O
name	pointer
=	O
"double"	pointer
;	O
rettype	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
8	int
)	O
;	O
break	O
;	O
case	O
14	int
:	O
name	pointer
=	O
"long double"	pointer
;	O
rettype	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
8	int
)	O
;	O
break	O
;	O
case	O
15	int
:	O
name	pointer
=	O
"integer"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
16	int
:	O
name	pointer
=	O
"boolean"	pointer
;	O
rettype	pointer
=	O
debug_make_bool_type	function
(	O
dhandle	pointer
,	O
4	int
)	O
;	O
break	O
;	O
case	O
17	int
:	O
name	pointer
=	O
"short real"	pointer
;	O
rettype	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
4	int
)	O
;	O
break	O
;	O
case	O
18	int
:	O
name	pointer
=	O
"real"	pointer
;	O
rettype	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
8	int
)	O
;	O
break	O
;	O
case	O
19	int
:	O
name	pointer
=	O
"stringptr"	pointer
;	O
rettype	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
20	int
:	O
name	pointer
=	O
"character"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
21	int
:	O
name	pointer
=	O
"logical*1"	pointer
;	O
rettype	pointer
=	O
debug_make_bool_type	function
(	O
dhandle	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
22	int
:	O
name	pointer
=	O
"logical*2"	pointer
;	O
rettype	pointer
=	O
debug_make_bool_type	function
(	O
dhandle	pointer
,	O
2	int
)	O
;	O
break	O
;	O
case	O
23	int
:	O
name	pointer
=	O
"logical*4"	pointer
;	O
rettype	pointer
=	O
debug_make_bool_type	function
(	O
dhandle	pointer
,	O
4	int
)	O
;	O
break	O
;	O
case	O
24	int
:	O
name	pointer
=	O
"logical"	pointer
;	O
rettype	pointer
=	O
debug_make_bool_type	function
(	O
dhandle	pointer
,	O
4	int
)	O
;	O
break	O
;	O
case	O
25	int
:	O
name	pointer
=	O
"complex"	pointer
;	O
rettype	pointer
=	O
debug_make_complex_type	function
(	O
dhandle	pointer
,	O
8	int
)	O
;	O
break	O
;	O
case	O
26	int
:	O
name	pointer
=	O
"double complex"	pointer
;	O
rettype	pointer
=	O
debug_make_complex_type	function
(	O
dhandle	pointer
,	O
16	int
)	O
;	O
break	O
;	O
case	O
27	int
:	O
name	pointer
=	O
"integer*1"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
28	int
:	O
name	pointer
=	O
"integer*2"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
2	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
29	int
:	O
name	pointer
=	O
"integer*4"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
30	int
:	O
name	pointer
=	O
"wchar"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
2	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
31	int
:	O
name	pointer
=	O
"long long"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
32	int
:	O
name	pointer
=	O
"unsigned long long"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
33	int
:	O
name	pointer
=	O
"logical*8"	pointer
;	O
rettype	pointer
=	O
debug_make_bool_type	function
(	O
dhandle	pointer
,	O
8	int
)	O
;	O
break	O
;	O
case	O
34	int
:	O
name	pointer
=	O
"integer*8"	pointer
;	O
rettype	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
FALSE	int
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
rettype	pointer
=	O
debug_name_type	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
rettype	pointer
)	O
;	O
info	pointer
->	O
xcoff_types	array
[	O
-	O
typenum	int
]	O
=	O
rettype	pointer
;	O
return	O
rettype	pointer
;	O
}	O
static	O
debug_type	pointer
stab_find_tagged_type	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
p	pointer
,	O
int	O
len	long
,	O
enum	O
debug_type_kind	enum
kind	enum
)	O
{	O
char	O
*	O
name	pointer
;	O
debug_type	pointer
dtype	pointer
;	O
struct	O
stab_tag	struct
*	O
st	pointer
;	O
name	pointer
=	O
savestring	function
(	O
p	pointer
,	O
len	long
)	O
;	O
dtype	pointer
=	O
debug_find_tagged_type	function
(	O
dhandle	pointer
,	O
name	pointer
,	O
DEBUG_KIND_ILLEGAL	int
)	O
;	O
if	O
(	O
dtype	pointer
!=	O
DEBUG_TYPE_NULL	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
return	O
dtype	pointer
;	O
}	O
for	O
(	O
st	pointer
=	O
info	pointer
->	O
tags	pointer
;	O
st	pointer
!=	O
NULL	O
;	O
st	pointer
=	O
st	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
st	pointer
->	O
name	pointer
[	O
0	int
]	O
==	O
name	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
st	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
st	pointer
->	O
kind	enum
==	O
DEBUG_KIND_ILLEGAL	int
)	O
st	pointer
->	O
kind	enum
=	O
kind	enum
;	O
free	function
(	O
name	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
st	pointer
==	O
NULL	O
)	O
{	O
st	pointer
=	O
(	O
struct	O
stab_tag	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
st	pointer
)	O
;	O
memset	function
(	O
st	pointer
,	O
0	int
,	O
sizeof	O
*	O
st	pointer
)	O
;	O
st	pointer
->	O
next	pointer
=	O
info	pointer
->	O
tags	pointer
;	O
st	pointer
->	O
name	pointer
=	O
name	pointer
;	O
st	pointer
->	O
kind	enum
=	O
kind	enum
;	O
st	pointer
->	O
slot	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
st	pointer
->	O
type	enum
=	O
debug_make_indirect_type	function
(	O
dhandle	pointer
,	O
&	O
st	pointer
->	O
slot	pointer
,	O
name	pointer
)	O
;	O
info	pointer
->	O
tags	pointer
=	O
st	pointer
;	O
}	O
return	O
st	pointer
->	O
type	enum
;	O
}	O
struct	O
stab_demangle_typestring	struct
{	O
const	O
char	O
*	O
typestring	pointer
;	O
unsigned	O
int	O
len	long
;	O
}	O
;	O
struct	O
stab_demangle_info	struct
{	O
void	O
*	O
dhandle	pointer
;	O
struct	O
stab_handle	struct
*	O
info	pointer
;	O
debug_type	pointer
*	O
args	int
;	O
bfd_boolean	int
varargs	int
;	O
struct	O
stab_demangle_typestring	struct
*	O
typestrings	pointer
;	O
unsigned	O
int	O
typestring_count	int
;	O
unsigned	O
int	O
typestring_alloc	int
;	O
}	O
;	O
static	O
void	O
stab_bad_demangle	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
unsigned	O
int	O
stab_demangle_count	function
(	O
const	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_get_count	function
(	O
const	O
char	O
*	O
*	O
,	O
unsigned	O
int	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_prefix	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_function_name	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_signature	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_qualified	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	pointer
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_template	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_class	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
const	O
char	O
*	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_args	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	pointer
*	O
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_arg	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	pointer
*	O
*	O
,	O
unsigned	O
int	O
*	O
,	O
unsigned	O
int	O
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_type	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	pointer
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_fund_type	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
*	O
,	O
debug_type	pointer
*	O
)	O
;	O
static	O
bfd_boolean	int
stab_demangle_remember_type	function
(	O
struct	O
stab_demangle_info	struct
*	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
static	O
void	O
stab_bad_demangle	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"bad mangled name `%s'\n"	pointer
)	O
,	O
s	pointer
)	O
;	O
}	O
static	O
unsigned	O
int	O
stab_demangle_count	function
(	O
const	O
char	O
*	O
*	O
pp	pointer
)	O
{	O
unsigned	O
int	O
count	int
;	O
count	int
=	O
0	int
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
{	O
count	int
*=	O
10	int
;	O
count	int
+=	O
*	O
*	O
pp	pointer
-	O
'0'	O
;	O
++	O
*	O
pp	pointer
;	O
}	O
return	O
count	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_get_count	function
(	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
unsigned	O
int	O
*	O
pi	pointer
)	O
{	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
return	O
FALSE	int
;	O
*	O
pi	pointer
=	O
*	O
*	O
pp	pointer
-	O
'0'	O
;	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
{	O
unsigned	O
int	O
count	int
;	O
const	O
char	O
*	O
p	pointer
;	O
count	int
=	O
*	O
pi	pointer
;	O
p	pointer
=	O
*	O
pp	pointer
;	O
do	O
{	O
count	int
*=	O
10	int
;	O
count	int
+=	O
*	O
p	pointer
-	O
'0'	O
;	O
++	O
p	pointer
;	O
}	O
while	O
(	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'_'	O
)	O
{	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
*	O
pi	pointer
=	O
count	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	pointer
*	O
stab_demangle_argtypes	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
physname	pointer
,	O
bfd_boolean	int
*	O
pvarargs	pointer
,	O
unsigned	O
int	O
physname_len	int
)	O
{	O
struct	O
stab_demangle_info	struct
minfo	struct
;	O
if	O
(	O
physname	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
physname	pointer
[	O
1	int
]	O
==	O
'Z'	O
)	O
return	O
stab_demangle_v3_argtypes	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
physname	pointer
,	O
pvarargs	pointer
)	O
;	O
minfo	struct
.	O
dhandle	pointer
=	O
dhandle	pointer
;	O
minfo	struct
.	O
info	pointer
=	O
info	pointer
;	O
minfo	struct
.	O
args	int
=	O
NULL	O
;	O
minfo	struct
.	O
varargs	int
=	O
FALSE	int
;	O
minfo	struct
.	O
typestring_alloc	int
=	O
10	int
;	O
minfo	struct
.	O
typestrings	pointer
=	O
(	O
(	O
struct	O
stab_demangle_typestring	struct
*	O
)	O
xmalloc	function
(	O
minfo	struct
.	O
typestring_alloc	int
*	O
sizeof	O
*	O
minfo	struct
.	O
typestrings	pointer
)	O
)	O
;	O
minfo	struct
.	O
typestring_count	int
=	O
0	int
;	O
if	O
(	O
!	O
stab_demangle_prefix	function
(	O
&	O
minfo	struct
,	O
&	O
physname	pointer
,	O
physname_len	int
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
*	O
physname	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
!	O
stab_demangle_signature	function
(	O
&	O
minfo	struct
,	O
&	O
physname	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
free	function
(	O
minfo	struct
.	O
typestrings	pointer
)	O
;	O
minfo	struct
.	O
typestrings	pointer
=	O
NULL	O
;	O
if	O
(	O
minfo	struct
.	O
args	int
==	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"no argument types in mangled string\n"	pointer
)	O
)	O
;	O
*	O
pvarargs	pointer
=	O
minfo	struct
.	O
varargs	int
;	O
return	O
minfo	struct
.	O
args	int
;	O
error_return	O
:	O
if	O
(	O
minfo	struct
.	O
typestrings	pointer
!=	O
NULL	O
)	O
free	function
(	O
minfo	struct
.	O
typestrings	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_prefix	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
unsigned	O
int	O
physname_len	int
)	O
{	O
const	O
char	O
*	O
scan	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
physname_len	int
)	O
scan	pointer
=	O
*	O
pp	pointer
+	O
physname_len	int
;	O
else	O
{	O
scan	pointer
=	O
*	O
pp	pointer
;	O
do	O
scan	pointer
=	O
strchr	function
(	O
scan	pointer
,	O
'_'	O
)	O
;	O
while	O
(	O
scan	pointer
!=	O
NULL	O
&&	O
*	O
++	O
scan	pointer
!=	O
'_'	O
)	O
;	O
if	O
(	O
scan	pointer
==	O
NULL	O
)	O
{	O
stab_bad_demangle	function
(	O
*	O
pp	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
--	O
scan	pointer
;	O
i	pointer
=	O
strspn	function
(	O
scan	pointer
,	O
"_"	pointer
)	O
;	O
if	O
(	O
i	pointer
>	O
2	int
)	O
scan	pointer
+=	O
i	pointer
-	O
2	int
;	O
}	O
if	O
(	O
scan	pointer
==	O
*	O
pp	pointer
&&	O
(	O
ISDIGIT	O
(	O
scan	pointer
[	O
2	int
]	O
)	O
||	O
scan	pointer
[	O
2	int
]	O
==	O
'Q'	O
||	O
scan	pointer
[	O
2	int
]	O
==	O
't'	O
)	O
)	O
{	O
*	O
pp	pointer
=	O
scan	pointer
+	O
2	int
;	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
scan	pointer
==	O
*	O
pp	pointer
&&	O
!	O
ISDIGIT	O
(	O
scan	pointer
[	O
2	int
]	O
)	O
&&	O
scan	pointer
[	O
2	int
]	O
!=	O
't'	O
)	O
{	O
while	O
(	O
*	O
scan	pointer
==	O
'_'	O
)	O
++	O
scan	pointer
;	O
scan	pointer
=	O
strstr	function
(	O
scan	pointer
,	O
"__"	pointer
)	O
;	O
if	O
(	O
scan	pointer
==	O
NULL	O
||	O
scan	pointer
[	O
2	int
]	O
==	O
'\0'	O
)	O
{	O
stab_bad_demangle	function
(	O
*	O
pp	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
stab_demangle_function_name	function
(	O
minfo	struct
,	O
pp	pointer
,	O
scan	pointer
)	O
;	O
}	O
else	O
if	O
(	O
scan	pointer
[	O
2	int
]	O
!=	O
'\0'	O
)	O
{	O
return	O
stab_demangle_function_name	function
(	O
minfo	struct
,	O
pp	pointer
,	O
scan	pointer
)	O
;	O
}	O
else	O
{	O
stab_bad_demangle	function
(	O
*	O
pp	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
stab_demangle_function_name	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
char	O
*	O
scan	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
*	O
pp	pointer
;	O
*	O
pp	pointer
=	O
scan	pointer
+	O
2	int
;	O
if	O
(	O
*	O
pp	pointer
-	O
name	pointer
>=	O
5	int
&&	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
"type"	pointer
)	O
&&	O
(	O
name	pointer
[	O
4	int
]	O
==	O
'$'	O
||	O
name	pointer
[	O
4	int
]	O
==	O
'.'	O
)	O
)	O
{	O
const	O
char	O
*	O
tem	pointer
;	O
tem	pointer
=	O
name	pointer
+	O
5	int
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
&	O
tem	pointer
,	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'_'	O
&&	O
name	pointer
[	O
2	int
]	O
==	O
'o'	O
&&	O
name	pointer
[	O
3	int
]	O
==	O
'p'	O
)	O
{	O
const	O
char	O
*	O
tem	pointer
;	O
tem	pointer
=	O
name	pointer
+	O
4	int
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
&	O
tem	pointer
,	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_signature	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
bfd_boolean	int
expect_func	int
,	O
func_done	int
;	O
const	O
char	O
*	O
hold	pointer
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
expect_func	int
=	O
FALSE	int
;	O
func_done	int
=	O
FALSE	int
;	O
hold	pointer
=	O
NULL	O
;	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'Q'	O
:	O
hold	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_qualified	function
(	O
minfo	struct
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
)	O
||	O
!	O
stab_demangle_remember_type	function
(	O
minfo	struct
,	O
hold	pointer
,	O
*	O
pp	pointer
-	O
hold	pointer
)	O
)	O
return	O
FALSE	int
;	O
expect_func	int
=	O
TRUE	int
;	O
hold	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'S'	O
:	O
if	O
(	O
hold	pointer
==	O
NULL	O
)	O
hold	pointer
=	O
*	O
pp	pointer
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
hold	pointer
==	O
NULL	O
)	O
hold	pointer
=	O
*	O
pp	pointer
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
hold	pointer
==	O
NULL	O
)	O
hold	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_class	function
(	O
minfo	struct
,	O
pp	pointer
,	O
(	O
const	O
char	O
*	O
*	O
)	O
NULL	O
)	O
||	O
!	O
stab_demangle_remember_type	function
(	O
minfo	struct
,	O
hold	pointer
,	O
*	O
pp	pointer
-	O
hold	pointer
)	O
)	O
return	O
FALSE	int
;	O
expect_func	int
=	O
TRUE	int
;	O
hold	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'F'	O
:	O
hold	pointer
=	O
NULL	O
;	O
func_done	int
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_args	function
(	O
minfo	struct
,	O
pp	pointer
,	O
&	O
minfo	struct
->	O
args	int
,	O
&	O
minfo	struct
->	O
varargs	int
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
't'	O
:	O
if	O
(	O
hold	pointer
==	O
NULL	O
)	O
hold	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_template	function
(	O
minfo	struct
,	O
pp	pointer
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
||	O
!	O
stab_demangle_remember_type	function
(	O
minfo	struct
,	O
hold	pointer
,	O
*	O
pp	pointer
-	O
hold	pointer
)	O
)	O
return	O
FALSE	int
;	O
hold	pointer
=	O
NULL	O
;	O
expect_func	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'_'	O
:	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
default	O
:	O
func_done	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
stab_demangle_args	function
(	O
minfo	struct
,	O
pp	pointer
,	O
&	O
minfo	struct
->	O
args	int
,	O
&	O
minfo	struct
->	O
varargs	int
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
}	O
if	O
(	O
expect_func	int
)	O
{	O
func_done	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
stab_demangle_args	function
(	O
minfo	struct
,	O
pp	pointer
,	O
&	O
minfo	struct
->	O
args	int
,	O
&	O
minfo	struct
->	O
varargs	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
func_done	int
)	O
{	O
if	O
(	O
!	O
stab_demangle_args	function
(	O
minfo	struct
,	O
pp	pointer
,	O
&	O
minfo	struct
->	O
args	int
,	O
&	O
minfo	struct
->	O
varargs	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_qualified	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_type	pointer
*	O
ptype	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
unsigned	O
int	O
qualifiers	int
;	O
debug_type	pointer
context	pointer
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
switch	O
(	O
(	O
*	O
pp	pointer
)	O
[	O
1	int
]	O
)	O
{	O
case	O
'_'	O
:	O
p	pointer
=	O
*	O
pp	pointer
+	O
2	int
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
||	O
*	O
p	pointer
==	O
'0'	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
qualifiers	int
=	O
atoi	function
(	O
p	pointer
)	O
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
p	pointer
)	O
)	O
++	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
!=	O
'_'	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
*	O
pp	pointer
=	O
p	pointer
+	O
1	int
;	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
qualifiers	int
=	O
(	O
*	O
pp	pointer
)	O
[	O
1	int
]	O
-	O
'0'	O
;	O
if	O
(	O
(	O
*	O
pp	pointer
)	O
[	O
2	int
]	O
==	O
'_'	O
)	O
++	O
*	O
pp	pointer
;	O
*	O
pp	pointer
+=	O
2	int
;	O
break	O
;	O
case	O
'0'	O
:	O
default	O
:	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
context	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
while	O
(	O
qualifiers	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'_'	O
)	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
't'	O
)	O
{	O
char	O
*	O
name	pointer
;	O
if	O
(	O
!	O
stab_demangle_template	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
!=	O
NULL	O
?	O
&	O
name	pointer
:	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
context	pointer
=	O
stab_find_tagged_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
minfo	struct
->	O
info	pointer
,	O
name	pointer
,	O
strlen	function
(	O
name	pointer
)	O
,	O
DEBUG_KIND_CLASS	int
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
context	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
len	long
;	O
len	long
=	O
stab_demangle_count	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
*	O
pp	pointer
)	O
<	O
len	long
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
const	O
debug_field	pointer
*	O
fields	pointer
;	O
fields	pointer
=	O
NULL	O
;	O
if	O
(	O
context	pointer
!=	O
DEBUG_TYPE_NULL	O
)	O
fields	pointer
=	O
debug_get_fields	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
context	pointer
)	O
;	O
context	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
fields	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
savestring	function
(	O
*	O
pp	pointer
,	O
len	long
)	O
;	O
for	O
(	O
;	O
*	O
fields	pointer
!=	O
DEBUG_FIELD_NULL	O
;	O
fields	pointer
++	O
)	O
{	O
debug_type	pointer
ft	pointer
;	O
const	O
char	O
*	O
dn	pointer
;	O
ft	pointer
=	O
debug_get_field_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
fields	pointer
)	O
;	O
if	O
(	O
ft	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
dn	pointer
=	O
debug_get_type_name	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
ft	pointer
)	O
;	O
if	O
(	O
dn	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
dn	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
context	pointer
=	O
ft	pointer
;	O
break	O
;	O
}	O
}	O
free	function
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
context	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
if	O
(	O
qualifiers	int
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
savestring	function
(	O
*	O
pp	pointer
,	O
len	long
)	O
;	O
context	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
context	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
context	pointer
=	O
stab_find_tagged_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
minfo	struct
->	O
info	pointer
,	O
*	O
pp	pointer
,	O
len	long
,	O
(	O
qualifiers	int
==	O
0	int
?	O
DEBUG_KIND_ILLEGAL	int
:	O
DEBUG_KIND_CLASS	int
)	O
)	O
;	O
if	O
(	O
context	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
*	O
pp	pointer
+=	O
len	long
;	O
}	O
}	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
*	O
ptype	pointer
=	O
context	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_template	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
char	O
*	O
*	O
pname	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
unsigned	O
int	O
r	int
,	O
i	pointer
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
++	O
*	O
pp	pointer
;	O
r	int
=	O
stab_demangle_count	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
r	int
==	O
0	int
||	O
strlen	function
(	O
*	O
pp	pointer
)	O
<	O
r	int
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
*	O
pp	pointer
+=	O
r	int
;	O
if	O
(	O
stab_demangle_get_count	function
(	O
pp	pointer
,	O
&	O
r	int
)	O
==	O
0	int
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
r	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'Z'	O
)	O
{	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
const	O
char	O
*	O
old_p	pointer
;	O
bfd_boolean	int
pointerp	int
,	O
realp	int
,	O
integralp	int
,	O
charp	int
,	O
boolp	int
;	O
bfd_boolean	int
done	int
;	O
old_p	pointer
=	O
*	O
pp	pointer
;	O
pointerp	int
=	O
FALSE	int
;	O
realp	int
=	O
FALSE	int
;	O
integralp	int
=	O
FALSE	int
;	O
charp	int
=	O
FALSE	int
;	O
boolp	int
=	O
FALSE	int
;	O
done	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
while	O
(	O
*	O
old_p	pointer
!=	O
'\0'	O
&&	O
!	O
done	int
)	O
{	O
switch	O
(	O
*	O
old_p	pointer
)	O
{	O
case	O
'P'	O
:	O
case	O
'p'	O
:	O
case	O
'R'	O
:	O
pointerp	int
=	O
TRUE	int
;	O
done	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'C'	O
:	O
case	O
'S'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'F'	O
:	O
case	O
'M'	O
:	O
case	O
'O'	O
:	O
++	O
old_p	pointer
;	O
break	O
;	O
case	O
'Q'	O
:	O
integralp	int
=	O
TRUE	int
;	O
done	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'T'	O
:	O
abort	function
(	O
)	O
;	O
case	O
'v'	O
:	O
abort	function
(	O
)	O
;	O
case	O
'x'	O
:	O
case	O
'l'	O
:	O
case	O
'i'	O
:	O
case	O
's'	O
:	O
case	O
'w'	O
:	O
integralp	int
=	O
TRUE	int
;	O
done	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'b'	O
:	O
boolp	int
=	O
TRUE	int
;	O
done	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'c'	O
:	O
charp	int
=	O
TRUE	int
;	O
done	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'd'	O
:	O
case	O
'f'	O
:	O
realp	int
=	O
TRUE	int
;	O
done	int
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
integralp	int
=	O
TRUE	int
;	O
done	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
integralp	int
)	O
{	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'm'	O
)	O
++	O
*	O
pp	pointer
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
++	O
*	O
pp	pointer
;	O
}	O
else	O
if	O
(	O
charp	int
)	O
{	O
unsigned	O
int	O
val	array
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'm'	O
)	O
++	O
*	O
pp	pointer
;	O
val	array
=	O
stab_demangle_count	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
val	array
==	O
0	int
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
if	O
(	O
boolp	int
)	O
{	O
unsigned	O
int	O
val	array
;	O
val	array
=	O
stab_demangle_count	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
val	array
!=	O
0	int
&&	O
val	array
!=	O
1	int
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
if	O
(	O
realp	int
)	O
{	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'm'	O
)	O
++	O
*	O
pp	pointer
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'.'	O
)	O
{	O
++	O
*	O
pp	pointer
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
++	O
*	O
pp	pointer
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'e'	O
)	O
{	O
++	O
*	O
pp	pointer
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
++	O
*	O
pp	pointer
;	O
}	O
}	O
else	O
if	O
(	O
pointerp	int
)	O
{	O
unsigned	O
int	O
len	long
;	O
len	long
=	O
stab_demangle_count	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
*	O
pp	pointer
+=	O
len	long
;	O
}	O
}	O
}	O
if	O
(	O
pname	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
s1	pointer
,	O
*	O
s2	pointer
,	O
*	O
s3	pointer
,	O
*	O
s4	pointer
=	O
NULL	O
;	O
char	O
*	O
from	pointer
,	O
*	O
to	pointer
;	O
s1	pointer
=	O
savestring	function
(	O
orig	pointer
,	O
*	O
pp	pointer
-	O
orig	pointer
)	O
;	O
s2	pointer
=	O
concat	function
(	O
"NoSuchStrinG__"	pointer
,	O
s1	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
free	function
(	O
s1	pointer
)	O
;	O
s3	pointer
=	O
cplus_demangle	function
(	O
s2	pointer
,	O
demangle_flags	int
)	O
;	O
free	function
(	O
s2	pointer
)	O
;	O
if	O
(	O
s3	pointer
!=	O
NULL	O
)	O
s4	pointer
=	O
strstr	function
(	O
s3	pointer
,	O
"::NoSuchStrinG"	pointer
)	O
;	O
if	O
(	O
s3	pointer
==	O
NULL	O
||	O
s4	pointer
==	O
NULL	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
if	O
(	O
s3	pointer
!=	O
NULL	O
)	O
free	function
(	O
s3	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
from	pointer
=	O
to	pointer
=	O
s3	pointer
;	O
from	pointer
!=	O
s4	pointer
;	O
++	O
from	pointer
)	O
if	O
(	O
*	O
from	pointer
!=	O
' '	O
||	O
(	O
from	pointer
[	O
1	int
]	O
==	O
'>'	O
&&	O
from	pointer
>	O
s3	pointer
&&	O
from	pointer
[	O
-	O
1	int
]	O
==	O
'>'	O
)	O
)	O
*	O
to	pointer
++	O
=	O
*	O
from	pointer
;	O
*	O
pname	pointer
=	O
savestring	function
(	O
s3	pointer
,	O
to	pointer
-	O
s3	pointer
)	O
;	O
free	function
(	O
s3	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_class	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
const	O
char	O
*	O
*	O
pstart	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
unsigned	O
int	O
n	long
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
n	long
=	O
stab_demangle_count	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
*	O
pp	pointer
)	O
<	O
n	long
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
pstart	pointer
!=	O
NULL	O
)	O
*	O
pstart	pointer
=	O
*	O
pp	pointer
;	O
*	O
pp	pointer
+=	O
n	long
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_args	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_type	pointer
*	O
*	O
pargs	pointer
,	O
bfd_boolean	int
*	O
pvarargs	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
unsigned	O
int	O
alloc	int
,	O
count	int
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
alloc	int
=	O
10	int
;	O
if	O
(	O
pargs	pointer
!=	O
NULL	O
)	O
{	O
*	O
pargs	pointer
=	O
(	O
debug_type	pointer
*	O
)	O
xmalloc	function
(	O
alloc	int
*	O
sizeof	O
*	O
*	O
pargs	pointer
)	O
;	O
*	O
pvarargs	pointer
=	O
FALSE	int
;	O
}	O
count	int
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
'_'	O
&&	O
*	O
*	O
pp	pointer
!=	O
'\0'	O
&&	O
*	O
*	O
pp	pointer
!=	O
'e'	O
)	O
{	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'N'	O
||	O
*	O
*	O
pp	pointer
==	O
'T'	O
)	O
{	O
char	O
temptype	char
;	O
unsigned	O
int	O
r	int
,	O
t	int
;	O
temptype	char
=	O
*	O
*	O
pp	pointer
;	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
temptype	char
==	O
'T'	O
)	O
r	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
!	O
stab_demangle_get_count	function
(	O
pp	pointer
,	O
&	O
r	int
)	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
stab_demangle_get_count	function
(	O
pp	pointer
,	O
&	O
t	int
)	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
t	int
>=	O
minfo	struct
->	O
typestring_count	int
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
while	O
(	O
r	int
--	O
>	O
0	int
)	O
{	O
const	O
char	O
*	O
tem	pointer
;	O
tem	pointer
=	O
minfo	struct
->	O
typestrings	pointer
[	O
t	int
]	O
.	O
typestring	pointer
;	O
if	O
(	O
!	O
stab_demangle_arg	function
(	O
minfo	struct
,	O
&	O
tem	pointer
,	O
pargs	pointer
,	O
&	O
count	int
,	O
&	O
alloc	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
stab_demangle_arg	function
(	O
minfo	struct
,	O
pp	pointer
,	O
pargs	pointer
,	O
&	O
count	int
,	O
&	O
alloc	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
pargs	pointer
!=	O
NULL	O
)	O
(	O
*	O
pargs	pointer
)	O
[	O
count	int
]	O
=	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'e'	O
)	O
{	O
if	O
(	O
pargs	pointer
!=	O
NULL	O
)	O
*	O
pvarargs	pointer
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_arg	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_type	pointer
*	O
*	O
pargs	pointer
,	O
unsigned	O
int	O
*	O
pcount	pointer
,	O
unsigned	O
int	O
*	O
palloc	pointer
)	O
{	O
const	O
char	O
*	O
start	pointer
;	O
debug_type	pointer
type	enum
;	O
start	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
pargs	pointer
==	O
NULL	O
?	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
:	O
&	O
type	enum
)	O
||	O
!	O
stab_demangle_remember_type	function
(	O
minfo	struct
,	O
start	pointer
,	O
*	O
pp	pointer
-	O
start	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
pargs	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
type	enum
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
pcount	pointer
+	O
1	int
>=	O
*	O
palloc	pointer
)	O
{	O
*	O
palloc	pointer
+=	O
10	int
;	O
*	O
pargs	pointer
=	O
(	O
(	O
debug_type	pointer
*	O
)	O
xrealloc	function
(	O
*	O
pargs	pointer
,	O
*	O
palloc	pointer
*	O
sizeof	O
*	O
*	O
pargs	pointer
)	O
)	O
;	O
}	O
(	O
*	O
pargs	pointer
)	O
[	O
*	O
pcount	pointer
]	O
=	O
type	enum
;	O
++	O
*	O
pcount	pointer
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_type	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_type	pointer
*	O
ptype	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'P'	O
:	O
case	O
'p'	O
:	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_pointer_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
ptype	pointer
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_reference_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
ptype	pointer
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
{	O
unsigned	O
long	O
high	long
;	O
++	O
*	O
pp	pointer
;	O
high	long
=	O
0	int
;	O
while	O
(	O
*	O
*	O
pp	pointer
!=	O
'\0'	O
&&	O
*	O
*	O
pp	pointer
!=	O
'_'	O
)	O
{	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
high	long
*=	O
10	int
;	O
high	long
+=	O
*	O
*	O
pp	pointer
-	O
'0'	O
;	O
++	O
*	O
pp	pointer
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'_'	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
debug_type	pointer
int_type	pointer
;	O
int_type	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
"int"	pointer
)	O
;	O
if	O
(	O
int_type	pointer
==	O
NULL	O
)	O
int_type	pointer
=	O
debug_make_int_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
*	O
ptype	pointer
=	O
debug_make_array_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
ptype	pointer
,	O
int_type	pointer
,	O
0	int
,	O
high	long
,	O
FALSE	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'T'	O
:	O
{	O
unsigned	O
int	O
i	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_get_count	function
(	O
pp	pointer
,	O
&	O
i	pointer
)	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
i	pointer
>=	O
minfo	struct
->	O
typestring_count	int
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
p	pointer
=	O
minfo	struct
->	O
typestrings	pointer
[	O
i	pointer
]	O
.	O
typestring	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
&	O
p	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
case	O
'F'	O
:	O
{	O
debug_type	pointer
*	O
args	int
;	O
bfd_boolean	int
varargs	int
;	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_args	function
(	O
minfo	struct
,	O
pp	pointer
,	O
(	O
ptype	pointer
==	O
NULL	O
?	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
:	O
&	O
args	int
)	O
,	O
(	O
ptype	pointer
==	O
NULL	O
?	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
:	O
&	O
varargs	int
)	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'_'	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_function_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
ptype	pointer
,	O
args	int
,	O
varargs	int
)	O
;	O
}	O
break	O
;	O
case	O
'M'	O
:	O
case	O
'O'	O
:	O
{	O
bfd_boolean	int
memberp	int
;	O
debug_type	pointer
class_type	pointer
=	O
DEBUG_TYPE_NULL	O
;	O
debug_type	pointer
*	O
args	int
;	O
bfd_boolean	int
varargs	int
;	O
unsigned	O
int	O
n	long
;	O
const	O
char	O
*	O
name	pointer
;	O
memberp	int
=	O
*	O
*	O
pp	pointer
==	O
'M'	O
;	O
args	int
=	O
NULL	O
;	O
varargs	int
=	O
FALSE	int
;	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
{	O
n	long
=	O
stab_demangle_count	function
(	O
pp	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
*	O
pp	pointer
)	O
<	O
n	long
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
name	pointer
=	O
*	O
pp	pointer
;	O
*	O
pp	pointer
+=	O
n	long
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
class_type	pointer
=	O
stab_find_tagged_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
minfo	struct
->	O
info	pointer
,	O
name	pointer
,	O
(	O
int	O
)	O
n	long
,	O
DEBUG_KIND_CLASS	int
)	O
;	O
if	O
(	O
class_type	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'Q'	O
)	O
{	O
if	O
(	O
!	O
stab_demangle_qualified	function
(	O
minfo	struct
,	O
pp	pointer
,	O
(	O
ptype	pointer
==	O
NULL	O
?	O
(	O
debug_type	pointer
*	O
)	O
NULL	O
:	O
&	O
class_type	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
memberp	int
)	O
{	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'C'	O
)	O
{	O
++	O
*	O
pp	pointer
;	O
}	O
else	O
if	O
(	O
*	O
*	O
pp	pointer
==	O
'V'	O
)	O
{	O
++	O
*	O
pp	pointer
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'F'	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_args	function
(	O
minfo	struct
,	O
pp	pointer
,	O
(	O
ptype	pointer
==	O
NULL	O
?	O
(	O
debug_type	pointer
*	O
*	O
)	O
NULL	O
:	O
&	O
args	int
)	O
,	O
(	O
ptype	pointer
==	O
NULL	O
?	O
(	O
bfd_boolean	int
*	O
)	O
NULL	O
:	O
&	O
varargs	int
)	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
*	O
*	O
pp	pointer
!=	O
'_'	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
memberp	int
)	O
*	O
ptype	pointer
=	O
debug_make_offset_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
class_type	pointer
,	O
*	O
ptype	pointer
)	O
;	O
else	O
{	O
*	O
ptype	pointer
=	O
debug_make_method_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
ptype	pointer
,	O
class_type	pointer
,	O
args	int
,	O
varargs	int
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
'G'	O
:	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
case	O
'C'	O
:	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
stab_demangle_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_const_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
ptype	pointer
)	O
;	O
break	O
;	O
case	O
'Q'	O
:	O
{	O
if	O
(	O
!	O
stab_demangle_qualified	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
stab_demangle_fund_type	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
)	O
)	O
return	O
FALSE	int
;	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_fund_type	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
*	O
pp	pointer
,	O
debug_type	pointer
*	O
ptype	pointer
)	O
{	O
const	O
char	O
*	O
orig	pointer
;	O
bfd_boolean	int
constp	int
,	O
volatilep	int
,	O
unsignedp	int
,	O
signedp	int
;	O
bfd_boolean	int
done	int
;	O
orig	pointer
=	O
*	O
pp	pointer
;	O
constp	int
=	O
FALSE	int
;	O
volatilep	int
=	O
FALSE	int
;	O
unsignedp	int
=	O
FALSE	int
;	O
signedp	int
=	O
FALSE	int
;	O
done	int
=	O
FALSE	int
;	O
while	O
(	O
!	O
done	int
)	O
{	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'C'	O
:	O
constp	int
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'U'	O
:	O
unsignedp	int
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'S'	O
:	O
signedp	int
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'V'	O
:	O
volatilep	int
=	O
TRUE	int
;	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
default	O
:	O
done	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
switch	O
(	O
*	O
*	O
pp	pointer
)	O
{	O
case	O
'\0'	O
:	O
case	O
'_'	O
:	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
"void"	pointer
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_void_type	function
(	O
minfo	struct
->	O
dhandle	pointer
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'x'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
(	O
unsignedp	int
?	O
"long long unsigned int"	pointer
:	O
"long long int"	pointer
)	O
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_int_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
8	int
,	O
unsignedp	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
(	O
unsignedp	int
?	O
"long unsigned int"	pointer
:	O
"long int"	pointer
)	O
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_int_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
4	int
,	O
unsignedp	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
(	O
unsignedp	int
?	O
"unsigned int"	pointer
:	O
"int"	pointer
)	O
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_int_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
4	int
,	O
unsignedp	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
(	O
unsignedp	int
?	O
"short unsigned int"	pointer
:	O
"short int"	pointer
)	O
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_int_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
2	int
,	O
unsignedp	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
"bool"	pointer
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_bool_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
4	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
(	O
unsignedp	int
?	O
"unsigned char"	pointer
:	O
(	O
signedp	int
?	O
"signed char"	pointer
:	O
"char"	pointer
)	O
)	O
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_int_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
1	int
,	O
unsignedp	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'w'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
"__wchar_t"	pointer
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_int_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
2	int
,	O
TRUE	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'r'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
"long double"	pointer
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_float_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
8	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
"double"	pointer
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_float_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
8	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
"float"	pointer
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
*	O
ptype	pointer
=	O
debug_make_float_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
4	int
)	O
;	O
}	O
++	O
*	O
pp	pointer
;	O
break	O
;	O
case	O
'G'	O
:	O
++	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
*	O
pp	pointer
)	O
)	O
{	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
{	O
const	O
char	O
*	O
hold	pointer
;	O
if	O
(	O
!	O
stab_demangle_class	function
(	O
minfo	struct
,	O
pp	pointer
,	O
&	O
hold	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
savestring	function
(	O
hold	pointer
,	O
*	O
pp	pointer
-	O
hold	pointer
)	O
;	O
*	O
ptype	pointer
=	O
debug_find_named_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
stab_find_tagged_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
minfo	struct
->	O
info	pointer
,	O
hold	pointer
,	O
*	O
pp	pointer
-	O
hold	pointer
,	O
DEBUG_KIND_ILLEGAL	int
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
break	O
;	O
case	O
't'	O
:	O
{	O
char	O
*	O
name	pointer
;	O
if	O
(	O
!	O
stab_demangle_template	function
(	O
minfo	struct
,	O
pp	pointer
,	O
ptype	pointer
!=	O
NULL	O
?	O
&	O
name	pointer
:	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
*	O
ptype	pointer
=	O
stab_find_tagged_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
minfo	struct
->	O
info	pointer
,	O
name	pointer
,	O
strlen	function
(	O
name	pointer
)	O
,	O
DEBUG_KIND_CLASS	int
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
*	O
ptype	pointer
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
stab_bad_demangle	function
(	O
orig	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
ptype	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
constp	int
)	O
*	O
ptype	pointer
=	O
debug_make_const_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
ptype	pointer
)	O
;	O
if	O
(	O
volatilep	int
)	O
*	O
ptype	pointer
=	O
debug_make_volatile_type	function
(	O
minfo	struct
->	O
dhandle	pointer
,	O
*	O
ptype	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
stab_demangle_remember_type	function
(	O
struct	O
stab_demangle_info	struct
*	O
minfo	struct
,	O
const	O
char	O
*	O
p	pointer
,	O
int	O
len	long
)	O
{	O
if	O
(	O
minfo	struct
->	O
typestring_count	int
>=	O
minfo	struct
->	O
typestring_alloc	int
)	O
{	O
minfo	struct
->	O
typestring_alloc	int
+=	O
10	int
;	O
minfo	struct
->	O
typestrings	pointer
=	O
(	O
(	O
struct	O
stab_demangle_typestring	struct
*	O
)	O
xrealloc	function
(	O
minfo	struct
->	O
typestrings	pointer
,	O
(	O
minfo	struct
->	O
typestring_alloc	int
*	O
sizeof	O
*	O
minfo	struct
->	O
typestrings	pointer
)	O
)	O
)	O
;	O
}	O
minfo	struct
->	O
typestrings	pointer
[	O
minfo	struct
->	O
typestring_count	int
]	O
.	O
typestring	pointer
=	O
p	pointer
;	O
minfo	struct
->	O
typestrings	pointer
[	O
minfo	struct
->	O
typestring_count	int
]	O
.	O
len	long
=	O
(	O
unsigned	O
int	O
)	O
len	long
;	O
++	O
minfo	struct
->	O
typestring_count	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
debug_type	pointer
*	O
stab_demangle_v3_argtypes	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
physname	pointer
,	O
bfd_boolean	int
*	O
pvarargs	pointer
)	O
{	O
struct	O
demangle_component	struct
*	O
dc	pointer
;	O
void	O
*	O
mem	pointer
;	O
debug_type	pointer
*	O
pargs	pointer
;	O
dc	pointer
=	O
cplus_demangle_v3_components	function
(	O
physname	pointer
,	O
DMGL_PARAMS	O
|	O
demangle_flags	int
,	O
&	O
mem	pointer
)	O
;	O
if	O
(	O
dc	pointer
==	O
NULL	O
)	O
{	O
stab_bad_demangle	function
(	O
physname	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dc	pointer
->	O
type	enum
!=	O
DEMANGLE_COMPONENT_TYPED_NAME	int
||	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
right	pointer
->	O
type	enum
!=	O
DEMANGLE_COMPONENT_FUNCTION_TYPE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Demangled name is not a function\n"	pointer
)	O
)	O
;	O
free	function
(	O
mem	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
pargs	pointer
=	O
stab_demangle_v3_arglist	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
right	pointer
->	O
u	union
.	O
s_binary	struct
.	O
right	pointer
,	O
pvarargs	pointer
)	O
;	O
free	function
(	O
mem	pointer
)	O
;	O
return	O
pargs	pointer
;	O
}	O
static	O
debug_type	pointer
*	O
stab_demangle_v3_arglist	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
struct	O
demangle_component	struct
*	O
arglist	pointer
,	O
bfd_boolean	int
*	O
pvarargs	pointer
)	O
{	O
struct	O
demangle_component	struct
*	O
dc	pointer
;	O
unsigned	O
int	O
alloc	int
,	O
count	int
;	O
debug_type	pointer
*	O
pargs	pointer
;	O
alloc	int
=	O
10	int
;	O
pargs	pointer
=	O
(	O
debug_type	pointer
*	O
)	O
xmalloc	function
(	O
alloc	int
*	O
sizeof	O
*	O
pargs	pointer
)	O
;	O
*	O
pvarargs	pointer
=	O
FALSE	int
;	O
count	int
=	O
0	int
;	O
for	O
(	O
dc	pointer
=	O
arglist	pointer
;	O
dc	pointer
!=	O
NULL	O
;	O
dc	pointer
=	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
right	pointer
)	O
{	O
debug_type	pointer
arg	pointer
;	O
bfd_boolean	int
varargs	int
;	O
if	O
(	O
dc	pointer
->	O
type	enum
!=	O
DEMANGLE_COMPONENT_ARGLIST	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Unexpected type in v3 arglist demangling\n"	pointer
)	O
)	O
;	O
free	function
(	O
pargs	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
left	pointer
==	O
NULL	O
)	O
break	O
;	O
arg	pointer
=	O
stab_demangle_v3_arg	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
left	pointer
,	O
NULL	O
,	O
&	O
varargs	int
)	O
;	O
if	O
(	O
arg	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
varargs	int
)	O
{	O
*	O
pvarargs	pointer
=	O
TRUE	int
;	O
continue	O
;	O
}	O
free	function
(	O
pargs	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
count	int
+	O
1	int
>=	O
alloc	int
)	O
{	O
alloc	int
+=	O
10	int
;	O
pargs	pointer
=	O
(	O
debug_type	pointer
*	O
)	O
xrealloc	function
(	O
pargs	pointer
,	O
alloc	int
*	O
sizeof	O
*	O
pargs	pointer
)	O
;	O
}	O
pargs	pointer
[	O
count	int
]	O
=	O
arg	pointer
;	O
++	O
count	int
;	O
}	O
pargs	pointer
[	O
count	int
]	O
=	O
DEBUG_TYPE_NULL	O
;	O
return	O
pargs	pointer
;	O
}	O
static	O
debug_type	pointer
stab_demangle_v3_arg	function
(	O
void	O
*	O
dhandle	pointer
,	O
struct	O
stab_handle	struct
*	O
info	pointer
,	O
struct	O
demangle_component	struct
*	O
dc	pointer
,	O
debug_type	pointer
context	pointer
,	O
bfd_boolean	int
*	O
pvarargs	pointer
)	O
{	O
debug_type	pointer
dt	pointer
;	O
if	O
(	O
pvarargs	pointer
!=	O
NULL	O
)	O
*	O
pvarargs	pointer
=	O
FALSE	int
;	O
switch	O
(	O
dc	pointer
->	O
type	enum
)	O
{	O
case	O
DEMANGLE_COMPONENT_LOCAL_NAME	int
:	O
case	O
DEMANGLE_COMPONENT_TYPED_NAME	int
:	O
case	O
DEMANGLE_COMPONENT_TEMPLATE_PARAM	int
:	O
case	O
DEMANGLE_COMPONENT_CTOR	int
:	O
case	O
DEMANGLE_COMPONENT_DTOR	int
:	O
case	O
DEMANGLE_COMPONENT_JAVA_CLASS	int
:	O
case	O
DEMANGLE_COMPONENT_RESTRICT_THIS	int
:	O
case	O
DEMANGLE_COMPONENT_VOLATILE_THIS	int
:	O
case	O
DEMANGLE_COMPONENT_CONST_THIS	int
:	O
case	O
DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL	int
:	O
case	O
DEMANGLE_COMPONENT_COMPLEX	int
:	O
case	O
DEMANGLE_COMPONENT_IMAGINARY	int
:	O
case	O
DEMANGLE_COMPONENT_VENDOR_TYPE	int
:	O
case	O
DEMANGLE_COMPONENT_ARRAY_TYPE	int
:	O
case	O
DEMANGLE_COMPONENT_PTRMEM_TYPE	int
:	O
case	O
DEMANGLE_COMPONENT_ARGLIST	int
:	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Unrecognized demangle component %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
dc	pointer
->	O
type	enum
)	O
;	O
return	O
NULL	O
;	O
case	O
DEMANGLE_COMPONENT_NAME	int
:	O
if	O
(	O
context	pointer
!=	O
NULL	O
)	O
{	O
const	O
debug_field	pointer
*	O
fields	pointer
;	O
fields	pointer
=	O
debug_get_fields	function
(	O
dhandle	pointer
,	O
context	pointer
)	O
;	O
if	O
(	O
fields	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
;	O
*	O
fields	pointer
!=	O
DEBUG_FIELD_NULL	O
;	O
fields	pointer
++	O
)	O
{	O
debug_type	pointer
ft	pointer
;	O
const	O
char	O
*	O
dn	pointer
;	O
ft	pointer
=	O
debug_get_field_type	function
(	O
dhandle	pointer
,	O
*	O
fields	pointer
)	O
;	O
if	O
(	O
ft	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
dn	pointer
=	O
debug_get_type_name	function
(	O
dhandle	pointer
,	O
ft	pointer
)	O
;	O
if	O
(	O
dn	pointer
!=	O
NULL	O
&&	O
(	O
int	O
)	O
strlen	function
(	O
dn	pointer
)	O
==	O
dc	pointer
->	O
u	union
.	O
s_name	struct
.	O
len	long
&&	O
strncmp	function
(	O
dn	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_name	struct
.	O
s	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_name	struct
.	O
len	long
)	O
==	O
0	int
)	O
return	O
ft	pointer
;	O
}	O
}	O
}	O
return	O
stab_find_tagged_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_name	struct
.	O
s	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_name	struct
.	O
len	long
,	O
DEBUG_KIND_ILLEGAL	int
)	O
;	O
case	O
DEMANGLE_COMPONENT_QUAL_NAME	int
:	O
context	pointer
=	O
stab_demangle_v3_arg	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
left	pointer
,	O
context	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
context	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
stab_demangle_v3_arg	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
right	pointer
,	O
context	pointer
,	O
NULL	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_TEMPLATE	int
:	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
alc	long
;	O
p	pointer
=	O
cplus_demangle_print	function
(	O
DMGL_PARAMS	O
|	O
demangle_flags	int
,	O
dc	pointer
,	O
20	int
,	O
&	O
alc	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Failed to print demangled template\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
dt	pointer
=	O
stab_find_tagged_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
,	O
DEBUG_KIND_CLASS	int
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
return	O
dt	pointer
;	O
}	O
case	O
DEMANGLE_COMPONENT_SUB_STD	int
:	O
return	O
stab_find_tagged_type	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_string	struct
.	O
string	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_string	struct
.	O
len	long
,	O
DEBUG_KIND_ILLEGAL	int
)	O
;	O
case	O
DEMANGLE_COMPONENT_RESTRICT	int
:	O
case	O
DEMANGLE_COMPONENT_VOLATILE	int
:	O
case	O
DEMANGLE_COMPONENT_CONST	int
:	O
case	O
DEMANGLE_COMPONENT_POINTER	int
:	O
case	O
DEMANGLE_COMPONENT_REFERENCE	int
:	O
dt	pointer
=	O
stab_demangle_v3_arg	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
left	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dt	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
dc	pointer
->	O
type	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
DEMANGLE_COMPONENT_RESTRICT	int
:	O
return	O
dt	pointer
;	O
case	O
DEMANGLE_COMPONENT_VOLATILE	int
:	O
return	O
debug_make_volatile_type	function
(	O
dhandle	pointer
,	O
dt	pointer
)	O
;	O
case	O
DEMANGLE_COMPONENT_CONST	int
:	O
return	O
debug_make_const_type	function
(	O
dhandle	pointer
,	O
dt	pointer
)	O
;	O
case	O
DEMANGLE_COMPONENT_POINTER	int
:	O
return	O
debug_make_pointer_type	function
(	O
dhandle	pointer
,	O
dt	pointer
)	O
;	O
case	O
DEMANGLE_COMPONENT_REFERENCE	int
:	O
return	O
debug_make_reference_type	function
(	O
dhandle	pointer
,	O
dt	pointer
)	O
;	O
}	O
case	O
DEMANGLE_COMPONENT_FUNCTION_TYPE	int
:	O
{	O
debug_type	pointer
*	O
pargs	pointer
;	O
bfd_boolean	int
varargs	int
;	O
if	O
(	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
left	pointer
==	O
NULL	O
)	O
{	O
dt	pointer
=	O
debug_make_void_type	function
(	O
dhandle	pointer
)	O
;	O
}	O
else	O
dt	pointer
=	O
stab_demangle_v3_arg	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
left	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
dt	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
pargs	pointer
=	O
stab_demangle_v3_arglist	function
(	O
dhandle	pointer
,	O
info	pointer
,	O
dc	pointer
->	O
u	union
.	O
s_binary	struct
.	O
right	pointer
,	O
&	O
varargs	int
)	O
;	O
if	O
(	O
pargs	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
debug_make_function_type	function
(	O
dhandle	pointer
,	O
dt	pointer
,	O
pargs	pointer
,	O
varargs	int
)	O
;	O
}	O
case	O
DEMANGLE_COMPONENT_BUILTIN_TYPE	int
:	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
alc	long
;	O
debug_type	pointer
ret	pointer
;	O
p	pointer
=	O
cplus_demangle_print	function
(	O
DMGL_PARAMS	O
|	O
demangle_flags	int
,	O
dc	pointer
,	O
20	int
,	O
&	O
alc	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Couldn't get demangled builtin type\n"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"signed char"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"bool"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_bool_type	function
(	O
dhandle	pointer
,	O
1	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"char"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"double"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
8	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"long double"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
8	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"float"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
4	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"__float128"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_float_type	function
(	O
dhandle	pointer
,	O
16	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"unsigned char"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
1	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"int"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"unsigned int"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"long"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"unsigned long"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"__int128"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
16	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"unsigned __int128"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
16	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"short"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
2	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"unsigned short"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
2	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"void"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_void_type	function
(	O
dhandle	pointer
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"wchar_t"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
4	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"long long"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
FALSE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"unsigned long long"	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
debug_make_int_type	function
(	O
dhandle	pointer
,	O
8	int
,	O
TRUE	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"..."	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
pvarargs	pointer
==	O
NULL	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Unexpected demangled varargs\n"	pointer
)	O
)	O
;	O
else	O
*	O
pvarargs	pointer
=	O
TRUE	int
;	O
ret	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Unrecognized demangled builtin type\n"	pointer
)	O
)	O
;	O
ret	pointer
=	O
NULL	O
;	O
}	O
free	function
(	O
p	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
}	O
}	O
