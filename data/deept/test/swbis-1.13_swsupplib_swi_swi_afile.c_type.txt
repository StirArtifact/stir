typedef	O
struct	O
{	O
int	O
did_itM	int
;	O
char	O
*	O
tagM	pointer
;	O
}	O
G_CONTROL_SCRIPT	struct
;	O
static	O
G_CONTROL_SCRIPT	struct
pp_g_scripts	array
[	O
]	O
=	O
{	O
{	O
0	int
,	O
"checkinstall"	pointer
}	O
,	O
{	O
0	int
,	O
"preinstall"	pointer
}	O
,	O
{	O
0	int
,	O
"postinstall"	pointer
}	O
,	O
{	O
0	int
,	O
"verify"	pointer
}	O
,	O
{	O
0	int
,	O
"fix"	pointer
}	O
,	O
{	O
0	int
,	O
"checkremove"	pointer
}	O
,	O
{	O
0	int
,	O
"preremove"	pointer
}	O
,	O
{	O
0	int
,	O
"postremove"	pointer
}	O
,	O
{	O
0	int
,	O
"configure"	pointer
}	O
,	O
{	O
0	int
,	O
"unconfigure"	pointer
}	O
,	O
{	O
0	int
,	O
"request"	pointer
}	O
,	O
{	O
0	int
,	O
"unpreinstall"	pointer
}	O
,	O
{	O
0	int
,	O
"unpostinstall"	pointer
}	O
,	O
{	O
0	int
,	O
"space"	pointer
}	O
,	O
{	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
}	O
}	O
;	O
static	O
void	O
make_case_pattern_for_unused_tags	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
int	O
is_first	int
=	O
1	int
;	O
G_CONTROL_SCRIPT	struct
*	O
script_ent	pointer
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\t\t"	pointer
)	O
;	O
script_ent	pointer
=	O
pp_g_scripts	array
;	O
while	O
(	O
(	O
script_ent	pointer
)	O
->	O
tagM	pointer
)	O
{	O
if	O
(	O
script_ent	pointer
->	O
did_itM	int
==	O
0	int
)	O
{	O
if	O
(	O
is_first	int
==	O
0	int
)	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"|"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s"	pointer
,	O
script_ent	pointer
->	O
tagM	pointer
)	O
;	O
is_first	int
=	O
0	int
;	O
}	O
else	O
{	O
script_ent	pointer
->	O
did_itM	int
=	O
0	int
;	O
}	O
script_ent	pointer
++	O
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
")\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\t\t\techo \"$0: no ${SWBCS_SCRIPT_TAG} script for ${SWBCS_MATCH}\" 1>&2\n"	pointer
"\t\t\texit "	pointer
SWBIS_STATUS_COMMAND_NOT_FOUND	pointer
"\n"	pointer
"\t\t\t;;\n"	pointer
)	O
;	O
}	O
static	O
int	O
set_is_ieee_control_script	function
(	O
char	O
*	O
pathname	pointer
,	O
int	O
do_set	int
)	O
{	O
char	O
*	O
base	int
;	O
G_CONTROL_SCRIPT	struct
*	O
script_ent	pointer
;	O
base	int
=	O
swlib_basename	function
(	O
NULL	O
,	O
pathname	pointer
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
base	int
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
script_ent	pointer
=	O
pp_g_scripts	array
;	O
while	O
(	O
(	O
script_ent	pointer
)	O
->	O
tagM	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
base	int
,	O
(	O
script_ent	pointer
)	O
->	O
tagM	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
do_set	int
)	O
{	O
(	O
script_ent	pointer
)	O
->	O
did_itM	int
=	O
1	int
;	O
}	O
return	O
1	int
;	O
}	O
script_ent	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
get_attribute_from_INFO_object	function
(	O
SWI_CONTROL_SCRIPT	struct
*	O
control_script	pointer
,	O
char	O
*	O
attr_name	pointer
)	O
{	O
SWI_XFILE	struct
*	O
xfile	pointer
;	O
SWHEADER	struct
*	O
h	pointer
;	O
SWHEADER_STATE	struct
state	pointer
;	O
char	O
*	O
val	array
;	O
xfile	pointer
=	O
control_script	pointer
->	O
swi_xfileM	pointer
;	O
if	O
(	O
!	O
xfile	pointer
)	O
return	O
NULL	O
;	O
h	pointer
=	O
xfile	pointer
->	O
info_headerM	pointer
;	O
if	O
(	O
!	O
h	pointer
)	O
return	O
NULL	O
;	O
swheader_store_state	function
(	O
h	pointer
,	O
&	O
state	pointer
)	O
;	O
swheader_reset	function
(	O
h	pointer
)	O
;	O
swheader_set_current_offset_p	function
(	O
h	pointer
,	O
&	O
(	O
xfile	pointer
->	O
INFO_header_indexM	int
)	O
)	O
;	O
swheader_set_current_offset_p_value	function
(	O
h	pointer
,	O
control_script	pointer
->	O
INFO_offsetM	int
)	O
;	O
val	array
=	O
swheader_get_single_attribute_value	function
(	O
h	pointer
,	O
attr_name	pointer
)	O
;	O
swheader_restore_state	function
(	O
h	pointer
,	O
&	O
state	pointer
)	O
;	O
return	O
val	array
;	O
}	O
void	O
swi_scripts_delete	function
(	O
SWI_SCRIPTS	struct
*	O
s	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SWI_MAX_OBJ	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
s	pointer
->	O
swi_coM	array
[	O
i	int
]	O
)	O
swi_control_script_delete	function
(	O
s	pointer
->	O
swi_coM	array
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
s	pointer
)	O
;	O
}	O
SWI_SCRIPTS	struct
*	O
swi_scripts_create	function
(	O
void	O
)	O
{	O
SWI_SCRIPTS	struct
*	O
s	pointer
=	O
(	O
SWI_SCRIPTS	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWI_SCRIPTS	struct
)	O
)	O
;	O
SWSWI_E_DEBUG	O
(	O
""	pointer
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
s	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
swiInitListOfObjects	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
s	pointer
->	O
swi_coM	array
)	O
)	O
;	O
return	O
s	pointer
;	O
}	O
void	O
swi_file_member_delete	function
(	O
SWI_FILE_MEMBER	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
refcountM	int
>	O
1	int
)	O
{	O
(	O
s	pointer
->	O
refcountM	int
)	O
--	O
;	O
return	O
;	O
}	O
if	O
(	O
s	pointer
->	O
pathnameM	pointer
)	O
free	function
(	O
s	pointer
->	O
pathnameM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
dataM	pointer
)	O
free	function
(	O
s	pointer
->	O
dataM	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
SWI_FILE_MEMBER	struct
*	O
swi_file_member_create	function
(	O
void	O
)	O
{	O
SWI_FILE_MEMBER	struct
*	O
s	pointer
=	O
(	O
SWI_FILE_MEMBER	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWI_FILE_MEMBER	struct
)	O
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
s	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
swi_vbase_init	function
(	O
s	pointer
,	O
SWI_I_TYPE_AFILE	char
,	O
NULL	O
,	O
NULL	O
)	O
;	O
s	pointer
->	O
refcountM	int
=	O
1	int
;	O
s	pointer
->	O
pathnameM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
lenM	int
=	O
-	O
1	int
;	O
s	pointer
->	O
dataM	pointer
=	O
NULL	O
;	O
return	O
s	pointer
;	O
}	O
void	O
swi_control_script_delete	function
(	O
SWI_CONTROL_SCRIPT	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
free	function
(	O
s	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
afileM	pointer
)	O
swi_file_member_delete	function
(	O
s	pointer
->	O
afileM	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
SWI_CONTROL_SCRIPT	struct
*	O
swi_control_script_create	function
(	O
void	O
)	O
{	O
static	O
int	O
id	pointer
=	O
0	int
;	O
SWI_CONTROL_SCRIPT	struct
*	O
s	pointer
;	O
SWSWI_E_DEBUG	O
(	O
""	pointer
)	O
;	O
s	pointer
=	O
(	O
SWI_CONTROL_SCRIPT	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWI_CONTROL_SCRIPT	struct
)	O
)	O
;	O
swi_com_assert_pointer	function
(	O
(	O
void	O
*	O
)	O
s	pointer
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
swi_vbase_init	function
(	O
s	pointer
,	O
SWI_I_TYPE_SCRIPT	char
,	O
NULL	O
,	O
NULL	O
)	O
;	O
s	pointer
->	O
sidM	int
=	O
++	O
id	pointer
;	O
s	pointer
->	O
afileM	pointer
=	O
NULL	O
;	O
s	pointer
->	O
swi_xfileM	pointer
=	O
(	O
void	O
*	O
)	O
NULL	O
;	O
s	pointer
->	O
INFO_offsetM	int
=	O
-	O
1	int
;	O
s	pointer
->	O
resultM	int
=	O
SWI_RESULT_UNDEFINED	O
;	O
return	O
s	pointer
;	O
}	O
void	O
swi_add_script	function
(	O
SWI_SCRIPTS	struct
*	O
thisisit	pointer
,	O
SWI_CONTROL_SCRIPT	struct
*	O
v	int
)	O
{	O
SWSWI_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
swiAddObjectToList	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
thisisit	pointer
->	O
swi_coM	array
)	O
,	O
(	O
void	O
*	O
)	O
v	int
)	O
;	O
SWSWI_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
}	O
int	O
swi_control_script_get_return_code	function
(	O
char	O
*	O
posix_result	pointer
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
posix_result	pointer
,	O
SW_RESULT_NONE	pointer
)	O
==	O
0	int
)	O
{	O
return	O
SWI_RESULT_UNDEFINED	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
posix_result	pointer
,	O
SW_RESULT_SUCCESS	pointer
)	O
==	O
0	int
)	O
{	O
return	O
SWI_RESULT_SUCCESS	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
posix_result	pointer
,	O
SW_RESULT_WARNING	pointer
)	O
==	O
0	int
)	O
{	O
return	O
SWI_RESULT_WARNING	O
;	O
}	O
else	O
if	O
(	O
strcasecmp	function
(	O
posix_result	pointer
,	O
SW_RESULT_FAILURE	pointer
)	O
==	O
0	int
)	O
{	O
return	O
SWI_RESULT_FAILURE	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unrecognized  POSIX result string: [%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
posix_result	pointer
)	O
;	O
return	O
SWI_RESULT_FAILURE	O
;	O
}	O
}	O
char	O
*	O
swi_control_script_posix_result	function
(	O
SWI_CONTROL_SCRIPT	struct
*	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
->	O
resultM	int
==	O
SWI_RESULT_UNDEFINED	O
||	O
s	pointer
->	O
resultM	int
<	O
0	int
)	O
{	O
return	O
SW_RESULT_NONE	pointer
;	O
}	O
else	O
if	O
(	O
s	pointer
->	O
resultM	int
==	O
SW_SUCCESS	int
)	O
{	O
return	O
SW_RESULT_SUCCESS	pointer
;	O
}	O
else	O
if	O
(	O
s	pointer
->	O
resultM	int
==	O
SW_ERROR	int
)	O
{	O
return	O
SW_RESULT_FAILURE	pointer
;	O
}	O
else	O
if	O
(	O
s	pointer
->	O
resultM	int
==	O
SW_WARNING	int
)	O
{	O
return	O
SW_RESULT_WARNING	pointer
;	O
}	O
else	O
if	O
(	O
s	pointer
->	O
resultM	int
==	O
SW_NOTE	int
)	O
{	O
return	O
SW_RESULT_WARNING	pointer
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: internal error: bad result code: [%d]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
s	pointer
->	O
resultM	int
)	O
;	O
return	O
SW_RESULT_FAILURE	pointer
;	O
}	O
}	O
int	O
swi_afile_write_script_cases	function
(	O
SWI_SCRIPTS	struct
*	O
scripts	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
char	O
*	O
installed_isc_path	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
lslash	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
interpreter	pointer
;	O
G_CONTROL_SCRIPT	struct
*	O
script_ent	pointer
;	O
SWI_CONTROL_SCRIPT	struct
*	O
control_script	pointer
;	O
STROB	struct
*	O
vintbuf	pointer
;	O
vintbuf	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
script_ent	pointer
=	O
pp_g_scripts	array
;	O
while	O
(	O
(	O
script_ent	pointer
)	O
->	O
tagM	pointer
)	O
{	O
(	O
script_ent	pointer
)	O
->	O
did_itM	int
=	O
0	int
;	O
script_ent	pointer
++	O
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"		case \"${SWBCS_SCRIPT_TAG}\" in\n"	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
installed_isc_path	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SWI_MAX_OBJ	int
;	O
i	int
++	O
)	O
{	O
script_ent	pointer
=	O
pp_g_scripts	array
;	O
control_script	pointer
=	O
scripts	pointer
->	O
swi_coM	array
[	O
i	int
]	O
;	O
if	O
(	O
control_script	pointer
)	O
{	O
set_is_ieee_control_script	function
(	O
control_script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
,	O
1	int
)	O
;	O
interpreter	pointer
=	O
get_attribute_from_INFO_object	function
(	O
control_script	pointer
,	O
SW_A_interpreter	pointer
)	O
;	O
if	O
(	O
interpreter	pointer
==	O
NULL	O
)	O
{	O
interpreter	pointer
=	O
""	pointer
;	O
}	O
if	O
(	O
strlen	function
(	O
interpreter	pointer
)	O
&&	O
swlib_check_clean_path	function
(	O
interpreter	pointer
)	O
)	O
{	O
interpreter	pointer
=	O
""	pointer
;	O
}	O
if	O
(	O
strlen	function
(	O
interpreter	pointer
)	O
)	O
{	O
strob_sprintf	function
(	O
vintbuf	pointer
,	O
STROB_NO_APPEND	int
,	O
"INTERPRETER=\"%s\"\n"	pointer
,	O
interpreter	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
vintbuf	pointer
,	O
""	pointer
)	O
;	O
}	O
lslash	pointer
=	O
strrchr	function
(	O
control_script	pointer
->	O
afileM	pointer
->	O
pathnameM	pointer
,	O
'/'	O
)	O
;	O
SWLIB_ASSERT	O
(	O
lslash	pointer
!=	O
NULL	O
)	O
;	O
*	O
lslash	pointer
=	O
'\0'	O
;	O
name	pointer
=	O
lslash	pointer
+	O
1	int
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\t\t%s)\n"	pointer
"\t\t\texport SW_CONTROL_TAG=\"%s\"\n"	pointer
"\t\t\t%s\n"	pointer
"\t\tcase \"$SW_CATALOG\" in\n"	pointer
"\t\t\t  # User specified SW_CATALOG as really, really absolute\n"	pointer
"\t\t\t/*) export SW_CONTROL_DIRECTORY=\"${SW_CATALOG}/%s/%s\"\n"	pointer
"\t\t\t;;\n"	pointer
"\t\t\t  # Normal case\n"	pointer
"\t\t\t*) export SW_CONTROL_DIRECTORY=\"${SW_ROOT_DIRECTORY}/${SW_CATALOG}/%s/%s\"\n"	pointer
"\t\t\t;;\n"	pointer
"\t\tesac\n"	pointer
"\t\t\tSWBCS_SCRIPT_NAME=\"%s\"\n"	pointer
"\t\t\t;;\n"	pointer
,	O
control_script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
,	O
control_script	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
,	O
strob_str	function
(	O
vintbuf	pointer
)	O
,	O
SWINSTALL_INCAT_NAME	pointer
,	O
control_script	pointer
->	O
afileM	pointer
->	O
pathnameM	pointer
,	O
SWINSTALL_INCAT_NAME	pointer
,	O
control_script	pointer
->	O
afileM	pointer
->	O
pathnameM	pointer
,	O
name	pointer
)	O
;	O
*	O
lslash	pointer
=	O
'/'	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
make_case_pattern_for_unused_tags	function
(	O
buf	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"		*)\n"	pointer
"			echo \"$0: invalid tag\" 1>&2\n"	pointer
"			exit 1\n"	pointer
"			;;\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"		esac\n"	pointer
)	O
;	O
strob_close	function
(	O
vintbuf	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swi_afile_is_ieee_control_script	function
(	O
char	O
*	O
pathname	pointer
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
set_is_ieee_control_script	function
(	O
pathname	pointer
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
