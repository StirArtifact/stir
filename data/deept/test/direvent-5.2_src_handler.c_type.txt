struct	O
handler	struct
*	O
handler_alloc	function
(	O
event_mask	struct
ev_mask	struct
)	O
{	O
struct	O
handler	pointer
*	O
hp	pointer
=	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
hp	pointer
)	O
)	O
;	O
hp	pointer
->	O
refcnt	int
=	O
0	int
;	O
hp	pointer
->	O
ev_mask	pointer
=	O
ev_mask	int
;	O
return	O
hp	pointer
;	O
}	O
void	O
watchpoint_run_handlers	function
(	O
struct	O
watchpoint	struct
*	O
wp	pointer
,	O
int	O
evflags	int
,	O
const	O
char	O
*	O
dirname	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
handler_iterator_t	pointer
itr	pointer
;	O
struct	O
handler	pointer
*	O
hp	pointer
;	O
event_mask	struct
m	pointer
;	O
for_each_handler	function
(	O
wp	pointer
,	O
itr	pointer
,	O
hp	pointer
)	O
{	O
if	O
(	O
handler_matches_event	function
(	O
hp	pointer
,	O
sys	pointer
,	O
evflags	pointer
,	O
filename	pointer
)	O
)	O
hp	pointer
->	O
run	function
(	O
wp	pointer
,	O
event_mask_init	function
(	O
&	O
m	pointer
,	O
evflags	pointer
,	O
&	O
hp	pointer
->	O
ev_mask	pointer
)	O
,	O
dirname	pointer
,	O
filename	pointer
,	O
hp	pointer
->	O
data	pointer
)	O
;	O
}	O
}	O
static	O
void	O
handler_ref	function
(	O
struct	O
handler	pointer
*	O
hp	pointer
)	O
{	O
++	O
hp	pointer
->	O
refcnt	int
;	O
}	O
void	O
handler_free	function
(	O
struct	O
handler	pointer
*	O
hp	pointer
)	O
{	O
filpatlist_destroy	function
(	O
&	O
hp	pointer
->	O
fnames	pointer
)	O
;	O
if	O
(	O
hp	pointer
->	O
free	function
)	O
hp	pointer
->	O
free	function
(	O
hp	pointer
->	O
data	pointer
)	O
;	O
}	O
static	O
void	O
handler_unref	function
(	O
struct	O
handler	struct
*	O
hp	pointer
)	O
{	O
if	O
(	O
hp	pointer
&&	O
--	O
hp	pointer
->	O
refcnt	int
)	O
{	O
handler_free	function
(	O
hp	pointer
)	O
;	O
free	function
(	O
hp	pointer
)	O
;	O
}	O
}	O
static	O
void	O
handler_listent_free	function
(	O
void	O
*	O
p	pointer
)	O
{	O
struct	O
handler	pointer
*	O
hp	pointer
=	O
p	pointer
;	O
handler_unref	function
(	O
hp	pointer
)	O
;	O
}	O
struct	O
handler_list	struct
{	O
size_t	long
refcnt	int
;	O
grecs_list_ptr_t	pointer
list	pointer
;	O
struct	O
handler_iterator	struct
*	O
itr_chain	pointer
;	O
}	O
;	O
struct	O
handler_iterator	struct
{	O
struct	O
handler_iterator	struct
*	O
prev	pointer
,	O
*	O
next	pointer
;	O
handler_list_t	pointer
hlist	pointer
;	O
struct	O
grecs_list_entry	struct
*	O
ent	pointer
;	O
int	O
advanced	int
;	O
}	O
;	O
static	O
struct	O
handler_iterator	struct
*	O
itr_avail	pointer
;	O
struct	O
handler	pointer
*	O
handler_itr_first	function
(	O
struct	O
watchpoint	struct
*	O
wpt	pointer
,	O
handler_iterator_t	struct
*	O
ret_itr	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	pointer
;	O
if	O
(	O
!	O
wpt	pointer
->	O
handler_list	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
itr_avail	pointer
)	O
{	O
itr	pointer
=	O
itr_avail	pointer
;	O
itr_avail	pointer
=	O
itr	pointer
->	O
next	pointer
;	O
if	O
(	O
itr_avail	pointer
)	O
itr_avail	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
}	O
else	O
itr	pointer
=	O
emalloc	function
(	O
sizeof	O
*	O
itr	pointer
)	O
;	O
itr	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
itr	pointer
->	O
next	pointer
=	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
;	O
itr	pointer
->	O
hlist	pointer
=	O
wpt	pointer
->	O
handler_list	int
;	O
if	O
(	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
)	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
->	O
prev	pointer
=	O
itr	pointer
;	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
=	O
itr	pointer
;	O
itr	pointer
->	O
ent	pointer
=	O
wpt	pointer
->	O
handler_list	pointer
->	O
list	pointer
->	O
head	pointer
;	O
itr	pointer
->	O
advanced	int
=	O
0	int
;	O
*	O
ret_itr	pointer
=	O
itr	pointer
;	O
return	O
handler_itr_current	function
(	O
itr	pointer
)	O
;	O
}	O
struct	O
handler	pointer
*	O
handler_itr_next	function
(	O
handler_iterator_t	struct
*	O
pitr	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	pointer
;	O
if	O
(	O
!	O
pitr	pointer
||	O
(	O
itr	pointer
=	O
*	O
pitr	pointer
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
itr	pointer
->	O
advanced	pointer
)	O
itr	pointer
->	O
advanced	int
=	O
0	int
;	O
else	O
itr	pointer
->	O
ent	pointer
=	O
itr	pointer
->	O
ent	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
itr	pointer
->	O
ent	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
p	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
itr	pointer
->	O
prev	pointer
)	O
!=	O
NULL	O
)	O
p	pointer
->	O
next	pointer
=	O
itr	pointer
->	O
next	pointer
;	O
else	O
itr	pointer
->	O
hlist	pointer
->	O
itr_chain	pointer
=	O
itr	pointer
->	O
next	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
itr	pointer
->	O
next	pointer
)	O
!=	O
NULL	O
)	O
p	pointer
->	O
prev	pointer
=	O
itr	pointer
->	O
prev	pointer
;	O
if	O
(	O
itr_avail	pointer
)	O
itr_avail	pointer
->	O
prev	pointer
=	O
itr	pointer
;	O
itr	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
itr	pointer
->	O
next	pointer
=	O
itr_avail	pointer
;	O
itr	pointer
->	O
hlist	pointer
=	O
NULL	O
;	O
itr_avail	pointer
=	O
itr	pointer
;	O
*	O
pitr	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
return	O
handler_itr_current	function
(	O
itr	pointer
)	O
;	O
}	O
struct	O
handler	pointer
*	O
handler_itr_current	function
(	O
handler_iterator_t	pointer
itr	pointer
)	O
{	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
NULL	O
;	O
return	O
itr	pointer
->	O
ent	pointer
?	O
itr	pointer
->	O
ent	pointer
->	O
data	pointer
:	O
NULL	O
;	O
}	O
handler_list_t	O
handler_list_create	function
(	O
void	O
)	O
{	O
handler_list_t	O
hlist	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
hlist	pointer
)	O
)	O
;	O
hlist	pointer
->	O
list	pointer
=	O
grecs_list_create	function
(	O
)	O
;	O
hlist	pointer
->	O
list	pointer
->	O
free_entry	pointer
=	O
handler_listent_free	pointer
;	O
hlist	pointer
->	O
refcnt	int
=	O
1	int
;	O
hlist	pointer
->	O
itr_chain	pointer
=	O
NULL	O
;	O
return	O
hlist	int
;	O
}	O
size_t	long
handler_list_size	function
(	O
handler_list_t	pointer
hlist	pointer
)	O
{	O
return	O
grecs_list_size	function
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
}	O
handler_list_t	O
handler_list_copy	O
(	O
handler_list_t	pointer
orig	pointer
)	O
{	O
if	O
(	O
!	O
orig	pointer
)	O
return	O
handler_list_create	function
(	O
)	O
;	O
++	O
orig	pointer
->	O
refcnt	int
;	O
return	O
orig	pointer
;	O
}	O
void	O
handler_list_unref	function
(	O
handler_list_t	pointer
hlist	pointer
)	O
{	O
if	O
(	O
hlist	pointer
)	O
{	O
if	O
(	O
--	O
hlist	pointer
->	O
refcnt	int
==	O
0	int
)	O
{	O
grecs_list_free	function
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
free	function
(	O
hlist	pointer
)	O
;	O
}	O
}	O
}	O
void	O
handler_list_append	function
(	O
handler_list_t	pointer
hlist	int
,	O
struct	O
handler	pointer
*	O
hp	pointer
)	O
{	O
handler_ref	function
(	O
hp	pointer
)	O
;	O
grecs_list_append	function
(	O
hlist	pointer
->	O
list	pointer
,	O
hp	pointer
)	O
;	O
}	O
size_t	long
handler_list_remove	function
(	O
handler_list_t	pointer
hlist	int
,	O
struct	O
handler	pointer
*	O
hp	pointer
)	O
{	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
for	O
(	O
ep	pointer
=	O
hlist	pointer
->	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
if	O
(	O
ep	pointer
->	O
data	pointer
==	O
hp	pointer
)	O
break	O
;	O
if	O
(	O
!	O
ep	pointer
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
hlist	pointer
->	O
itr_chain	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	pointer
;	O
for	O
(	O
itr	pointer
=	O
hlist	pointer
->	O
itr_chain	pointer
;	O
itr	pointer
;	O
itr	pointer
=	O
itr	pointer
->	O
next	pointer
)	O
if	O
(	O
itr	pointer
->	O
ent	pointer
==	O
ep	pointer
)	O
{	O
itr	pointer
->	O
ent	pointer
=	O
ep	pointer
->	O
next	pointer
;	O
itr	pointer
->	O
advanced	int
=	O
1	int
;	O
}	O
}	O
grecs_list_remove_entry	function
(	O
hlist	pointer
->	O
list	pointer
,	O
ep	pointer
)	O
;	O
return	O
grecs_list_size	function
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
}	O