void	O
mu_i_sv_code	function
(	O
struct	O
mu_sieve_machine	struct
*	O
mach	pointer
,	O
sieve_op_t	union
op	int
)	O
{	O
if	O
(	O
mach	pointer
->	O
changeloc	int
)	O
{	O
mach	pointer
->	O
changeloc	int
=	O
0	int
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
_mu_i_sv_instr_locus	function
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
mu_i_sv_id_num	function
(	O
mach	pointer
,	O
mach	pointer
->	O
locus	struct
.	O
beg	struct
.	O
mu_file	pointer
)	O
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
mach	pointer
->	O
locus	struct
.	O
beg	struct
.	O
mu_line	int
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
mach	pointer
->	O
locus	struct
.	O
beg	struct
.	O
mu_col	int
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
mu_i_sv_id_num	function
(	O
mach	pointer
,	O
mach	pointer
->	O
locus	struct
.	O
end	struct
.	O
mu_file	pointer
)	O
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
mach	pointer
->	O
locus	struct
.	O
end	struct
.	O
mu_line	int
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
mach	pointer
->	O
locus	struct
.	O
end	struct
.	O
mu_col	int
)	O
;	O
}	O
if	O
(	O
mach	pointer
->	O
pc	long
>=	O
mach	pointer
->	O
progsize	long
)	O
{	O
mu_i_sv_2nrealloc	function
(	O
mach	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
mach	pointer
->	O
prog	pointer
,	O
&	O
mach	pointer
->	O
progsize	long
,	O
sizeof	O
mach	pointer
->	O
prog	pointer
[	O
0	int
]	O
)	O
;	O
}	O
mach	pointer
->	O
prog	pointer
[	O
mach	pointer
->	O
pc	long
++	O
]	O
=	O
op	int
;	O
}	O
int	O
mu_i_sv_locus	function
(	O
struct	O
mu_sieve_machine	struct
*	O
mach	pointer
,	O
struct	O
mu_locus_range	struct
*	O
lr	pointer
)	O
{	O
if	O
(	O
!	O
mu_locus_point_eq	function
(	O
&	O
mach	pointer
->	O
locus	struct
.	O
beg	struct
,	O
&	O
lr	pointer
->	O
beg	struct
)	O
)	O
{	O
mach	pointer
->	O
changeloc	int
=	O
1	int
;	O
mu_locus_range_copy	function
(	O
&	O
mach	pointer
->	O
locus	struct
,	O
lr	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
mu_sieve_tag_def_t	struct
*	O
find_tag	function
(	O
mu_sieve_tag_group_t	struct
*	O
taglist	pointer
,	O
char	O
*	O
tagname	pointer
,	O
mu_sieve_tag_checker_t	pointer
*	O
checker	pointer
)	O
{	O
*	O
checker	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
taglist	pointer
)	O
return	O
NULL	O
;	O
for	O
(	O
;	O
taglist	pointer
->	O
tags	pointer
;	O
taglist	pointer
++	O
)	O
{	O
mu_sieve_tag_def_t	struct
*	O
def	pointer
;	O
for	O
(	O
def	pointer
=	O
taglist	pointer
->	O
tags	pointer
;	O
def	pointer
->	O
name	pointer
;	O
def	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
def	pointer
->	O
name	pointer
,	O
tagname	pointer
)	O
==	O
0	int
)	O
{	O
*	O
checker	pointer
=	O
taglist	pointer
->	O
checker	pointer
;	O
return	O
def	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
check_arg	struct
{	O
struct	O
mu_sieve_machine	struct
*	O
mach	pointer
;	O
struct	O
mu_sieve_node	struct
*	O
node	pointer
;	O
}	O
;	O
static	O
int	O
_run_checker	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
check_arg	struct
*	O
arg	pointer
=	O
data	pointer
;	O
mu_sieve_machine_t	pointer
mach	pointer
=	O
arg	pointer
->	O
mach	pointer
;	O
struct	O
mu_sieve_node	struct
*	O
node	pointer
=	O
arg	pointer
->	O
node	pointer
;	O
mu_sieve_tag_checker_t	pointer
checker	pointer
=	O
item	pointer
;	O
int	O
rc	int
;	O
mach	pointer
->	O
comparator	pointer
=	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
comparator	pointer
;	O
mach	pointer
->	O
argstart	long
=	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argstart	long
;	O
mach	pointer
->	O
argcount	long
=	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
;	O
mach	pointer
->	O
tagcount	long
=	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
tagcount	long
;	O
mach	pointer
->	O
identifier	pointer
=	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
reg	long
->	O
name	pointer
;	O
rc	int
=	O
checker	pointer
(	O
arg	pointer
->	O
mach	pointer
)	O
;	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
comparator	pointer
=	O
mach	pointer
->	O
comparator	pointer
;	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
=	O
mach	pointer
->	O
argcount	long
;	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
tagcount	long
=	O
mach	pointer
->	O
tagcount	long
;	O
mach	pointer
->	O
argstart	long
=	O
0	int
;	O
mach	pointer
->	O
argcount	long
=	O
0	int
;	O
mach	pointer
->	O
tagcount	long
=	O
0	int
;	O
mach	pointer
->	O
identifier	pointer
=	O
NULL	O
;	O
return	O
rc	int
?	O
MU_ERR_USER0	O
:	O
0	int
;	O
}	O
void	O
mu_i_sv_lint_command	function
(	O
struct	O
mu_sieve_machine	struct
*	O
mach	pointer
,	O
struct	O
mu_sieve_node	struct
*	O
node	pointer
)	O
{	O
size_t	long
i	long
;	O
mu_sieve_registry_t	struct
*	O
reg	long
=	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
reg	long
;	O
mu_sieve_value_t	struct
*	O
start	pointer
=	O
mach	pointer
->	O
valspace	pointer
+	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argstart	long
;	O
mu_list_t	pointer
chk_list	pointer
=	O
NULL	O
;	O
mu_sieve_data_type	enum
*	O
exp_arg	pointer
;	O
int	O
opt_args	pointer
=	O
0	int
;	O
int	O
rc	int
,	O
err	int
=	O
0	int
;	O
static	O
mu_sieve_data_type	enum
empty	pointer
[	O
]	O
=	O
{	O
SVT_VOID	int
}	O
;	O
if	O
(	O
!	O
reg	long
)	O
return	O
;	O
exp_arg	pointer
=	O
reg	long
->	O
v	array
.	O
command	pointer
.	O
req_args	pointer
?	O
reg	long
->	O
v	array
.	O
command	pointer
.	O
req_args	pointer
:	O
empty	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
;	O
i	long
++	O
)	O
{	O
mu_sieve_value_t	struct
*	O
val	pointer
=	O
start	pointer
+	O
i	long
;	O
if	O
(	O
val	pointer
->	O
type	int
==	O
SVT_TAG	int
)	O
{	O
mu_sieve_tag_checker_t	pointer
cf	pointer
;	O
mu_sieve_tag_def_t	struct
*	O
tag	pointer
=	O
find_tag	function
(	O
reg	long
->	O
v	array
.	O
command	pointer
.	O
tags	pointer
,	O
val	pointer
->	O
v	array
.	O
string	pointer
,	O
&	O
cf	pointer
)	O
;	O
if	O
(	O
!	O
tag	pointer
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
val	pointer
->	O
locus	struct
,	O
_	O
(	O
"invalid tag name `%s' for `%s'"	pointer
)	O
,	O
val	pointer
->	O
v	array
.	O
string	pointer
,	O
reg	long
->	O
name	pointer
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
err	int
=	O
1	int
;	O
break	O
;	O
}	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
tagcount	long
++	O
;	O
if	O
(	O
tag	pointer
->	O
argtype	enum
==	O
SVT_VOID	int
)	O
{	O
val	pointer
->	O
type	int
=	O
SVT_VOID	int
;	O
val	pointer
->	O
tag	pointer
=	O
val	pointer
->	O
v	array
.	O
string	pointer
;	O
val	pointer
->	O
v	array
.	O
string	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
i	long
+	O
1	int
==	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
mach	pointer
->	O
locus	struct
,	O
_	O
(	O
"required argument for tag %s is missing"	pointer
)	O
,	O
tag	pointer
->	O
name	pointer
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
err	int
=	O
1	int
;	O
break	O
;	O
}	O
val	pointer
[	O
1	int
]	O
.	O
tag	pointer
=	O
val	pointer
->	O
v	array
.	O
string	pointer
;	O
*	O
val	pointer
=	O
val	pointer
[	O
1	int
]	O
;	O
memmove	function
(	O
val	pointer
+	O
1	int
,	O
val	pointer
+	O
2	int
,	O
(	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
-	O
i	long
-	O
2	int
)	O
*	O
sizeof	O
(	O
val	pointer
[	O
0	int
]	O
)	O
)	O
;	O
mach	pointer
->	O
valcount	long
--	O
;	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
--	O
;	O
if	O
(	O
val	pointer
->	O
type	int
!=	O
tag	pointer
->	O
argtype	enum
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
val	pointer
->	O
locus	struct
,	O
_	O
(	O
"type mismatch in argument to "	pointer
"tag `%s'"	pointer
)	O
,	O
tag	pointer
->	O
name	pointer
)	O
;	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
val	pointer
->	O
locus	struct
,	O
_	O
(	O
"expected %s but passed %s"	pointer
)	O
,	O
mu_sieve_type_str	function
(	O
tag	pointer
->	O
argtype	enum
)	O
,	O
mu_sieve_type_str	function
(	O
val	pointer
->	O
type	int
)	O
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
err	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
cf	pointer
)	O
{	O
if	O
(	O
!	O
chk_list	pointer
&&	O
(	O
rc	int
=	O
mu_list_create	function
(	O
&	O
chk_list	pointer
)	O
)	O
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
mach	pointer
->	O
locus	struct
,	O
_	O
(	O
"cannot create check list: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
err	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
mu_list_locate	function
(	O
chk_list	pointer
,	O
cf	pointer
,	O
NULL	O
)	O
==	O
MU_ERR_NOENT	O
)	O
{	O
rc	int
=	O
mu_list_append	function
(	O
chk_list	pointer
,	O
cf	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
mach	pointer
->	O
locus	struct
,	O
"mu_list_append: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
err	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
exp_arg	pointer
==	O
SVT_VOID	int
)	O
{	O
if	O
(	O
reg	long
->	O
v	array
.	O
command	pointer
.	O
opt_args	pointer
)	O
{	O
exp_arg	pointer
=	O
reg	long
->	O
v	array
.	O
command	pointer
.	O
opt_args	pointer
;	O
opt_args	pointer
=	O
1	int
;	O
}	O
else	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
mach	pointer
->	O
locus	struct
,	O
_	O
(	O
"too many arguments in call to `%s'"	pointer
)	O
,	O
reg	long
->	O
name	pointer
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
err	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
*	O
exp_arg	pointer
!=	O
val	pointer
->	O
type	int
)	O
{	O
if	O
(	O
*	O
exp_arg	pointer
==	O
SVT_STRING_LIST	int
&&	O
val	pointer
->	O
type	int
==	O
SVT_STRING	int
)	O
;	O
else	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
val	pointer
->	O
locus	struct
,	O
_	O
(	O
"type mismatch in argument %lu to `%s'"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
exp_arg	pointer
-	O
reg	long
->	O
v	array
.	O
command	pointer
.	O
req_args	pointer
+	O
1	int
)	O
,	O
reg	long
->	O
name	pointer
)	O
;	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
val	pointer
->	O
locus	struct
,	O
_	O
(	O
"expected %s but passed %s"	pointer
)	O
,	O
mu_sieve_type_str	function
(	O
*	O
exp_arg	pointer
)	O
,	O
mu_sieve_type_str	function
(	O
val	pointer
->	O
type	int
)	O
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
err	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
exp_arg	pointer
++	O
;	O
}	O
}	O
if	O
(	O
!	O
err	int
&&	O
!	O
opt_args	pointer
&&	O
*	O
exp_arg	pointer
!=	O
SVT_VOID	int
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
mach	pointer
->	O
locus	struct
,	O
_	O
(	O
"too few arguments in call to `%s'"	pointer
)	O
,	O
reg	long
->	O
name	pointer
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
err	int
=	O
1	int
;	O
}	O
if	O
(	O
err	int
)	O
{	O
mu_list_destroy	function
(	O
&	O
chk_list	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
tagcount	long
)	O
{	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
;	O
i	long
++	O
)	O
{	O
size_t	long
j	long
;	O
mu_sieve_value_t	struct
tmp	struct
=	O
start	pointer
[	O
i	long
]	O
;	O
for	O
(	O
j	long
=	O
i	long
;	O
j	long
>	O
0	int
;	O
j	long
--	O
)	O
{	O
if	O
(	O
!	O
tmp	struct
.	O
tag	pointer
&&	O
start	pointer
[	O
j	long
-	O
1	int
]	O
.	O
tag	pointer
)	O
start	pointer
[	O
j	long
]	O
=	O
start	pointer
[	O
j	long
-	O
1	int
]	O
;	O
else	O
break	O
;	O
}	O
start	pointer
[	O
j	long
]	O
=	O
tmp	struct
;	O
}	O
}	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
-=	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
tagcount	long
;	O
if	O
(	O
chk_list	pointer
)	O
{	O
struct	O
check_arg	struct
chk_arg	struct
;	O
chk_arg	struct
.	O
mach	pointer
=	O
mach	pointer
;	O
chk_arg	struct
.	O
node	pointer
=	O
node	pointer
;	O
err	int
=	O
mu_list_foreach	function
(	O
chk_list	pointer
,	O
_run_checker	function
,	O
&	O
chk_arg	struct
)	O
;	O
}	O
}	O
static	O
void	O
sv_code_command	function
(	O
struct	O
mu_sieve_machine	struct
*	O
mach	pointer
,	O
struct	O
mu_sieve_node	struct
*	O
node	pointer
)	O
{	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
reg	long
->	O
v	array
.	O
command	pointer
.	O
handler	array
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argstart	long
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
argcount	long
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
tagcount	long
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
(	O
char	O
*	O
)	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
reg	long
->	O
name	pointer
)	O
;	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
node	pointer
->	O
v	array
.	O
command	pointer
.	O
comparator	pointer
)	O
;	O
}	O
void	O
mu_i_sv_code_action	function
(	O
struct	O
mu_sieve_machine	struct
*	O
mach	pointer
,	O
struct	O
mu_sieve_node	struct
*	O
node	pointer
)	O
{	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
_mu_i_sv_instr_action	function
)	O
;	O
sv_code_command	function
(	O
mach	pointer
,	O
node	pointer
)	O
;	O
}	O
void	O
mu_i_sv_code_test	function
(	O
struct	O
mu_sieve_machine	struct
*	O
mach	pointer
,	O
struct	O
mu_sieve_node	struct
*	O
node	pointer
)	O
{	O
mu_i_sv_code	function
(	O
mach	pointer
,	O
(	O
sieve_op_t	union
)	O
_mu_i_sv_instr_test	function
)	O
;	O
sv_code_command	function
(	O
mach	pointer
,	O
node	pointer
)	O
;	O
}	O
