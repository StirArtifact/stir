static	O
int	O
lookup_string	function
(	O
const	O
char	O
*	O
p	pointer
,	O
int	O
*	O
precision	long
,	O
int	O
*	O
rounding	pointer
,	O
int	O
*	O
exception_mask	pointer
)	O
;	O
int	O
gsl_ieee_read_mode_string	function
(	O
const	O
char	O
*	O
description	pointer
,	O
int	O
*	O
precision	long
,	O
int	O
*	O
rounding	pointer
,	O
int	O
*	O
exception_mask	pointer
)	O
{	O
char	O
*	O
start	pointer
;	O
char	O
*	O
end	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
precision_count	int
=	O
0	int
;	O
int	O
rounding_count	int
=	O
0	int
;	O
int	O
exception_count	int
=	O
0	int
;	O
start	int
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
description	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
start	int
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"no memory to parse mode string"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
strcpy	function
(	O
start	pointer
,	O
description	pointer
)	O
;	O
p	pointer
=	O
start	int
;	O
*	O
precision	long
=	O
0	int
;	O
*	O
rounding	pointer
=	O
0	int
;	O
*	O
exception_mask	pointer
=	O
0	int
;	O
do	O
{	O
int	O
status	int
;	O
int	O
new_precision	int
,	O
new_rounding	int
,	O
new_exception	int
;	O
end	pointer
=	O
strchr	function
(	O
p	pointer
,	O
','	O
)	O
;	O
if	O
(	O
end	pointer
)	O
{	O
*	O
end	pointer
=	O
'\0'	O
;	O
do	O
{	O
end	pointer
++	O
;	O
}	O
while	O
(	O
*	O
end	pointer
==	O
' '	O
||	O
*	O
end	pointer
==	O
','	O
)	O
;	O
}	O
new_precision	int
=	O
0	int
;	O
new_rounding	int
=	O
0	int
;	O
new_exception	int
=	O
0	int
;	O
status	int
=	O
lookup_string	function
(	O
p	pointer
,	O
&	O
new_precision	int
,	O
&	O
new_rounding	int
,	O
&	O
new_exception	struct
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
start	pointer
)	O
;	O
GSL_ERROR	O
(	O
"unrecognized GSL_IEEE_MODE string.\nValid settings are:\n\n"	pointer
"  single-precision double-precision extended-precision\n"	O
"  round-to-nearest round-down round-up round-to-zero\n"	int
"  mask-invalid mask-denormalized mask-division-by-zero\n"	int
"  mask-overflow mask-underflow mask-all\n"	int
"  trap-common trap-inexact\n"	pointer
"\n"	pointer
"separated by commas. "	pointer
"(e.g. GSL_IEEE_MODE=\"round-down,mask-underflow\")"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
new_precision	pointer
)	O
{	O
*	O
precision	long
=	O
new_precision	int
;	O
precision_count	int
++	O
;	O
if	O
(	O
precision_count	int
>	O
1	int
)	O
{	O
free	function
(	O
start	pointer
)	O
;	O
GSL_ERROR	O
(	O
"attempted to set IEEE precision twice"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
new_rounding	pointer
)	O
{	O
*	O
rounding	pointer
=	O
new_rounding	pointer
;	O
rounding_count	int
++	O
;	O
if	O
(	O
rounding_count	int
>	O
1	int
)	O
{	O
free	function
(	O
start	pointer
)	O
;	O
GSL_ERROR	O
(	O
"attempted to set IEEE rounding mode twice"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
new_exception	pointer
)	O
{	O
*	O
exception_mask	pointer
|=	O
new_exception	int
;	O
exception_count	int
++	O
;	O
}	O
p	pointer
=	O
end	pointer
;	O
}	O
while	O
(	O
end	int
&&	O
*	O
p	pointer
!=	O
'\0'	O
)	O
;	O
free	function
(	O
start	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
lookup_string	function
(	O
const	O
char	O
*	O
p	pointer
,	O
int	O
*	O
precision	pointer
,	O
int	O
*	O
rounding	pointer
,	O
int	O
*	O
exception_mask	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"single-precision"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
precision	long
=	O
GSL_IEEE_SINGLE_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"double-precision"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
precision	long
=	O
GSL_IEEE_DOUBLE_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"extended-precision"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
precision	long
=	O
GSL_IEEE_EXTENDED_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"round-to-nearest"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
rounding	pointer
=	O
GSL_IEEE_ROUND_TO_NEAREST	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"round-down"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
rounding	pointer
=	O
GSL_IEEE_ROUND_DOWN	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"round-up"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
rounding	pointer
=	O
GSL_IEEE_ROUND_UP	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"round-to-zero"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
rounding	pointer
=	O
GSL_IEEE_ROUND_TO_ZERO	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-all"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_ALL	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-invalid"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_INVALID	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-denormalized"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_DENORMALIZED	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-division-by-zero"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_DIVISION_BY_ZERO	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-overflow"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_OVERFLOW	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-underflow"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_UNDERFLOW	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"trap-inexact"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_TRAP_INEXACT	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"trap-common"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O