typedef	O
struct	O
{	O
double	O
step_size	double
,	O
stored_step	double
,	O
prev_stored_step	double
;	O
double	O
x_prev_small	double
,	O
f_prev_small	double
,	O
x_small	double
,	O
f_small	double
;	O
unsigned	O
int	O
num_iter	int
;	O
}	O
quad_golden_state_t	struct
;	O
static	O
int	O
quad_golden_init	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
x_minimum	double
,	O
double	O
f_minimum	double
,	O
double	O
x_lower	double
,	O
double	O
f_lower	double
,	O
double	O
x_upper	double
,	O
double	O
f_upper	double
)	O
{	O
quad_golden_state_t	struct
*	O
state	pointer
=	O
(	O
quad_golden_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
->	O
x_prev_small	double
=	O
x_minimum	double
;	O
state	pointer
->	O
x_small	double
=	O
x_minimum	double
;	O
state	pointer
->	O
f_prev_small	double
=	O
f_minimum	double
;	O
state	pointer
->	O
f_small	double
=	O
f_minimum	double
;	O
state	pointer
->	O
step_size	double
=	O
0.0	int
;	O
state	pointer
->	O
stored_step	double
=	O
0.0	int
;	O
state	pointer
->	O
prev_stored_step	double
=	O
0.0	int
;	O
state	pointer
->	O
num_iter	int
=	O
0	int
;	O
x_lower	double
=	O
0	int
;	O
x_upper	double
=	O
0	int
;	O
f_lower	double
=	O
0	int
;	O
f_upper	double
=	O
0	int
;	O
f	pointer
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
quad_golden_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
*	O
x_minimum	double
,	O
double	O
*	O
f_minimum	double
,	O
double	O
*	O
x_lower	double
,	O
double	O
*	O
f_lower	double
,	O
double	O
*	O
x_upper	double
,	O
double	O
*	O
f_upper	double
)	O
{	O
quad_golden_state_t	struct
*	O
state	pointer
=	O
(	O
quad_golden_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
double	O
x_m	double
=	O
*	O
x_minimum	double
;	O
const	O
double	O
f_m	double
=	O
*	O
f_minimum	double
;	O
const	O
double	O
x_l	double
=	O
*	O
x_lower	double
;	O
const	O
double	O
x_u	double
=	O
*	O
x_upper	double
;	O
const	O
double	O
x_small	double
=	O
state	pointer
->	O
x_small	double
;	O
const	O
double	O
f_small	double
=	O
state	pointer
->	O
f_small	double
;	O
const	O
double	O
x_prev_small	double
=	O
state	pointer
->	O
x_prev_small	double
;	O
const	O
double	O
f_prev_small	double
=	O
state	pointer
->	O
f_prev_small	double
;	O
double	O
stored_step	double
=	O
state	pointer
->	O
stored_step	double
;	O
double	O
prev_stored_step	double
=	O
state	pointer
->	O
prev_stored_step	double
;	O
double	O
step_size	double
=	O
state	pointer
->	O
step_size	double
;	O
double	O
quad_step_size	double
=	O
prev_stored_step	double
;	O
double	O
x_trial	double
;	O
double	O
x_eval	double
,	O
f_eval	double
;	O
double	O
x_midpoint	double
=	O
0.5	int
*	O
(	O
x_l	double
+	O
x_u	double
)	O
;	O
double	O
tol	double
=	O
REL_ERR_VAL	int
*	O
fabs	function
(	O
x_m	double
)	O
+	O
ABS_ERR_VAL	int
;	O
if	O
(	O
fabs	function
(	O
stored_step	double
)	O
-	O
tol	double
>	O
-	O
2.0	int
*	O
GSL_DBL_EPSILON	int
)	O
{	O
double	O
c3	double
=	O
(	O
x_m	double
-	O
x_small	double
)	O
*	O
(	O
f_m	double
-	O
f_prev_small	double
)	O
;	O
double	O
c2	double
=	O
(	O
x_m	double
-	O
x_prev_small	double
)	O
*	O
(	O
f_m	double
-	O
f_small	double
)	O
;	O
double	O
c1	double
=	O
(	O
x_m	double
-	O
x_prev_small	double
)	O
*	O
c2	double
-	O
(	O
x_m	double
-	O
x_small	double
)	O
*	O
c3	double
;	O
c2	double
=	O
2.0	int
*	O
(	O
c2	double
-	O
c3	double
)	O
;	O
if	O
(	O
fabs	function
(	O
c2	double
)	O
>	O
GSL_DBL_EPSILON	int
)	O
{	O
if	O
(	O
c2	double
>	O
0.0	int
)	O
c1	double
=	O
-	O
c1	double
;	O
c2	double
=	O
fabs	function
(	O
c2	double
)	O
;	O
quad_step_size	double
=	O
c1	double
/	O
c2	double
;	O
}	O
else	O
{	O
quad_step_size	double
=	O
stored_step	double
;	O
}	O
prev_stored_step	double
=	O
stored_step	double
;	O
stored_step	double
=	O
step_size	double
;	O
}	O
x_trial	double
=	O
x_m	double
+	O
quad_step_size	double
;	O
if	O
(	O
fabs	function
(	O
quad_step_size	double
)	O
<	O
fabs	function
(	O
0.5	int
*	O
prev_stored_step	double
)	O
&&	O
x_trial	double
>	O
x_l	double
&&	O
x_trial	double
<	O
x_u	double
)	O
{	O
step_size	double
=	O
quad_step_size	double
;	O
if	O
(	O
(	O
x_trial	double
-	O
x_l	double
)	O
<	O
2.0	int
*	O
tol	double
||	O
(	O
x_u	double
-	O
x_trial	double
)	O
<	O
2.0	int
*	O
tol	double
)	O
{	O
step_size	double
=	O
(	O
x_midpoint	double
>=	O
x_m	double
?	O
+	O
1.0	int
:	O
-	O
1.0	int
)	O
*	O
fabs	function
(	O
tol	double
)	O
;	O
}	O
DEBUG_PRINTF	O
(	O
(	O
"quadratic step: %g\n"	pointer
,	O
step_size	double
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
x_small	double
!=	O
x_prev_small	double
&&	O
x_small	double
<	O
x_m	double
&&	O
x_prev_small	double
<	O
x_m	double
)	O
||	O
(	O
x_small	double
!=	O
x_prev_small	double
&&	O
x_small	double
>	O
x_m	double
&&	O
x_prev_small	double
>	O
x_m	double
)	O
)	O
{	O
double	O
outside_interval	double
,	O
inside_interval	double
;	O
if	O
(	O
x_small	double
<	O
x_m	double
)	O
{	O
outside_interval	double
=	O
x_l	double
-	O
x_m	double
;	O
inside_interval	double
=	O
x_u	double
-	O
x_m	double
;	O
}	O
else	O
{	O
outside_interval	double
=	O
x_u	double
-	O
x_m	double
;	O
inside_interval	double
=	O
x_l	double
-	O
x_m	double
;	O
}	O
if	O
(	O
fabs	function
(	O
inside_interval	double
)	O
<=	O
tol	double
)	O
{	O
double	O
tmp	double
=	O
outside_interval	double
;	O
outside_interval	double
=	O
inside_interval	double
;	O
inside_interval	double
=	O
tmp	double
;	O
}	O
{	O
double	O
step	double
=	O
inside_interval	double
;	O
double	O
scale_factor	double
;	O
if	O
(	O
fabs	function
(	O
outside_interval	double
)	O
<	O
fabs	function
(	O
inside_interval	double
)	O
)	O
{	O
scale_factor	double
=	O
0.5	int
*	O
sqrt	function
(	O
-	O
outside_interval	double
/	O
inside_interval	double
)	O
;	O
}	O
else	O
{	O
scale_factor	double
=	O
(	O
5.0	int
/	O
11.0	int
)	O
*	O
(	O
0.1	int
-	O
inside_interval	double
/	O
outside_interval	double
)	O
;	O
}	O
state	pointer
->	O
stored_step	double
=	O
step	double
;	O
step_size	double
=	O
scale_factor	double
*	O
step	double
;	O
}	O
DEBUG_PRINTF	O
(	O
(	O
"safeguard step: %g\n"	pointer
,	O
step_size	double
)	O
)	O
;	O
}	O
else	O
{	O
double	O
step	double
;	O
if	O
(	O
x_m	double
<	O
x_midpoint	double
)	O
{	O
step	double
=	O
x_u	double
-	O
x_m	double
;	O
}	O
else	O
{	O
step	double
=	O
x_l	double
-	O
x_m	double
;	O
}	O
state	pointer
->	O
stored_step	double
=	O
step	double
;	O
step_size	double
=	O
GOLDEN_MEAN	int
*	O
step	double
;	O
DEBUG_PRINTF	O
(	O
(	O
"golden step: %g\n"	pointer
,	O
step_size	double
)	O
)	O
;	O
}	O
if	O
(	O
fabs	function
(	O
step_size	double
)	O
>	O
tol	double
)	O
{	O
x_eval	double
=	O
x_m	double
+	O
step_size	double
;	O
}	O
else	O
{	O
x_eval	double
=	O
x_m	double
+	O
(	O
step_size	double
>=	O
0	int
?	O
+	O
1.0	int
:	O
-	O
1.0	int
)	O
*	O
fabs	function
(	O
tol	double
)	O
;	O
}	O
SAFE_FUNC_CALL	O
(	O
f	pointer
,	O
x_eval	double
,	O
&	O
f_eval	double
)	O
;	O
if	O
(	O
f_eval	double
<=	O
f_m	double
)	O
{	O
if	O
(	O
x_eval	double
<	O
x_m	double
)	O
{	O
*	O
x_upper	double
=	O
x_m	double
;	O
*	O
f_upper	double
=	O
f_m	double
;	O
}	O
else	O
{	O
*	O
x_lower	double
=	O
x_m	double
;	O
*	O
f_upper	double
=	O
f_m	double
;	O
}	O
state	pointer
->	O
x_prev_small	double
=	O
x_small	double
;	O
state	pointer
->	O
f_prev_small	double
=	O
f_small	double
;	O
state	pointer
->	O
x_small	double
=	O
x_m	double
;	O
state	pointer
->	O
f_small	double
=	O
f_m	double
;	O
*	O
x_minimum	double
=	O
x_eval	double
;	O
*	O
f_minimum	double
=	O
f_eval	double
;	O
}	O
else	O
{	O
if	O
(	O
x_eval	double
<	O
x_m	double
)	O
{	O
*	O
x_lower	double
=	O
x_eval	double
;	O
*	O
f_lower	double
=	O
f_eval	double
;	O
}	O
else	O
{	O
*	O
x_upper	double
=	O
x_eval	double
;	O
*	O
f_upper	double
=	O
f_eval	double
;	O
}	O
if	O
(	O
f_eval	double
<=	O
f_small	double
||	O
fabs	function
(	O
x_small	double
-	O
x_m	double
)	O
<	O
2.0	int
*	O
GSL_DBL_EPSILON	int
)	O
{	O
state	pointer
->	O
x_prev_small	double
=	O
x_small	double
;	O
state	pointer
->	O
f_prev_small	double
=	O
f_small	double
;	O
state	pointer
->	O
x_small	double
=	O
x_eval	double
;	O
state	pointer
->	O
f_small	double
=	O
f_eval	double
;	O
}	O
else	O
if	O
(	O
f_eval	double
<=	O
f_prev_small	double
||	O
fabs	function
(	O
x_prev_small	double
-	O
x_m	double
)	O
<	O
2.0	int
*	O
GSL_DBL_EPSILON	int
||	O
fabs	function
(	O
x_prev_small	double
-	O
x_small	double
)	O
<	O
2.0	int
*	O
GSL_DBL_EPSILON	int
)	O
{	O
state	pointer
->	O
x_prev_small	double
=	O
x_eval	double
;	O
state	pointer
->	O
f_prev_small	double
=	O
f_eval	double
;	O
}	O
}	O
state	pointer
->	O
stored_step	double
=	O
stored_step	double
;	O
state	pointer
->	O
prev_stored_step	double
=	O
prev_stored_step	double
;	O
state	pointer
->	O
step_size	double
=	O
step_size	double
;	O
state	pointer
->	O
num_iter	int
++	O
;	O
DEBUG_PRINTF	O
(	O
(	O
"[%d] Final State: %g  %g  %g\n"	pointer
,	O
state	pointer
->	O
num_iter	int
,	O
x_l	double
,	O
x_m	double
,	O
x_u	double
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_min_fminimizer_type	struct
quad_golden_type	struct
=	O
{	O
"quad-golden"	pointer
,	O
sizeof	O
(	O
quad_golden_state_t	struct
)	O
,	O
&	O
quad_golden_init	function
,	O
&	O
quad_golden_iterate	function
}	O
;	O
const	O
gsl_min_fminimizer_type	struct
*	O
gsl_min_fminimizer_quad_golden	pointer
=	O
&	O
quad_golden_type	struct
;	O
