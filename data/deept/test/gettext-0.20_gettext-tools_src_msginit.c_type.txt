extern	O
const	O
char	O
*	O
_nl_expand_alias	function
(	O
const	O
char	O
*	O
name	pointer
)	O
;	O
static	O
const	O
char	O
*	O
locale	pointer
;	O
static	O
const	O
char	O
*	O
catalogname	pointer
;	O
static	O
const	O
char	O
*	O
language	pointer
;	O
static	O
bool	bool
no_translator	bool
;	O
static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"color"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
5	int
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"input"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"locale"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"no-translator"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"no-wrap"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
2	int
}	O
,	O
{	O
"output-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"properties-input"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"properties-output"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"stringtable-input"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
3	int
}	O
,	O
{	O
"stringtable-output"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
4	int
}	O
,	O
{	O
"style"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
6	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"width"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
const	O
char	O
*	O
find_pot	function
(	O
void	O
)	O
;	O
static	O
const	O
char	O
*	O
catalogname_for_locale	function
(	O
const	O
char	O
*	O
locale	pointer
)	O
;	O
static	O
const	O
char	O
*	O
language_of_locale	function
(	O
const	O
char	O
*	O
locale	pointer
)	O
;	O
static	O
char	O
*	O
get_field	function
(	O
const	O
char	O
*	O
header	pointer
,	O
const	O
char	O
*	O
field	pointer
)	O
;	O
static	O
msgdomain_list_ty	struct
*	O
fill_header	function
(	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
)	O
;	O
static	O
msgdomain_list_ty	struct
*	O
update_msgstr_plurals	function
(	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
opt	int
;	O
bool	bool
do_help	bool
;	O
bool	bool
do_version	bool
;	O
char	O
*	O
output_file	pointer
;	O
const	O
char	O
*	O
input_file	pointer
;	O
msgdomain_list_ty	struct
*	O
result	pointer
;	O
catalog_input_format_ty	pointer
input_syntax	pointer
=	O
&	O
input_format_po	struct
;	O
catalog_output_format_ty	pointer
output_syntax	pointer
=	O
&	O
output_format_po	struct
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
error_print_progname	pointer
=	O
maybe_print_progname	function
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
relocate	O
(	O
LOCALEDIR	pointer
)	O
)	O
;	O
bindtextdomain	function
(	O
"bison-runtime"	pointer
,	O
relocate	O
(	O
BISON_LOCALEDIR	O
)	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
atexit	function
(	O
close_stdout	function
)	O
;	O
do_help	bool
=	O
false	int
;	O
do_version	bool
=	O
false	int
;	O
output_file	pointer
=	O
NULL	O
;	O
input_file	pointer
=	O
NULL	O
;	O
locale	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
opt	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"hi:l:o:pPVw:"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
input_file	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"at most one input file allowed"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
input_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'l'	O
:	O
locale	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'o'	O
:	O
output_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'p'	O
:	O
output_syntax	pointer
=	O
&	O
output_format_properties	struct
;	O
break	O
;	O
case	O
'P'	O
:	O
input_syntax	pointer
=	O
&	O
input_format_properties	struct
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
case	O
'w'	O
:	O
{	O
int	O
value	pointer
;	O
char	O
*	O
endp	pointer
;	O
value	pointer
=	O
strtol	function
(	O
optarg	pointer
,	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
endp	pointer
!=	O
optarg	pointer
)	O
message_page_width_set	function
(	O
value	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
no_translator	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
2	int
:	O
message_page_width_ignore	function
(	O
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
3	int
:	O
input_syntax	pointer
=	O
&	O
input_format_stringtable	struct
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
4	int
:	O
output_syntax	pointer
=	O
&	O
output_format_stringtable	struct
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
5	int
:	O
if	O
(	O
handle_color_option	function
(	O
optarg	pointer
)	O
||	O
color_test_mode	bool
)	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
6	int
:	O
handle_style_option	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	function
(	O
"%s (GNU %s) %s\n"	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"2001-2019"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Written by %s.\n"	pointer
)	O
,	O
proper_name	function
(	O
"Bruno Haible"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
if	O
(	O
input_file	pointer
==	O
NULL	O
)	O
input_file	pointer
=	O
find_pot	function
(	O
)	O
;	O
if	O
(	O
locale	pointer
==	O
NULL	O
)	O
{	O
locale	pointer
=	O
gl_locale_name	function
(	O
LC_MESSAGES	O
,	O
"LC_MESSAGES"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
locale	pointer
,	O
"C"	pointer
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
doc_url	pointer
=	O
"https://www.gnu.org/software/gettext/manual/html_node/Setting-the-POSIX-Locale.html"	pointer
;	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xasprintf	function
(	O
_	O
(	O
"You are in a language indifferent environment.  Please set\nyour LANG environment variable, as described in\n<%s>.\nThis is necessary so you can test your translations.\n"	pointer
)	O
,	O
doc_url	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
{	O
const	O
char	O
*	O
alias	pointer
=	O
_nl_expand_alias	function
(	O
locale	pointer
)	O
;	O
if	O
(	O
alias	pointer
!=	O
NULL	O
)	O
locale	pointer
=	O
alias	pointer
;	O
}	O
catalogname	pointer
=	O
catalogname_for_locale	function
(	O
locale	pointer
)	O
;	O
language	pointer
=	O
language_of_locale	function
(	O
locale	pointer
)	O
;	O
if	O
(	O
output_file	pointer
==	O
NULL	O
)	O
{	O
output_file	pointer
=	O
xasprintf	function
(	O
"%s.po"	pointer
,	O
catalogname	pointer
)	O
;	O
if	O
(	O
access	function
(	O
output_file	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xasprintf	function
(	O
_	O
(	O
"Output file %s already exists.\nPlease specify the locale through the --locale option or\nthe output .po file through the --output-file option.\n"	pointer
)	O
,	O
output_file	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
result	pointer
=	O
read_catalog_file	function
(	O
input_file	pointer
,	O
input_syntax	pointer
)	O
;	O
result	pointer
=	O
fill_header	function
(	O
result	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
language	pointer
,	O
"en"	pointer
)	O
==	O
0	int
)	O
result	pointer
=	O
msgdomain_list_english	function
(	O
result	pointer
)	O
;	O
else	O
result	pointer
=	O
update_msgstr_plurals	function
(	O
result	pointer
)	O
;	O
msgdomain_list_print	function
(	O
result	pointer
,	O
output_file	pointer
,	O
output_syntax	pointer
,	O
true	int
,	O
false	int
)	O
;	O
if	O
(	O
!	O
no_translator	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Created %s.\n"	pointer
)	O
,	O
output_file	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Creates a new PO file, initializing the meta information with values from the\nuser's environment.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file location:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -i, --input=INPUTFILE       input POT file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"If no input file is given, the current directory is searched for the POT file.\nIf it is -, standard input is read.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output file location:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified PO file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"If no output file is given, it depends on the --locale option or the user's\nlocale setting.  If it is -, the results are written to standard output.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file syntax:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -P, --properties-input      input file is in Java .properties syntax\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --stringtable-input     input file is in NeXTstep/GNUstep .strings syntax\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output details:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -l, --locale=LL_CC[.ENCODING]  set target locale\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --no-translator         assume the PO file is automatically generated\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --color                 use colors and other text attributes always\n      --color=WHEN            use colors and other text attributes if WHEN.\n                              WHEN may be 'always', 'never', 'auto', or 'html'.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --style=STYLEFILE       specify CSS style rule file for --color\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -p, --properties-output     write out a Java .properties file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --stringtable-output    write out a NeXTstep/GNUstep .strings file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -w, --width=NUMBER          set output page width\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --no-wrap               do not break long message lines, longer than\n                              the output page width, into several lines\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Informative output:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -h, --help                  display this help and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -V, --version               output version information and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
find_pot	function
(	O
)	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
char	O
*	O
found	pointer
=	O
NULL	O
;	O
dirp	pointer
=	O
opendir	function
(	O
"."	pointer
)	O
;	O
if	O
(	O
dirp	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
errno	O
=	O
0	int
;	O
dp	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
;	O
if	O
(	O
dp	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
dp	pointer
->	O
d_name	array
;	O
size_t	long
namlen	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
namlen	long
>	O
4	int
&&	O
memcmp	function
(	O
name	pointer
+	O
namlen	long
-	O
4	int
,	O
".pot"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
found	pointer
==	O
NULL	O
)	O
found	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
else	O
{	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xstrdup	function
(	O
_	O
(	O
"Found more than one .pot file.\nPlease specify the input .pot file through the --input option.\n"	pointer
)	O
)	O
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
errno	O
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error reading current directory"	pointer
)	O
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
closedir	function
(	O
dirp	pointer
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error reading current directory"	pointer
)	O
)	O
;	O
if	O
(	O
found	pointer
!=	O
NULL	O
)	O
return	O
found	pointer
;	O
}	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xstrdup	function
(	O
_	O
(	O
"Found no .pot file in the current directory.\nPlease specify the input .pot file through the --input option.\n"	pointer
)	O
)	O
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
catalogname_for_locale	function
(	O
const	O
char	O
*	O
locale	pointer
)	O
{	O
static	O
const	O
char	O
*	O
locales_with_principal_territory	array
[	O
]	O
=	O
{	O
"ace_ID"	pointer
,	O
"af_ZA"	pointer
,	O
"ak_GH"	pointer
,	O
"am_ET"	pointer
,	O
"an_ES"	pointer
,	O
"ang_GB"	pointer
,	O
"arn_CL"	pointer
,	O
"as_IN"	pointer
,	O
"ast_ES"	pointer
,	O
"av_RU"	pointer
,	O
"awa_IN"	pointer
,	O
"az_AZ"	pointer
,	O
"ban_ID"	pointer
,	O
"be_BY"	pointer
,	O
"bej_SD"	pointer
,	O
"bem_ZM"	pointer
,	O
"bg_BG"	pointer
,	O
"bho_IN"	pointer
,	O
"bik_PH"	pointer
,	O
"bin_NG"	pointer
,	O
"bm_ML"	pointer
,	O
"bn_IN"	pointer
,	O
"bo_CN"	pointer
,	O
"br_FR"	pointer
,	O
"bs_BA"	pointer
,	O
"bug_ID"	pointer
,	O
"ca_ES"	pointer
,	O
"ce_RU"	pointer
,	O
"ceb_PH"	pointer
,	O
"co_FR"	pointer
,	O
"cr_CA"	pointer
,	O
"cs_CZ"	pointer
,	O
"csb_PL"	pointer
,	O
"cy_GB"	pointer
,	O
"da_DK"	pointer
,	O
"de_DE"	pointer
,	O
"din_SD"	pointer
,	O
"doi_IN"	pointer
,	O
"dsb_DE"	pointer
,	O
"dv_MV"	pointer
,	O
"dz_BT"	pointer
,	O
"ee_GH"	pointer
,	O
"el_GR"	pointer
,	O
"es_ES"	pointer
,	O
"et_EE"	pointer
,	O
"fa_IR"	pointer
,	O
"fi_FI"	pointer
,	O
"fil_PH"	pointer
,	O
"fj_FJ"	pointer
,	O
"fo_FO"	pointer
,	O
"fon_BJ"	pointer
,	O
"fr_FR"	pointer
,	O
"fur_IT"	pointer
,	O
"fy_NL"	pointer
,	O
"ga_IE"	pointer
,	O
"gd_GB"	pointer
,	O
"gon_IN"	pointer
,	O
"gsw_CH"	pointer
,	O
"gu_IN"	pointer
,	O
"he_IL"	pointer
,	O
"hi_IN"	pointer
,	O
"hil_PH"	pointer
,	O
"hr_HR"	pointer
,	O
"hsb_DE"	pointer
,	O
"ht_HT"	pointer
,	O
"hu_HU"	pointer
,	O
"hy_AM"	pointer
,	O
"id_ID"	pointer
,	O
"ig_NG"	pointer
,	O
"ii_CN"	pointer
,	O
"ilo_PH"	pointer
,	O
"is_IS"	pointer
,	O
"it_IT"	pointer
,	O
"ja_JP"	pointer
,	O
"jab_NG"	pointer
,	O
"jv_ID"	pointer
,	O
"ka_GE"	pointer
,	O
"kab_DZ"	pointer
,	O
"kaj_NG"	pointer
,	O
"kam_KE"	pointer
,	O
"kmb_AO"	pointer
,	O
"kcg_NG"	pointer
,	O
"kdm_NG"	pointer
,	O
"kg_CD"	pointer
,	O
"kk_KZ"	pointer
,	O
"kl_GL"	pointer
,	O
"km_KH"	pointer
,	O
"kn_IN"	pointer
,	O
"ko_KR"	pointer
,	O
"kok_IN"	pointer
,	O
"kr_NG"	pointer
,	O
"kru_IN"	pointer
,	O
"lg_UG"	pointer
,	O
"li_BE"	pointer
,	O
"lo_LA"	pointer
,	O
"lt_LT"	pointer
,	O
"lu_CD"	pointer
,	O
"lua_CD"	pointer
,	O
"luo_KE"	pointer
,	O
"lv_LV"	pointer
,	O
"mad_ID"	pointer
,	O
"mag_IN"	pointer
,	O
"mai_IN"	pointer
,	O
"mak_ID"	pointer
,	O
"man_ML"	pointer
,	O
"men_SL"	pointer
,	O
"mg_MG"	pointer
,	O
"mi_NZ"	pointer
,	O
"min_ID"	pointer
,	O
"mk_MK"	pointer
,	O
"ml_IN"	pointer
,	O
"mn_MN"	pointer
,	O
"mni_IN"	pointer
,	O
"mos_BF"	pointer
,	O
"mr_IN"	pointer
,	O
"ms_MY"	pointer
,	O
"mt_MT"	pointer
,	O
"mwr_IN"	pointer
,	O
"my_MM"	pointer
,	O
"na_NR"	pointer
,	O
"nah_MX"	pointer
,	O
"nap_IT"	pointer
,	O
"nb_NO"	pointer
,	O
"nds_DE"	pointer
,	O
"ne_NP"	pointer
,	O
"nl_NL"	pointer
,	O
"nn_NO"	pointer
,	O
"no_NO"	pointer
,	O
"nr_ZA"	pointer
,	O
"nso_ZA"	pointer
,	O
"nym_TZ"	pointer
,	O
"nyn_UG"	pointer
,	O
"oc_FR"	pointer
,	O
"oj_CA"	pointer
,	O
"or_IN"	pointer
,	O
"pa_IN"	pointer
,	O
"pag_PH"	pointer
,	O
"pam_PH"	pointer
,	O
"pap_AN"	pointer
,	O
"pbb_CO"	pointer
,	O
"pl_PL"	pointer
,	O
"ps_AF"	pointer
,	O
"pt_PT"	pointer
,	O
"raj_IN"	pointer
,	O
"rm_CH"	pointer
,	O
"rn_BI"	pointer
,	O
"ro_RO"	pointer
,	O
"ru_RU"	pointer
,	O
"sa_IN"	pointer
,	O
"sah_RU"	pointer
,	O
"sas_ID"	pointer
,	O
"sat_IN"	pointer
,	O
"sc_IT"	pointer
,	O
"scn_IT"	pointer
,	O
"sg_CF"	pointer
,	O
"shn_MM"	pointer
,	O
"si_LK"	pointer
,	O
"sid_ET"	pointer
,	O
"sk_SK"	pointer
,	O
"sl_SI"	pointer
,	O
"smn_FI"	pointer
,	O
"sms_FI"	pointer
,	O
"so_SO"	pointer
,	O
"sq_AL"	pointer
,	O
"sr_RS"	pointer
,	O
"srr_SN"	pointer
,	O
"suk_TZ"	pointer
,	O
"sus_GN"	pointer
,	O
"sv_SE"	pointer
,	O
"te_IN"	pointer
,	O
"tem_SL"	pointer
,	O
"tet_ID"	pointer
,	O
"tg_TJ"	pointer
,	O
"th_TH"	pointer
,	O
"tiv_NG"	pointer
,	O
"tk_TM"	pointer
,	O
"tl_PH"	pointer
,	O
"to_TO"	pointer
,	O
"tr_TR"	pointer
,	O
"tum_MW"	pointer
,	O
"ug_CN"	pointer
,	O
"uk_UA"	pointer
,	O
"umb_AO"	pointer
,	O
"ur_PK"	pointer
,	O
"uz_UZ"	pointer
,	O
"ve_ZA"	pointer
,	O
"vi_VN"	pointer
,	O
"wa_BE"	pointer
,	O
"wal_ET"	pointer
,	O
"war_PH"	pointer
,	O
"wen_DE"	pointer
,	O
"yao_MW"	pointer
,	O
"zap_MX"	pointer
}	O
;	O
const	O
char	O
*	O
dot	pointer
;	O
size_t	long
i	long
;	O
dot	pointer
=	O
strchr	function
(	O
locale	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
dot	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
codeset_end	pointer
;	O
char	O
*	O
shorter_locale	pointer
;	O
codeset_end	pointer
=	O
strpbrk	function
(	O
dot	pointer
+	O
1	int
,	O
"_@"	pointer
)	O
;	O
if	O
(	O
codeset_end	pointer
==	O
NULL	O
)	O
codeset_end	pointer
=	O
dot	pointer
+	O
strlen	function
(	O
dot	pointer
)	O
;	O
shorter_locale	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
locale	pointer
)	O
,	O
char	O
)	O
;	O
memcpy	function
(	O
shorter_locale	pointer
,	O
locale	pointer
,	O
dot	pointer
-	O
locale	pointer
)	O
;	O
strcpy	function
(	O
shorter_locale	pointer
+	O
(	O
dot	pointer
-	O
locale	pointer
)	O
,	O
codeset_end	pointer
)	O
;	O
locale	pointer
=	O
shorter_locale	pointer
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
SIZEOF	O
(	O
locales_with_principal_territory	array
)	O
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
locale	pointer
,	O
locales_with_principal_territory	array
[	O
i	long
]	O
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
language_end	pointer
;	O
size_t	long
len	long
;	O
char	O
*	O
shorter_locale	pointer
;	O
language_end	pointer
=	O
strchr	function
(	O
locale	pointer
,	O
'_'	O
)	O
;	O
if	O
(	O
language_end	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
len	long
=	O
language_end	pointer
-	O
locale	pointer
;	O
shorter_locale	pointer
=	O
XNMALLOC	O
(	O
len	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
shorter_locale	pointer
,	O
locale	pointer
,	O
len	long
)	O
;	O
shorter_locale	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
locale	pointer
=	O
shorter_locale	pointer
;	O
break	O
;	O
}	O
return	O
locale	pointer
;	O
}	O
static	O
const	O
char	O
*	O
language_of_locale	function
(	O
const	O
char	O
*	O
locale	pointer
)	O
{	O
const	O
char	O
*	O
language_end	pointer
;	O
language_end	pointer
=	O
strpbrk	function
(	O
locale	pointer
,	O
"_.@"	pointer
)	O
;	O
if	O
(	O
language_end	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
char	O
*	O
result	pointer
;	O
len	long
=	O
language_end	pointer
-	O
locale	pointer
;	O
result	pointer
=	O
XNMALLOC	O
(	O
len	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
result	pointer
,	O
locale	pointer
,	O
len	long
)	O
;	O
result	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
result	pointer
;	O
}	O
else	O
return	O
locale	pointer
;	O
}	O
static	O
const	O
char	O
*	O
canonical_locale_charset	function
(	O
)	O
{	O
const	O
char	O
*	O
tmp	pointer
;	O
char	O
*	O
old_LC_ALL	pointer
;	O
const	O
char	O
*	O
charset	pointer
;	O
tmp	pointer
=	O
getenv	function
(	O
"LC_ALL"	pointer
)	O
;	O
old_LC_ALL	pointer
=	O
(	O
tmp	pointer
!=	O
NULL	O
?	O
xstrdup	function
(	O
tmp	pointer
)	O
:	O
NULL	O
)	O
;	O
xsetenv	function
(	O
"LC_ALL"	pointer
,	O
locale	pointer
,	O
1	int
)	O
;	O
if	O
(	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
==	O
NULL	O
)	O
charset	pointer
=	O
""	pointer
;	O
else	O
charset	pointer
=	O
locale_charset	function
(	O
)	O
;	O
if	O
(	O
old_LC_ALL	pointer
!=	O
NULL	O
)	O
xsetenv	function
(	O
"LC_ALL"	pointer
,	O
old_LC_ALL	pointer
,	O
1	int
)	O
,	O
free	function
(	O
old_LC_ALL	pointer
)	O
;	O
else	O
unsetenv	function
(	O
"LC_ALL"	pointer
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
charset	pointer
=	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
;	O
if	O
(	O
charset	pointer
==	O
NULL	O
)	O
charset	pointer
=	O
po_charset_ascii	pointer
;	O
return	O
charset	pointer
;	O
}	O
static	O
const	O
char	O
*	O
englishname_of_language	function
(	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
language_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
language_table	array
[	O
i	long
]	O
.	O
code	pointer
,	O
language	pointer
)	O
==	O
0	int
)	O
return	O
language_table	array
[	O
i	long
]	O
.	O
english	pointer
;	O
return	O
xasprintf	function
(	O
"Language %s"	pointer
,	O
language	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
project_id	function
(	O
const	O
char	O
*	O
header	pointer
)	O
{	O
const	O
char	O
*	O
old_field	pointer
;	O
old_field	pointer
=	O
get_field	function
(	O
header	pointer
,	O
"Project-Id-Version"	pointer
)	O
;	O
if	O
(	O
old_field	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
old_field	pointer
,	O
"PACKAGE VERSION"	pointer
)	O
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
last_space	pointer
;	O
last_space	pointer
=	O
strrchr	function
(	O
old_field	pointer
,	O
' '	O
)	O
;	O
if	O
(	O
last_space	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
last_space	pointer
>	O
old_field	pointer
&&	O
last_space	pointer
[	O
-	O
1	int
]	O
==	O
' '	O
)	O
last_space	pointer
--	O
;	O
if	O
(	O
last_space	pointer
>	O
old_field	pointer
)	O
{	O
size_t	long
package_len	long
=	O
last_space	pointer
-	O
old_field	pointer
;	O
char	O
*	O
package	pointer
=	O
XNMALLOC	O
(	O
package_len	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
package	pointer
,	O
old_field	pointer
,	O
package_len	long
)	O
;	O
package	pointer
[	O
package_len	long
]	O
=	O
'\0'	O
;	O
return	O
package	pointer
;	O
}	O
}	O
return	O
old_field	pointer
;	O
}	O
{	O
const	O
char	O
*	O
gettextlibdir	pointer
;	O
char	O
*	O
prog	pointer
;	O
char	O
*	O
argv	pointer
[	O
3	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
gettextlibdir	pointer
=	O
getenv	function
(	O
"GETTEXTLIBDIR_SRCDIR"	pointer
)	O
;	O
if	O
(	O
gettextlibdir	pointer
==	O
NULL	O
||	O
gettextlibdir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextlibdir	pointer
=	O
relocate	O
(	O
LIBDIR	pointer
"/gettext"	pointer
)	O
;	O
prog	pointer
=	O
xconcatenated_filename	function
(	O
gettextlibdir	pointer
,	O
"project-id"	pointer
,	O
NULL	O
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
BOURNE_SHELL	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
prog	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	function
(	O
prog	pointer
,	O
BOURNE_SHELL	pointer
,	O
argv	pointer
,	O
DEV_NULL	pointer
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	pointer
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	function
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess I/O error"	pointer
)	O
,	O
prog	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
goto	O
failed	O
;	O
}	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
exitstatus	int
=	O
wait_subprocess	function
(	O
child	int
,	O
prog	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	pointer
)	O
,	O
prog	pointer
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
return	O
"PACKAGE"	pointer
;	O
}	O
static	O
const	O
char	O
*	O
project_id_version	function
(	O
const	O
char	O
*	O
header	pointer
)	O
{	O
const	O
char	O
*	O
old_field	pointer
;	O
old_field	pointer
=	O
get_field	function
(	O
header	pointer
,	O
"Project-Id-Version"	pointer
)	O
;	O
if	O
(	O
old_field	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
old_field	pointer
,	O
"PACKAGE VERSION"	pointer
)	O
!=	O
0	int
)	O
return	O
old_field	pointer
;	O
{	O
const	O
char	O
*	O
gettextlibdir	pointer
;	O
char	O
*	O
prog	pointer
;	O
char	O
*	O
argv	pointer
[	O
4	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
gettextlibdir	pointer
=	O
getenv	function
(	O
"GETTEXTLIBDIR_SRCDIR"	pointer
)	O
;	O
if	O
(	O
gettextlibdir	pointer
==	O
NULL	O
||	O
gettextlibdir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextlibdir	pointer
=	O
relocate	O
(	O
LIBDIR	pointer
"/gettext"	pointer
)	O
;	O
prog	pointer
=	O
xconcatenated_filename	function
(	O
gettextlibdir	pointer
,	O
"project-id"	pointer
,	O
NULL	O
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
BOURNE_SHELL	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
prog	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
"yes"	pointer
;	O
argv	pointer
[	O
3	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	function
(	O
prog	pointer
,	O
BOURNE_SHELL	pointer
,	O
argv	pointer
,	O
DEV_NULL	pointer
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	pointer
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	function
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess I/O error"	pointer
)	O
,	O
prog	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
goto	O
failed	O
;	O
}	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
exitstatus	int
=	O
wait_subprocess	function
(	O
child	int
,	O
prog	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	pointer
)	O
,	O
prog	pointer
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
return	O
"PACKAGE VERSION"	pointer
;	O
}	O
static	O
const	O
char	O
*	O
po_revision_date	function
(	O
const	O
char	O
*	O
header	pointer
)	O
{	O
if	O
(	O
no_translator	bool
)	O
return	O
get_field	function
(	O
header	pointer
,	O
"POT-Creation-Date"	pointer
)	O
;	O
else	O
{	O
time_t	long
now	long
;	O
time	struct
(	O
&	O
now	long
)	O
;	O
return	O
po_strftime	function
(	O
&	O
now	long
)	O
;	O
}	O
}	O
static	O
struct	O
passwd	struct
*	O
get_user_pwd	function
(	O
)	O
{	O
const	O
char	O
*	O
username	pointer
;	O
struct	O
passwd	struct
*	O
userpasswd	pointer
;	O
username	pointer
=	O
getenv	function
(	O
"USER"	pointer
)	O
;	O
if	O
(	O
username	pointer
!=	O
NULL	O
)	O
{	O
errno	O
=	O
0	int
;	O
userpasswd	pointer
=	O
getpwnam	function
(	O
username	pointer
)	O
;	O
if	O
(	O
userpasswd	pointer
!=	O
NULL	O
)	O
return	O
userpasswd	pointer
;	O
if	O
(	O
errno	O
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"getpwnam(\"%s\")"	pointer
,	O
username	pointer
)	O
;	O
}	O
username	pointer
=	O
getlogin	function
(	O
)	O
;	O
if	O
(	O
username	pointer
!=	O
NULL	O
)	O
{	O
errno	O
=	O
0	int
;	O
userpasswd	pointer
=	O
getpwnam	function
(	O
username	pointer
)	O
;	O
if	O
(	O
userpasswd	pointer
!=	O
NULL	O
)	O
return	O
userpasswd	pointer
;	O
if	O
(	O
errno	O
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"getpwnam(\"%s\")"	pointer
,	O
username	pointer
)	O
;	O
}	O
errno	O
=	O
0	int
;	O
userpasswd	pointer
=	O
getpwuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
if	O
(	O
userpasswd	pointer
!=	O
NULL	O
)	O
return	O
userpasswd	pointer
;	O
if	O
(	O
errno	O
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"getpwuid(%ju)"	pointer
,	O
(	O
uintmax_t	long
)	O
getuid	function
(	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_user_fullname	function
(	O
)	O
{	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
pwd	pointer
=	O
get_user_pwd	function
(	O
)	O
;	O
if	O
(	O
pwd	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
fullname	pointer
;	O
const	O
char	O
*	O
fullname_end	pointer
;	O
char	O
*	O
result	pointer
;	O
fullname	pointer
=	O
pwd	pointer
->	O
pw_gecos	pointer
;	O
fullname_end	pointer
=	O
strchr	function
(	O
fullname	pointer
,	O
','	O
)	O
;	O
if	O
(	O
fullname_end	pointer
==	O
NULL	O
)	O
fullname_end	pointer
=	O
fullname	pointer
+	O
strlen	function
(	O
fullname	pointer
)	O
;	O
result	pointer
=	O
XNMALLOC	O
(	O
fullname_end	pointer
-	O
fullname	pointer
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
result	pointer
,	O
fullname	pointer
,	O
fullname_end	pointer
-	O
fullname	pointer
)	O
;	O
result	pointer
[	O
fullname_end	pointer
-	O
fullname	pointer
]	O
=	O
'\0'	O
;	O
return	O
result	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_user_email	function
(	O
)	O
{	O
{	O
const	O
char	O
*	O
prog	pointer
=	O
relocate	O
(	O
LIBDIR	pointer
"/gettext/user-email"	pointer
)	O
;	O
char	O
*	O
argv	pointer
[	O
4	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
argv	pointer
[	O
0	int
]	O
=	O
BOURNE_SHELL	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
prog	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
(	O
char	O
*	O
)	O
_	O
(	O
"The new message catalog should contain your email address, so that users can\ngive you feedback about the translations, and so that maintainers can contact\nyou in case of unexpected technical problems.\n"	pointer
)	O
;	O
argv	pointer
[	O
3	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	function
(	O
prog	pointer
,	O
BOURNE_SHELL	pointer
,	O
argv	pointer
,	O
DEV_NULL	pointer
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	pointer
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	function
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess I/O error"	pointer
)	O
,	O
prog	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
goto	O
failed	O
;	O
}	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
exitstatus	int
=	O
wait_subprocess	function
(	O
child	int
,	O
prog	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	pointer
)	O
,	O
prog	pointer
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
return	O
"EMAIL@ADDRESS"	pointer
;	O
}	O
static	O
const	O
char	O
*	O
last_translator	function
(	O
)	O
{	O
if	O
(	O
no_translator	bool
)	O
return	O
"Automatically generated"	pointer
;	O
else	O
{	O
const	O
char	O
*	O
fullname	pointer
=	O
get_user_fullname	function
(	O
)	O
;	O
const	O
char	O
*	O
email	pointer
=	O
get_user_email	function
(	O
)	O
;	O
if	O
(	O
fullname	pointer
!=	O
NULL	O
)	O
return	O
xasprintf	function
(	O
"%s <%s>"	pointer
,	O
fullname	pointer
,	O
email	pointer
)	O
;	O
else	O
return	O
xasprintf	function
(	O
"<%s>"	pointer
,	O
email	pointer
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
language_team_englishname	function
(	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
language_variant_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
language_variant_table	array
[	O
i	long
]	O
.	O
code	pointer
,	O
catalogname	pointer
)	O
==	O
0	int
)	O
return	O
language_variant_table	array
[	O
i	long
]	O
.	O
english	pointer
;	O
return	O
englishname_of_language	function
(	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
language_team_address	function
(	O
)	O
{	O
{	O
const	O
char	O
*	O
prog	pointer
=	O
relocate	O
(	O
PROJECTSDIR	O
"/team-address"	pointer
)	O
;	O
char	O
*	O
argv	pointer
[	O
7	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
argv	pointer
[	O
0	int
]	O
=	O
BOURNE_SHELL	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
prog	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
(	O
char	O
*	O
)	O
relocate	O
(	O
PROJECTSDIR	O
)	O
;	O
argv	pointer
[	O
3	int
]	O
=	O
(	O
char	O
*	O
)	O
relocate	O
(	O
LIBDIR	pointer
"/gettext"	pointer
)	O
;	O
argv	pointer
[	O
4	int
]	O
=	O
(	O
char	O
*	O
)	O
catalogname	pointer
;	O
argv	pointer
[	O
5	int
]	O
=	O
(	O
char	O
*	O
)	O
language	pointer
;	O
argv	pointer
[	O
6	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	function
(	O
prog	pointer
,	O
BOURNE_SHELL	pointer
,	O
argv	pointer
,	O
DEV_NULL	pointer
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	pointer
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	function
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
line	long
=	O
""	pointer
;	O
else	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
exitstatus	int
=	O
wait_subprocess	function
(	O
child	int
,	O
prog	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	pointer
)	O
,	O
prog	pointer
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
return	O
""	pointer
;	O
}	O
static	O
const	O
char	O
*	O
language_team	function
(	O
)	O
{	O
if	O
(	O
no_translator	bool
)	O
return	O
"none"	pointer
;	O
else	O
{	O
const	O
char	O
*	O
englishname	pointer
=	O
language_team_englishname	function
(	O
)	O
;	O
const	O
char	O
*	O
address	pointer
=	O
language_team_address	function
(	O
)	O
;	O
if	O
(	O
address	pointer
!=	O
NULL	O
&&	O
address	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
return	O
xasprintf	function
(	O
"%s %s"	pointer
,	O
englishname	pointer
,	O
address	pointer
)	O
;	O
else	O
return	O
englishname	pointer
;	O
}	O
}	O
static	O
const	O
char	O
*	O
language_value	function
(	O
)	O
{	O
return	O
catalogname	pointer
;	O
}	O
static	O
const	O
char	O
*	O
mime_version	function
(	O
)	O
{	O
return	O
"1.0"	pointer
;	O
}	O
static	O
const	O
char	O
*	O
content_type	function
(	O
const	O
char	O
*	O
header	pointer
)	O
{	O
bool	bool
was_utf8	bool
;	O
const	O
char	O
*	O
old_field	pointer
;	O
was_utf8	bool
=	O
false	int
;	O
old_field	pointer
=	O
get_field	function
(	O
header	pointer
,	O
"Content-Type"	pointer
)	O
;	O
if	O
(	O
old_field	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	pointer
=	O
c_strstr	function
(	O
old_field	pointer
,	O
"charset="	pointer
)	O
;	O
if	O
(	O
charsetstr	pointer
!=	O
NULL	O
)	O
{	O
charsetstr	pointer
+=	O
strlen	function
(	O
"charset="	pointer
)	O
;	O
was_utf8	bool
=	O
(	O
c_strcasecmp	function
(	O
charsetstr	pointer
,	O
"UTF-8"	pointer
)	O
==	O
0	int
)	O
;	O
}	O
}	O
return	O
xasprintf	function
(	O
"text/plain; charset=%s"	pointer
,	O
was_utf8	bool
?	O
"UTF-8"	pointer
:	O
canonical_locale_charset	function
(	O
)	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
content_transfer_encoding	function
(	O
)	O
{	O
return	O
"8bit"	pointer
;	O
}	O
static	O
const	O
char	O
*	O
plural_forms	function
(	O
)	O
{	O
const	O
char	O
*	O
gettextcldrdir	pointer
;	O
char	O
*	O
prog	pointer
=	O
NULL	O
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plural_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
plural_table	array
[	O
i	long
]	O
.	O
lang	pointer
,	O
catalogname	pointer
)	O
==	O
0	int
)	O
return	O
plural_table	array
[	O
i	long
]	O
.	O
value	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
plural_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
plural_table	array
[	O
i	long
]	O
.	O
lang	pointer
,	O
language	pointer
)	O
==	O
0	int
)	O
return	O
plural_table	array
[	O
i	long
]	O
.	O
value	pointer
;	O
gettextcldrdir	pointer
=	O
getenv	function
(	O
"GETTEXTCLDRDIR"	pointer
)	O
;	O
if	O
(	O
gettextcldrdir	pointer
!=	O
NULL	O
&&	O
gettextcldrdir	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
gettextlibdir	pointer
;	O
char	O
*	O
dirs	array
[	O
3	int
]	O
,	O
*	O
last_dir	pointer
;	O
char	O
*	O
argv	pointer
[	O
4	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
line	long
;	O
size_t	long
linesize	long
;	O
size_t	long
linelen	long
;	O
int	O
exitstatus	int
;	O
gettextlibdir	pointer
=	O
getenv	function
(	O
"GETTEXTLIBDIR_BUILDDIR"	pointer
)	O
;	O
if	O
(	O
gettextlibdir	pointer
==	O
NULL	O
||	O
gettextlibdir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextlibdir	pointer
=	O
relocate	O
(	O
LIBDIR	pointer
"/gettext"	pointer
)	O
;	O
prog	pointer
=	O
xconcatenated_filename	function
(	O
gettextlibdir	pointer
,	O
"cldr-plurals"	pointer
,	O
EXEEXT	O
)	O
;	O
last_dir	pointer
=	O
xstrdup	function
(	O
gettextcldrdir	pointer
)	O
;	O
dirs	array
[	O
0	int
]	O
=	O
"common"	pointer
;	O
dirs	array
[	O
1	int
]	O
=	O
"supplemental"	pointer
;	O
dirs	array
[	O
2	int
]	O
=	O
"plurals.xml"	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
SIZEOF	O
(	O
dirs	array
)	O
;	O
i	long
++	O
)	O
{	O
char	O
*	O
dir	pointer
=	O
xconcatenated_filename	function
(	O
last_dir	pointer
,	O
dirs	array
[	O
i	long
]	O
,	O
NULL	O
)	O
;	O
free	function
(	O
last_dir	pointer
)	O
;	O
last_dir	pointer
=	O
dir	pointer
;	O
}	O
argv	pointer
[	O
0	int
]	O
=	O
prog	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
language	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
last_dir	pointer
;	O
argv	pointer
[	O
3	int
]	O
=	O
NULL	O
;	O
child	int
=	O
create_pipe_in	function
(	O
prog	pointer
,	O
prog	pointer
,	O
argv	pointer
,	O
DEV_NULL	pointer
,	O
false	int
,	O
true	int
,	O
false	int
,	O
fd	int
)	O
;	O
free	function
(	O
last_dir	pointer
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
goto	O
failed	O
;	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	pointer
)	O
)	O
;	O
goto	O
failed	O
;	O
}	O
line	long
=	O
NULL	O
;	O
linesize	long
=	O
0	int
;	O
linelen	long
=	O
getline	function
(	O
&	O
line	long
,	O
&	O
linesize	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
linelen	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess I/O error"	pointer
)	O
,	O
prog	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
goto	O
failed	O
;	O
}	O
if	O
(	O
linelen	long
>	O
0	int
&&	O
line	long
[	O
linelen	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
line	long
[	O
linelen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
exitstatus	int
=	O
wait_subprocess	function
(	O
child	int
,	O
prog	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
false	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	pointer
)	O
,	O
prog	pointer
,	O
exitstatus	int
)	O
;	O
goto	O
failed	O
;	O
}	O
return	O
line	long
;	O
}	O
failed	O
:	O
free	function
(	O
prog	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
(	O
*	O
getter0	pointer
)	O
(	O
void	O
)	O
;	O
const	O
char	O
*	O
(	O
*	O
getter1	pointer
)	O
(	O
const	O
char	O
*	O
header	pointer
)	O
;	O
}	O
fields	array
[	O
]	O
=	O
{	O
{	O
"Project-Id-Version"	pointer
,	O
NULL	O
,	O
project_id_version	function
}	O
,	O
{	O
"PO-Revision-Date"	pointer
,	O
NULL	O
,	O
po_revision_date	function
}	O
,	O
{	O
"Last-Translator"	pointer
,	O
last_translator	function
,	O
NULL	O
}	O
,	O
{	O
"Language-Team"	pointer
,	O
language_team	function
,	O
NULL	O
}	O
,	O
{	O
"Language"	pointer
,	O
language_value	function
,	O
NULL	O
}	O
,	O
{	O
"MIME-Version"	pointer
,	O
mime_version	function
,	O
NULL	O
}	O
,	O
{	O
"Content-Type"	pointer
,	O
NULL	O
,	O
content_type	function
}	O
,	O
{	O
"Content-Transfer-Encoding"	pointer
,	O
content_transfer_encoding	function
,	O
NULL	O
}	O
,	O
{	O
"Plural-Forms"	pointer
,	O
plural_forms	function
,	O
NULL	O
}	O
}	O
;	O
static	O
char	O
*	O
get_field	function
(	O
const	O
char	O
*	O
header	pointer
,	O
const	O
char	O
*	O
field	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
field	pointer
)	O
;	O
const	O
char	O
*	O
line	long
;	O
for	O
(	O
line	long
=	O
header	pointer
;	O
;	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
line	long
,	O
field	pointer
,	O
len	long
)	O
==	O
0	int
&&	O
line	long
[	O
len	long
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
value_start	pointer
;	O
const	O
char	O
*	O
value_end	pointer
;	O
char	O
*	O
value	pointer
;	O
value_start	pointer
=	O
line	long
+	O
len	long
+	O
1	int
;	O
if	O
(	O
*	O
value_start	pointer
==	O
' '	O
)	O
value_start	pointer
++	O
;	O
value_end	pointer
=	O
strchr	function
(	O
value_start	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
value_end	pointer
==	O
NULL	O
)	O
value_end	pointer
=	O
value_start	pointer
+	O
strlen	function
(	O
value_start	pointer
)	O
;	O
value	pointer
=	O
XNMALLOC	O
(	O
value_end	pointer
-	O
value_start	pointer
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
value	pointer
,	O
value_start	pointer
,	O
value_end	pointer
-	O
value_start	pointer
)	O
;	O
value	pointer
[	O
value_end	pointer
-	O
value_start	pointer
]	O
=	O
'\0'	O
;	O
return	O
value	pointer
;	O
}	O
line	long
=	O
strchr	function
(	O
line	long
,	O
'\n'	O
)	O
;	O
if	O
(	O
line	long
!=	O
NULL	O
)	O
line	long
++	O
;	O
else	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
put_field	function
(	O
const	O
char	O
*	O
old_header	pointer
,	O
const	O
char	O
*	O
field	pointer
,	O
const	O
char	O
*	O
value	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
field	pointer
)	O
;	O
const	O
char	O
*	O
line	long
;	O
char	O
*	O
new_header	pointer
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
line	long
=	O
old_header	pointer
;	O
;	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
line	long
,	O
field	pointer
,	O
len	long
)	O
==	O
0	int
&&	O
line	long
[	O
len	long
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
value_start	pointer
;	O
const	O
char	O
*	O
value_end	pointer
;	O
value_start	pointer
=	O
line	long
+	O
len	long
+	O
1	int
;	O
if	O
(	O
*	O
value_start	pointer
==	O
' '	O
)	O
value_start	pointer
++	O
;	O
value_end	pointer
=	O
strchr	function
(	O
value_start	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
value_end	pointer
==	O
NULL	O
)	O
value_end	pointer
=	O
value_start	pointer
+	O
strlen	function
(	O
value_start	pointer
)	O
;	O
new_header	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
old_header	pointer
)	O
-	O
(	O
value_end	pointer
-	O
value_start	pointer
)	O
+	O
strlen	function
(	O
value	pointer
)	O
+	O
(	O
*	O
value_end	pointer
!=	O
'\n'	O
?	O
1	int
:	O
0	int
)	O
+	O
1	int
,	O
char	O
)	O
;	O
p	pointer
=	O
new_header	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
old_header	pointer
,	O
value_start	pointer
-	O
old_header	pointer
)	O
;	O
p	pointer
+=	O
value_start	pointer
-	O
old_header	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
value	pointer
,	O
strlen	function
(	O
value	pointer
)	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
value	pointer
)	O
;	O
if	O
(	O
*	O
value_end	pointer
!=	O
'\n'	O
)	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
strcpy	function
(	O
p	pointer
,	O
value_end	pointer
)	O
;	O
return	O
new_header	pointer
;	O
}	O
line	long
=	O
strchr	function
(	O
line	long
,	O
'\n'	O
)	O
;	O
if	O
(	O
line	long
!=	O
NULL	O
)	O
line	long
++	O
;	O
else	O
break	O
;	O
}	O
new_header	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
old_header	pointer
)	O
+	O
1	int
+	O
len	long
+	O
2	int
+	O
strlen	function
(	O
value	pointer
)	O
+	O
1	int
+	O
1	int
,	O
char	O
)	O
;	O
p	pointer
=	O
new_header	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
old_header	pointer
,	O
strlen	function
(	O
old_header	pointer
)	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
old_header	pointer
)	O
;	O
if	O
(	O
p	pointer
>	O
new_header	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
!=	O
'\n'	O
)	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
memcpy	function
(	O
p	pointer
,	O
field	pointer
,	O
len	long
)	O
;	O
p	pointer
+=	O
len	long
;	O
*	O
p	pointer
++	O
=	O
':'	O
;	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
memcpy	function
(	O
p	pointer
,	O
value	pointer
,	O
strlen	function
(	O
value	pointer
)	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
value	pointer
)	O
;	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
new_header	pointer
;	O
}	O
static	O
const	O
char	O
*	O
get_title	function
(	O
)	O
{	O
const	O
char	O
*	O
encoding	pointer
;	O
const	O
char	O
*	O
tmp	pointer
;	O
char	O
*	O
old_LC_ALL	pointer
;	O
char	O
*	O
old_LANGUAGE	pointer
;	O
char	O
*	O
old_OUTPUT_CHARSET	pointer
;	O
const	O
char	O
*	O
msgid	pointer
;	O
const	O
char	O
*	O
english	pointer
;	O
const	O
char	O
*	O
result	pointer
;	O
encoding	pointer
=	O
canonical_locale_charset	function
(	O
)	O
;	O
english	pointer
=	O
xasprintf	function
(	O
"%s translations for %%s package"	pointer
,	O
englishname_of_language	function
(	O
)	O
)	O
;	O
tmp	pointer
=	O
getenv	function
(	O
"LC_ALL"	pointer
)	O
;	O
old_LC_ALL	pointer
=	O
(	O
tmp	pointer
!=	O
NULL	O
?	O
xstrdup	function
(	O
tmp	pointer
)	O
:	O
NULL	O
)	O
;	O
tmp	pointer
=	O
getenv	function
(	O
"LANGUAGE"	pointer
)	O
;	O
old_LANGUAGE	pointer
=	O
(	O
tmp	pointer
!=	O
NULL	O
?	O
xstrdup	function
(	O
tmp	pointer
)	O
:	O
NULL	O
)	O
;	O
tmp	pointer
=	O
getenv	function
(	O
"OUTPUT_CHARSET"	pointer
)	O
;	O
old_OUTPUT_CHARSET	pointer
=	O
(	O
tmp	pointer
!=	O
NULL	O
?	O
xstrdup	function
(	O
tmp	pointer
)	O
:	O
NULL	O
)	O
;	O
xsetenv	function
(	O
"LC_ALL"	pointer
,	O
locale	pointer
,	O
1	int
)	O
;	O
unsetenv	function
(	O
"LANGUAGE"	pointer
)	O
;	O
xsetenv	function
(	O
"OUTPUT_CHARSET"	pointer
,	O
encoding	pointer
,	O
1	int
)	O
;	O
if	O
(	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
==	O
NULL	O
)	O
result	pointer
=	O
english	pointer
;	O
else	O
{	O
msgid	pointer
=	O
N_	O
(	O
"English translations for %s package"	pointer
)	O
;	O
result	pointer
=	O
gettext	function
(	O
msgid	pointer
)	O
;	O
if	O
(	O
result	pointer
!=	O
msgid	pointer
&&	O
strcmp	function
(	O
result	pointer
,	O
msgid	pointer
)	O
!=	O
0	int
)	O
result	pointer
=	O
xasprintf	function
(	O
"%s\n%s"	pointer
,	O
english	pointer
,	O
result	pointer
)	O
;	O
else	O
result	pointer
=	O
english	pointer
;	O
}	O
if	O
(	O
old_LC_ALL	pointer
!=	O
NULL	O
)	O
xsetenv	function
(	O
"LC_ALL"	pointer
,	O
old_LC_ALL	pointer
,	O
1	int
)	O
,	O
free	function
(	O
old_LC_ALL	pointer
)	O
;	O
else	O
unsetenv	function
(	O
"LC_ALL"	pointer
)	O
;	O
if	O
(	O
old_LANGUAGE	pointer
!=	O
NULL	O
)	O
xsetenv	function
(	O
"LANGUAGE"	pointer
,	O
old_LANGUAGE	pointer
,	O
1	int
)	O
,	O
free	function
(	O
old_LANGUAGE	pointer
)	O
;	O
else	O
unsetenv	function
(	O
"LANGUAGE"	pointer
)	O
;	O
if	O
(	O
old_OUTPUT_CHARSET	pointer
!=	O
NULL	O
)	O
xsetenv	function
(	O
"OUTPUT_CHARSET"	pointer
,	O
old_OUTPUT_CHARSET	pointer
,	O
1	int
)	O
,	O
free	function
(	O
old_OUTPUT_CHARSET	pointer
)	O
;	O
else	O
unsetenv	function
(	O
"OUTPUT_CHARSET"	pointer
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
static	O
const	O
char	O
*	O
subst_string	function
(	O
const	O
char	O
*	O
str	pointer
,	O
unsigned	O
int	O
nsubst	int
,	O
const	O
char	O
*	O
(	O
*	O
subst	pointer
)	O
[	O
2	int
]	O
)	O
{	O
if	O
(	O
nsubst	int
>	O
0	int
)	O
{	O
char	O
*	O
malloced	pointer
=	O
NULL	O
;	O
size_t	long
*	O
substlen	pointer
;	O
size_t	long
i	long
;	O
unsigned	O
int	O
j	int
;	O
substlen	pointer
=	O
(	O
size_t	long
*	O
)	O
xmalloca	O
(	O
nsubst	int
*	O
sizeof	O
(	O
size_t	long
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nsubst	int
;	O
j	int
++	O
)	O
{	O
substlen	pointer
[	O
j	int
]	O
=	O
strlen	function
(	O
subst	pointer
[	O
j	int
]	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
substlen	pointer
[	O
j	int
]	O
==	O
0	int
)	O
abort	function
(	O
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
;	O
)	O
{	O
if	O
(	O
str	pointer
[	O
i	long
]	O
==	O
'\0'	O
)	O
break	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nsubst	int
;	O
j	int
++	O
)	O
if	O
(	O
*	O
(	O
str	pointer
+	O
i	long
)	O
==	O
*	O
subst	pointer
[	O
j	int
]	O
[	O
0	int
]	O
&&	O
strncmp	function
(	O
str	pointer
+	O
i	long
,	O
subst	pointer
[	O
j	int
]	O
[	O
0	int
]	O
,	O
substlen	pointer
[	O
j	int
]	O
)	O
==	O
0	int
)	O
{	O
size_t	long
replacement_len	long
=	O
strlen	function
(	O
subst	pointer
[	O
j	int
]	O
[	O
1	int
]	O
)	O
;	O
size_t	long
new_len	long
=	O
strlen	function
(	O
str	pointer
)	O
-	O
substlen	pointer
[	O
j	int
]	O
+	O
replacement_len	long
;	O
char	O
*	O
new_str	pointer
=	O
XNMALLOC	O
(	O
new_len	long
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
new_str	pointer
,	O
str	pointer
,	O
i	long
)	O
;	O
memcpy	function
(	O
new_str	pointer
+	O
i	long
,	O
subst	pointer
[	O
j	int
]	O
[	O
1	int
]	O
,	O
replacement_len	long
)	O
;	O
strcpy	function
(	O
new_str	pointer
+	O
i	long
+	O
replacement_len	long
,	O
str	pointer
+	O
i	long
+	O
substlen	pointer
[	O
j	int
]	O
)	O
;	O
if	O
(	O
malloced	pointer
!=	O
NULL	O
)	O
free	function
(	O
malloced	pointer
)	O
;	O
str	pointer
=	O
new_str	pointer
;	O
malloced	pointer
=	O
new_str	pointer
;	O
i	long
+=	O
replacement_len	long
;	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
nsubst	int
)	O
i	long
++	O
;	O
}	O
freea	function
(	O
substlen	pointer
)	O
;	O
}	O
return	O
str	pointer
;	O
}	O
static	O
void	O
subst_string_list	function
(	O
string_list_ty	struct
*	O
slp	pointer
,	O
unsigned	O
int	O
nsubst	int
,	O
const	O
char	O
*	O
(	O
*	O
subst	pointer
)	O
[	O
2	int
]	O
)	O
{	O
size_t	long
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
slp	pointer
->	O
nitems	long
;	O
j	int
++	O
)	O
slp	pointer
->	O
item	pointer
[	O
j	int
]	O
=	O
subst_string	function
(	O
slp	pointer
->	O
item	pointer
[	O
j	int
]	O
,	O
nsubst	int
,	O
subst	pointer
)	O
;	O
}	O
static	O
msgdomain_list_ty	struct
*	O
fill_header	function
(	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
)	O
{	O
const	O
char	O
*	O
field_value	array
[	O
NFIELDS	O
]	O
;	O
size_t	long
k	long
,	O
j	int
,	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFIELDS	O
;	O
i	long
++	O
)	O
field_value	array
[	O
i	long
]	O
=	O
NULL	O
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mdlp	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
>	O
0	int
)	O
{	O
message_ty	struct
*	O
header_mp	pointer
=	O
NULL	O
;	O
char	O
*	O
header	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
mlp	pointer
->	O
nitems	long
;	O
j	int
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	int
]	O
)	O
&&	O
!	O
mlp	pointer
->	O
item	pointer
[	O
j	int
]	O
->	O
obsolete	bool
)	O
{	O
header_mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	int
]	O
;	O
break	O
;	O
}	O
if	O
(	O
header_mp	pointer
==	O
NULL	O
)	O
{	O
static	O
lex_pos_ty	struct
pos	struct
=	O
{	O
__FILE__	O
,	O
__LINE__	O
}	O
;	O
header_mp	pointer
=	O
message_alloc	function
(	O
NULL	O
,	O
""	pointer
,	O
NULL	O
,	O
""	pointer
,	O
1	int
,	O
&	O
pos	struct
)	O
;	O
message_list_prepend	function
(	O
mlp	pointer
,	O
header_mp	pointer
)	O
;	O
}	O
header	pointer
=	O
xstrdup	function
(	O
header_mp	pointer
->	O
msgstr	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFIELDS	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
field_value	array
[	O
i	long
]	O
==	O
NULL	O
)	O
field_value	array
[	O
i	long
]	O
=	O
(	O
fields	array
[	O
i	long
]	O
.	O
getter1	pointer
!=	O
NULL	O
?	O
fields	array
[	O
i	long
]	O
.	O
getter1	pointer
(	O
header	pointer
)	O
:	O
fields	array
[	O
i	long
]	O
.	O
getter0	pointer
(	O
)	O
)	O
;	O
if	O
(	O
field_value	array
[	O
i	long
]	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
old_header	pointer
=	O
header	pointer
;	O
header	pointer
=	O
put_field	function
(	O
header	pointer
,	O
fields	array
[	O
i	long
]	O
.	O
name	pointer
,	O
field_value	array
[	O
i	long
]	O
)	O
;	O
free	function
(	O
old_header	pointer
)	O
;	O
}	O
}	O
header_mp	pointer
->	O
msgstr	pointer
=	O
header	pointer
;	O
header_mp	pointer
->	O
msgstr_len	long
=	O
strlen	function
(	O
header	pointer
)	O
+	O
1	int
;	O
if	O
(	O
header_mp	pointer
->	O
comment	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
subst	pointer
[	O
4	int
]	O
[	O
2	int
]	O
;	O
const	O
char	O
*	O
id	pointer
;	O
time_t	long
now	long
;	O
id	pointer
=	O
project_id	function
(	O
header	pointer
)	O
;	O
subst	pointer
[	O
0	int
]	O
[	O
0	int
]	O
=	O
"SOME DESCRIPTIVE TITLE"	pointer
;	O
subst	pointer
[	O
0	int
]	O
[	O
1	int
]	O
=	O
xasprintf	function
(	O
get_title	function
(	O
)	O
,	O
id	pointer
,	O
id	pointer
)	O
;	O
subst	pointer
[	O
1	int
]	O
[	O
0	int
]	O
=	O
"PACKAGE"	pointer
;	O
subst	pointer
[	O
1	int
]	O
[	O
1	int
]	O
=	O
id	pointer
;	O
subst	pointer
[	O
2	int
]	O
[	O
0	int
]	O
=	O
"FIRST AUTHOR <EMAIL@ADDRESS>"	pointer
;	O
subst	pointer
[	O
2	int
]	O
[	O
1	int
]	O
=	O
field_value	array
[	O
FIELD_LAST_TRANSLATOR	int
]	O
;	O
subst	pointer
[	O
3	int
]	O
[	O
0	int
]	O
=	O
"YEAR"	pointer
;	O
subst	pointer
[	O
3	int
]	O
[	O
1	int
]	O
=	O
xasprintf	function
(	O
"%d"	pointer
,	O
(	O
time	struct
(	O
&	O
now	long
)	O
,	O
(	O
localtime	function
(	O
&	O
now	long
)	O
)	O
->	O
tm_year	int
+	O
1900	int
)	O
)	O
;	O
subst_string_list	function
(	O
header_mp	pointer
->	O
comment	pointer
,	O
SIZEOF	O
(	O
subst	pointer
)	O
,	O
subst	pointer
)	O
;	O
}	O
header_mp	pointer
->	O
is_fuzzy	bool
=	O
false	int
;	O
}	O
}	O
return	O
mdlp	pointer
;	O
}	O
static	O
msgdomain_list_ty	struct
*	O
update_msgstr_plurals	function
(	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
)	O
{	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mdlp	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
message_ty	struct
*	O
header_entry	pointer
;	O
unsigned	O
long	O
int	O
nplurals	long
;	O
char	O
*	O
untranslated_plural_msgstr	pointer
;	O
size_t	long
j	int
;	O
header_entry	pointer
=	O
message_list_search	function
(	O
mlp	pointer
,	O
NULL	O
,	O
""	pointer
)	O
;	O
nplurals	long
=	O
get_plural_count	function
(	O
header_entry	pointer
?	O
header_entry	pointer
->	O
msgstr	pointer
:	O
NULL	O
)	O
;	O
untranslated_plural_msgstr	pointer
=	O
XNMALLOC	O
(	O
nplurals	long
,	O
char	O
)	O
;	O
memset	function
(	O
untranslated_plural_msgstr	pointer
,	O
'\0'	O
,	O
nplurals	long
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
mlp	pointer
->	O
nitems	long
;	O
j	int
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	int
]	O
;	O
bool	bool
is_untranslated	bool
;	O
const	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
pend	pointer
;	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
is_untranslated	bool
=	O
true	int
;	O
for	O
(	O
p	pointer
=	O
mp	pointer
->	O
msgstr	pointer
,	O
pend	pointer
=	O
p	pointer
+	O
mp	pointer
->	O
msgstr_len	long
;	O
p	pointer
<	O
pend	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
is_untranslated	bool
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
is_untranslated	bool
)	O
{	O
if	O
(	O
nplurals	long
>	O
mp	pointer
->	O
msgstr_len	long
)	O
mp	pointer
->	O
msgstr	pointer
=	O
untranslated_plural_msgstr	pointer
;	O
mp	pointer
->	O
msgstr_len	long
=	O
nplurals	long
;	O
}	O
}	O
}	O
}	O
return	O
mdlp	pointer
;	O
}	O
