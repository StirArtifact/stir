static	O
int	O
single_set	int
;	O
static	O
int	O
mode_change	int
,	O
need_update	int
;	O
static	O
int	O
c_file	int
,	O
end_chmod	int
;	O
static	O
mode_t	int
and_mask	int
,	O
or_mask	int
,	O
c_stat	int
;	O
static	O
const	O
char	O
*	O
c_fname	pointer
,	O
*	O
c_fown	pointer
,	O
*	O
c_fgrp	pointer
;	O
static	O
WLabel	struct
*	O
statl	pointer
;	O
static	O
struct	O
{	O
mode_t	int
mode	int
;	O
const	O
char	O
*	O
text	pointer
;	O
int	O
selected	int
;	O
WCheck	struct
*	O
check	pointer
;	O
}	O
check_perm	array
[	O
PERMISSIONS	int
]	O
=	O
{	O
{	O
S_IXOTH	O
,	O
N_	O
(	O
"execute/search by others"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_IWOTH	O
,	O
N_	O
(	O
"write by others"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_IROTH	O
,	O
N_	O
(	O
"read by others"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_IXGRP	O
,	O
N_	O
(	O
"execute/search by group"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_IWGRP	O
,	O
N_	O
(	O
"write by group"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_IRGRP	O
,	O
N_	O
(	O
"read by group"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_IXUSR	O
,	O
N_	O
(	O
"execute/search by owner"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_IWUSR	O
,	O
N_	O
(	O
"write by owner"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_IRUSR	O
,	O
N_	O
(	O
"read by owner"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_ISVTX	O
,	O
N_	O
(	O
"sticky bit"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_ISGID	O
,	O
N_	O
(	O
"set group ID on execution"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
{	O
S_ISUID	O
,	O
N_	O
(	O
"set user ID on execution"	pointer
)	O
,	O
0	int
,	O
0	int
,	O
}	O
,	O
}	O
;	O
static	O
struct	O
{	O
int	O
ret_cmd	int
,	O
flags	enum
,	O
y	short
,	O
x	array
;	O
const	O
char	O
*	O
text	pointer
;	O
}	O
chmod_but	array
[	O
BUTTONS	int
]	O
=	O
{	O
{	O
B_CANCEL	int
,	O
NORMAL_BUTTON	int
,	O
2	int
,	O
33	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
}	O
,	O
{	O
B_ENTER	int
,	O
DEFPUSH_BUTTON	int
,	O
2	int
,	O
17	int
,	O
N_	O
(	O
"&Set"	pointer
)	O
}	O
,	O
{	O
B_CLRMRK	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
42	int
,	O
N_	O
(	O
"C&lear marked"	pointer
)	O
}	O
,	O
{	O
B_SETMRK	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
27	int
,	O
N_	O
(	O
"S&et marked"	pointer
)	O
}	O
,	O
{	O
B_MARKED	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
12	int
,	O
N_	O
(	O
"&Marked all"	pointer
)	O
}	O
,	O
{	O
B_ALL	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"Set &all"	pointer
)	O
}	O
,	O
}	O
;	O
static	O
void	O
chmod_toggle_select	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
Id	int
)	O
{	O
attrset	function
(	O
COLOR_NORMAL	O
)	O
;	O
check_perm	array
[	O
Id	int
]	O
.	O
selected	int
^=	O
1	int
;	O
dlg_move	O
(	O
h	pointer
,	O
PY	int
+	O
PERMISSIONS	int
-	O
Id	int
,	O
PX	int
+	O
1	int
)	O
;	O
addch	O
(	O
(	O
check_perm	array
[	O
Id	int
]	O
.	O
selected	int
)	O
?	O
'*'	O
:	O
' '	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
PY	int
+	O
PERMISSIONS	int
-	O
Id	int
,	O
PX	int
+	O
3	int
)	O
;	O
}	O
static	O
void	O
chmod_refresh	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
common_dialog_repaint	function
(	O
h	pointer
)	O
;	O
attrset	function
(	O
COLOR_NORMAL	O
)	O
;	O
draw_box	function
(	O
h	pointer
,	O
PY	int
,	O
PX	int
,	O
PERMISSIONS	int
+	O
2	int
,	O
33	int
)	O
;	O
draw_box	function
(	O
h	pointer
,	O
FY	int
,	O
FX	int
,	O
10	int
,	O
25	int
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
FY	int
+	O
1	int
,	O
FX	int
+	O
2	int
)	O
;	O
addstr	O
(	O
_	O
(	O
"Name"	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
FY	int
+	O
3	int
,	O
FX	int
+	O
2	int
)	O
;	O
addstr	O
(	O
_	O
(	O
"Permissions (Octal)"	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
FY	int
+	O
5	int
,	O
FX	int
+	O
2	int
)	O
;	O
addstr	O
(	O
_	O
(	O
"Owner name"	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
FY	int
+	O
7	int
,	O
FX	int
+	O
2	int
)	O
;	O
addstr	O
(	O
_	O
(	O
"Group name"	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
,	O
TX	int
)	O
;	O
addstr	O
(	O
_	O
(	O
"Use SPACE to change"	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
+	O
1	int
,	O
TX	int
)	O
;	O
addstr	O
(	O
_	O
(	O
"an option, ARROW KEYS"	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
+	O
2	int
,	O
TX	int
)	O
;	O
addstr	O
(	O
_	O
(	O
"to move between options"	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
+	O
3	int
,	O
TX	int
)	O
;	O
addstr	O
(	O
_	O
(	O
"and T or INS to mark"	pointer
)	O
)	O
;	O
attrset	function
(	O
COLOR_HOT_NORMAL	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
PY	int
,	O
PX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" Permission "	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
FY	int
,	O
FX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" File "	pointer
)	O
)	O
;	O
}	O
static	O
cb_ret_t	enum
chmod_callback	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
char	O
buffer	pointer
[	O
BUF_TINY	int
]	O
;	O
int	O
id	int
=	O
h	pointer
->	O
current	pointer
->	O
dlg_id	int
-	O
BUTTONS	int
+	O
single_set	int
*	O
2	int
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_ACTION	int
:	O
if	O
(	O
id	int
>=	O
0	int
)	O
{	O
c_stat	int
^=	O
check_perm	array
[	O
id	int
]	O
.	O
mode	int
;	O
g_snprintf	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
"%o"	pointer
,	O
c_stat	int
)	O
;	O
label_set_text	function
(	O
statl	pointer
,	O
buffer	pointer
)	O
;	O
chmod_toggle_select	function
(	O
h	pointer
,	O
id	int
)	O
;	O
mode_change	int
=	O
1	int
;	O
}	O
return	O
MSG_HANDLED	int
;	O
case	O
DLG_KEY	int
:	O
if	O
(	O
(	O
parm	int
==	O
'T'	O
||	O
parm	int
==	O
't'	O
||	O
parm	int
==	O
KEY_IC	int
)	O
&&	O
id	int
>	O
0	int
)	O
{	O
chmod_toggle_select	function
(	O
h	pointer
,	O
id	int
)	O
;	O
if	O
(	O
parm	int
==	O
KEY_IC	int
)	O
dlg_one_down	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
DLG_DRAW	int
:	O
chmod_refresh	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
Dlg_head	struct
*	O
init_chmod	function
(	O
void	O
)	O
{	O
int	O
i	array
;	O
Dlg_head	struct
*	O
ch_dlg	pointer
;	O
do_refresh	function
(	O
)	O
;	O
end_chmod	int
=	O
c_file	int
=	O
need_update	int
=	O
0	int
;	O
single_set	int
=	O
(	O
current_panel	pointer
->	O
marked	int
<	O
2	int
)	O
?	O
2	int
:	O
0	int
;	O
ch_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
22	int
-	O
single_set	int
,	O
70	int
,	O
dialog_colors	array
,	O
chmod_callback	function
,	O
"[Chmod]"	pointer
,	O
_	O
(	O
"Chmod command"	pointer
)	O
,	O
DLG_CENTER	O
|	O
DLG_REVERSE	O
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
BUTTONS	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
i	array
==	O
2	int
&&	O
single_set	int
)	O
break	O
;	O
else	O
add_widget	function
(	O
ch_dlg	pointer
,	O
button_new	function
(	O
BY	int
+	O
chmod_but	array
[	O
i	array
]	O
.	O
y	short
-	O
single_set	int
,	O
BX	int
+	O
chmod_but	array
[	O
i	array
]	O
.	O
x	array
,	O
chmod_but	array
[	O
i	array
]	O
.	O
ret_cmd	int
,	O
chmod_but	array
[	O
i	array
]	O
.	O
flags	enum
,	O
_	O
(	O
chmod_but	array
[	O
i	array
]	O
.	O
text	pointer
)	O
,	O
0	int
)	O
)	O
;	O
}	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
PERMISSIONS	int
;	O
i	array
++	O
)	O
{	O
check_perm	array
[	O
i	array
]	O
.	O
check	pointer
=	O
check_new	function
(	O
PY	int
+	O
(	O
PERMISSIONS	int
-	O
i	array
)	O
,	O
PX	int
+	O
2	int
,	O
0	int
,	O
_	O
(	O
check_perm	array
[	O
i	array
]	O
.	O
text	pointer
)	O
)	O
;	O
add_widget	function
(	O
ch_dlg	pointer
,	O
check_perm	array
[	O
i	array
]	O
.	O
check	pointer
)	O
;	O
}	O
return	O
ch_dlg	pointer
;	O
}	O
static	O
void	O
chmod_done	function
(	O
void	O
)	O
{	O
if	O
(	O
need_update	int
)	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
static	O
char	O
*	O
next_file	function
(	O
void	O
)	O
{	O
while	O
(	O
!	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
c_file	int
]	O
.	O
f	float
.	O
marked	int
)	O
c_file	int
++	O
;	O
return	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
c_file	int
]	O
.	O
fname	pointer
;	O
}	O
static	O
void	O
do_chmod	function
(	O
struct	O
stat	struct
*	O
sf	pointer
)	O
{	O
sf	pointer
->	O
st_mode	int
&=	O
and_mask	int
;	O
sf	pointer
->	O
st_mode	int
|=	O
or_mask	int
;	O
if	O
(	O
mc_chmod	function
(	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
c_file	int
]	O
.	O
fname	pointer
,	O
sf	pointer
->	O
st_mode	int
)	O
==	O
-	O
1	int
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot chmod \"%s\" \n %s "	pointer
)	O
,	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
c_file	int
]	O
.	O
fname	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
do_file_mark	function
(	O
current_panel	pointer
,	O
c_file	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
apply_mask	function
(	O
struct	O
stat	struct
*	O
sf	pointer
)	O
{	O
char	O
*	O
fname	pointer
;	O
need_update	int
=	O
end_chmod	int
=	O
1	int
;	O
do_chmod	function
(	O
sf	pointer
)	O
;	O
do	O
{	O
fname	pointer
=	O
next_file	function
(	O
)	O
;	O
if	O
(	O
mc_stat	function
(	O
fname	pointer
,	O
sf	pointer
)	O
!=	O
0	int
)	O
return	O
;	O
c_stat	int
=	O
sf	pointer
->	O
st_mode	int
;	O
do_chmod	function
(	O
sf	pointer
)	O
;	O
}	O
while	O
(	O
current_panel	pointer
->	O
marked	int
)	O
;	O
}	O
void	O
chmod_cmd	function
(	O
void	O
)	O
{	O
char	O
buffer	pointer
[	O
BUF_TINY	int
]	O
;	O
char	O
*	O
fname	pointer
;	O
int	O
i	array
;	O
struct	O
stat	struct
sf_stat	struct
;	O
Dlg_head	struct
*	O
ch_dlg	pointer
;	O
do	O
{	O
ch_dlg	pointer
=	O
init_chmod	function
(	O
)	O
;	O
if	O
(	O
current_panel	pointer
->	O
marked	int
)	O
fname	pointer
=	O
next_file	function
(	O
)	O
;	O
else	O
fname	pointer
=	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
;	O
if	O
(	O
mc_stat	function
(	O
fname	pointer
,	O
&	O
sf_stat	struct
)	O
!=	O
0	int
)	O
{	O
destroy_dlg	function
(	O
ch_dlg	pointer
)	O
;	O
break	O
;	O
}	O
c_stat	int
=	O
sf_stat	struct
.	O
st_mode	int
;	O
mode_change	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
PERMISSIONS	int
;	O
i	array
++	O
)	O
{	O
check_perm	array
[	O
i	array
]	O
.	O
check	pointer
->	O
state	pointer
=	O
(	O
c_stat	int
&	O
check_perm	array
[	O
i	array
]	O
.	O
mode	int
)	O
?	O
1	int
:	O
0	int
;	O
check_perm	array
[	O
i	array
]	O
.	O
selected	int
=	O
0	int
;	O
}	O
c_fname	pointer
=	O
name_trunc	function
(	O
fname	pointer
,	O
21	int
)	O
;	O
add_widget	function
(	O
ch_dlg	pointer
,	O
label_new	function
(	O
FY	int
+	O
2	int
,	O
FX	int
+	O
2	int
,	O
c_fname	pointer
)	O
)	O
;	O
c_fown	pointer
=	O
name_trunc	function
(	O
get_owner	function
(	O
sf_stat	struct
.	O
st_uid	int
)	O
,	O
21	int
)	O
;	O
add_widget	function
(	O
ch_dlg	pointer
,	O
label_new	function
(	O
FY	int
+	O
6	int
,	O
FX	int
+	O
2	int
,	O
c_fown	pointer
)	O
)	O
;	O
c_fgrp	pointer
=	O
name_trunc	function
(	O
get_group	function
(	O
sf_stat	struct
.	O
st_gid	int
)	O
,	O
21	int
)	O
;	O
add_widget	function
(	O
ch_dlg	pointer
,	O
label_new	function
(	O
FY	int
+	O
8	int
,	O
FX	int
+	O
2	int
,	O
c_fgrp	pointer
)	O
)	O
;	O
g_snprintf	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
"%o"	pointer
,	O
c_stat	int
)	O
;	O
statl	pointer
=	O
label_new	function
(	O
FY	int
+	O
4	int
,	O
FX	int
+	O
2	int
,	O
buffer	pointer
)	O
;	O
add_widget	function
(	O
ch_dlg	pointer
,	O
statl	pointer
)	O
;	O
run_dlg	function
(	O
ch_dlg	pointer
)	O
;	O
switch	O
(	O
ch_dlg	pointer
->	O
ret_value	int
)	O
{	O
case	O
B_ENTER	int
:	O
if	O
(	O
mode_change	int
)	O
if	O
(	O
mc_chmod	function
(	O
fname	pointer
,	O
c_stat	int
)	O
==	O
-	O
1	int
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot chmod \"%s\" \n %s "	pointer
)	O
,	O
fname	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
need_update	int
=	O
1	int
;	O
break	O
;	O
case	O
B_CANCEL	int
:	O
end_chmod	int
=	O
1	int
;	O
break	O
;	O
case	O
B_ALL	O
:	O
case	O
B_MARKED	O
:	O
and_mask	int
=	O
or_mask	int
=	O
0	int
;	O
and_mask	int
=	O
~	O
and_mask	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
PERMISSIONS	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
check_perm	array
[	O
i	array
]	O
.	O
selected	int
||	O
ch_dlg	pointer
->	O
ret_value	int
==	O
B_ALL	O
)	O
{	O
if	O
(	O
check_perm	array
[	O
i	array
]	O
.	O
check	pointer
->	O
state	pointer
&	O
C_BOOL	int
)	O
or_mask	int
|=	O
check_perm	array
[	O
i	array
]	O
.	O
mode	int
;	O
else	O
and_mask	int
&=	O
~	O
check_perm	array
[	O
i	array
]	O
.	O
mode	int
;	O
}	O
}	O
apply_mask	function
(	O
&	O
sf_stat	struct
)	O
;	O
break	O
;	O
case	O
B_SETMRK	O
:	O
and_mask	int
=	O
or_mask	int
=	O
0	int
;	O
and_mask	int
=	O
~	O
and_mask	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
PERMISSIONS	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
check_perm	array
[	O
i	array
]	O
.	O
selected	int
)	O
or_mask	int
|=	O
check_perm	array
[	O
i	array
]	O
.	O
mode	int
;	O
}	O
apply_mask	function
(	O
&	O
sf_stat	struct
)	O
;	O
break	O
;	O
case	O
B_CLRMRK	O
:	O
and_mask	int
=	O
or_mask	int
=	O
0	int
;	O
and_mask	int
=	O
~	O
and_mask	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
PERMISSIONS	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
check_perm	array
[	O
i	array
]	O
.	O
selected	int
)	O
and_mask	int
&=	O
~	O
check_perm	array
[	O
i	array
]	O
.	O
mode	int
;	O
}	O
apply_mask	function
(	O
&	O
sf_stat	struct
)	O
;	O
break	O
;	O
}	O
if	O
(	O
current_panel	pointer
->	O
marked	int
&&	O
ch_dlg	pointer
->	O
ret_value	int
!=	O
B_CANCEL	int
)	O
{	O
do_file_mark	function
(	O
current_panel	pointer
,	O
c_file	int
,	O
0	int
)	O
;	O
need_update	int
=	O
1	int
;	O
}	O
destroy_dlg	function
(	O
ch_dlg	pointer
)	O
;	O
}	O
while	O
(	O
current_panel	pointer
->	O
marked	int
&&	O
!	O
end_chmod	int
)	O
;	O
chmod_done	function
(	O
)	O
;	O
}	O
