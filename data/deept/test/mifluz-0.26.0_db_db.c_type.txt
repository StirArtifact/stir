static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db.c,v 1.9 2014/04/17 20:27:26 sebdiaz Exp $"	pointer
;	O
typedef	O
enum	O
{	O
MU_REMOVE	int
,	O
MU_RENAME	int
,	O
MU_OPEN	int
}	O
mu_action	enum
;	O
static	O
int	O
__db_file_setup	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
const	O
char	O
*	O
,	O
u_int32_t	int
,	O
int	O
,	O
db_pgno_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_master_update	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
const	O
char	O
*	O
,	O
u_int32_t	int
,	O
db_pgno_t	int
*	O
,	O
mu_action	enum
,	O
const	O
char	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__db_metabegin	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_LOCK	struct
*	O
)	O
)	O
;	O
static	O
int	O
__db_metaend	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_LOCK	struct
*	O
,	O
int	O
,	O
int	O
(	O
*	O
)	O
(	O
DB	struct
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_refresh	function
__P	O
(	O
(	O
DB	struct
*	O
)	O
)	O
;	O
static	O
int	O
__db_remove_callback	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
void	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_set_pgsize	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_FH	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_subdb_remove	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_subdb_rename	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
int	O
CDB___db_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
subdb	pointer
,	O
type	enum
,	O
flags	int
,	O
mode	enum
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
,	O
*	O
subdb	pointer
;	O
DBTYPE	enum
type	enum
;	O
u_int32_t	int
flags	int
;	O
int	O
mode	enum
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK	struct
open_lock	struct
;	O
DB	struct
*	O
mdbp	pointer
;	O
db_pgno_t	int
meta_pgno	int
;	O
u_int32_t	int
ok_flags	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
mdbp	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"DB->open"	pointer
,	O
flags	int
,	O
OKFLAGS	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_EXCL	int
)	O
&&	O
!	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
"DB->open"	pointer
,	O
1	int
)	O
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_RDONLY	int
)	O
&&	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
"DB->open"	pointer
,	O
1	int
)	O
)	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
DB_UNKNOWN	int
:	O
if	O
(	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: DB_UNKNOWN type specified with DB_CREATE"	pointer
,	O
name	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
ok_flags	int
=	O
0	int
;	O
break	O
;	O
case	O
DB_BTREE	int
:	O
ok_flags	int
=	O
DB_OK_BTREE	int
;	O
break	O
;	O
case	O
DB_HASH	int
:	O
ok_flags	int
=	O
DB_OK_HASH	int
;	O
break	O
;	O
case	O
DB_QUEUE	int
:	O
ok_flags	int
=	O
DB_OK_QUEUE	int
;	O
break	O
;	O
case	O
DB_RECNO	int
:	O
ok_flags	int
=	O
DB_OK_RECNO	int
;	O
break	O
;	O
default	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"unknown type: %lu"	pointer
,	O
type	enum
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
ok_flags	int
)	O
DB_ILLEGAL_METHOD	O
(	O
dbp	pointer
,	O
ok_flags	int
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_DBLOCAL	int
|	O
DB_ENV_OPEN_CALLED	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"environment not yet opened"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_DBLOCAL	int
)	O
&&	O
!	O
MPOOL_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"environment did not include a memory pool."	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_THREAD	int
)	O
&&	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_DBLOCAL	int
|	O
DB_ENV_THREAD	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"environment not created using DB_THREAD"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
LF_SET	O
(	O
DB_THREAD	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_TRUNCATE	int
)	O
&&	O
TXN_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"DB_TRUNCATE illegal in a transaction protected environment"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
subdb	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"multiple databases cannot be created in temporary files"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
type	enum
==	O
DB_QUEUE	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Queue databases must be one-per-file"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_RDONLY	int
)	O
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_COMPRESS	int
)	O
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_CMPR	int
)	O
;	O
dbp	pointer
->	O
type	enum
=	O
type	enum
;	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
&&	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
__db_metabegin	function
(	O
dbp	pointer
,	O
&	O
open_lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
subdb	pointer
==	O
NULL	O
)	O
meta_pgno	int
=	O
PGNO_BASE_MD	int
;	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_master_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	enum
,	O
&	O
mdbp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
dbp	pointer
->	O
pgsize	int
=	O
mdbp	pointer
->	O
pgsize	int
;	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
;	O
memcpy	function
(	O
dbp	pointer
->	O
fileid	array
,	O
mdbp	pointer
->	O
fileid	array
,	O
DB_FILE_ID_LEN	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_master_update	function
(	O
mdbp	pointer
,	O
subdb	pointer
,	O
type	enum
,	O
&	O
meta_pgno	int
,	O
MU_OPEN	int
,	O
NULL	O
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
LF_CLR	O
(	O
DB_EXCL	int
|	O
DB_TRUNCATE	int
)	O
;	O
}	O
ret	int
=	O
CDB___db_dbopen	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	enum
,	O
meta_pgno	int
)	O
;	O
if	O
(	O
subdb	pointer
==	O
NULL	O
&&	O
!	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
&&	O
!	O
LF_ISSET	O
(	O
DB_RDONLY	int
)	O
&&	O
!	O
LF_ISSET	O
(	O
DB_RDWRMASTER	int
)	O
&&	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"files containing multiple databases may only be opened read-only"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
err	pointer
:	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
&&	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
if	O
(	O
(	O
t_ret	int
=	O
__db_metaend	function
(	O
dbp	pointer
,	O
&	O
open_lock	struct
,	O
ret	int
==	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
F_CLR	O
(	O
dbp	pointer
,	O
DB_AM_DISCARD	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
if	O
(	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
)	O
dbp	pointer
->	O
log_fileid	int
=	O
DB_LOGFILEID_INVALID	O
;	O
__db_refresh	function
(	O
dbp	pointer
)	O
;	O
}	O
if	O
(	O
mdbp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
F_CLR	O
(	O
mdbp	pointer
,	O
DB_AM_DISCARD	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
mdbp	pointer
->	O
close	pointer
(	O
mdbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_dbopen	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	enum
,	O
meta_pgno	int
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
mode	enum
;	O
db_pgno_t	int
meta_pgno	int
;	O
{	O
int	O
ret	int
,	O
retinfo	int
;	O
if	O
(	O
(	O
ret	int
=	O
__db_file_setup	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	enum
,	O
meta_pgno	int
,	O
&	O
retinfo	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
retinfo	int
&	O
DB_FILE_SETUP_CREATE	int
)	O
flags	int
|=	O
DB_TRUNCATE	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_dbenv_setup	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
F_SET	O
(	O
dbp	pointer
,	O
DB_OPEN_CALLED	int
)	O
;	O
if	O
(	O
retinfo	int
&	O
DB_FILE_SETUP_ZERO	int
)	O
return	O
(	O
0	int
)	O
;	O
switch	O
(	O
dbp	pointer
->	O
type	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
ret	int
=	O
CDB___bam_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
DB_HASH	int
:	O
ret	int
=	O
CDB___ham_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
DB_RECNO	int
:	O
ret	int
=	O
CDB___ram_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
DB_QUEUE	int
:	O
ret	int
=	O
CDB___qam_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
meta_pgno	int
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
DB_UNKNOWN	int
:	O
return	O
(	O
CDB___db_unknown_type	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___db_dbopen"	pointer
,	O
dbp	pointer
->	O
type	enum
)	O
)	O
;	O
break	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_master_open	function
(	O
subdbp	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	enum
,	O
dbpp	pointer
)	O
DB	struct
*	O
subdbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
mode	enum
;	O
DB	struct
*	O
*	O
dbpp	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_db_create	function
(	O
&	O
dbp	pointer
,	O
subdbp	pointer
->	O
dbenv	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbp	pointer
->	O
type	enum
=	O
DB_BTREE	int
;	O
dbp	pointer
->	O
open_txn	pointer
=	O
subdbp	pointer
->	O
open_txn	pointer
;	O
dbp	pointer
->	O
pgsize	int
=	O
subdbp	pointer
->	O
pgsize	int
;	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_SUBDB	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_COMPRESS	int
)	O
)	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_CMPR	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_dbopen	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	enum
,	O
PGNO_BASE_MD	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DISCARD	int
)	O
)	O
dbp	pointer
->	O
close	pointer
(	O
dbp	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
*	O
dbpp	pointer
=	O
dbp	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_master_update	function
(	O
mdbp	pointer
,	O
subdb	pointer
,	O
type	enum
,	O
meta_pgnop	pointer
,	O
action	enum
,	O
newname	struct
,	O
flags	int
)	O
DB	struct
*	O
mdbp	pointer
;	O
const	O
char	O
*	O
subdb	pointer
;	O
u_int32_t	int
type	enum
;	O
db_pgno_t	int
*	O
meta_pgnop	pointer
;	O
mu_action	enum
action	enum
;	O
const	O
char	O
*	O
newname	struct
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DBC	struct
*	O
dbc	pointer
,	O
*	O
ndbc	pointer
;	O
DBT	struct
key	struct
,	O
data	pointer
,	O
ndata	struct
;	O
PAGE	struct
*	O
p	pointer
;	O
db_pgno_t	int
t_pgno	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbenv	pointer
=	O
mdbp	pointer
->	O
dbenv	pointer
;	O
dbc	pointer
=	O
ndbc	pointer
=	O
NULL	O
;	O
p	pointer
=	O
NULL	O
;	O
memset	function
(	O
&	O
key	struct
,	O
0	int
,	O
sizeof	O
(	O
key	struct
)	O
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
mdbp	pointer
->	O
cursor	pointer
(	O
mdbp	pointer
,	O
mdbp	pointer
->	O
open_txn	pointer
,	O
&	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
key	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
subdb	pointer
;	O
key	struct
.	O
size	int
=	O
strlen	function
(	O
subdb	pointer
)	O
;	O
F_SET	O
(	O
&	O
data	pointer
,	O
DB_DBT_MALLOC	int
)	O
;	O
ret	int
=	O
dbc	pointer
->	O
c_get	pointer
(	O
dbc	pointer
,	O
&	O
key	struct
,	O
&	O
data	pointer
,	O
DB_SET	int
|	O
(	O
STD_LOCKING	O
(	O
dbc	pointer
)	O
&&	O
(	O
action	enum
==	O
MU_RENAME	int
||	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
?	O
DB_RMW	int
:	O
0	int
)	O
)	O
;	O
switch	O
(	O
action	enum
)	O
{	O
case	O
MU_REMOVE	int
:	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_del	pointer
(	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memcpy	function
(	O
meta_pgnop	pointer
,	O
data	pointer
.	O
data	pointer
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
DB_NTOHL	O
(	O
meta_pgnop	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
mdbp	pointer
->	O
mpf	pointer
,	O
meta_pgnop	pointer
,	O
0	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_free	function
(	O
dbc	pointer
,	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
p	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
MU_RENAME	int
:	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
mdbp	pointer
->	O
cursor	pointer
(	O
mdbp	pointer
,	O
mdbp	pointer
->	O
open_txn	pointer
,	O
&	O
ndbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
DB_ASSERT	O
(	O
newname	struct
!=	O
NULL	O
)	O
;	O
key	struct
.	O
data	pointer
=	O
(	O
void	O
*	O
)	O
newname	struct
;	O
key	struct
.	O
size	int
=	O
strlen	function
(	O
newname	struct
)	O
;	O
memset	function
(	O
&	O
ndata	struct
,	O
0	int
,	O
sizeof	O
(	O
ndata	struct
)	O
)	O
;	O
F_SET	O
(	O
&	O
ndata	struct
,	O
DB_DBT_USERMEM	int
|	O
DB_DBT_PARTIAL	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
ndbc	pointer
->	O
c_get	pointer
(	O
ndbc	pointer
,	O
&	O
key	struct
,	O
&	O
ndata	struct
,	O
DB_SET	int
)	O
)	O
==	O
0	int
)	O
{	O
ret	int
=	O
EEXIST	int
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"rename: database %s exists"	pointer
,	O
newname	struct
)	O
;	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
ret	int
!=	O
DB_NOTFOUND	O
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
ndbc	pointer
->	O
c_put	pointer
(	O
ndbc	pointer
,	O
&	O
key	struct
,	O
&	O
data	pointer
,	O
DB_KEYFIRST	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_del	pointer
(	O
dbc	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
ndbc	pointer
->	O
c_del	pointer
(	O
ndbc	pointer
,	O
0	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
MU_OPEN	int
:	O
switch	O
(	O
ret	int
)	O
{	O
case	O
0	int
:	O
memcpy	function
(	O
meta_pgnop	pointer
,	O
data	pointer
.	O
data	pointer
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
DB_NTOHL	O
(	O
meta_pgnop	pointer
)	O
;	O
goto	O
done	O
;	O
case	O
DB_NOTFOUND	O
:	O
if	O
(	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
break	O
;	O
ret	int
=	O
ENOENT	int
;	O
goto	O
err	pointer
;	O
default	O
:	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_new	function
(	O
dbc	pointer
,	O
type	enum
==	O
DB_HASH	int
?	O
P_HASHMETA	int
:	O
P_BTREEMETA	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
*	O
meta_pgnop	pointer
=	O
PGNO	O
(	O
p	pointer
)	O
;	O
t_pgno	int
=	O
PGNO	O
(	O
p	pointer
)	O
;	O
DB_HTONL	O
(	O
&	O
t_pgno	int
)	O
;	O
memset	function
(	O
&	O
ndata	struct
,	O
0	int
,	O
sizeof	O
(	O
ndata	struct
)	O
)	O
;	O
ndata	struct
.	O
data	pointer
=	O
&	O
t_pgno	int
;	O
ndata	struct
.	O
size	int
=	O
sizeof	O
(	O
db_pgno_t	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbc	pointer
->	O
c_put	pointer
(	O
dbc	pointer
,	O
&	O
key	struct
,	O
&	O
ndata	struct
,	O
DB_KEYLAST	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
}	O
err	pointer
:	O
done	O
:	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
mdbp	pointer
->	O
mpf	pointer
,	O
p	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
mdbp	pointer
->	O
sync	pointer
(	O
mdbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
else	O
(	O
void	O
)	O
CDB___db_free	function
(	O
dbc	pointer
,	O
p	pointer
)	O
;	O
}	O
if	O
(	O
data	pointer
.	O
data	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
data	pointer
.	O
data	pointer
,	O
data	pointer
.	O
size	int
)	O
;	O
if	O
(	O
dbc	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
ndbc	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
ndbc	pointer
->	O
c_close	pointer
(	O
ndbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_dbenv_setup	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DBT	struct
pgcookie	pointer
;	O
DB_MPOOL_FINFO	struct
finfo	struct
;	O
DB_PGINFO	struct
pginfo	struct
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_OPEN_CALLED	int
)	O
)	O
{	O
if	O
(	O
dbenv	pointer
->	O
mp_gbytes	int
==	O
0	int
&&	O
dbenv	pointer
->	O
mp_bytes	int
<	O
dbp	pointer
->	O
pgsize	int
*	O
DB_MINPAGECACHE	int
&&	O
(	O
ret	int
=	O
dbenv	pointer
->	O
set_cachesize	pointer
(	O
dbenv	pointer
,	O
0	int
,	O
dbp	pointer
->	O
pgsize	int
*	O
DB_MINPAGECACHE	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbenv	pointer
->	O
open	pointer
(	O
dbenv	pointer
,	O
NULL	O
,	O
DB_CREATE	int
|	O
DB_INIT_MPOOL	int
|	O
DB_PRIVATE	int
|	O
LF_ISSET	O
(	O
DB_THREAD	int
)	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_register	function
(	O
dbenv	pointer
,	O
DB_FTYPE_SET	O
,	O
CDB___db_pgin	function
,	O
CDB___db_pgout	function
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memset	function
(	O
&	O
finfo	struct
,	O
0	int
,	O
sizeof	O
(	O
finfo	struct
)	O
)	O
;	O
switch	O
(	O
dbp	pointer
->	O
type	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
case	O
DB_RECNO	int
:	O
finfo	struct
.	O
ftype	int
=	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
?	O
DB_FTYPE_SET	O
:	O
DB_FTYPE_NOTSET	int
;	O
finfo	struct
.	O
clear_len	int
=	O
DB_PAGE_DB_LEN	int
;	O
break	O
;	O
case	O
DB_HASH	int
:	O
finfo	struct
.	O
ftype	int
=	O
DB_FTYPE_SET	O
;	O
finfo	struct
.	O
clear_len	int
=	O
DB_PAGE_DB_LEN	int
;	O
break	O
;	O
case	O
DB_QUEUE	int
:	O
finfo	struct
.	O
ftype	int
=	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
?	O
DB_FTYPE_SET	O
:	O
DB_FTYPE_NOTSET	int
;	O
finfo	struct
.	O
clear_len	int
=	O
DB_PAGE_QUEUE_LEN	int
;	O
break	O
;	O
case	O
DB_UNKNOWN	int
:	O
return	O
(	O
CDB___db_unknown_type	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"CDB___db_dbenv_setup"	pointer
,	O
dbp	pointer
->	O
type	enum
)	O
)	O
;	O
}	O
finfo	struct
.	O
pgcookie	pointer
=	O
&	O
pgcookie	pointer
;	O
finfo	struct
.	O
fileid	array
=	O
dbp	pointer
->	O
fileid	array
;	O
finfo	struct
.	O
lsn_offset	int
=	O
0	int
;	O
pginfo	struct
.	O
db_pagesize	long
=	O
dbp	pointer
->	O
pgsize	int
;	O
pginfo	struct
.	O
needswap	int
=	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
;	O
pgcookie	pointer
.	O
data	pointer
=	O
&	O
pginfo	struct
;	O
pgcookie	pointer
.	O
size	int
=	O
sizeof	O
(	O
DB_PGINFO	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fopen	function
(	O
dbenv	pointer
,	O
name	pointer
,	O
LF_ISSET	O
(	O
DB_RDONLY	int
|	O
DB_NOMMAP	int
|	O
DB_ODDFILESIZE	int
|	O
DB_TRUNCATE	int
|	O
DB_COMPRESS	int
)	O
,	O
0	int
,	O
dbp	pointer
->	O
pgsize	int
,	O
&	O
finfo	struct
,	O
&	O
dbp	pointer
->	O
mpf	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_THREAD	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_mutex_alloc	function
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
reginfo	pointer
,	O
(	O
MUTEX	struct
*	O
*	O
)	O
&	O
dbp	pointer
->	O
mutexp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_mutex_init	O
(	O
dbenv	pointer
,	O
dbp	pointer
->	O
mutexp	pointer
,	O
0	int
,	O
MUTEX_THREAD	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
&&	O
!	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
&&	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
&&	O
(	O
ret	int
=	O
CDB_log_register	function
(	O
dbenv	pointer
,	O
dbp	pointer
,	O
name	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_file_setup	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	enum
,	O
meta_pgno	int
,	O
retflags	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
mode	enum
;	O
db_pgno_t	int
meta_pgno	int
;	O
int	O
*	O
retflags	pointer
;	O
{	O
DB	struct
*	O
mdb	pointer
;	O
DBT	struct
namedbt	struct
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
,	O
fh	struct
;	O
DB_LSN	struct
lsn	struct
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
size_t	long
nr	long
;	O
u_int32_t	int
magic	int
,	O
oflags	int
;	O
int	O
ret	int
,	O
retry_cnt	int
,	O
t_ret	int
;	O
char	O
*	O
real_name	pointer
,	O
mbuf	array
[	O
DBMETASIZE	int
]	O
;	O
size_t	long
disk_pagesize	long
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
dbp	pointer
->	O
meta_pgno	int
=	O
meta_pgno	int
;	O
txn	pointer
=	O
NULL	O
;	O
*	O
retflags	pointer
=	O
0	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_FCNTL_LOCKING	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
*	O
fhp	pointer
)	O
,	O
NULL	O
,	O
&	O
fhp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
else	O
fhp	pointer
=	O
&	O
fh	struct
;	O
memset	function
(	O
fhp	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
fhp	pointer
)	O
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_INMEM	int
)	O
;	O
if	O
(	O
dbp	pointer
->	O
type	enum
==	O
DB_UNKNOWN	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"DBTYPE of unknown without existing file"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
real_name	pointer
=	O
NULL	O
;	O
if	O
(	O
dbp	pointer
->	O
pgsize	int
==	O
0	int
)	O
dbp	pointer
->	O
pgsize	int
=	O
DB_DEF_IOSIZE	O
;	O
if	O
(	O
LOCKING_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB_lock_id	function
(	O
dbenv	pointer
,	O
(	O
u_int32_t	int
*	O
)	O
dbp	pointer
->	O
fileid	array
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
name	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
real_name	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
mode	enum
==	O
0	int
)	O
mode	enum
=	O
CDB___db_omode	function
(	O
"rwrw--"	pointer
)	O
;	O
oflags	int
=	O
0	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_RDONLY	int
)	O
)	O
oflags	int
|=	O
DB_OSO_RDONLY	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_TRUNCATE	int
)	O
)	O
oflags	int
|=	O
DB_OSO_TRUNC	int
;	O
retry_cnt	int
=	O
0	int
;	O
open_retry	O
:	O
*	O
retflags	pointer
=	O
0	int
;	O
ret	int
=	O
0	int
;	O
if	O
(	O
!	O
IS_SUBDB_SETUP	O
&&	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
{	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_txn_begin	function
(	O
dbenv	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
,	O
&	O
txn	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err_msg	O
;	O
memset	function
(	O
&	O
namedbt	struct
,	O
0	int
,	O
sizeof	O
(	O
namedbt	struct
)	O
)	O
;	O
namedbt	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
namedbt	struct
.	O
size	int
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___crdel_fileopen_log	function
(	O
dbenv	pointer
,	O
txn	pointer
,	O
&	O
lsn	struct
,	O
DB_FLUSH	int
,	O
&	O
namedbt	struct
,	O
mode	enum
)	O
)	O
!=	O
0	int
)	O
goto	O
err_msg	O
;	O
}	O
DB_TEST_RECOVERY	O
(	O
dbp	pointer
,	O
DB_TEST_PREOPEN	O
,	O
ret	int
,	O
name	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_open	function
(	O
dbenv	pointer
,	O
real_name	pointer
,	O
oflags	int
|	O
DB_OSO_CREATE	int
|	O
DB_OSO_EXCL	int
,	O
mode	enum
,	O
fhp	pointer
)	O
)	O
==	O
0	int
)	O
{	O
DB_TEST_RECOVERY	O
(	O
dbp	pointer
,	O
DB_TEST_POSTOPEN	O
,	O
ret	int
,	O
name	pointer
)	O
;	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_txn_commit	function
(	O
txn	pointer
,	O
DB_TXN_SYNC	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err_msg	O
;	O
txn	pointer
=	O
NULL	O
;	O
}	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_DISCARD	int
)	O
;	O
*	O
retflags	pointer
|=	O
DB_FILE_SETUP_CREATE	int
;	O
}	O
else	O
{	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_txn_abort	function
(	O
txn	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
ret	int
=	O
t_ret	int
;	O
goto	O
err_msg	O
;	O
}	O
txn	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
ret	int
==	O
EEXIST	int
&&	O
!	O
LF_ISSET	O
(	O
DB_EXCL	int
)	O
)	O
{	O
LF_CLR	O
(	O
DB_CREATE	int
)	O
;	O
DB_TEST_RECOVERY	O
(	O
dbp	pointer
,	O
DB_TEST_POSTOPEN	O
,	O
ret	int
,	O
name	pointer
)	O
;	O
goto	O
open_retry	O
;	O
}	O
}	O
}	O
else	O
ret	int
=	O
CDB___os_open	function
(	O
dbenv	pointer
,	O
real_name	pointer
,	O
oflags	int
,	O
mode	enum
,	O
fhp	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
if	O
(	O
ret	int
==	O
EACCES	int
||	O
ret	int
==	O
ENOENT	int
)	O
goto	O
err	pointer
;	O
goto	O
err_msg	O
;	O
}	O
if	O
(	O
dbp	pointer
->	O
pgsize	int
==	O
0	int
)	O
{	O
if	O
(	O
IS_SUBDB_SETUP	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_master_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
flags	int
,	O
mode	enum
,	O
&	O
mdb	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
dbp	pointer
->	O
pgsize	int
=	O
mdb	pointer
->	O
pgsize	int
;	O
(	O
void	O
)	O
mdb	pointer
->	O
close	pointer
(	O
mdb	pointer
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
__db_set_pgsize	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
real_name	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
disk_pagesize	long
=	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_CMPR	int
)	O
?	O
DB_CMPR_DIVIDE	O
(	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
:	O
dbp	pointer
->	O
pgsize	int
;	O
if	O
(	O
meta_pgno	int
==	O
PGNO_BASE_MD	int
||	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_CMPR	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
disk_pagesize	long
,	O
meta_pgno	int
,	O
0	int
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err_msg	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
mbuf	array
,	O
sizeof	O
(	O
mbuf	array
)	O
,	O
&	O
nr	long
)	O
)	O
!=	O
0	int
)	O
goto	O
err_msg	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
disk_pagesize	long
,	O
meta_pgno	int
,	O
0	int
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err_msg	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_cmpr_read_meta	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
mbuf	array
,	O
sizeof	O
(	O
mbuf	array
)	O
,	O
(	O
ssize_t	long
*	O
)	O
&	O
nr	long
)	O
)	O
!=	O
0	int
)	O
goto	O
err_msg	O
;	O
}	O
if	O
(	O
nr	long
==	O
sizeof	O
(	O
mbuf	array
)	O
)	O
{	O
F_CLR	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
;	O
magic	int
=	O
(	O
(	O
DBMETA	struct
*	O
)	O
mbuf	array
)	O
->	O
magic	int
;	O
swap_retry	O
:	O
switch	O
(	O
magic	int
)	O
{	O
case	O
DB_BTREEMAGIC	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_metachk	function
(	O
dbp	pointer
,	O
name	pointer
,	O
(	O
BTMETA	struct
*	O
)	O
mbuf	array
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_HASHMAGIC	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_metachk	function
(	O
dbp	pointer
,	O
name	pointer
,	O
(	O
HMETA	struct
*	O
)	O
mbuf	array
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_QAMMAGIC	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___qam_metachk	function
(	O
dbp	pointer
,	O
name	pointer
,	O
(	O
QMETA	struct
*	O
)	O
mbuf	array
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
IS_SUBDB_SETUP	O
)	O
{	O
if	O
(	O
(	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
&&	O
F_ISSET	O
(	O
(	O
DB_LOG	struct
*	O
)	O
dbenv	pointer
->	O
lg_handle	pointer
,	O
DBLOG_FORCE_OPEN	int
)	O
)	O
||	O
(	O
(	O
DBMETA	struct
*	O
)	O
mbuf	array
)	O
->	O
pgno	int
!=	O
PGNO_INVALID	int
)	O
goto	O
empty	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
)	O
{	O
*	O
retflags	pointer
|=	O
DB_FILE_SETUP_ZERO	int
;	O
goto	O
empty	O
;	O
}	O
goto	O
bad_format	O
;	O
default	O
:	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
)	O
goto	O
bad_format	O
;	O
M_32_SWAP	O
(	O
magic	int
)	O
;	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
;	O
goto	O
swap_retry	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
nr	long
!=	O
0	int
||	O
(	O
!	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
&&	O
IS_SUBDB_SETUP	O
)	O
)	O
goto	O
bad_format	O
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_CREATE	int
|	O
DB_TRUNCATE	int
)	O
)	O
*	O
retflags	pointer
=	O
DB_FILE_SETUP_ZERO	int
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_CREATE	int
|	O
DB_TRUNCATE	int
)	O
&&	O
!	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
)	O
{	O
if	O
(	O
retry_cnt	int
++	O
<	O
3	int
)	O
{	O
CDB___os_sleep	function
(	O
dbenv	pointer
,	O
1	int
,	O
0	int
)	O
;	O
goto	O
open_retry	O
;	O
}	O
bad_format	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: unexpected file type or format"	pointer
,	O
name	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
DB_ASSERT	O
(	O
dbp	pointer
->	O
type	enum
!=	O
DB_UNKNOWN	int
)	O
;	O
empty	O
:	O
if	O
(	O
!	O
IS_SUBDB_SETUP	O
)	O
{	O
if	O
(	O
*	O
retflags	pointer
&	O
DB_FILE_SETUP_ZERO	int
)	O
memset	function
(	O
dbp	pointer
->	O
fileid	array
,	O
0	int
,	O
DB_FILE_ID_LEN	int
)	O
;	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_fileid	function
(	O
dbenv	pointer
,	O
real_name	pointer
,	O
1	int
,	O
dbp	pointer
->	O
fileid	array
)	O
)	O
!=	O
0	int
)	O
goto	O
err_msg	O
;	O
CDB___memp_cmpr_create	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
disk_pagesize	long
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_CMPR	int
)	O
?	O
MP_CMPR	int
:	O
0	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
0	int
)	O
{	O
err_msg	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
name	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
}	O
err	pointer
:	O
if	O
(	O
txn	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB_txn_abort	function
(	O
txn	pointer
)	O
;	O
DB_TEST_RECOVERY_LABEL	O
if	O
(	O
F_ISSET	O
(	O
fhp	pointer
,	O
DB_FH_VALID	int
)	O
)	O
{	O
if	O
(	O
ret	int
==	O
0	int
&&	O
LF_ISSET	O
(	O
DB_FCNTL_LOCKING	int
)	O
)	O
dbp	pointer
->	O
saved_open_fhp	pointer
=	O
fhp	pointer
;	O
else	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___os_closehandle	function
(	O
fhp	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
real_name	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
real_name	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_set_pgsize	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
name	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
char	O
*	O
name	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
u_int32_t	int
iopsize	int
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_ioinfo	function
(	O
dbenv	pointer
,	O
name	pointer
,	O
fhp	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
iopsize	int
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
name	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
iopsize	int
<	O
512	int
)	O
iopsize	int
=	O
512	int
;	O
if	O
(	O
iopsize	int
>	O
16	int
*	O
1024	int
)	O
iopsize	int
=	O
16	int
*	O
1024	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_CMPR	int
)	O
)	O
{	O
if	O
(	O
iopsize	int
<	O
(	O
u_int32_t	int
)	O
DB_CMPR_MULTIPLY	O
(	O
dbenv	pointer
,	O
DB_MIN_PGSIZE	int
)	O
)	O
iopsize	int
=	O
DB_CMPR_MULTIPLY	O
(	O
dbenv	pointer
,	O
DB_MIN_PGSIZE	int
)	O
;	O
}	O
OS_ROUNDOFF	O
(	O
iopsize	int
,	O
512	int
)	O
;	O
dbp	pointer
->	O
pgsize	int
=	O
iopsize	int
;	O
F_SET	O
(	O
dbp	pointer
,	O
DB_AM_PGDEF	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___db_close	function
(	O
dbp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
ret	int
=	O
0	int
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_closechk	function
(	O
dbp	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_OPEN_CALLED	int
)	O
)	O
goto	O
never_opened	O
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_NOSYNC	int
)	O
&&	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DISCARD	int
)	O
&&	O
(	O
t_ret	int
=	O
dbp	pointer
->	O
sync	pointer
(	O
dbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
while	O
(	O
(	O
dbc	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
while	O
(	O
(	O
dbc	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
free_queue	struct
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_c_destroy	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
while	O
(	O
(	O
dbc	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
join_queue	struct
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
!	O
LF_ISSET	O
(	O
DB_NOSYNC	int
)	O
&&	O
!	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DISCARD	int
)	O
&&	O
(	O
t_ret	int
=	O
CDB_memp_fsync	function
(	O
dbp	pointer
->	O
mpf	pointer
)	O
)	O
!=	O
0	int
&&	O
t_ret	int
!=	O
DB_INCOMPLETE	O
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
dbp	pointer
->	O
saved_open_fhp	pointer
!=	O
NULL	O
&&	O
F_ISSET	O
(	O
dbp	pointer
->	O
saved_open_fhp	pointer
,	O
DB_FH_VALID	int
)	O
&&	O
(	O
t_ret	int
=	O
CDB___os_closehandle	function
(	O
dbp	pointer
->	O
saved_open_fhp	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
never_opened	O
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___ham_db_close	function
(	O
dbp	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___bam_db_close	function
(	O
dbp	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___qam_db_close	function
(	O
dbp	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
(	O
t_ret	int
=	O
__db_refresh	function
(	O
dbp	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_DBLOCAL	int
)	O
&&	O
--	O
dbenv	pointer
->	O
dblocal_ref	int
==	O
0	int
&&	O
(	O
t_ret	int
=	O
dbenv	pointer
->	O
close	pointer
(	O
dbenv	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
memset	function
(	O
dbp	pointer
,	O
CLEAR_BYTE	int
,	O
sizeof	O
(	O
*	O
dbp	pointer
)	O
)	O
;	O
CDB___os_free	function
(	O
dbp	pointer
,	O
sizeof	O
(	O
*	O
dbp	pointer
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_refresh	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
ret	int
=	O
0	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
while	O
(	O
(	O
dbc	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
while	O
(	O
(	O
dbc	pointer
=	O
TAILQ_FIRST	O
(	O
&	O
dbp	pointer
->	O
free_queue	struct
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_c_destroy	function
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
dbp	pointer
->	O
type	enum
=	O
0	int
;	O
if	O
(	O
dbp	pointer
->	O
mpf	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_DISCARD	int
)	O
)	O
(	O
void	O
)	O
CDB___memp_fremove	function
(	O
dbp	pointer
->	O
mpf	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fclose	function
(	O
dbp	pointer
->	O
mpf	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
dbp	pointer
->	O
mpf	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
dbp	pointer
->	O
mutexp	pointer
!=	O
NULL	O
)	O
{	O
CDB___db_mutex_free	function
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
reginfo	pointer
,	O
dbp	pointer
->	O
mutexp	pointer
)	O
;	O
dbp	pointer
->	O
mutexp	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
IS_RECOVERING	O
(	O
dbenv	pointer
)	O
&&	O
dbp	pointer
->	O
log_fileid	int
!=	O
DB_LOGFILEID_INVALID	O
)	O
(	O
void	O
)	O
CDB_log_unregister	function
(	O
dbenv	pointer
,	O
dbp	pointer
)	O
;	O
TAILQ_INIT	O
(	O
&	O
dbp	pointer
->	O
free_queue	struct
)	O
;	O
TAILQ_INIT	O
(	O
&	O
dbp	pointer
->	O
active_queue	struct
)	O
;	O
TAILQ_INIT	O
(	O
&	O
dbp	pointer
->	O
join_queue	struct
)	O
;	O
F_CLR	O
(	O
dbp	pointer
,	O
DB_AM_DISCARD	int
)	O
;	O
F_CLR	O
(	O
dbp	pointer
,	O
DB_AM_INMEM	int
)	O
;	O
F_CLR	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
;	O
F_CLR	O
(	O
dbp	pointer
,	O
DB_AM_SWAP	int
)	O
;	O
F_CLR	O
(	O
dbp	pointer
,	O
DB_DBM_ERROR	int
)	O
;	O
F_CLR	O
(	O
dbp	pointer
,	O
DB_OPEN_CALLED	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_remove	function
(	O
dbp	pointer
,	O
name	pointer
,	O
subdb	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
,	O
*	O
subdb	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DBT	struct
namedbt	struct
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK	struct
remove_lock	struct
;	O
DB_LSN	struct
newlsn	struct
;	O
int	O
ret	int
,	O
t_ret	int
;	O
char	O
*	O
backup	pointer
,	O
*	O
real_back	pointer
,	O
*	O
real_name	pointer
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
ret	int
=	O
0	int
;	O
backup	pointer
=	O
real_back	pointer
=	O
real_name	pointer
=	O
NULL	O
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
DB_ILLEGAL_AFTER_OPEN	O
(	O
dbp	pointer
,	O
"remove"	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_removechk	function
(	O
dbp	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
subdb	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"multiple databases cannot be created in temporary files"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
return	O
(	O
__db_subdb_remove	function
(	O
dbp	pointer
,	O
name	pointer
,	O
subdb	pointer
)	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
open	pointer
(	O
dbp	pointer
,	O
name	pointer
,	O
NULL	O
,	O
DB_UNKNOWN	int
,	O
DB_RDWRMASTER	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB___log_file_lock	function
(	O
dbp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
sync	pointer
(	O
dbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
(	O
void	O
)	O
CDB___memp_fremove	function
(	O
dbp	pointer
->	O
mpf	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fclose	function
(	O
dbp	pointer
->	O
mpf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
dbp	pointer
->	O
mpf	pointer
=	O
NULL	O
;	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
__db_metabegin	function
(	O
dbp	pointer
,	O
&	O
remove_lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
memset	function
(	O
&	O
namedbt	struct
,	O
0	int
,	O
sizeof	O
(	O
namedbt	struct
)	O
)	O
;	O
namedbt	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
namedbt	struct
.	O
size	int
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___crdel_delete_log	function
(	O
dbenv	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
,	O
&	O
newlsn	struct
,	O
DB_FLUSH	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
namedbt	struct
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
name	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
name	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
real_name	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_backup_name	function
(	O
dbenv	pointer
,	O
name	pointer
,	O
&	O
backup	pointer
,	O
&	O
newlsn	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
backup	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
real_back	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
DB_TEST_RECOVERY	O
(	O
dbp	pointer
,	O
DB_TEST_PRERENAME	O
,	O
ret	int
,	O
name	pointer
)	O
;	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
)	O
ret	int
=	O
CDB___os_rename	function
(	O
dbenv	pointer
,	O
real_name	pointer
,	O
real_back	pointer
)	O
;	O
else	O
ret	int
=	O
CDB___os_unlink	function
(	O
dbenv	pointer
,	O
real_name	pointer
)	O
;	O
DB_TEST_RECOVERY	O
(	O
dbp	pointer
,	O
DB_TEST_POSTRENAME	O
,	O
ret	int
,	O
name	pointer
)	O
;	O
err	pointer
:	O
DB_TEST_RECOVERY_LABEL	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
__db_metaend	function
(	O
dbp	pointer
,	O
&	O
remove_lock	struct
,	O
ret	int
==	O
0	int
,	O
__db_remove_callback	function
,	O
real_back	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
err_close	O
:	O
if	O
(	O
real_name	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
real_name	pointer
)	O
;	O
if	O
(	O
backup	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
backup	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
dbp	pointer
->	O
close	pointer
(	O
dbp	pointer
,	O
DB_NOSYNC	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_subdb_remove	function
(	O
dbp	pointer
,	O
name	pointer
,	O
subdb	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
,	O
*	O
subdb	pointer
;	O
{	O
DB	struct
*	O
mdbp	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK	struct
remove_lock	struct
;	O
db_pgno_t	int
meta_pgno	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
mdbp	pointer
=	O
NULL	O
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
__db_metabegin	function
(	O
dbp	pointer
,	O
&	O
remove_lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
subdb	pointer
,	O
DB_UNKNOWN	int
,	O
(	O
(	O
dbenv	pointer
->	O
flags	int
&	O
DB_ENV_CMPR	int
)	O
?	O
DB_COMPRESS	int
:	O
0	int
)	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
switch	O
(	O
dbp	pointer
->	O
type	enum
)	O
{	O
case	O
DB_BTREE	int
:	O
case	O
DB_RECNO	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_reclaim	function
(	O
dbp	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
case	O
DB_HASH	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___ham_reclaim	function
(	O
dbp	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_unknown_type	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__db_subdb_remove"	pointer
,	O
dbp	pointer
->	O
type	enum
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_master_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
(	O
(	O
dbenv	pointer
->	O
flags	int
&	O
DB_ENV_CMPR	int
)	O
?	O
DB_COMPRESS	int
:	O
0	int
)	O
,	O
0	int
,	O
&	O
mdbp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__db_master_update	function
(	O
mdbp	pointer
,	O
subdb	pointer
,	O
dbp	pointer
->	O
type	enum
,	O
&	O
meta_pgno	int
,	O
MU_REMOVE	int
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
err	pointer
:	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
__db_metaend	function
(	O
dbp	pointer
,	O
&	O
remove_lock	struct
,	O
ret	int
==	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
dbp	pointer
->	O
close	pointer
(	O
dbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
mdbp	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
mdbp	pointer
->	O
close	pointer
(	O
mdbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_rename	function
(	O
dbp	pointer
,	O
filename	pointer
,	O
subdb	pointer
,	O
newname	struct
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
filename	pointer
,	O
*	O
subdb	pointer
,	O
*	O
newname	struct
;	O
u_int32_t	int
flags	int
;	O
{	O
DBT	struct
namedbt	struct
,	O
newnamedbt	struct
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK	struct
remove_lock	struct
;	O
DB_LSN	struct
newlsn	struct
;	O
char	O
*	O
real_name	pointer
,	O
*	O
real_newname	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
ret	int
=	O
0	int
;	O
real_name	pointer
=	O
real_newname	pointer
=	O
NULL	O
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
DB_ILLEGAL_AFTER_OPEN	O
(	O
dbp	pointer
,	O
"rename"	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_removechk	function
(	O
dbp	pointer
,	O
flags	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
subdb	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"multiple databases cannot be created in temporary files"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
return	O
(	O
__db_subdb_rename	function
(	O
dbp	pointer
,	O
filename	pointer
,	O
subdb	pointer
,	O
newname	struct
)	O
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
open	pointer
(	O
dbp	pointer
,	O
filename	pointer
,	O
NULL	O
,	O
DB_UNKNOWN	int
,	O
DB_RDWRMASTER	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB___log_file_lock	function
(	O
dbp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
sync	pointer
(	O
dbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_fremove	function
(	O
dbp	pointer
->	O
mpf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fclose	function
(	O
dbp	pointer
->	O
mpf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
dbp	pointer
->	O
mpf	pointer
=	O
NULL	O
;	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
__db_metabegin	function
(	O
dbp	pointer
,	O
&	O
remove_lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err_close	O
;	O
if	O
(	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
memset	function
(	O
&	O
namedbt	struct
,	O
0	int
,	O
sizeof	O
(	O
namedbt	struct
)	O
)	O
;	O
namedbt	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
filename	pointer
;	O
namedbt	struct
.	O
size	int
=	O
strlen	function
(	O
filename	pointer
)	O
+	O
1	int
;	O
memset	function
(	O
&	O
newnamedbt	struct
,	O
0	int
,	O
sizeof	O
(	O
namedbt	struct
)	O
)	O
;	O
newnamedbt	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
newname	struct
;	O
newnamedbt	struct
.	O
size	int
=	O
strlen	function
(	O
newname	struct
)	O
+	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___crdel_rename_log	function
(	O
dbenv	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
,	O
&	O
newlsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
namedbt	struct
,	O
&	O
newnamedbt	struct
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
filename	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_filelist_update	function
(	O
dbenv	pointer
,	O
dbp	pointer
,	O
dbp	pointer
->	O
log_fileid	int
,	O
newname	struct
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
filename	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
real_name	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
newname	struct
,	O
0	int
,	O
NULL	O
,	O
&	O
real_newname	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
CDB___os_exists	function
(	O
real_newname	pointer
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
ret	int
=	O
EEXIST	int
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"rename: file %s exists"	pointer
,	O
real_newname	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
DB_TEST_RECOVERY	O
(	O
dbp	pointer
,	O
DB_TEST_PRERENAME	O
,	O
ret	int
,	O
filename	pointer
)	O
;	O
ret	int
=	O
CDB___os_rename	function
(	O
dbenv	pointer
,	O
real_name	pointer
,	O
real_newname	pointer
)	O
;	O
DB_TEST_RECOVERY	O
(	O
dbp	pointer
,	O
DB_TEST_POSTRENAME	O
,	O
ret	int
,	O
newname	struct
)	O
;	O
DB_TEST_RECOVERY_LABEL	O
err	pointer
:	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
__db_metaend	function
(	O
dbp	pointer
,	O
&	O
remove_lock	struct
,	O
ret	int
==	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
err_close	O
:	O
dbp	pointer
->	O
close	pointer
(	O
dbp	pointer
,	O
DB_NOSYNC	int
)	O
;	O
if	O
(	O
real_name	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
real_name	pointer
)	O
;	O
if	O
(	O
real_newname	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
real_newname	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_subdb_rename	function
(	O
dbp	pointer
,	O
name	pointer
,	O
subdb	pointer
,	O
newname	struct
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
,	O
*	O
subdb	pointer
,	O
*	O
newname	struct
;	O
{	O
DB	struct
*	O
mdbp	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOCK	struct
remove_lock	struct
;	O
int	O
ret	int
,	O
t_ret	int
;	O
mdbp	pointer
=	O
NULL	O
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
TXN_ON	O
(	O
dbenv	pointer
)	O
&&	O
(	O
ret	int
=	O
__db_metabegin	function
(	O
dbp	pointer
,	O
&	O
remove_lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
subdb	pointer
,	O
DB_UNKNOWN	int
,	O
0	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_master_open	function
(	O
dbp	pointer
,	O
name	pointer
,	O
0	int
,	O
0	int
,	O
&	O
mdbp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__db_master_update	function
(	O
mdbp	pointer
,	O
subdb	pointer
,	O
dbp	pointer
->	O
type	enum
,	O
NULL	O
,	O
MU_RENAME	int
,	O
newname	struct
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
err	pointer
:	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
__db_metaend	function
(	O
dbp	pointer
,	O
&	O
remove_lock	struct
,	O
ret	int
==	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
dbp	pointer
->	O
close	pointer
(	O
dbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
mdbp	pointer
!=	O
NULL	O
&&	O
(	O
t_ret	int
=	O
mdbp	pointer
->	O
close	pointer
(	O
mdbp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_metabegin	function
(	O
dbp	pointer
,	O
lockp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
*	O
lockp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DBT	struct
dbplock	struct
;	O
u_int32_t	int
locker	int
,	O
lockval	int
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
lockp	pointer
->	O
off	long
=	O
LOCK_INVALID	O
;	O
if	O
(	O
LOCKING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_lock_id	function
(	O
dbenv	pointer
,	O
&	O
locker	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
lockval	int
=	O
0	int
;	O
dbplock	struct
.	O
data	pointer
=	O
&	O
lockval	int
;	O
dbplock	struct
.	O
size	int
=	O
sizeof	O
(	O
lockval	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_lock_get	function
(	O
dbenv	pointer
,	O
locker	int
,	O
0	int
,	O
&	O
dbplock	struct
,	O
DB_LOCK_WRITE	int
,	O
lockp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
}	O
return	O
(	O
CDB_txn_begin	function
(	O
dbenv	pointer
,	O
NULL	O
,	O
&	O
dbp	pointer
->	O
open_txn	pointer
,	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
__db_metaend	function
(	O
dbp	pointer
,	O
lockp	pointer
,	O
commit	int
,	O
callback	pointer
,	O
cookie	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
*	O
lockp	pointer
;	O
int	O
commit	int
,	O
(	O
*	O
callback	pointer
)	O
__P	O
(	O
(	O
DB	struct
*	O
,	O
void	O
*	O
)	O
)	O
;	O
void	O
*	O
cookie	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
ret	int
=	O
0	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
if	O
(	O
commit	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB_txn_commit	function
(	O
dbp	pointer
->	O
open_txn	pointer
,	O
DB_TXN_SYNC	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
callback	pointer
!=	O
NULL	O
)	O
ret	int
=	O
callback	pointer
(	O
dbp	pointer
,	O
cookie	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_txn_abort	function
(	O
dbp	pointer
->	O
open_txn	pointer
)	O
)	O
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
lockp	pointer
->	O
off	long
!=	O
LOCK_INVALID	O
&&	O
(	O
t_ret	int
=	O
CDB_lock_put	function
(	O
dbenv	pointer
,	O
lockp	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_log_page	function
(	O
dbp	pointer
,	O
name	pointer
,	O
lsn	struct
,	O
pgno	int
,	O
page	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
DB_LSN	struct
*	O
lsn	struct
;	O
db_pgno_t	int
pgno	int
;	O
PAGE	struct
*	O
page	pointer
;	O
{	O
DBT	struct
name_dbt	struct
,	O
page_dbt	struct
;	O
DB_LSN	struct
new_lsn	struct
;	O
int	O
ret	int
;	O
if	O
(	O
dbp	pointer
->	O
open_txn	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
memset	function
(	O
&	O
page_dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
page_dbt	struct
)	O
)	O
;	O
page_dbt	struct
.	O
size	int
=	O
dbp	pointer
->	O
pgsize	int
;	O
page_dbt	struct
.	O
data	pointer
=	O
page	pointer
;	O
if	O
(	O
pgno	int
==	O
PGNO_BASE_MD	int
)	O
{	O
memset	function
(	O
&	O
name_dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
name_dbt	struct
)	O
)	O
;	O
name_dbt	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
*	O
name	pointer
==	O
'\0'	O
)	O
name_dbt	struct
.	O
size	int
=	O
0	int
;	O
else	O
name_dbt	struct
.	O
size	int
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
ret	int
=	O
CDB___crdel_metapage_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
,	O
&	O
new_lsn	struct
,	O
DB_FLUSH	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
name_dbt	struct
,	O
pgno	int
,	O
&	O
page_dbt	struct
)	O
;	O
}	O
else	O
ret	int
=	O
CDB___crdel_metasub_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
open_txn	pointer
,	O
&	O
new_lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
pgno	int
,	O
&	O
page_dbt	struct
,	O
lsn	struct
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
page	pointer
->	O
lsn	struct
=	O
new_lsn	struct
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___db_backup_name	function
(	O
dbenv	pointer
,	O
name	pointer
,	O
backup	pointer
,	O
lsn	struct
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
char	O
*	O
*	O
backup	pointer
;	O
DB_LSN	struct
*	O
lsn	struct
;	O
{	O
size_t	long
len	short
;	O
int	O
plen	int
,	O
ret	int
;	O
char	O
*	O
p	pointer
,	O
*	O
retp	pointer
;	O
len	short
=	O
strlen	function
(	O
name	pointer
)	O
+	O
strlen	function
(	O
BACKUP_PREFIX	pointer
)	O
+	O
MAX_LSN_TO_TEXT	int
+	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
len	short
,	O
NULL	O
,	O
&	O
retp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
p	pointer
=	O
CDB___db_rpath	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
snprintf	function
(	O
retp	pointer
,	O
len	short
,	O
"%s%s.0x%x0x%x"	pointer
,	O
BACKUP_PREFIX	pointer
,	O
name	pointer
,	O
lsn	struct
->	O
file	int
,	O
lsn	struct
->	O
offset	int
)	O
;	O
else	O
{	O
plen	int
=	O
p	pointer
-	O
name	pointer
+	O
1	int
;	O
p	pointer
++	O
;	O
snprintf	function
(	O
retp	pointer
,	O
len	short
,	O
"%.*s%s%s.0x%x0x%x"	pointer
,	O
plen	int
,	O
name	pointer
,	O
BACKUP_PREFIX	pointer
,	O
p	pointer
,	O
lsn	struct
->	O
file	int
,	O
lsn	struct
->	O
offset	int
)	O
;	O
}	O
*	O
backup	pointer
=	O
retp	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_remove_callback	function
(	O
dbp	pointer
,	O
cookie	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
void	O
*	O
cookie	pointer
;	O
{	O
return	O
(	O
CDB___os_unlink	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cookie	pointer
)	O
)	O
;	O
}	O
