static	O
const	O
char	O
*	O
grammar	array
[	O
]	O
[	O
2	int
]	O
=	O
{	O
{	O
"S=s"	pointer
,	O
""	pointer
}	O
,	O
{	O
"s=TDe"	pointer
,	O
"reduce_declaration"	pointer
}	O
,	O
{	O
"s=sTDe"	pointer
,	O
"reduce_declaration"	pointer
}	O
,	O
{	O
"T=tT"	pointer
,	O
""	pointer
}	O
,	O
{	O
"T=t"	pointer
,	O
""	pointer
}	O
,	O
{	O
"t=1"	pointer
,	O
"reduce_typedef"	pointer
}	O
,	O
{	O
"t=2"	pointer
,	O
""	pointer
}	O
,	O
{	O
"t=3iB"	pointer
,	O
""	pointer
}	O
,	O
{	O
"t=4"	pointer
,	O
""	pointer
}	O
,	O
{	O
"B=xa}"	pointer
,	O
""	pointer
}	O
,	O
{	O
"B="	pointer
,	O
""	pointer
}	O
,	O
{	O
"x={"	pointer
,	O
"reduce_struct_definition"	pointer
}	O
,	O
{	O
"D=d,D"	pointer
,	O
"reduce_declarator"	pointer
}	O
,	O
{	O
"D=d"	pointer
,	O
"reduce_declarator"	pointer
}	O
,	O
{	O
"d=*Qd"	pointer
,	O
"reduce_pointer"	pointer
}	O
,	O
{	O
"d=E"	pointer
,	O
""	pointer
}	O
,	O
{	O
"Q=Q4"	pointer
,	O
""	pointer
}	O
,	O
{	O
"Q="	pointer
,	O
""	pointer
}	O
,	O
{	O
"E=I"	pointer
,	O
""	pointer
}	O
,	O
{	O
"E=(d)"	pointer
,	O
""	pointer
}	O
,	O
{	O
"E=E[a]"	pointer
,	O
"reduce_array"	pointer
}	O
,	O
{	O
"E=E(a)"	pointer
,	O
"reduce_function"	pointer
}	O
,	O
{	O
"I=i"	pointer
,	O
"reduce_identifier"	pointer
}	O
,	O
{	O
"a="	pointer
,	O
""	pointer
}	O
,	O
{	O
"a=ab"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=(a)"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b={a}"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=[a]"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=i"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=o"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=1"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=2"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=3"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=4"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=,"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=*"	pointer
,	O
""	pointer
}	O
,	O
{	O
"b=;"	pointer
,	O
""	pointer
}	O
,	O
{	O
"e=;"	pointer
,	O
""	pointer
}	O
,	O
{	O
"e=ya}"	pointer
,	O
""	pointer
}	O
,	O
{	O
"y={"	pointer
,	O
"reduce_function_definition"	pointer
}	O
,	O
}	O
;	O
static	O
struct	O
production	struct
{	O
int	O
left	int
;	O
int	O
n_right	int
;	O
int	O
*	O
right	pointer
;	O
const	O
char	O
*	O
ascii	pointer
;	O
const	O
char	O
*	O
reduction	pointer
;	O
}	O
G	array
[	O
n_grammar	O
]	O
;	O
static	O
struct	O
{	O
int	O
token	int
;	O
char	O
*	O
name	pointer
;	O
}	O
tokens	array
[	O
]	O
=	O
{	O
{	O
'i'	O
,	O
"lex_identifier"	pointer
}	O
,	O
{	O
'1'	O
,	O
"lex_typedef"	pointer
}	O
,	O
{	O
'2'	O
,	O
"lex_type_name"	pointer
}	O
,	O
{	O
'3'	O
,	O
"lex_struct"	pointer
}	O
,	O
{	O
'4'	O
,	O
"lex_const"	pointer
}	O
,	O
{	O
'('	O
,	O
"lex_lparen"	pointer
}	O
,	O
{	O
')'	O
,	O
"lex_rparen"	pointer
}	O
,	O
{	O
'['	O
,	O
"lex_lbrack"	pointer
}	O
,	O
{	O
']'	O
,	O
"lex_rbrack"	pointer
}	O
,	O
{	O
'{'	O
,	O
"lex_lbrace"	pointer
}	O
,	O
{	O
'}'	O
,	O
"lex_rbrace"	pointer
}	O
,	O
{	O
','	O
,	O
"lex_comma"	pointer
}	O
,	O
{	O
'*'	O
,	O
"lex_pointer"	pointer
}	O
,	O
{	O
';'	O
,	O
"lex_semicolon"	pointer
}	O
,	O
{	O
'o'	O
,	O
"lex_other"	pointer
}	O
,	O
{	O
'$'	O
,	O
"lex_stop"	pointer
}	O
,	O
}	O
;	O
static	O
int	O
debug	int
=	O
0	int
;	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
amt	long
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
amt	long
==	O
0	int
)	O
return	O
NULL	O
;	O
p	pointer
=	O
malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"virtual memory exhausted\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
vp	pointer
;	O
if	O
(	O
!	O
size	long
)	O
{	O
if	O
(	O
ptr	pointer
)	O
free	function
(	O
ptr	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ptr	pointer
)	O
vp	pointer
=	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
;	O
else	O
vp	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
!	O
vp	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"virtual memory exhausted\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
vp	pointer
;	O
}	O
struct	O
set	struct
{	O
int	O
n	int
;	O
int	O
*	O
which	pointer
;	O
}	O
;	O
static	O
void	O
set_init	function
(	O
struct	O
set	struct
*	O
set	struct
)	O
{	O
set	struct
->	O
n	int
=	O
0	int
;	O
set	struct
->	O
which	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
set_free	function
(	O
struct	O
set	struct
*	O
set	struct
)	O
{	O
free	function
(	O
set	struct
->	O
which	pointer
)	O
;	O
}	O
static	O
int	O
set_contains	function
(	O
const	O
struct	O
set	struct
*	O
set	struct
,	O
int	O
c	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
set	struct
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
set	struct
->	O
which	pointer
[	O
i	int
]	O
==	O
c	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
set_add	function
(	O
struct	O
set	struct
*	O
set	struct
,	O
int	O
c	int
)	O
{	O
if	O
(	O
set_contains	function
(	O
set	struct
,	O
c	int
)	O
)	O
return	O
0	int
;	O
set	struct
->	O
which	pointer
=	O
xrealloc	function
(	O
set	struct
->	O
which	pointer
,	O
sizeof	O
*	O
set	struct
->	O
which	pointer
*	O
(	O
set	struct
->	O
n	int
+	O
1	int
)	O
)	O
;	O
set	struct
->	O
which	pointer
[	O
set	struct
->	O
n	int
++	O
]	O
=	O
c	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
set_merge	function
(	O
struct	O
set	struct
*	O
dst	pointer
,	O
const	O
struct	O
set	struct
*	O
src	pointer
,	O
int	O
null_also	int
)	O
{	O
int	O
count	int
;	O
int	O
i	int
;	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
src	pointer
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
null_also	int
||	O
src	pointer
->	O
which	pointer
[	O
i	int
]	O
!=	O
0	int
)	O
count	int
+=	O
set_add	function
(	O
dst	pointer
,	O
src	pointer
->	O
which	pointer
[	O
i	int
]	O
)	O
;	O
return	O
count	int
;	O
}	O
static	O
void	O
set_print	function
(	O
const	O
struct	O
set	struct
*	O
set	struct
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
set	struct
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
set	struct
->	O
which	pointer
[	O
i	int
]	O
!=	O
0	int
)	O
putchar	function
(	O
set	struct
->	O
which	pointer
[	O
i	int
]	O
)	O
;	O
else	O
putchar	function
(	O
'0'	O
)	O
;	O
}	O
static	O
struct	O
symbol	struct
{	O
int	O
sym	int
;	O
int	O
nonterminal	int
;	O
int	O
nt_index	int
;	O
struct	O
set	struct
first	struct
,	O
follow	struct
;	O
}	O
symbols	array
[	O
UCHAR_MAX	O
]	O
;	O
static	O
int	O
n_symbols	int
;	O
static	O
int	O
n_nonterminals	int
;	O
static	O
int	O
n_terminals	int
;	O
struct	O
symbol	struct
*	O
find_symbol	function
(	O
int	O
c	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
if	O
(	O
c	int
==	O
symbols	array
[	O
i	int
]	O
.	O
sym	int
)	O
return	O
&	O
symbols	array
[	O
i	int
]	O
;	O
abort	function
(	O
)	O
;	O
}	O
static	O
void	O
find_unique_symbols	function
(	O
void	O
)	O
{	O
unsigned	O
char	O
seen	array
[	O
UCHAR_MAX	O
]	O
;	O
size_t	long
i	int
;	O
n_symbols	int
=	O
n_terminals	int
=	O
n_nonterminals	int
=	O
0	int
;	O
memset	function
(	O
seen	array
,	O
0	int
,	O
sizeof	O
seen	array
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
seen	array
[	O
(	O
unsigned	O
char	O
)	O
grammar	array
[	O
i	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
]	O
|=	O
2	int
;	O
for	O
(	O
p	pointer
=	O
grammar	array
[	O
i	int
]	O
[	O
0	int
]	O
+	O
2	int
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
seen	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
]	O
|=	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
UCHAR_MAX	O
;	O
i	int
++	O
)	O
if	O
(	O
seen	array
[	O
i	int
]	O
)	O
{	O
struct	O
symbol	struct
*	O
sym	int
=	O
&	O
symbols	array
[	O
n_symbols	int
]	O
;	O
sym	int
->	O
sym	int
=	O
i	int
;	O
sym	int
->	O
nonterminal	int
=	O
(	O
seen	array
[	O
i	int
]	O
&	O
2	int
)	O
!=	O
0	int
;	O
sym	int
->	O
nt_index	int
=	O
sym	int
->	O
nonterminal	int
?	O
n_nonterminals	int
:	O
-	O
1	int
;	O
n_symbols	int
++	O
;	O
n_nonterminals	int
+=	O
sym	int
->	O
nonterminal	int
;	O
n_terminals	int
+=	O
!	O
sym	int
->	O
nonterminal	int
;	O
}	O
}	O
struct	O
item	struct
{	O
int	O
prod	int
;	O
int	O
dot	int
;	O
}	O
;	O
static	O
int	O
item_n_after_dot	function
(	O
const	O
struct	O
item	struct
*	O
item	struct
)	O
{	O
assert	O
(	O
item	struct
!=	O
NULL	O
&&	O
item	struct
->	O
prod	int
>=	O
0	int
&&	O
item	struct
->	O
prod	int
<	O
(	O
int	O
)	O
n_grammar	O
)	O
;	O
return	O
G	array
[	O
item	struct
->	O
prod	int
]	O
.	O
n_right	int
-	O
item	struct
->	O
dot	int
;	O
}	O
static	O
int	O
item_symbol_after_dot	function
(	O
const	O
struct	O
item	struct
*	O
item	struct
)	O
{	O
assert	O
(	O
item_n_after_dot	function
(	O
item	struct
)	O
>=	O
0	int
)	O
;	O
return	O
G	array
[	O
item	struct
->	O
prod	int
]	O
.	O
right	pointer
[	O
item	struct
->	O
dot	int
]	O
;	O
}	O
static	O
void	O
item_print	function
(	O
const	O
struct	O
item	struct
*	O
item	struct
)	O
{	O
const	O
struct	O
production	struct
*	O
prod	int
;	O
int	O
i	int
;	O
assert	O
(	O
item	struct
!=	O
NULL	O
&&	O
item	struct
->	O
prod	int
>=	O
0	int
&&	O
item	struct
->	O
prod	int
<	O
(	O
int	O
)	O
n_grammar	O
)	O
;	O
prod	int
=	O
&	O
G	array
[	O
item	struct
->	O
prod	int
]	O
;	O
printf	function
(	O
"%c="	pointer
,	O
prod	int
->	O
left	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
prod	int
->	O
n_right	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
item	struct
->	O
dot	int
)	O
putchar	function
(	O
'.'	O
)	O
;	O
putchar	function
(	O
prod	int
->	O
right	pointer
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
i	int
==	O
item	struct
->	O
dot	int
)	O
putchar	function
(	O
'.'	O
)	O
;	O
}	O
struct	O
list	struct
{	O
int	O
n	int
;	O
int	O
m	int
;	O
struct	O
item	struct
*	O
contents	pointer
;	O
}	O
;	O
static	O
void	O
list_init	function
(	O
struct	O
list	struct
*	O
list	struct
)	O
{	O
assert	O
(	O
list	struct
!=	O
NULL	O
)	O
;	O
list	struct
->	O
n	int
=	O
list	struct
->	O
m	int
=	O
0	int
;	O
list	struct
->	O
contents	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
list_free	function
(	O
struct	O
list	struct
*	O
list	struct
)	O
{	O
free	function
(	O
list	struct
->	O
contents	pointer
)	O
;	O
}	O
static	O
int	O
list_contains	function
(	O
struct	O
list	struct
*	O
list	struct
,	O
int	O
prod	int
,	O
int	O
dot	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	struct
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
list	struct
->	O
contents	pointer
[	O
i	int
]	O
.	O
prod	int
==	O
prod	int
&&	O
list	struct
->	O
contents	pointer
[	O
i	int
]	O
.	O
dot	int
==	O
dot	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
list_add	function
(	O
struct	O
list	struct
*	O
list	struct
,	O
int	O
prod	int
,	O
int	O
dot	int
)	O
{	O
assert	O
(	O
list	struct
!=	O
NULL	O
)	O
;	O
if	O
(	O
list_contains	function
(	O
list	struct
,	O
prod	int
,	O
dot	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
list	struct
->	O
n	int
>=	O
list	struct
->	O
m	int
)	O
{	O
if	O
(	O
list	struct
->	O
m	int
==	O
0	int
)	O
list	struct
->	O
m	int
=	O
16	int
;	O
else	O
list	struct
->	O
m	int
*=	O
2	int
;	O
list	struct
->	O
contents	pointer
=	O
xrealloc	function
(	O
list	struct
->	O
contents	pointer
,	O
sizeof	O
*	O
list	struct
->	O
contents	pointer
*	O
list	struct
->	O
m	int
)	O
;	O
}	O
assert	O
(	O
list	struct
->	O
n	int
<	O
list	struct
->	O
m	int
)	O
;	O
list	struct
->	O
contents	pointer
[	O
list	struct
->	O
n	int
]	O
.	O
prod	int
=	O
prod	int
;	O
list	struct
->	O
contents	pointer
[	O
list	struct
->	O
n	int
]	O
.	O
dot	int
=	O
dot	int
;	O
list	struct
->	O
n	int
++	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
list_copy	function
(	O
struct	O
list	struct
*	O
dst	pointer
,	O
const	O
struct	O
list	struct
*	O
src	pointer
)	O
{	O
int	O
i	int
;	O
dst	pointer
->	O
n	int
=	O
src	pointer
->	O
n	int
;	O
dst	pointer
->	O
m	int
=	O
src	pointer
->	O
m	int
;	O
dst	pointer
->	O
contents	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
dst	pointer
->	O
contents	pointer
*	O
dst	pointer
->	O
m	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
src	pointer
->	O
n	int
;	O
i	int
++	O
)	O
dst	pointer
->	O
contents	pointer
[	O
i	int
]	O
=	O
src	pointer
->	O
contents	pointer
[	O
i	int
]	O
;	O
}	O
static	O
int	O
list_equal	function
(	O
const	O
struct	O
list	struct
*	O
a	pointer
,	O
const	O
struct	O
list	struct
*	O
b	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
a	pointer
->	O
n	int
!=	O
b	pointer
->	O
n	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
a	pointer
->	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
a	pointer
->	O
contents	pointer
[	O
i	int
]	O
.	O
prod	int
!=	O
b	pointer
->	O
contents	pointer
[	O
i	int
]	O
.	O
prod	int
||	O
a	pointer
->	O
contents	pointer
[	O
i	int
]	O
.	O
dot	int
!=	O
b	pointer
->	O
contents	pointer
[	O
i	int
]	O
.	O
dot	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
list_count	function
(	O
const	O
struct	O
list	struct
*	O
list	struct
)	O
{	O
assert	O
(	O
list	struct
!=	O
NULL	O
)	O
;	O
return	O
list	struct
->	O
n	int
;	O
}	O
static	O
const	O
struct	O
item	struct
*	O
list_item	function
(	O
const	O
struct	O
list	struct
*	O
list	struct
,	O
int	O
index	int
)	O
{	O
assert	O
(	O
list	struct
!=	O
NULL	O
&&	O
index	int
>=	O
0	int
&&	O
index	int
<	O
list	struct
->	O
n	int
)	O
;	O
return	O
&	O
list	struct
->	O
contents	pointer
[	O
index	int
]	O
;	O
}	O
static	O
void	O
list_print	function
(	O
const	O
struct	O
list	struct
*	O
list	struct
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	struct
->	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
!=	O
0	int
)	O
printf	function
(	O
", "	pointer
)	O
;	O
item_print	function
(	O
&	O
list	struct
->	O
contents	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
precalc_first	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
{	O
set_init	function
(	O
&	O
symbols	array
[	O
i	int
]	O
.	O
first	struct
)	O
;	O
if	O
(	O
symbols	array
[	O
i	int
]	O
.	O
nonterminal	int
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_grammar	O
;	O
j	long
++	O
)	O
if	O
(	O
G	array
[	O
j	long
]	O
.	O
left	int
==	O
symbols	array
[	O
i	int
]	O
.	O
sym	int
&&	O
G	array
[	O
j	long
]	O
.	O
n_right	int
==	O
0	int
)	O
{	O
set_add	function
(	O
&	O
symbols	array
[	O
i	int
]	O
.	O
first	struct
,	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
set_add	function
(	O
&	O
symbols	array
[	O
i	int
]	O
.	O
first	struct
,	O
symbols	array
[	O
i	int
]	O
.	O
sym	int
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
added	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
struct	O
production	struct
*	O
prod	int
=	O
&	O
G	array
[	O
i	int
]	O
;	O
struct	O
symbol	struct
*	O
X	pointer
=	O
find_symbol	function
(	O
prod	int
->	O
left	int
)	O
;	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
prod	int
->	O
n_right	int
;	O
j	long
++	O
)	O
{	O
struct	O
symbol	struct
*	O
Y	pointer
;	O
int	O
k	int
;	O
Y	pointer
=	O
find_symbol	function
(	O
prod	int
->	O
right	pointer
[	O
j	long
]	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
Y	pointer
->	O
first	struct
.	O
n	int
;	O
k	int
++	O
)	O
if	O
(	O
Y	pointer
->	O
first	struct
.	O
which	pointer
[	O
k	int
]	O
!=	O
0	int
)	O
added	int
|=	O
set_add	function
(	O
&	O
X	pointer
->	O
first	struct
,	O
Y	pointer
->	O
first	struct
.	O
which	pointer
[	O
k	int
]	O
)	O
;	O
if	O
(	O
!	O
set_contains	function
(	O
&	O
X	pointer
->	O
first	struct
,	O
0	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
j	long
>=	O
prod	int
->	O
n_right	int
)	O
added	int
|=	O
set_add	function
(	O
&	O
X	pointer
->	O
first	struct
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
added	int
)	O
break	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	function
(	O
"FIRST function:\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
{	O
struct	O
symbol	struct
*	O
sym	int
=	O
&	O
symbols	array
[	O
i	int
]	O
;	O
printf	function
(	O
"\tFIRST(%c) = "	pointer
,	O
sym	int
->	O
sym	int
)	O
;	O
set_print	function
(	O
&	O
sym	int
->	O
first	struct
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
calc_first	function
(	O
struct	O
set	struct
*	O
set	struct
,	O
int	O
*	O
X	pointer
,	O
int	O
n	int
)	O
{	O
int	O
i	int
;	O
set_init	function
(	O
set	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
set	struct
*	O
f	pointer
=	O
&	O
find_symbol	function
(	O
X	pointer
[	O
i	int
]	O
)	O
->	O
first	struct
;	O
set_merge	function
(	O
set	struct
,	O
f	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
set_contains	function
(	O
f	pointer
,	O
0	int
)	O
)	O
return	O
;	O
}	O
set_add	function
(	O
set	struct
,	O
0	int
)	O
;	O
}	O
static	O
void	O
precalc_follow	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
set_init	function
(	O
&	O
symbols	array
[	O
i	int
]	O
.	O
follow	struct
)	O
;	O
set_add	function
(	O
&	O
find_symbol	function
(	O
G	array
[	O
0	int
]	O
.	O
left	int
)	O
->	O
follow	struct
,	O
'$'	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
added	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
production	struct
*	O
prod	int
;	O
struct	O
symbol	struct
*	O
A	pointer
;	O
int	O
j	long
;	O
prod	int
=	O
&	O
G	array
[	O
i	int
]	O
;	O
A	pointer
=	O
find_symbol	function
(	O
prod	int
->	O
left	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
prod	int
->	O
n_right	int
-	O
1	int
;	O
j	long
++	O
)	O
{	O
struct	O
symbol	struct
*	O
B	pointer
;	O
struct	O
set	struct
first_Beta	struct
;	O
B	pointer
=	O
find_symbol	function
(	O
prod	int
->	O
right	pointer
[	O
j	long
]	O
)	O
;	O
calc_first	function
(	O
&	O
first_Beta	struct
,	O
&	O
prod	int
->	O
right	pointer
[	O
j	long
+	O
1	int
]	O
,	O
prod	int
->	O
n_right	int
-	O
(	O
j	long
+	O
1	int
)	O
)	O
;	O
added	int
|=	O
set_merge	function
(	O
&	O
B	pointer
->	O
follow	struct
,	O
&	O
first_Beta	struct
,	O
0	int
)	O
;	O
if	O
(	O
set_contains	function
(	O
&	O
first_Beta	struct
,	O
0	int
)	O
)	O
added	int
|=	O
set_merge	function
(	O
&	O
B	pointer
->	O
follow	struct
,	O
&	O
A	pointer
->	O
follow	struct
,	O
1	int
)	O
;	O
set_free	function
(	O
&	O
first_Beta	struct
)	O
;	O
}	O
if	O
(	O
prod	int
->	O
n_right	int
>	O
0	int
)	O
{	O
struct	O
symbol	struct
*	O
B	pointer
=	O
find_symbol	function
(	O
prod	int
->	O
right	pointer
[	O
prod	int
->	O
n_right	int
-	O
1	int
]	O
)	O
;	O
added	int
|=	O
set_merge	function
(	O
&	O
B	pointer
->	O
follow	struct
,	O
&	O
A	pointer
->	O
follow	struct
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
added	int
)	O
break	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	function
(	O
"FOLLOW function:\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
{	O
struct	O
symbol	struct
*	O
sym	int
=	O
&	O
symbols	array
[	O
i	int
]	O
;	O
if	O
(	O
!	O
sym	int
->	O
nonterminal	int
)	O
continue	O
;	O
printf	function
(	O
"\tFOLLOW(%c) = "	pointer
,	O
sym	int
->	O
sym	int
)	O
;	O
set_print	function
(	O
&	O
sym	int
->	O
follow	struct
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
calc_closure	function
(	O
struct	O
list	struct
*	O
J	pointer
,	O
const	O
struct	O
list	struct
*	O
I	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
I	pointer
!=	O
J	pointer
)	O
list_copy	function
(	O
J	pointer
,	O
I	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list_count	function
(	O
J	pointer
)	O
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
item	struct
*	O
item	struct
=	O
list_item	function
(	O
J	pointer
,	O
i	int
)	O
;	O
if	O
(	O
item_n_after_dot	function
(	O
item	struct
)	O
>	O
0	int
)	O
{	O
int	O
t	int
=	O
item_symbol_after_dot	function
(	O
item	struct
)	O
;	O
if	O
(	O
find_symbol	function
(	O
t	int
)	O
->	O
nonterminal	int
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_grammar	O
;	O
j	long
++	O
)	O
if	O
(	O
G	array
[	O
j	long
]	O
.	O
left	int
==	O
t	int
)	O
list_add	function
(	O
J	pointer
,	O
j	long
,	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
calc_goto	function
(	O
struct	O
list	struct
*	O
J	pointer
,	O
struct	O
list	struct
*	O
I	pointer
,	O
int	O
X	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
I	pointer
!=	O
J	pointer
)	O
list_init	function
(	O
J	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list_count	function
(	O
I	pointer
)	O
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
item	struct
*	O
item	struct
=	O
list_item	function
(	O
I	pointer
,	O
i	int
)	O
;	O
if	O
(	O
item_n_after_dot	function
(	O
item	struct
)	O
>	O
0	int
&&	O
item_symbol_after_dot	function
(	O
item	struct
)	O
==	O
X	pointer
)	O
list_add	function
(	O
J	pointer
,	O
item	struct
->	O
prod	int
,	O
item	struct
->	O
dot	int
+	O
1	int
)	O
;	O
}	O
calc_closure	function
(	O
J	pointer
,	O
J	pointer
)	O
;	O
}	O
static	O
struct	O
list	struct
C	array
[	O
MAX_LOL_COUNT	int
]	O
;	O
static	O
int	O
nC	int
;	O
static	O
void	O
build_canonical_sets	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
nC	int
=	O
1	int
;	O
list_init	function
(	O
&	O
C	array
[	O
0	int
]	O
)	O
;	O
list_add	function
(	O
&	O
C	array
[	O
0	int
]	O
,	O
0	int
,	O
0	int
)	O
;	O
calc_closure	function
(	O
&	O
C	array
[	O
0	int
]	O
,	O
&	O
C	array
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
X	pointer
;	O
for	O
(	O
X	pointer
=	O
0	int
;	O
X	pointer
<	O
n_symbols	int
;	O
X	pointer
++	O
)	O
{	O
struct	O
list	struct
list	struct
;	O
calc_goto	function
(	O
&	O
list	struct
,	O
&	O
C	array
[	O
i	int
]	O
,	O
symbols	array
[	O
X	pointer
]	O
.	O
sym	int
)	O
;	O
if	O
(	O
list_count	function
(	O
&	O
list	struct
)	O
)	O
{	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nC	int
;	O
j	long
++	O
)	O
if	O
(	O
list_equal	function
(	O
&	O
list	struct
,	O
&	O
C	array
[	O
j	long
]	O
)	O
)	O
break	O
;	O
if	O
(	O
j	long
>=	O
nC	int
)	O
{	O
assert	O
(	O
nC	int
<	O
MAX_LOL_COUNT	int
)	O
;	O
C	array
[	O
nC	int
++	O
]	O
=	O
list	struct
;	O
}	O
else	O
list_free	function
(	O
&	O
list	struct
)	O
;	O
}	O
else	O
list_free	function
(	O
&	O
list	struct
)	O
;	O
}	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	function
(	O
"Canonical collection of sets:\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
printf	function
(	O
"\tI(%d) = "	pointer
,	O
i	int
)	O
;	O
list_print	function
(	O
&	O
C	array
[	O
i	int
]	O
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
action_name	function
(	O
char	O
buf	array
[	O
16	int
]	O
,	O
int	O
action	int
)	O
{	O
if	O
(	O
action	int
==	O
0	int
)	O
strcpy	function
(	O
buf	array
,	O
"0"	pointer
)	O
;	O
else	O
if	O
(	O
action	int
==	O
1	int
)	O
strcpy	function
(	O
buf	array
,	O
"acc"	pointer
)	O
;	O
else	O
if	O
(	O
action	int
>=	O
2	int
&&	O
action	int
<	O
2	int
+	O
nC	int
)	O
sprintf	function
(	O
buf	array
,	O
"s%d"	pointer
,	O
action	int
-	O
2	int
)	O
;	O
else	O
{	O
int	O
reduce	int
=	O
action	int
-	O
(	O
2	int
+	O
nC	int
)	O
+	O
1	int
;	O
assert	O
(	O
action	int
>=	O
2	int
+	O
nC	int
&&	O
action	int
<	O
2	int
+	O
nC	int
+	O
n_grammar	O
)	O
;	O
sprintf	function
(	O
buf	array
,	O
"r%d"	pointer
,	O
reduce	int
)	O
;	O
}	O
}	O
static	O
void	O
print_enum_list	function
(	O
int	O
c	int
,	O
int	O
first	struct
,	O
int	O
last	int
)	O
{	O
char	O
string	array
[	O
80	int
]	O
;	O
int	O
i	int
;	O
string	array
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
first	struct
;	O
i	int
<=	O
last	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strlen	function
(	O
string	array
)	O
>	O
65	int
)	O
{	O
printf	function
(	O
"    %s\n"	pointer
,	O
string	array
)	O
;	O
string	array
[	O
0	int
]	O
=	O
0	int
;	O
}	O
sprintf	function
(	O
string	array
+	O
strlen	function
(	O
string	array
)	O
,	O
"%c%d, "	pointer
,	O
c	int
,	O
i	int
)	O
;	O
}	O
if	O
(	O
strlen	function
(	O
string	array
)	O
>	O
0	int
)	O
{	O
printf	function
(	O
"    %s\n"	pointer
,	O
string	array
)	O
;	O
string	array
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
static	O
void	O
set_action	function
(	O
unsigned	O
char	O
*	O
*	O
actions	pointer
,	O
int	O
state	int
,	O
int	O
input	int
,	O
int	O
value	int
)	O
{	O
assert	O
(	O
actions	pointer
!=	O
NULL	O
)	O
;	O
assert	O
(	O
state	int
>=	O
0	int
&&	O
state	int
<	O
nC	int
)	O
;	O
assert	O
(	O
input	int
>=	O
0	int
&&	O
input	int
<=	O
n_symbols	int
)	O
;	O
if	O
(	O
actions	pointer
[	O
state	int
]	O
[	O
input	int
]	O
!=	O
0	int
&&	O
actions	pointer
[	O
state	int
]	O
[	O
input	int
]	O
!=	O
value	int
)	O
{	O
char	O
a	pointer
[	O
16	int
]	O
,	O
b	pointer
[	O
16	int
]	O
;	O
action_name	function
(	O
a	pointer
,	O
value	int
)	O
;	O
action_name	function
(	O
b	pointer
,	O
actions	pointer
[	O
state	int
]	O
[	O
input	int
]	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Conflict for state %d, input %c: %s versus %s\n"	pointer
,	O
state	int
,	O
input	int
<	O
n_symbols	int
?	O
symbols	array
[	O
input	int
]	O
.	O
sym	int
:	O
'$'	O
,	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
actions	pointer
[	O
state	int
]	O
[	O
input	int
]	O
=	O
value	int
;	O
}	O
static	O
void	O
build_action_table	function
(	O
void	O
)	O
{	O
unsigned	O
char	O
*	O
*	O
actions	pointer
;	O
int	O
i	int
;	O
actions	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
actions	pointer
*	O
nC	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
actions	pointer
[	O
i	int
]	O
=	O
xmalloc	function
(	O
sizeof	O
*	O
*	O
actions	pointer
*	O
(	O
n_symbols	int
+	O
1	int
)	O
)	O
;	O
memset	function
(	O
actions	pointer
[	O
i	int
]	O
,	O
0	int
,	O
sizeof	O
*	O
*	O
actions	pointer
*	O
(	O
n_symbols	int
+	O
1	int
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
list_count	function
(	O
&	O
C	array
[	O
i	int
]	O
)	O
;	O
j	long
++	O
)	O
{	O
const	O
struct	O
item	struct
*	O
item	struct
=	O
list_item	function
(	O
&	O
C	array
[	O
i	int
]	O
,	O
j	long
)	O
;	O
const	O
struct	O
production	struct
*	O
prod	int
=	O
&	O
G	array
[	O
item	struct
->	O
prod	int
]	O
;	O
const	O
struct	O
symbol	struct
*	O
A	pointer
=	O
find_symbol	function
(	O
prod	int
->	O
left	int
)	O
;	O
if	O
(	O
item_n_after_dot	function
(	O
item	struct
)	O
>	O
0	int
)	O
{	O
struct	O
symbol	struct
*	O
a	pointer
;	O
a	pointer
=	O
find_symbol	function
(	O
item_symbol_after_dot	function
(	O
item	struct
)	O
)	O
;	O
if	O
(	O
!	O
a	pointer
->	O
nonterminal	int
)	O
{	O
struct	O
list	struct
list	struct
;	O
int	O
k	int
;	O
calc_goto	function
(	O
&	O
list	struct
,	O
&	O
C	array
[	O
i	int
]	O
,	O
a	pointer
->	O
sym	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
nC	int
;	O
k	int
++	O
)	O
if	O
(	O
list_equal	function
(	O
&	O
list	struct
,	O
&	O
C	array
[	O
k	int
]	O
)	O
)	O
set_action	function
(	O
actions	pointer
,	O
i	int
,	O
a	pointer
-	O
symbols	array
,	O
2	int
+	O
k	int
)	O
;	O
list_free	function
(	O
&	O
list	struct
)	O
;	O
}	O
}	O
else	O
if	O
(	O
A	pointer
->	O
sym	int
!=	O
G	array
[	O
0	int
]	O
.	O
left	int
)	O
{	O
const	O
struct	O
set	struct
*	O
follow_A	pointer
=	O
&	O
A	pointer
->	O
follow	struct
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
follow_A	pointer
->	O
n	int
;	O
k	int
++	O
)	O
{	O
int	O
c	int
;	O
int	O
index	int
;	O
c	int
=	O
follow_A	pointer
->	O
which	pointer
[	O
k	int
]	O
;	O
if	O
(	O
c	int
==	O
'$'	O
)	O
index	int
=	O
n_symbols	int
;	O
else	O
index	int
=	O
find_symbol	function
(	O
c	int
)	O
-	O
symbols	array
;	O
set_action	function
(	O
actions	pointer
,	O
i	int
,	O
index	int
,	O
2	int
+	O
nC	int
+	O
(	O
prod	int
-	O
G	array
)	O
)	O
;	O
}	O
}	O
if	O
(	O
list_contains	function
(	O
&	O
C	array
[	O
i	int
]	O
,	O
0	int
,	O
1	int
)	O
)	O
set_action	function
(	O
actions	pointer
,	O
i	int
,	O
n_symbols	int
,	O
1	int
)	O
;	O
}	O
}	O
fputs	function
(	O
"/* Actions used in action_table[][] entries. */\n"	pointer
"enum\n"	pointer
"  {\n"	pointer
"    err,\t/* Error. */\n"	pointer
"    acc,\t/* Accept. */\n"	pointer
"\n"	pointer
"    /* Shift actions. */\n"	pointer
,	O
stdout	pointer
)	O
;	O
print_enum_list	function
(	O
's'	O
,	O
0	int
,	O
nC	int
-	O
1	int
)	O
;	O
fputs	function
(	O
"\n"	pointer
"    /* Reduce actions. */\n"	pointer
,	O
stdout	pointer
)	O
;	O
print_enum_list	function
(	O
'r'	O
,	O
1	int
,	O
n_grammar	O
)	O
;	O
printf	function
(	O
"\n"	pointer
"    n_states = %d,\n"	pointer
"    n_terminals = %d,\n"	pointer
"    n_nonterminals = %d,\n"	pointer
"    n_reductions = %d\n"	pointer
"  };\n"	pointer
"\n"	pointer
"/* Symbolic token names used in parse_table[][] second index. */\n"	pointer
"enum\n"	pointer
"  {\n"	pointer
,	O
nC	int
,	O
n_terminals	int
+	O
1	int
,	O
n_nonterminals	int
,	O
n_grammar	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
{	O
struct	O
symbol	struct
*	O
sym	int
=	O
&	O
symbols	array
[	O
i	int
]	O
;	O
int	O
j	long
;	O
if	O
(	O
sym	int
->	O
nonterminal	int
)	O
continue	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_tokens	O
;	O
j	long
++	O
)	O
if	O
(	O
tokens	array
[	O
j	long
]	O
.	O
token	int
==	O
sym	int
->	O
sym	int
)	O
break	O
;	O
assert	O
(	O
j	long
<	O
n_tokens	O
)	O
;	O
printf	function
(	O
"    %s,%*c/* %c */\n"	pointer
,	O
tokens	array
[	O
j	long
]	O
.	O
name	pointer
,	O
25	int
-	O
(	O
int	O
)	O
strlen	function
(	O
tokens	array
[	O
j	long
]	O
.	O
name	pointer
)	O
,	O
' '	O
,	O
sym	int
->	O
sym	int
)	O
;	O
}	O
fputs	function
(	O
"    lex_stop                  /* $ */\n"	pointer
"  };\n"	pointer
"\n"	pointer
"/* Action table.  This is action[][] from Fig. 4.30, \"LR parsing\n"	pointer
"   program\", in Aho, Sethi, and Ullman. */\n"	pointer
"static const unsigned char action_table[n_states][n_terminals] =\n"	pointer
"  {\n"	pointer
"    /*        "	pointer
,	O
stdout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
symbols	array
[	O
i	int
]	O
.	O
nonterminal	int
)	O
printf	function
(	O
"  %c "	pointer
,	O
symbols	array
[	O
i	int
]	O
.	O
sym	int
)	O
;	O
fputs	function
(	O
"  $ */\n"	pointer
,	O
stdout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
printf	function
(	O
"    /*%3d */ {"	pointer
,	O
i	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<=	O
n_symbols	int
;	O
j	long
++	O
)	O
if	O
(	O
j	long
==	O
n_symbols	int
||	O
!	O
symbols	array
[	O
j	long
]	O
.	O
nonterminal	int
)	O
{	O
char	O
buf	array
[	O
16	int
]	O
;	O
if	O
(	O
j	long
!=	O
0	int
)	O
putchar	function
(	O
','	O
)	O
;	O
action_name	function
(	O
buf	array
,	O
actions	pointer
[	O
i	int
]	O
[	O
j	long
]	O
)	O
;	O
printf	function
(	O
"%3s"	pointer
,	O
buf	array
)	O
;	O
}	O
fputs	function
(	O
"},\n"	pointer
,	O
stdout	pointer
)	O
;	O
}	O
fputs	function
(	O
"  };\n\n"	pointer
,	O
stdout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
free	function
(	O
actions	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
actions	pointer
)	O
;	O
}	O
static	O
void	O
build_goto_table	function
(	O
void	O
)	O
{	O
unsigned	O
char	O
*	O
*	O
gotos	pointer
;	O
int	O
i	int
;	O
gotos	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
gotos	pointer
*	O
nC	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
gotos	pointer
[	O
i	int
]	O
=	O
xmalloc	function
(	O
sizeof	O
*	O
*	O
gotos	pointer
*	O
n_nonterminals	int
)	O
;	O
memset	function
(	O
gotos	pointer
[	O
i	int
]	O
,	O
0	int
,	O
sizeof	O
*	O
*	O
gotos	pointer
*	O
n_nonterminals	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_symbols	int
;	O
j	long
++	O
)	O
{	O
struct	O
symbol	struct
*	O
A	pointer
;	O
struct	O
list	struct
list	struct
;	O
A	pointer
=	O
&	O
symbols	array
[	O
j	long
]	O
;	O
if	O
(	O
A	pointer
->	O
nonterminal	int
)	O
{	O
int	O
k	int
;	O
calc_goto	function
(	O
&	O
list	struct
,	O
&	O
C	array
[	O
i	int
]	O
,	O
A	pointer
->	O
sym	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
nC	int
;	O
k	int
++	O
)	O
if	O
(	O
list_equal	function
(	O
&	O
list	struct
,	O
&	O
C	array
[	O
k	int
]	O
)	O
)	O
{	O
gotos	pointer
[	O
i	int
]	O
[	O
A	pointer
->	O
nt_index	int
]	O
=	O
k	int
;	O
break	O
;	O
}	O
list_free	function
(	O
&	O
list	struct
)	O
;	O
}	O
}	O
}	O
fputs	function
(	O
"/* Go to table.  This is goto[][] from Fig. 4.30, \"LR parsing\n"	pointer
"   program\", in Aho, Sethi, and Ullman. */\n"	pointer
"static const unsigned char goto_table[n_states][n_nonterminals] =\n"	pointer
"  {\n"	pointer
"    /*        "	pointer
,	O
stdout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_symbols	int
;	O
i	int
++	O
)	O
if	O
(	O
symbols	array
[	O
i	int
]	O
.	O
nonterminal	int
)	O
printf	function
(	O
" %c "	pointer
,	O
symbols	array
[	O
i	int
]	O
.	O
sym	int
)	O
;	O
fputs	function
(	O
"*/\n"	pointer
,	O
stdout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
printf	function
(	O
"    /*%3d */ {"	pointer
,	O
i	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_symbols	int
;	O
j	long
++	O
)	O
{	O
struct	O
symbol	struct
*	O
sym	int
=	O
&	O
symbols	array
[	O
j	long
]	O
;	O
if	O
(	O
sym	int
->	O
nonterminal	int
)	O
{	O
if	O
(	O
sym	int
->	O
nt_index	int
!=	O
0	int
)	O
putchar	function
(	O
','	O
)	O
;	O
printf	function
(	O
"%2d"	pointer
,	O
gotos	pointer
[	O
i	int
]	O
[	O
sym	int
->	O
nt_index	int
]	O
)	O
;	O
}	O
}	O
fputs	function
(	O
"},\n"	pointer
,	O
stdout	pointer
)	O
;	O
}	O
fputs	function
(	O
"  };\n\n"	pointer
,	O
stdout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nC	int
;	O
i	int
++	O
)	O
free	function
(	O
gotos	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
gotos	pointer
)	O
;	O
}	O
static	O
int	O
compare_strings	function
(	O
const	O
void	O
*	O
pa	pointer
,	O
const	O
void	O
*	O
pb	pointer
)	O
{	O
const	O
char	O
*	O
a	pointer
=	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
pa	pointer
)	O
;	O
const	O
char	O
*	O
b	pointer
=	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
pb	pointer
)	O
;	O
return	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
static	O
void	O
print_reduce_table	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
fputs	function
(	O
"/* Reduction rule symbolic names (reduce_table[][2]). */\n"	pointer
"enum\n"	pointer
"  {\n"	pointer
"    reduce_null"	pointer
,	O
stdout	pointer
)	O
;	O
{	O
const	O
char	O
*	O
*	O
reductions	pointer
;	O
int	O
count	int
;	O
count	int
=	O
0	int
;	O
reductions	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
reductions	pointer
*	O
n_grammar	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
if	O
(	O
*	O
G	array
[	O
i	int
]	O
.	O
reduction	pointer
)	O
reductions	pointer
[	O
count	int
++	O
]	O
=	O
G	array
[	O
i	int
]	O
.	O
reduction	pointer
;	O
qsort	function
(	O
reductions	pointer
,	O
count	int
,	O
sizeof	O
*	O
reductions	pointer
,	O
compare_strings	function
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>	O
0	int
&&	O
reductions	pointer
[	O
i	int
-	O
1	int
]	O
==	O
reductions	pointer
[	O
i	int
]	O
)	O
continue	O
;	O
printf	function
(	O
",\n    %s"	pointer
,	O
reductions	pointer
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
reductions	pointer
)	O
;	O
}	O
fputs	function
(	O
"\n"	pointer
"  };\n"	pointer
"\n"	pointer
"/* Reduction table.  First index is reduction number, from\n"	pointer
"   parse_table[][] above.  Second index is as follows:\n\n"	pointer
"   reduce_table[r][0]: Number of grammar symbols on right side of\n"	pointer
"   production.\n\n"	pointer
"   reduce_table[r][1]: Second index into goto[][] array, "	pointer
"corresponding\n"	pointer
"   to the left side of the production.\n\n"	pointer
"   reduce_table[r][2]: User-specified symbolic name for this\n"	pointer
"   production. */\n"	pointer
"static const unsigned char reduce_table[n_reductions][3] = \n"	pointer
"  {\n"	pointer
,	O
stdout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
struct	O
production	struct
*	O
prod	int
=	O
&	O
G	array
[	O
i	int
]	O
;	O
printf	function
(	O
"    {%3d,%3d, %-30s}, /* %s */\n"	pointer
,	O
prod	int
->	O
n_right	int
,	O
find_symbol	function
(	O
prod	int
->	O
left	int
)	O
->	O
nt_index	int
,	O
*	O
prod	int
->	O
reduction	pointer
?	O
prod	int
->	O
reduction	pointer
:	O
"reduce_null"	pointer
,	O
prod	int
->	O
ascii	pointer
)	O
;	O
}	O
fputs	function
(	O
"  };\n\n"	pointer
,	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
parse_command_line	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
static	O
const	O
char	O
help	array
[	O
]	O
=	O
"slr, a program to generate an SLR parser for texiweave\n"	pointer
"\nUsage: %s [OPTION]...\n"	pointer
"  -d, --debug           turn on debugging\n"	pointer
"  -h, --help            print this help, then exit\n"	pointer
"  -v, --version         show version, then exit\n"	pointer
;	O
static	O
const	O
char	O
version	array
[	O
]	O
=	O
"slr version 1.0\n"	pointer
"\nCopyright (C) 2000 Free Software Foundation, Inc.\n"	pointer
"This is free software; see the source for copying conditions.  "	pointer
"There is NO\n"	pointer
"WARRANTY; not even for MERCHANTABILITY or FITNESS FOR A "	pointer
"PARTICULAR PURPOSE.\n\n"	pointer
"Written by Ben Pfaff <blp@gnu.org>.\n"	pointer
;	O
const	O
char	O
*	O
short_pgm_name	pointer
=	O
strrchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
short_pgm_name	pointer
!=	O
NULL	O
)	O
short_pgm_name	pointer
++	O
;	O
else	O
short_pgm_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
return	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
argc	int
--	O
;	O
argv	pointer
++	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"-d"	pointer
)	O
||	O
!	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"--debug"	pointer
)	O
)	O
debug	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"-h"	pointer
)	O
||	O
!	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"--help"	pointer
)	O
)	O
{	O
printf	function
(	O
help	array
,	O
short_pgm_name	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"-v"	pointer
)	O
||	O
!	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"--version"	pointer
)	O
)	O
{	O
fputs	function
(	O
version	array
,	O
stdout	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
help	array
,	O
short_pgm_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
initialize_G	function
(	O
void	O
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_grammar	O
;	O
i	int
++	O
)	O
{	O
int	O
j	long
;	O
G	array
[	O
i	int
]	O
.	O
left	int
=	O
(	O
unsigned	O
char	O
)	O
grammar	array
[	O
i	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
;	O
G	array
[	O
i	int
]	O
.	O
n_right	int
=	O
strlen	function
(	O
grammar	array
[	O
i	int
]	O
[	O
0	int
]	O
+	O
2	int
)	O
;	O
G	array
[	O
i	int
]	O
.	O
right	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
G	array
[	O
i	int
]	O
.	O
right	pointer
*	O
G	array
[	O
i	int
]	O
.	O
n_right	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
G	array
[	O
i	int
]	O
.	O
n_right	int
;	O
j	long
++	O
)	O
G	array
[	O
i	int
]	O
.	O
right	pointer
[	O
j	long
]	O
=	O
(	O
unsigned	O
char	O
)	O
grammar	array
[	O
i	int
]	O
[	O
0	int
]	O
[	O
j	long
+	O
2	int
]	O
;	O
G	array
[	O
i	int
]	O
.	O
ascii	pointer
=	O
grammar	array
[	O
i	int
]	O
[	O
0	int
]	O
;	O
G	array
[	O
i	int
]	O
.	O
reduction	pointer
=	O
grammar	array
[	O
i	int
]	O
[	O
1	int
]	O
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
parse_command_line	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
find_unique_symbols	function
(	O
)	O
;	O
initialize_G	function
(	O
)	O
;	O
build_canonical_sets	function
(	O
)	O
;	O
precalc_first	function
(	O
)	O
;	O
precalc_follow	function
(	O
)	O
;	O
build_action_table	function
(	O
)	O
;	O
build_goto_table	function
(	O
)	O
;	O
print_reduce_table	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
