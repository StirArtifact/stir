static	O
int	O
zip_cmd	function
(	O
int	O
priv	int
,	O
int	O
fd	int
,	O
unsigned	O
char	O
cdb	array
[	O
6	int
]	O
,	O
int	O
clen	int
,	O
scsi_io_mode_t	enum
mode	int
,	O
void	O
*	O
data	pointer
,	O
size_t	long
len	long
,	O
void	O
*	O
extra_data	pointer
)	O
{	O
int	O
r	int
;	O
if	O
(	O
priv	int
)	O
reclaim_privs	function
(	O
)	O
;	O
r	int
=	O
scsi_cmd	function
(	O
fd	int
,	O
cdb	array
,	O
clen	int
,	O
mode	int
,	O
data	pointer
,	O
len	long
,	O
extra_data	pointer
)	O
;	O
if	O
(	O
priv	int
)	O
drop_privs	function
(	O
)	O
;	O
return	O
r	int
;	O
}	O
static	O
int	O
test_mounted	function
(	O
char	O
*	O
dev	pointer
)	O
{	O
struct	O
mntent	struct
*	O
mnt	pointer
;	O
struct	O
MT_STAT	O
st_dev	long
,	O
st_mnt	struct
;	O
FILE	struct
*	O
mtab	pointer
;	O
if	O
(	O
MT_STAT	O
(	O
dev	pointer
,	O
&	O
st_dev	long
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: stat(%s) failed: %s.\n"	pointer
,	O
progname	pointer
,	O
dev	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
S_ISBLK	O
(	O
st_dev	long
.	O
st_mode	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
mtab	pointer
=	O
setmntent	function
(	O
_PATH_MOUNTED	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: can't open %s.\n"	pointer
,	O
progname	pointer
,	O
_PATH_MOUNTED	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
(	O
mnt	pointer
=	O
getmntent	function
(	O
mtab	pointer
)	O
)	O
)	O
{	O
if	O
(	O
!	O
mnt	pointer
->	O
mnt_fsname	pointer
||	O
!	O
strcmp	function
(	O
mnt	pointer
->	O
mnt_type	pointer
,	O
MNTTYPE_SWAP	pointer
)	O
||	O
!	O
strcmp	function
(	O
mnt	pointer
->	O
mnt_type	pointer
,	O
MNTTYPE_NFS	pointer
)	O
||	O
!	O
strcmp	function
(	O
mnt	pointer
->	O
mnt_type	pointer
,	O
"proc"	pointer
)	O
||	O
!	O
strcmp	function
(	O
mnt	pointer
->	O
mnt_type	pointer
,	O
"smbfs"	pointer
)	O
||	O
!	O
strcmp	function
(	O
mnt	pointer
->	O
mnt_type	pointer
,	O
MNTTYPE_IGNORE	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
MT_STAT	O
(	O
mnt	pointer
->	O
mnt_fsname	pointer
,	O
&	O
st_mnt	struct
)	O
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
S_ISBLK	O
(	O
st_mnt	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
MAJOR	O
(	O
st_mnt	struct
.	O
st_rdev	long
)	O
==	O
MAJOR	O
(	O
st_dev	long
.	O
st_rdev	long
)	O
&&	O
MINOR	O
(	O
st_mnt	struct
.	O
st_rdev	long
)	O
>=	O
MINOR	O
(	O
st_dev	long
.	O
st_rdev	long
)	O
&&	O
MINOR	O
(	O
st_mnt	struct
.	O
st_rdev	long
)	O
<=	O
MINOR	O
(	O
st_dev	long
.	O
st_rdev	long
)	O
+	O
15	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Device %s%d is mounted on %s.\n"	pointer
,	O
dev	pointer
,	O
MINOR	O
(	O
st_mnt	struct
.	O
st_rdev	long
)	O
-	O
MINOR	O
(	O
st_dev	long
.	O
st_rdev	long
)	O
,	O
mnt	pointer
->	O
mnt_dir	pointer
)	O
;	O
endmntent	function
(	O
mtab	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
endmntent	function
(	O
mtab	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
ret	int
)	O
NORETURN	O
;	O
static	O
void	O
usage	function
(	O
int	O
ret	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Mtools version %s, dated %s\n"	pointer
,	O
mversion	pointer
,	O
mdate	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s [-V] [-q] [-e] [-u] [-r|-w|-p|-x] [drive:]\n"	pointer
"\t-q print status\n"	pointer
"\t-e eject disk\n"	pointer
"\t-f eject disk even when mounted\n"	pointer
"\t-r write protected (read-only)\n"	pointer
"\t-w not write-protected (read-write)\n"	pointer
"\t-p password write protected\n"	pointer
"\t-x password protected\n"	pointer
"\t-u unprotect till disk ejecting\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	function
(	O
ret	int
)	O
;	O
}	O
enum	O
mode_t	int
{	O
ZIP_RW	int
=	O
0	int
,	O
ZIP_RO	int
=	O
2	int
,	O
ZIP_RO_PW	int
=	O
3	int
,	O
ZIP_PW	int
=	O
5	int
,	O
ZIP_UNLOCK_TIL_EJECT	int
=	O
8	int
}	O
;	O
static	O
enum	O
mode_t	int
get_zip_status	function
(	O
int	O
priv	int
,	O
int	O
fd	int
,	O
void	O
*	O
extra_data	pointer
)	O
{	O
unsigned	O
char	O
status	int
[	O
128	int
]	O
;	O
unsigned	O
char	O
cdb	array
[	O
6	int
]	O
=	O
{	O
0x06	int
,	O
0	int
,	O
0x02	int
,	O
0	int
,	O
sizeof	O
status	int
,	O
0	int
}	O
;	O
if	O
(	O
zip_cmd	function
(	O
priv	int
,	O
fd	int
,	O
cdb	array
,	O
6	int
,	O
SCSI_IO_READ	int
,	O
status	int
,	O
sizeof	O
status	int
,	O
extra_data	pointer
)	O
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"status: "	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
status	int
[	O
21	int
]	O
&	O
0xf	int
;	O
}	O
static	O
int	O
short_command	function
(	O
int	O
priv	int
,	O
int	O
fd	int
,	O
int	O
cmd1	int
,	O
int	O
cmd2	int
,	O
int	O
cmd3	int
,	O
const	O
char	O
*	O
data	pointer
,	O
void	O
*	O
extra_data	pointer
)	O
{	O
unsigned	O
char	O
cdb	array
[	O
6	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
cdb	array
[	O
0	int
]	O
=	O
cmd1	int
;	O
cdb	array
[	O
1	int
]	O
=	O
cmd2	int
;	O
cdb	array
[	O
4	int
]	O
=	O
cmd3	int
;	O
return	O
zip_cmd	function
(	O
priv	int
,	O
fd	int
,	O
cdb	array
,	O
6	int
,	O
SCSI_IO_WRITE	int
,	O
(	O
char	O
*	O
)	O
data	pointer
,	O
data	pointer
?	O
strlen	function
(	O
data	pointer
)	O
:	O
0	int
,	O
extra_data	pointer
)	O
;	O
}	O
static	O
int	O
iomega_command	function
(	O
int	O
priv	int
,	O
int	O
fd	int
,	O
int	O
mode	int
,	O
const	O
char	O
*	O
data	pointer
,	O
void	O
*	O
extra_data	pointer
)	O
{	O
return	O
short_command	function
(	O
priv	int
,	O
fd	int
,	O
SCSI_IOMEGA	int
,	O
mode	int
,	O
data	pointer
?	O
strlen	function
(	O
data	pointer
)	O
:	O
0	int
,	O
data	pointer
,	O
extra_data	pointer
)	O
;	O
}	O
static	O
int	O
door_command	function
(	O
int	O
priv	int
,	O
int	O
fd	int
,	O
int	O
cmd1	int
,	O
int	O
cmd2	int
,	O
void	O
*	O
extra_data	pointer
)	O
{	O
return	O
short_command	function
(	O
priv	int
,	O
fd	int
,	O
cmd1	int
,	O
0	int
,	O
cmd2	int
,	O
0	int
,	O
extra_data	pointer
)	O
;	O
}	O
void	O
mzip	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
type	enum
UNUSEDP	O
)	O
NORETURN	O
;	O
void	O
mzip	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
type	enum
UNUSEDP	O
)	O
{	O
void	O
*	O
extra_data	pointer
=	O
NULL	O
;	O
int	O
c	int
;	O
char	O
drive	char
;	O
device_t	struct
*	O
dev	pointer
;	O
int	O
fd	int
=	O
-	O
1	int
;	O
char	O
name	pointer
[	O
EXPAND_BUF	int
]	O
;	O
enum	O
{	O
ZIP_NIX	int
=	O
0	int
,	O
ZIP_STATUS	int
=	O
1	int
<<	O
0	int
,	O
ZIP_EJECT	int
=	O
1	int
<<	O
1	int
,	O
ZIP_MODE_CHANGE	int
=	O
1	int
<<	O
2	int
,	O
ZIP_FORCE	int
=	O
1	int
<<	O
3	int
}	O
request	pointer
=	O
ZIP_NIX	int
;	O
enum	O
mode_t	int
newMode	enum
=	O
ZIP_RW	int
;	O
enum	O
mode_t	int
oldMode	enum
=	O
ZIP_RW	int
;	O
if	O
(	O
helpFlag	function
(	O
argc	int
,	O
argv	pointer
)	O
)	O
usage	function
(	O
0	int
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt	function
(	O
argc	int
,	O
argv	pointer
,	O
"i:efpqrwxuh"	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'i'	O
:	O
set_cmd_line_image	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
get_real_uid	function
(	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Only root can use force. Sorry.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
request	pointer
|=	O
ZIP_FORCE	int
;	O
break	O
;	O
case	O
'e'	O
:	O
request	pointer
|=	O
ZIP_EJECT	int
;	O
break	O
;	O
case	O
'q'	O
:	O
request	pointer
|=	O
ZIP_STATUS	int
;	O
break	O
;	O
case	O
'p'	O
:	O
setMode	O
(	O
ZIP_RO_PW	int
)	O
;	O
case	O
'r'	O
:	O
setMode	O
(	O
ZIP_RO	int
)	O
;	O
case	O
'w'	O
:	O
setMode	O
(	O
ZIP_RW	int
)	O
;	O
case	O
'x'	O
:	O
setMode	O
(	O
ZIP_PW	int
)	O
;	O
case	O
'u'	O
:	O
setMode	O
(	O
ZIP_UNLOCK_TIL_EJECT	int
)	O
case	O
'h'	O
:	O
usage	function
(	O
0	int
)	O
;	O
default	O
:	O
usage	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
request	pointer
==	O
ZIP_NIX	int
)	O
request	pointer
=	O
ZIP_STATUS	int
;	O
if	O
(	O
argc	int
-	O
optind	int
>	O
1	int
||	O
(	O
argc	int
-	O
optind	int
==	O
1	int
&&	O
(	O
!	O
argv	pointer
[	O
optind	int
]	O
[	O
0	int
]	O
||	O
argv	pointer
[	O
optind	int
]	O
[	O
1	int
]	O
!=	O
':'	O
)	O
)	O
)	O
usage	function
(	O
1	int
)	O
;	O
drive	char
=	O
ch_toupper	function
(	O
argc	int
-	O
optind	int
==	O
1	int
?	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
[	O
0	int
]	O
:	O
':'	O
)	O
;	O
for	O
(	O
dev	pointer
=	O
devices	pointer
;	O
dev	pointer
->	O
name	pointer
;	O
dev	pointer
++	O
)	O
{	O
unsigned	O
char	O
cdb	array
[	O
6	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
struct	O
{	O
char	O
type	enum
,	O
type_modifier	char
,	O
scsi_version	char
,	O
data_format	char
,	O
length	int
,	O
reserved1	int
[	O
2	int
]	O
,	O
capabilities	char
,	O
vendor	array
[	O
8	int
]	O
,	O
product	array
[	O
16	int
]	O
,	O
revision	array
[	O
4	int
]	O
,	O
vendor_specific	array
[	O
20	int
]	O
,	O
reserved2	array
[	O
40	int
]	O
;	O
}	O
inq_data	struct
;	O
if	O
(	O
dev	pointer
->	O
drive	char
!=	O
drive	char
)	O
continue	O
;	O
expand	function
(	O
dev	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
(	O
request	pointer
&	O
(	O
ZIP_MODE_CHANGE	int
|	O
ZIP_EJECT	int
)	O
)	O
&&	O
!	O
(	O
request	pointer
&	O
ZIP_FORCE	int
)	O
&&	O
test_mounted	function
(	O
name	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Can\'t change status of/eject mounted device\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
precmd	pointer
(	O
dev	pointer
)	O
;	O
if	O
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
)	O
reclaim_privs	function
(	O
)	O
;	O
fd	int
=	O
scsi_open	function
(	O
name	pointer
,	O
O_RDONLY	int
|	O
O_NDELAY	O
,	O
0644	int
,	O
&	O
extra_data	pointer
)	O
;	O
if	O
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
)	O
drop_privs	function
(	O
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
continue	O
;	O
closeExec	function
(	O
fd	int
)	O
;	O
if	O
(	O
!	O
(	O
request	pointer
&	O
(	O
ZIP_MODE_CHANGE	int
|	O
ZIP_STATUS	int
)	O
)	O
)	O
break	O
;	O
cdb	array
[	O
0	int
]	O
=	O
SCSI_INQUIRY	int
;	O
cdb	array
[	O
4	int
]	O
=	O
sizeof	O
inq_data	struct
;	O
if	O
(	O
zip_cmd	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
cdb	array
,	O
6	int
,	O
SCSI_IO_READ	int
,	O
&	O
inq_data	struct
,	O
sizeof	O
inq_data	struct
,	O
extra_data	pointer
)	O
!=	O
0	int
)	O
{	O
close	pointer
(	O
fd	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
strncasecmp	function
(	O
"IOMEGA  "	pointer
,	O
inq_data	struct
.	O
vendor	array
,	O
sizeof	O
inq_data	struct
.	O
vendor	array
)	O
||	O
(	O
strncasecmp	function
(	O
"ZIP 100         "	pointer
,	O
inq_data	struct
.	O
product	array
,	O
sizeof	O
inq_data	struct
.	O
product	array
)	O
&&	O
strncasecmp	function
(	O
"ZIP 100 PLUS    "	pointer
,	O
inq_data	struct
.	O
product	array
,	O
sizeof	O
inq_data	struct
.	O
product	array
)	O
&&	O
strncasecmp	function
(	O
"ZIP 250         "	pointer
,	O
inq_data	struct
.	O
product	array
,	O
sizeof	O
inq_data	struct
.	O
product	array
)	O
&&	O
strncasecmp	function
(	O
"ZIP 750         "	pointer
,	O
inq_data	struct
.	O
product	array
,	O
sizeof	O
inq_data	struct
.	O
product	array
)	O
&&	O
strncasecmp	function
(	O
"JAZ 1GB         "	pointer
,	O
inq_data	struct
.	O
product	array
,	O
sizeof	O
inq_data	struct
.	O
product	array
)	O
&&	O
strncasecmp	function
(	O
"JAZ 2GB         "	pointer
,	O
inq_data	struct
.	O
product	array
,	O
sizeof	O
inq_data	struct
.	O
product	array
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Skipping drive with vendor='"	pointer
)	O
;	O
fwrite	function
(	O
inq_data	struct
.	O
vendor	array
,	O
1	int
,	O
sizeof	O
(	O
inq_data	struct
.	O
vendor	array
)	O
,	O
stderr	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"' product='"	pointer
)	O
;	O
fwrite	function
(	O
inq_data	struct
.	O
product	array
,	O
1	int
,	O
sizeof	O
(	O
inq_data	struct
.	O
product	array
)	O
,	O
stderr	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"'\n"	pointer
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
dev	pointer
->	O
drive	char
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: drive '%c:' is not a Zip or Jaz drive\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
drive	char
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
request	pointer
&	O
(	O
ZIP_MODE_CHANGE	int
|	O
ZIP_STATUS	int
)	O
)	O
oldMode	enum
=	O
get_zip_status	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
extra_data	pointer
)	O
;	O
if	O
(	O
request	pointer
&	O
ZIP_MODE_CHANGE	int
)	O
{	O
if	O
(	O
newMode	enum
==	O
ZIP_UNLOCK_TIL_EJECT	int
&&	O
(	O
oldMode	enum
&	O
ZIP_UNLOCK_TIL_EJECT	int
)	O
)	O
request	pointer
&=	O
~	O
ZIP_MODE_CHANGE	int
;	O
if	O
(	O
!	O
(	O
newMode	enum
&	O
0x01	int
)	O
&&	O
newMode	enum
==	O
oldMode	enum
)	O
request	pointer
&=	O
~	O
ZIP_MODE_CHANGE	int
;	O
}	O
if	O
(	O
request	pointer
&	O
ZIP_MODE_CHANGE	int
)	O
{	O
int	O
ret	int
;	O
enum	O
mode_t	int
unlockMode	enum
,	O
unlockMask	enum
;	O
const	O
char	O
*	O
passwd	struct
;	O
char	O
dummy	array
[	O
1	int
]	O
;	O
if	O
(	O
newMode	enum
==	O
ZIP_UNLOCK_TIL_EJECT	int
)	O
{	O
unlockMode	enum
=	O
newMode	enum
|	O
oldMode	enum
;	O
unlockMask	enum
=	O
9	int
;	O
}	O
else	O
{	O
unlockMode	enum
=	O
newMode	enum
&	O
~	O
0x5	int
;	O
unlockMask	enum
=	O
1	int
;	O
}	O
if	O
(	O
(	O
oldMode	enum
&	O
unlockMask	enum
)	O
==	O
1	int
)	O
{	O
char	O
*	O
s	pointer
;	O
passwd	struct
=	O
"APlaceForYourStuff"	pointer
;	O
if	O
(	O
(	O
s	pointer
=	O
strchr	function
(	O
passwd	struct
,	O
'\n'	O
)	O
)	O
)	O
*	O
s	pointer
=	O
'\0'	O
;	O
iomega_command	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
unlockMode	enum
,	O
passwd	struct
,	O
extra_data	pointer
)	O
;	O
}	O
if	O
(	O
(	O
get_zip_status	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
extra_data	pointer
)	O
&	O
unlockMask	enum
)	O
==	O
1	int
)	O
{	O
char	O
*	O
s	pointer
;	O
passwd	struct
=	O
getpass	function
(	O
"Password: "	pointer
)	O
;	O
if	O
(	O
(	O
s	pointer
=	O
strchr	function
(	O
passwd	struct
,	O
'\n'	O
)	O
)	O
)	O
*	O
s	pointer
=	O
'\0'	O
;	O
if	O
(	O
(	O
ret	int
=	O
iomega_command	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
unlockMode	enum
,	O
passwd	struct
,	O
extra_data	pointer
)	O
)	O
)	O
{	O
if	O
(	O
ret	int
==	O
-	O
1	int
)	O
perror	function
(	O
"passwd: "	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"wrong password\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
get_zip_status	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
extra_data	pointer
)	O
&	O
unlockMask	enum
)	O
==	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"wrong password\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
newMode	enum
&	O
0x1	int
)	O
{	O
char	O
first_try	array
[	O
_PASSWORD_LEN	int
+	O
1	int
]	O
;	O
passwd	struct
=	O
getpass	function
(	O
"Enter new password:"	pointer
)	O
;	O
strncpy	function
(	O
first_try	array
,	O
passwd	struct
,	O
_PASSWORD_LEN	int
)	O
;	O
passwd	struct
=	O
getpass	function
(	O
"Re-type new password:"	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
first_try	array
,	O
passwd	struct
,	O
_PASSWORD_LEN	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"You misspelled it. Password not set.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
passwd	struct
=	O
dummy	array
;	O
dummy	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
newMode	enum
==	O
ZIP_UNLOCK_TIL_EJECT	int
)	O
newMode	enum
|=	O
oldMode	enum
;	O
if	O
(	O
(	O
ret	int
=	O
iomega_command	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
newMode	enum
,	O
passwd	struct
,	O
extra_data	pointer
)	O
)	O
)	O
{	O
if	O
(	O
ret	int
==	O
-	O
1	int
)	O
perror	function
(	O
"set passwd: "	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"password not changed\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
ioctl	function
(	O
fd	int
,	O
BLKRRPART	O
)	O
;	O
}	O
if	O
(	O
request	pointer
&	O
ZIP_STATUS	int
)	O
{	O
const	O
char	O
*	O
unlocked	pointer
;	O
if	O
(	O
oldMode	enum
&	O
8	int
)	O
unlocked	pointer
=	O
" and unlocked until eject"	pointer
;	O
else	O
unlocked	pointer
=	O
""	pointer
;	O
switch	O
(	O
oldMode	enum
&	O
~	O
8	int
)	O
{	O
case	O
ZIP_RW	int
:	O
printf	function
(	O
"Drive '%c:' is not write-protected\n"	pointer
,	O
drive	char
)	O
;	O
break	O
;	O
case	O
ZIP_RO	int
:	O
printf	function
(	O
"Drive '%c:' is write-protected%s\n"	pointer
,	O
drive	char
,	O
unlocked	pointer
)	O
;	O
break	O
;	O
case	O
ZIP_RO_PW	int
:	O
printf	function
(	O
"Drive '%c:' is password write-protected%s\n"	pointer
,	O
drive	char
,	O
unlocked	pointer
)	O
;	O
break	O
;	O
case	O
ZIP_PW	int
:	O
printf	function
(	O
"Drive '%c:' is password protected%s\n"	pointer
,	O
drive	char
,	O
unlocked	pointer
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"Unknown protection mode %d of drive '%c:'\n"	pointer
,	O
oldMode	enum
,	O
drive	char
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
request	pointer
&	O
ZIP_EJECT	int
)	O
{	O
if	O
(	O
request	pointer
&	O
ZIP_FORCE	int
)	O
if	O
(	O
door_command	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
SCSI_ALLOW_MEDIUM_REMOVAL	int
,	O
0	int
,	O
extra_data	pointer
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
"door unlock: "	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
door_command	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
SCSI_START_STOP	int
,	O
1	int
,	O
extra_data	pointer
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
"stop motor: "	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
door_command	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
SCSI_START_STOP	int
,	O
2	int
,	O
extra_data	pointer
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
"eject: "	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
door_command	function
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
,	O
fd	int
,	O
SCSI_START_STOP	int
,	O
2	int
,	O
extra_data	pointer
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
"second eject: "	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
close	pointer
(	O
fd	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
