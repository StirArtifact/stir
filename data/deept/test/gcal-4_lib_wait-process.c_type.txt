typedef	O
struct	O
{	O
volatile	O
sig_atomic_t	int
used	int
;	O
volatile	O
pid_t	int
child	int
;	O
}	O
slaves_entry_t	struct
;	O
static	O
slaves_entry_t	struct
static_slaves	array
[	O
32	int
]	O
;	O
static	O
slaves_entry_t	struct
*	O
volatile	O
slaves	pointer
=	O
static_slaves	array
;	O
static	O
sig_atomic_t	int
volatile	O
slaves_count	int
=	O
0	int
;	O
static	O
size_t	long
slaves_allocated	long
=	O
SIZEOF	O
(	O
static_slaves	array
)	O
;	O
static	O
void	O
cleanup_slaves	function
(	O
void	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
n	long
=	O
slaves_count	int
;	O
if	O
(	O
n	long
==	O
0	int
)	O
break	O
;	O
n	long
--	O
;	O
slaves_count	int
=	O
n	long
;	O
if	O
(	O
slaves	pointer
[	O
n	long
]	O
.	O
used	int
)	O
{	O
pid_t	int
slave	int
=	O
slaves	pointer
[	O
n	long
]	O
.	O
child	int
;	O
kill	function
(	O
slave	int
,	O
TERMINATOR	O
)	O
;	O
}	O
}	O
}	O
void	O
register_slave_subprocess	function
(	O
pid_t	int
child	int
)	O
{	O
static	O
bool	bool
cleanup_slaves_registered	bool
=	O
false	int
;	O
if	O
(	O
!	O
cleanup_slaves_registered	bool
)	O
{	O
atexit	function
(	O
cleanup_slaves	function
)	O
;	O
at_fatal_signal	function
(	O
cleanup_slaves	function
)	O
;	O
cleanup_slaves_registered	bool
=	O
true	int
;	O
}	O
{	O
slaves_entry_t	struct
*	O
s	pointer
=	O
slaves	pointer
;	O
slaves_entry_t	struct
*	O
s_end	pointer
=	O
s	long
+	O
slaves_count	int
;	O
for	O
(	O
;	O
s	pointer
<	O
s_end	pointer
;	O
s	pointer
++	O
)	O
if	O
(	O
!	O
s	pointer
->	O
used	int
)	O
{	O
s	pointer
->	O
child	int
=	O
child	int
;	O
s	long
->	O
used	int
=	O
1	int
;	O
return	O
;	O
}	O
}	O
if	O
(	O
slaves_count	int
==	O
slaves_allocated	long
)	O
{	O
slaves_entry_t	struct
*	O
old_slaves	pointer
=	O
slaves	pointer
;	O
size_t	long
new_slaves_allocated	long
=	O
2	int
*	O
slaves_allocated	long
;	O
slaves_entry_t	struct
*	O
new_slaves	pointer
=	O
(	O
slaves_entry_t	struct
*	O
)	O
malloc	function
(	O
new_slaves_allocated	long
*	O
sizeof	O
(	O
slaves_entry_t	struct
)	O
)	O
;	O
if	O
(	O
new_slaves	pointer
==	O
NULL	O
)	O
{	O
kill	function
(	O
child	int
,	O
TERMINATOR	O
)	O
;	O
xalloc_die	function
(	O
)	O
;	O
}	O
memcpy	function
(	O
new_slaves	pointer
,	O
old_slaves	pointer
,	O
slaves_allocated	long
*	O
sizeof	O
(	O
slaves_entry_t	struct
)	O
)	O
;	O
slaves	pointer
=	O
new_slaves	pointer
;	O
slaves_allocated	long
=	O
new_slaves_allocated	long
;	O
if	O
(	O
old_slaves	pointer
!=	O
static_slaves	array
)	O
free	function
(	O
old_slaves	pointer
)	O
;	O
}	O
slaves	pointer
[	O
slaves_count	int
]	O
.	O
child	int
=	O
child	int
;	O
slaves	pointer
[	O
slaves_count	int
]	O
.	O
used	int
=	O
1	int
;	O
slaves_count	int
++	O
;	O
}	O
static	O
void	O
unregister_slave_subprocess	function
(	O
pid_t	int
child	int
)	O
{	O
slaves_entry_t	struct
*	O
s	pointer
=	O
slaves	pointer
;	O
slaves_entry_t	struct
*	O
s_end	pointer
=	O
s	long
+	O
slaves_count	int
;	O
for	O
(	O
;	O
s	pointer
<	O
s_end	pointer
;	O
s	pointer
++	O
)	O
if	O
(	O
s	pointer
->	O
used	int
&&	O
s	long
->	O
child	int
==	O
child	int
)	O
s	long
->	O
used	int
=	O
0	int
;	O
}	O
int	O
wait_subprocess	function
(	O
pid_t	int
child	int
,	O
const	O
char	O
*	O
progname	pointer
,	O
bool	bool
ignore_sigpipe	bool
,	O
bool	bool
null_stderr	bool
,	O
bool	bool
slave_process	bool
,	O
bool	bool
exit_on_error	bool
,	O
int	O
*	O
termsigp	pointer
)	O
{	O
int	O
status	int
;	O
if	O
(	O
termsigp	pointer
!=	O
NULL	O
)	O
*	O
termsigp	pointer
=	O
0	int
;	O
status	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
result	int
=	O
waitpid	function
(	O
child	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
result	int
!=	O
child	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
exit_on_error	bool
||	O
!	O
null_stderr	bool
)	O
error	function
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
errno	O
,	O
_	O
(	O
"%s subprocess"	pointer
)	O
,	O
progname	pointer
)	O
;	O
return	O
127	int
;	O
}	O
if	O
(	O
!	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
slave_process	bool
)	O
unregister_slave_subprocess	function
(	O
child	int
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
if	O
(	O
termsigp	pointer
!=	O
NULL	O
)	O
*	O
termsigp	pointer
=	O
WTERMSIG	O
(	O
status	int
)	O
;	O
if	O
(	O
WTERMSIG	O
(	O
status	int
)	O
==	O
SIGPIPE	int
&&	O
ignore_sigpipe	bool
)	O
return	O
0	int
;	O
if	O
(	O
exit_on_error	bool
||	O
(	O
!	O
null_stderr	bool
&&	O
termsigp	pointer
==	O
NULL	O
)	O
)	O
error	function
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess got fatal signal %d"	pointer
)	O
,	O
progname	pointer
,	O
(	O
int	O
)	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
return	O
127	int
;	O
}	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
==	O
127	int
)	O
{	O
if	O
(	O
exit_on_error	bool
||	O
!	O
null_stderr	bool
)	O
error	function
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed"	pointer
)	O
,	O
progname	pointer
)	O
;	O
return	O
127	int
;	O
}	O
return	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
}	O