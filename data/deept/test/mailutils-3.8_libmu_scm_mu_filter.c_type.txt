static	O
void	O
argv_free	function
(	O
void	O
*	O
p	pointer
)	O
{	O
mu_argv_free	function
(	O
(	O
char	O
*	O
*	O
)	O
p	pointer
)	O
;	O
}	O
static	O
SCM	function
make_filter_port	function
(	O
SCM	function
port	int
,	O
SCM	function
name	pointer
,	O
SCM	function
args	array
,	O
int	O
filter_mode	int
,	O
char	O
const	O
*	O
func_name	pointer
)	O
{	O
char	O
*	O
fltname	pointer
;	O
mu_stream_t	pointer
filter	pointer
;	O
mu_stream_t	pointer
instr	pointer
;	O
size_t	long
argc	long
=	O
0	int
;	O
char	O
*	O
*	O
argv	pointer
=	O
NULL	O
;	O
int	O
rc	int
;	O
int	O
flags	int
=	O
0	int
;	O
char	O
*	O
port_mode	pointer
;	O
SCM_ASSERT	function
(	O
scm_port_p	function
(	O
port	pointer
)	O
,	O
port	int
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
name	pointer
)	O
,	O
name	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_VALIDATE_REST_ARGUMENT	function
(	O
args	pointer
)	O
;	O
port_mode	pointer
=	O
scm_to_locale_string	function
(	O
scm_port_mode	function
(	O
port	pointer
)	O
)	O
;	O
if	O
(	O
strchr	function
(	O
port_mode	pointer
,	O
'r'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_READ	int
;	O
if	O
(	O
strchr	function
(	O
port_mode	pointer
,	O
'w'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_WRITE	int
;	O
free	function
(	O
port_mode	pointer
)	O
;	O
if	O
(	O
!	O
flags	int
||	O
(	O
(	O
flags	int
&	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
==	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
)	O
scm_out_of_range	function
(	O
FUNC_NAME	O
,	O
port	int
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
fltname	pointer
=	O
scm_to_locale_string	function
(	O
name	pointer
)	O
;	O
scm_dynwind_free	function
(	O
fltname	pointer
)	O
;	O
rc	int
=	O
mu_scm_port_stream_create	function
(	O
&	O
instr	pointer
,	O
port	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to convert transport port ~A"	int
,	O
scm_list_1	function
(	O
port	pointer
)	O
)	O
;	O
}	O
if	O
(	O
!	O
scm_is_null	function
(	O
args	pointer
)	O
)	O
{	O
size_t	long
n	long
;	O
argc	int
=	O
scm_to_size_t	function
(	O
scm_length	function
(	O
args	pointer
)	O
)	O
+	O
1	int
;	O
argv	pointer
=	O
calloc	function
(	O
argc	int
+	O
1	int
,	O
sizeof	O
(	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
argv	pointer
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
ENOMEM	int
,	O
"Cannot allocate memory"	int
,	O
SCM_BOOL_F	O
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
strdup	function
(	O
fltname	pointer
)	O
;	O
n	long
=	O
1	int
;	O
for	O
(	O
;	O
!	O
scm_is_null	function
(	O
args	pointer
)	O
;	O
args	pointer
=	O
SCM_CDR	function
(	O
args	pointer
)	O
)	O
{	O
SCM	int
arg	pointer
=	O
SCM_CAR	function
(	O
args	pointer
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
arg	pointer
)	O
,	O
arg	pointer
,	O
SCM_ARGn	O
,	O
FUNC_NAME	O
)	O
;	O
argv	pointer
[	O
n	int
]	O
=	O
scm_to_locale_string	function
(	O
arg	pointer
)	O
;	O
n	int
++	O
;	O
}	O
argv	pointer
[	O
n	int
]	O
=	O
NULL	O
;	O
scm_dynwind_unwind_handler	function
(	O
argv_free	pointer
,	O
argv	pointer
,	O
SCM_F_WIND_EXPLICITLY	pointer
)	O
;	O
}	O
rc	int
=	O
mu_filter_create_args	function
(	O
&	O
filter	struct
,	O
instr	pointer
,	O
fltname	pointer
,	O
argc	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
filter_mode	int
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to create filter ~A"	int
,	O
scm_list_1	function
(	O
name	pointer
)	O
)	O
;	O
}	O
scm_dynwind_end	function
(	O
)	O
;	O
return	O
mu_port_make_from_stream	function
(	O
filter	int
,	O
flags	int
==	O
MU_STREAM_READ	int
?	O
SCM_RDNG	int
:	O
SCM_WRTNG	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_encoder_port	pointer
,	O
"mu-encoder-port"	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	function
port	int
,	O
SCM	function
name	pointer
,	O
SCM	function
args	array
)	O
,	O
"Create encoding port using Mailutils filter @var{name} with optional arguments\n"	int
"@var{args}. The @var{port} argument must be a port opened either for\n"	int
"writing or for reading, but not both. The returned port will have the same\n"	int
"mode as @var{port}."	pointer
"\n\n"	pointer
"If @var{port} is open for reading, data will be read from it, passed through the\n"	pointer
"filter and returned. If it is open for writing, data written to the returned\n"	O
"port will be passed through filter and its output will be written to @var{port}.\n"	pointer
)	O
{	O
return	O
make_filter_port	function
(	O
port	int
,	O
name	pointer
,	O
args	array
,	O
MU_FILTER_ENCODE	int
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_decoder_port	pointer
,	O
"mu-decoder-port"	int
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	function
port	int
,	O
SCM	function
name	pointer
,	O
SCM	function
args	array
)	O
,	O
"Create a decoding port using Mailutils filter @var{name} with optional arguments\n"	int
"@var{args}. The @var{port} argument must be a port opened either for\n"	int
"writing or for reading, but not both. The returned port will have the same\n"	int
"mode as @var{port}."	pointer
"\n\n"	pointer
"If @var{port} is open for reading, data will be read from it, passed through the\n"	pointer
"filter and returned. If it is open for writing, data written to the returned\n"	O
"port will be passed through filter and its output will be written to @var{port}.\n"	pointer
)	O
{	O
return	O
make_filter_port	function
(	O
port	int
,	O
name	pointer
,	O
args	array
,	O
MU_FILTER_DECODE	int
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_header_decode	pointer
,	O
"mu-header-decode"	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
(	O
SCM	function
hdr	pointer
,	O
SCM	function
charset	pointer
)	O
,	O
"Decode the header value @var{hdr}, encoded as per RFC 2047.\n"	int
"Optional @var{charset} defaults to @samp{utf-8}.\n"	int
)	O
{	O
char	O
*	O
c_hdr	pointer
,	O
*	O
c_charset	pointer
,	O
*	O
c_res	pointer
;	O
int	O
rc	int
;	O
SCM	function
res	pointer
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
hdr	pointer
)	O
,	O
hdr	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
charset	pointer
)	O
)	O
c_charset	int
=	O
"utf-8"	pointer
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
charset	pointer
)	O
,	O
charset	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_charset	int
=	O
scm_to_locale_string	function
(	O
charset	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_charset	pointer
)	O
;	O
}	O
c_hdr	int
=	O
scm_to_locale_string	function
(	O
hdr	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_hdr	pointer
)	O
;	O
rc	int
=	O
mu_rfc2047_decode	function
(	O
c_charset	pointer
,	O
c_hdr	int
,	O
&	O
c_res	struct
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't convert header value"	int
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	function
(	O
)	O
;	O
res	pointer
=	O
scm_from_locale_string	function
(	O
c_res	pointer
)	O
;	O
free	function
(	O
c_res	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_header_encode	pointer
,	O
"mu-header-encode"	int
,	O
1	int
,	O
2	int
,	O
0	int
,	O
(	O
SCM	function
hdr	pointer
,	O
SCM	function
encoding	pointer
,	O
SCM	function
charset	pointer
)	O
,	O
"Encode the string @var{hdr} as per RFC 2047.\n"	int
"Both @var{encoding} and @var{charset} are optional.\n"	int
"Allowed values for @var{encoding} are @samp{base64} and @samp{quoted-printable}.\n"	int
"Default is selected depending on number of printable characters in @var{hdr}.\n"	O
"Optional @var{charset} defaults to @samp{utf-8}.\n"	pointer
)	O
{	O
char	O
*	O
c_hdr	pointer
,	O
*	O
c_charset	pointer
,	O
*	O
c_encoding	pointer
,	O
*	O
c_res	pointer
;	O
int	O
rc	int
;	O
SCM	function
res	pointer
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
hdr	pointer
)	O
,	O
hdr	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
encoding	pointer
)	O
)	O
c_encoding	pointer
=	O
NULL	O
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
encoding	pointer
)	O
,	O
encoding	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_encoding	int
=	O
scm_to_locale_string	function
(	O
encoding	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_encoding	pointer
)	O
;	O
}	O
if	O
(	O
SCM_UNBNDP	function
(	O
charset	pointer
)	O
)	O
c_charset	int
=	O
"utf-8"	pointer
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
charset	pointer
)	O
,	O
charset	pointer
,	O
SCM_ARG3	int
,	O
FUNC_NAME	O
)	O
;	O
c_charset	int
=	O
scm_to_locale_string	function
(	O
charset	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_charset	pointer
)	O
;	O
}	O
c_hdr	int
=	O
scm_to_locale_string	function
(	O
hdr	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_hdr	pointer
)	O
;	O
if	O
(	O
!	O
c_encoding	int
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
c_hdr	pointer
)	O
;	O
size_t	long
i	long
,	O
enc	pointer
;	O
enc	pointer
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
mu_isprint	O
(	O
c_hdr	array
[	O
i	long
]	O
)	O
)	O
enc	pointer
++	O
;	O
c_encoding	pointer
=	O
(	O
enc	pointer
>	O
len	long
/	O
2	int
)	O
?	O
"base64"	int
:	O
"quoted-printable"	pointer
;	O
}	O
rc	int
=	O
mu_rfc2047_encode	function
(	O
c_charset	pointer
,	O
c_encoding	int
,	O
c_hdr	int
,	O
&	O
c_res	struct
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't encode header value"	int
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	function
(	O
)	O
;	O
res	pointer
=	O
scm_from_locale_string	function
(	O
c_res	pointer
)	O
;	O
free	function
(	O
c_res	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
void	O
mu_scm_filter_init	function
(	O
void	O
)	O
{	O
}	O