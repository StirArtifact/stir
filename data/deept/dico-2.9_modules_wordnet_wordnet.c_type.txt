struct	O
wndb	struct
{	O
char	O
*	O
dbname	pointer
;	O
int	O
flags	int
;	O
int	O
pos	int
;	O
int	O
optc	int
;	O
struct	O
wn_option	struct
*	O
*	O
optv	pointer
;	O
}	O
;	O
static	O
int	O
_dico_display_message	function
(	O
char	O
*	O
msg	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"WordNet: %s"	pointer
,	O
msg	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
wn_free_db	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
wndb	struct
*	O
wndb	struct
=	O
(	O
struct	O
wndb	struct
*	O
)	O
hp	pointer
;	O
free	function
(	O
wndb	struct
->	O
dbname	pointer
)	O
;	O
free	function
(	O
wndb	struct
->	O
optv	pointer
)	O
;	O
free	function
(	O
wndb	struct
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
wn_register_strategies	function
(	O
void	O
)	O
;	O
static	O
void	O
wn_free_result	function
(	O
dico_result_t	pointer
rp	pointer
)	O
;	O
static	O
int	O
wn_init	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
wnsearchdir	pointer
=	O
NULL	O
;	O
char	O
*	O
wnhome	pointer
=	O
NULL	O
;	O
struct	O
dico_option	struct
init_option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
wnsearchdir	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
wnsearchdir	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
wnhome	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
wnhome	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	function
(	O
init_option	array
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
display_message	O
=	O
_dico_display_message	function
;	O
if	O
(	O
wnhome	pointer
)	O
setenv	function
(	O
"WNHOME"	pointer
,	O
wnhome	pointer
,	O
1	int
)	O
;	O
if	O
(	O
wnsearchdir	pointer
)	O
setenv	function
(	O
"WNSEARCHDIR"	pointer
,	O
wnsearchdir	pointer
,	O
1	int
)	O
;	O
if	O
(	O
wninit	function
(	O
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot open wordnet database"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
wn_register_strategies	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
pos_choice	array
[	O
]	O
=	O
{	O
"all"	pointer
,	O
"noun"	pointer
,	O
"verb"	pointer
,	O
"adj"	pointer
,	O
"adjective"	pointer
,	O
"adv"	pointer
,	O
"adverb"	pointer
,	O
"satellite"	pointer
,	O
"adjsat"	pointer
,	O
NULL	O
}	O
;	O
static	O
int	O
pos_trans	array
[	O
]	O
=	O
{	O
ALL_POS	O
,	O
NOUN	O
,	O
VERB	O
,	O
ADJ	O
,	O
ADJ	O
,	O
ADV	O
,	O
ADV	O
,	O
ADJSAT	O
,	O
ADJSAT	O
}	O
;	O
struct	O
result	pointer
;	O
static	O
void	O
_wn_print_overview	function
(	O
struct	O
wn_option	struct
*	O
,	O
SynsetPtr	int
,	O
struct	O
result	pointer
*	O
res	pointer
,	O
dico_stream_t	pointer
)	O
;	O
static	O
void	O
_wn_print_definition	function
(	O
struct	O
wn_option	struct
*	O
opt	pointer
,	O
SynsetPtr	int
sp	int
,	O
struct	O
result	pointer
*	O
res	pointer
,	O
dico_stream_t	pointer
str	pointer
)	O
;	O
static	O
void	O
_wn_print_hypernym	function
(	O
struct	O
wn_option	struct
*	O
,	O
SynsetPtr	int
,	O
struct	O
result	pointer
*	O
res	pointer
,	O
dico_stream_t	pointer
)	O
;	O
struct	O
wn_option	struct
{	O
char	O
*	O
option	pointer
;	O
int	O
search	int
;	O
int	O
posmask	int
;	O
char	O
*	O
label	pointer
;	O
void	O
(	O
*	O
tracer	pointer
)	O
(	O
SynsetPtr	int
)	O
;	O
void	O
(	O
*	O
printer	pointer
)	O
(	O
struct	O
wn_option	struct
*	O
,	O
SynsetPtr	int
,	O
struct	O
result	pointer
*	O
,	O
dico_stream_t	pointer
)	O
;	O
}	O
;	O
static	O
struct	O
wn_option	struct
wn_optlist	array
[	O
]	O
=	O
{	O
{	O
"hypernym"	pointer
,	O
HYPERPTR	O
,	O
POS_MASK	O
(	O
NOUN	O
)	O
|	O
POS_MASK	O
(	O
VERB	O
)	O
,	O
"Synonyms/Hypernyms (Ordered by Estimated Frequency)"	pointer
,	O
NULL	O
,	O
_wn_print_hypernym	function
}	O
,	O
{	O
"synonym"	pointer
,	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
wn_option	struct
*	O
find_option	function
(	O
const	O
char	O
*	O
text	pointer
)	O
{	O
struct	O
wn_option	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
wn_optlist	array
;	O
p	pointer
->	O
option	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
option	pointer
,	O
text	pointer
)	O
==	O
0	int
)	O
return	O
p	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
dico_handle_t	pointer
wn_init_db	function
(	O
const	O
char	O
*	O
dbname	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
wndb	struct
*	O
wndb	struct
;	O
int	O
pos	int
=	O
0	int
;	O
int	O
idx	int
,	O
i	int
,	O
j	int
;	O
struct	O
wn_option	struct
*	O
*	O
optv	pointer
;	O
int	O
optc	int
;	O
int	O
flags	int
=	O
0	int
;	O
static	O
struct	O
wn_option	struct
overview	array
[	O
2	int
]	O
=	O
{	O
{	O
"overview"	pointer
,	O
OVERVIEW	O
,	O
PM_ALL	int
,	O
"Overview"	pointer
,	O
NULL	O
,	O
_wn_print_overview	function
}	O
,	O
{	O
"overview"	pointer
,	O
OVERVIEW	O
,	O
PM_ALL	int
,	O
"Overview"	pointer
,	O
NULL	O
,	O
_wn_print_definition	function
}	O
}	O
;	O
struct	O
dico_option	struct
init_db_option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
pos	int
)	O
,	O
dico_opt_enum	int
,	O
&	O
pos	int
,	O
{	O
.	O
enumstr	pointer
=	O
pos_choice	array
}	O
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
merge	O
-	O
defs	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
flags	int
,	O
{	O
.	O
value	pointer
=	O
WNDB_MERGE_DEFS	int
}	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	function
(	O
init_db_option	array
,	O
argc	int
,	O
argv	pointer
,	O
DICO_PARSEOPT_PERMUTE	int
,	O
&	O
idx	int
)	O
)	O
return	O
NULL	O
;	O
argc	int
-=	O
idx	int
;	O
argv	pointer
+=	O
idx	int
;	O
optc	int
=	O
argc	int
+	O
1	int
;	O
optv	pointer
=	O
calloc	function
(	O
optc	int
,	O
sizeof	O
(	O
optv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
optv	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
optv	pointer
[	O
0	int
]	O
=	O
overview	array
+	O
(	O
(	O
flags	int
&	O
WNDB_MERGE_DEFS	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
struct	O
wn_option	struct
*	O
p	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
find_option	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"wordnet: unknown option %s"	pointer
)	O
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
optv	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
while	O
(	O
p	pointer
->	O
search	int
==	O
0	int
&&	O
p	pointer
>	O
wn_optlist	array
)	O
p	pointer
--	O
;	O
if	O
(	O
!	O
p	pointer
->	O
printer	pointer
)	O
{	O
dico_log	function
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"wordnet: option %s is not yet supported"	pointer
)	O
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
continue	O
;	O
}	O
optv	pointer
[	O
j	int
]	O
=	O
p	pointer
;	O
}	O
wndb	struct
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
wndb	struct
)	O
)	O
;	O
if	O
(	O
!	O
wndb	struct
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	function
(	O
optv	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
wndb	struct
->	O
dbname	pointer
=	O
strdup	function
(	O
dbname	pointer
)	O
;	O
if	O
(	O
!	O
wndb	struct
->	O
dbname	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	function
(	O
wndb	struct
)	O
;	O
return	O
NULL	O
;	O
}	O
wndb	struct
->	O
flags	int
=	O
flags	int
;	O
wndb	struct
->	O
pos	int
=	O
pos_trans	array
[	O
pos	int
]	O
;	O
wndb	struct
->	O
optc	int
=	O
optc	int
;	O
wndb	struct
->	O
optv	pointer
=	O
optv	pointer
;	O
return	O
(	O
dico_handle_t	pointer
)	O
wndb	struct
;	O
}	O
static	O
char	O
*	O
wn_descr	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
return	O
strdup	function
(	O
"WordNet dictionary"	pointer
)	O
;	O
}	O
static	O
char	O
*	O
wn_info	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
return	O
strdup	function
(	O
license	O
)	O
;	O
}	O
static	O
int	O
wn_lang	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
dico_list_t	pointer
list	array
[	O
2	int
]	O
)	O
{	O
if	O
(	O
(	O
list	array
[	O
0	int
]	O
=	O
dico_list_create	function
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
list	array
[	O
1	int
]	O
=	O
dico_list_create	function
(	O
)	O
)	O
==	O
NULL	O
)	O
{	O
dico_list_destroy	function
(	O
&	O
list	array
[	O
0	int
]	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
dico_list_append	function
(	O
list	array
[	O
0	int
]	O
,	O
strdup	function
(	O
"en"	pointer
)	O
)	O
;	O
dico_list_append	function
(	O
list	array
[	O
1	int
]	O
,	O
strdup	function
(	O
"en"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
wordbuf	pointer
{	O
char	O
*	O
word	pointer
;	O
size_t	long
len	int
;	O
size_t	long
size	long
;	O
}	O
;	O
static	O
int	O
wordbuf_expand	function
(	O
struct	O
wordbuf	pointer
*	O
wb	pointer
,	O
size_t	long
len	int
)	O
{	O
if	O
(	O
len	int
>=	O
wb	pointer
->	O
size	long
)	O
{	O
size_t	long
size	long
=	O
(	O
(	O
len	int
+	O
WORDBUFINC	int
-	O
1	int
)	O
/	O
WORDBUFINC	int
)	O
*	O
WORDBUFINC	int
;	O
char	O
*	O
newword	pointer
=	O
realloc	function
(	O
wb	pointer
->	O
word	pointer
,	O
size	long
)	O
;	O
if	O
(	O
!	O
newword	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
wb	pointer
->	O
word	pointer
=	O
newword	pointer
;	O
wb	pointer
->	O
size	long
=	O
size	long
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
wordbuf_grow	function
(	O
struct	O
wordbuf	pointer
*	O
wb	pointer
,	O
int	O
c	int
)	O
{	O
if	O
(	O
wordbuf_expand	function
(	O
wb	pointer
,	O
wb	pointer
->	O
len	int
+	O
1	int
)	O
)	O
return	O
1	int
;	O
wb	pointer
->	O
word	pointer
[	O
wb	pointer
->	O
len	int
++	O
]	O
=	O
c	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
wordbuf_finish	function
(	O
struct	O
wordbuf	pointer
*	O
wb	pointer
)	O
{	O
if	O
(	O
wordbuf_expand	function
(	O
wb	pointer
,	O
wb	pointer
->	O
len	int
+	O
1	int
)	O
)	O
return	O
1	int
;	O
wb	pointer
->	O
word	pointer
[	O
wb	pointer
->	O
len	int
]	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
wordbuf_reverse	function
(	O
struct	O
wordbuf	pointer
*	O
wb	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
wb	pointer
->	O
len	int
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
wb	pointer
->	O
len	int
-	O
1	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
,	O
j	int
--	O
)	O
{	O
int	O
c	int
=	O
wb	pointer
->	O
word	pointer
[	O
j	int
]	O
;	O
wb	pointer
->	O
word	pointer
[	O
j	int
]	O
=	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
;	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
=	O
c	int
;	O
}	O
}	O
enum	O
result_type	enum
{	O
result_match	int
,	O
result_define	int
}	O
;	O
struct	O
defn	struct
{	O
int	O
pos	int
;	O
SynsetPtr	int
*	O
synset	pointer
;	O
}	O
;	O
struct	O
result	pointer
{	O
enum	O
result_type	enum
type	enum
;	O
size_t	long
compare_count	long
;	O
struct	O
wndb	struct
*	O
wndb	struct
;	O
dico_list_t	pointer
list	array
;	O
dico_iterator_t	pointer
itr	pointer
;	O
char	O
*	O
searchword	pointer
;	O
dico_list_t	pointer
rootlist	pointer
;	O
}	O
;	O
static	O
int	O
free_defn	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
defn	struct
*	O
dp	pointer
=	O
item	pointer
;	O
free	function
(	O
dp	pointer
->	O
synset	pointer
)	O
;	O
free	function
(	O
dp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_root_synset	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
free_syns	function
(	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_string	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
free	function
(	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
compare_words	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
return	O
utf8_strcasecmp	function
(	O
(	O
char	O
*	O
)	O
a	pointer
,	O
(	O
char	O
*	O
)	O
b	pointer
)	O
;	O
}	O
static	O
struct	O
result	pointer
*	O
wn_create_match_result	function
(	O
struct	O
wndb	struct
*	O
wndb	struct
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
;	O
res	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
res	pointer
)	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
res	pointer
->	O
type	enum
=	O
result_match	int
;	O
res	pointer
->	O
wndb	struct
=	O
wndb	struct
;	O
res	pointer
->	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	function
(	O
res	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
dico_list_set_free_item	function
(	O
res	pointer
->	O
list	array
,	O
free_string	function
,	O
NULL	O
)	O
;	O
dico_list_set_comparator	function
(	O
res	pointer
->	O
list	array
,	O
compare_words	function
,	O
NULL	O
)	O
;	O
dico_list_set_flags	function
(	O
res	pointer
->	O
list	array
,	O
DICO_LIST_COMPARE_TAIL	int
)	O
;	O
return	O
res	pointer
;	O
}	O
static	O
struct	O
result	pointer
*	O
wn_create_define_result	function
(	O
struct	O
wndb	struct
*	O
wndb	struct
,	O
const	O
char	O
*	O
searchword	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
;	O
res	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
res	pointer
)	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
res	pointer
->	O
type	enum
=	O
result_define	int
;	O
res	pointer
->	O
wndb	struct
=	O
wndb	struct
;	O
res	pointer
->	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	function
(	O
res	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
dico_list_set_free_item	function
(	O
res	pointer
->	O
list	array
,	O
free_defn	function
,	O
NULL	O
)	O
;	O
res	pointer
->	O
searchword	pointer
=	O
strdup	function
(	O
searchword	pointer
)	O
;	O
if	O
(	O
!	O
res	pointer
->	O
searchword	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
wn_free_result	function
(	O
(	O
dico_result_t	pointer
)	O
res	pointer
)	O
;	O
}	O
res	pointer
->	O
rootlist	pointer
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
res	pointer
->	O
rootlist	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
wn_free_result	function
(	O
(	O
dico_result_t	pointer
)	O
res	pointer
)	O
;	O
}	O
dico_list_set_free_item	function
(	O
res	pointer
->	O
rootlist	pointer
,	O
free_root_synset	function
,	O
NULL	O
)	O
;	O
return	O
res	pointer
;	O
}	O
static	O
int	O
wn_match_result_add	function
(	O
struct	O
result	pointer
*	O
res	pointer
,	O
const	O
char	O
*	O
hw	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
s	pointer
=	O
strdup	function
(	O
hw	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
dico_list_insert_sorted	function
(	O
res	pointer
->	O
list	array
,	O
s	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	function
(	O
s	pointer
)	O
;	O
if	O
(	O
rc	int
!=	O
EEXIST	int
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
skipeol	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
fp	pointer
)	O
)	O
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
;	O
}	O
static	O
void	O
skipheader	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
fp	pointer
)	O
)	O
==	O
' '	O
)	O
skipeol	function
(	O
fp	pointer
)	O
;	O
ungetc	function
(	O
c	int
,	O
fp	pointer
)	O
;	O
}	O
static	O
int	O
getword	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
wordbuf	pointer
*	O
wb	pointer
)	O
{	O
int	O
c	int
;	O
size_t	long
i	int
;	O
wordbuf_start	O
(	O
wb	pointer
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
fp	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	int
==	O
' '	O
)	O
break	O
;	O
if	O
(	O
wordbuf_grow	function
(	O
wb	pointer
,	O
c	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
wb	pointer
->	O
len	int
==	O
0	int
&&	O
c	int
==	O
EOF	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
wordbuf_finish	function
(	O
wb	pointer
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
==	O
'_'	O
)	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
=	O
' '	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
lineback	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
wordbuf	pointer
*	O
wb	pointer
)	O
{	O
int	O
c	int
,	O
i	int
;	O
wordbuf_start	O
(	O
wb	pointer
)	O
;	O
while	O
(	O
fseek	function
(	O
fp	pointer
,	O
-	O
2	int
,	O
SEEK_CUR	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
c	int
=	O
getc	function
(	O
fp	pointer
)	O
)	O
==	O
'\n'	O
)	O
break	O
;	O
if	O
(	O
wordbuf_grow	function
(	O
wb	pointer
,	O
c	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
wordbuf_finish	function
(	O
wb	pointer
)	O
)	O
return	O
-	O
1	int
;	O
wordbuf_reverse	function
(	O
wb	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
==	O
' '	O
)	O
break	O
;	O
else	O
if	O
(	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
==	O
'_'	O
)	O
wb	pointer
->	O
word	pointer
[	O
i	int
]	O
=	O
' '	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
wn_is_defined	function
(	O
struct	O
wndb	struct
*	O
wndb	struct
,	O
char	O
*	O
searchword	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
unsigned	O
int	O
search	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
NUMPARTS	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
search	int
=	O
is_defined	function
(	O
searchword	pointer
,	O
i	int
)	O
)	O
!=	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
wndb	struct
->	O
optc	int
;	O
j	int
++	O
)	O
{	O
int	O
n	long
;	O
if	O
(	O
!	O
(	O
POS_MASK	O
(	O
i	int
)	O
&	O
wndb	struct
->	O
optv	pointer
[	O
j	int
]	O
->	O
posmask	int
)	O
)	O
continue	O
;	O
n	long
=	O
wndb	struct
->	O
optv	pointer
[	O
j	int
]	O
->	O
search	int
;	O
if	O
(	O
n	long
<	O
0	int
)	O
n	long
=	O
-	O
n	long
;	O
if	O
(	O
bit	function
(	O
n	long
)	O
&	O
search	int
)	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
wn_foreach_db	function
(	O
struct	O
wndb	struct
*	O
wndb	struct
,	O
int	O
dbn	int
,	O
char	O
*	O
searchword	pointer
,	O
struct	O
dico_key	struct
*	O
key	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
indexfps	O
[	O
dbn	int
]	O
;	O
struct	O
wordbuf	pointer
wb	pointer
=	O
INIT_WORDBUF	O
;	O
dico_iterator_t	pointer
itr	pointer
;	O
char	O
*	O
word	pointer
;	O
fseek	function
(	O
fp	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
for	O
(	O
skipheader	function
(	O
fp	pointer
)	O
;	O
getword	function
(	O
fp	pointer
,	O
&	O
wb	pointer
)	O
==	O
0	int
;	O
skipeol	function
(	O
fp	pointer
)	O
)	O
{	O
res	pointer
->	O
compare_count	long
++	O
;	O
if	O
(	O
dico_key_match	function
(	O
key	pointer
,	O
wb	pointer
.	O
word	pointer
)	O
)	O
{	O
if	O
(	O
wn_match_result_add	function
(	O
res	pointer
,	O
wb	pointer
.	O
word	pointer
)	O
)	O
break	O
;	O
}	O
}	O
free	function
(	O
wb	pointer
.	O
word	pointer
)	O
;	O
itr	pointer
=	O
dico_list_iterator	function
(	O
res	pointer
->	O
list	array
)	O
;	O
for	O
(	O
word	pointer
=	O
dico_iterator_first	function
(	O
itr	pointer
)	O
;	O
word	pointer
;	O
word	pointer
=	O
dico_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
!	O
wn_is_defined	function
(	O
wndb	struct
,	O
word	pointer
)	O
)	O
dico_iterator_remove_current	function
(	O
itr	pointer
,	O
NULL	O
)	O
;	O
}	O
dico_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
static	O
struct	O
result	pointer
*	O
wn_foreach	function
(	O
struct	O
wndb	struct
*	O
wndb	struct
,	O
const	O
dico_strategy_t	pointer
strat	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
wn_create_match_result	function
(	O
wndb	struct
)	O
;	O
struct	O
dico_key	struct
key	pointer
;	O
char	O
*	O
searchword	pointer
;	O
searchword	pointer
=	O
strdup	function
(	O
word	pointer
)	O
;	O
strtolower	function
(	O
strsubst	function
(	O
searchword	pointer
,	O
' '	O
,	O
'_'	O
)	O
)	O
;	O
if	O
(	O
!	O
searchword	pointer
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
wn_free_result	function
(	O
(	O
dico_result_t	pointer
)	O
res	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dico_key_init	function
(	O
&	O
key	pointer
,	O
strat	pointer
,	O
word	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: key initialization failed"	pointer
)	O
,	O
__func__	O
)	O
;	O
wn_free_result	function
(	O
(	O
dico_result_t	pointer
)	O
res	pointer
)	O
;	O
free	function
(	O
searchword	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
wndb	struct
->	O
pos	int
==	O
ALL_POS	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
NUMPARTS	O
;	O
i	int
++	O
)	O
wn_foreach_db	function
(	O
wndb	struct
,	O
i	int
,	O
searchword	pointer
,	O
&	O
key	pointer
,	O
res	pointer
)	O
;	O
}	O
else	O
wn_foreach_db	function
(	O
wndb	struct
,	O
wndb	struct
->	O
pos	int
,	O
searchword	pointer
,	O
&	O
key	pointer
,	O
res	pointer
)	O
;	O
dico_key_deinit	function
(	O
&	O
key	pointer
)	O
;	O
free	function
(	O
searchword	pointer
)	O
;	O
if	O
(	O
dico_list_count	function
(	O
res	pointer
->	O
list	array
)	O
==	O
0	int
)	O
{	O
wn_free_result	function
(	O
(	O
dico_result_t	pointer
)	O
res	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
res	pointer
;	O
}	O
static	O
off_t	long
wn_bsearch	function
(	O
FILE	struct
*	O
fp	pointer
,	O
void	O
*	O
key	pointer
,	O
int	O
(	O
*	O
cmp	pointer
)	O
(	O
const	O
char	O
*	O
a	pointer
,	O
void	O
*	O
b	pointer
)	O
)	O
{	O
long	O
top	long
,	O
mid	long
,	O
bot	long
,	O
diff	long
;	O
struct	O
wordbuf	pointer
wb	pointer
=	O
INIT_WORDBUF	O
;	O
off_t	long
last_match	long
=	O
-	O
1	int
;	O
fseek	function
(	O
fp	pointer
,	O
0L	int
,	O
SEEK_END	int
)	O
;	O
top	long
=	O
0	int
;	O
bot	long
=	O
ftell	function
(	O
fp	pointer
)	O
;	O
mid	long
=	O
(	O
bot	long
-	O
top	long
)	O
/	O
2	int
;	O
do	O
{	O
fseek	function
(	O
fp	pointer
,	O
mid	long
-	O
1	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
mid	long
!=	O
1	int
)	O
skipeol	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
getword	function
(	O
fp	pointer
,	O
&	O
wb	pointer
)	O
)	O
break	O
;	O
if	O
(	O
cmp	pointer
(	O
wb	pointer
.	O
word	pointer
,	O
key	pointer
)	O
<	O
0	int
)	O
{	O
top	long
=	O
mid	long
;	O
diff	long
=	O
(	O
bot	long
-	O
top	long
)	O
/	O
2	int
;	O
mid	long
=	O
top	long
+	O
diff	long
;	O
}	O
else	O
if	O
(	O
cmp	pointer
(	O
wb	pointer
.	O
word	pointer
,	O
key	pointer
)	O
>	O
0	int
)	O
{	O
bot	long
=	O
mid	long
;	O
diff	long
=	O
(	O
bot	long
-	O
top	long
)	O
/	O
2	int
;	O
mid	long
=	O
top	long
+	O
diff	long
;	O
}	O
else	O
{	O
do	O
last_match	long
=	O
ftell	function
(	O
fp	pointer
)	O
;	O
while	O
(	O
lineback	function
(	O
fp	pointer
,	O
&	O
wb	pointer
)	O
==	O
0	int
&&	O
cmp	pointer
(	O
wb	pointer
.	O
word	pointer
,	O
key	pointer
)	O
==	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
diff	long
)	O
;	O
free	function
(	O
wb	pointer
.	O
word	pointer
)	O
;	O
return	O
last_match	long
;	O
}	O
static	O
struct	O
result	pointer
*	O
wn_exact_match	function
(	O
struct	O
wndb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
hw	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
;	O
if	O
(	O
!	O
wn_is_defined	function
(	O
db	pointer
,	O
(	O
char	O
*	O
)	O
hw	pointer
)	O
)	O
return	O
NULL	O
;	O
res	pointer
=	O
wn_create_match_result	function
(	O
db	pointer
)	O
;	O
dico_list_append	function
(	O
res	pointer
->	O
list	array
,	O
strdup	function
(	O
hw	pointer
)	O
)	O
;	O
return	O
res	pointer
;	O
}	O
struct	O
prefix	struct
{	O
const	O
char	O
*	O
str	pointer
;	O
size_t	long
len	int
;	O
}	O
;	O
static	O
int	O
cmp_pref	function
(	O
const	O
char	O
*	O
hw	pointer
,	O
void	O
*	O
key	pointer
)	O
{	O
struct	O
prefix	struct
*	O
pref	pointer
=	O
key	pointer
;	O
return	O
strncasecmp	function
(	O
hw	pointer
,	O
pref	pointer
->	O
str	pointer
,	O
pref	pointer
->	O
len	int
)	O
;	O
}	O
static	O
struct	O
result	pointer
*	O
wn_prefix_match	function
(	O
struct	O
wndb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
hw	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
;	O
int	O
i	int
;	O
struct	O
prefix	struct
pfx	struct
;	O
struct	O
wordbuf	pointer
wb	pointer
=	O
INIT_WORDBUF	O
;	O
res	pointer
=	O
wn_create_match_result	function
(	O
db	pointer
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
return	O
NULL	O
;	O
pfx	struct
.	O
str	pointer
=	O
hw	pointer
;	O
pfx	struct
.	O
len	int
=	O
strlen	function
(	O
hw	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
NUMPARTS	O
;	O
i	int
++	O
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
indexfps	O
[	O
i	int
]	O
;	O
off_t	long
off	long
;	O
off	long
=	O
wn_bsearch	function
(	O
fp	pointer
,	O
&	O
pfx	struct
,	O
cmp_pref	function
)	O
;	O
if	O
(	O
off	long
!=	O
-	O
1	int
)	O
{	O
fseek	function
(	O
fp	pointer
,	O
off	long
,	O
SEEK_SET	int
)	O
;	O
for	O
(	O
;	O
getword	function
(	O
fp	pointer
,	O
&	O
wb	pointer
)	O
==	O
0	int
&&	O
cmp_pref	function
(	O
wb	pointer
.	O
word	pointer
,	O
&	O
pfx	struct
)	O
==	O
0	int
;	O
skipeol	function
(	O
fp	pointer
)	O
)	O
{	O
if	O
(	O
wn_match_result_add	function
(	O
res	pointer
,	O
wb	pointer
.	O
word	pointer
)	O
)	O
break	O
;	O
}	O
}	O
}	O
free	function
(	O
wb	pointer
.	O
word	pointer
)	O
;	O
if	O
(	O
dico_list_count	function
(	O
res	pointer
->	O
list	array
)	O
==	O
0	int
)	O
{	O
wn_free_result	function
(	O
(	O
dico_result_t	pointer
)	O
res	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
res	pointer
;	O
}	O
typedef	O
struct	O
result	pointer
*	O
(	O
*	O
wn_matcher_t	pointer
)	O
(	O
struct	O
wndb	struct
*	O
db	pointer
,	O
const	O
char	O
*	O
hw	pointer
)	O
;	O
struct	O
strategy_def	struct
{	O
struct	O
dico_strategy	struct
strat	pointer
;	O
wn_matcher_t	pointer
matcher	pointer
;	O
}	O
;	O
static	O
struct	O
strategy_def	struct
stratdef	array
[	O
]	O
=	O
{	O
{	O
{	O
"exact"	pointer
,	O
"Match words exactly"	pointer
}	O
,	O
wn_exact_match	function
}	O
,	O
{	O
{	O
"prefix"	pointer
,	O
"Match word prefixes"	pointer
}	O
,	O
wn_prefix_match	function
}	O
,	O
}	O
;	O
static	O
wn_matcher_t	pointer
wn_find_matcher	function
(	O
const	O
char	O
*	O
strat	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
stratdef	array
)	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
strat	pointer
,	O
stratdef	array
[	O
i	int
]	O
.	O
strat	pointer
.	O
name	pointer
)	O
==	O
0	int
)	O
return	O
stratdef	array
[	O
i	int
]	O
.	O
matcher	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
wn_register_strategies	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
stratdef	array
)	O
;	O
i	int
++	O
)	O
dico_strategy_add	function
(	O
&	O
stratdef	array
[	O
i	int
]	O
.	O
strat	pointer
)	O
;	O
}	O
static	O
char	O
*	O
nornmalize_search_word	function
(	O
const	O
char	O
*	O
word	pointer
)	O
{	O
char	O
*	O
copy	pointer
=	O
NULL	O
;	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
q	pointer
;	O
copy	pointer
=	O
malloc	function
(	O
strlen	function
(	O
word	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
copy	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
p	pointer
=	O
copy	pointer
,	O
q	pointer
=	O
word	pointer
;	O
*	O
q	pointer
;	O
)	O
{	O
if	O
(	O
ISSPACE	O
(	O
*	O
q	pointer
)	O
)	O
{	O
*	O
p	pointer
++	O
=	O
'_'	O
;	O
do	O
q	pointer
++	O
;	O
while	O
(	O
*	O
q	pointer
&&	O
ISSPACE	O
(	O
*	O
q	pointer
)	O
)	O
;	O
}	O
else	O
*	O
p	pointer
++	O
=	O
*	O
q	pointer
++	O
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
strtolower	function
(	O
copy	pointer
)	O
;	O
return	O
copy	pointer
;	O
}	O
static	O
dico_result_t	pointer
wn_match	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
const	O
dico_strategy_t	pointer
strat	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
wndb	struct
*	O
wndb	struct
=	O
(	O
struct	O
wndb	struct
*	O
)	O
hp	pointer
;	O
wn_matcher_t	pointer
match	pointer
=	O
wn_find_matcher	function
(	O
strat	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
match	pointer
)	O
return	O
(	O
dico_result_t	pointer
)	O
match	pointer
(	O
wndb	struct
,	O
word	pointer
)	O
;	O
else	O
if	O
(	O
strat	pointer
->	O
sel	pointer
)	O
return	O
(	O
dico_result_t	pointer
)	O
wn_foreach	function
(	O
wndb	struct
,	O
strat	pointer
,	O
word	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
defn	struct
*	O
create_defn	function
(	O
struct	O
wndb	struct
*	O
wndb	struct
,	O
int	O
pos	int
)	O
{	O
struct	O
defn	struct
*	O
p	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
p	pointer
->	O
synset	pointer
=	O
calloc	function
(	O
wndb	struct
->	O
optc	int
,	O
sizeof	O
(	O
p	pointer
->	O
synset	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
p	pointer
->	O
synset	pointer
)	O
{	O
DICO_LOG_ERRNO	O
(	O
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
p	pointer
->	O
pos	int
=	O
pos	int
;	O
return	O
p	pointer
;	O
}	O
static	O
int	O
search_defns	function
(	O
struct	O
wndb	struct
*	O
wndb	struct
,	O
int	O
pos	int
,	O
struct	O
result	pointer
*	O
res	pointer
,	O
const	O
char	O
*	O
searchword	pointer
)	O
{	O
SynsetPtr	int
sp	int
;	O
int	O
i	int
;	O
struct	O
defn	struct
*	O
dp	pointer
;	O
int	O
sense	int
=	O
0	int
;	O
sp	int
=	O
findtheinfo_ds	function
(	O
(	O
char	O
*	O
)	O
searchword	pointer
,	O
pos	int
,	O
OVERVIEW	O
,	O
ALLSENSES	O
)	O
;	O
if	O
(	O
!	O
sp	int
)	O
return	O
0	int
;	O
dico_list_append	function
(	O
res	pointer
->	O
rootlist	pointer
,	O
sp	int
)	O
;	O
do	O
{	O
dp	pointer
=	O
create_defn	function
(	O
wndb	struct
,	O
pos	int
)	O
;	O
if	O
(	O
!	O
dp	pointer
)	O
return	O
0	int
;	O
dp	pointer
->	O
synset	pointer
[	O
0	int
]	O
=	O
sp	int
;	O
++	O
sense	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
wndb	struct
->	O
optc	int
;	O
i	int
++	O
)	O
{	O
SynsetPtr	int
ssp	O
;	O
if	O
(	O
!	O
(	O
POS_MASK	O
(	O
pos	int
)	O
&	O
wndb	struct
->	O
optv	pointer
[	O
i	int
]	O
->	O
posmask	int
)	O
)	O
continue	O
;	O
ssp	O
=	O
findtheinfo_ds	function
(	O
(	O
char	O
*	O
)	O
searchword	pointer
,	O
pos	int
,	O
wndb	struct
->	O
optv	pointer
[	O
i	int
]	O
->	O
search	int
,	O
sense	int
)	O
;	O
if	O
(	O
ssp	O
)	O
dp	pointer
->	O
synset	pointer
[	O
i	int
]	O
=	O
ssp	O
;	O
}	O
dico_list_append	function
(	O
res	pointer
->	O
list	array
,	O
dp	pointer
)	O
;	O
}	O
while	O
(	O
(	O
sp	int
=	O
sp	int
->	O
nextss	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
dico_result_t	pointer
wn_define	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
wndb	struct
*	O
wndb	struct
=	O
(	O
struct	O
wndb	struct
*	O
)	O
hp	pointer
;	O
struct	O
result	pointer
*	O
res	pointer
;	O
int	O
i	int
;	O
int	O
found	int
=	O
0	int
;	O
char	O
*	O
copy	pointer
;	O
res	pointer
=	O
wn_create_define_result	function
(	O
wndb	struct
,	O
word	pointer
)	O
;	O
copy	pointer
=	O
nornmalize_search_word	function
(	O
word	pointer
)	O
;	O
if	O
(	O
!	O
copy	pointer
)	O
{	O
wn_free_result	function
(	O
(	O
dico_result_t	pointer
)	O
res	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
res	pointer
->	O
wndb	struct
=	O
wndb	struct
;	O
res	pointer
->	O
type	enum
=	O
result_define	int
;	O
if	O
(	O
wndb	struct
->	O
pos	int
==	O
ALL_POS	O
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
NUMPARTS	O
;	O
i	int
++	O
)	O
found	int
+=	O
search_defns	function
(	O
wndb	struct
,	O
i	int
,	O
res	pointer
,	O
copy	pointer
)	O
;	O
}	O
else	O
found	int
=	O
search_defns	function
(	O
wndb	struct
,	O
wndb	struct
->	O
pos	int
,	O
res	pointer
,	O
copy	pointer
)	O
;	O
if	O
(	O
!	O
found	int
)	O
{	O
free	function
(	O
copy	pointer
)	O
;	O
wn_free_result	function
(	O
(	O
dico_result_t	pointer
)	O
res	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
free	function
(	O
copy	pointer
)	O
;	O
return	O
(	O
dico_result_t	pointer
)	O
res	pointer
;	O
}	O
static	O
void	O
format_word	function
(	O
const	O
char	O
*	O
word	pointer
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
len	int
=	O
strcspn	function
(	O
word	pointer
,	O
"_"	pointer
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
word	pointer
,	O
len	int
)	O
;	O
if	O
(	O
word	pointer
[	O
len	int
]	O
==	O
0	int
)	O
break	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
" "	pointer
,	O
1	int
)	O
;	O
word	pointer
+=	O
len	int
+	O
1	int
;	O
}	O
}	O
static	O
void	O
format_defn_string	function
(	O
const	O
char	O
*	O
defn	struct
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
defn	struct
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
defn	struct
[	O
0	int
]	O
==	O
'('	O
&&	O
defn	struct
[	O
len	int
-	O
1	int
]	O
==	O
')'	O
)	O
{	O
defn	struct
++	O
;	O
len	int
-=	O
2	int
;	O
}	O
dico_stream_write	function
(	O
str	pointer
,	O
defn	struct
,	O
len	int
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
}	O
static	O
void	O
_wn_print_overview	function
(	O
struct	O
wn_option	struct
*	O
opt	pointer
,	O
SynsetPtr	int
sp	int
,	O
struct	O
result	pointer
*	O
res	pointer
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sp	int
->	O
wcount	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
)	O
dico_stream_write	function
(	O
str	pointer
,	O
", "	pointer
,	O
2	int
)	O
;	O
format_word	function
(	O
sp	int
->	O
words	O
[	O
i	int
]	O
,	O
str	pointer
)	O
;	O
}	O
dico_stream_write	function
(	O
str	pointer
,	O
"; "	pointer
,	O
2	int
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
sp	int
->	O
pos	int
,	O
strlen	function
(	O
sp	int
->	O
pos	int
)	O
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
".\n\n"	pointer
,	O
3	int
)	O
;	O
format_defn_string	function
(	O
sp	int
->	O
defn	struct
,	O
str	pointer
)	O
;	O
}	O
static	O
void	O
_wn_print_definition	function
(	O
struct	O
wn_option	struct
*	O
opt	pointer
,	O
SynsetPtr	int
sp	int
,	O
struct	O
result	pointer
*	O
res	pointer
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
format_defn_string	function
(	O
sp	int
->	O
defn	struct
,	O
str	pointer
)	O
;	O
if	O
(	O
sp	int
->	O
wcount	O
>	O
1	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
static	O
char	O
const	O
*	O
sym	pointer
=	O
"Synonyms: "	pointer
;	O
dico_stream_write	function
(	O
str	pointer
,	O
sym	pointer
,	O
strlen	function
(	O
sym	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
j	int
=	O
0	int
;	O
i	int
<	O
sp	int
->	O
wcount	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
sp	int
->	O
words	O
[	O
i	int
]	O
,	O
res	pointer
->	O
searchword	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
j	int
)	O
dico_stream_write	function
(	O
str	pointer
,	O
", "	pointer
,	O
2	int
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
"{"	pointer
,	O
1	int
)	O
;	O
format_word	function
(	O
sp	int
->	O
words	O
[	O
i	int
]	O
,	O
str	pointer
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
"}"	pointer
,	O
1	int
)	O
;	O
j	int
++	O
;	O
}	O
dico_stream_write	function
(	O
str	pointer
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
_wn_print_hypernym	function
(	O
struct	O
wn_option	struct
*	O
opt	pointer
,	O
SynsetPtr	int
ptr	pointer
,	O
struct	O
result	pointer
*	O
res	pointer
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
int	O
i	int
;	O
SynsetPtr	int
sp	int
;	O
dico_stream_write	function
(	O
str	pointer
,	O
opt	pointer
->	O
label	pointer
,	O
strlen	function
(	O
opt	pointer
->	O
label	pointer
)	O
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
":\n\n"	pointer
,	O
3	int
)	O
;	O
for	O
(	O
sp	int
=	O
ptr	pointer
->	O
ptrlist	O
;	O
sp	int
;	O
sp	int
=	O
sp	int
->	O
nextss	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sp	int
->	O
wcount	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
)	O
dico_stream_write	function
(	O
str	pointer
,	O
", "	pointer
,	O
2	int
)	O
;	O
format_word	function
(	O
sp	int
->	O
words	O
[	O
i	int
]	O
,	O
str	pointer
)	O
;	O
}	O
dico_stream_write	function
(	O
str	pointer
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
format_defn	function
(	O
struct	O
defn	struct
*	O
defn	struct
,	O
struct	O
result	pointer
*	O
res	pointer
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
int	O
i	int
;	O
struct	O
wndb	struct
*	O
wndb	struct
=	O
res	pointer
->	O
wndb	struct
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wndb	struct
->	O
optc	int
;	O
i	int
++	O
)	O
wndb	struct
->	O
optv	pointer
[	O
i	int
]	O
->	O
printer	pointer
(	O
wndb	struct
->	O
optv	pointer
[	O
i	int
]	O
,	O
defn	struct
->	O
synset	pointer
[	O
i	int
]	O
,	O
res	pointer
,	O
str	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_num	function
(	O
dico_stream_t	pointer
str	pointer
,	O
unsigned	O
num	int
)	O
{	O
char	O
buf	pointer
[	O
128	int
]	O
;	O
char	O
*	O
p	pointer
=	O
buf	pointer
+	O
sizeof	O
(	O
buf	pointer
)	O
;	O
*	O
--	O
p	pointer
=	O
0	int
;	O
while	O
(	O
p	pointer
>	O
buf	pointer
&&	O
num	int
)	O
{	O
*	O
--	O
p	pointer
=	O
num	int
%	O
10	int
+	O
'0'	O
;	O
num	int
/=	O
10	int
;	O
}	O
dico_stream_write	function
(	O
str	pointer
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
". "	pointer
,	O
2	int
)	O
;	O
}	O
static	O
void	O
format_all_defns	function
(	O
struct	O
result	pointer
*	O
res	pointer
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
struct	O
defn	struct
*	O
defn	struct
;	O
int	O
pos	int
=	O
0	int
;	O
unsigned	O
num	int
;	O
format_word	function
(	O
res	pointer
->	O
searchword	pointer
,	O
str	pointer
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
for	O
(	O
defn	struct
=	O
dico_iterator_first	function
(	O
res	pointer
->	O
itr	pointer
)	O
;	O
defn	struct
;	O
defn	struct
=	O
dico_iterator_next	function
(	O
res	pointer
->	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
defn	struct
->	O
pos	int
!=	O
pos	int
)	O
{	O
pos	int
=	O
defn	struct
->	O
pos	int
;	O
num	int
=	O
1	int
;	O
dico_stream_write	function
(	O
str	pointer
,	O
defn	struct
->	O
synset	pointer
[	O
0	int
]	O
->	O
pos	int
,	O
strlen	function
(	O
defn	struct
->	O
synset	pointer
[	O
0	int
]	O
->	O
pos	int
)	O
)	O
;	O
dico_stream_write	function
(	O
str	pointer
,	O
". "	pointer
,	O
2	int
)	O
;	O
}	O
print_num	function
(	O
str	pointer
,	O
num	int
)	O
;	O
format_defn	function
(	O
defn	struct
,	O
res	pointer
,	O
str	pointer
)	O
;	O
num	int
++	O
;	O
}	O
}	O
int	O
wn_output_result	function
(	O
dico_result_t	pointer
rp	pointer
,	O
size_t	long
n	long
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
void	O
*	O
item	pointer
;	O
if	O
(	O
!	O
res	pointer
->	O
itr	pointer
)	O
{	O
res	pointer
->	O
itr	pointer
=	O
dico_list_iterator	function
(	O
res	pointer
->	O
list	array
)	O
;	O
if	O
(	O
!	O
res	pointer
->	O
itr	pointer
)	O
return	O
1	int
;	O
}	O
item	pointer
=	O
dico_iterator_item	function
(	O
res	pointer
->	O
itr	pointer
,	O
n	long
)	O
;	O
switch	O
(	O
res	pointer
->	O
type	enum
)	O
{	O
case	O
result_match	int
:	O
dico_stream_write	function
(	O
str	pointer
,	O
item	pointer
,	O
strlen	function
(	O
(	O
char	O
*	O
)	O
item	pointer
)	O
)	O
;	O
break	O
;	O
case	O
result_define	int
:	O
if	O
(	O
res	pointer
->	O
wndb	struct
->	O
flags	int
&	O
WNDB_MERGE_DEFS	int
)	O
format_all_defns	function
(	O
res	pointer
,	O
str	pointer
)	O
;	O
else	O
format_defn	function
(	O
item	pointer
,	O
res	pointer
,	O
str	pointer
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	long
wn_result_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
if	O
(	O
res	pointer
->	O
type	enum
==	O
result_define	int
&&	O
(	O
res	pointer
->	O
wndb	struct
->	O
flags	int
&	O
WNDB_MERGE_DEFS	int
)	O
)	O
return	O
1	int
;	O
return	O
dico_list_count	function
(	O
res	pointer
->	O
list	array
)	O
;	O
}	O
static	O
size_t	long
wn_compare_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
return	O
res	pointer
->	O
compare_count	long
;	O
}	O
static	O
void	O
wn_free_result	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
result	pointer
*	O
res	pointer
=	O
(	O
struct	O
result	pointer
*	O
)	O
rp	pointer
;	O
dico_list_destroy	function
(	O
&	O
res	pointer
->	O
list	array
)	O
;	O
dico_iterator_destroy	function
(	O
&	O
res	pointer
->	O
itr	pointer
)	O
;	O
dico_list_destroy	function
(	O
&	O
res	pointer
->	O
rootlist	pointer
)	O
;	O
free	function
(	O
res	pointer
->	O
searchword	pointer
)	O
;	O
free	function
(	O
res	pointer
)	O
;	O
}	O
struct	O
dico_database_module	struct
DICO_EXPORT	O
(	O
wordnet	O
,	O
module	O
)	O
=	O
{	O
DICO_MODULE_VERSION	int
,	O
DICO_CAPA_NONE	int
,	O
wn_init	function
,	O
wn_init_db	function
,	O
wn_free_db	function
,	O
NULL	O
,	O
NULL	O
,	O
wn_info	function
,	O
wn_descr	function
,	O
wn_lang	function
,	O
wn_match	function
,	O
wn_define	function
,	O
wn_output_result	function
,	O
wn_result_count	function
,	O
wn_compare_count	function
,	O
wn_free_result	function
}	O
;	O
