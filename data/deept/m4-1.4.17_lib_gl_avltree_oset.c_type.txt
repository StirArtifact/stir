struct	O
gl_oset_node_impl	struct
{	O
struct	O
gl_oset_node_impl	struct
*	O
left	pointer
;	O
struct	O
gl_oset_node_impl	struct
*	O
right	pointer
;	O
struct	O
gl_oset_node_impl	struct
*	O
parent	pointer
;	O
int	O
balance	int
;	O
const	O
void	O
*	O
value	pointer
;	O
}	O
;	O
typedef	O
struct	O
gl_oset_node_impl	struct
*	O
gl_oset_node_t	pointer
;	O
struct	O
gl_oset_impl	struct
{	O
struct	O
gl_oset_impl_base	struct
base	struct
;	O
struct	O
gl_oset_node_impl	struct
*	O
root	pointer
;	O
size_t	long
count	long
;	O
}	O
;	O
static	O
void	O
rebalance	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
node	pointer
,	O
int	O
height_diff	int
,	O
gl_oset_node_t	pointer
parent	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
gl_oset_node_t	pointer
child	pointer
;	O
int	O
previous_balance	int
;	O
int	O
balance_diff	int
;	O
gl_oset_node_t	pointer
nodeleft	pointer
;	O
gl_oset_node_t	pointer
noderight	pointer
;	O
child	pointer
=	O
node	pointer
;	O
node	pointer
=	O
parent	pointer
;	O
previous_balance	int
=	O
node	pointer
->	O
balance	int
;	O
if	O
(	O
node	pointer
->	O
left	pointer
!=	O
NULL	O
||	O
node	pointer
->	O
right	pointer
!=	O
NULL	O
)	O
balance_diff	int
=	O
(	O
child	pointer
==	O
node	pointer
->	O
right	pointer
?	O
height_diff	int
:	O
-	O
height_diff	int
)	O
;	O
else	O
balance_diff	int
=	O
-	O
previous_balance	int
;	O
node	pointer
->	O
balance	int
+=	O
balance_diff	int
;	O
if	O
(	O
balance_diff	int
==	O
previous_balance	int
)	O
{	O
gl_oset_node_t	pointer
*	O
nodep	pointer
;	O
if	O
(	O
node	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
nodep	pointer
=	O
&	O
set	pointer
->	O
root	pointer
;	O
else	O
if	O
(	O
node	pointer
->	O
parent	pointer
->	O
left	pointer
==	O
node	pointer
)	O
nodep	pointer
=	O
&	O
node	pointer
->	O
parent	pointer
->	O
left	pointer
;	O
else	O
if	O
(	O
node	pointer
->	O
parent	pointer
->	O
right	pointer
==	O
node	pointer
)	O
nodep	pointer
=	O
&	O
node	pointer
->	O
parent	pointer
->	O
right	pointer
;	O
else	O
abort	function
(	O
)	O
;	O
nodeleft	pointer
=	O
node	pointer
->	O
left	pointer
;	O
noderight	pointer
=	O
node	pointer
->	O
right	pointer
;	O
if	O
(	O
balance_diff	int
<	O
0	int
)	O
{	O
gl_oset_node_t	pointer
nodeleftright	pointer
=	O
nodeleft	pointer
->	O
right	pointer
;	O
if	O
(	O
nodeleft	pointer
->	O
balance	int
<=	O
0	int
)	O
{	O
node	pointer
->	O
left	pointer
=	O
nodeleftright	pointer
;	O
nodeleft	pointer
->	O
right	pointer
=	O
node	pointer
;	O
nodeleft	pointer
->	O
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
node	pointer
->	O
parent	pointer
=	O
nodeleft	pointer
;	O
if	O
(	O
nodeleftright	pointer
!=	O
NULL	O
)	O
nodeleftright	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
nodeleft	pointer
->	O
balance	int
+=	O
1	int
;	O
node	pointer
->	O
balance	int
=	O
-	O
nodeleft	pointer
->	O
balance	int
;	O
*	O
nodep	pointer
=	O
nodeleft	pointer
;	O
height_diff	int
=	O
(	O
height_diff	int
<	O
0	int
?	O
nodeleft	pointer
->	O
balance	int
-	O
1	int
:	O
nodeleft	pointer
->	O
balance	int
)	O
;	O
}	O
else	O
{	O
gl_oset_node_t	pointer
L	pointer
=	O
nodeleft	pointer
->	O
right	pointer
=	O
nodeleftright	pointer
->	O
left	pointer
;	O
gl_oset_node_t	pointer
R	pointer
=	O
node	pointer
->	O
left	pointer
=	O
nodeleftright	pointer
->	O
right	pointer
;	O
nodeleftright	pointer
->	O
left	pointer
=	O
nodeleft	pointer
;	O
nodeleftright	pointer
->	O
right	pointer
=	O
node	pointer
;	O
nodeleftright	pointer
->	O
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
if	O
(	O
L	pointer
!=	O
NULL	O
)	O
L	pointer
->	O
parent	pointer
=	O
nodeleft	pointer
;	O
if	O
(	O
R	pointer
!=	O
NULL	O
)	O
R	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
nodeleft	pointer
->	O
parent	pointer
=	O
nodeleftright	pointer
;	O
node	pointer
->	O
parent	pointer
=	O
nodeleftright	pointer
;	O
nodeleft	pointer
->	O
balance	int
=	O
(	O
nodeleftright	pointer
->	O
balance	int
>	O
0	int
?	O
-	O
1	int
:	O
0	int
)	O
;	O
node	pointer
->	O
balance	int
=	O
(	O
nodeleftright	pointer
->	O
balance	int
<	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
nodeleftright	pointer
->	O
balance	int
=	O
0	int
;	O
*	O
nodep	pointer
=	O
nodeleftright	pointer
;	O
height_diff	int
=	O
(	O
height_diff	int
<	O
0	int
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
gl_oset_node_t	pointer
noderightleft	pointer
=	O
noderight	pointer
->	O
left	pointer
;	O
if	O
(	O
noderight	pointer
->	O
balance	int
>=	O
0	int
)	O
{	O
node	pointer
->	O
right	pointer
=	O
noderightleft	pointer
;	O
noderight	pointer
->	O
left	pointer
=	O
node	pointer
;	O
noderight	pointer
->	O
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
node	pointer
->	O
parent	pointer
=	O
noderight	pointer
;	O
if	O
(	O
noderightleft	pointer
!=	O
NULL	O
)	O
noderightleft	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
noderight	pointer
->	O
balance	int
-=	O
1	int
;	O
node	pointer
->	O
balance	int
=	O
-	O
noderight	pointer
->	O
balance	int
;	O
*	O
nodep	pointer
=	O
noderight	pointer
;	O
height_diff	int
=	O
(	O
height_diff	int
<	O
0	int
?	O
-	O
noderight	pointer
->	O
balance	int
-	O
1	int
:	O
-	O
noderight	pointer
->	O
balance	int
)	O
;	O
}	O
else	O
{	O
gl_oset_node_t	pointer
L	pointer
=	O
node	pointer
->	O
right	pointer
=	O
noderightleft	pointer
->	O
left	pointer
;	O
gl_oset_node_t	pointer
R	pointer
=	O
noderight	pointer
->	O
left	pointer
=	O
noderightleft	pointer
->	O
right	pointer
;	O
noderightleft	pointer
->	O
left	pointer
=	O
node	pointer
;	O
noderightleft	pointer
->	O
right	pointer
=	O
noderight	pointer
;	O
noderightleft	pointer
->	O
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
if	O
(	O
L	pointer
!=	O
NULL	O
)	O
L	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
if	O
(	O
R	pointer
!=	O
NULL	O
)	O
R	pointer
->	O
parent	pointer
=	O
noderight	pointer
;	O
node	pointer
->	O
parent	pointer
=	O
noderightleft	pointer
;	O
noderight	pointer
->	O
parent	pointer
=	O
noderightleft	pointer
;	O
node	pointer
->	O
balance	int
=	O
(	O
noderightleft	pointer
->	O
balance	int
>	O
0	int
?	O
-	O
1	int
:	O
0	int
)	O
;	O
noderight	pointer
->	O
balance	int
=	O
(	O
noderightleft	pointer
->	O
balance	int
<	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
noderightleft	pointer
->	O
balance	int
=	O
0	int
;	O
*	O
nodep	pointer
=	O
noderightleft	pointer
;	O
height_diff	int
=	O
(	O
height_diff	int
<	O
0	int
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
}	O
node	pointer
=	O
*	O
nodep	pointer
;	O
}	O
else	O
{	O
if	O
(	O
height_diff	int
<	O
0	int
)	O
height_diff	int
=	O
(	O
previous_balance	int
==	O
0	int
?	O
0	int
:	O
-	O
1	int
)	O
;	O
else	O
height_diff	int
=	O
(	O
node	pointer
->	O
balance	int
==	O
0	int
?	O
0	int
:	O
1	int
)	O
;	O
}	O
if	O
(	O
height_diff	int
==	O
0	int
)	O
break	O
;	O
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
break	O
;	O
}	O
}	O
static	O
gl_oset_node_t	pointer
gl_tree_nx_add_first	function
(	O
gl_oset_t	pointer
set	pointer
,	O
const	O
void	O
*	O
elt	pointer
)	O
{	O
gl_oset_node_t	pointer
new_node	pointer
=	O
(	O
struct	O
gl_oset_node_impl	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct
)	O
)	O
;	O
if	O
(	O
new_node	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	pointer
->	O
left	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
right	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
balance	int
=	O
0	int
;	O
new_node	pointer
->	O
value	pointer
=	O
elt	pointer
;	O
if	O
(	O
set	pointer
->	O
root	pointer
==	O
NULL	O
)	O
{	O
set	pointer
->	O
root	pointer
=	O
new_node	pointer
;	O
new_node	pointer
->	O
parent	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
gl_oset_node_t	pointer
node	pointer
;	O
for	O
(	O
node	pointer
=	O
set	pointer
->	O
root	pointer
;	O
node	pointer
->	O
left	pointer
!=	O
NULL	O
;	O
)	O
node	pointer
=	O
node	pointer
->	O
left	pointer
;	O
node	pointer
->	O
left	pointer
=	O
new_node	pointer
;	O
new_node	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
node	pointer
->	O
balance	int
--	O
;	O
if	O
(	O
node	pointer
->	O
right	pointer
==	O
NULL	O
&&	O
node	pointer
->	O
parent	pointer
!=	O
NULL	O
)	O
rebalance	function
(	O
set	pointer
,	O
node	pointer
,	O
1	int
,	O
node	pointer
->	O
parent	pointer
)	O
;	O
}	O
set	pointer
->	O
count	long
++	O
;	O
return	O
new_node	pointer
;	O
}	O
static	O
gl_oset_node_t	pointer
gl_tree_nx_add_before	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
node	pointer
,	O
const	O
void	O
*	O
elt	pointer
)	O
{	O
gl_oset_node_t	pointer
new_node	pointer
=	O
(	O
struct	O
gl_oset_node_impl	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct
)	O
)	O
;	O
bool	bool
height_inc	bool
;	O
if	O
(	O
new_node	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	pointer
->	O
left	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
right	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
balance	int
=	O
0	int
;	O
new_node	pointer
->	O
value	pointer
=	O
elt	pointer
;	O
if	O
(	O
node	pointer
->	O
left	pointer
==	O
NULL	O
)	O
{	O
node	pointer
->	O
left	pointer
=	O
new_node	pointer
;	O
node	pointer
->	O
balance	int
--	O
;	O
height_inc	bool
=	O
(	O
node	pointer
->	O
right	pointer
==	O
NULL	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
node	pointer
=	O
node	pointer
->	O
left	pointer
;	O
node	pointer
->	O
right	pointer
!=	O
NULL	O
;	O
)	O
node	pointer
=	O
node	pointer
->	O
right	pointer
;	O
node	pointer
->	O
right	pointer
=	O
new_node	pointer
;	O
node	pointer
->	O
balance	int
++	O
;	O
height_inc	bool
=	O
(	O
node	pointer
->	O
left	pointer
==	O
NULL	O
)	O
;	O
}	O
new_node	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
if	O
(	O
height_inc	bool
&&	O
node	pointer
->	O
parent	pointer
!=	O
NULL	O
)	O
rebalance	function
(	O
set	pointer
,	O
node	pointer
,	O
1	int
,	O
node	pointer
->	O
parent	pointer
)	O
;	O
set	pointer
->	O
count	long
++	O
;	O
return	O
new_node	pointer
;	O
}	O
static	O
gl_oset_node_t	pointer
gl_tree_nx_add_after	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
node	pointer
,	O
const	O
void	O
*	O
elt	pointer
)	O
{	O
gl_oset_node_t	pointer
new_node	pointer
=	O
(	O
struct	O
gl_oset_node_impl	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct
)	O
)	O
;	O
bool	bool
height_inc	bool
;	O
if	O
(	O
new_node	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	pointer
->	O
left	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
right	pointer
=	O
NULL	O
;	O
new_node	pointer
->	O
balance	int
=	O
0	int
;	O
new_node	pointer
->	O
value	pointer
=	O
elt	pointer
;	O
if	O
(	O
node	pointer
->	O
right	pointer
==	O
NULL	O
)	O
{	O
node	pointer
->	O
right	pointer
=	O
new_node	pointer
;	O
node	pointer
->	O
balance	int
++	O
;	O
height_inc	bool
=	O
(	O
node	pointer
->	O
left	pointer
==	O
NULL	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
node	pointer
=	O
node	pointer
->	O
right	pointer
;	O
node	pointer
->	O
left	pointer
!=	O
NULL	O
;	O
)	O
node	pointer
=	O
node	pointer
->	O
left	pointer
;	O
node	pointer
->	O
left	pointer
=	O
new_node	pointer
;	O
node	pointer
->	O
balance	int
--	O
;	O
height_inc	bool
=	O
(	O
node	pointer
->	O
right	pointer
==	O
NULL	O
)	O
;	O
}	O
new_node	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
if	O
(	O
height_inc	bool
&&	O
node	pointer
->	O
parent	pointer
!=	O
NULL	O
)	O
rebalance	function
(	O
set	pointer
,	O
node	pointer
,	O
1	int
,	O
node	pointer
->	O
parent	pointer
)	O
;	O
set	pointer
->	O
count	long
++	O
;	O
return	O
new_node	pointer
;	O
}	O
static	O
bool	bool
gl_tree_remove_node	function
(	O
gl_oset_t	pointer
set	pointer
,	O
gl_oset_node_t	pointer
node	pointer
)	O
{	O
gl_oset_node_t	pointer
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
if	O
(	O
node	pointer
->	O
left	pointer
==	O
NULL	O
)	O
{	O
gl_oset_node_t	pointer
child	pointer
=	O
node	pointer
->	O
right	pointer
;	O
if	O
(	O
child	pointer
!=	O
NULL	O
)	O
child	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
set	pointer
->	O
root	pointer
=	O
child	pointer
;	O
else	O
{	O
if	O
(	O
parent	pointer
->	O
left	pointer
==	O
node	pointer
)	O
parent	pointer
->	O
left	pointer
=	O
child	pointer
;	O
else	O
parent	pointer
->	O
right	pointer
=	O
child	pointer
;	O
rebalance	function
(	O
set	pointer
,	O
child	pointer
,	O
-	O
1	int
,	O
parent	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
node	pointer
->	O
right	pointer
==	O
NULL	O
)	O
{	O
gl_oset_node_t	pointer
child	pointer
=	O
node	pointer
->	O
left	pointer
;	O
child	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
set	pointer
->	O
root	pointer
=	O
child	pointer
;	O
else	O
{	O
if	O
(	O
parent	pointer
->	O
left	pointer
==	O
node	pointer
)	O
parent	pointer
->	O
left	pointer
=	O
child	pointer
;	O
else	O
parent	pointer
->	O
right	pointer
=	O
child	pointer
;	O
rebalance	function
(	O
set	pointer
,	O
child	pointer
,	O
-	O
1	int
,	O
parent	pointer
)	O
;	O
}	O
}	O
else	O
{	O
gl_oset_node_t	pointer
subst	pointer
;	O
gl_oset_node_t	pointer
subst_parent	pointer
;	O
gl_oset_node_t	pointer
child	pointer
;	O
for	O
(	O
subst	pointer
=	O
node	pointer
->	O
left	pointer
;	O
subst	pointer
->	O
right	pointer
!=	O
NULL	O
;	O
)	O
subst	pointer
=	O
subst	pointer
->	O
right	pointer
;	O
subst_parent	pointer
=	O
subst	pointer
->	O
parent	pointer
;	O
child	pointer
=	O
subst	pointer
->	O
left	pointer
;	O
if	O
(	O
subst_parent	pointer
!=	O
node	pointer
)	O
{	O
if	O
(	O
child	pointer
!=	O
NULL	O
)	O
child	pointer
->	O
parent	pointer
=	O
subst_parent	pointer
;	O
subst_parent	pointer
->	O
right	pointer
=	O
child	pointer
;	O
}	O
if	O
(	O
subst_parent	pointer
!=	O
node	pointer
)	O
{	O
subst	pointer
->	O
left	pointer
=	O
node	pointer
->	O
left	pointer
;	O
subst	pointer
->	O
left	pointer
->	O
parent	pointer
=	O
subst	pointer
;	O
}	O
subst	pointer
->	O
right	pointer
=	O
node	pointer
->	O
right	pointer
;	O
subst	pointer
->	O
right	pointer
->	O
parent	pointer
=	O
subst	pointer
;	O
subst	pointer
->	O
balance	int
=	O
node	pointer
->	O
balance	int
;	O
subst	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
set	pointer
->	O
root	pointer
=	O
subst	pointer
;	O
else	O
if	O
(	O
parent	pointer
->	O
left	pointer
==	O
node	pointer
)	O
parent	pointer
->	O
left	pointer
=	O
subst	pointer
;	O
else	O
parent	pointer
->	O
right	pointer
=	O
subst	pointer
;	O
rebalance	function
(	O
set	pointer
,	O
child	pointer
,	O
-	O
1	int
,	O
subst_parent	pointer
!=	O
node	pointer
?	O
subst_parent	pointer
:	O
subst	pointer
)	O
;	O
}	O
set	pointer
->	O
count	long
--	O
;	O
if	O
(	O
set	pointer
->	O
base	struct
.	O
dispose_fn	pointer
!=	O
NULL	O
)	O
set	pointer
->	O
base	struct
.	O
dispose_fn	pointer
(	O
node	pointer
->	O
value	pointer
)	O
;	O
free	function
(	O
node	pointer
)	O
;	O
return	O
true	int
;	O
}	O
static	O
unsigned	O
int	O
check_invariants	function
(	O
gl_oset_node_t	pointer
node	pointer
,	O
gl_oset_node_t	pointer
parent	pointer
,	O
size_t	long
*	O
counterp	pointer
)	O
{	O
unsigned	O
int	O
left_height	int
=	O
(	O
node	pointer
->	O
left	pointer
!=	O
NULL	O
?	O
check_invariants	function
(	O
node	pointer
->	O
left	pointer
,	O
node	pointer
,	O
counterp	pointer
)	O
:	O
0	int
)	O
;	O
unsigned	O
int	O
right_height	int
=	O
(	O
node	pointer
->	O
right	pointer
!=	O
NULL	O
?	O
check_invariants	function
(	O
node	pointer
->	O
right	pointer
,	O
node	pointer
,	O
counterp	pointer
)	O
:	O
0	int
)	O
;	O
int	O
balance	int
=	O
(	O
int	O
)	O
right_height	int
-	O
(	O
int	O
)	O
left_height	int
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
parent	pointer
==	O
parent	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
balance	int
>=	O
-	O
1	int
&&	O
balance	int
<=	O
1	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
node	pointer
->	O
balance	int
==	O
balance	int
)	O
)	O
abort	function
(	O
)	O
;	O
(	O
*	O
counterp	pointer
)	O
++	O
;	O
return	O
1	int
+	O
(	O
left_height	int
>	O
right_height	int
?	O
left_height	int
:	O
right_height	int
)	O
;	O
}	O
void	O
gl_avltree_oset_check_invariants	function
(	O
gl_oset_t	pointer
set	pointer
)	O
{	O
size_t	long
counter	long
=	O
0	int
;	O
if	O
(	O
set	pointer
->	O
root	pointer
!=	O
NULL	O
)	O
check_invariants	function
(	O
set	pointer
->	O
root	pointer
,	O
NULL	O
,	O
&	O
counter	long
)	O
;	O
if	O
(	O
!	O
(	O
set	pointer
->	O
count	long
==	O
counter	long
)	O
)	O
abort	function
(	O
)	O
;	O
}	O
const	O
struct	O
gl_oset_implementation	struct
gl_avltree_oset_implementation	struct
=	O
{	O
gl_tree_nx_create_empty	function
,	O
gl_tree_size	function
,	O
gl_tree_search	function
,	O
gl_tree_search_atleast	function
,	O
gl_tree_nx_add	function
,	O
gl_tree_remove	function
,	O
gl_tree_oset_free	function
,	O
gl_tree_iterator	function
,	O
gl_tree_iterator_next	function
,	O
gl_tree_iterator_free	function
}	O
;	O
