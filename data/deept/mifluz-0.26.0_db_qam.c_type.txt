static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: qam.c,v 1.4 2014/04/17 20:27:33 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__qam_c_close	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_pgno_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__qam_c_del	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__qam_c_destroy	function
__P	O
(	O
(	O
DBC	struct
*	O
)	O
)	O
;	O
static	O
int	O
__qam_c_get	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
db_pgno_t	int
*	O
)	O
)	O
;	O
static	O
int	O
__qam_c_put	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
,	O
db_pgno_t	int
*	O
)	O
)	O
;	O
static	O
int	O
__qam_getno	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
const	O
DBT	struct
*	O
,	O
db_recno_t	int
*	O
)	O
)	O
;	O
static	O
int	O
__qam_nrecs	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_recno_t	int
*	O
,	O
db_recno_t	int
*	O
)	O
)	O
;	O
static	O
int	O
__qam_position	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
db_recno_t	int
*	O
,	O
db_lockmode_t	enum
,	O
db_recno_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__qam_nrecs	function
(	O
dbc	pointer
,	O
rep	pointer
,	O
start	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
*	O
rep	pointer
,	O
*	O
start	int
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
lock	struct
;	O
QMETA	struct
*	O
meta	pointer
;	O
db_pgno_t	int
pg	struct
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
pg	struct
=	O
(	O
(	O
QUEUE	struct
*	O
)	O
dbp	pointer
->	O
q_internal	pointer
)	O
->	O
q_meta	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
DB_LOCK_READ	int
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
meta	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
*	O
rep	pointer
=	O
meta	pointer
->	O
cur_recno	int
;	O
*	O
start	int
=	O
meta	pointer
->	O
start	int
;	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
meta	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__qam_position	function
(	O
dbc	pointer
,	O
recnop	pointer
,	O
lock_mode	enum
,	O
start	int
,	O
exactp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_recno_t	int
*	O
recnop	pointer
;	O
db_lockmode_t	enum
lock_mode	enum
;	O
db_recno_t	int
start	int
;	O
int	O
*	O
exactp	pointer
;	O
{	O
QUEUE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
QAMDATA	struct
*	O
qp	pointer
;	O
db_pgno_t	int
pg	struct
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
pg	struct
=	O
QAM_RECNO_PAGE	O
(	O
dbp	pointer
,	O
start	int
,	O
*	O
recnop	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
cp	pointer
->	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
lock_mode	enum
==	O
DB_LOCK_WRITE	int
?	O
DB_MPOOL_CREATE	int
:	O
0	int
,	O
&	O
cp	pointer
->	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
cp	pointer
->	O
pgno	int
=	O
pg	struct
;	O
cp	pointer
->	O
indx	short
=	O
QAM_RECNO_INDEX	O
(	O
dbp	pointer
,	O
pg	struct
,	O
start	int
,	O
*	O
recnop	pointer
)	O
;	O
if	O
(	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
)	O
{	O
*	O
exactp	pointer
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
=	O
pg	struct
;	O
TYPE_SET	O
(	O
cp	pointer
->	O
page	pointer
,	O
P_QAMDATA	int
)	O
;	O
}	O
qp	pointer
=	O
QAM_GET_RECORD	O
(	O
dbp	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
)	O
;	O
*	O
exactp	pointer
=	O
F_ISSET	O
(	O
qp	pointer
,	O
QAM_VALID	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___qam_pitem	function
(	O
dbc	pointer
,	O
pagep	pointer
,	O
indx	short
,	O
recno	int
,	O
data	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
QPAGE	struct
*	O
pagep	pointer
;	O
u_int32_t	int
indx	short
;	O
db_recno_t	int
recno	int
;	O
DBT	struct
*	O
data	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
olddata	struct
,	O
pdata	struct
,	O
*	O
datap	pointer
;	O
QAMDATA	struct
*	O
qp	pointer
;	O
QUEUE	struct
*	O
t	pointer
;	O
u_int8_t	char
*	O
dest	pointer
,	O
*	O
p	pointer
;	O
int	O
alloced	int
,	O
ret	int
;	O
alloced	int
=	O
ret	int
=	O
0	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
t	pointer
=	O
(	O
QUEUE	struct
*	O
)	O
dbp	pointer
->	O
q_internal	pointer
;	O
if	O
(	O
data	pointer
->	O
size	int
>	O
t	pointer
->	O
re_len	int
)	O
goto	O
len_err	O
;	O
qp	pointer
=	O
QAM_GET_RECORD	O
(	O
dbp	pointer
,	O
pagep	pointer
,	O
indx	short
)	O
;	O
p	pointer
=	O
qp	pointer
->	O
data	pointer
;	O
datap	pointer
=	O
data	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
data	pointer
,	O
DB_DBT_PARTIAL	int
)	O
)	O
{	O
if	O
(	O
data	pointer
->	O
doff	int
+	O
data	pointer
->	O
dlen	int
>	O
t	pointer
->	O
re_len	int
)	O
{	O
alloced	int
=	O
data	pointer
->	O
dlen	int
;	O
goto	O
len_err	O
;	O
}	O
if	O
(	O
data	pointer
->	O
size	int
!=	O
data	pointer
->	O
dlen	int
)	O
{	O
len_err	O
:	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Length improper for fixed length record %lu"	pointer
,	O
(	O
u_long	long
)	O
(	O
alloced	int
?	O
(	O
u_long	long
)	O
alloced	int
:	O
(	O
u_long	long
)	O
data	pointer
->	O
size	int
)	O
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
data	pointer
->	O
size	int
==	O
t	pointer
->	O
re_len	int
)	O
goto	O
no_partial	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
||	O
!	O
F_ISSET	O
(	O
qp	pointer
,	O
QAM_VALID	int
)	O
)	O
{	O
datap	pointer
=	O
&	O
pdata	struct
;	O
memset	function
(	O
datap	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
datap	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
t	pointer
->	O
re_len	int
,	O
NULL	O
,	O
&	O
datap	pointer
->	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
alloced	int
=	O
1	int
;	O
datap	pointer
->	O
size	int
=	O
t	pointer
->	O
re_len	int
;	O
dest	pointer
=	O
datap	pointer
->	O
data	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
qp	pointer
,	O
QAM_VALID	int
)	O
)	O
memcpy	function
(	O
dest	pointer
,	O
p	pointer
,	O
t	pointer
->	O
re_len	int
)	O
;	O
else	O
memset	function
(	O
dest	pointer
,	O
t	pointer
->	O
re_pad	int
,	O
t	pointer
->	O
re_len	int
)	O
;	O
dest	pointer
+=	O
data	pointer
->	O
doff	int
;	O
memcpy	function
(	O
dest	pointer
,	O
data	pointer
->	O
data	pointer
,	O
data	pointer
->	O
size	int
)	O
;	O
}	O
else	O
{	O
datap	pointer
=	O
data	pointer
;	O
p	pointer
+=	O
data	pointer
->	O
doff	int
;	O
}	O
}	O
no_partial	O
:	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
olddata	struct
.	O
size	int
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
qp	pointer
,	O
QAM_SET	int
)	O
)	O
{	O
olddata	struct
.	O
data	pointer
=	O
qp	pointer
->	O
data	pointer
;	O
olddata	struct
.	O
size	int
=	O
t	pointer
->	O
re_len	int
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___qam_add_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
pagep	pointer
->	O
pgno	int
,	O
indx	short
,	O
recno	int
,	O
datap	pointer
,	O
qp	pointer
->	O
flags	int
,	O
olddata	struct
.	O
size	int
==	O
0	int
?	O
NULL	O
:	O
&	O
olddata	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
F_SET	O
(	O
qp	pointer
,	O
QAM_VALID	int
|	O
QAM_SET	int
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
datap	pointer
->	O
data	pointer
,	O
datap	pointer
->	O
size	int
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
data	pointer
,	O
DB_DBT_PARTIAL	int
)	O
)	O
memset	function
(	O
p	pointer
+	O
datap	pointer
->	O
size	int
,	O
t	pointer
->	O
re_pad	int
,	O
t	pointer
->	O
re_len	int
-	O
datap	pointer
->	O
size	int
)	O
;	O
err	pointer
:	O
if	O
(	O
alloced	int
)	O
CDB___os_free	function
(	O
datap	pointer
->	O
data	pointer
,	O
t	pointer
->	O
re_len	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__qam_c_put	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
if	O
(	O
key	struct
)	O
{	O
}	O
QUEUE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
lock	struct
;	O
QMETA	struct
*	O
meta	pointer
;	O
db_pgno_t	int
pg	struct
;	O
db_recno_t	int
new_cur	int
,	O
new_first	int
;	O
u_int32_t	int
opcode	int
;	O
int	O
exact	int
,	O
ret	int
,	O
t_ret	int
;	O
COMPQUIET	O
(	O
key	struct
,	O
NULL	O
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
pgnop	pointer
!=	O
NULL	O
)	O
*	O
pgnop	pointer
=	O
PGNO_INVALID	int
;	O
cp	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
cp	pointer
->	O
recno	int
,	O
DB_LOCK_WRITE	int
,	O
DB_LOCK_RECORD	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__qam_position	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
recno	int
,	O
DB_LOCK_WRITE	int
,	O
cp	pointer
->	O
start	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
{	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
exact	int
&&	O
flags	int
==	O
DB_NOOVERWRITE	int
)	O
{	O
ret	int
=	O
__TLPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
)	O
==	O
0	int
)	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
else	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
return	O
(	O
ret	int
==	O
0	int
?	O
DB_KEYEXIST	O
:	O
ret	int
)	O
;	O
}	O
ret	int
=	O
CDB___qam_pitem	function
(	O
dbc	pointer
,	O
(	O
QPAGE	struct
*	O
)	O
cp	pointer
->	O
page	pointer
,	O
cp	pointer
->	O
indx	short
,	O
cp	pointer
->	O
recno	int
,	O
data	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
cp	pointer
->	O
lock	struct
=	O
lock	struct
;	O
cp	pointer
->	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
pg	struct
=	O
(	O
(	O
QUEUE	struct
*	O
)	O
dbp	pointer
->	O
q_internal	pointer
)	O
->	O
q_meta	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
meta	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
opcode	int
=	O
0	int
;	O
new_cur	int
=	O
new_first	int
=	O
0	int
;	O
if	O
(	O
cp	pointer
->	O
recno	int
>	O
meta	pointer
->	O
cur_recno	int
)	O
{	O
new_cur	int
=	O
cp	pointer
->	O
recno	int
;	O
opcode	int
|=	O
QAM_SETCUR	int
;	O
}	O
if	O
(	O
cp	pointer
->	O
recno	int
<	O
meta	pointer
->	O
first_recno	int
||	O
meta	pointer
->	O
first_recno	int
<	O
meta	pointer
->	O
start	int
)	O
{	O
new_first	int
=	O
cp	pointer
->	O
recno	int
;	O
opcode	int
|=	O
QAM_SETFIRST	int
;	O
}	O
if	O
(	O
opcode	int
!=	O
0	int
&&	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
ret	int
=	O
CDB___qam_mvptr_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
meta	pointer
->	O
dbmeta	struct
.	O
lsn	struct
,	O
0	int
,	O
opcode	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
meta	pointer
->	O
first_recno	int
,	O
new_first	int
,	O
meta	pointer
->	O
cur_recno	int
,	O
new_cur	int
,	O
&	O
meta	pointer
->	O
dbmeta	struct
.	O
lsn	struct
)	O
;	O
}	O
if	O
(	O
opcode	int
&	O
QAM_SETCUR	int
)	O
meta	pointer
->	O
cur_recno	int
=	O
cp	pointer
->	O
recno	int
;	O
if	O
(	O
opcode	int
&	O
QAM_SETFIRST	int
)	O
meta	pointer
->	O
first_recno	int
=	O
cp	pointer
->	O
recno	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
meta	pointer
,	O
opcode	int
!=	O
0	int
?	O
DB_MPOOL_DIRTY	int
:	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___qam_put	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
QUEUE_CURSOR	struct
*	O
cp	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
DB_LOCK	struct
lock	struct
;	O
QMETA	struct
*	O
meta	pointer
;	O
QPAGE	struct
*	O
page	pointer
;	O
db_pgno_t	int
pg	struct
;	O
db_recno_t	int
recno	int
,	O
start	int
,	O
total	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
cursor	pointer
(	O
dbp	pointer
,	O
txn	pointer
,	O
&	O
dbc	pointer
,	O
DB_WRITELOCK	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
DEBUG_LWRITE	O
(	O
dbc	pointer
,	O
txn	pointer
,	O
"qam_put"	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
)	O
;	O
cp	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_putchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
done	O
;	O
if	O
(	O
flags	int
!=	O
DB_APPEND	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__qam_getno	function
(	O
dbp	pointer
,	O
key	struct
,	O
&	O
cp	pointer
->	O
recno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
done	O
;	O
__qam_nrecs	function
(	O
dbc	pointer
,	O
&	O
total	int
,	O
&	O
cp	pointer
->	O
start	int
)	O
;	O
ret	int
=	O
__qam_c_put	function
(	O
dbc	pointer
,	O
NULL	O
,	O
data	pointer
,	O
flags	int
,	O
NULL	O
)	O
;	O
goto	O
done	O
;	O
}	O
pg	struct
=	O
(	O
(	O
QUEUE	struct
*	O
)	O
dbp	pointer
->	O
q_internal	pointer
)	O
->	O
q_meta	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
done	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
meta	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
CDB___qam_inc_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
txn	pointer
,	O
&	O
meta	pointer
->	O
dbmeta	struct
.	O
lsn	struct
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
meta	pointer
->	O
dbmeta	struct
.	O
lsn	struct
)	O
;	O
}	O
recno	int
=	O
++	O
meta	pointer
->	O
cur_recno	int
;	O
start	int
=	O
meta	pointer
->	O
start	int
;	O
if	O
(	O
meta	pointer
->	O
first_recno	int
<	O
meta	pointer
->	O
start	int
||	O
meta	pointer
->	O
first_recno	int
>	O
recno	int
)	O
meta	pointer
->	O
first_recno	int
=	O
recno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
meta	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
1	int
,	O
recno	int
,	O
DB_LOCK_WRITE	int
,	O
DB_LOCK_RECORD	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
done	O
;	O
cp	pointer
->	O
lock	struct
=	O
lock	struct
;	O
cp	pointer
->	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
pg	struct
=	O
QAM_RECNO_PAGE	O
(	O
dbp	pointer
,	O
start	int
,	O
recno	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
done	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
DB_MPOOL_CREATE	int
,	O
&	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
page	pointer
->	O
pgno	int
==	O
0	int
)	O
{	O
page	pointer
->	O
pgno	int
=	O
pg	struct
;	O
page	pointer
->	O
type	enum
=	O
P_QAMDATA	int
;	O
}	O
ret	int
=	O
CDB___qam_pitem	function
(	O
dbc	pointer
,	O
page	pointer
,	O
QAM_RECNO_INDEX	O
(	O
dbp	pointer
,	O
pg	struct
,	O
start	int
,	O
recno	int
)	O
,	O
recno	int
,	O
data	pointer
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
page	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
key	struct
,	O
&	O
recno	int
,	O
sizeof	O
(	O
recno	int
)	O
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
;	O
done	O
:	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__qam_c_del	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
QUEUE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
lock	struct
;	O
PAGE	struct
*	O
pagep	pointer
;	O
QAMDATA	struct
*	O
qp	pointer
;	O
db_recno_t	int
start	int
;	O
db_recno_t	int
total	int
;	O
int	O
exact	int
,	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
ret	int
=	O
0	int
;	O
__qam_nrecs	function
(	O
dbc	pointer
,	O
&	O
total	int
,	O
&	O
cp	pointer
->	O
start	int
)	O
;	O
start	int
=	O
cp	pointer
->	O
start	int
;	O
if	O
(	O
cp	pointer
->	O
recno	int
>	O
total	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
cp	pointer
->	O
recno	int
,	O
DB_LOCK_WRITE	int
,	O
DB_LOCK_RECORD	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
cp	pointer
->	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
if	O
(	O
(	O
ret	int
=	O
__qam_position	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
recno	int
,	O
DB_LOCK_WRITE	int
,	O
start	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
{	O
cp	pointer
->	O
lock	struct
=	O
lock	struct
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
!	O
exact	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err1	O
;	O
}	O
pagep	pointer
=	O
cp	pointer
->	O
page	pointer
;	O
qp	pointer
=	O
QAM_GET_RECORD	O
(	O
dbp	pointer
,	O
pagep	pointer
,	O
cp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___qam_del_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
LSN	O
(	O
pagep	pointer
)	O
,	O
pagep	pointer
->	O
pgno	int
,	O
cp	pointer
->	O
indx	short
,	O
cp	pointer
->	O
recno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
}	O
F_CLR	O
(	O
qp	pointer
,	O
QAM_VALID	int
)	O
;	O
err1	O
:	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
ret	int
==	O
0	int
?	O
DB_MPOOL_DIRTY	int
:	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
?	O
ret	int
:	O
t_ret	int
)	O
;	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
{	O
cp	pointer
->	O
lock	struct
=	O
lock	struct
;	O
return	O
(	O
ret	int
?	O
ret	int
:	O
t_ret	int
)	O
;	O
}	O
cp	pointer
->	O
lock	struct
=	O
lock	struct
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___qam_delete	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
key	struct
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
flags	int
;	O
{	O
QUEUE_CURSOR	struct
*	O
cp	pointer
;	O
DBC	struct
*	O
dbc	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_delchk	function
(	O
dbp	pointer
,	O
key	struct
,	O
flags	int
,	O
F_ISSET	O
(	O
dbp	pointer
,	O
DB_AM_RDONLY	int
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
dbp	pointer
->	O
cursor	pointer
(	O
dbp	pointer
,	O
txn	pointer
,	O
&	O
dbc	pointer
,	O
DB_WRITELOCK	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
DEBUG_LWRITE	O
(	O
dbc	pointer
,	O
txn	pointer
,	O
"qam_delete"	pointer
,	O
key	struct
,	O
NULL	O
,	O
flags	int
)	O
;	O
cp	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__qam_getno	function
(	O
dbp	pointer
,	O
key	struct
,	O
&	O
cp	pointer
->	O
recno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
ret	int
=	O
__qam_c_del	function
(	O
dbc	pointer
)	O
;	O
err	pointer
:	O
if	O
(	O
(	O
t_ret	int
=	O
dbc	pointer
->	O
c_close	pointer
(	O
dbc	pointer
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__qam_c_get	function
(	O
dbc	pointer
,	O
key	struct
,	O
data	pointer
,	O
flags	int
,	O
pgnop	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
DBT	struct
*	O
key	struct
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
QUEUE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
lock	struct
,	O
pglock	struct
,	O
metalock	struct
,	O
save_lock	struct
;	O
DBT	struct
tmp	struct
;	O
PAGE	struct
*	O
pg	struct
;	O
QAMDATA	struct
*	O
qp	pointer
;	O
QMETA	struct
*	O
meta	pointer
;	O
db_indx_t	short
save_indx	short
;	O
db_lockmode_t	enum
lock_mode	enum
;	O
db_pgno_t	int
metapno	int
,	O
save_page	int
;	O
db_recno_t	int
start	int
,	O
first	int
,	O
skipped	int
,	O
save_recno	int
;	O
int	O
exact	int
,	O
is_first	int
,	O
locked	int
,	O
ret	int
,	O
t_ret	int
,	O
with_delete	int
;	O
int	O
put_mode	int
,	O
meta_dirty	int
;	O
cp	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
PANIC_CHECK	O
(	O
dbp	pointer
->	O
dbenv	pointer
)	O
;	O
with_delete	int
=	O
0	int
;	O
lock_mode	enum
=	O
DB_LOCK_READ	int
;	O
put_mode	int
=	O
0	int
;	O
t_ret	int
=	O
0	int
;	O
*	O
pgnop	pointer
=	O
0	int
;	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_RMW	int
)	O
)	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
if	O
(	O
flags	int
==	O
DB_CONSUME	int
)	O
{	O
with_delete	int
=	O
1	int
;	O
flags	int
=	O
DB_FIRST	int
;	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
}	O
DEBUG_LREAD	O
(	O
dbc	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
"qam_c_get"	pointer
,	O
flags	int
==	O
DB_SET	int
||	O
flags	int
==	O
DB_SET_RANGE	int
?	O
key	struct
:	O
NULL	O
,	O
NULL	O
,	O
flags	int
)	O
;	O
is_first	int
=	O
0	int
;	O
metapno	int
=	O
(	O
(	O
QUEUE	struct
*	O
)	O
dbp	pointer
->	O
q_internal	pointer
)	O
->	O
q_meta	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
metapno	int
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
locked	int
=	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
metapno	int
,	O
0	int
,	O
&	O
meta	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
skipped	int
=	O
0	int
;	O
first	int
=	O
0	int
;	O
meta_dirty	int
=	O
0	int
;	O
if	O
(	O
cp	pointer
->	O
lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
{	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
}	O
retry	O
:	O
cp	pointer
->	O
start	int
=	O
start	int
=	O
meta	pointer
->	O
start	int
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_CURRENT	int
:	O
break	O
;	O
case	O
DB_NEXT_DUP	int
:	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
case	O
DB_NEXT	int
:	O
case	O
DB_NEXT_NODUP	int
:	O
if	O
(	O
cp	pointer
->	O
recno	int
!=	O
RECNO_OOB	int
)	O
{	O
++	O
cp	pointer
->	O
recno	int
;	O
break	O
;	O
}	O
case	O
DB_FIRST	int
:	O
flags	int
=	O
DB_NEXT	int
;	O
is_first	int
=	O
1	int
;	O
cp	pointer
->	O
recno	int
=	O
first	int
=	O
meta	pointer
->	O
first_recno	int
;	O
if	O
(	O
with_delete	int
&&	O
first	int
<	O
meta	pointer
->	O
cur_recno	int
)	O
{	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
CDB___qam_incfirst_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
meta	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
first	int
)	O
;	O
meta	pointer
->	O
first_recno	int
++	O
;	O
meta_dirty	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
DB_PREV	int
:	O
case	O
DB_PREV_NODUP	int
:	O
if	O
(	O
cp	pointer
->	O
recno	int
!=	O
RECNO_OOB	int
)	O
{	O
if	O
(	O
cp	pointer
->	O
recno	int
<=	O
meta	pointer
->	O
first_recno	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
--	O
cp	pointer
->	O
recno	int
;	O
break	O
;	O
}	O
case	O
DB_LAST	int
:	O
cp	pointer
->	O
recno	int
=	O
meta	pointer
->	O
cur_recno	int
;	O
if	O
(	O
cp	pointer
->	O
recno	int
==	O
0	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err	pointer
;	O
}	O
break	O
;	O
case	O
DB_GET_BOTH	int
:	O
case	O
DB_SET	int
:	O
case	O
DB_SET_RANGE	int
:	O
if	O
(	O
(	O
ret	int
=	O
__qam_getno	function
(	O
dbp	pointer
,	O
key	struct
,	O
&	O
cp	pointer
->	O
recno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
CDB___db_unknown_flag	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"__qam_c_get"	pointer
,	O
flags	int
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
cp	pointer
->	O
recno	int
>	O
meta	pointer
->	O
cur_recno	int
||	O
cp	pointer
->	O
recno	int
<	O
start	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
pg	struct
=	O
NULL	O
;	O
if	O
(	O
skipped	int
)	O
goto	O
undo_meta	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
locked	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
locked	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
cp	pointer
->	O
recno	int
,	O
lock_mode	enum
,	O
with_delete	int
?	O
DB_LOCK_NOWAIT	int
|	O
DB_LOCK_RECORD	int
:	O
DB_LOCK_RECORD	int
,	O
&	O
lock	struct
)	O
)	O
==	O
DB_LOCK_NOTGRANTED	O
&&	O
with_delete	int
)	O
{	O
is_first	int
=	O
0	int
;	O
if	O
(	O
skipped	int
==	O
0	int
)	O
skipped	int
=	O
cp	pointer
->	O
recno	int
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
!	O
with_delete	int
&&	O
is_first	int
)	O
||	O
flags	int
==	O
DB_LAST	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
metapno	int
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
cp	pointer
->	O
recno	int
!=	O
(	O
is_first	int
?	O
meta	pointer
->	O
first_recno	int
:	O
meta	pointer
->	O
cur_recno	int
)	O
)	O
{	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
if	O
(	O
is_first	int
)	O
flags	int
=	O
DB_FIRST	int
;	O
locked	int
=	O
1	int
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__qam_position	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
recno	int
,	O
lock_mode	enum
,	O
start	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
goto	O
err	pointer
;	O
}	O
pg	struct
=	O
cp	pointer
->	O
page	pointer
;	O
pglock	struct
=	O
cp	pointer
->	O
lock	struct
;	O
cp	pointer
->	O
lock	struct
=	O
lock	struct
;	O
cp	pointer
->	O
lock_mode	enum
=	O
lock_mode	enum
;	O
if	O
(	O
!	O
exact	int
)	O
{	O
if	O
(	O
flags	int
==	O
DB_NEXT	int
||	O
flags	int
==	O
DB_NEXT_NODUP	int
||	O
flags	int
==	O
DB_PREV	int
||	O
flags	int
==	O
DB_PREV_NODUP	int
||	O
flags	int
==	O
DB_LAST	int
)	O
{	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
pglock	struct
)	O
;	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
if	O
(	O
flags	int
==	O
DB_LAST	int
)	O
flags	int
=	O
DB_PREV	int
;	O
if	O
(	O
!	O
with_delete	int
)	O
is_first	int
=	O
0	int
;	O
goto	O
retry	O
;	O
}	O
ret	int
=	O
DB_KEYEMPTY	O
;	O
goto	O
err1	O
;	O
}	O
if	O
(	O
flags	int
!=	O
DB_SET	int
&&	O
flags	int
!=	O
DB_GET_BOTH	int
&&	O
(	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
key	struct
,	O
&	O
cp	pointer
->	O
recno	int
,	O
sizeof	O
(	O
cp	pointer
->	O
recno	int
)	O
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rkey	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
with_delete	int
)	O
goto	O
undo_meta	O
;	O
else	O
goto	O
err1	O
;	O
}	O
F_SET	O
(	O
key	struct
,	O
DB_DBT_ISSET	int
)	O
;	O
qp	pointer
=	O
QAM_GET_RECORD	O
(	O
dbp	pointer
,	O
pg	struct
,	O
cp	pointer
->	O
indx	short
)	O
;	O
if	O
(	O
flags	int
==	O
DB_GET_BOTH	int
)	O
{	O
tmp	struct
.	O
data	pointer
=	O
qp	pointer
->	O
data	pointer
;	O
tmp	struct
.	O
size	int
=	O
(	O
(	O
QUEUE	struct
*	O
)	O
dbp	pointer
->	O
q_internal	pointer
)	O
->	O
re_len	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_defcmp	function
(	O
data	pointer
,	O
&	O
tmp	struct
)	O
)	O
!=	O
0	int
)	O
{	O
ret	int
=	O
DB_NOTFOUND	O
;	O
goto	O
err1	O
;	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_retcopy	function
(	O
dbp	pointer
,	O
data	pointer
,	O
qp	pointer
->	O
data	pointer
,	O
(	O
(	O
QUEUE	struct
*	O
)	O
dbp	pointer
->	O
q_internal	pointer
)	O
->	O
re_len	int
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
data	pointer
,	O
&	O
dbc	pointer
->	O
rdata	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
with_delete	int
)	O
goto	O
undo_meta	O
;	O
else	O
goto	O
err1	O
;	O
}	O
F_SET	O
(	O
data	pointer
,	O
DB_DBT_ISSET	int
)	O
;	O
if	O
(	O
with_delete	int
)	O
{	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___qam_del_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
pg	struct
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
&	O
LSN	O
(	O
pg	struct
)	O
,	O
pg	struct
->	O
pgno	int
,	O
cp	pointer
->	O
indx	short
,	O
cp	pointer
->	O
recno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
undo_meta	O
;	O
F_CLR	O
(	O
qp	pointer
,	O
QAM_VALID	int
)	O
;	O
put_mode	int
=	O
DB_MPOOL_DIRTY	int
;	O
if	O
(	O
cp	pointer
->	O
recno	int
!=	O
first	int
)	O
{	O
if	O
(	O
0	int
)	O
{	O
undo_meta	O
:	O
is_first	int
=	O
0	int
;	O
}	O
if	O
(	O
locked	int
==	O
0	int
&&	O
(	O
t_ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
metapno	int
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
if	O
(	O
is_first	int
)	O
{	O
if	O
(	O
meta	pointer
->	O
first_recno	int
>	O
first	int
)	O
{	O
meta	pointer
->	O
first_recno	int
=	O
cp	pointer
->	O
recno	int
;	O
meta_dirty	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
skipped	int
==	O
0	int
)	O
{	O
if	O
(	O
meta	pointer
->	O
first_recno	int
>	O
cp	pointer
->	O
recno	int
)	O
{	O
meta	pointer
->	O
first_recno	int
=	O
cp	pointer
->	O
recno	int
;	O
meta_dirty	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
meta	pointer
->	O
first_recno	int
>	O
skipped	int
)	O
{	O
first	int
=	O
meta	pointer
->	O
first_recno	int
;	O
__LPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
;	O
locked	int
=	O
0	int
;	O
save_page	int
=	O
cp	pointer
->	O
pgno	int
;	O
save_indx	short
=	O
cp	pointer
->	O
indx	short
;	O
save_recno	int
=	O
cp	pointer
->	O
recno	int
;	O
save_lock	struct
=	O
cp	pointer
->	O
lock	struct
;	O
do	O
{	O
t_ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
skipped	int
,	O
DB_LOCK_READ	int
,	O
DB_LOCK_NOWAIT	int
|	O
DB_LOCK_RECORD	int
,	O
&	O
lock	struct
)	O
;	O
if	O
(	O
t_ret	int
==	O
DB_LOCK_NOTGRANTED	O
)	O
break	O
;	O
if	O
(	O
t_ret	int
!=	O
0	int
)	O
goto	O
err1	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__qam_position	function
(	O
dbc	pointer
,	O
&	O
skipped	int
,	O
DB_LOCK_READ	int
,	O
start	int
,	O
&	O
exact	int
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
goto	O
err1	O
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
put_mode	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
if	O
(	O
exact	int
)	O
break	O
;	O
}	O
while	O
(	O
++	O
skipped	int
<=	O
first	int
)	O
;	O
t_ret	int
=	O
0	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
metapno	int
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
metalock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
if	O
(	O
meta	pointer
->	O
first_recno	int
>	O
skipped	int
)	O
{	O
meta	pointer
->	O
first_recno	int
=	O
skipped	int
;	O
meta_dirty	int
=	O
1	int
;	O
}	O
cp	pointer
->	O
pgno	int
=	O
save_page	int
;	O
cp	pointer
->	O
indx	short
=	O
save_indx	short
;	O
cp	pointer
->	O
recno	int
=	O
save_recno	int
;	O
cp	pointer
->	O
lock	struct
=	O
save_lock	struct
;	O
}	O
locked	int
=	O
1	int
;	O
}	O
}	O
err1	O
:	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
if	O
(	O
pg	struct
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
ret	int
)	O
ret	int
=	O
t_ret	int
;	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pg	struct
,	O
put_mode	int
)	O
;	O
if	O
(	O
!	O
ret	int
)	O
ret	int
=	O
t_ret	int
;	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
pglock	struct
)	O
;	O
}	O
err	pointer
:	O
if	O
(	O
meta	pointer
)	O
{	O
if	O
(	O
!	O
ret	int
)	O
ret	int
=	O
t_ret	int
;	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
meta	pointer
,	O
meta_dirty	int
?	O
DB_MPOOL_DIRTY	int
:	O
0	int
)	O
;	O
if	O
(	O
!	O
ret	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
locked	int
)	O
t_ret	int
=	O
__LPUT	O
(	O
dbc	pointer
,	O
metalock	struct
)	O
;	O
}	O
return	O
(	O
ret	int
?	O
ret	int
:	O
t_ret	int
)	O
;	O
}	O
static	O
int	O
__qam_c_close	function
(	O
dbc	pointer
,	O
root_pgno	int
,	O
rmroot	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
db_pgno_t	int
root_pgno	int
;	O
int	O
*	O
rmroot	pointer
;	O
{	O
if	O
(	O
dbc	pointer
||	O
root_pgno	int
||	O
rmroot	pointer
)	O
{	O
}	O
QUEUE_CURSOR	struct
*	O
cp	pointer
;	O
COMPQUIET	O
(	O
root_pgno	int
,	O
0	int
)	O
;	O
COMPQUIET	O
(	O
rmroot	pointer
,	O
NULL	O
)	O
;	O
cp	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
cp	pointer
->	O
lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
{	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
}	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
cp	pointer
->	O
pgno	int
=	O
PGNO_INVALID	int
;	O
cp	pointer
->	O
indx	short
=	O
0	int
;	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
cp	pointer
->	O
lock_mode	enum
=	O
DB_LOCK_NG	int
;	O
cp	pointer
->	O
recno	int
=	O
RECNO_OOB	int
;	O
cp	pointer
->	O
flags	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___qam_c_dup	function
(	O
orig_dbc	pointer
,	O
new_dbc	pointer
)	O
DBC	struct
*	O
orig_dbc	pointer
,	O
*	O
new_dbc	pointer
;	O
{	O
QUEUE_CURSOR	struct
*	O
orig	struct
,	O
*	O
new	pointer
;	O
orig	struct
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
orig_dbc	pointer
->	O
internal	pointer
;	O
new	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
new_dbc	pointer
->	O
internal	pointer
;	O
new	pointer
->	O
recno	int
=	O
orig	struct
->	O
recno	int
;	O
new	pointer
->	O
start	int
=	O
orig	struct
->	O
start	int
;	O
if	O
(	O
orig_dbc	pointer
->	O
txn	pointer
!=	O
NULL	O
||	O
!	O
STD_LOCKING	O
(	O
orig_dbc	pointer
)	O
||	O
orig	struct
->	O
lock	struct
.	O
off	long
==	O
LOCK_INVALID	O
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
CDB___db_lget	function
(	O
new_dbc	pointer
,	O
0	int
,	O
new	pointer
->	O
recno	int
,	O
new	pointer
->	O
lock_mode	enum
,	O
DB_LOCK_RECORD	int
,	O
&	O
new	pointer
->	O
lock	struct
)	O
)	O
;	O
}	O
int	O
CDB___qam_c_init	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
QUEUE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
QUEUE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
QUEUE_CURSOR	struct
)	O
,	O
&	O
cp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbc	pointer
->	O
internal	pointer
=	O
(	O
DBC_INTERNAL	struct
*	O
)	O
cp	pointer
;	O
}	O
dbc	pointer
->	O
c_close	pointer
=	O
CDB___db_c_close	function
;	O
dbc	pointer
->	O
c_count	pointer
=	O
CDB___db_c_count	function
;	O
dbc	pointer
->	O
c_del	pointer
=	O
CDB___db_c_del	function
;	O
dbc	pointer
->	O
c_dup	pointer
=	O
CDB___db_c_dup	function
;	O
dbc	pointer
->	O
c_get	pointer
=	O
CDB___db_c_get	function
;	O
dbc	pointer
->	O
c_put	pointer
=	O
CDB___db_c_put	function
;	O
dbc	pointer
->	O
c_am_close	pointer
=	O
__qam_c_close	function
;	O
dbc	pointer
->	O
c_am_del	pointer
=	O
__qam_c_del	function
;	O
dbc	pointer
->	O
c_am_destroy	pointer
=	O
__qam_c_destroy	function
;	O
dbc	pointer
->	O
c_am_get	pointer
=	O
__qam_c_get	function
;	O
dbc	pointer
->	O
c_am_put	pointer
=	O
__qam_c_put	function
;	O
dbc	pointer
->	O
c_am_writelock	pointer
=	O
NULL	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__qam_c_destroy	function
(	O
dbc	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
{	O
CDB___os_free	function
(	O
dbc	pointer
->	O
internal	pointer
,	O
sizeof	O
(	O
QUEUE_CURSOR	struct
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__qam_getno	function
(	O
dbp	pointer
,	O
key	struct
,	O
rep	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
const	O
DBT	struct
*	O
key	struct
;	O
db_recno_t	int
*	O
rep	pointer
;	O
{	O
if	O
(	O
(	O
*	O
rep	pointer
=	O
*	O
(	O
db_recno_t	int
*	O
)	O
key	struct
->	O
data	pointer
)	O
==	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"illegal record number of 0"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
