static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: bt_search.c,v 1.4 2000/06/28 16:47:00 loic Exp $"	pointer
;	O
int	O
CDB___bam_search	function
(	O
dbc	pointer
,	O
key	struct
,	O
flags	int
,	O
stop	int
,	O
recnop	pointer
,	O
exactp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
const	O
DBT	struct
*	O
key	struct
;	O
u_int32_t	int
flags	int
;	O
int	O
stop	int
,	O
*	O
exactp	pointer
;	O
db_recno_t	int
*	O
recnop	pointer
;	O
{	O
BTREE	struct
*	O
t	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
lock	struct
;	O
PAGE	struct
*	O
h	pointer
;	O
db_indx_t	short
base	short
,	O
i	short
,	O
indx	short
,	O
lim	short
;	O
db_lockmode_t	enum
lock_mode	enum
;	O
db_pgno_t	int
pg	struct
;	O
db_recno_t	int
recno	int
;	O
int	O
adjust	int
,	O
cmp	int
,	O
deloffset	int
,	O
ret	int
,	O
stack	array
;	O
int	O
(	O
*	O
func	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
recno	int
=	O
0	int
;	O
BT_STK_CLR	O
(	O
cp	pointer
)	O
;	O
try_again	O
:	O
pg	struct
=	O
cp	pointer
->	O
root	int
;	O
stack	array
=	O
LF_ISSET	O
(	O
S_STACK	int
)	O
&&	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
;	O
lock_mode	enum
=	O
stack	array
?	O
DB_LOCK_WRITE	int
:	O
DB_LOCK_READ	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
!	O
stack	array
&&	O
(	O
(	O
LF_ISSET	O
(	O
S_PARENT	int
)	O
&&	O
(	O
u_int8_t	char
)	O
(	O
stop	int
+	O
1	int
)	O
>=	O
h	pointer
->	O
level	char
)	O
||	O
(	O
LF_ISSET	O
(	O
S_WRITE	int
)	O
&&	O
h	pointer
->	O
level	char
==	O
LEAFLEVEL	int
)	O
)	O
)	O
{	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
(	O
LF_ISSET	O
(	O
S_PARENT	int
)	O
&&	O
(	O
u_int8_t	char
)	O
(	O
stop	int
+	O
1	int
)	O
>=	O
h	pointer
->	O
level	char
)	O
||	O
(	O
LF_ISSET	O
(	O
S_WRITE	int
)	O
&&	O
h	pointer
->	O
level	char
==	O
LEAFLEVEL	int
)	O
)	O
)	O
{	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
goto	O
try_again	O
;	O
}	O
stack	array
=	O
1	int
;	O
}	O
func	pointer
=	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
?	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
NULL	O
?	O
CDB___bam_defcmp	function
:	O
dbp	pointer
->	O
dup_compare	pointer
)	O
:	O
t	pointer
->	O
bt_compare	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
adjust	int
=	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
?	O
P_INDX	int
:	O
O_INDX	int
;	O
for	O
(	O
base	short
=	O
0	int
,	O
lim	short
=	O
NUM_ENT	O
(	O
h	pointer
)	O
/	O
(	O
db_indx_t	short
)	O
adjust	int
;	O
lim	short
!=	O
0	int
;	O
lim	short
>>=	O
1	int
)	O
{	O
indx	short
=	O
base	short
+	O
(	O
(	O
lim	short
>>	O
1	int
)	O
*	O
adjust	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_cmp	function
(	O
dbp	pointer
,	O
key	struct
,	O
h	pointer
,	O
indx	short
,	O
func	pointer
,	O
&	O
cmp	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
cmp	int
==	O
0	int
)	O
{	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
||	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LDUP	int
)	O
goto	O
found	O
;	O
goto	O
next	int
;	O
}	O
if	O
(	O
cmp	int
>	O
0	int
)	O
{	O
base	short
=	O
indx	short
+	O
adjust	int
;	O
--	O
lim	short
;	O
}	O
}	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
||	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LDUP	int
)	O
{	O
*	O
exactp	pointer
=	O
0	int
;	O
if	O
(	O
LF_ISSET	O
(	O
S_EXACT	int
)	O
)	O
goto	O
notfound	O
;	O
if	O
(	O
LF_ISSET	O
(	O
S_STK_ONLY	int
)	O
)	O
{	O
BT_STK_NUM	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
base	short
,	O
ret	int
)	O
;	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
BT_STK_ENTER	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
base	short
,	O
lock	struct
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
indx	short
=	O
base	short
>	O
0	int
?	O
base	short
-	O
O_INDX	int
:	O
base	short
;	O
next	int
:	O
if	O
(	O
recnop	pointer
!=	O
NULL	O
)	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
indx	short
;	O
++	O
i	short
)	O
recno	int
+=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
i	short
)	O
->	O
nrecs	int
;	O
pg	struct
=	O
GET_BINTERNAL	O
(	O
h	pointer
,	O
indx	short
)	O
->	O
pgno	int
;	O
if	O
(	O
LF_ISSET	O
(	O
S_STK_ONLY	int
)	O
)	O
{	O
if	O
(	O
stop	int
==	O
h	pointer
->	O
level	char
)	O
{	O
BT_STK_NUM	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
ret	int
)	O
;	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
BT_STK_NUMPUSH	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
ret	int
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
LCK_COUPLE	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
{	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
stack	array
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
S_PARENT	int
)	O
&&	O
stop	int
==	O
h	pointer
->	O
level	char
)	O
{	O
BT_STK_ENTER	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
lock	struct
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
BT_STK_PUSH	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
lock	struct
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
lock_mode	enum
=	O
DB_LOCK_WRITE	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
{	O
if	O
(	O
(	O
LF_ISSET	O
(	O
S_PARENT	int
)	O
&&	O
(	O
u_int8_t	char
)	O
(	O
stop	int
+	O
1	int
)	O
>=	O
(	O
u_int8_t	char
)	O
(	O
h	pointer
->	O
level	char
-	O
1	int
)	O
)	O
||	O
(	O
h	pointer
->	O
level	char
-	O
1	int
)	O
==	O
LEAFLEVEL	int
)	O
stack	array
=	O
1	int
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
lock_mode	enum
=	O
stack	array
&&	O
LF_ISSET	O
(	O
S_WRITE	int
)	O
?	O
DB_LOCK_WRITE	int
:	O
DB_LOCK_READ	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
LCK_COUPLE	int
,	O
pg	struct
,	O
lock_mode	enum
,	O
0	int
,	O
&	O
lock	struct
)	O
)	O
!=	O
0	int
)	O
{	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
goto	O
err	pointer
;	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
pg	struct
,	O
0	int
,	O
&	O
h	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
found	O
:	O
*	O
exactp	pointer
=	O
1	int
;	O
if	O
(	O
recnop	pointer
!=	O
NULL	O
)	O
*	O
recnop	pointer
=	O
recno	int
+	O
(	O
indx	short
/	O
P_INDX	int
)	O
+	O
1	int
;	O
if	O
(	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
S_DUPLAST	int
)	O
)	O
while	O
(	O
indx	short
<	O
(	O
db_indx_t	short
)	O
(	O
NUM_ENT	O
(	O
h	pointer
)	O
-	O
P_INDX	int
)	O
&&	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
==	O
h	pointer
->	O
inp	array
[	O
indx	short
+	O
P_INDX	int
]	O
)	O
indx	short
+=	O
P_INDX	int
;	O
else	O
while	O
(	O
indx	short
>	O
0	int
&&	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
==	O
h	pointer
->	O
inp	array
[	O
indx	short
-	O
P_INDX	int
]	O
)	O
indx	short
-=	O
P_INDX	int
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
S_DELNO	int
)	O
)	O
{	O
deloffset	int
=	O
TYPE	O
(	O
h	pointer
)	O
==	O
P_LBTREE	int
?	O
O_INDX	int
:	O
0	int
;	O
if	O
(	O
LF_ISSET	O
(	O
S_DUPLAST	int
)	O
)	O
while	O
(	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
deloffset	int
)	O
->	O
type	enum
)	O
&&	O
indx	short
>	O
0	int
&&	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
==	O
h	pointer
->	O
inp	array
[	O
indx	short
-	O
adjust	int
]	O
)	O
indx	short
-=	O
adjust	int
;	O
else	O
while	O
(	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
deloffset	int
)	O
->	O
type	enum
)	O
&&	O
indx	short
<	O
(	O
db_indx_t	short
)	O
(	O
NUM_ENT	O
(	O
h	pointer
)	O
-	O
adjust	int
)	O
&&	O
h	pointer
->	O
inp	array
[	O
indx	short
]	O
==	O
h	pointer
->	O
inp	array
[	O
indx	short
+	O
adjust	int
]	O
)	O
indx	short
+=	O
adjust	int
;	O
if	O
(	O
B_DISSET	O
(	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
+	O
deloffset	int
)	O
->	O
type	enum
)	O
)	O
goto	O
notfound	O
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
S_STK_ONLY	int
)	O
)	O
{	O
BT_STK_NUM	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
ret	int
)	O
;	O
__LPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
BT_STK_ENTER	O
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cp	pointer
,	O
h	pointer
,	O
indx	short
,	O
lock	struct
,	O
lock_mode	enum
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
return	O
(	O
0	int
)	O
;	O
notfound	O
:	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
h	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
lock	struct
)	O
;	O
ret	int
=	O
DB_NOTFOUND	O
;	O
err	pointer
:	O
if	O
(	O
cp	pointer
->	O
csp	pointer
>	O
cp	pointer
->	O
sp	pointer
)	O
{	O
BT_STK_POP	O
(	O
cp	pointer
)	O
;	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
0	int
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
flags	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
EPG	struct
*	O
epg	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
for	O
(	O
ret	int
=	O
0	int
,	O
epg	pointer
=	O
cp	pointer
->	O
sp	pointer
;	O
epg	pointer
<=	O
cp	pointer
->	O
csp	pointer
;	O
++	O
epg	pointer
)	O
{	O
if	O
(	O
epg	pointer
->	O
page	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
STK_CLRDBC	int
)	O
&&	O
cp	pointer
->	O
page	pointer
==	O
epg	pointer
->	O
page	pointer
)	O
{	O
cp	pointer
->	O
page	pointer
=	O
NULL	O
;	O
cp	pointer
->	O
lock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
}	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
epg	pointer
->	O
page	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
}	O
if	O
(	O
epg	pointer
->	O
lock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
STK_NOLOCK	int
)	O
)	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
epg	pointer
->	O
lock	struct
)	O
;	O
else	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
epg	pointer
->	O
lock	struct
)	O
;	O
}	O
}	O
BT_STK_CLR	O
(	O
cp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___bam_stkgrow	function
(	O
dbenv	pointer
,	O
cp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
{	O
EPG	struct
*	O
p	pointer
;	O
size_t	long
entries	short
;	O
int	O
ret	int
;	O
entries	short
=	O
cp	pointer
->	O
esp	pointer
-	O
cp	pointer
->	O
sp	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
entries	short
*	O
2	int
,	O
sizeof	O
(	O
EPG	struct
)	O
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
cp	pointer
->	O
sp	pointer
,	O
entries	short
*	O
sizeof	O
(	O
EPG	struct
)	O
)	O
;	O
if	O
(	O
cp	pointer
->	O
sp	pointer
!=	O
cp	pointer
->	O
stack	array
)	O
CDB___os_free	function
(	O
cp	pointer
->	O
sp	pointer
,	O
entries	short
*	O
sizeof	O
(	O
EPG	struct
)	O
)	O
;	O
cp	pointer
->	O
sp	pointer
=	O
p	pointer
;	O
cp	pointer
->	O
csp	pointer
=	O
p	pointer
+	O
entries	short
;	O
cp	pointer
->	O
esp	pointer
=	O
p	pointer
+	O
entries	short
*	O
2	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
