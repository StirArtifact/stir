typedef	O
enum	O
{	O
PCX_INIT	int
,	O
PCX_NORMAL	int
,	O
PCX_EXIT	int
}	O
PCXmode	enum
;	O
static	O
void	O
RLEcode_to_file	function
(	O
int	O
c	int
,	O
int	O
repeat	int
,	O
FILE	struct
*	O
fd	pointer
)	O
{	O
if	O
(	O
(	O
repeat	int
==	O
1	int
)	O
&&	O
(	O
(	O
c	int
&	O
0xC0	int
)	O
!=	O
0xC0	int
)	O
)	O
{	O
if	O
(	O
putc	function
(	O
c	int
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
{	O
PError	function
(	O
"RLEcode_to_file (1)"	pointer
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
putc	function
(	O
repeat	int
|	O
0xC0	int
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
{	O
PError	function
(	O
"RLEcode_to_file (2)"	pointer
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
if	O
(	O
putc	function
(	O
c	int
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
{	O
PError	function
(	O
"RLEcode_to_file (3)"	pointer
)	O
;	O
exit	function
(	O
ERROR	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
byte_to_PCX	function
(	O
Byte	char
b	char
,	O
PCXmode	enum
mode	enum
,	O
FILE	struct
*	O
fd	pointer
)	O
{	O
static	O
Byte	char
last_b	char
;	O
static	O
int	O
rept	int
;	O
switch	O
(	O
mode	enum
)	O
{	O
case	O
PCX_NORMAL	int
:	O
if	O
(	O
b	char
==	O
last_b	char
)	O
{	O
if	O
(	O
++	O
rept	int
==	O
63	int
)	O
{	O
RLEcode_to_file	function
(	O
last_b	char
,	O
rept	int
,	O
fd	pointer
)	O
;	O
rept	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
rept	int
)	O
RLEcode_to_file	function
(	O
last_b	char
,	O
rept	int
,	O
fd	pointer
)	O
;	O
rept	int
=	O
1	int
;	O
last_b	char
=	O
b	char
;	O
}	O
break	O
;	O
case	O
PCX_INIT	int
:	O
rept	int
=	O
0	int
;	O
last_b	char
=	O
-	O
2	int
;	O
break	O
;	O
case	O
PCX_EXIT	int
:	O
if	O
(	O
rept	int
)	O
{	O
RLEcode_to_file	function
(	O
last_b	char
,	O
rept	int
,	O
fd	pointer
)	O
;	O
rept	int
=	O
0	int
;	O
}	O
break	O
;	O
}	O
}	O
typedef	O
struct	O
{	O
char	O
creator	char
,	O
version	char
,	O
encoding	char
,	O
bits	char
;	O
short	O
xmin	double
,	O
ymin	double
,	O
xmax	double
,	O
ymax	double
,	O
hres	short
,	O
vres	short
;	O
unsigned	O
char	O
palette	array
[	O
16	int
]	O
[	O
3	int
]	O
,	O
vmode	char
,	O
planes	char
;	O
short	O
byteperline	short
,	O
paletteinfo	short
;	O
short	O
hscreensize	short
,	O
vscreensize	short
;	O
char	O
dummy	array
[	O
54	int
]	O
;	O
}	O
PCXheader	struct
;	O
static	O
int	O
start_PCX	function
(	O
const	O
OUT_PAR	struct
*	O
po	pointer
,	O
const	O
GEN_PAR	struct
*	O
pg	pointer
,	O
FILE	struct
*	O
fd	pointer
)	O
{	O
PCXheader	struct
h	struct
;	O
int	O
i	int
;	O
h	struct
.	O
creator	char
=	O
0x0A	int
;	O
if	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
depth	int
==	O
1	int
)	O
h	struct
.	O
version	char
=	O
'\002'	O
;	O
else	O
h	struct
.	O
version	char
=	O
'\005'	O
;	O
h	struct
.	O
encoding	char
=	O
1	int
;	O
if	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
depth	int
==	O
1	int
)	O
h	struct
.	O
bits	char
=	O
1	int
;	O
else	O
h	struct
.	O
bits	char
=	O
8	int
;	O
h	struct
.	O
xmin	double
=	O
0	int
;	O
h	struct
.	O
ymin	double
=	O
0	int
;	O
h	struct
.	O
xmax	double
=	O
(	O
short	O
)	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
nc	int
-	O
1	int
)	O
;	O
h	struct
.	O
ymax	double
=	O
(	O
short	O
)	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
nr	int
-	O
1	int
)	O
;	O
h	struct
.	O
hres	short
=	O
(	O
short	O
)	O
po	pointer
->	O
dpi_x	int
;	O
h	struct
.	O
vres	short
=	O
(	O
short	O
)	O
po	pointer
->	O
dpi_y	int
;	O
if	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
depth	int
==	O
1	int
)	O
{	O
h	struct
.	O
palette	array
[	O
0	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
0	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
0	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
1	int
]	O
[	O
0	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
1	int
]	O
[	O
2	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
2	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
2	int
]	O
[	O
1	int
]	O
=	O
128	int
;	O
h	struct
.	O
palette	array
[	O
2	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
3	int
]	O
[	O
0	int
]	O
=	O
128	int
;	O
h	struct
.	O
palette	array
[	O
3	int
]	O
[	O
1	int
]	O
=	O
128	int
;	O
h	struct
.	O
palette	array
[	O
3	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
4	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
4	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
4	int
]	O
[	O
2	int
]	O
=	O
128	int
;	O
h	struct
.	O
palette	array
[	O
5	int
]	O
[	O
0	int
]	O
=	O
128	int
;	O
h	struct
.	O
palette	array
[	O
5	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
5	int
]	O
[	O
2	int
]	O
=	O
128	int
;	O
h	struct
.	O
palette	array
[	O
6	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
6	int
]	O
[	O
1	int
]	O
=	O
128	int
;	O
h	struct
.	O
palette	array
[	O
6	int
]	O
[	O
2	int
]	O
=	O
128	int
;	O
h	struct
.	O
palette	array
[	O
7	int
]	O
[	O
0	int
]	O
=	O
192	int
;	O
h	struct
.	O
palette	array
[	O
7	int
]	O
[	O
1	int
]	O
=	O
192	int
;	O
h	struct
.	O
palette	array
[	O
7	int
]	O
[	O
2	int
]	O
=	O
192	int
;	O
h	struct
.	O
palette	array
[	O
8	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
8	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
8	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
9	int
]	O
[	O
0	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
9	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
9	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
10	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
10	int
]	O
[	O
1	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
10	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
11	int
]	O
[	O
0	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
11	int
]	O
[	O
1	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
11	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
12	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
12	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
12	int
]	O
[	O
2	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
13	int
]	O
[	O
0	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
13	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
13	int
]	O
[	O
2	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
14	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
14	int
]	O
[	O
1	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
14	int
]	O
[	O
2	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
15	int
]	O
[	O
0	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
15	int
]	O
[	O
1	int
]	O
=	O
255	int
;	O
h	struct
.	O
palette	array
[	O
15	int
]	O
[	O
2	int
]	O
=	O
255	int
;	O
}	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
16	int
;	O
i	int
++	O
)	O
{	O
h	struct
.	O
palette	array
[	O
i	int
]	O
[	O
0	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
i	int
]	O
[	O
1	int
]	O
=	O
0	int
;	O
h	struct
.	O
palette	array
[	O
i	int
]	O
[	O
2	int
]	O
=	O
0	int
;	O
}	O
h	struct
.	O
vmode	char
=	O
0	int
;	O
if	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
depth	int
==	O
1	int
)	O
{	O
h	struct
.	O
planes	char
=	O
1	int
;	O
h	struct
.	O
byteperline	short
=	O
(	O
short	O
)	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
;	O
}	O
else	O
{	O
h	struct
.	O
byteperline	short
=	O
(	O
short	O
)	O
(	O
8	int
*	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
)	O
;	O
h	struct
.	O
planes	char
=	O
3	int
;	O
}	O
h	struct
.	O
paletteinfo	short
=	O
1	int
;	O
h	struct
.	O
hscreensize	short
=	O
(	O
short	O
)	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
nc	int
-	O
1	int
)	O
;	O
h	struct
.	O
vscreensize	short
=	O
(	O
short	O
)	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
nr	int
-	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
54	int
;	O
)	O
{	O
h	struct
.	O
dummy	array
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
h	struct
.	O
dummy	array
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
fputc	function
(	O
h	struct
.	O
creator	char
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
h	struct
.	O
version	char
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
h	struct
.	O
encoding	char
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
h	struct
.	O
bits	char
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
xmin	double
&	O
0xff	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
xmin	double
>>	O
8	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
ymin	double
&	O
0xff	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
ymin	double
>>	O
8	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
xmax	double
&	O
0xff	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
xmax	double
>>	O
8	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
ymax	double
&	O
0xff	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
ymax	double
>>	O
8	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
hres	short
&	O
0xff	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
hres	short
>>	O
8	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
vres	short
&	O
0xff	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
vres	short
>>	O
8	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fwrite	function
(	O
(	O
VOID	void
*	O
)	O
h	struct
.	O
palette	array
,	O
48	int
,	O
1	int
,	O
fd	pointer
)	O
!=	O
1	int
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
h	struct
.	O
vmode	char
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
h	struct
.	O
planes	char
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
byteperline	short
&	O
0xff	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
byteperline	short
>>	O
8	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
paletteinfo	short
&	O
0xff	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fputc	function
(	O
(	O
h	struct
.	O
paletteinfo	short
>>	O
8	int
)	O
,	O
fd	pointer
)	O
==	O
EOF	O
)	O
goto	O
ERROR_EXIT	O
;	O
if	O
(	O
fwrite	function
(	O
(	O
VOID	void
*	O
)	O
h	struct
.	O
dummy	array
,	O
58	int
,	O
1	int
,	O
fd	pointer
)	O
!=	O
1	int
)	O
goto	O
ERROR_EXIT	O
;	O
return	O
0	int
;	O
ERROR_EXIT	O
:	O
PError	function
(	O
"start_PCX"	pointer
)	O
;	O
return	O
ERROR	O
;	O
}	O
static	O
void	O
Buf_to_PCX	function
(	O
Byte	char
*	O
pb	pointer
,	O
int	O
nb	int
,	O
FILE	struct
*	O
fd	pointer
)	O
{	O
int	O
x	int
;	O
byte_to_PCX	function
(	O
0	int
,	O
PCX_INIT	int
,	O
fd	pointer
)	O
;	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
nb	int
;	O
x	int
++	O
)	O
byte_to_PCX	function
(	O
~	O
*	O
pb	pointer
++	O
,	O
PCX_NORMAL	int
,	O
fd	pointer
)	O
;	O
byte_to_PCX	function
(	O
0	int
,	O
PCX_EXIT	int
,	O
fd	pointer
)	O
;	O
}	O
int	O
PicBuf_to_PCX	function
(	O
const	O
GEN_PAR	struct
*	O
pg	pointer
,	O
const	O
OUT_PAR	struct
*	O
po	pointer
)	O
{	O
FILE	struct
*	O
fd	pointer
=	O
NULL	O
;	O
RowBuf	struct
*	O
row	pointer
=	O
NULL	O
;	O
int	O
row_c	int
,	O
x	int
,	O
color_index	int
,	O
err	int
;	O
Byte	char
*	O
p_R	pointer
=	O
NULL	O
,	O
*	O
p_G	pointer
=	O
NULL	O
,	O
*	O
p_B	pointer
=	O
NULL	O
,	O
*	O
p_I	pointer
=	O
NULL	O
;	O
err	int
=	O
0	int
;	O
if	O
(	O
!	O
pg	pointer
->	O
quiet	int
)	O
Eprintf	function
(	O
"\nWriting PCX output\n"	pointer
)	O
;	O
if	O
(	O
*	O
po	pointer
->	O
outfile	pointer
!=	O
'-'	O
)	O
{	O
if	O
(	O
(	O
fd	pointer
=	O
fopen	function
(	O
po	pointer
->	O
outfile	pointer
,	O
WRITE_BIN	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
PError	function
(	O
"hp2xx -- opening output file"	pointer
)	O
;	O
return	O
ERROR	O
;	O
}	O
}	O
else	O
fd	pointer
=	O
stdout	pointer
;	O
if	O
(	O
start_PCX	function
(	O
po	pointer
,	O
pg	pointer
,	O
fd	pointer
)	O
)	O
{	O
err	int
=	O
ERROR	O
;	O
goto	O
PCX_exit	O
;	O
}	O
if	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
depth	int
>	O
1	int
)	O
{	O
p_I	pointer
=	O
calloc	function
(	O
(	O
size_t	long
)	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
)	O
,	O
8	int
*	O
sizeof	O
(	O
Byte	char
)	O
)	O
;	O
p_B	pointer
=	O
calloc	function
(	O
(	O
size_t	long
)	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
)	O
,	O
8	int
*	O
sizeof	O
(	O
Byte	char
)	O
)	O
;	O
p_G	pointer
=	O
calloc	function
(	O
(	O
size_t	long
)	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
)	O
,	O
8	int
*	O
sizeof	O
(	O
Byte	char
)	O
)	O
;	O
p_R	pointer
=	O
calloc	function
(	O
(	O
size_t	long
)	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
)	O
,	O
8	int
*	O
sizeof	O
(	O
Byte	char
)	O
)	O
;	O
if	O
(	O
p_I	pointer
==	O
NULL	O
||	O
p_B	pointer
==	O
NULL	O
||	O
p_G	pointer
==	O
NULL	O
||	O
p_R	pointer
==	O
NULL	O
)	O
{	O
Eprintf	function
(	O
"\nCannot 'calloc' color conversion memory -- sorry, use B/W!\n"	pointer
)	O
;	O
err	int
=	O
ERROR	O
;	O
goto	O
PCX_exit	O
;	O
}	O
}	O
for	O
(	O
row_c	int
=	O
po	pointer
->	O
picbuf	pointer
->	O
nr	int
-	O
1	int
;	O
row_c	int
>=	O
0	int
;	O
row_c	int
--	O
)	O
{	O
if	O
(	O
(	O
!	O
pg	pointer
->	O
quiet	int
)	O
&&	O
(	O
row_c	int
%	O
10	int
==	O
0	int
)	O
)	O
Eprintf	function
(	O
"."	pointer
)	O
;	O
row	pointer
=	O
get_RowBuf	function
(	O
po	pointer
->	O
picbuf	pointer
,	O
row_c	int
)	O
;	O
byte_to_PCX	function
(	O
0	int
,	O
PCX_INIT	int
,	O
fd	pointer
)	O
;	O
if	O
(	O
po	pointer
->	O
picbuf	pointer
->	O
depth	int
==	O
1	int
)	O
Buf_to_PCX	function
(	O
row	pointer
->	O
buf	pointer
,	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
,	O
fd	pointer
)	O
;	O
else	O
{	O
for	O
(	O
x	int
=	O
0	int
;	O
(	O
x	int
<	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
<<	O
3	int
)	O
;	O
x	int
++	O
)	O
{	O
p_I	pointer
[	O
x	int
]	O
=	O
p_R	pointer
[	O
x	int
]	O
=	O
p_G	pointer
[	O
x	int
]	O
=	O
p_B	pointer
[	O
x	int
]	O
=	O
0	int
;	O
color_index	int
=	O
index_from_RowBuf	function
(	O
row	pointer
,	O
x	int
,	O
po	pointer
->	O
picbuf	pointer
)	O
;	O
p_R	pointer
[	O
x	int
]	O
=	O
(	O
Byte	char
)	O
(	O
255	int
-	O
pt	struct
.	O
clut	array
[	O
color_index	int
]	O
[	O
0	int
]	O
)	O
;	O
p_G	pointer
[	O
x	int
]	O
=	O
(	O
Byte	char
)	O
(	O
255	int
-	O
pt	struct
.	O
clut	array
[	O
color_index	int
]	O
[	O
1	int
]	O
)	O
;	O
p_B	pointer
[	O
x	int
]	O
=	O
(	O
Byte	char
)	O
(	O
255	int
-	O
pt	struct
.	O
clut	array
[	O
color_index	int
]	O
[	O
2	int
]	O
)	O
;	O
}	O
Buf_to_PCX	function
(	O
p_R	pointer
,	O
8	int
*	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
,	O
fd	pointer
)	O
;	O
Buf_to_PCX	function
(	O
p_G	pointer
,	O
8	int
*	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
,	O
fd	pointer
)	O
;	O
Buf_to_PCX	function
(	O
p_B	pointer
,	O
8	int
*	O
po	pointer
->	O
picbuf	pointer
->	O
nb	int
,	O
fd	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
pg	pointer
->	O
quiet	int
)	O
Eprintf	function
(	O
"\n"	pointer
)	O
;	O
PCX_exit	O
:	O
if	O
(	O
fd	pointer
!=	O
stdout	pointer
)	O
fclose	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
p_R	pointer
!=	O
NULL	O
)	O
free	function
(	O
p_R	pointer
)	O
;	O
if	O
(	O
p_G	pointer
!=	O
NULL	O
)	O
free	function
(	O
p_G	pointer
)	O
;	O
if	O
(	O
p_B	pointer
!=	O
NULL	O
)	O
free	function
(	O
p_B	pointer
)	O
;	O
if	O
(	O
p_I	pointer
!=	O
NULL	O
)	O
free	function
(	O
p_I	pointer
)	O
;	O
return	O
err	int
;	O
}	O
