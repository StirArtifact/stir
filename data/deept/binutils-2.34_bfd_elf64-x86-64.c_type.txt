static	O
reloc_howto_type	struct
x86_64_elf_howto_table	array
[	O
]	O
=	O
{	O
HOWTO	O
(	O
R_X86_64_NONE	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_NONE"	pointer
,	O
FALSE	int
,	O
0x00000000	int
,	O
0x00000000	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_PC32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_PC32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOT32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOT32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_PLT32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_PLT32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_COPY	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_COPY"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GLOB_DAT	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GLOB_DAT"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_JUMP_SLOT	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_JUMP_SLOT"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_RELATIVE	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_RELATIVE"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTPCREL	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTPCREL"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_unsigned	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_32S	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_32S"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_16	int
,	O
0	int
,	O
1	int
,	O
16	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_16"	pointer
,	O
FALSE	int
,	O
0xffff	int
,	O
0xffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_PC16	int
,	O
0	int
,	O
1	int
,	O
16	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_PC16"	pointer
,	O
FALSE	int
,	O
0xffff	int
,	O
0xffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_8	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_8"	pointer
,	O
FALSE	int
,	O
0xff	int
,	O
0xff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_PC8	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_PC8"	pointer
,	O
FALSE	int
,	O
0xff	int
,	O
0xff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_DTPMOD64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_DTPMOD64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_DTPOFF64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_DTPOFF64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_TPOFF64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_TPOFF64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_TLSGD	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_TLSGD"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_TLSLD	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_TLSLD"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_DTPOFF32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_DTPOFF32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTTPOFF	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTTPOFF"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_TPOFF32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_TPOFF32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_PC64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_PC64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTOFF64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTOFF64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTPC32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTPC32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOT64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOT64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTPCREL64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTPCREL64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTPC64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTPC64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTPLT64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTPLT64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_PLTOFF64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_PLTOFF64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_SIZE32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_unsigned	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_SIZE32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_SIZE64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_unsigned	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_SIZE64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTPC32_TLSDESC	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTPC32_TLSDESC"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_TLSDESC_CALL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_TLSDESC_CALL"	pointer
,	O
FALSE	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_TLSDESC	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_TLSDESC"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_IRELATIVE	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_IRELATIVE"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_RELATIVE64	int
,	O
0	int
,	O
4	int
,	O
64	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_RELATIVE64"	pointer
,	O
FALSE	int
,	O
MINUS_ONE	O
,	O
MINUS_ONE	O
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_PC32_BND	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_PC32_BND"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_PLT32_BND	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_PLT32_BND"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GOTPCRELX	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_GOTPCRELX"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_REX_GOTPCRELX	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_REX_GOTPCRELX"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GNU_VTINHERIT	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
NULL	O
,	O
"R_X86_64_GNU_VTINHERIT"	pointer
,	O
FALSE	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_GNU_VTENTRY	int
,	O
0	int
,	O
4	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
_bfd_elf_rel_vtable_reloc_fn	function
,	O
"R_X86_64_GNU_VTENTRY"	pointer
,	O
FALSE	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_X86_64_32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_X86_64_32"	pointer
,	O
FALSE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
}	O
;	O
struct	O
elf_reloc_map	struct
{	O
bfd_reloc_code_real_type	enum
bfd_reloc_val	enum
;	O
unsigned	O
char	O
elf_reloc_val	char
;	O
}	O
;	O
static	O
const	O
struct	O
elf_reloc_map	struct
x86_64_reloc_map	array
[	O
]	O
=	O
{	O
{	O
BFD_RELOC_NONE	int
,	O
R_X86_64_NONE	int
,	O
}	O
,	O
{	O
BFD_RELOC_64	int
,	O
R_X86_64_64	int
,	O
}	O
,	O
{	O
BFD_RELOC_32_PCREL	int
,	O
R_X86_64_PC32	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOT32	int
,	O
R_X86_64_GOT32	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_PLT32	int
,	O
R_X86_64_PLT32	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_COPY	int
,	O
R_X86_64_COPY	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GLOB_DAT	int
,	O
R_X86_64_GLOB_DAT	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_JUMP_SLOT	int
,	O
R_X86_64_JUMP_SLOT	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_RELATIVE	int
,	O
R_X86_64_RELATIVE	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTPCREL	int
,	O
R_X86_64_GOTPCREL	int
,	O
}	O
,	O
{	O
BFD_RELOC_32	int
,	O
R_X86_64_32	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_32S	int
,	O
R_X86_64_32S	int
,	O
}	O
,	O
{	O
BFD_RELOC_16	int
,	O
R_X86_64_16	int
,	O
}	O
,	O
{	O
BFD_RELOC_16_PCREL	int
,	O
R_X86_64_PC16	int
,	O
}	O
,	O
{	O
BFD_RELOC_8	int
,	O
R_X86_64_8	int
,	O
}	O
,	O
{	O
BFD_RELOC_8_PCREL	int
,	O
R_X86_64_PC8	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_DTPMOD64	int
,	O
R_X86_64_DTPMOD64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_DTPOFF64	int
,	O
R_X86_64_DTPOFF64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_TPOFF64	int
,	O
R_X86_64_TPOFF64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_TLSGD	int
,	O
R_X86_64_TLSGD	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_TLSLD	int
,	O
R_X86_64_TLSLD	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_DTPOFF32	int
,	O
R_X86_64_DTPOFF32	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTTPOFF	int
,	O
R_X86_64_GOTTPOFF	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_TPOFF32	int
,	O
R_X86_64_TPOFF32	int
,	O
}	O
,	O
{	O
BFD_RELOC_64_PCREL	int
,	O
R_X86_64_PC64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTOFF64	int
,	O
R_X86_64_GOTOFF64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTPC32	int
,	O
R_X86_64_GOTPC32	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOT64	int
,	O
R_X86_64_GOT64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTPCREL64	int
,	O
R_X86_64_GOTPCREL64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTPC64	int
,	O
R_X86_64_GOTPC64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTPLT64	int
,	O
R_X86_64_GOTPLT64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_PLTOFF64	int
,	O
R_X86_64_PLTOFF64	int
,	O
}	O
,	O
{	O
BFD_RELOC_SIZE32	int
,	O
R_X86_64_SIZE32	int
,	O
}	O
,	O
{	O
BFD_RELOC_SIZE64	int
,	O
R_X86_64_SIZE64	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTPC32_TLSDESC	int
,	O
R_X86_64_GOTPC32_TLSDESC	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_TLSDESC_CALL	int
,	O
R_X86_64_TLSDESC_CALL	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_TLSDESC	int
,	O
R_X86_64_TLSDESC	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_IRELATIVE	int
,	O
R_X86_64_IRELATIVE	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_PC32_BND	int
,	O
R_X86_64_PC32_BND	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_PLT32_BND	int
,	O
R_X86_64_PLT32_BND	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_GOTPCRELX	int
,	O
R_X86_64_GOTPCRELX	int
,	O
}	O
,	O
{	O
BFD_RELOC_X86_64_REX_GOTPCRELX	int
,	O
R_X86_64_REX_GOTPCRELX	int
,	O
}	O
,	O
{	O
BFD_RELOC_VTABLE_INHERIT	int
,	O
R_X86_64_GNU_VTINHERIT	int
,	O
}	O
,	O
{	O
BFD_RELOC_VTABLE_ENTRY	int
,	O
R_X86_64_GNU_VTENTRY	int
,	O
}	O
,	O
}	O
;	O
static	O
reloc_howto_type	struct
*	O
elf_x86_64_rtype_to_howto	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
r_type	int
)	O
{	O
unsigned	O
i	pointer
;	O
if	O
(	O
r_type	int
==	O
(	O
unsigned	O
int	O
)	O
R_X86_64_32	int
)	O
{	O
if	O
(	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
i	pointer
=	O
r_type	int
;	O
else	O
i	pointer
=	O
ARRAY_SIZE	O
(	O
x86_64_elf_howto_table	array
)	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
r_type	int
<	O
(	O
unsigned	O
int	O
)	O
R_X86_64_GNU_VTINHERIT	int
||	O
r_type	int
>=	O
(	O
unsigned	O
int	O
)	O
R_X86_64_max	int
)	O
{	O
if	O
(	O
r_type	int
>=	O
(	O
unsigned	O
int	O
)	O
R_X86_64_standard	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unsupported relocation type %#x"	pointer
)	O
,	O
abfd	pointer
,	O
r_type	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
NULL	O
;	O
}	O
i	pointer
=	O
r_type	int
;	O
}	O
else	O
i	pointer
=	O
r_type	int
-	O
(	O
unsigned	O
int	O
)	O
R_X86_64_vt_offset	O
;	O
BFD_ASSERT	O
(	O
x86_64_elf_howto_table	array
[	O
i	pointer
]	O
.	O
type	enum
==	O
r_type	int
)	O
;	O
return	O
&	O
x86_64_elf_howto_table	array
[	O
i	pointer
]	O
;	O
}	O
static	O
reloc_howto_type	struct
*	O
elf_x86_64_reloc_type_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_reloc_code_real_type	enum
code	int
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
sizeof	O
(	O
x86_64_reloc_map	array
)	O
/	O
sizeof	O
(	O
struct	O
elf_reloc_map	struct
)	O
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
x86_64_reloc_map	array
[	O
i	pointer
]	O
.	O
bfd_reloc_val	enum
==	O
code	int
)	O
return	O
elf_x86_64_rtype_to_howto	function
(	O
abfd	pointer
,	O
x86_64_reloc_map	array
[	O
i	pointer
]	O
.	O
elf_reloc_val	char
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
reloc_howto_type	struct
*	O
elf_x86_64_reloc_name_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
r_name	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
!	O
ABI_64_P	O
(	O
abfd	pointer
)	O
&&	O
strcasecmp	function
(	O
r_name	pointer
,	O
"R_X86_64_32"	pointer
)	O
==	O
0	int
)	O
{	O
reloc_howto_type	struct
*	O
reloc	enum
=	O
&	O
x86_64_elf_howto_table	array
[	O
ARRAY_SIZE	O
(	O
x86_64_elf_howto_table	array
)	O
-	O
1	int
]	O
;	O
BFD_ASSERT	O
(	O
reloc	enum
->	O
type	enum
==	O
(	O
unsigned	O
int	O
)	O
R_X86_64_32	int
)	O
;	O
return	O
reloc	enum
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ARRAY_SIZE	O
(	O
x86_64_elf_howto_table	array
)	O
;	O
i	pointer
++	O
)	O
if	O
(	O
x86_64_elf_howto_table	array
[	O
i	pointer
]	O
.	O
name	pointer
!=	O
NULL	O
&&	O
strcasecmp	function
(	O
x86_64_elf_howto_table	array
[	O
i	pointer
]	O
.	O
name	pointer
,	O
r_name	pointer
)	O
==	O
0	int
)	O
return	O
&	O
x86_64_elf_howto_table	array
[	O
i	pointer
]	O
;	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_info_to_howto	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
arelent	struct
*	O
cache_ptr	pointer
,	O
Elf_Internal_Rela	struct
*	O
dst	pointer
)	O
{	O
unsigned	O
r_type	int
;	O
r_type	int
=	O
ELF32_R_TYPE	O
(	O
dst	pointer
->	O
r_info	array
)	O
;	O
cache_ptr	pointer
->	O
howto	pointer
=	O
elf_x86_64_rtype_to_howto	function
(	O
abfd	pointer
,	O
r_type	int
)	O
;	O
if	O
(	O
cache_ptr	pointer
->	O
howto	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
BFD_ASSERT	O
(	O
r_type	int
==	O
cache_ptr	pointer
->	O
howto	pointer
->	O
type	enum
||	O
cache_ptr	pointer
->	O
howto	pointer
->	O
type	enum
==	O
R_X86_64_NONE	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_grok_prstatus	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
int	O
offset	long
;	O
size_t	long
size	long
;	O
switch	O
(	O
note	pointer
->	O
descsz	array
)	O
{	O
default	O
:	O
return	O
FALSE	int
;	O
case	O
296	int
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
12	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
24	int
)	O
;	O
offset	long
=	O
72	int
;	O
size	long
=	O
216	int
;	O
break	O
;	O
case	O
336	int
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
12	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
32	int
)	O
;	O
offset	long
=	O
112	int
;	O
size	long
=	O
216	int
;	O
break	O
;	O
}	O
return	O
_bfd_elfcore_make_pseudosection	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
size	long
,	O
note	pointer
->	O
descpos	long
+	O
offset	long
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_grok_psinfo	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
switch	O
(	O
note	pointer
->	O
descsz	array
)	O
{	O
default	O
:	O
return	O
FALSE	int
;	O
case	O
124	int
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
12	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
program	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
28	int
,	O
16	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
44	int
,	O
80	int
)	O
;	O
break	O
;	O
case	O
136	int
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
24	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
program	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
40	int
,	O
16	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
56	int
,	O
80	int
)	O
;	O
}	O
{	O
char	O
*	O
command	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
;	O
int	O
n	long
=	O
strlen	function
(	O
command	pointer
)	O
;	O
if	O
(	O
0	int
<	O
n	long
&&	O
command	pointer
[	O
n	long
-	O
1	int
]	O
==	O
' '	O
)	O
command	pointer
[	O
n	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
char	O
*	O
elf_x86_64_write_core_note	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
bufsiz	pointer
,	O
int	O
note_type	int
,	O
...	O
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
va_list	array
ap	array
;	O
const	O
char	O
*	O
fname	pointer
,	O
*	O
psargs	pointer
;	O
long	O
pid	int
;	O
int	O
cursig	int
;	O
const	O
void	O
*	O
gregs	pointer
;	O
switch	O
(	O
note_type	int
)	O
{	O
default	O
:	O
return	O
NULL	O
;	O
case	O
NT_PRPSINFO	int
:	O
va_start	O
(	O
ap	array
,	O
note_type	int
)	O
;	O
fname	pointer
=	O
va_arg	O
(	O
ap	array
,	O
const	O
char	O
*	O
)	O
;	O
psargs	pointer
=	O
va_arg	O
(	O
ap	array
,	O
const	O
char	O
*	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS32	int
)	O
{	O
prpsinfo32_t	struct
data	pointer
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
strncpy	function
(	O
data	pointer
.	O
pr_fname	array
,	O
fname	pointer
,	O
sizeof	O
(	O
data	pointer
.	O
pr_fname	array
)	O
)	O
;	O
strncpy	function
(	O
data	pointer
.	O
pr_psargs	array
,	O
psargs	pointer
,	O
sizeof	O
(	O
data	pointer
.	O
pr_psargs	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
note_type	int
,	O
&	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
}	O
else	O
{	O
prpsinfo64_t	struct
data	pointer
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
strncpy	function
(	O
data	pointer
.	O
pr_fname	array
,	O
fname	pointer
,	O
sizeof	O
(	O
data	pointer
.	O
pr_fname	array
)	O
)	O
;	O
strncpy	function
(	O
data	pointer
.	O
pr_psargs	array
,	O
psargs	pointer
,	O
sizeof	O
(	O
data	pointer
.	O
pr_psargs	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
note_type	int
,	O
&	O
data	pointer
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
}	O
case	O
NT_PRSTATUS	int
:	O
va_start	O
(	O
ap	array
,	O
note_type	int
)	O
;	O
pid	int
=	O
va_arg	O
(	O
ap	array
,	O
long	O
)	O
;	O
cursig	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
gregs	pointer
=	O
va_arg	O
(	O
ap	array
,	O
const	O
void	O
*	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
bed	pointer
->	O
s	pointer
->	O
elfclass	char
==	O
ELFCLASS32	int
)	O
{	O
if	O
(	O
bed	pointer
->	O
elf_machine_code	int
==	O
EM_X86_64	int
)	O
{	O
prstatusx32_t	struct
prstat	struct
;	O
memset	function
(	O
&	O
prstat	struct
,	O
0	int
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
prstat	struct
.	O
pr_pid	int
=	O
pid	int
;	O
prstat	struct
.	O
pr_cursig	short
=	O
cursig	int
;	O
memcpy	function
(	O
&	O
prstat	struct
.	O
pr_reg	array
,	O
gregs	pointer
,	O
sizeof	O
(	O
prstat	struct
.	O
pr_reg	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
note_type	int
,	O
&	O
prstat	struct
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
}	O
else	O
{	O
prstatus32_t	struct
prstat	struct
;	O
memset	function
(	O
&	O
prstat	struct
,	O
0	int
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
prstat	struct
.	O
pr_pid	int
=	O
pid	int
;	O
prstat	struct
.	O
pr_cursig	short
=	O
cursig	int
;	O
memcpy	function
(	O
&	O
prstat	struct
.	O
pr_reg	array
,	O
gregs	pointer
,	O
sizeof	O
(	O
prstat	struct
.	O
pr_reg	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
note_type	int
,	O
&	O
prstat	struct
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
}	O
}	O
else	O
{	O
prstatus64_t	struct
prstat	struct
;	O
memset	function
(	O
&	O
prstat	struct
,	O
0	int
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
prstat	struct
.	O
pr_pid	int
=	O
pid	int
;	O
prstat	struct
.	O
pr_cursig	short
=	O
cursig	int
;	O
memcpy	function
(	O
&	O
prstat	struct
.	O
pr_reg	array
,	O
gregs	pointer
,	O
sizeof	O
(	O
prstat	struct
.	O
pr_reg	array
)	O
)	O
;	O
return	O
elfcore_write_note	function
(	O
abfd	pointer
,	O
buf	pointer
,	O
bufsiz	pointer
,	O
"CORE"	pointer
,	O
note_type	int
,	O
&	O
prstat	struct
,	O
sizeof	O
(	O
prstat	struct
)	O
)	O
;	O
}	O
}	O
}	O
static	O
const	O
bfd_byte	char
elf_x86_64_lazy_plt0_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0x35	int
,	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xff	int
,	O
0x25	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x40	int
,	O
0x00	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_lazy_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_lazy_bnd_plt0_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0x35	int
,	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xf2	int
,	O
0xff	int
,	O
0x25	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_lazy_bnd_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xf2	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x44	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_lazy_ibt_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf3	int
,	O
0x0f	int
,	O
0x1e	int
,	O
0xfa	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xf2	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x32_lazy_ibt_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf3	int
,	O
0x0f	int
,	O
0x1e	int
,	O
0xfa	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_non_lazy_plt_entry	array
[	O
NON_LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_non_lazy_bnd_plt_entry	array
[	O
NON_LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf2	int
,	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_non_lazy_ibt_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf3	int
,	O
0x0f	int
,	O
0x1e	int
,	O
0xfa	int
,	O
0xf2	int
,	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x44	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x32_non_lazy_ibt_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf3	int
,	O
0x0f	int
,	O
0x1e	int
,	O
0xfa	int
,	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x44	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_tlsdesc_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf3	int
,	O
0x0f	int
,	O
0x1e	int
,	O
0xfa	int
,	O
0xff	int
,	O
0x35	int
,	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xff	int
,	O
0x25	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_eh_frame_lazy_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x78	int
,	O
16	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
7	int
,	O
8	int
,	O
DW_CFA_offset	int
+	O
16	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_def_cfa_offset	int
,	O
16	int
,	O
DW_CFA_advance_loc	int
+	O
6	int
,	O
DW_CFA_def_cfa_offset	int
,	O
24	int
,	O
DW_CFA_advance_loc	int
+	O
10	int
,	O
DW_CFA_def_cfa_expression	int
,	O
11	int
,	O
DW_OP_breg7	int
,	O
8	int
,	O
DW_OP_breg16	int
,	O
0	int
,	O
DW_OP_lit15	int
,	O
DW_OP_and	int
,	O
DW_OP_lit11	int
,	O
DW_OP_ge	int
,	O
DW_OP_lit3	int
,	O
DW_OP_shl	int
,	O
DW_OP_plus	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_eh_frame_lazy_bnd_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x78	int
,	O
16	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
7	int
,	O
8	int
,	O
DW_CFA_offset	int
+	O
16	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_def_cfa_offset	int
,	O
16	int
,	O
DW_CFA_advance_loc	int
+	O
6	int
,	O
DW_CFA_def_cfa_offset	int
,	O
24	int
,	O
DW_CFA_advance_loc	int
+	O
10	int
,	O
DW_CFA_def_cfa_expression	int
,	O
11	int
,	O
DW_OP_breg7	int
,	O
8	int
,	O
DW_OP_breg16	int
,	O
0	int
,	O
DW_OP_lit15	int
,	O
DW_OP_and	int
,	O
DW_OP_lit5	int
,	O
DW_OP_ge	int
,	O
DW_OP_lit3	int
,	O
DW_OP_shl	int
,	O
DW_OP_plus	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_eh_frame_lazy_ibt_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x78	int
,	O
16	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
7	int
,	O
8	int
,	O
DW_CFA_offset	int
+	O
16	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_def_cfa_offset	int
,	O
16	int
,	O
DW_CFA_advance_loc	int
+	O
6	int
,	O
DW_CFA_def_cfa_offset	int
,	O
24	int
,	O
DW_CFA_advance_loc	int
+	O
10	int
,	O
DW_CFA_def_cfa_expression	int
,	O
11	int
,	O
DW_OP_breg7	int
,	O
8	int
,	O
DW_OP_breg16	int
,	O
0	int
,	O
DW_OP_lit15	int
,	O
DW_OP_and	int
,	O
DW_OP_lit10	int
,	O
DW_OP_ge	int
,	O
DW_OP_lit3	int
,	O
DW_OP_shl	int
,	O
DW_OP_plus	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x32_eh_frame_lazy_ibt_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x78	int
,	O
16	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
7	int
,	O
8	int
,	O
DW_CFA_offset	int
+	O
16	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_def_cfa_offset	int
,	O
16	int
,	O
DW_CFA_advance_loc	int
+	O
6	int
,	O
DW_CFA_def_cfa_offset	int
,	O
24	int
,	O
DW_CFA_advance_loc	int
+	O
10	int
,	O
DW_CFA_def_cfa_expression	int
,	O
11	int
,	O
DW_OP_breg7	int
,	O
8	int
,	O
DW_OP_breg16	int
,	O
0	int
,	O
DW_OP_lit15	int
,	O
DW_OP_and	int
,	O
DW_OP_lit9	int
,	O
DW_OP_ge	int
,	O
DW_OP_lit3	int
,	O
DW_OP_shl	int
,	O
DW_OP_plus	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_eh_frame_non_lazy_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x78	int
,	O
16	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
7	int
,	O
8	int
,	O
DW_CFA_offset	int
+	O
16	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_GOT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_x86_64_lazy_plt	struct
=	O
{	O
elf_x86_64_lazy_plt0_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_lazy_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_tlsdesc_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
6	int
,	O
12	int
,	O
10	int
,	O
16	int
,	O
2	int
,	O
8	int
,	O
12	int
,	O
2	int
,	O
7	int
,	O
12	int
,	O
6	int
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
6	int
,	O
elf_x86_64_lazy_plt0_entry	array
,	O
elf_x86_64_lazy_plt_entry	array
,	O
elf_x86_64_eh_frame_lazy_plt	array
,	O
sizeof	O
(	O
elf_x86_64_eh_frame_lazy_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
elf_x86_64_non_lazy_plt	struct
=	O
{	O
elf_x86_64_non_lazy_plt_entry	array
,	O
elf_x86_64_non_lazy_plt_entry	array
,	O
NON_LAZY_PLT_ENTRY_SIZE	int
,	O
2	int
,	O
6	int
,	O
elf_x86_64_eh_frame_non_lazy_plt	array
,	O
sizeof	O
(	O
elf_x86_64_eh_frame_non_lazy_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_x86_64_lazy_bnd_plt	struct
=	O
{	O
elf_x86_64_lazy_bnd_plt0_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_lazy_bnd_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_tlsdesc_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
6	int
,	O
12	int
,	O
10	int
,	O
16	int
,	O
2	int
,	O
1	int
+	O
8	int
,	O
1	int
+	O
12	int
,	O
1	int
+	O
2	int
,	O
1	int
,	O
7	int
,	O
1	int
+	O
6	int
,	O
11	int
,	O
0	int
,	O
elf_x86_64_lazy_bnd_plt0_entry	array
,	O
elf_x86_64_lazy_bnd_plt_entry	array
,	O
elf_x86_64_eh_frame_lazy_bnd_plt	array
,	O
sizeof	O
(	O
elf_x86_64_eh_frame_lazy_bnd_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
elf_x86_64_non_lazy_bnd_plt	struct
=	O
{	O
elf_x86_64_non_lazy_bnd_plt_entry	array
,	O
elf_x86_64_non_lazy_bnd_plt_entry	array
,	O
NON_LAZY_PLT_ENTRY_SIZE	int
,	O
1	int
+	O
2	int
,	O
1	int
+	O
6	int
,	O
elf_x86_64_eh_frame_non_lazy_plt	array
,	O
sizeof	O
(	O
elf_x86_64_eh_frame_non_lazy_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_x86_64_lazy_ibt_plt	struct
=	O
{	O
elf_x86_64_lazy_bnd_plt0_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_lazy_ibt_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_tlsdesc_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
6	int
,	O
12	int
,	O
10	int
,	O
16	int
,	O
2	int
,	O
1	int
+	O
8	int
,	O
1	int
+	O
12	int
,	O
4	int
+	O
1	int
+	O
2	int
,	O
4	int
+	O
1	int
,	O
4	int
+	O
1	int
+	O
6	int
,	O
4	int
+	O
1	int
+	O
6	int
,	O
4	int
+	O
1	int
+	O
5	int
+	O
5	int
,	O
0	int
,	O
elf_x86_64_lazy_bnd_plt0_entry	array
,	O
elf_x86_64_lazy_ibt_plt_entry	array
,	O
elf_x86_64_eh_frame_lazy_ibt_plt	array
,	O
sizeof	O
(	O
elf_x86_64_eh_frame_lazy_ibt_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_x32_lazy_ibt_plt	struct
=	O
{	O
elf_x86_64_lazy_plt0_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
elf_x32_lazy_ibt_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_tlsdesc_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
6	int
,	O
12	int
,	O
10	int
,	O
16	int
,	O
2	int
,	O
8	int
,	O
12	int
,	O
4	int
+	O
2	int
,	O
4	int
+	O
1	int
,	O
4	int
+	O
6	int
,	O
4	int
+	O
6	int
,	O
4	int
+	O
5	int
+	O
5	int
,	O
0	int
,	O
elf_x86_64_lazy_plt0_entry	array
,	O
elf_x32_lazy_ibt_plt_entry	array
,	O
elf_x32_eh_frame_lazy_ibt_plt	array
,	O
sizeof	O
(	O
elf_x32_eh_frame_lazy_ibt_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
elf_x86_64_non_lazy_ibt_plt	struct
=	O
{	O
elf_x86_64_non_lazy_ibt_plt_entry	array
,	O
elf_x86_64_non_lazy_ibt_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
4	int
+	O
1	int
+	O
2	int
,	O
4	int
+	O
1	int
+	O
6	int
,	O
elf_x86_64_eh_frame_non_lazy_plt	array
,	O
sizeof	O
(	O
elf_x86_64_eh_frame_non_lazy_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
elf_x32_non_lazy_ibt_plt	struct
=	O
{	O
elf_x32_non_lazy_ibt_plt_entry	array
,	O
elf_x32_non_lazy_ibt_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
4	int
+	O
2	int
,	O
4	int
+	O
6	int
,	O
elf_x86_64_eh_frame_non_lazy_plt	array
,	O
sizeof	O
(	O
elf_x86_64_eh_frame_non_lazy_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_backend_data	struct
elf_x86_64_arch_bed	struct
=	O
{	O
is_normal	int
}	O
;	O
static	O
bfd_boolean	int
elf64_x86_64_elf_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
bfd_arch_i386	int
,	O
bfd_mach_x86_64	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf32_x86_64_elf_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
bfd_arch_i386	int
,	O
bfd_mach_x64_32	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_check_tls_transition	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
,	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
,	O
unsigned	O
int	O
r_type	int
,	O
const	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
const	O
Elf_Internal_Rela	struct
*	O
relend	pointer
)	O
{	O
unsigned	O
int	O
val	array
;	O
unsigned	O
long	O
r_symndx	long
;	O
bfd_boolean	int
largepic	int
=	O
FALSE	int
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
bfd_vma	long
offset	long
;	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
bfd_byte	char
*	O
call	pointer
;	O
bfd_boolean	int
indirect_call	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
X86_64_ELF_DATA	int
)	O
;	O
offset	long
=	O
rel	pointer
->	O
r_offset	array
;	O
switch	O
(	O
r_type	int
)	O
{	O
case	O
R_X86_64_TLSGD	int
:	O
case	O
R_X86_64_TLSLD	int
:	O
if	O
(	O
(	O
rel	pointer
+	O
1	int
)	O
>=	O
relend	pointer
)	O
return	O
FALSE	int
;	O
if	O
(	O
r_type	int
==	O
R_X86_64_TLSGD	int
)	O
{	O
static	O
const	O
unsigned	O
char	O
leaq	array
[	O
]	O
=	O
{	O
0x66	int
,	O
0x48	int
,	O
0x8d	int
,	O
0x3d	int
}	O
;	O
if	O
(	O
(	O
offset	long
+	O
12	int
)	O
>	O
sec	pointer
->	O
size	long
)	O
return	O
FALSE	int
;	O
call	pointer
=	O
contents	pointer
+	O
offset	long
+	O
4	int
;	O
if	O
(	O
call	pointer
[	O
0	int
]	O
!=	O
0x66	int
||	O
!	O
(	O
(	O
call	pointer
[	O
1	int
]	O
==	O
0x48	int
&&	O
call	pointer
[	O
2	int
]	O
==	O
0xff	int
&&	O
call	pointer
[	O
3	int
]	O
==	O
0x15	int
)	O
||	O
(	O
call	pointer
[	O
1	int
]	O
==	O
0x48	int
&&	O
call	pointer
[	O
2	int
]	O
==	O
0x67	int
&&	O
call	pointer
[	O
3	int
]	O
==	O
0xe8	int
)	O
||	O
(	O
call	pointer
[	O
1	int
]	O
==	O
0x66	int
&&	O
call	pointer
[	O
2	int
]	O
==	O
0x48	int
&&	O
call	pointer
[	O
3	int
]	O
==	O
0xe8	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
ABI_64_P	O
(	O
abfd	pointer
)	O
||	O
(	O
offset	long
+	O
19	int
)	O
>	O
sec	pointer
->	O
size	long
||	O
offset	long
<	O
3	int
||	O
memcmp	function
(	O
call	pointer
-	O
7	int
,	O
leaq	array
+	O
1	int
,	O
3	int
)	O
!=	O
0	int
||	O
memcmp	function
(	O
call	pointer
,	O
"\x48\xb8"	pointer
,	O
2	int
)	O
!=	O
0	int
||	O
call	pointer
[	O
11	int
]	O
!=	O
0x01	int
||	O
call	pointer
[	O
13	int
]	O
!=	O
0xff	int
||	O
call	pointer
[	O
14	int
]	O
!=	O
0xd0	int
||	O
!	O
(	O
(	O
call	pointer
[	O
10	int
]	O
==	O
0x48	int
&&	O
call	pointer
[	O
12	int
]	O
==	O
0xd8	int
)	O
||	O
(	O
call	pointer
[	O
10	int
]	O
==	O
0x4c	int
&&	O
call	pointer
[	O
12	int
]	O
==	O
0xf8	int
)	O
)	O
)	O
return	O
FALSE	int
;	O
largepic	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
offset	long
<	O
4	int
||	O
memcmp	function
(	O
contents	pointer
+	O
offset	long
-	O
4	int
,	O
leaq	array
,	O
4	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
offset	long
<	O
3	int
||	O
memcmp	function
(	O
contents	pointer
+	O
offset	long
-	O
3	int
,	O
leaq	array
+	O
1	int
,	O
3	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
}	O
indirect_call	int
=	O
call	pointer
[	O
2	int
]	O
==	O
0xff	int
;	O
}	O
else	O
{	O
static	O
const	O
unsigned	O
char	O
lea	array
[	O
]	O
=	O
{	O
0x48	int
,	O
0x8d	int
,	O
0x3d	int
}	O
;	O
if	O
(	O
offset	long
<	O
3	int
||	O
(	O
offset	long
+	O
9	int
)	O
>	O
sec	pointer
->	O
size	long
)	O
return	O
FALSE	int
;	O
if	O
(	O
memcmp	function
(	O
contents	pointer
+	O
offset	long
-	O
3	int
,	O
lea	array
,	O
3	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
call	pointer
=	O
contents	pointer
+	O
offset	long
+	O
4	int
;	O
if	O
(	O
!	O
(	O
call	pointer
[	O
0	int
]	O
==	O
0xe8	int
||	O
(	O
call	pointer
[	O
0	int
]	O
==	O
0xff	int
&&	O
call	pointer
[	O
1	int
]	O
==	O
0x15	int
)	O
||	O
(	O
call	pointer
[	O
0	int
]	O
==	O
0x67	int
&&	O
call	pointer
[	O
1	int
]	O
==	O
0xe8	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
ABI_64_P	O
(	O
abfd	pointer
)	O
||	O
(	O
offset	long
+	O
19	int
)	O
>	O
sec	pointer
->	O
size	long
||	O
memcmp	function
(	O
call	pointer
,	O
"\x48\xb8"	pointer
,	O
2	int
)	O
!=	O
0	int
||	O
call	pointer
[	O
11	int
]	O
!=	O
0x01	int
||	O
call	pointer
[	O
13	int
]	O
!=	O
0xff	int
||	O
call	pointer
[	O
14	int
]	O
!=	O
0xd0	int
||	O
!	O
(	O
(	O
call	pointer
[	O
10	int
]	O
==	O
0x48	int
&&	O
call	pointer
[	O
12	int
]	O
==	O
0xd8	int
)	O
||	O
(	O
call	pointer
[	O
10	int
]	O
==	O
0x4c	int
&&	O
call	pointer
[	O
12	int
]	O
==	O
0xf8	int
)	O
)	O
)	O
return	O
FALSE	int
;	O
largepic	int
=	O
TRUE	int
;	O
}	O
indirect_call	int
=	O
call	pointer
[	O
0	int
]	O
==	O
0xff	int
;	O
}	O
r_symndx	long
=	O
htab	struct
->	O
r_sym	pointer
(	O
rel	pointer
[	O
1	int
]	O
.	O
r_info	array
)	O
;	O
if	O
(	O
r_symndx	long
<	O
symtab_hdr	struct
->	O
sh_info	array
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
sym_hashes	pointer
[	O
r_symndx	long
-	O
symtab_hdr	struct
->	O
sh_info	array
]	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
||	O
!	O
(	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
)	O
->	O
tls_get_addr	int
)	O
return	O
FALSE	int
;	O
else	O
{	O
r_type	int
=	O
(	O
ELF32_R_TYPE	O
(	O
rel	pointer
[	O
1	int
]	O
.	O
r_info	array
)	O
&	O
~	O
R_X86_64_converted_reloc_bit	O
)	O
;	O
if	O
(	O
largepic	int
)	O
return	O
r_type	int
==	O
R_X86_64_PLTOFF64	int
;	O
else	O
if	O
(	O
indirect_call	int
)	O
return	O
r_type	int
==	O
R_X86_64_GOTPCRELX	int
;	O
else	O
return	O
(	O
r_type	int
==	O
R_X86_64_PC32	int
||	O
r_type	int
==	O
R_X86_64_PLT32	int
)	O
;	O
}	O
case	O
R_X86_64_GOTTPOFF	int
:	O
if	O
(	O
offset	long
>=	O
3	int
&&	O
(	O
offset	long
+	O
4	int
)	O
<=	O
sec	pointer
->	O
size	long
)	O
{	O
val	array
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
3	int
)	O
;	O
if	O
(	O
val	array
!=	O
0x48	int
&&	O
val	array
!=	O
0x4c	int
)	O
{	O
if	O
(	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
offset	long
<	O
2	int
||	O
(	O
offset	long
+	O
3	int
)	O
>	O
sec	pointer
->	O
size	long
)	O
return	O
FALSE	int
;	O
}	O
val	array
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
2	int
)	O
;	O
if	O
(	O
val	array
!=	O
0x8b	int
&&	O
val	array
!=	O
0x03	int
)	O
return	O
FALSE	int
;	O
val	array
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
1	int
)	O
;	O
return	O
(	O
val	array
&	O
0xc7	int
)	O
==	O
5	int
;	O
case	O
R_X86_64_GOTPC32_TLSDESC	int
:	O
if	O
(	O
offset	long
<	O
3	int
||	O
(	O
offset	long
+	O
4	int
)	O
>	O
sec	pointer
->	O
size	long
)	O
return	O
FALSE	int
;	O
val	array
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
3	int
)	O
;	O
if	O
(	O
(	O
val	array
&	O
0xfb	int
)	O
!=	O
0x48	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
2	int
)	O
!=	O
0x8d	int
)	O
return	O
FALSE	int
;	O
val	array
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
1	int
)	O
;	O
return	O
(	O
val	array
&	O
0xc7	int
)	O
==	O
0x05	int
;	O
case	O
R_X86_64_TLSDESC_CALL	int
:	O
if	O
(	O
offset	long
+	O
2	int
<=	O
sec	pointer
->	O
size	long
)	O
{	O
call	pointer
=	O
contents	pointer
+	O
offset	long
;	O
return	O
call	pointer
[	O
0	int
]	O
==	O
0xff	int
&&	O
call	pointer
[	O
1	int
]	O
==	O
0x10	int
;	O
}	O
return	O
FALSE	int
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
elf_x86_64_tls_transition	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
,	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
,	O
unsigned	O
int	O
*	O
r_type	int
,	O
int	O
tls_type	char
,	O
const	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
const	O
Elf_Internal_Rela	struct
*	O
relend	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
unsigned	O
long	O
r_symndx	long
,	O
bfd_boolean	int
from_relocate_section	int
)	O
{	O
unsigned	O
int	O
from_type	int
=	O
*	O
r_type	int
;	O
unsigned	O
int	O
to_type	int
=	O
from_type	int
;	O
bfd_boolean	int
check	int
=	O
TRUE	int
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
||	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
)	O
return	O
TRUE	int
;	O
switch	O
(	O
from_type	int
)	O
{	O
case	O
R_X86_64_TLSGD	int
:	O
case	O
R_X86_64_GOTPC32_TLSDESC	int
:	O
case	O
R_X86_64_TLSDESC_CALL	int
:	O
case	O
R_X86_64_GOTTPOFF	int
:	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
to_type	int
=	O
R_X86_64_TPOFF32	int
;	O
else	O
to_type	int
=	O
R_X86_64_GOTTPOFF	int
;	O
}	O
if	O
(	O
from_relocate_section	int
)	O
{	O
unsigned	O
int	O
new_to_type	int
=	O
to_type	int
;	O
if	O
(	O
TLS_TRANSITION_IE_TO_LE_P	O
(	O
info	pointer
,	O
h	pointer
,	O
tls_type	char
)	O
)	O
new_to_type	int
=	O
R_X86_64_TPOFF32	int
;	O
if	O
(	O
to_type	int
==	O
R_X86_64_TLSGD	int
||	O
to_type	int
==	O
R_X86_64_GOTPC32_TLSDESC	int
||	O
to_type	int
==	O
R_X86_64_TLSDESC_CALL	int
)	O
{	O
if	O
(	O
tls_type	char
==	O
GOT_TLS_IE	int
)	O
new_to_type	int
=	O
R_X86_64_GOTTPOFF	int
;	O
}	O
check	int
=	O
new_to_type	int
!=	O
to_type	int
&&	O
from_type	int
==	O
to_type	int
;	O
to_type	int
=	O
new_to_type	int
;	O
}	O
break	O
;	O
case	O
R_X86_64_TLSLD	int
:	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
to_type	int
=	O
R_X86_64_TPOFF32	int
;	O
break	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
from_type	int
==	O
to_type	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
check	int
&&	O
!	O
elf_x86_64_check_tls_transition	function
(	O
abfd	pointer
,	O
info	pointer
,	O
sec	pointer
,	O
contents	pointer
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
from_type	int
,	O
rel	pointer
,	O
relend	pointer
)	O
)	O
{	O
reloc_howto_type	struct
*	O
from	pointer
,	O
*	O
to	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
from	pointer
=	O
elf_x86_64_rtype_to_howto	function
(	O
abfd	pointer
,	O
from_type	int
)	O
;	O
to	pointer
=	O
elf_x86_64_rtype_to_howto	function
(	O
abfd	pointer
,	O
to_type	int
)	O
;	O
if	O
(	O
from	pointer
==	O
NULL	O
||	O
to	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
h	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
X86_64_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
name	pointer
=	O
"*unknown*"	pointer
;	O
else	O
{	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
isym	pointer
=	O
bfd_sym_from_r_symndx	function
(	O
&	O
htab	struct
->	O
sym_cache	struct
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: TLS transition from %s to %s against `%s' at %#"	pointer
PRIx64	O
" in section `%pA' failed"	pointer
)	O
,	O
abfd	pointer
,	O
from	pointer
->	O
name	pointer
,	O
to	pointer
->	O
name	pointer
,	O
name	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_offset	array
,	O
sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
*	O
r_type	int
=	O
to_type	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_need_pic	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
,	O
Elf_Internal_Sym	struct
*	O
isym	pointer
,	O
reloc_howto_type	struct
*	O
howto	pointer
)	O
{	O
const	O
char	O
*	O
v	pointer
=	O
""	pointer
;	O
const	O
char	O
*	O
und	pointer
=	O
""	pointer
;	O
const	O
char	O
*	O
pic	pointer
=	O
""	pointer
;	O
const	O
char	O
*	O
object	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
h	pointer
)	O
{	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
switch	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
)	O
{	O
case	O
STV_HIDDEN	int
:	O
v	pointer
=	O
_	O
(	O
"hidden symbol "	pointer
)	O
;	O
break	O
;	O
case	O
STV_INTERNAL	int
:	O
v	pointer
=	O
_	O
(	O
"internal symbol "	pointer
)	O
;	O
break	O
;	O
case	O
STV_PROTECTED	int
:	O
v	pointer
=	O
_	O
(	O
"protected symbol "	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
)	O
->	O
def_protected	int
)	O
v	pointer
=	O
_	O
(	O
"protected symbol "	pointer
)	O
;	O
else	O
v	pointer
=	O
_	O
(	O
"symbol "	pointer
)	O
;	O
pic	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
SYMBOL_DEFINED_NON_SHARED_P	O
(	O
h	pointer
)	O
&&	O
!	O
h	pointer
->	O
def_dynamic	int
)	O
und	pointer
=	O
_	O
(	O
"undefined "	pointer
)	O
;	O
}	O
else	O
{	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
pic	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
bfd_link_dll	O
(	O
info	pointer
)	O
)	O
{	O
object	pointer
=	O
_	O
(	O
"a shared object"	pointer
)	O
;	O
if	O
(	O
!	O
pic	pointer
)	O
pic	pointer
=	O
_	O
(	O
"; recompile with -fPIC"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
bfd_link_pie	O
(	O
info	pointer
)	O
)	O
object	pointer
=	O
_	O
(	O
"a PIE object"	pointer
)	O
;	O
else	O
object	pointer
=	O
_	O
(	O
"a PDE object"	pointer
)	O
;	O
if	O
(	O
!	O
pic	pointer
)	O
pic	pointer
=	O
_	O
(	O
"; recompile with -fPIE"	pointer
)	O
;	O
}	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation %s against %s%s`%s' can "	pointer
"not be used when making %s%s"	pointer
)	O
,	O
input_bfd	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
und	pointer
,	O
v	pointer
,	O
name	pointer
,	O
object	pointer
,	O
pic	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
sec	pointer
->	O
check_relocs_failed	O
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_convert_load_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
unsigned	O
int	O
*	O
r_type_p	pointer
,	O
Elf_Internal_Rela	struct
*	O
irel	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
bfd_boolean	int
*	O
converted	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
bfd_boolean	int
is_pic	int
;	O
bfd_boolean	int
no_overflow	int
;	O
bfd_boolean	int
relocx	int
;	O
bfd_boolean	int
to_reloc_pc32	int
;	O
asection	struct
*	O
tsec	pointer
;	O
bfd_signed_vma	long
raddend	long
;	O
unsigned	O
int	O
opcode	int
;	O
unsigned	O
int	O
modrm	int
;	O
unsigned	O
int	O
r_type	int
=	O
*	O
r_type_p	pointer
;	O
unsigned	O
int	O
r_symndx	long
;	O
bfd_vma	long
roff	long
=	O
irel	pointer
->	O
r_offset	array
;	O
if	O
(	O
roff	long
<	O
(	O
r_type	int
==	O
R_X86_64_REX_GOTPCRELX	int
?	O
3	int
:	O
2	int
)	O
)	O
return	O
TRUE	int
;	O
raddend	long
=	O
irel	pointer
->	O
r_addend	array
;	O
if	O
(	O
raddend	long
!=	O
-	O
4	int
)	O
return	O
TRUE	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
link_info	pointer
,	O
X86_64_ELF_DATA	int
)	O
;	O
is_pic	int
=	O
bfd_link_pic	O
(	O
link_info	pointer
)	O
;	O
relocx	int
=	O
(	O
r_type	int
==	O
R_X86_64_GOTPCRELX	int
||	O
r_type	int
==	O
R_X86_64_REX_GOTPCRELX	int
)	O
;	O
no_overflow	int
=	O
link_info	pointer
->	O
disable_target_specific_optimizations	int
>	O
1	int
;	O
r_symndx	long
=	O
htab	struct
->	O
r_sym	pointer
(	O
irel	pointer
->	O
r_info	array
)	O
;	O
opcode	int
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
if	O
(	O
opcode	int
!=	O
0x8b	int
)	O
{	O
if	O
(	O
!	O
relocx	int
)	O
return	O
TRUE	int
;	O
}	O
to_reloc_pc32	int
=	O
(	O
opcode	int
==	O
0xff	int
||	O
!	O
relocx	int
||	O
no_overflow	int
||	O
is_pic	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
Elf_Internal_Sym	struct
*	O
isym	pointer
=	O
bfd_sym_from_r_symndx	function
(	O
&	O
htab	struct
->	O
sym_cache	struct
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_UNDEF	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_ABS	O
)	O
tsec	pointer
=	O
bfd_abs_section_ptr	O
;	O
else	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_COMMON	O
)	O
tsec	pointer
=	O
bfd_com_section_ptr	O
;	O
else	O
if	O
(	O
isym	pointer
->	O
st_shndx	array
==	O
SHN_X86_64_LCOMMON	O
)	O
tsec	pointer
=	O
&	O
_bfd_elf_large_com_section	struct
;	O
else	O
tsec	pointer
=	O
bfd_section_from_elf_index	function
(	O
abfd	pointer
,	O
isym	pointer
->	O
st_shndx	array
)	O
;	O
}	O
else	O
{	O
bfd_boolean	int
local_ref	int
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
;	O
local_ref	int
=	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
link_info	pointer
,	O
h	pointer
)	O
;	O
if	O
(	O
(	O
relocx	int
||	O
opcode	int
==	O
0x8b	int
)	O
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
!	O
eh	pointer
->	O
linker_def	int
&&	O
local_ref	int
)	O
)	O
{	O
if	O
(	O
opcode	int
==	O
0xff	int
)	O
{	O
if	O
(	O
no_overflow	int
)	O
return	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
relocx	int
)	O
{	O
to_reloc_pc32	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
to_reloc_pc32	int
&&	O
is_pic	int
)	O
return	O
TRUE	int
;	O
goto	O
convert	O
;	O
}	O
else	O
if	O
(	O
h	pointer
->	O
start_stop	int
||	O
eh	pointer
->	O
linker_def	int
||	O
(	O
(	O
h	pointer
->	O
def_regular	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h	pointer
!=	O
htab	struct
->	O
elf	struct
.	O
hdynamic	pointer
&&	O
local_ref	int
)	O
)	O
{	O
if	O
(	O
h	pointer
->	O
start_stop	int
||	O
eh	pointer
->	O
linker_def	int
||	O
(	O
h	pointer
->	O
def_regular	int
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
||	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
==	O
bfd_und_section_ptr	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
no_overflow	int
)	O
return	O
TRUE	int
;	O
goto	O
convert	O
;	O
}	O
tsec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
}	O
else	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
elf_section_data	O
(	O
tsec	pointer
)	O
!=	O
NULL	O
&&	O
(	O
elf_section_flags	O
(	O
tsec	pointer
)	O
&	O
SHF_X86_64_LARGE	int
)	O
!=	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
no_overflow	int
)	O
return	O
TRUE	int
;	O
convert	O
:	O
if	O
(	O
opcode	int
==	O
0xff	int
)	O
{	O
unsigned	O
int	O
nop	int
;	O
unsigned	O
int	O
disp	int
;	O
bfd_vma	long
nop_offset	long
;	O
modrm	int
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
if	O
(	O
modrm	int
==	O
0x25	int
)	O
{	O
modrm	int
=	O
0xe9	int
;	O
nop	int
=	O
NOP_OPCODE	O
;	O
nop_offset	long
=	O
irel	pointer
->	O
r_offset	array
+	O
3	int
;	O
disp	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
irel	pointer
->	O
r_offset	array
)	O
;	O
irel	pointer
->	O
r_offset	array
-=	O
1	int
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
disp	int
,	O
contents	pointer
+	O
irel	pointer
->	O
r_offset	array
)	O
;	O
}	O
else	O
{	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
modrm	int
=	O
0xe8	int
;	O
if	O
(	O
eh	pointer
&&	O
eh	pointer
->	O
tls_get_addr	int
)	O
{	O
nop	int
=	O
0x67	int
;	O
nop_offset	long
=	O
irel	pointer
->	O
r_offset	array
-	O
2	int
;	O
}	O
else	O
{	O
nop	int
=	O
htab	struct
->	O
params	pointer
->	O
call_nop_byte	char
;	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
call_nop_as_suffix	int
)	O
{	O
nop_offset	long
=	O
irel	pointer
->	O
r_offset	array
+	O
3	int
;	O
disp	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
irel	pointer
->	O
r_offset	array
)	O
;	O
irel	pointer
->	O
r_offset	array
-=	O
1	int
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
disp	int
,	O
contents	pointer
+	O
irel	pointer
->	O
r_offset	array
)	O
;	O
}	O
else	O
nop_offset	long
=	O
irel	pointer
->	O
r_offset	array
-	O
2	int
;	O
}	O
}	O
bfd_put_8	O
(	O
abfd	pointer
,	O
nop	int
,	O
contents	pointer
+	O
nop_offset	long
)	O
;	O
bfd_put_8	O
(	O
abfd	pointer
,	O
modrm	int
,	O
contents	pointer
+	O
irel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
r_type	int
=	O
R_X86_64_PC32	int
;	O
}	O
else	O
{	O
unsigned	O
int	O
rex	int
;	O
unsigned	O
int	O
rex_mask	int
=	O
REX_R	int
;	O
if	O
(	O
r_type	int
==	O
R_X86_64_REX_GOTPCRELX	int
)	O
rex	int
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
else	O
rex	int
=	O
0	int
;	O
if	O
(	O
opcode	int
==	O
0x8b	int
)	O
{	O
if	O
(	O
to_reloc_pc32	int
)	O
{	O
opcode	int
=	O
0x8d	int
;	O
r_type	int
=	O
R_X86_64_PC32	int
;	O
}	O
else	O
{	O
opcode	int
=	O
0xc7	int
;	O
modrm	int
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
modrm	int
=	O
0xc0	int
|	O
(	O
modrm	int
&	O
0x38	int
)	O
>>	O
3	int
;	O
if	O
(	O
(	O
rex	int
&	O
REX_W	int
)	O
!=	O
0	int
&&	O
ABI_64_P	O
(	O
link_info	pointer
->	O
output_bfd	pointer
)	O
)	O
{	O
r_type	int
=	O
R_X86_64_32S	int
;	O
goto	O
rewrite_modrm_rex	O
;	O
}	O
else	O
{	O
r_type	int
=	O
R_X86_64_32	int
;	O
rex_mask	int
|=	O
REX_W	int
;	O
goto	O
rewrite_modrm_rex	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
to_reloc_pc32	int
)	O
return	O
TRUE	int
;	O
modrm	int
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
if	O
(	O
opcode	int
==	O
0x85	int
)	O
{	O
modrm	int
=	O
0xc0	int
|	O
(	O
modrm	int
&	O
0x38	int
)	O
>>	O
3	int
;	O
opcode	int
=	O
0xf7	int
;	O
}	O
else	O
{	O
modrm	int
=	O
0xc0	int
|	O
(	O
modrm	int
&	O
0x38	int
)	O
>>	O
3	int
|	O
(	O
opcode	int
&	O
0x3c	int
)	O
;	O
opcode	int
=	O
0x81	int
;	O
}	O
r_type	int
=	O
(	O
rex	int
&	O
REX_W	int
)	O
!=	O
0	int
?	O
R_X86_64_32S	int
:	O
R_X86_64_32	int
;	O
rewrite_modrm_rex	O
:	O
bfd_put_8	O
(	O
abfd	pointer
,	O
modrm	int
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
if	O
(	O
rex	int
)	O
{	O
rex	int
=	O
(	O
rex	int
&	O
~	O
rex_mask	int
)	O
|	O
(	O
rex	int
&	O
REX_R	int
)	O
>>	O
2	int
;	O
bfd_put_8	O
(	O
abfd	pointer
,	O
rex	int
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
}	O
irel	pointer
->	O
r_addend	array
=	O
0	int
;	O
}	O
bfd_put_8	O
(	O
abfd	pointer
,	O
opcode	int
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
}	O
*	O
r_type_p	pointer
=	O
r_type	int
;	O
irel	pointer
->	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
r_symndx	long
,	O
r_type	int
|	O
R_X86_64_converted_reloc_bit	O
)	O
;	O
*	O
converted	pointer
=	O
TRUE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_check_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
const	O
Elf_Internal_Rela	struct
*	O
relocs	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
;	O
const	O
Elf_Internal_Rela	struct
*	O
rel	pointer
;	O
const	O
Elf_Internal_Rela	struct
*	O
rel_end	pointer
;	O
asection	struct
*	O
sreloc	pointer
;	O
bfd_byte	char
*	O
contents	pointer
;	O
bfd_boolean	int
converted	pointer
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
return	O
TRUE	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
X86_64_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
{	O
sec	pointer
->	O
check_relocs_failed	O
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
BFD_ASSERT	O
(	O
is_x86_elf	O
(	O
abfd	pointer
,	O
htab	struct
)	O
)	O
;	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
!=	O
NULL	O
)	O
contents	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
;	O
else	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
&	O
contents	pointer
)	O
)	O
{	O
sec	pointer
->	O
check_relocs_failed	O
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
symtab_hdr	struct
=	O
&	O
elf_symtab_hdr	O
(	O
abfd	pointer
)	O
;	O
sym_hashes	pointer
=	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
converted	pointer
=	O
FALSE	int
;	O
sreloc	pointer
=	O
NULL	O
;	O
rel_end	pointer
=	O
relocs	pointer
+	O
sec	pointer
->	O
reloc_count	int
;	O
for	O
(	O
rel	pointer
=	O
relocs	pointer
;	O
rel	pointer
<	O
rel_end	pointer
;	O
rel	pointer
++	O
)	O
{	O
unsigned	O
int	O
r_type	int
;	O
unsigned	O
int	O
r_symndx	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
bfd_boolean	int
size_reloc	int
;	O
bfd_boolean	int
converted_reloc	int
;	O
r_symndx	long
=	O
htab	struct
->	O
r_sym	pointer
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
r_type	int
=	O
ELF32_R_TYPE	O
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
r_symndx	long
>=	O
NUM_SHDR_ENTRIES	O
(	O
symtab_hdr	struct
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: bad symbol index: %d"	pointer
)	O
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
r_symndx	long
<	O
symtab_hdr	struct
->	O
sh_info	array
)	O
{	O
isym	pointer
=	O
bfd_sym_from_r_symndx	function
(	O
&	O
htab	struct
->	O
sym_cache	struct
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
if	O
(	O
isym	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
==	O
STT_GNU_IFUNC	int
)	O
{	O
h	pointer
=	O
_bfd_elf_x86_get_local_sym_hash	function
(	O
htab	struct
,	O
abfd	pointer
,	O
rel	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
=	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
h	pointer
->	O
type	enum
=	O
STT_GNU_IFUNC	int
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
h	pointer
->	O
ref_regular	int
=	O
1	int
;	O
h	pointer
->	O
forced_local	int
=	O
1	int
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
}	O
else	O
h	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
isym	pointer
=	O
NULL	O
;	O
h	pointer
=	O
sym_hashes	pointer
[	O
r_symndx	long
-	O
symtab_hdr	struct
->	O
sh_info	array
]	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
}	O
if	O
(	O
!	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
switch	O
(	O
r_type	int
)	O
{	O
default	O
:	O
break	O
;	O
case	O
R_X86_64_DTPOFF64	int
:	O
case	O
R_X86_64_TPOFF64	int
:	O
case	O
R_X86_64_PC64	int
:	O
case	O
R_X86_64_GOTOFF64	int
:	O
case	O
R_X86_64_GOT64	int
:	O
case	O
R_X86_64_GOTPCREL64	int
:	O
case	O
R_X86_64_GOTPC64	int
:	O
case	O
R_X86_64_GOTPLT64	int
:	O
case	O
R_X86_64_PLTOFF64	int
:	O
{	O
if	O
(	O
h	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation %s against symbol `%s' isn't "	pointer
"supported in x32 mode"	pointer
)	O
,	O
abfd	pointer
,	O
x86_64_elf_howto_table	array
[	O
r_type	int
]	O
.	O
name	pointer
,	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
h	pointer
->	O
ref_regular	int
=	O
1	int
;	O
}	O
converted_reloc	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
r_type	int
==	O
R_X86_64_GOTPCREL	int
||	O
r_type	int
==	O
R_X86_64_GOTPCRELX	int
||	O
r_type	int
==	O
R_X86_64_REX_GOTPCRELX	int
)	O
&&	O
(	O
h	pointer
==	O
NULL	O
||	O
h	pointer
->	O
type	enum
!=	O
STT_GNU_IFUNC	int
)	O
)	O
{	O
Elf_Internal_Rela	struct
*	O
irel	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
rel	pointer
;	O
if	O
(	O
!	O
elf_x86_64_convert_load_reloc	function
(	O
abfd	pointer
,	O
contents	pointer
,	O
&	O
r_type	int
,	O
irel	pointer
,	O
h	pointer
,	O
&	O
converted_reloc	int
,	O
info	pointer
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
converted_reloc	int
)	O
converted	pointer
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
elf_x86_64_tls_transition	function
(	O
info	pointer
,	O
abfd	pointer
,	O
sec	pointer
,	O
contents	pointer
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
&	O
r_type	int
,	O
GOT_UNKNOWN	int
,	O
rel	pointer
,	O
rel_end	pointer
,	O
h	pointer
,	O
r_symndx	long
,	O
FALSE	int
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
h	pointer
==	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
)	O
htab	struct
->	O
got_referenced	int
=	O
TRUE	int
;	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
switch	O
(	O
r_type	int
)	O
{	O
case	O
R_X86_64_TLSLD	int
:	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
refcount	int
=	O
1	int
;	O
goto	O
create_got	O
;	O
case	O
R_X86_64_TPOFF32	int
:	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
return	O
elf_x86_64_need_pic	function
(	O
info	pointer
,	O
abfd	pointer
,	O
sec	pointer
,	O
h	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
&	O
x86_64_elf_howto_table	array
[	O
r_type	int
]	O
)	O
;	O
if	O
(	O
eh	pointer
!=	O
NULL	O
)	O
eh	pointer
->	O
zero_undefweak	int
&=	O
0x2	int
;	O
break	O
;	O
case	O
R_X86_64_GOTTPOFF	int
:	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
info	pointer
->	O
flags	int
|=	O
DF_STATIC_TLS	O
;	O
case	O
R_X86_64_GOT32	int
:	O
case	O
R_X86_64_GOTPCREL	int
:	O
case	O
R_X86_64_GOTPCRELX	int
:	O
case	O
R_X86_64_REX_GOTPCRELX	int
:	O
case	O
R_X86_64_TLSGD	int
:	O
case	O
R_X86_64_GOT64	int
:	O
case	O
R_X86_64_GOTPCREL64	int
:	O
case	O
R_X86_64_GOTPLT64	int
:	O
case	O
R_X86_64_GOTPC32_TLSDESC	int
:	O
case	O
R_X86_64_TLSDESC_CALL	int
:	O
{	O
int	O
tls_type	char
,	O
old_tls_type	int
;	O
switch	O
(	O
r_type	int
)	O
{	O
default	O
:	O
tls_type	char
=	O
GOT_NORMAL	int
;	O
break	O
;	O
case	O
R_X86_64_TLSGD	int
:	O
tls_type	char
=	O
GOT_TLS_GD	int
;	O
break	O
;	O
case	O
R_X86_64_GOTTPOFF	int
:	O
tls_type	char
=	O
GOT_TLS_IE	int
;	O
break	O
;	O
case	O
R_X86_64_GOTPC32_TLSDESC	int
:	O
case	O
R_X86_64_TLSDESC_CALL	int
:	O
tls_type	char
=	O
GOT_TLS_GDESC	int
;	O
break	O
;	O
}	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
h	pointer
->	O
got	union
.	O
refcount	int
=	O
1	int
;	O
old_tls_type	int
=	O
eh	pointer
->	O
tls_type	char
;	O
}	O
else	O
{	O
bfd_signed_vma	long
*	O
local_got_refcounts	pointer
;	O
local_got_refcounts	pointer
=	O
elf_local_got_refcounts	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
local_got_refcounts	pointer
==	O
NULL	O
)	O
{	O
bfd_size_type	long
size	long
;	O
size	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
size	long
*=	O
sizeof	O
(	O
bfd_signed_vma	long
)	O
+	O
sizeof	O
(	O
bfd_vma	long
)	O
+	O
sizeof	O
(	O
char	O
)	O
;	O
local_got_refcounts	pointer
=	O
(	O
(	O
bfd_signed_vma	long
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
size	long
)	O
)	O
;	O
if	O
(	O
local_got_refcounts	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
elf_local_got_refcounts	O
(	O
abfd	pointer
)	O
=	O
local_got_refcounts	pointer
;	O
elf_x86_local_tlsdesc_gotent	O
(	O
abfd	pointer
)	O
=	O
(	O
bfd_vma	long
*	O
)	O
(	O
local_got_refcounts	pointer
+	O
symtab_hdr	struct
->	O
sh_info	array
)	O
;	O
elf_x86_local_got_tls_type	O
(	O
abfd	pointer
)	O
=	O
(	O
char	O
*	O
)	O
(	O
local_got_refcounts	pointer
+	O
2	int
*	O
symtab_hdr	struct
->	O
sh_info	array
)	O
;	O
}	O
local_got_refcounts	pointer
[	O
r_symndx	long
]	O
=	O
1	int
;	O
old_tls_type	int
=	O
elf_x86_local_got_tls_type	O
(	O
abfd	pointer
)	O
[	O
r_symndx	long
]	O
;	O
}	O
if	O
(	O
old_tls_type	int
!=	O
tls_type	char
&&	O
old_tls_type	int
!=	O
GOT_UNKNOWN	int
&&	O
(	O
!	O
GOT_TLS_GD_ANY_P	O
(	O
old_tls_type	int
)	O
||	O
tls_type	char
!=	O
GOT_TLS_IE	int
)	O
)	O
{	O
if	O
(	O
old_tls_type	int
==	O
GOT_TLS_IE	int
&&	O
GOT_TLS_GD_ANY_P	O
(	O
tls_type	char
)	O
)	O
tls_type	char
=	O
old_tls_type	int
;	O
else	O
if	O
(	O
GOT_TLS_GD_ANY_P	O
(	O
old_tls_type	int
)	O
&&	O
GOT_TLS_GD_ANY_P	O
(	O
tls_type	char
)	O
)	O
tls_type	char
|=	O
old_tls_type	int
;	O
else	O
{	O
if	O
(	O
h	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: '%s' accessed both as normal and"	pointer
" thread local symbol"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
}	O
if	O
(	O
old_tls_type	int
!=	O
tls_type	char
)	O
{	O
if	O
(	O
eh	pointer
!=	O
NULL	O
)	O
eh	pointer
->	O
tls_type	char
=	O
tls_type	char
;	O
else	O
elf_x86_local_got_tls_type	O
(	O
abfd	pointer
)	O
[	O
r_symndx	long
]	O
=	O
tls_type	char
;	O
}	O
}	O
case	O
R_X86_64_GOTOFF64	int
:	O
case	O
R_X86_64_GOTPC32	int
:	O
case	O
R_X86_64_GOTPC64	int
:	O
create_got	O
:	O
if	O
(	O
eh	pointer
!=	O
NULL	O
)	O
eh	pointer
->	O
zero_undefweak	int
&=	O
0x2	int
;	O
break	O
;	O
case	O
R_X86_64_PLT32	int
:	O
case	O
R_X86_64_PLT32_BND	int
:	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
continue	O
;	O
eh	pointer
->	O
zero_undefweak	int
&=	O
0x2	int
;	O
h	pointer
->	O
needs_plt	int
=	O
1	int
;	O
h	pointer
->	O
plt	union
.	O
refcount	int
=	O
1	int
;	O
break	O
;	O
case	O
R_X86_64_PLTOFF64	int
:	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
h	pointer
->	O
needs_plt	int
=	O
1	int
;	O
h	pointer
->	O
plt	union
.	O
refcount	int
=	O
1	int
;	O
}	O
goto	O
create_got	O
;	O
case	O
R_X86_64_SIZE32	int
:	O
case	O
R_X86_64_SIZE64	int
:	O
size_reloc	int
=	O
TRUE	int
;	O
goto	O
do_size	O
;	O
case	O
R_X86_64_32	int
:	O
if	O
(	O
!	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
goto	O
pointer	O
;	O
case	O
R_X86_64_8	int
:	O
case	O
R_X86_64_16	int
:	O
case	O
R_X86_64_32S	int
:	O
if	O
(	O
!	O
htab	struct
->	O
params	pointer
->	O
no_reloc_overflow_check	int
&&	O
!	O
converted_reloc	int
&&	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
||	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
h	pointer
!=	O
NULL	O
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
def_dynamic	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
)	O
)	O
return	O
elf_x86_64_need_pic	function
(	O
info	pointer
,	O
abfd	pointer
,	O
sec	pointer
,	O
h	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
&	O
x86_64_elf_howto_table	array
[	O
r_type	int
]	O
)	O
;	O
case	O
R_X86_64_PC8	int
:	O
case	O
R_X86_64_PC16	int
:	O
case	O
R_X86_64_PC32	int
:	O
case	O
R_X86_64_PC32_BND	int
:	O
case	O
R_X86_64_PC64	int
:	O
case	O
R_X86_64_64	int
:	O
pointer	O
:	O
if	O
(	O
eh	pointer
!=	O
NULL	O
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
eh	pointer
->	O
zero_undefweak	int
|=	O
0x2	int
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
)	O
{	O
bfd_boolean	int
func_pointer_ref	int
=	O
FALSE	int
;	O
if	O
(	O
r_type	int
==	O
R_X86_64_PC32	int
)	O
{	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
{	O
h	pointer
->	O
pointer_equality_needed	int
=	O
1	int
;	O
if	O
(	O
bfd_link_pie	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
def_dynamic	int
)	O
{	O
h	pointer
->	O
needs_plt	int
=	O
1	int
;	O
h	pointer
->	O
plt	union
.	O
refcount	int
=	O
1	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
r_type	int
!=	O
R_X86_64_PC32_BND	int
&&	O
r_type	int
!=	O
R_X86_64_PC64	int
)	O
{	O
h	pointer
->	O
pointer_equality_needed	int
=	O
1	int
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
&&	O
(	O
r_type	int
==	O
R_X86_64_64	int
||	O
(	O
!	O
ABI_64_P	O
(	O
abfd	pointer
)	O
&&	O
(	O
r_type	int
==	O
R_X86_64_32	int
||	O
r_type	int
==	O
R_X86_64_32S	int
)	O
)	O
)	O
)	O
func_pointer_ref	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
func_pointer_ref	int
)	O
{	O
h	pointer
->	O
non_got_ref	int
=	O
1	int
;	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
||	O
(	O
sec	pointer
->	O
flags	int
&	O
(	O
SEC_CODE	int
|	O
SEC_READONLY	int
)	O
)	O
!=	O
0	int
)	O
h	pointer
->	O
plt	union
.	O
refcount	int
=	O
1	int
;	O
}	O
}	O
size_reloc	int
=	O
FALSE	int
;	O
do_size	O
:	O
if	O
(	O
NEED_DYNAMIC_RELOCATION_P	O
(	O
info	pointer
,	O
TRUE	int
,	O
h	pointer
,	O
sec	pointer
,	O
r_type	int
,	O
htab	struct
->	O
pointer_r_type	int
)	O
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
p	pointer
;	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
head	pointer
;	O
if	O
(	O
sreloc	pointer
==	O
NULL	O
)	O
{	O
sreloc	pointer
=	O
_bfd_elf_make_dynamic_reloc_section	function
(	O
sec	pointer
,	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
,	O
ABI_64_P	O
(	O
abfd	pointer
)	O
?	O
3	int
:	O
2	int
,	O
abfd	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
sreloc	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
head	pointer
=	O
&	O
eh	pointer
->	O
dyn_relocs	pointer
;	O
else	O
{	O
asection	struct
*	O
s	pointer
;	O
void	O
*	O
*	O
vpp	pointer
;	O
isym	pointer
=	O
bfd_sym_from_r_symndx	function
(	O
&	O
htab	struct
->	O
sym_cache	struct
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
if	O
(	O
isym	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
s	pointer
=	O
bfd_section_from_elf_index	function
(	O
abfd	pointer
,	O
isym	pointer
->	O
st_shndx	array
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
sec	pointer
;	O
vpp	pointer
=	O
&	O
(	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
local_dynrel	pointer
)	O
;	O
head	pointer
=	O
(	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
)	O
vpp	pointer
;	O
}	O
p	pointer
=	O
*	O
head	pointer
;	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
p	pointer
->	O
sec	pointer
!=	O
sec	pointer
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
*	O
p	pointer
;	O
p	pointer
=	O
(	O
(	O
struct	O
elf_dyn_relocs	struct
*	O
)	O
bfd_alloc	function
(	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
,	O
amt	long
)	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
p	pointer
->	O
next	pointer
=	O
*	O
head	pointer
;	O
*	O
head	pointer
=	O
p	pointer
;	O
p	pointer
->	O
sec	pointer
=	O
sec	pointer
;	O
p	pointer
->	O
count	int
=	O
0	int
;	O
p	pointer
->	O
pc_count	long
=	O
0	int
;	O
}	O
p	pointer
->	O
count	int
+=	O
1	int
;	O
if	O
(	O
X86_PCREL_TYPE_P	O
(	O
r_type	int
)	O
||	O
size_reloc	int
)	O
p	pointer
->	O
pc_count	long
+=	O
1	int
;	O
}	O
break	O
;	O
case	O
R_X86_64_GNU_VTINHERIT	int
:	O
if	O
(	O
!	O
bfd_elf_gc_record_vtinherit	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
h	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
)	O
goto	O
error_return	O
;	O
break	O
;	O
case	O
R_X86_64_GNU_VTENTRY	int
:	O
if	O
(	O
!	O
bfd_elf_gc_record_vtentry	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
h	pointer
,	O
rel	pointer
->	O
r_addend	array
)	O
)	O
goto	O
error_return	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
!=	O
contents	pointer
)	O
{	O
if	O
(	O
!	O
converted	pointer
&&	O
!	O
info	pointer
->	O
keep_memory	int
)	O
free	function
(	O
contents	pointer
)	O
;	O
else	O
{	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
=	O
contents	pointer
;	O
}	O
}	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
relocs	pointer
!=	O
relocs	pointer
&&	O
converted	pointer
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
relocs	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
relocs	pointer
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
!=	O
contents	pointer
)	O
free	function
(	O
contents	pointer
)	O
;	O
sec	pointer
->	O
check_relocs_failed	O
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_vma	long
elf_x86_64_tpoff	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd_vma	long
address	long
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
bfd_vma	long
static_tls_size	long
;	O
if	O
(	O
htab	struct
->	O
tls_sec	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
static_tls_size	long
=	O
BFD_ALIGN	O
(	O
htab	struct
->	O
tls_size	long
,	O
bed	pointer
->	O
static_tls_alignment	int
)	O
;	O
return	O
address	long
-	O
static_tls_size	long
-	O
htab	struct
->	O
tls_sec	pointer
->	O
vma	long
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_relocate_section	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
Elf_Internal_Rela	struct
*	O
relocs	pointer
,	O
Elf_Internal_Sym	struct
*	O
local_syms	pointer
,	O
asection	struct
*	O
*	O
local_sections	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
;	O
bfd_vma	long
*	O
local_got_offsets	pointer
;	O
bfd_vma	long
*	O
local_tlsdesc_gotents	pointer
;	O
Elf_Internal_Rela	struct
*	O
rel	pointer
;	O
Elf_Internal_Rela	struct
*	O
wrel	pointer
;	O
Elf_Internal_Rela	struct
*	O
relend	pointer
;	O
unsigned	O
int	O
plt_entry_size	int
;	O
if	O
(	O
input_section	pointer
->	O
check_relocs_failed	O
)	O
return	O
FALSE	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
X86_64_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
is_x86_elf	O
(	O
input_bfd	pointer
,	O
htab	struct
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
plt_entry_size	int
=	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
;	O
symtab_hdr	struct
=	O
&	O
elf_symtab_hdr	O
(	O
input_bfd	pointer
)	O
;	O
sym_hashes	pointer
=	O
elf_sym_hashes	O
(	O
input_bfd	pointer
)	O
;	O
local_got_offsets	pointer
=	O
elf_local_got_offsets	O
(	O
input_bfd	pointer
)	O
;	O
local_tlsdesc_gotents	pointer
=	O
elf_x86_local_tlsdesc_gotent	O
(	O
input_bfd	pointer
)	O
;	O
_bfd_x86_elf_set_tls_module_base	function
(	O
info	pointer
)	O
;	O
rel	pointer
=	O
wrel	pointer
=	O
relocs	pointer
;	O
relend	pointer
=	O
relocs	pointer
+	O
input_section	pointer
->	O
reloc_count	int
;	O
for	O
(	O
;	O
rel	pointer
<	O
relend	pointer
;	O
wrel	pointer
++	O
,	O
rel	pointer
++	O
)	O
{	O
unsigned	O
int	O
r_type	int
,	O
r_type_tls	int
;	O
reloc_howto_type	struct
*	O
howto	pointer
;	O
unsigned	O
long	O
r_symndx	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
bfd_vma	long
off	long
,	O
offplt	long
,	O
plt_offset	long
;	O
bfd_vma	long
relocation	pointer
;	O
bfd_boolean	int
unresolved_reloc	int
;	O
bfd_reloc_status_type	enum
r	enum
;	O
int	O
tls_type	char
;	O
asection	struct
*	O
base_got	pointer
,	O
*	O
resolved_plt	pointer
;	O
bfd_vma	long
st_size	long
;	O
bfd_boolean	int
resolved_to_zero	int
;	O
bfd_boolean	int
relative_reloc	int
;	O
bfd_boolean	int
converted_reloc	int
;	O
bfd_boolean	int
need_copy_reloc_in_pie	int
;	O
bfd_boolean	int
no_copyreloc_p	int
;	O
r_type	int
=	O
ELF32_R_TYPE	O
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
r_type	int
==	O
(	O
int	O
)	O
R_X86_64_GNU_VTINHERIT	int
||	O
r_type	int
==	O
(	O
int	O
)	O
R_X86_64_GNU_VTENTRY	int
)	O
{	O
if	O
(	O
wrel	pointer
!=	O
rel	pointer
)	O
*	O
wrel	pointer
=	O
*	O
rel	pointer
;	O
continue	O
;	O
}	O
r_symndx	long
=	O
htab	struct
->	O
r_sym	pointer
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
converted_reloc	int
=	O
(	O
r_type	int
&	O
R_X86_64_converted_reloc_bit	O
)	O
!=	O
0	int
;	O
if	O
(	O
converted_reloc	int
)	O
{	O
r_type	int
&=	O
~	O
R_X86_64_converted_reloc_bit	O
;	O
rel	pointer
->	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
r_symndx	long
,	O
r_type	int
)	O
;	O
}	O
howto	pointer
=	O
elf_x86_64_rtype_to_howto	function
(	O
input_bfd	pointer
,	O
r_type	int
)	O
;	O
if	O
(	O
howto	pointer
==	O
NULL	O
)	O
return	O
_bfd_unrecognized_reloc	function
(	O
input_bfd	pointer
,	O
input_section	pointer
,	O
r_type	int
)	O
;	O
h	pointer
=	O
NULL	O
;	O
sym	pointer
=	O
NULL	O
;	O
sec	pointer
=	O
NULL	O
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
if	O
(	O
r_symndx	long
<	O
symtab_hdr	struct
->	O
sh_info	array
)	O
{	O
sym	pointer
=	O
local_syms	pointer
+	O
r_symndx	long
;	O
sec	pointer
=	O
local_sections	pointer
[	O
r_symndx	long
]	O
;	O
relocation	pointer
=	O
_bfd_elf_rela_local_sym	function
(	O
output_bfd	pointer
,	O
sym	pointer
,	O
&	O
sec	pointer
,	O
rel	pointer
)	O
;	O
st_size	long
=	O
sym	pointer
->	O
st_size	long
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STT_GNU_IFUNC	int
)	O
{	O
h	pointer
=	O
_bfd_elf_x86_get_local_sym_hash	function
(	O
htab	struct
,	O
input_bfd	pointer
,	O
rel	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
sym	pointer
->	O
st_value	array
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
sec	pointer
;	O
}	O
}	O
else	O
{	O
bfd_boolean	int
warned	int
ATTRIBUTE_UNUSED	O
;	O
bfd_boolean	int
ignored	int
ATTRIBUTE_UNUSED	O
;	O
RELOC_FOR_GLOBAL_SYMBOL	O
(	O
info	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
rel	pointer
,	O
r_symndx	long
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
h	pointer
,	O
sec	pointer
,	O
relocation	pointer
,	O
unresolved_reloc	int
,	O
warned	int
,	O
ignored	int
)	O
;	O
st_size	long
=	O
h	pointer
->	O
size	long
;	O
}	O
if	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
discarded_section	function
(	O
sec	pointer
)	O
)	O
{	O
_bfd_clear_contents	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
;	O
wrel	pointer
->	O
r_offset	array
=	O
rel	pointer
->	O
r_offset	array
;	O
wrel	pointer
->	O
r_info	array
=	O
0	int
;	O
wrel	pointer
->	O
r_addend	array
=	O
0	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
)	O
wrel	pointer
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
if	O
(	O
wrel	pointer
!=	O
rel	pointer
)	O
*	O
wrel	pointer
=	O
*	O
rel	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
rel	pointer
->	O
r_addend	array
==	O
0	int
&&	O
!	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
)	O
{	O
if	O
(	O
r_type	int
==	O
R_X86_64_64	int
)	O
{	O
r_type	int
=	O
R_X86_64_32	int
;	O
memset	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
+	O
4	int
,	O
0	int
,	O
4	int
)	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_X86_64_SIZE64	int
)	O
{	O
r_type	int
=	O
R_X86_64_SIZE32	int
;	O
memset	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
+	O
4	int
,	O
0	int
,	O
4	int
)	O
;	O
}	O
}	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
h	pointer
->	O
def_regular	int
)	O
{	O
bfd_vma	long
plt_index	long
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
elf_section_type	O
(	O
input_section	pointer
)	O
==	O
SHT_NOTE	int
)	O
goto	O
skip_ifunc	O
;	O
if	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
continue	O
;	O
abort	function
(	O
)	O
;	O
}	O
switch	O
(	O
r_type	int
)	O
{	O
default	O
:	O
break	O
;	O
case	O
R_X86_64_GOTPCREL	int
:	O
case	O
R_X86_64_GOTPCRELX	int
:	O
case	O
R_X86_64_REX_GOTPCRELX	int
:	O
case	O
R_X86_64_GOTPCREL64	int
:	O
base_got	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
off	long
=	O
h	pointer
->	O
got	union
.	O
offset	long
;	O
if	O
(	O
base_got	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
off	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
{	O
plt_index	long
=	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
plt_entry_size	int
-	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
;	O
off	long
=	O
(	O
plt_index	long
+	O
3	int
)	O
*	O
GOT_ENTRY_SIZE	int
;	O
base_got	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
}	O
else	O
{	O
plt_index	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
plt_entry_size	int
;	O
off	long
=	O
plt_index	long
*	O
GOT_ENTRY_SIZE	int
;	O
base_got	pointer
=	O
htab	struct
->	O
elf	struct
.	O
igotplt	pointer
;	O
}	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
||	O
h	pointer
->	O
forced_local	int
||	O
info	pointer
->	O
symbolic	int
)	O
{	O
if	O
(	O
(	O
off	long
&	O
1	int
)	O
!=	O
0	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
relocation	pointer
,	O
base_got	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
h	pointer
->	O
got	union
.	O
offset	long
|=	O
1	int
;	O
}	O
}	O
}	O
relocation	pointer
=	O
(	O
base_got	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
base_got	pointer
->	O
output_offset	long
+	O
off	long
)	O
;	O
goto	O
do_relocation	O
;	O
}	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
r_type	int
==	O
htab	struct
->	O
pointer_r_type	int
&&	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
goto	O
do_ifunc_pointer	O
;	O
goto	O
bad_ifunc_reloc	O
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
)	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
relocation	pointer
=	O
(	O
resolved_plt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
resolved_plt	pointer
->	O
output_offset	long
+	O
plt_offset	long
)	O
;	O
switch	O
(	O
r_type	int
)	O
{	O
default	O
:	O
bad_ifunc_reloc	O
:	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
,	O
sym	pointer
,	O
NULL	O
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation %s against STT_GNU_IFUNC "	pointer
"symbol `%s' isn't supported"	pointer
)	O
,	O
input_bfd	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
case	O
R_X86_64_32S	int
:	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
goto	O
do_relocation	O
;	O
case	O
R_X86_64_32	int
:	O
if	O
(	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
)	O
goto	O
do_relocation	O
;	O
case	O
R_X86_64_64	int
:	O
do_ifunc_pointer	O
:	O
if	O
(	O
rel	pointer
->	O
r_addend	array
!=	O
0	int
)	O
{	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
,	O
sym	pointer
,	O
NULL	O
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation %s against STT_GNU_IFUNC "	pointer
"symbol `%s' has non-zero addend: %"	pointer
PRId64	O
)	O
,	O
input_bfd	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
name	pointer
,	O
(	O
int64_t	long
)	O
rel	pointer
->	O
r_addend	array
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
non_got_ref	int
)	O
||	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
asection	struct
*	O
sreloc	pointer
;	O
outrel	struct
.	O
r_offset	array
=	O
_bfd_elf_section_offset	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
;	O
if	O
(	O
outrel	struct
.	O
r_offset	array
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
outrel	struct
.	O
r_offset	array
==	O
(	O
bfd_vma	long
)	O
-	O
2	int
)	O
abort	function
(	O
)	O
;	O
outrel	struct
.	O
r_offset	array
+=	O
(	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
POINTER_LOCAL_IFUNC_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
(	O
_	O
(	O
"Local IFUNC function `%s' in %pB\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
0	int
,	O
R_X86_64_IRELATIVE	int
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
}	O
else	O
{	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
h	pointer
->	O
dynindx	long
,	O
r_type	int
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
0	int
;	O
}	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
irelifunc	pointer
;	O
else	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
else	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
irelplt	pointer
;	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
continue	O
;	O
}	O
case	O
R_X86_64_PC32	int
:	O
case	O
R_X86_64_PC32_BND	int
:	O
case	O
R_X86_64_PC64	int
:	O
case	O
R_X86_64_PLT32	int
:	O
case	O
R_X86_64_PLT32_BND	int
:	O
goto	O
do_relocation	O
;	O
}	O
}	O
skip_ifunc	O
:	O
resolved_to_zero	int
=	O
(	O
eh	pointer
!=	O
NULL	O
&&	O
UNDEFINED_WEAK_RESOLVED_TO_ZERO	O
(	O
info	pointer
,	O
eh	pointer
)	O
)	O
;	O
switch	O
(	O
r_type	int
)	O
{	O
case	O
R_X86_64_GOT32	int
:	O
case	O
R_X86_64_GOT64	int
:	O
case	O
R_X86_64_GOTPCREL	int
:	O
case	O
R_X86_64_GOTPCRELX	int
:	O
case	O
R_X86_64_REX_GOTPCRELX	int
:	O
case	O
R_X86_64_GOTPCREL64	int
:	O
case	O
R_X86_64_GOTPLT64	int
:	O
base_got	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
relative_reloc	int
=	O
FALSE	int
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
off	long
=	O
h	pointer
->	O
got	union
.	O
offset	long
;	O
if	O
(	O
h	pointer
->	O
needs_plt	int
&&	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
off	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
bfd_vma	long
plt_index	long
=	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
plt_entry_size	int
-	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
;	O
off	long
=	O
(	O
plt_index	long
+	O
3	int
)	O
*	O
GOT_ENTRY_SIZE	int
;	O
base_got	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
}	O
if	O
(	O
RESOLVED_LOCALLY_P	O
(	O
info	pointer
,	O
h	pointer
,	O
htab	struct
)	O
)	O
{	O
if	O
(	O
(	O
off	long
&	O
1	int
)	O
!=	O
0	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
relocation	pointer
,	O
base_got	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
h	pointer
->	O
got	union
.	O
offset	long
|=	O
1	int
;	O
if	O
(	O
GENERATE_RELATIVE_RELOC_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
eh	pointer
->	O
no_finish_dynamic_symbol	int
=	O
1	int
;	O
relative_reloc	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
else	O
unresolved_reloc	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
local_got_offsets	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
off	long
=	O
local_got_offsets	pointer
[	O
r_symndx	long
]	O
;	O
if	O
(	O
(	O
off	long
&	O
1	int
)	O
!=	O
0	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
relocation	pointer
,	O
base_got	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
local_got_offsets	pointer
[	O
r_symndx	long
]	O
|=	O
1	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
relative_reloc	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
relative_reloc	int
)	O
{	O
asection	struct
*	O
s	pointer
;	O
Elf_Internal_Rela	struct
outrel	struct
;	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
base_got	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
base_got	pointer
->	O
output_offset	long
+	O
off	long
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
0	int
,	O
R_X86_64_RELATIVE	int
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
relocation	pointer
;	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
s	pointer
,	O
&	O
outrel	struct
)	O
;	O
}	O
if	O
(	O
off	long
>=	O
(	O
bfd_vma	long
)	O
-	O
2	int
)	O
abort	function
(	O
)	O
;	O
relocation	pointer
=	O
base_got	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
base_got	pointer
->	O
output_offset	long
+	O
off	long
;	O
if	O
(	O
r_type	int
!=	O
R_X86_64_GOTPCREL	int
&&	O
r_type	int
!=	O
R_X86_64_GOTPCRELX	int
&&	O
r_type	int
!=	O
R_X86_64_REX_GOTPCRELX	int
&&	O
r_type	int
!=	O
R_X86_64_GOTPCREL64	int
)	O
relocation	pointer
-=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
;	O
break	O
;	O
case	O
R_X86_64_GOTOFF64	int
:	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
h	pointer
)	O
{	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
)	O
{	O
const	O
char	O
*	O
v	pointer
;	O
switch	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
)	O
{	O
case	O
STV_HIDDEN	int
:	O
v	pointer
=	O
_	O
(	O
"hidden symbol"	pointer
)	O
;	O
break	O
;	O
case	O
STV_INTERNAL	int
:	O
v	pointer
=	O
_	O
(	O
"internal symbol"	pointer
)	O
;	O
break	O
;	O
case	O
STV_PROTECTED	int
:	O
v	pointer
=	O
_	O
(	O
"protected symbol"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
v	pointer
=	O
_	O
(	O
"symbol"	pointer
)	O
;	O
break	O
;	O
}	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation R_X86_64_GOTOFF64 against undefined %s"	pointer
" `%s' can not be used when making a shared object"	pointer
)	O
,	O
input_bfd	pointer
,	O
v	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
!	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
info	pointer
,	O
h	pointer
)	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
||	O
h	pointer
->	O
type	enum
==	O
STT_OBJECT	int
)	O
&&	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_PROTECTED	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation R_X86_64_GOTOFF64 against protected %s"	pointer
" `%s' can not be used when making a shared object"	pointer
)	O
,	O
input_bfd	pointer
,	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
?	O
"function"	pointer
:	O
"data"	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
relocation	pointer
-=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
;	O
break	O
;	O
case	O
R_X86_64_GOTPC32	int
:	O
case	O
R_X86_64_GOTPC64	int
:	O
relocation	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
R_X86_64_PLTOFF64	int
:	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
&&	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_got	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
;	O
}	O
else	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
)	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
relocation	pointer
=	O
(	O
resolved_plt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
resolved_plt	pointer
->	O
output_offset	long
+	O
plt_offset	long
)	O
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
}	O
relocation	pointer
-=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
;	O
break	O
;	O
case	O
R_X86_64_PLT32	int
:	O
case	O
R_X86_64_PLT32_BND	int
:	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
||	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
==	O
NULL	O
)	O
{	O
break	O
;	O
}	O
use_plt	O
:	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
)	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_got	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
;	O
}	O
relocation	pointer
=	O
(	O
resolved_plt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
resolved_plt	pointer
->	O
output_offset	long
+	O
plt_offset	long
)	O
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
R_X86_64_SIZE32	int
:	O
case	O
R_X86_64_SIZE64	int
:	O
relocation	pointer
=	O
st_size	long
;	O
goto	O
direct	O
;	O
case	O
R_X86_64_PC8	int
:	O
case	O
R_X86_64_PC16	int
:	O
case	O
R_X86_64_PC32	int
:	O
case	O
R_X86_64_PC32_BND	int
:	O
no_copyreloc_p	int
=	O
(	O
info	pointer
->	O
nocopyreloc	int
||	O
(	O
h	pointer
!=	O
NULL	O
&&	O
!	O
h	pointer
->	O
root	struct
.	O
linker_def	int
&&	O
!	O
h	pointer
->	O
root	struct
.	O
ldscript_def	int
&&	O
eh	pointer
->	O
def_protected	int
&&	O
elf_has_no_copy_on_protected	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
)	O
)	O
;	O
if	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
!=	O
0	int
&&	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
!=	O
0	int
&&	O
h	pointer
!=	O
NULL	O
&&	O
(	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
(	O
eh	pointer
==	O
NULL	O
||	O
!	O
UNDEFINED_WEAK_RESOLVED_TO_ZERO	O
(	O
info	pointer
,	O
eh	pointer
)	O
)	O
)	O
||	O
(	O
bfd_link_pie	O
(	O
info	pointer
)	O
&&	O
!	O
SYMBOL_DEFINED_NON_SHARED_P	O
(	O
h	pointer
)	O
&&	O
h	pointer
->	O
def_dynamic	int
)	O
||	O
(	O
no_copyreloc_p	int
&&	O
h	pointer
->	O
def_dynamic	int
&&	O
!	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
)	O
)	O
)	O
||	O
bfd_link_dll	O
(	O
info	pointer
)	O
)	O
)	O
{	O
bfd_boolean	int
fail	int
=	O
FALSE	int
;	O
if	O
(	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
fail	int
=	O
!	O
SYMBOL_DEFINED_NON_SHARED_P	O
(	O
h	pointer
)	O
;	O
}	O
else	O
if	O
(	O
bfd_link_pie	O
(	O
info	pointer
)	O
)	O
{	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
fail	int
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
no_copyreloc_p	int
||	O
bfd_link_dll	O
(	O
info	pointer
)	O
)	O
{	O
fail	int
=	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_DEFAULT	int
||	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_PROTECTED	int
)	O
;	O
}	O
if	O
(	O
fail	int
)	O
return	O
elf_x86_64_need_pic	function
(	O
info	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
h	pointer
,	O
NULL	O
,	O
NULL	O
,	O
howto	pointer
)	O
;	O
}	O
else	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
&&	O
bfd_link_pie	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
def_dynamic	int
)	O
goto	O
use_plt	O
;	O
case	O
R_X86_64_8	int
:	O
case	O
R_X86_64_16	int
:	O
case	O
R_X86_64_32	int
:	O
case	O
R_X86_64_PC64	int
:	O
case	O
R_X86_64_64	int
:	O
direct	O
:	O
if	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
break	O
;	O
need_copy_reloc_in_pie	int
=	O
(	O
bfd_link_pie	O
(	O
info	pointer
)	O
&&	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
needs_copy	int
||	O
eh	pointer
->	O
needs_copy	int
||	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
)	O
)	O
&&	O
(	O
X86_PCREL_TYPE_P	O
(	O
r_type	int
)	O
||	O
X86_SIZE_TYPE_P	O
(	O
r_type	int
)	O
)	O
)	O
;	O
if	O
(	O
GENERATE_DYNAMIC_RELOCATION_P	O
(	O
info	pointer
,	O
eh	pointer
,	O
r_type	int
,	O
need_copy_reloc_in_pie	int
,	O
resolved_to_zero	int
,	O
FALSE	int
)	O
)	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
bfd_boolean	int
skip	int
,	O
relocate	int
;	O
asection	struct
*	O
sreloc	pointer
;	O
skip	int
=	O
FALSE	int
;	O
relocate	int
=	O
FALSE	int
;	O
outrel	struct
.	O
r_offset	array
=	O
_bfd_elf_section_offset	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
;	O
if	O
(	O
outrel	struct
.	O
r_offset	array
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
skip	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
outrel	struct
.	O
r_offset	array
==	O
(	O
bfd_vma	long
)	O
-	O
2	int
)	O
skip	int
=	O
TRUE	int
,	O
relocate	int
=	O
TRUE	int
;	O
outrel	struct
.	O
r_offset	array
+=	O
(	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
skip	int
)	O
memset	function
(	O
&	O
outrel	struct
,	O
0	int
,	O
sizeof	O
outrel	struct
)	O
;	O
else	O
if	O
(	O
COPY_INPUT_RELOC_P	O
(	O
info	pointer
,	O
h	pointer
,	O
r_type	int
)	O
)	O
{	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
h	pointer
->	O
dynindx	long
,	O
r_type	int
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
rel	pointer
->	O
r_addend	array
;	O
}	O
else	O
{	O
if	O
(	O
r_type	int
==	O
htab	struct
->	O
pointer_r_type	int
||	O
(	O
r_type	int
==	O
R_X86_64_32	int
&&	O
htab	struct
->	O
params	pointer
->	O
no_reloc_overflow_check	int
)	O
)	O
{	O
relocate	int
=	O
TRUE	int
;	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
0	int
,	O
R_X86_64_RELATIVE	int
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
relocation	pointer
+	O
rel	pointer
->	O
r_addend	array
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_X86_64_64	int
&&	O
!	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
)	O
{	O
relocate	int
=	O
TRUE	int
;	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
0	int
,	O
R_X86_64_RELATIVE64	int
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
relocation	pointer
+	O
rel	pointer
->	O
r_addend	array
;	O
if	O
(	O
(	O
outrel	struct
.	O
r_addend	array
&	O
0x80000000	int
)	O
!=	O
(	O
rel	pointer
->	O
r_addend	array
&	O
0x80000000	int
)	O
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
int	O
addend	long
=	O
rel	pointer
->	O
r_addend	array
;	O
if	O
(	O
h	pointer
&&	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
,	O
sym	pointer
,	O
NULL	O
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: addend %s%#x in relocation %s against "	pointer
"symbol `%s' at %#"	pointer
PRIx64	O
" in section `%pA' is out of range"	pointer
)	O
,	O
input_bfd	pointer
,	O
addend	long
<	O
0	int
?	O
"-"	pointer
:	O
""	pointer
,	O
addend	long
,	O
howto	pointer
->	O
name	pointer
,	O
name	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_offset	array
,	O
input_section	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
long	O
sindx	long
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
sec	pointer
)	O
)	O
sindx	long
=	O
0	int
;	O
else	O
if	O
(	O
sec	pointer
==	O
NULL	O
||	O
sec	pointer
->	O
owner	pointer
==	O
NULL	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
asection	struct
*	O
osec	pointer
;	O
osec	pointer
=	O
sec	pointer
->	O
output_section	pointer
;	O
sindx	long
=	O
elf_section_data	O
(	O
osec	pointer
)	O
->	O
dynindx	long
;	O
if	O
(	O
sindx	long
==	O
0	int
)	O
{	O
asection	struct
*	O
oi	pointer
=	O
htab	struct
->	O
elf	struct
.	O
text_index_section	pointer
;	O
sindx	long
=	O
elf_section_data	O
(	O
oi	pointer
)	O
->	O
dynindx	long
;	O
}	O
BFD_ASSERT	O
(	O
sindx	long
!=	O
0	int
)	O
;	O
}	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
sindx	long
,	O
r_type	int
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
relocation	pointer
+	O
rel	pointer
->	O
r_addend	array
;	O
}	O
}	O
sreloc	pointer
=	O
elf_section_data	O
(	O
input_section	pointer
)	O
->	O
sreloc	pointer
;	O
if	O
(	O
sreloc	pointer
==	O
NULL	O
||	O
sreloc	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
r	enum
=	O
bfd_reloc_notsupported	int
;	O
goto	O
check_relocation_error	O
;	O
}	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
if	O
(	O
!	O
relocate	int
)	O
continue	O
;	O
}	O
break	O
;	O
case	O
R_X86_64_TLSGD	int
:	O
case	O
R_X86_64_GOTPC32_TLSDESC	int
:	O
case	O
R_X86_64_TLSDESC_CALL	int
:	O
case	O
R_X86_64_GOTTPOFF	int
:	O
tls_type	char
=	O
GOT_UNKNOWN	int
;	O
if	O
(	O
h	pointer
==	O
NULL	O
&&	O
local_got_offsets	pointer
)	O
tls_type	char
=	O
elf_x86_local_got_tls_type	O
(	O
input_bfd	pointer
)	O
[	O
r_symndx	long
]	O
;	O
else	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
tls_type	char
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
;	O
r_type_tls	int
=	O
r_type	int
;	O
if	O
(	O
!	O
elf_x86_64_tls_transition	function
(	O
info	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
&	O
r_type_tls	int
,	O
tls_type	char
,	O
rel	pointer
,	O
relend	pointer
,	O
h	pointer
,	O
r_symndx	long
,	O
TRUE	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
r_type_tls	int
==	O
R_X86_64_TPOFF32	int
)	O
{	O
bfd_vma	long
roff	long
=	O
rel	pointer
->	O
r_offset	array
;	O
BFD_ASSERT	O
(	O
!	O
unresolved_reloc	int
)	O
;	O
if	O
(	O
r_type	int
==	O
R_X86_64_TLSGD	int
)	O
{	O
int	O
largepic	int
=	O
0	int
;	O
if	O
(	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
)	O
{	O
if	O
(	O
contents	pointer
[	O
roff	long
+	O
5	int
]	O
==	O
0xb8	int
)	O
{	O
if	O
(	O
roff	long
<	O
3	int
||	O
(	O
roff	long
-	O
3	int
+	O
22	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
{	O
corrupt_input	O
:	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: corrupt input: %pB\n"	pointer
)	O
,	O
input_bfd	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
memcpy	function
(	O
contents	pointer
+	O
roff	long
-	O
3	int
,	O
"\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80"	pointer
"\0\0\0\0\x66\x0f\x1f\x44\0"	pointer
,	O
22	int
)	O
;	O
largepic	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
roff	long
<	O
4	int
||	O
(	O
roff	long
-	O
4	int
+	O
16	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
roff	long
-	O
4	int
,	O
"\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0"	pointer
,	O
16	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
roff	long
<	O
3	int
||	O
(	O
roff	long
-	O
3	int
+	O
15	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
roff	long
-	O
3	int
,	O
"\x64\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0"	pointer
,	O
15	int
)	O
;	O
}	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
elf_x86_64_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
,	O
contents	pointer
+	O
roff	long
+	O
8	int
+	O
largepic	int
)	O
;	O
rel	pointer
++	O
;	O
wrel	pointer
++	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_X86_64_GOTPC32_TLSDESC	int
)	O
{	O
unsigned	O
int	O
val	array
,	O
type	enum
;	O
if	O
(	O
roff	long
<	O
3	int
)	O
goto	O
corrupt_input	O
;	O
type	enum
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
val	array
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x48	int
|	O
(	O
(	O
type	enum
>>	O
2	int
)	O
&	O
1	int
)	O
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc7	int
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc0	int
|	O
(	O
(	O
val	array
>>	O
3	int
)	O
&	O
7	int
)	O
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
elf_x86_64_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
,	O
contents	pointer
+	O
roff	long
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_X86_64_TLSDESC_CALL	int
)	O
{	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x66	int
,	O
contents	pointer
+	O
roff	long
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x90	int
,	O
contents	pointer
+	O
roff	long
+	O
1	int
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_X86_64_GOTTPOFF	int
)	O
{	O
unsigned	O
int	O
val	array
,	O
type	enum
,	O
reg	int
;	O
if	O
(	O
roff	long
>=	O
3	int
)	O
val	array
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
else	O
{	O
if	O
(	O
roff	long
<	O
2	int
)	O
goto	O
corrupt_input	O
;	O
val	array
=	O
0	int
;	O
}	O
type	enum
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
reg	int
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
reg	int
>>=	O
3	int
;	O
if	O
(	O
type	enum
==	O
0x8b	int
)	O
{	O
if	O
(	O
val	array
==	O
0x4c	int
)	O
{	O
if	O
(	O
roff	long
<	O
3	int
)	O
goto	O
corrupt_input	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x49	int
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
&&	O
val	array
==	O
0x44	int
)	O
{	O
if	O
(	O
roff	long
<	O
3	int
)	O
goto	O
corrupt_input	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x41	int
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
}	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc7	int
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc0	int
|	O
reg	int
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
reg	int
==	O
4	int
)	O
{	O
if	O
(	O
val	array
==	O
0x4c	int
)	O
{	O
if	O
(	O
roff	long
<	O
3	int
)	O
goto	O
corrupt_input	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x49	int
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
&&	O
val	array
==	O
0x44	int
)	O
{	O
if	O
(	O
roff	long
<	O
3	int
)	O
goto	O
corrupt_input	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x41	int
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
}	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x81	int
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc0	int
|	O
reg	int
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
val	array
==	O
0x4c	int
)	O
{	O
if	O
(	O
roff	long
<	O
3	int
)	O
goto	O
corrupt_input	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x4d	int
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
&&	O
val	array
==	O
0x44	int
)	O
{	O
if	O
(	O
roff	long
<	O
3	int
)	O
goto	O
corrupt_input	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x45	int
,	O
contents	pointer
+	O
roff	long
-	O
3	int
)	O
;	O
}	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x8d	int
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x80	int
|	O
reg	int
|	O
(	O
reg	int
<<	O
3	int
)	O
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
}	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
elf_x86_64_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
,	O
contents	pointer
+	O
roff	long
)	O
;	O
continue	O
;	O
}	O
else	O
BFD_ASSERT	O
(	O
FALSE	int
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
off	long
=	O
h	pointer
->	O
got	union
.	O
offset	long
;	O
offplt	long
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tlsdesc_got	long
;	O
}	O
else	O
{	O
if	O
(	O
local_got_offsets	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
off	long
=	O
local_got_offsets	pointer
[	O
r_symndx	long
]	O
;	O
offplt	long
=	O
local_tlsdesc_gotents	pointer
[	O
r_symndx	long
]	O
;	O
}	O
if	O
(	O
(	O
off	long
&	O
1	int
)	O
!=	O
0	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
int	O
dr_type	int
,	O
indx	long
;	O
asection	struct
*	O
sreloc	pointer
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
indx	long
=	O
h	pointer
&&	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
?	O
h	pointer
->	O
dynindx	long
:	O
0	int
;	O
if	O
(	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
)	O
{	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
indx	long
,	O
R_X86_64_TLSDESC	int
)	O
;	O
BFD_ASSERT	O
(	O
htab	struct
->	O
sgotplt_jump_table_size	long
+	O
offplt	long
+	O
2	int
*	O
GOT_ENTRY_SIZE	int
<=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
)	O
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
offplt	long
+	O
htab	struct
->	O
sgotplt_jump_table_size	long
)	O
;	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
;	O
if	O
(	O
indx	long
==	O
0	int
)	O
outrel	struct
.	O
r_addend	array
=	O
relocation	pointer
-	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
;	O
else	O
outrel	struct
.	O
r_addend	array
=	O
0	int
;	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
}	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
)	O
;	O
if	O
(	O
GOT_TLS_GD_P	O
(	O
tls_type	char
)	O
)	O
dr_type	int
=	O
R_X86_64_DTPMOD64	int
;	O
else	O
if	O
(	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
)	O
goto	O
dr_done	O
;	O
else	O
dr_type	int
=	O
R_X86_64_TPOFF64	int
;	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
0	int
;	O
if	O
(	O
(	O
dr_type	int
==	O
R_X86_64_TPOFF64	int
||	O
dr_type	int
==	O
R_X86_64_TLSDESC	int
)	O
&&	O
indx	long
==	O
0	int
)	O
outrel	struct
.	O
r_addend	array
=	O
relocation	pointer
-	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
indx	long
,	O
dr_type	int
)	O
;	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
if	O
(	O
GOT_TLS_GD_P	O
(	O
tls_type	char
)	O
)	O
{	O
if	O
(	O
indx	long
==	O
0	int
)	O
{	O
BFD_ASSERT	O
(	O
!	O
unresolved_reloc	int
)	O
;	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
relocation	pointer
-	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
+	O
GOT_ENTRY_SIZE	int
)	O
;	O
}	O
else	O
{	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
+	O
GOT_ENTRY_SIZE	int
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
indx	long
,	O
R_X86_64_DTPOFF64	int
)	O
;	O
outrel	struct
.	O
r_offset	array
+=	O
GOT_ENTRY_SIZE	int
;	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
}	O
}	O
dr_done	O
:	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
h	pointer
->	O
got	union
.	O
offset	long
|=	O
1	int
;	O
else	O
local_got_offsets	pointer
[	O
r_symndx	long
]	O
|=	O
1	int
;	O
}	O
if	O
(	O
off	long
>=	O
(	O
bfd_vma	long
)	O
-	O
2	int
&&	O
!	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
r_type_tls	int
==	O
r_type	int
)	O
{	O
if	O
(	O
r_type	int
==	O
R_X86_64_GOTPC32_TLSDESC	int
||	O
r_type	int
==	O
R_X86_64_TLSDESC_CALL	int
)	O
relocation	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
offplt	long
+	O
htab	struct
->	O
sgotplt_jump_table_size	long
;	O
else	O
relocation	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
bfd_vma	long
roff	long
=	O
rel	pointer
->	O
r_offset	array
;	O
if	O
(	O
r_type	int
==	O
R_X86_64_TLSGD	int
)	O
{	O
int	O
largepic	int
=	O
0	int
;	O
if	O
(	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
)	O
{	O
if	O
(	O
contents	pointer
[	O
roff	long
+	O
5	int
]	O
==	O
0xb8	int
)	O
{	O
if	O
(	O
roff	long
<	O
3	int
||	O
(	O
roff	long
-	O
3	int
+	O
22	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
roff	long
-	O
3	int
,	O
"\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05"	pointer
"\0\0\0\0\x66\x0f\x1f\x44\0"	pointer
,	O
22	int
)	O
;	O
largepic	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
roff	long
<	O
4	int
||	O
(	O
roff	long
-	O
4	int
+	O
16	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
roff	long
-	O
4	int
,	O
"\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0"	pointer
,	O
16	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
roff	long
<	O
3	int
||	O
(	O
roff	long
-	O
3	int
+	O
15	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
roff	long
-	O
3	int
,	O
"\x64\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0"	pointer
,	O
15	int
)	O
;	O
}	O
relocation	pointer
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
-	O
roff	long
-	O
largepic	int
-	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
input_section	pointer
->	O
output_offset	long
-	O
12	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
relocation	pointer
,	O
contents	pointer
+	O
roff	long
+	O
8	int
+	O
largepic	int
)	O
;	O
rel	pointer
++	O
;	O
wrel	pointer
++	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_X86_64_GOTPC32_TLSDESC	int
)	O
{	O
if	O
(	O
roff	long
<	O
2	int
)	O
goto	O
corrupt_input	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x8b	int
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
-	O
rel	pointer
->	O
r_offset	array
-	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
input_section	pointer
->	O
output_offset	long
-	O
4	int
,	O
contents	pointer
+	O
roff	long
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_X86_64_TLSDESC_CALL	int
)	O
{	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x66	int
,	O
contents	pointer
+	O
roff	long
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x90	int
,	O
contents	pointer
+	O
roff	long
+	O
1	int
)	O
;	O
continue	O
;	O
}	O
else	O
BFD_ASSERT	O
(	O
FALSE	int
)	O
;	O
}	O
break	O
;	O
case	O
R_X86_64_TLSLD	int
:	O
if	O
(	O
!	O
elf_x86_64_tls_transition	function
(	O
info	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
&	O
r_type	int
,	O
GOT_UNKNOWN	int
,	O
rel	pointer
,	O
relend	pointer
,	O
h	pointer
,	O
r_symndx	long
,	O
TRUE	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
r_type	int
!=	O
R_X86_64_TLSLD	int
)	O
{	O
BFD_ASSERT	O
(	O
r_type	int
==	O
R_X86_64_TPOFF32	int
)	O
;	O
if	O
(	O
ABI_64_P	O
(	O
output_bfd	pointer
)	O
)	O
{	O
if	O
(	O
(	O
rel	pointer
->	O
r_offset	array
+	O
5	int
)	O
>=	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
if	O
(	O
contents	pointer
[	O
rel	pointer
->	O
r_offset	array
+	O
5	int
]	O
==	O
0xb8	int
)	O
{	O
if	O
(	O
rel	pointer
->	O
r_offset	array
<	O
3	int
||	O
(	O
rel	pointer
->	O
r_offset	array
-	O
3	int
+	O
22	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
3	int
,	O
"\x66\x66\x66\x66\x2e\x0f\x1f\x84\0\0\0\0\0"	pointer
"\x64\x48\x8b\x04\x25\0\0\0"	pointer
,	O
22	int
)	O
;	O
}	O
else	O
if	O
(	O
contents	pointer
[	O
rel	pointer
->	O
r_offset	array
+	O
4	int
]	O
==	O
0xff	int
||	O
contents	pointer
[	O
rel	pointer
->	O
r_offset	array
+	O
4	int
]	O
==	O
0x67	int
)	O
{	O
if	O
(	O
rel	pointer
->	O
r_offset	array
<	O
3	int
||	O
(	O
rel	pointer
->	O
r_offset	array
-	O
3	int
+	O
13	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
3	int
,	O
"\x66\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0"	pointer
,	O
13	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rel	pointer
->	O
r_offset	array
<	O
3	int
||	O
(	O
rel	pointer
->	O
r_offset	array
-	O
3	int
+	O
12	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
3	int
,	O
"\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0"	pointer
,	O
12	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
rel	pointer
->	O
r_offset	array
+	O
4	int
)	O
>=	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
if	O
(	O
contents	pointer
[	O
rel	pointer
->	O
r_offset	array
+	O
4	int
]	O
==	O
0xff	int
)	O
{	O
if	O
(	O
rel	pointer
->	O
r_offset	array
<	O
3	int
||	O
(	O
rel	pointer
->	O
r_offset	array
-	O
3	int
+	O
13	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
3	int
,	O
"\x66\x0f\x1f\x40\x00\x64\x8b\x04\x25\0\0\0"	pointer
,	O
13	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rel	pointer
->	O
r_offset	array
<	O
3	int
||	O
(	O
rel	pointer
->	O
r_offset	array
-	O
3	int
+	O
12	int
)	O
>	O
input_section	pointer
->	O
size	long
)	O
goto	O
corrupt_input	O
;	O
memcpy	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
3	int
,	O
"\x0f\x1f\x40\x00\x64\x8b\x04\x25\0\0\0"	pointer
,	O
12	int
)	O
;	O
}	O
}	O
rel	pointer
++	O
;	O
wrel	pointer
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
off	long
=	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
offset	long
;	O
if	O
(	O
off	long
&	O
1	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
)	O
;	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
+	O
GOT_ENTRY_SIZE	int
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
0	int
,	O
R_X86_64_DTPMOD64	int
)	O
;	O
outrel	struct
.	O
r_addend	array
=	O
0	int
;	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
,	O
&	O
outrel	struct
)	O
;	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
offset	long
|=	O
1	int
;	O
}	O
relocation	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
R_X86_64_DTPOFF32	int
:	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
relocation	pointer
-=	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
;	O
else	O
relocation	pointer
=	O
elf_x86_64_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
;	O
break	O
;	O
case	O
R_X86_64_TPOFF32	int
:	O
case	O
R_X86_64_TPOFF64	int
:	O
BFD_ASSERT	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
;	O
relocation	pointer
=	O
elf_x86_64_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
;	O
break	O
;	O
case	O
R_X86_64_DTPOFF64	int
:	O
BFD_ASSERT	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
;	O
relocation	pointer
-=	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
unresolved_reloc	int
&&	O
!	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
&&	O
h	pointer
->	O
def_dynamic	int
)	O
&&	O
_bfd_elf_section_offset	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
switch	O
(	O
r_type	int
)	O
{	O
case	O
R_X86_64_32S	int
:	O
sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
if	O
(	O
(	O
info	pointer
->	O
nocopyreloc	int
||	O
(	O
eh	pointer
->	O
def_protected	int
&&	O
elf_has_no_copy_on_protected	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
)	O
)	O
&&	O
!	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
)	O
return	O
elf_x86_64_need_pic	function
(	O
info	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
h	pointer
,	O
NULL	O
,	O
NULL	O
,	O
howto	pointer
)	O
;	O
default	O
:	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB(%pA+%#"	pointer
PRIx64	O
"): "	pointer
"unresolvable %s relocation against symbol `%s'"	pointer
)	O
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_offset	array
,	O
howto	pointer
->	O
name	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
do_relocation	O
:	O
r	enum
=	O
_bfd_final_link_relocate	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
rel	pointer
->	O
r_offset	array
,	O
relocation	pointer
,	O
rel	pointer
->	O
r_addend	array
)	O
;	O
check_relocation_error	O
:	O
if	O
(	O
r	enum
!=	O
bfd_reloc_ok	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
{	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
->	O
sh_link	array
,	O
sym	pointer
->	O
st_name	array
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
name	pointer
==	O
'\0'	O
)	O
name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
}	O
if	O
(	O
r	enum
==	O
bfd_reloc_overflow	int
)	O
{	O
if	O
(	O
converted_reloc	int
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: failed to convert GOTPCREL relocation; relink with --no-relax\n"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
reloc_overflow	pointer
)	O
(	O
info	pointer
,	O
(	O
h	pointer
?	O
&	O
h	pointer
->	O
root	struct
:	O
NULL	O
)	O
,	O
name	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
;	O
}	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB(%pA+%#"	pointer
PRIx64	O
"): reloc against `%s': error %d"	pointer
)	O
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_offset	array
,	O
name	pointer
,	O
(	O
int	O
)	O
r	enum
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
wrel	pointer
!=	O
rel	pointer
)	O
*	O
wrel	pointer
=	O
*	O
rel	pointer
;	O
}	O
if	O
(	O
wrel	pointer
!=	O
rel	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
rel_hdr	pointer
;	O
size_t	long
deleted	long
=	O
rel	pointer
-	O
wrel	pointer
;	O
rel_hdr	pointer
=	O
_bfd_elf_single_rel_hdr	function
(	O
input_section	pointer
->	O
output_section	pointer
)	O
;	O
rel_hdr	pointer
->	O
sh_size	array
-=	O
rel_hdr	pointer
->	O
sh_entsize	array
*	O
deleted	long
;	O
if	O
(	O
rel_hdr	pointer
->	O
sh_size	array
==	O
0	int
)	O
{	O
rel_hdr	pointer
->	O
sh_size	array
=	O
rel_hdr	pointer
->	O
sh_entsize	array
;	O
deleted	long
-=	O
1	int
;	O
}	O
rel_hdr	pointer
=	O
_bfd_elf_single_rel_hdr	function
(	O
input_section	pointer
)	O
;	O
rel_hdr	pointer
->	O
sh_size	array
-=	O
rel_hdr	pointer
->	O
sh_entsize	array
*	O
deleted	long
;	O
input_section	pointer
->	O
reloc_count	int
-=	O
deleted	long
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_finish_dynamic_symbol	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
bfd_boolean	int
use_plt_second	int
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
bfd_boolean	int
local_undefweak	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
X86_64_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
use_plt_second	int
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
;	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
if	O
(	O
eh	pointer
->	O
no_finish_dynamic_symbol	int
)	O
abort	function
(	O
)	O
;	O
local_undefweak	int
=	O
UNDEFINED_WEAK_RESOLVED_TO_ZERO	O
(	O
info	pointer
,	O
eh	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
bfd_vma	long
plt_index	long
;	O
bfd_vma	long
got_offset	long
,	O
plt_offset	long
;	O
Elf_Internal_Rela	struct
rela	struct
;	O
bfd_byte	char
*	O
loc	pointer
;	O
asection	struct
*	O
plt	union
,	O
*	O
gotplt	pointer
,	O
*	O
relplt	pointer
,	O
*	O
resolved_plt	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
bfd_vma	long
plt_got_pcrel_offset	long
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
{	O
plt	union
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
gotplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
relplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
;	O
}	O
else	O
{	O
plt	union
=	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
;	O
gotplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
igotplt	pointer
;	O
relplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
irelplt	pointer
;	O
}	O
VERIFY_PLT_ENTRY	O
(	O
info	pointer
,	O
h	pointer
,	O
plt	union
,	O
gotplt	pointer
,	O
relplt	pointer
,	O
local_undefweak	int
)	O
if	O
(	O
plt	union
==	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
)	O
{	O
got_offset	long
=	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
-	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
;	O
got_offset	long
=	O
(	O
got_offset	long
+	O
3	int
)	O
*	O
GOT_ENTRY_SIZE	int
;	O
}	O
else	O
{	O
got_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
;	O
got_offset	long
=	O
got_offset	long
*	O
GOT_ENTRY_SIZE	int
;	O
}	O
memcpy	function
(	O
plt	union
->	O
contents	pointer
+	O
h	pointer
->	O
plt	union
.	O
offset	long
,	O
htab	struct
->	O
plt	union
.	O
plt_entry	pointer
,	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
)	O
;	O
if	O
(	O
use_plt_second	int
)	O
{	O
memcpy	function
(	O
htab	struct
->	O
plt_second	union
->	O
contents	pointer
+	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
,	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry	pointer
,	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
)	O
;	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
plt	union
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
plt_got_pcrel_offset	long
=	O
(	O
gotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
gotplt	pointer
->	O
output_offset	long
+	O
got_offset	long
-	O
resolved_plt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
resolved_plt	pointer
->	O
output_offset	long
-	O
plt_offset	long
-	O
htab	struct
->	O
plt	union
.	O
plt_got_insn_size	int
)	O
;	O
if	O
(	O
(	O
plt_got_pcrel_offset	long
+	O
0x80000000	int
)	O
>	O
0xffffffff	int
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%pB: PC-relative offset overflow in PLT entry for `%s'\n"	pointer
)	O
,	O
output_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
plt_got_pcrel_offset	long
,	O
(	O
resolved_plt	pointer
->	O
contents	pointer
+	O
plt_offset	long
+	O
htab	struct
->	O
plt	union
.	O
plt_got_offset	int
)	O
)	O
;	O
if	O
(	O
!	O
local_undefweak	int
)	O
{	O
if	O
(	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
(	O
plt	union
->	O
output_section	pointer
->	O
vma	long
+	O
plt	union
->	O
output_offset	long
+	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_lazy_offset	int
)	O
,	O
gotplt	pointer
->	O
contents	pointer
+	O
got_offset	long
)	O
;	O
rela	struct
.	O
r_offset	array
=	O
(	O
gotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
gotplt	pointer
->	O
output_offset	long
+	O
got_offset	long
)	O
;	O
if	O
(	O
PLT_LOCAL_IFUNC_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
(	O
_	O
(	O
"Local IFUNC function `%s' in %pB\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
rela	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
0	int
,	O
R_X86_64_IRELATIVE	int
)	O
;	O
rela	struct
.	O
r_addend	array
=	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
plt_index	long
=	O
htab	struct
->	O
next_irelative_index	long
--	O
;	O
}	O
else	O
{	O
rela	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
h	pointer
->	O
dynindx	long
,	O
R_X86_64_JUMP_SLOT	int
)	O
;	O
rela	struct
.	O
r_addend	array
=	O
0	int
;	O
plt_index	long
=	O
htab	struct
->	O
next_jump_slot_index	long
++	O
;	O
}	O
if	O
(	O
plt	union
==	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
&&	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
{	O
bfd_vma	long
plt0_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_plt_insn_end	int
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
plt_index	long
,	O
(	O
plt	union
->	O
contents	pointer
+	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_reloc_offset	int
)	O
)	O
;	O
if	O
(	O
plt0_offset	long
>	O
0x80000000	int
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%pB: branch displacement overflow in PLT entry for `%s'\n"	pointer
)	O
,	O
output_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
-	O
plt0_offset	long
,	O
(	O
plt	union
->	O
contents	pointer
+	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_plt_offset	int
)	O
)	O
;	O
}	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
loc	pointer
=	O
relplt	pointer
->	O
contents	pointer
+	O
plt_index	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
;	O
bed	pointer
->	O
s	pointer
->	O
swap_reloca_out	pointer
(	O
output_bfd	pointer
,	O
&	O
rela	struct
,	O
loc	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
bfd_vma	long
got_offset	long
,	O
plt_offset	long
;	O
asection	struct
*	O
plt	union
,	O
*	O
got	union
;	O
bfd_boolean	int
got_after_plt	int
;	O
int32_t	int
got_pcrel_offset	int
;	O
plt	union
=	O
htab	struct
->	O
plt_got	union
;	O
got	union
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
got_offset	long
=	O
h	pointer
->	O
got	union
.	O
offset	long
;	O
if	O
(	O
got_offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
(	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
h	pointer
->	O
def_regular	int
)	O
||	O
plt	union
==	O
NULL	O
||	O
got	union
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
;	O
memcpy	function
(	O
plt	union
->	O
contents	pointer
+	O
plt_offset	long
,	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry	pointer
,	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
)	O
;	O
got_pcrel_offset	int
=	O
(	O
got	union
->	O
output_section	pointer
->	O
vma	long
+	O
got	union
->	O
output_offset	long
+	O
got_offset	long
-	O
plt	union
->	O
output_section	pointer
->	O
vma	long
-	O
plt	union
->	O
output_offset	long
-	O
plt_offset	long
-	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_got_insn_size	int
)	O
;	O
got_after_plt	int
=	O
got	union
->	O
output_section	pointer
->	O
vma	long
>	O
plt	union
->	O
output_section	pointer
->	O
vma	long
;	O
if	O
(	O
(	O
got_after_plt	int
&&	O
got_pcrel_offset	int
<	O
0	int
)	O
||	O
(	O
!	O
got_after_plt	int
&&	O
got_pcrel_offset	int
>	O
0	int
)	O
)	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%pB: PC-relative offset overflow in GOT PLT entry for `%s'\n"	pointer
)	O
,	O
output_bfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
got_pcrel_offset	int
,	O
(	O
plt	union
->	O
contents	pointer
+	O
plt_offset	long
+	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_got_offset	int
)	O
)	O
;	O
}	O
if	O
(	O
!	O
local_undefweak	int
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
)	O
{	O
sym	pointer
->	O
st_shndx	array
=	O
SHN_UNDEF	int
;	O
if	O
(	O
!	O
h	pointer
->	O
pointer_equality_needed	int
)	O
sym	pointer
->	O
st_value	array
=	O
0	int
;	O
}	O
_bfd_x86_elf_link_fixup_ifunc_symbol	function
(	O
info	pointer
,	O
htab	struct
,	O
h	pointer
,	O
sym	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
got	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
!	O
GOT_TLS_GD_ANY_P	O
(	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
)	O
&&	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
!=	O
GOT_TLS_IE	int
&&	O
!	O
local_undefweak	int
)	O
{	O
Elf_Internal_Rela	struct
rela	struct
;	O
asection	struct
*	O
relgot	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
||	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
rela	struct
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
(	O
h	pointer
->	O
got	union
.	O
offset	long
&	O
~	O
(	O
bfd_vma	long
)	O
1	int
)	O
)	O
;	O
if	O
(	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
{	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
==	O
NULL	O
)	O
{	O
relgot	pointer
=	O
htab	struct
->	O
elf	struct
.	O
irelplt	pointer
;	O
}	O
if	O
(	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
(	O
_	O
(	O
"Local IFUNC function `%s' in %pB\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
rela	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
0	int
,	O
R_X86_64_IRELATIVE	int
)	O
;	O
rela	struct
.	O
r_addend	array
=	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
}	O
else	O
goto	O
do_glob_dat	O
;	O
}	O
else	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
goto	O
do_glob_dat	O
;	O
}	O
else	O
{	O
asection	struct
*	O
plt	union
;	O
bfd_vma	long
plt_offset	long
;	O
if	O
(	O
!	O
h	pointer
->	O
pointer_equality_needed	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
)	O
{	O
plt	union
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
plt	union
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
?	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
:	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
(	O
plt	union
->	O
output_section	pointer
->	O
vma	long
+	O
plt	union
->	O
output_offset	long
+	O
plt_offset	long
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
h	pointer
->	O
got	union
.	O
offset	long
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
else	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
if	O
(	O
!	O
SYMBOL_DEFINED_NON_SHARED_P	O
(	O
h	pointer
)	O
)	O
return	O
FALSE	int
;	O
BFD_ASSERT	O
(	O
(	O
h	pointer
->	O
got	union
.	O
offset	long
&	O
1	int
)	O
!=	O
0	int
)	O
;	O
rela	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
0	int
,	O
R_X86_64_RELATIVE	int
)	O
;	O
rela	struct
.	O
r_addend	array
=	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
}	O
else	O
{	O
BFD_ASSERT	O
(	O
(	O
h	pointer
->	O
got	union
.	O
offset	long
&	O
1	int
)	O
==	O
0	int
)	O
;	O
do_glob_dat	O
:	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
h	pointer
->	O
got	union
.	O
offset	long
)	O
;	O
rela	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
h	pointer
->	O
dynindx	long
,	O
R_X86_64_GLOB_DAT	int
)	O
;	O
rela	struct
.	O
r_addend	array
=	O
0	int
;	O
}	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
relgot	pointer
,	O
&	O
rela	struct
)	O
;	O
}	O
if	O
(	O
h	pointer
->	O
needs_copy	int
)	O
{	O
Elf_Internal_Rela	struct
rela	struct
;	O
asection	struct
*	O
s	pointer
;	O
VERIFY_COPY_RELOC	O
(	O
h	pointer
,	O
htab	struct
)	O
rela	struct
.	O
r_offset	array
=	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
rela	struct
.	O
r_info	array
=	O
htab	struct
->	O
r_info	array
(	O
h	pointer
->	O
dynindx	long
,	O
R_X86_64_COPY	int
)	O
;	O
rela	struct
.	O
r_addend	array
=	O
0	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
==	O
htab	struct
->	O
elf	struct
.	O
sdynrelro	pointer
)	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sreldynrelro	pointer
;	O
else	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelbss	pointer
;	O
elf_append_rela	function
(	O
output_bfd	pointer
,	O
s	pointer
,	O
&	O
rela	struct
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_finish_local_dynamic_symbol	function
(	O
void	O
*	O
*	O
slot	pointer
,	O
void	O
*	O
inf	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
*	O
slot	pointer
;	O
struct	O
bfd_link_info	struct
*	O
info	pointer
=	O
(	O
struct	O
bfd_link_info	struct
*	O
)	O
inf	pointer
;	O
return	O
elf_x86_64_finish_dynamic_symbol	function
(	O
info	pointer
->	O
output_bfd	pointer
,	O
info	pointer
,	O
h	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_pie_finish_undefweak_symbol	function
(	O
struct	O
bfd_hash_entry	struct
*	O
bh	pointer
,	O
void	O
*	O
inf	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
struct	O
bfd_link_info	struct
*	O
info	pointer
=	O
(	O
struct	O
bfd_link_info	struct
*	O
)	O
inf	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefweak	int
||	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
return	O
TRUE	int
;	O
return	O
elf_x86_64_finish_dynamic_symbol	function
(	O
info	pointer
->	O
output_bfd	pointer
,	O
info	pointer
,	O
h	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
enum	O
elf_reloc_type_class	enum
elf_x86_64_reloc_type_class	function
(	O
const	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
asection	struct
*	O
rel_sec	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
Elf_Internal_Rela	struct
*	O
rela	struct
)	O
{	O
bfd	struct
*	O
abfd	pointer
=	O
info	pointer
->	O
output_bfd	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
X86_64_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
dynsym	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
elf	struct
.	O
dynsym	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
r_symndx	long
=	O
htab	struct
->	O
r_sym	pointer
(	O
rela	struct
->	O
r_info	array
)	O
;	O
if	O
(	O
r_symndx	long
!=	O
STN_UNDEF	int
)	O
{	O
Elf_Internal_Sym	struct
sym	pointer
;	O
if	O
(	O
!	O
bed	pointer
->	O
s	pointer
->	O
swap_symbol_in	pointer
(	O
abfd	pointer
,	O
(	O
htab	struct
->	O
elf	struct
.	O
dynsym	pointer
->	O
contents	pointer
+	O
r_symndx	long
*	O
bed	pointer
->	O
s	pointer
->	O
sizeof_sym	char
)	O
,	O
0	int
,	O
&	O
sym	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
.	O
st_info	array
)	O
==	O
STT_GNU_IFUNC	int
)	O
return	O
reloc_class_ifunc	int
;	O
}	O
}	O
switch	O
(	O
(	O
int	O
)	O
ELF32_R_TYPE	O
(	O
rela	struct
->	O
r_info	array
)	O
)	O
{	O
case	O
R_X86_64_IRELATIVE	int
:	O
return	O
reloc_class_ifunc	int
;	O
case	O
R_X86_64_RELATIVE	int
:	O
case	O
R_X86_64_RELATIVE64	int
:	O
return	O
reloc_class_relative	int
;	O
case	O
R_X86_64_JUMP_SLOT	int
:	O
return	O
reloc_class_plt	int
;	O
case	O
R_X86_64_COPY	int
:	O
return	O
reloc_class_copy	int
;	O
default	O
:	O
return	O
reloc_class_normal	int
;	O
}	O
}	O
static	O
bfd_boolean	int
elf_x86_64_finish_dynamic_sections	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
htab	struct
=	O
_bfd_x86_elf_finish_dynamic_sections	function
(	O
output_bfd	pointer
,	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
htab	struct
->	O
elf	struct
.	O
dynamic_sections_created	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
&&	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
>	O
0	int
)	O
{	O
elf_section_data	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
;	O
if	O
(	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
{	O
memcpy	function
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
,	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_entry	pointer
,	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_entry_size	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
8	int
-	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_offset	long
-	O
6	int
)	O
,	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_got1_offset	int
)	O
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
16	int
-	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_offset	long
-	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_got2_insn_end	int
)	O
,	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_got2_offset	int
)	O
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
tlsdesc_plt	long
)	O
{	O
bfd_put_64	O
(	O
output_bfd	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
tlsdesc_got	long
)	O
;	O
memcpy	function
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
tlsdesc_plt	long
,	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_tlsdesc_entry	pointer
,	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_tlsdesc_entry_size	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
8	int
-	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_offset	long
-	O
htab	struct
->	O
tlsdesc_plt	long
-	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_tlsdesc_got1_insn_end	int
)	O
,	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
tlsdesc_plt	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_tlsdesc_got1_offset	int
)	O
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
htab	struct
->	O
tlsdesc_got	long
-	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_offset	long
-	O
htab	struct
->	O
tlsdesc_plt	long
-	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_tlsdesc_got2_insn_end	int
)	O
,	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
tlsdesc_plt	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_tlsdesc_got2_offset	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
bfd_link_pie	O
(	O
info	pointer
)	O
)	O
bfd_hash_traverse	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
elf_x86_64_pie_finish_undefweak_symbol	function
,	O
info	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_output_arch_local_syms	function
(	O
bfd	struct
*	O
output_bfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
void	O
*	O
flaginfo	pointer
ATTRIBUTE_UNUSED	O
,	O
int	O
(	O
*	O
func	pointer
)	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
Elf_Internal_Sym	struct
*	O
,	O
asection	struct
*	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
X86_64_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
htab_traverse	function
(	O
htab	struct
->	O
loc_hash_table	pointer
,	O
elf_x86_64_finish_local_dynamic_symbol	function
,	O
info	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_x86_64_nacl_plt	struct
;	O
static	O
long	O
elf_x86_64_get_synthetic_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
long	O
symcount	int
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
*	O
syms	pointer
ATTRIBUTE_UNUSED	O
,	O
long	O
dynsymcount	int
,	O
asymbol	struct
*	O
*	O
dynsyms	pointer
,	O
asymbol	struct
*	O
*	O
ret	pointer
)	O
{	O
long	O
count	int
,	O
i	pointer
,	O
n	long
;	O
int	O
j	int
;	O
bfd_byte	char
*	O
plt_contents	pointer
;	O
long	O
relsize	long
;	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
*	O
lazy_plt	pointer
;	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
*	O
non_lazy_plt	pointer
;	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
*	O
lazy_bnd_plt	pointer
;	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
*	O
non_lazy_bnd_plt	pointer
;	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
*	O
lazy_ibt_plt	pointer
;	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
*	O
non_lazy_ibt_plt	pointer
;	O
asection	struct
*	O
plt	union
;	O
enum	O
elf_x86_plt_type	enum
plt_type	enum
;	O
struct	O
elf_x86_plt	struct
plts	array
[	O
]	O
=	O
{	O
{	O
".plt"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
plt_unknown	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".plt.got"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
plt_non_lazy	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".plt.sec"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
plt_second	union
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".plt.bnd"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
plt_second	union
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
plt_non_lazy	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
*	O
ret	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
EXEC_P	int
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
dynsymcount	int
<=	O
0	int
)	O
return	O
0	int
;	O
relsize	long
=	O
bfd_get_dynamic_reloc_upper_bound	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
relsize	long
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
get_elf_x86_backend_data	O
(	O
abfd	pointer
)	O
->	O
target_os	enum
!=	O
is_nacl	int
)	O
{	O
lazy_plt	pointer
=	O
&	O
elf_x86_64_lazy_plt	struct
;	O
non_lazy_plt	pointer
=	O
&	O
elf_x86_64_non_lazy_plt	struct
;	O
lazy_bnd_plt	pointer
=	O
&	O
elf_x86_64_lazy_bnd_plt	struct
;	O
non_lazy_bnd_plt	pointer
=	O
&	O
elf_x86_64_non_lazy_bnd_plt	struct
;	O
if	O
(	O
ABI_64_P	O
(	O
abfd	pointer
)	O
)	O
{	O
lazy_ibt_plt	pointer
=	O
&	O
elf_x86_64_lazy_ibt_plt	struct
;	O
non_lazy_ibt_plt	pointer
=	O
&	O
elf_x86_64_non_lazy_ibt_plt	struct
;	O
}	O
else	O
{	O
lazy_ibt_plt	pointer
=	O
&	O
elf_x32_lazy_ibt_plt	struct
;	O
non_lazy_ibt_plt	pointer
=	O
&	O
elf_x32_non_lazy_ibt_plt	struct
;	O
}	O
}	O
else	O
{	O
lazy_plt	pointer
=	O
&	O
elf_x86_64_nacl_plt	struct
;	O
non_lazy_plt	pointer
=	O
NULL	O
;	O
lazy_bnd_plt	pointer
=	O
NULL	O
;	O
non_lazy_bnd_plt	pointer
=	O
NULL	O
;	O
lazy_ibt_plt	pointer
=	O
NULL	O
;	O
non_lazy_ibt_plt	pointer
=	O
NULL	O
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
plts	array
[	O
j	int
]	O
.	O
name	pointer
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
plt	union
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
plts	array
[	O
j	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
plt	union
==	O
NULL	O
||	O
plt	union
->	O
size	long
==	O
0	int
)	O
continue	O
;	O
plt_contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
plt	union
->	O
size	long
)	O
;	O
if	O
(	O
plt_contents	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
abfd	pointer
,	O
(	O
asection	struct
*	O
)	O
plt	union
,	O
plt_contents	pointer
,	O
0	int
,	O
plt	union
->	O
size	long
)	O
)	O
{	O
free	function
(	O
plt_contents	pointer
)	O
;	O
break	O
;	O
}	O
plt_type	enum
=	O
plt_unknown	int
;	O
if	O
(	O
plts	array
[	O
j	int
]	O
.	O
type	enum
==	O
plt_unknown	int
&&	O
(	O
plt	union
->	O
size	long
>=	O
(	O
lazy_plt	pointer
->	O
plt_entry_size	int
+	O
lazy_plt	pointer
->	O
plt_entry_size	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
lazy_plt	pointer
->	O
plt0_entry	pointer
,	O
lazy_plt	pointer
->	O
plt0_got1_offset	int
)	O
==	O
0	int
)	O
&&	O
(	O
memcmp	function
(	O
plt_contents	pointer
+	O
6	int
,	O
lazy_plt	pointer
->	O
plt0_entry	pointer
+	O
6	int
,	O
2	int
)	O
==	O
0	int
)	O
)	O
plt_type	enum
=	O
plt_lazy	int
;	O
else	O
if	O
(	O
lazy_bnd_plt	pointer
!=	O
NULL	O
&&	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
lazy_bnd_plt	pointer
->	O
plt0_entry	pointer
,	O
lazy_bnd_plt	pointer
->	O
plt0_got1_offset	int
)	O
==	O
0	int
)	O
&&	O
(	O
memcmp	function
(	O
plt_contents	pointer
+	O
6	int
,	O
lazy_bnd_plt	pointer
->	O
plt0_entry	pointer
+	O
6	int
,	O
3	int
)	O
==	O
0	int
)	O
)	O
{	O
plt_type	enum
=	O
plt_lazy	int
|	O
plt_second	union
;	O
if	O
(	O
(	O
memcmp	function
(	O
plt_contents	pointer
+	O
lazy_ibt_plt	pointer
->	O
plt_entry_size	int
,	O
lazy_ibt_plt	pointer
->	O
plt_entry	pointer
,	O
lazy_ibt_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
)	O
lazy_plt	pointer
=	O
lazy_ibt_plt	pointer
;	O
else	O
lazy_plt	pointer
=	O
lazy_bnd_plt	pointer
;	O
}	O
}	O
if	O
(	O
non_lazy_plt	pointer
!=	O
NULL	O
&&	O
(	O
plt_type	enum
==	O
plt_unknown	int
||	O
plt_type	enum
==	O
plt_non_lazy	int
)	O
&&	O
plt	union
->	O
size	long
>=	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
non_lazy_plt	pointer
->	O
plt_entry	pointer
,	O
non_lazy_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
plt_type	enum
=	O
plt_non_lazy	int
;	O
}	O
if	O
(	O
plt_type	enum
==	O
plt_unknown	int
||	O
plt_type	enum
==	O
plt_second	union
)	O
{	O
if	O
(	O
non_lazy_bnd_plt	pointer
!=	O
NULL	O
&&	O
plt	union
->	O
size	long
>=	O
non_lazy_bnd_plt	pointer
->	O
plt_entry_size	int
&&	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
non_lazy_bnd_plt	pointer
->	O
plt_entry	pointer
,	O
non_lazy_bnd_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
)	O
{	O
plt_type	enum
=	O
plt_second	union
;	O
non_lazy_plt	pointer
=	O
non_lazy_bnd_plt	pointer
;	O
}	O
else	O
if	O
(	O
non_lazy_ibt_plt	pointer
!=	O
NULL	O
&&	O
plt	union
->	O
size	long
>=	O
non_lazy_ibt_plt	pointer
->	O
plt_entry_size	int
&&	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
non_lazy_ibt_plt	pointer
->	O
plt_entry	pointer
,	O
non_lazy_ibt_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
)	O
{	O
plt_type	enum
=	O
plt_second	union
;	O
non_lazy_plt	pointer
=	O
non_lazy_ibt_plt	pointer
;	O
}	O
}	O
if	O
(	O
plt_type	enum
==	O
plt_unknown	int
)	O
{	O
free	function
(	O
plt_contents	pointer
)	O
;	O
continue	O
;	O
}	O
plts	array
[	O
j	int
]	O
.	O
sec	pointer
=	O
plt	union
;	O
plts	array
[	O
j	int
]	O
.	O
type	enum
=	O
plt_type	enum
;	O
if	O
(	O
(	O
plt_type	enum
&	O
plt_lazy	int
)	O
)	O
{	O
plts	array
[	O
j	int
]	O
.	O
plt_got_offset	int
=	O
lazy_plt	pointer
->	O
plt_got_offset	int
;	O
plts	array
[	O
j	int
]	O
.	O
plt_got_insn_size	int
=	O
lazy_plt	pointer
->	O
plt_got_insn_size	int
;	O
plts	array
[	O
j	int
]	O
.	O
plt_entry_size	int
=	O
lazy_plt	pointer
->	O
plt_entry_size	int
;	O
i	pointer
=	O
1	int
;	O
}	O
else	O
{	O
plts	array
[	O
j	int
]	O
.	O
plt_got_offset	int
=	O
non_lazy_plt	pointer
->	O
plt_got_offset	int
;	O
plts	array
[	O
j	int
]	O
.	O
plt_got_insn_size	int
=	O
non_lazy_plt	pointer
->	O
plt_got_insn_size	int
;	O
plts	array
[	O
j	int
]	O
.	O
plt_entry_size	int
=	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
;	O
i	pointer
=	O
0	int
;	O
}	O
if	O
(	O
plt_type	enum
==	O
(	O
plt_lazy	int
|	O
plt_second	union
)	O
)	O
plts	array
[	O
j	int
]	O
.	O
count	int
=	O
0	int
;	O
else	O
{	O
n	long
=	O
plt	union
->	O
size	long
/	O
plts	array
[	O
j	int
]	O
.	O
plt_entry_size	int
;	O
plts	array
[	O
j	int
]	O
.	O
count	int
=	O
n	long
;	O
count	int
+=	O
n	long
-	O
i	pointer
;	O
}	O
plts	array
[	O
j	int
]	O
.	O
contents	pointer
=	O
plt_contents	pointer
;	O
}	O
return	O
_bfd_x86_elf_get_synthetic_symtab	function
(	O
abfd	pointer
,	O
count	int
,	O
relsize	long
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
plts	array
,	O
dynsyms	pointer
,	O
ret	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_section_from_shdr	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
shindex	int
)	O
{	O
if	O
(	O
hdr	pointer
->	O
sh_type	array
!=	O
SHT_X86_64_UNWIND	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
_bfd_elf_make_section_from_shdr	function
(	O
abfd	pointer
,	O
hdr	pointer
,	O
name	pointer
,	O
shindex	int
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_add_symbol_hook	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
,	O
const	O
char	O
*	O
*	O
namep	pointer
ATTRIBUTE_UNUSED	O
,	O
flagword	int
*	O
flagsp	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
*	O
secp	pointer
,	O
bfd_vma	long
*	O
valp	pointer
)	O
{	O
asection	struct
*	O
lcomm	pointer
;	O
switch	O
(	O
sym	pointer
->	O
st_shndx	array
)	O
{	O
case	O
SHN_X86_64_LCOMMON	O
:	O
lcomm	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
"LARGE_COMMON"	pointer
)	O
;	O
if	O
(	O
lcomm	pointer
==	O
NULL	O
)	O
{	O
lcomm	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
"LARGE_COMMON"	pointer
,	O
(	O
SEC_ALLOC	int
|	O
SEC_IS_COMMON	int
|	O
SEC_LINKER_CREATED	int
)	O
)	O
;	O
if	O
(	O
lcomm	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
elf_section_flags	O
(	O
lcomm	pointer
)	O
|=	O
SHF_X86_64_LARGE	int
;	O
}	O
*	O
secp	pointer
=	O
lcomm	pointer
;	O
*	O
valp	pointer
=	O
sym	pointer
->	O
st_size	long
;	O
return	O
TRUE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_elf_section_from_bfd_section	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asection	struct
*	O
sec	pointer
,	O
int	O
*	O
index_return	pointer
)	O
{	O
if	O
(	O
sec	pointer
==	O
&	O
_bfd_elf_large_com_section	struct
)	O
{	O
*	O
index_return	pointer
=	O
SHN_X86_64_LCOMMON	O
;	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
elf_x86_64_symbol_processing	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
asym	pointer
)	O
{	O
elf_symbol_type	struct
*	O
elfsym	pointer
=	O
(	O
elf_symbol_type	struct
*	O
)	O
asym	pointer
;	O
switch	O
(	O
elfsym	pointer
->	O
internal_elf_sym	struct
.	O
st_shndx	array
)	O
{	O
case	O
SHN_X86_64_LCOMMON	O
:	O
asym	pointer
->	O
section	pointer
=	O
&	O
_bfd_elf_large_com_section	struct
;	O
asym	pointer
->	O
value	long
=	O
elfsym	pointer
->	O
internal_elf_sym	struct
.	O
st_size	long
;	O
asym	pointer
->	O
flags	int
&=	O
~	O
BSF_GLOBAL	O
;	O
break	O
;	O
}	O
}	O
static	O
bfd_boolean	int
elf_x86_64_common_definition	function
(	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
return	O
(	O
sym	pointer
->	O
st_shndx	array
==	O
SHN_COMMON	O
||	O
sym	pointer
->	O
st_shndx	array
==	O
SHN_X86_64_LCOMMON	O
)	O
;	O
}	O
static	O
unsigned	O
int	O
elf_x86_64_common_section_index	function
(	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
(	O
elf_section_flags	O
(	O
sec	pointer
)	O
&	O
SHF_X86_64_LARGE	int
)	O
==	O
0	int
)	O
return	O
SHN_COMMON	O
;	O
else	O
return	O
SHN_X86_64_LCOMMON	O
;	O
}	O
static	O
asection	struct
*	O
elf_x86_64_common_section	function
(	O
asection	struct
*	O
sec	pointer
)	O
{	O
if	O
(	O
(	O
elf_section_flags	O
(	O
sec	pointer
)	O
&	O
SHF_X86_64_LARGE	int
)	O
==	O
0	int
)	O
return	O
bfd_com_section_ptr	O
;	O
else	O
return	O
&	O
_bfd_elf_large_com_section	struct
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_merge_symbol	function
(	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
const	O
Elf_Internal_Sym	struct
*	O
sym	pointer
,	O
asection	struct
*	O
*	O
psec	pointer
,	O
bfd_boolean	int
newdef	int
,	O
bfd_boolean	int
olddef	int
,	O
bfd	struct
*	O
oldbfd	pointer
,	O
const	O
asection	struct
*	O
oldsec	pointer
)	O
{	O
if	O
(	O
!	O
olddef	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
&&	O
!	O
newdef	int
&&	O
bfd_is_com_section	function
(	O
*	O
psec	pointer
)	O
&&	O
oldsec	pointer
!=	O
*	O
psec	pointer
)	O
{	O
if	O
(	O
sym	pointer
->	O
st_shndx	array
==	O
SHN_COMMON	O
&&	O
(	O
elf_section_flags	O
(	O
oldsec	pointer
)	O
&	O
SHF_X86_64_LARGE	int
)	O
!=	O
0	int
)	O
{	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
=	O
bfd_make_section_old_way	function
(	O
oldbfd	pointer
,	O
"COMMON"	pointer
)	O
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
section	pointer
->	O
flags	int
=	O
SEC_ALLOC	int
;	O
}	O
else	O
if	O
(	O
sym	pointer
->	O
st_shndx	array
==	O
SHN_X86_64_LCOMMON	O
&&	O
(	O
elf_section_flags	O
(	O
oldsec	pointer
)	O
&	O
SHF_X86_64_LARGE	int
)	O
==	O
0	int
)	O
*	O
psec	pointer
=	O
bfd_com_section_ptr	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
elf_x86_64_additional_program_headers	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
asection	struct
*	O
s	pointer
;	O
int	O
count	int
=	O
0	int
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".lrodata"	pointer
)	O
;	O
if	O
(	O
s	pointer
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
)	O
count	int
++	O
;	O
s	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".ldata"	pointer
)	O
;	O
if	O
(	O
s	pointer
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
)	O
count	int
++	O
;	O
return	O
count	int
;	O
}	O
static	O
bfd_boolean	int
elf_x86_64_relocs_compatible	function
(	O
const	O
bfd_target	struct
*	O
input	pointer
,	O
const	O
bfd_target	struct
*	O
output	pointer
)	O
{	O
return	O
(	O
(	O
xvec_get_elf_backend_data	O
(	O
input	pointer
)	O
->	O
s	pointer
->	O
elfclass	char
==	O
xvec_get_elf_backend_data	O
(	O
output	pointer
)	O
->	O
s	pointer
->	O
elfclass	char
)	O
&&	O
_bfd_elf_relocs_compatible	function
(	O
input	pointer
,	O
output	pointer
)	O
)	O
;	O
}	O
static	O
bfd	struct
*	O
elf_x86_64_link_setup_gnu_properties	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_x86_init_table	struct
init_table	struct
;	O
if	O
(	O
(	O
int	O
)	O
R_X86_64_standard	O
>=	O
(	O
int	O
)	O
R_X86_64_converted_reloc_bit	O
||	O
(	O
int	O
)	O
R_X86_64_max	int
<=	O
(	O
int	O
)	O
R_X86_64_converted_reloc_bit	O
||	O
(	O
(	O
int	O
)	O
(	O
R_X86_64_GNU_VTINHERIT	int
|	O
R_X86_64_converted_reloc_bit	O
)	O
!=	O
(	O
int	O
)	O
R_X86_64_GNU_VTINHERIT	int
)	O
||	O
(	O
(	O
int	O
)	O
(	O
R_X86_64_GNU_VTENTRY	int
|	O
R_X86_64_converted_reloc_bit	O
)	O
!=	O
(	O
int	O
)	O
R_X86_64_GNU_VTENTRY	int
)	O
)	O
abort	function
(	O
)	O
;	O
init_table	struct
.	O
plt0_pad_byte	char
=	O
0x90	int
;	O
if	O
(	O
get_elf_x86_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
->	O
target_os	enum
!=	O
is_nacl	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
bed	pointer
->	O
target_id	enum
)	O
;	O
if	O
(	O
!	O
htab	struct
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
bndplt	int
)	O
{	O
init_table	struct
.	O
lazy_plt	pointer
=	O
&	O
elf_x86_64_lazy_bnd_plt	struct
;	O
init_table	struct
.	O
non_lazy_plt	pointer
=	O
&	O
elf_x86_64_non_lazy_bnd_plt	struct
;	O
}	O
else	O
{	O
init_table	struct
.	O
lazy_plt	pointer
=	O
&	O
elf_x86_64_lazy_plt	struct
;	O
init_table	struct
.	O
non_lazy_plt	pointer
=	O
&	O
elf_x86_64_non_lazy_plt	struct
;	O
}	O
if	O
(	O
ABI_64_P	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
)	O
{	O
init_table	struct
.	O
lazy_ibt_plt	pointer
=	O
&	O
elf_x86_64_lazy_ibt_plt	struct
;	O
init_table	struct
.	O
non_lazy_ibt_plt	pointer
=	O
&	O
elf_x86_64_non_lazy_ibt_plt	struct
;	O
}	O
else	O
{	O
init_table	struct
.	O
lazy_ibt_plt	pointer
=	O
&	O
elf_x32_lazy_ibt_plt	struct
;	O
init_table	struct
.	O
non_lazy_ibt_plt	pointer
=	O
&	O
elf_x32_non_lazy_ibt_plt	struct
;	O
}	O
}	O
else	O
{	O
init_table	struct
.	O
lazy_plt	pointer
=	O
&	O
elf_x86_64_nacl_plt	struct
;	O
init_table	struct
.	O
non_lazy_plt	pointer
=	O
NULL	O
;	O
init_table	struct
.	O
lazy_ibt_plt	pointer
=	O
NULL	O
;	O
init_table	struct
.	O
non_lazy_ibt_plt	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
ABI_64_P	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
)	O
{	O
init_table	struct
.	O
r_info	array
=	O
elf64_r_info	function
;	O
init_table	struct
.	O
r_sym	pointer
=	O
elf64_r_sym	function
;	O
}	O
else	O
{	O
init_table	struct
.	O
r_info	array
=	O
elf32_r_info	function
;	O
init_table	struct
.	O
r_sym	pointer
=	O
elf32_r_sym	function
;	O
}	O
return	O
_bfd_x86_elf_link_setup_gnu_properties	function
(	O
info	pointer
,	O
&	O
init_table	struct
)	O
;	O
}	O
static	O
const	O
struct	O
bfd_elf_special_section	struct
elf_x86_64_special_sections	array
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.linkonce.lb"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_NOBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
+	O
SHF_X86_64_LARGE	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.linkonce.lr"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_X86_64_LARGE	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".gnu.linkonce.lt"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_EXECINSTR	O
+	O
SHF_X86_64_LARGE	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".lbss"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_NOBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
+	O
SHF_X86_64_LARGE	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".ldata"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_WRITE	O
+	O
SHF_X86_64_LARGE	int
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
".lrodata"	pointer
)	O
,	O
-	O
2	int
,	O
SHT_PROGBITS	int
,	O
SHF_ALLOC	O
+	O
SHF_X86_64_LARGE	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_backend_data	struct
elf_x86_64_solaris_arch_bed	struct
=	O
{	O
is_solaris	int
}	O
;	O
static	O
bfd_boolean	int
elf64_x86_64_copy_solaris_special_section_fields	function
(	O
const	O
bfd	struct
*	O
ibfd	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
obfd	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
Elf_Internal_Shdr	struct
*	O
isection	pointer
ATTRIBUTE_UNUSED	O
,	O
Elf_Internal_Shdr	struct
*	O
osection	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
elf64_x86_64_nacl_elf_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
bfd_arch_i386	int
,	O
bfd_mach_x86_64_nacl	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
bfd_byte	char
elf_x86_64_nacl_plt0_entry	array
[	O
NACL_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0x35	int
,	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x4c	int
,	O
0x8b	int
,	O
0x1d	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x41	int
,	O
0x83	int
,	O
0xe3	int
,	O
NACLMASK	int
,	O
0x4d	int
,	O
0x01	int
,	O
0xfb	int
,	O
0x41	int
,	O
0xff	int
,	O
0xe3	int
,	O
0x66	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x84	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x2e	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x84	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x2e	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x84	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_nacl_plt_entry	array
[	O
NACL_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0x4c	int
,	O
0x8b	int
,	O
0x1d	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x41	int
,	O
0x83	int
,	O
0xe3	int
,	O
NACLMASK	int
,	O
0x4d	int
,	O
0x01	int
,	O
0xfb	int
,	O
0x41	int
,	O
0xff	int
,	O
0xe3	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x2e	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x84	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x66	int
,	O
0x2e	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x84	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x80	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
}	O
;	O
static	O
const	O
bfd_byte	char
elf_x86_64_nacl_eh_frame_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x78	int
,	O
16	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
7	int
,	O
8	int
,	O
DW_CFA_offset	int
+	O
16	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_def_cfa_offset	int
,	O
16	int
,	O
DW_CFA_advance_loc	int
+	O
6	int
,	O
DW_CFA_def_cfa_offset	int
,	O
24	int
,	O
DW_CFA_advance_loc	int
+	O
58	int
,	O
DW_CFA_def_cfa_expression	int
,	O
13	int
,	O
DW_OP_breg7	int
,	O
8	int
,	O
DW_OP_breg16	int
,	O
0	int
,	O
DW_OP_const1u	int
,	O
63	int
,	O
DW_OP_and	int
,	O
DW_OP_const1u	int
,	O
37	int
,	O
DW_OP_ge	int
,	O
DW_OP_lit3	int
,	O
DW_OP_shl	int
,	O
DW_OP_plus	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_x86_64_nacl_plt	struct
=	O
{	O
elf_x86_64_nacl_plt0_entry	array
,	O
NACL_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_nacl_plt_entry	array
,	O
NACL_PLT_ENTRY_SIZE	int
,	O
elf_x86_64_nacl_plt0_entry	array
,	O
NACL_PLT_ENTRY_SIZE	int
,	O
2	int
,	O
9	int
,	O
6	int
,	O
13	int
,	O
2	int
,	O
9	int
,	O
13	int
,	O
3	int
,	O
33	int
,	O
38	int
,	O
7	int
,	O
42	int
,	O
32	int
,	O
elf_x86_64_nacl_plt0_entry	array
,	O
elf_x86_64_nacl_plt_entry	array
,	O
elf_x86_64_nacl_eh_frame_plt	array
,	O
sizeof	O
(	O
elf_x86_64_nacl_eh_frame_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_backend_data	struct
elf_x86_64_nacl_arch_bed	struct
=	O
{	O
is_nacl	int
}	O
;	O
static	O
bfd_boolean	int
elf32_x86_64_nacl_elf_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
bfd_arch_i386	int
,	O
bfd_mach_x64_32_nacl	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf64_l1om_elf_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
bfd_arch_l1om	int
,	O
bfd_mach_l1om	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf64_k1om_elf_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
bfd_arch_k1om	int
,	O
bfd_mach_k1om	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
