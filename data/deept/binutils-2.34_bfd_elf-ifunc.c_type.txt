bfd_boolean	int
_bfd_elf_create_ifunc_sections	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
flagword	int
flags	int
,	O
pltflags	int
;	O
asection	struct
*	O
s	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
irelifunc	pointer
!=	O
NULL	O
||	O
htab	struct
->	O
iplt	pointer
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
flags	int
=	O
bed	pointer
->	O
dynamic_sec_flags	int
;	O
pltflags	int
=	O
flags	int
;	O
if	O
(	O
bed	pointer
->	O
plt_not_loaded	int
)	O
pltflags	int
&=	O
~	O
(	O
SEC_CODE	int
|	O
SEC_LOAD	int
|	O
SEC_HAS_CONTENTS	int
)	O
;	O
else	O
pltflags	int
|=	O
SEC_ALLOC	int
|	O
SEC_CODE	int
|	O
SEC_LOAD	int
;	O
if	O
(	O
bed	pointer
->	O
plt_readonly	int
)	O
pltflags	int
|=	O
SEC_READONLY	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
const	O
char	O
*	O
rel_sec	pointer
=	O
(	O
bed	pointer
->	O
rela_plts_and_copies_p	int
?	O
".rela.ifunc"	pointer
:	O
".rel.ifunc"	pointer
)	O
;	O
s	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
rel_sec	pointer
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
irelifunc	pointer
=	O
s	pointer
;	O
}	O
else	O
{	O
s	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
".iplt"	pointer
,	O
pltflags	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
plt_alignment	int
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
iplt	pointer
=	O
s	pointer
;	O
s	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
(	O
bed	pointer
->	O
rela_plts_and_copies_p	int
?	O
".rela.iplt"	pointer
:	O
".rel.iplt"	pointer
)	O
,	O
flags	int
|	O
SEC_READONLY	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
irelplt	pointer
=	O
s	pointer
;	O
if	O
(	O
bed	pointer
->	O
want_got_plt	int
)	O
s	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
".igot.plt"	pointer
,	O
flags	int
)	O
;	O
else	O
s	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
".igot"	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
htab	struct
->	O
igotplt	pointer
=	O
s	pointer
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_allocate_ifunc_dyn_relocs	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
head	pointer
,	O
bfd_boolean	int
*	O
readonly_dynrelocs_against_ifunc_p	pointer
,	O
unsigned	O
int	O
plt_entry_size	int
,	O
unsigned	O
int	O
plt_header_size	int
,	O
unsigned	O
int	O
got_entry_size	int
,	O
bfd_boolean	int
avoid_plt	int
)	O
{	O
asection	struct
*	O
plt	union
,	O
*	O
gotplt	pointer
,	O
*	O
relplt	pointer
;	O
struct	O
elf_dyn_relocs	struct
*	O
p	pointer
;	O
unsigned	O
int	O
sizeof_reloc	int
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
bfd_boolean	int
readonly_dynrelocs_against_ifunc	int
;	O
bfd_boolean	int
use_plt	int
=	O
!	O
avoid_plt	int
||	O
h	pointer
->	O
plt	union
.	O
refcount	int
>	O
0	int
;	O
bfd_boolean	int
need_dynreloc	int
=	O
!	O
use_plt	int
||	O
bfd_link_pic	O
(	O
info	pointer
)	O
;	O
if	O
(	O
!	O
need_dynreloc	int
&&	O
!	O
(	O
bfd_link_pde	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
def_regular	int
)	O
&&	O
(	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
||	O
info	pointer
->	O
export_dynamic	int
)	O
&&	O
h	pointer
->	O
pointer_equality_needed	int
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
(	O
_	O
(	O
"%F%P: dynamic STT_GNU_IFUNC symbol `%s' with pointer "	pointer
"equality in `%pB' can not be used when making an "	pointer
"executable; recompile with -fPIE and relink with -pie\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
need_dynreloc	int
&&	O
h	pointer
->	O
ref_regular	int
)	O
{	O
bfd_boolean	int
keep	int
=	O
FALSE	int
;	O
for	O
(	O
p	pointer
=	O
*	O
head	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
count	int
)	O
{	O
h	pointer
->	O
non_got_ref	int
=	O
1	int
;	O
keep	int
=	O
TRUE	int
;	O
if	O
(	O
p	pointer
->	O
pc_count	long
)	O
{	O
use_plt	int
=	O
TRUE	int
;	O
need_dynreloc	int
=	O
bfd_link_pic	O
(	O
info	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
keep	int
)	O
goto	O
keep	int
;	O
}	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
refcount	int
<=	O
0	int
&&	O
h	pointer
->	O
got	union
.	O
refcount	int
<=	O
0	int
)	O
{	O
h	pointer
->	O
got	union
=	O
htab	struct
->	O
init_got_offset	union
;	O
h	pointer
->	O
plt	union
=	O
htab	struct
->	O
init_plt_offset	union
;	O
*	O
head	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
h	pointer
->	O
ref_regular	int
)	O
{	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
refcount	int
>	O
0	int
||	O
h	pointer
->	O
got	union
.	O
refcount	int
>	O
0	int
)	O
abort	function
(	O
)	O
;	O
h	pointer
->	O
got	union
=	O
htab	struct
->	O
init_got_offset	union
;	O
h	pointer
->	O
plt	union
=	O
htab	struct
->	O
init_plt_offset	union
;	O
*	O
head	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
keep	int
:	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
if	O
(	O
bed	pointer
->	O
rela_plts_and_copies_p	int
)	O
sizeof_reloc	int
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rela	char
;	O
else	O
sizeof_reloc	int
=	O
bed	pointer
->	O
s	pointer
->	O
sizeof_rel	char
;	O
if	O
(	O
htab	struct
->	O
splt	pointer
!=	O
NULL	O
)	O
{	O
plt	union
=	O
htab	struct
->	O
splt	pointer
;	O
gotplt	pointer
=	O
htab	struct
->	O
sgotplt	pointer
;	O
relplt	pointer
=	O
htab	struct
->	O
srelplt	pointer
;	O
if	O
(	O
plt	union
->	O
size	long
==	O
0	int
&&	O
use_plt	int
)	O
plt	union
->	O
size	long
+=	O
plt_header_size	int
;	O
}	O
else	O
{	O
plt	union
=	O
htab	struct
->	O
iplt	pointer
;	O
gotplt	pointer
=	O
htab	struct
->	O
igotplt	pointer
;	O
relplt	pointer
=	O
htab	struct
->	O
irelplt	pointer
;	O
}	O
if	O
(	O
use_plt	int
)	O
{	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
plt	union
->	O
size	long
;	O
plt	union
->	O
size	long
+=	O
plt_entry_size	int
;	O
gotplt	pointer
->	O
size	long
+=	O
got_entry_size	int
;	O
}	O
if	O
(	O
use_plt	int
)	O
{	O
relplt	pointer
->	O
size	long
+=	O
sizeof_reloc	int
;	O
relplt	pointer
->	O
reloc_count	int
++	O
;	O
}	O
if	O
(	O
!	O
need_dynreloc	int
||	O
!	O
h	pointer
->	O
non_got_ref	int
)	O
*	O
head	pointer
=	O
NULL	O
;	O
readonly_dynrelocs_against_ifunc	int
=	O
FALSE	int
;	O
p	pointer
=	O
*	O
head	pointer
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
bfd_size_type	long
count	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
!	O
readonly_dynrelocs_against_ifunc	int
)	O
{	O
asection	struct
*	O
s	pointer
=	O
p	pointer
->	O
sec	pointer
->	O
output_section	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
s	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
!=	O
0	int
)	O
readonly_dynrelocs_against_ifunc	int
=	O
TRUE	int
;	O
}	O
count	int
+=	O
p	pointer
->	O
count	int
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
p	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
htab	struct
->	O
irelifunc	pointer
->	O
size	long
+=	O
count	int
*	O
sizeof_reloc	int
;	O
else	O
if	O
(	O
htab	struct
->	O
splt	pointer
!=	O
NULL	O
)	O
htab	struct
->	O
srelgot	pointer
->	O
size	long
+=	O
count	int
*	O
sizeof_reloc	int
;	O
else	O
{	O
relplt	pointer
->	O
size	long
+=	O
count	int
*	O
sizeof_reloc	int
;	O
relplt	pointer
->	O
reloc_count	int
+=	O
count	int
;	O
}	O
}	O
if	O
(	O
readonly_dynrelocs_against_ifunc_p	pointer
)	O
*	O
readonly_dynrelocs_against_ifunc_p	pointer
=	O
readonly_dynrelocs_against_ifunc	int
;	O
if	O
(	O
use_plt	int
&&	O
(	O
h	pointer
->	O
got	union
.	O
refcount	int
<=	O
0	int
||	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
||	O
h	pointer
->	O
forced_local	int
)	O
)	O
||	O
(	O
!	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
!	O
h	pointer
->	O
pointer_equality_needed	int
)	O
||	O
bfd_link_pie	O
(	O
info	pointer
)	O
||	O
htab	struct
->	O
sgot	pointer
==	O
NULL	O
)	O
)	O
{	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
use_plt	int
)	O
{	O
h	pointer
->	O
plt	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
if	O
(	O
h	pointer
->	O
got	union
.	O
refcount	int
<=	O
0	int
)	O
{	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
else	O
{	O
h	pointer
->	O
got	union
.	O
offset	long
=	O
htab	struct
->	O
sgot	pointer
->	O
size	long
;	O
htab	struct
->	O
sgot	pointer
->	O
size	long
+=	O
got_entry_size	int
;	O
if	O
(	O
need_dynreloc	int
)	O
{	O
if	O
(	O
htab	struct
->	O
splt	pointer
!=	O
NULL	O
)	O
htab	struct
->	O
srelgot	pointer
->	O
size	long
+=	O
sizeof_reloc	int
;	O
else	O
{	O
relplt	pointer
->	O
size	long
+=	O
sizeof_reloc	int
;	O
relplt	pointer
->	O
reloc_count	int
++	O
;	O
}	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
