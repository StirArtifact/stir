struct	O
debug_handle	struct
{	O
struct	O
debug_unit	struct
*	O
units	pointer
;	O
struct	O
debug_unit	struct
*	O
current_unit	pointer
;	O
struct	O
debug_file	struct
*	O
current_file	pointer
;	O
struct	O
debug_function	struct
*	O
current_function	pointer
;	O
struct	O
debug_block	struct
*	O
current_block	pointer
;	O
struct	O
debug_lineno	struct
*	O
current_lineno	pointer
;	O
unsigned	O
int	O
mark	int
;	O
unsigned	O
int	O
class_id	int
;	O
unsigned	O
int	O
base_id	int
;	O
struct	O
debug_lineno	struct
*	O
current_write_lineno	pointer
;	O
unsigned	O
int	O
current_write_lineno_index	int
;	O
struct	O
debug_class_id	struct
*	O
id_list	pointer
;	O
struct	O
debug_type_compare_list	struct
*	O
compare_list	pointer
;	O
}	O
;	O
struct	O
debug_unit	struct
{	O
struct	O
debug_unit	struct
*	O
next	pointer
;	O
struct	O
debug_file	struct
*	O
files	pointer
;	O
struct	O
debug_lineno	struct
*	O
linenos	pointer
;	O
}	O
;	O
struct	O
debug_file	struct
{	O
struct	O
debug_file	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
struct	O
debug_namespace	struct
*	O
globals	pointer
;	O
}	O
;	O
struct	O
debug_type_s	struct
{	O
enum	O
debug_type_kind	enum
kind	enum
;	O
unsigned	O
int	O
size	int
;	O
debug_type	pointer
pointer	pointer
;	O
union	O
{	O
struct	O
debug_indirect_type	struct
*	O
kindirect	pointer
;	O
bfd_boolean	int
kint	int
;	O
struct	O
debug_class_type	struct
*	O
kclass	pointer
;	O
struct	O
debug_enum_type	struct
*	O
kenum	pointer
;	O
struct	O
debug_type_s	struct
*	O
kpointer	pointer
;	O
struct	O
debug_function_type	struct
*	O
kfunction	pointer
;	O
struct	O
debug_type_s	struct
*	O
kreference	pointer
;	O
struct	O
debug_range_type	struct
*	O
krange	pointer
;	O
struct	O
debug_array_type	struct
*	O
karray	pointer
;	O
struct	O
debug_set_type	struct
*	O
kset	pointer
;	O
struct	O
debug_offset_type	struct
*	O
koffset	pointer
;	O
struct	O
debug_method_type	struct
*	O
kmethod	pointer
;	O
struct	O
debug_type_s	struct
*	O
kconst	pointer
;	O
struct	O
debug_type_s	struct
*	O
kvolatile	pointer
;	O
struct	O
debug_named_type	struct
*	O
knamed	pointer
;	O
}	O
u	union
;	O
}	O
;	O
struct	O
debug_indirect_type	struct
{	O
debug_type	pointer
*	O
slot	pointer
;	O
const	O
char	O
*	O
tag	pointer
;	O
}	O
;	O
struct	O
debug_class_type	struct
{	O
debug_field	pointer
*	O
fields	pointer
;	O
unsigned	O
int	O
mark	int
;	O
unsigned	O
int	O
id	int
;	O
debug_baseclass	pointer
*	O
baseclasses	pointer
;	O
debug_method	pointer
*	O
methods	pointer
;	O
debug_type	pointer
vptrbase	pointer
;	O
}	O
;	O
struct	O
debug_enum_type	struct
{	O
const	O
char	O
*	O
*	O
names	pointer
;	O
bfd_signed_vma	long
*	O
values	pointer
;	O
}	O
;	O
struct	O
debug_function_type	struct
{	O
debug_type	pointer
return_type	pointer
;	O
debug_type	pointer
*	O
arg_types	pointer
;	O
bfd_boolean	int
varargs	int
;	O
}	O
;	O
struct	O
debug_range_type	struct
{	O
debug_type	pointer
type	enum
;	O
bfd_signed_vma	long
lower	long
;	O
bfd_signed_vma	long
upper	long
;	O
}	O
;	O
struct	O
debug_array_type	struct
{	O
debug_type	pointer
element_type	pointer
;	O
debug_type	pointer
range_type	pointer
;	O
bfd_signed_vma	long
lower	long
;	O
bfd_signed_vma	long
upper	long
;	O
bfd_boolean	int
stringp	int
;	O
}	O
;	O
struct	O
debug_set_type	struct
{	O
debug_type	pointer
type	enum
;	O
bfd_boolean	int
bitstringp	int
;	O
}	O
;	O
struct	O
debug_offset_type	struct
{	O
debug_type	pointer
base_type	pointer
;	O
debug_type	pointer
target_type	pointer
;	O
}	O
;	O
struct	O
debug_method_type	struct
{	O
debug_type	pointer
return_type	pointer
;	O
debug_type	pointer
domain_type	pointer
;	O
debug_type	pointer
*	O
arg_types	pointer
;	O
bfd_boolean	int
varargs	int
;	O
}	O
;	O
struct	O
debug_named_type	struct
{	O
struct	O
debug_name	struct
*	O
name	pointer
;	O
debug_type	pointer
type	enum
;	O
}	O
;	O
struct	O
debug_field_s	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
struct	O
debug_type_s	struct
*	O
type	enum
;	O
enum	O
debug_visibility	enum
visibility	enum
;	O
bfd_boolean	int
static_member	int
;	O
union	O
{	O
struct	O
{	O
unsigned	O
int	O
bitpos	int
;	O
unsigned	O
int	O
bitsize	int
;	O
}	O
f	struct
;	O
struct	O
{	O
const	O
char	O
*	O
physname	pointer
;	O
}	O
s	pointer
;	O
}	O
u	union
;	O
}	O
;	O
struct	O
debug_baseclass_s	struct
{	O
struct	O
debug_type_s	struct
*	O
type	enum
;	O
unsigned	O
int	O
bitpos	int
;	O
bfd_boolean	int
is_virtual	int
;	O
enum	O
debug_visibility	enum
visibility	enum
;	O
}	O
;	O
struct	O
debug_method_s	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
struct	O
debug_method_variant_s	struct
*	O
*	O
variants	pointer
;	O
}	O
;	O
struct	O
debug_method_variant_s	struct
{	O
const	O
char	O
*	O
physname	pointer
;	O
struct	O
debug_type_s	struct
*	O
type	enum
;	O
enum	O
debug_visibility	enum
visibility	enum
;	O
bfd_boolean	int
constp	int
;	O
bfd_boolean	int
volatilep	int
;	O
bfd_vma	long
voffset	long
;	O
struct	O
debug_type_s	struct
*	O
context	pointer
;	O
}	O
;	O
struct	O
debug_variable	struct
{	O
enum	O
debug_var_kind	enum
kind	enum
;	O
debug_type	pointer
type	enum
;	O
bfd_vma	long
val	array
;	O
}	O
;	O
struct	O
debug_function	struct
{	O
debug_type	pointer
return_type	pointer
;	O
struct	O
debug_parameter	struct
*	O
parameters	pointer
;	O
struct	O
debug_block	struct
*	O
blocks	pointer
;	O
}	O
;	O
struct	O
debug_parameter	struct
{	O
struct	O
debug_parameter	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
debug_type	pointer
type	enum
;	O
enum	O
debug_parm_kind	enum
kind	enum
;	O
bfd_vma	long
val	array
;	O
}	O
;	O
struct	O
debug_typed_constant	struct
{	O
debug_type	pointer
type	enum
;	O
bfd_vma	long
val	array
;	O
}	O
;	O
struct	O
debug_block	struct
{	O
struct	O
debug_block	struct
*	O
next	pointer
;	O
struct	O
debug_block	struct
*	O
parent	pointer
;	O
struct	O
debug_block	struct
*	O
children	pointer
;	O
bfd_vma	long
start	long
;	O
bfd_vma	long
end	pointer
;	O
struct	O
debug_namespace	struct
*	O
locals	pointer
;	O
}	O
;	O
struct	O
debug_lineno	struct
{	O
struct	O
debug_lineno	struct
*	O
next	pointer
;	O
struct	O
debug_file	struct
*	O
file	pointer
;	O
unsigned	O
long	O
linenos	pointer
[	O
DEBUG_LINENO_COUNT	int
]	O
;	O
bfd_vma	long
addrs	array
[	O
DEBUG_LINENO_COUNT	int
]	O
;	O
}	O
;	O
struct	O
debug_namespace	struct
{	O
struct	O
debug_name	struct
*	O
list	pointer
;	O
struct	O
debug_name	struct
*	O
*	O
tail	pointer
;	O
}	O
;	O
enum	O
debug_object_kind	enum
{	O
DEBUG_OBJECT_TYPE	int
,	O
DEBUG_OBJECT_TAG	int
,	O
DEBUG_OBJECT_VARIABLE	int
,	O
DEBUG_OBJECT_FUNCTION	int
,	O
DEBUG_OBJECT_INT_CONSTANT	int
,	O
DEBUG_OBJECT_FLOAT_CONSTANT	int
,	O
DEBUG_OBJECT_TYPED_CONSTANT	int
}	O
;	O
enum	O
debug_object_linkage	enum
{	O
DEBUG_LINKAGE_AUTOMATIC	int
,	O
DEBUG_LINKAGE_STATIC	int
,	O
DEBUG_LINKAGE_GLOBAL	int
,	O
DEBUG_LINKAGE_NONE	int
}	O
;	O
struct	O
debug_name	struct
{	O
struct	O
debug_name	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
mark	int
;	O
enum	O
debug_object_kind	enum
kind	enum
;	O
enum	O
debug_object_linkage	enum
linkage	enum
;	O
union	O
{	O
struct	O
debug_type_s	struct
*	O
type	enum
;	O
struct	O
debug_type_s	struct
*	O
tag	pointer
;	O
struct	O
debug_variable	struct
*	O
variable	pointer
;	O
struct	O
debug_function	struct
*	O
function	pointer
;	O
bfd_vma	long
int_constant	pointer
;	O
double	O
float_constant	pointer
;	O
struct	O
debug_typed_constant	struct
*	O
typed_constant	pointer
;	O
}	O
u	union
;	O
}	O
;	O
struct	O
debug_class_id	struct
{	O
struct	O
debug_class_id	struct
*	O
next	pointer
;	O
struct	O
debug_type_s	struct
*	O
type	enum
;	O
const	O
char	O
*	O
tag	pointer
;	O
}	O
;	O
struct	O
debug_type_compare_list	struct
{	O
struct	O
debug_type_compare_list	struct
*	O
next	pointer
;	O
struct	O
debug_type_s	struct
*	O
t1	pointer
;	O
struct	O
debug_type_s	struct
*	O
t2	pointer
;	O
}	O
;	O
struct	O
debug_type_real_list	struct
{	O
struct	O
debug_type_real_list	struct
*	O
next	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
}	O
;	O
static	O
void	O
debug_error	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
struct	O
debug_name	struct
*	O
debug_add_to_namespace	function
(	O
struct	O
debug_handle	struct
*	O
,	O
struct	O
debug_namespace	struct
*	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_object_kind	enum
,	O
enum	O
debug_object_linkage	enum
)	O
;	O
static	O
struct	O
debug_name	struct
*	O
debug_add_to_current_namespace	function
(	O
struct	O
debug_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_object_kind	enum
,	O
enum	O
debug_object_linkage	enum
)	O
;	O
static	O
struct	O
debug_type_s	struct
*	O
debug_make_type	function
(	O
struct	O
debug_handle	struct
*	O
,	O
enum	O
debug_type_kind	enum
,	O
unsigned	O
int	O
)	O
;	O
static	O
struct	O
debug_type_s	struct
*	O
debug_get_real_type	function
(	O
void	O
*	O
,	O
debug_type	pointer
,	O
struct	O
debug_type_real_list	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_name	function
(	O
struct	O
debug_handle	struct
*	O
,	O
const	O
struct	O
debug_write_fns	struct
*	O
,	O
void	O
*	O
,	O
struct	O
debug_name	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_type	function
(	O
struct	O
debug_handle	struct
*	O
,	O
const	O
struct	O
debug_write_fns	struct
*	O
,	O
void	O
*	O
,	O
struct	O
debug_type_s	struct
*	O
,	O
struct	O
debug_name	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_class_type	function
(	O
struct	O
debug_handle	struct
*	O
,	O
const	O
struct	O
debug_write_fns	struct
*	O
,	O
void	O
*	O
,	O
struct	O
debug_type_s	struct
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_function	function
(	O
struct	O
debug_handle	struct
*	O
,	O
const	O
struct	O
debug_write_fns	struct
*	O
,	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_object_linkage	enum
,	O
struct	O
debug_function	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_block	function
(	O
struct	O
debug_handle	struct
*	O
,	O
const	O
struct	O
debug_write_fns	struct
*	O
,	O
void	O
*	O
,	O
struct	O
debug_block	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_write_linenos	function
(	O
struct	O
debug_handle	struct
*	O
,	O
const	O
struct	O
debug_write_fns	struct
*	O
,	O
void	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
debug_set_class_id	function
(	O
struct	O
debug_handle	struct
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
debug_type_s	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_type_samep	function
(	O
struct	O
debug_handle	struct
*	O
,	O
struct	O
debug_type_s	struct
*	O
,	O
struct	O
debug_type_s	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
debug_class_type_samep	function
(	O
struct	O
debug_handle	struct
*	O
,	O
struct	O
debug_type_s	struct
*	O
,	O
struct	O
debug_type_s	struct
*	O
)	O
;	O
static	O
void	O
debug_error	function
(	O
const	O
char	O
*	O
message	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
message	pointer
)	O
;	O
}	O
static	O
struct	O
debug_name	struct
*	O
debug_add_to_namespace	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
debug_namespace	struct
*	O
*	O
nsp	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
enum	O
debug_object_kind	enum
kind	enum
,	O
enum	O
debug_object_linkage	enum
linkage	enum
)	O
{	O
struct	O
debug_name	struct
*	O
n	long
;	O
struct	O
debug_namespace	struct
*	O
ns	pointer
;	O
n	long
=	O
(	O
struct	O
debug_name	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
n	long
)	O
;	O
memset	function
(	O
n	long
,	O
0	int
,	O
sizeof	O
*	O
n	long
)	O
;	O
n	long
->	O
name	pointer
=	O
name	pointer
;	O
n	long
->	O
kind	enum
=	O
kind	enum
;	O
n	long
->	O
linkage	enum
=	O
linkage	enum
;	O
ns	pointer
=	O
*	O
nsp	pointer
;	O
if	O
(	O
ns	pointer
==	O
NULL	O
)	O
{	O
ns	pointer
=	O
(	O
struct	O
debug_namespace	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
ns	pointer
)	O
;	O
memset	function
(	O
ns	pointer
,	O
0	int
,	O
sizeof	O
*	O
ns	pointer
)	O
;	O
ns	pointer
->	O
tail	pointer
=	O
&	O
ns	pointer
->	O
list	pointer
;	O
*	O
nsp	pointer
=	O
ns	pointer
;	O
}	O
*	O
ns	pointer
->	O
tail	pointer
=	O
n	long
;	O
ns	pointer
->	O
tail	pointer
=	O
&	O
n	long
->	O
next	pointer
;	O
return	O
n	long
;	O
}	O
static	O
struct	O
debug_name	struct
*	O
debug_add_to_current_namespace	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
enum	O
debug_object_kind	enum
kind	enum
,	O
enum	O
debug_object_linkage	enum
linkage	enum
)	O
{	O
struct	O
debug_namespace	struct
*	O
*	O
nsp	pointer
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
||	O
info	pointer
->	O
current_file	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_add_to_current_namespace: no current file"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
info	pointer
->	O
current_block	pointer
!=	O
NULL	O
)	O
nsp	pointer
=	O
&	O
info	pointer
->	O
current_block	pointer
->	O
locals	pointer
;	O
else	O
nsp	pointer
=	O
&	O
info	pointer
->	O
current_file	pointer
->	O
globals	pointer
;	O
return	O
debug_add_to_namespace	function
(	O
info	pointer
,	O
nsp	pointer
,	O
name	pointer
,	O
kind	enum
,	O
linkage	enum
)	O
;	O
}	O
void	O
*	O
debug_init	function
(	O
void	O
)	O
{	O
struct	O
debug_handle	struct
*	O
ret	pointer
;	O
ret	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
ret	pointer
)	O
;	O
memset	function
(	O
ret	pointer
,	O
0	int
,	O
sizeof	O
*	O
ret	pointer
)	O
;	O
return	O
(	O
void	O
*	O
)	O
ret	pointer
;	O
}	O
bfd_boolean	int
debug_set_filename	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_file	struct
*	O
nfile	pointer
;	O
struct	O
debug_unit	struct
*	O
nunit	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
name	pointer
=	O
""	pointer
;	O
nfile	pointer
=	O
(	O
struct	O
debug_file	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
nfile	pointer
)	O
;	O
memset	function
(	O
nfile	pointer
,	O
0	int
,	O
sizeof	O
*	O
nfile	pointer
)	O
;	O
nfile	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
nunit	pointer
=	O
(	O
struct	O
debug_unit	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
nunit	pointer
)	O
;	O
memset	function
(	O
nunit	pointer
,	O
0	int
,	O
sizeof	O
*	O
nunit	pointer
)	O
;	O
nunit	pointer
->	O
files	pointer
=	O
nfile	pointer
;	O
info	pointer
->	O
current_file	pointer
=	O
nfile	pointer
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
!=	O
NULL	O
)	O
info	pointer
->	O
current_unit	pointer
->	O
next	pointer
=	O
nunit	pointer
;	O
else	O
{	O
assert	O
(	O
info	pointer
->	O
units	pointer
==	O
NULL	O
)	O
;	O
info	pointer
->	O
units	pointer
=	O
nunit	pointer
;	O
}	O
info	pointer
->	O
current_unit	pointer
=	O
nunit	pointer
;	O
info	pointer
->	O
current_function	pointer
=	O
NULL	O
;	O
info	pointer
->	O
current_block	pointer
=	O
NULL	O
;	O
info	pointer
->	O
current_lineno	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_start_source	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_file	struct
*	O
f	struct
,	O
*	O
*	O
pf	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
name	pointer
=	O
""	pointer
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_start_source: no debug_set_filename call"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
f	struct
=	O
info	pointer
->	O
current_unit	pointer
->	O
files	pointer
;	O
f	struct
!=	O
NULL	O
;	O
f	struct
=	O
f	struct
->	O
next	pointer
)	O
{	O
if	O
(	O
filename_cmp	function
(	O
f	struct
->	O
filename	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
info	pointer
->	O
current_file	pointer
=	O
f	struct
;	O
return	O
TRUE	int
;	O
}	O
}	O
f	struct
=	O
(	O
struct	O
debug_file	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
f	struct
)	O
;	O
memset	function
(	O
f	struct
,	O
0	int
,	O
sizeof	O
*	O
f	struct
)	O
;	O
f	struct
->	O
filename	pointer
=	O
name	pointer
;	O
for	O
(	O
pf	pointer
=	O
&	O
info	pointer
->	O
current_file	pointer
->	O
next	pointer
;	O
*	O
pf	pointer
!=	O
NULL	O
;	O
pf	pointer
=	O
&	O
(	O
*	O
pf	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pf	pointer
=	O
f	struct
;	O
info	pointer
->	O
current_file	pointer
=	O
f	struct
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_function	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
return_type	pointer
,	O
bfd_boolean	int
global	int
,	O
bfd_vma	long
addr	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_function	struct
*	O
f	struct
;	O
struct	O
debug_block	struct
*	O
b	pointer
;	O
struct	O
debug_name	struct
*	O
n	long
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
name	pointer
=	O
""	pointer
;	O
if	O
(	O
return_type	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_record_function: no debug_set_filename call"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
f	struct
=	O
(	O
struct	O
debug_function	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
f	struct
)	O
;	O
memset	function
(	O
f	struct
,	O
0	int
,	O
sizeof	O
*	O
f	struct
)	O
;	O
f	struct
->	O
return_type	pointer
=	O
return_type	pointer
;	O
b	pointer
=	O
(	O
struct	O
debug_block	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
b	pointer
)	O
;	O
memset	function
(	O
b	pointer
,	O
0	int
,	O
sizeof	O
*	O
b	pointer
)	O
;	O
b	pointer
->	O
start	long
=	O
addr	pointer
;	O
b	pointer
->	O
end	pointer
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
f	struct
->	O
blocks	pointer
=	O
b	pointer
;	O
info	pointer
->	O
current_function	pointer
=	O
f	struct
;	O
info	pointer
->	O
current_block	pointer
=	O
b	pointer
;	O
n	long
=	O
debug_add_to_namespace	function
(	O
info	pointer
,	O
&	O
info	pointer
->	O
current_file	pointer
->	O
globals	pointer
,	O
name	pointer
,	O
DEBUG_OBJECT_FUNCTION	int
,	O
(	O
global	int
?	O
DEBUG_LINKAGE_GLOBAL	int
:	O
DEBUG_LINKAGE_STATIC	int
)	O
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
n	long
->	O
u	union
.	O
function	pointer
=	O
f	struct
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_parameter	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
type	enum
,	O
enum	O
debug_parm_kind	enum
kind	enum
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_parameter	struct
*	O
p	pointer
,	O
*	O
*	O
pp	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
type	enum
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
||	O
info	pointer
->	O
current_function	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_record_parameter: no current function"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
p	pointer
=	O
(	O
struct	O
debug_parameter	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
p	pointer
)	O
;	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
sizeof	O
*	O
p	pointer
)	O
;	O
p	pointer
->	O
name	pointer
=	O
name	pointer
;	O
p	pointer
->	O
type	enum
=	O
type	enum
;	O
p	pointer
->	O
kind	enum
=	O
kind	enum
;	O
p	pointer
->	O
val	array
=	O
val	array
;	O
for	O
(	O
pp	pointer
=	O
&	O
info	pointer
->	O
current_function	pointer
->	O
parameters	pointer
;	O
*	O
pp	pointer
!=	O
NULL	O
;	O
pp	pointer
=	O
&	O
(	O
*	O
pp	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_end_function	function
(	O
void	O
*	O
handle	pointer
,	O
bfd_vma	long
addr	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
||	O
info	pointer
->	O
current_block	pointer
==	O
NULL	O
||	O
info	pointer
->	O
current_function	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_end_function: no current function"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
info	pointer
->	O
current_block	pointer
->	O
parent	pointer
!=	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_end_function: some blocks were not closed"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
info	pointer
->	O
current_block	pointer
->	O
end	pointer
=	O
addr	pointer
;	O
info	pointer
->	O
current_function	pointer
=	O
NULL	O
;	O
info	pointer
->	O
current_block	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_start_block	function
(	O
void	O
*	O
handle	pointer
,	O
bfd_vma	long
addr	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_block	struct
*	O
b	pointer
,	O
*	O
*	O
pb	pointer
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
||	O
info	pointer
->	O
current_block	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_start_block: no current block"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
b	pointer
=	O
(	O
struct	O
debug_block	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
b	pointer
)	O
;	O
memset	function
(	O
b	pointer
,	O
0	int
,	O
sizeof	O
*	O
b	pointer
)	O
;	O
b	pointer
->	O
parent	pointer
=	O
info	pointer
->	O
current_block	pointer
;	O
b	pointer
->	O
start	long
=	O
addr	pointer
;	O
b	pointer
->	O
end	pointer
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
for	O
(	O
pb	pointer
=	O
&	O
info	pointer
->	O
current_block	pointer
->	O
children	pointer
;	O
*	O
pb	pointer
!=	O
NULL	O
;	O
pb	pointer
=	O
&	O
(	O
*	O
pb	pointer
)	O
->	O
next	pointer
)	O
;	O
*	O
pb	pointer
=	O
b	pointer
;	O
info	pointer
->	O
current_block	pointer
=	O
b	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_end_block	function
(	O
void	O
*	O
handle	pointer
,	O
bfd_vma	long
addr	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_block	struct
*	O
parent	pointer
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
||	O
info	pointer
->	O
current_block	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_end_block: no current block"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
parent	pointer
=	O
info	pointer
->	O
current_block	pointer
->	O
parent	pointer
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_end_block: attempt to close top level block"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
info	pointer
->	O
current_block	pointer
->	O
end	pointer
=	O
addr	pointer
;	O
info	pointer
->	O
current_block	pointer
=	O
parent	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_line	function
(	O
void	O
*	O
handle	pointer
,	O
unsigned	O
long	O
lineno	pointer
,	O
bfd_vma	long
addr	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_lineno	struct
*	O
l	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_record_line: no current unit"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
l	pointer
=	O
info	pointer
->	O
current_lineno	pointer
;	O
if	O
(	O
l	pointer
!=	O
NULL	O
&&	O
l	pointer
->	O
file	pointer
==	O
info	pointer
->	O
current_file	pointer
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
DEBUG_LINENO_COUNT	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
l	pointer
->	O
linenos	pointer
[	O
i	pointer
]	O
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
{	O
l	pointer
->	O
linenos	pointer
[	O
i	pointer
]	O
=	O
lineno	pointer
;	O
l	pointer
->	O
addrs	array
[	O
i	pointer
]	O
=	O
addr	pointer
;	O
return	O
TRUE	int
;	O
}	O
}	O
}	O
l	pointer
=	O
(	O
struct	O
debug_lineno	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
l	pointer
)	O
;	O
memset	function
(	O
l	pointer
,	O
0	int
,	O
sizeof	O
*	O
l	pointer
)	O
;	O
l	pointer
->	O
file	pointer
=	O
info	pointer
->	O
current_file	pointer
;	O
l	pointer
->	O
linenos	pointer
[	O
0	int
]	O
=	O
lineno	pointer
;	O
l	pointer
->	O
addrs	array
[	O
0	int
]	O
=	O
addr	pointer
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
DEBUG_LINENO_COUNT	int
;	O
i	pointer
++	O
)	O
l	pointer
->	O
linenos	pointer
[	O
i	pointer
]	O
=	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
;	O
if	O
(	O
info	pointer
->	O
current_lineno	pointer
!=	O
NULL	O
)	O
info	pointer
->	O
current_lineno	pointer
->	O
next	pointer
=	O
l	pointer
;	O
else	O
info	pointer
->	O
current_unit	pointer
->	O
linenos	pointer
=	O
l	pointer
;	O
info	pointer
->	O
current_lineno	pointer
=	O
l	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_start_common_block	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_start_common_block: not implemented"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
debug_end_common_block	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_end_common_block: not implemented"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
debug_record_int_const	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_name	struct
*	O
n	long
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
n	long
=	O
debug_add_to_current_namespace	function
(	O
info	pointer
,	O
name	pointer
,	O
DEBUG_OBJECT_INT_CONSTANT	int
,	O
DEBUG_LINKAGE_NONE	int
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
n	long
->	O
u	union
.	O
int_constant	pointer
=	O
val	array
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_float_const	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
double	O
val	array
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_name	struct
*	O
n	long
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
n	long
=	O
debug_add_to_current_namespace	function
(	O
info	pointer
,	O
name	pointer
,	O
DEBUG_OBJECT_FLOAT_CONSTANT	int
,	O
DEBUG_LINKAGE_NONE	int
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
n	long
->	O
u	union
.	O
float_constant	pointer
=	O
val	array
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_typed_const	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
type	enum
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_name	struct
*	O
n	long
;	O
struct	O
debug_typed_constant	struct
*	O
tc	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
type	enum
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
n	long
=	O
debug_add_to_current_namespace	function
(	O
info	pointer
,	O
name	pointer
,	O
DEBUG_OBJECT_TYPED_CONSTANT	int
,	O
DEBUG_LINKAGE_NONE	int
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
tc	pointer
=	O
(	O
struct	O
debug_typed_constant	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
tc	pointer
)	O
;	O
memset	function
(	O
tc	pointer
,	O
0	int
,	O
sizeof	O
*	O
tc	pointer
)	O
;	O
tc	pointer
->	O
type	enum
=	O
type	enum
;	O
tc	pointer
->	O
val	array
=	O
val	array
;	O
n	long
->	O
u	union
.	O
typed_constant	pointer
=	O
tc	pointer
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
debug_record_label	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_type	pointer
type	enum
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
addr	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_record_label: not implemented"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
debug_record_variable	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
type	enum
,	O
enum	O
debug_var_kind	enum
kind	enum
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_namespace	struct
*	O
*	O
nsp	pointer
;	O
enum	O
debug_object_linkage	enum
linkage	enum
;	O
struct	O
debug_name	struct
*	O
n	long
;	O
struct	O
debug_variable	struct
*	O
v	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
type	enum
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
||	O
info	pointer
->	O
current_file	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_record_variable: no current file"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
kind	enum
==	O
DEBUG_GLOBAL	int
||	O
kind	enum
==	O
DEBUG_STATIC	int
)	O
{	O
nsp	pointer
=	O
&	O
info	pointer
->	O
current_file	pointer
->	O
globals	pointer
;	O
if	O
(	O
kind	enum
==	O
DEBUG_GLOBAL	int
)	O
linkage	enum
=	O
DEBUG_LINKAGE_GLOBAL	int
;	O
else	O
linkage	enum
=	O
DEBUG_LINKAGE_STATIC	int
;	O
}	O
else	O
{	O
if	O
(	O
info	pointer
->	O
current_block	pointer
==	O
NULL	O
)	O
nsp	pointer
=	O
&	O
info	pointer
->	O
current_file	pointer
->	O
globals	pointer
;	O
else	O
nsp	pointer
=	O
&	O
info	pointer
->	O
current_block	pointer
->	O
locals	pointer
;	O
linkage	enum
=	O
DEBUG_LINKAGE_AUTOMATIC	int
;	O
}	O
n	long
=	O
debug_add_to_namespace	function
(	O
info	pointer
,	O
nsp	pointer
,	O
name	pointer
,	O
DEBUG_OBJECT_VARIABLE	int
,	O
linkage	enum
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
v	pointer
=	O
(	O
struct	O
debug_variable	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
v	pointer
)	O
;	O
memset	function
(	O
v	pointer
,	O
0	int
,	O
sizeof	O
*	O
v	pointer
)	O
;	O
v	pointer
->	O
kind	enum
=	O
kind	enum
;	O
v	pointer
->	O
type	enum
=	O
type	enum
;	O
v	pointer
->	O
val	array
=	O
val	array
;	O
n	long
->	O
u	union
.	O
variable	pointer
=	O
v	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
struct	O
debug_type_s	struct
*	O
debug_make_type	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
enum	O
debug_type_kind	enum
kind	enum
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
t	pointer
=	O
(	O
struct	O
debug_type_s	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
t	pointer
)	O
;	O
memset	function
(	O
t	pointer
,	O
0	int
,	O
sizeof	O
*	O
t	pointer
)	O
;	O
t	pointer
->	O
kind	enum
=	O
kind	enum
;	O
t	pointer
->	O
size	int
=	O
size	int
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_indirect_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
*	O
slot	pointer
,	O
const	O
char	O
*	O
tag	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_indirect_type	struct
*	O
i	pointer
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_INDIRECT	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
i	pointer
=	O
(	O
struct	O
debug_indirect_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
i	pointer
)	O
;	O
memset	function
(	O
i	pointer
,	O
0	int
,	O
sizeof	O
*	O
i	pointer
)	O
;	O
i	pointer
->	O
slot	pointer
=	O
slot	pointer
;	O
i	pointer
->	O
tag	pointer
=	O
tag	pointer
;	O
t	pointer
->	O
u	union
.	O
kindirect	pointer
=	O
i	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_void_type	function
(	O
void	O
*	O
handle	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
return	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_VOID	int
,	O
0	int
)	O
;	O
}	O
debug_type	pointer
debug_make_int_type	function
(	O
void	O
*	O
handle	pointer
,	O
unsigned	O
int	O
size	int
,	O
bfd_boolean	int
unsignedp	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_INT	int
,	O
size	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
->	O
u	union
.	O
kint	int
=	O
unsignedp	int
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_float_type	function
(	O
void	O
*	O
handle	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
return	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_FLOAT	int
,	O
size	int
)	O
;	O
}	O
debug_type	pointer
debug_make_bool_type	function
(	O
void	O
*	O
handle	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
return	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_BOOL	int
,	O
size	int
)	O
;	O
}	O
debug_type	pointer
debug_make_complex_type	function
(	O
void	O
*	O
handle	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
return	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_COMPLEX	int
,	O
size	int
)	O
;	O
}	O
debug_type	pointer
debug_make_struct_type	function
(	O
void	O
*	O
handle	pointer
,	O
bfd_boolean	int
structp	int
,	O
bfd_vma	long
size	int
,	O
debug_field	pointer
*	O
fields	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_class_type	struct
*	O
c	pointer
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
structp	int
?	O
DEBUG_KIND_STRUCT	int
:	O
DEBUG_KIND_UNION	int
,	O
size	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
c	pointer
=	O
(	O
struct	O
debug_class_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
c	pointer
)	O
;	O
memset	function
(	O
c	pointer
,	O
0	int
,	O
sizeof	O
*	O
c	pointer
)	O
;	O
c	pointer
->	O
fields	pointer
=	O
fields	pointer
;	O
t	pointer
->	O
u	union
.	O
kclass	pointer
=	O
c	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_object_type	function
(	O
void	O
*	O
handle	pointer
,	O
bfd_boolean	int
structp	int
,	O
bfd_vma	long
size	int
,	O
debug_field	pointer
*	O
fields	pointer
,	O
debug_baseclass	pointer
*	O
baseclasses	pointer
,	O
debug_method	pointer
*	O
methods	pointer
,	O
debug_type	pointer
vptrbase	pointer
,	O
bfd_boolean	int
ownvptr	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_class_type	struct
*	O
c	pointer
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
structp	int
?	O
DEBUG_KIND_CLASS	int
:	O
DEBUG_KIND_UNION_CLASS	int
,	O
size	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
c	pointer
=	O
(	O
struct	O
debug_class_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
c	pointer
)	O
;	O
memset	function
(	O
c	pointer
,	O
0	int
,	O
sizeof	O
*	O
c	pointer
)	O
;	O
c	pointer
->	O
fields	pointer
=	O
fields	pointer
;	O
c	pointer
->	O
baseclasses	pointer
=	O
baseclasses	pointer
;	O
c	pointer
->	O
methods	pointer
=	O
methods	pointer
;	O
if	O
(	O
ownvptr	int
)	O
c	pointer
->	O
vptrbase	pointer
=	O
t	pointer
;	O
else	O
c	pointer
->	O
vptrbase	pointer
=	O
vptrbase	pointer
;	O
t	pointer
->	O
u	union
.	O
kclass	pointer
=	O
c	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_enum_type	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
*	O
names	pointer
,	O
bfd_signed_vma	long
*	O
values	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_enum_type	struct
*	O
e	pointer
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_ENUM	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
e	pointer
=	O
(	O
struct	O
debug_enum_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
e	pointer
)	O
;	O
memset	function
(	O
e	pointer
,	O
0	int
,	O
sizeof	O
*	O
e	pointer
)	O
;	O
e	pointer
->	O
names	pointer
=	O
names	pointer
;	O
e	pointer
->	O
values	pointer
=	O
values	pointer
;	O
t	pointer
->	O
u	union
.	O
kenum	pointer
=	O
e	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_pointer_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
type	enum
->	O
pointer	pointer
!=	O
DEBUG_TYPE_NULL	O
)	O
return	O
type	enum
->	O
pointer	pointer
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_POINTER	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
->	O
u	union
.	O
kpointer	pointer
=	O
type	enum
;	O
type	enum
->	O
pointer	pointer
=	O
t	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_function_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
,	O
debug_type	pointer
*	O
arg_types	pointer
,	O
bfd_boolean	int
varargs	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_function_type	struct
*	O
f	struct
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_FUNCTION	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
f	struct
=	O
(	O
struct	O
debug_function_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
f	struct
)	O
;	O
memset	function
(	O
f	struct
,	O
0	int
,	O
sizeof	O
*	O
f	struct
)	O
;	O
f	struct
->	O
return_type	pointer
=	O
type	enum
;	O
f	struct
->	O
arg_types	pointer
=	O
arg_types	pointer
;	O
f	struct
->	O
varargs	int
=	O
varargs	int
;	O
t	pointer
->	O
u	union
.	O
kfunction	pointer
=	O
f	struct
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_reference_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_REFERENCE	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
->	O
u	union
.	O
kreference	pointer
=	O
type	enum
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_range_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
,	O
bfd_signed_vma	long
lower	long
,	O
bfd_signed_vma	long
upper	long
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_range_type	struct
*	O
r	pointer
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_RANGE	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
r	pointer
=	O
(	O
struct	O
debug_range_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
r	pointer
)	O
;	O
memset	function
(	O
r	pointer
,	O
0	int
,	O
sizeof	O
*	O
r	pointer
)	O
;	O
r	pointer
->	O
type	enum
=	O
type	enum
;	O
r	pointer
->	O
lower	long
=	O
lower	long
;	O
r	pointer
->	O
upper	long
=	O
upper	long
;	O
t	pointer
->	O
u	union
.	O
krange	pointer
=	O
r	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_array_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
element_type	pointer
,	O
debug_type	pointer
range_type	pointer
,	O
bfd_signed_vma	long
lower	long
,	O
bfd_signed_vma	long
upper	long
,	O
bfd_boolean	int
stringp	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_array_type	struct
*	O
a	pointer
;	O
if	O
(	O
element_type	pointer
==	O
NULL	O
||	O
range_type	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_ARRAY	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
a	pointer
=	O
(	O
struct	O
debug_array_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
a	pointer
)	O
;	O
memset	function
(	O
a	pointer
,	O
0	int
,	O
sizeof	O
*	O
a	pointer
)	O
;	O
a	pointer
->	O
element_type	pointer
=	O
element_type	pointer
;	O
a	pointer
->	O
range_type	pointer
=	O
range_type	pointer
;	O
a	pointer
->	O
lower	long
=	O
lower	long
;	O
a	pointer
->	O
upper	long
=	O
upper	long
;	O
a	pointer
->	O
stringp	int
=	O
stringp	int
;	O
t	pointer
->	O
u	union
.	O
karray	pointer
=	O
a	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_set_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
,	O
bfd_boolean	int
bitstringp	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_set_type	struct
*	O
s	pointer
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_SET	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
s	pointer
=	O
(	O
struct	O
debug_set_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
s	pointer
)	O
;	O
memset	function
(	O
s	pointer
,	O
0	int
,	O
sizeof	O
*	O
s	pointer
)	O
;	O
s	pointer
->	O
type	enum
=	O
type	enum
;	O
s	pointer
->	O
bitstringp	int
=	O
bitstringp	int
;	O
t	pointer
->	O
u	union
.	O
kset	pointer
=	O
s	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_offset_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
base_type	pointer
,	O
debug_type	pointer
target_type	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_offset_type	struct
*	O
o	pointer
;	O
if	O
(	O
base_type	pointer
==	O
NULL	O
||	O
target_type	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_OFFSET	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
o	pointer
=	O
(	O
struct	O
debug_offset_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
o	pointer
)	O
;	O
memset	function
(	O
o	pointer
,	O
0	int
,	O
sizeof	O
*	O
o	pointer
)	O
;	O
o	pointer
->	O
base_type	pointer
=	O
base_type	pointer
;	O
o	pointer
->	O
target_type	pointer
=	O
target_type	pointer
;	O
t	pointer
->	O
u	union
.	O
koffset	pointer
=	O
o	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_method_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
return_type	pointer
,	O
debug_type	pointer
domain_type	pointer
,	O
debug_type	pointer
*	O
arg_types	pointer
,	O
bfd_boolean	int
varargs	int
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_method_type	struct
*	O
m	pointer
;	O
if	O
(	O
return_type	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_METHOD	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
m	pointer
=	O
(	O
struct	O
debug_method_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
m	pointer
)	O
;	O
memset	function
(	O
m	pointer
,	O
0	int
,	O
sizeof	O
*	O
m	pointer
)	O
;	O
m	pointer
->	O
return_type	pointer
=	O
return_type	pointer
;	O
m	pointer
->	O
domain_type	pointer
=	O
domain_type	pointer
;	O
m	pointer
->	O
arg_types	pointer
=	O
arg_types	pointer
;	O
m	pointer
->	O
varargs	int
=	O
varargs	int
;	O
t	pointer
->	O
u	union
.	O
kmethod	pointer
=	O
m	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_const_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_CONST	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
->	O
u	union
.	O
kconst	pointer
=	O
type	enum
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_volatile_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_VOLATILE	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
t	pointer
->	O
u	union
.	O
kvolatile	pointer
=	O
type	enum
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_make_undefined_tagged_type	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
enum	O
debug_type_kind	enum
kind	enum
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
switch	O
(	O
kind	enum
)	O
{	O
case	O
DEBUG_KIND_STRUCT	int
:	O
case	O
DEBUG_KIND_UNION	int
:	O
case	O
DEBUG_KIND_CLASS	int
:	O
case	O
DEBUG_KIND_UNION_CLASS	int
:	O
case	O
DEBUG_KIND_ENUM	int
:	O
break	O
;	O
default	O
:	O
debug_error	function
(	O
_	O
(	O
"debug_make_undefined_type: unsupported kind"	pointer
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
kind	enum
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
return	O
debug_tag_type	function
(	O
handle	pointer
,	O
name	pointer
,	O
t	pointer
)	O
;	O
}	O
debug_baseclass	pointer
debug_make_baseclass	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_type	pointer
type	enum
,	O
bfd_vma	long
bitpos	int
,	O
bfd_boolean	int
is_virtual	int
,	O
enum	O
debug_visibility	enum
visibility	enum
)	O
{	O
struct	O
debug_baseclass_s	struct
*	O
b	pointer
;	O
b	pointer
=	O
(	O
struct	O
debug_baseclass_s	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
b	pointer
)	O
;	O
memset	function
(	O
b	pointer
,	O
0	int
,	O
sizeof	O
*	O
b	pointer
)	O
;	O
b	pointer
->	O
type	enum
=	O
type	enum
;	O
b	pointer
->	O
bitpos	int
=	O
bitpos	int
;	O
b	pointer
->	O
is_virtual	int
=	O
is_virtual	int
;	O
b	pointer
->	O
visibility	enum
=	O
visibility	enum
;	O
return	O
b	pointer
;	O
}	O
debug_field	pointer
debug_make_field	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
type	enum
,	O
bfd_vma	long
bitpos	int
,	O
bfd_vma	long
bitsize	int
,	O
enum	O
debug_visibility	enum
visibility	enum
)	O
{	O
struct	O
debug_field_s	struct
*	O
f	struct
;	O
f	struct
=	O
(	O
struct	O
debug_field_s	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
f	struct
)	O
;	O
memset	function
(	O
f	struct
,	O
0	int
,	O
sizeof	O
*	O
f	struct
)	O
;	O
f	struct
->	O
name	pointer
=	O
name	pointer
;	O
f	struct
->	O
type	enum
=	O
type	enum
;	O
f	struct
->	O
static_member	int
=	O
FALSE	int
;	O
f	struct
->	O
u	union
.	O
f	struct
.	O
bitpos	int
=	O
bitpos	int
;	O
f	struct
->	O
u	union
.	O
f	struct
.	O
bitsize	int
=	O
bitsize	int
;	O
f	struct
->	O
visibility	enum
=	O
visibility	enum
;	O
return	O
f	struct
;	O
}	O
debug_field	pointer
debug_make_static_member	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
type	enum
,	O
const	O
char	O
*	O
physname	pointer
,	O
enum	O
debug_visibility	enum
visibility	enum
)	O
{	O
struct	O
debug_field_s	struct
*	O
f	struct
;	O
f	struct
=	O
(	O
struct	O
debug_field_s	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
f	struct
)	O
;	O
memset	function
(	O
f	struct
,	O
0	int
,	O
sizeof	O
*	O
f	struct
)	O
;	O
f	struct
->	O
name	pointer
=	O
name	pointer
;	O
f	struct
->	O
type	enum
=	O
type	enum
;	O
f	struct
->	O
static_member	int
=	O
TRUE	int
;	O
f	struct
->	O
u	union
.	O
s	pointer
.	O
physname	pointer
=	O
physname	pointer
;	O
f	struct
->	O
visibility	enum
=	O
visibility	enum
;	O
return	O
f	struct
;	O
}	O
debug_method	pointer
debug_make_method	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_method_variant	pointer
*	O
variants	pointer
)	O
{	O
struct	O
debug_method_s	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
struct	O
debug_method_s	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
m	pointer
)	O
;	O
memset	function
(	O
m	pointer
,	O
0	int
,	O
sizeof	O
*	O
m	pointer
)	O
;	O
m	pointer
->	O
name	pointer
=	O
name	pointer
;	O
m	pointer
->	O
variants	pointer
=	O
variants	pointer
;	O
return	O
m	pointer
;	O
}	O
debug_method_variant	pointer
debug_make_method_variant	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
physname	pointer
,	O
debug_type	pointer
type	enum
,	O
enum	O
debug_visibility	enum
visibility	enum
,	O
bfd_boolean	int
constp	int
,	O
bfd_boolean	int
volatilep	int
,	O
bfd_vma	long
voffset	long
,	O
debug_type	pointer
context	pointer
)	O
{	O
struct	O
debug_method_variant_s	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
struct	O
debug_method_variant_s	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
m	pointer
)	O
;	O
memset	function
(	O
m	pointer
,	O
0	int
,	O
sizeof	O
*	O
m	pointer
)	O
;	O
m	pointer
->	O
physname	pointer
=	O
physname	pointer
;	O
m	pointer
->	O
type	enum
=	O
type	enum
;	O
m	pointer
->	O
visibility	enum
=	O
visibility	enum
;	O
m	pointer
->	O
constp	int
=	O
constp	int
;	O
m	pointer
->	O
volatilep	int
=	O
volatilep	int
;	O
m	pointer
->	O
voffset	long
=	O
voffset	long
;	O
m	pointer
->	O
context	pointer
=	O
context	pointer
;	O
return	O
m	pointer
;	O
}	O
debug_method_variant	pointer
debug_make_static_method_variant	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
physname	pointer
,	O
debug_type	pointer
type	enum
,	O
enum	O
debug_visibility	enum
visibility	enum
,	O
bfd_boolean	int
constp	int
,	O
bfd_boolean	int
volatilep	int
)	O
{	O
struct	O
debug_method_variant_s	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
struct	O
debug_method_variant_s	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
m	pointer
)	O
;	O
memset	function
(	O
m	pointer
,	O
0	int
,	O
sizeof	O
*	O
m	pointer
)	O
;	O
m	pointer
->	O
physname	pointer
=	O
physname	pointer
;	O
m	pointer
->	O
type	enum
=	O
type	enum
;	O
m	pointer
->	O
visibility	enum
=	O
visibility	enum
;	O
m	pointer
->	O
constp	int
=	O
constp	int
;	O
m	pointer
->	O
volatilep	int
=	O
volatilep	int
;	O
m	pointer
->	O
voffset	long
=	O
VOFFSET_STATIC_METHOD	O
;	O
return	O
m	pointer
;	O
}	O
debug_type	pointer
debug_name_type	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_named_type	struct
*	O
n	long
;	O
struct	O
debug_name	struct
*	O
nm	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
||	O
info	pointer
->	O
current_file	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_name_type: no current file"	pointer
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_NAMED	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
n	long
=	O
(	O
struct	O
debug_named_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
n	long
)	O
;	O
memset	function
(	O
n	long
,	O
0	int
,	O
sizeof	O
*	O
n	long
)	O
;	O
n	long
->	O
type	enum
=	O
type	enum
;	O
t	pointer
->	O
u	union
.	O
knamed	pointer
=	O
n	long
;	O
nm	pointer
=	O
debug_add_to_namespace	function
(	O
info	pointer
,	O
&	O
info	pointer
->	O
current_file	pointer
->	O
globals	pointer
,	O
name	pointer
,	O
DEBUG_OBJECT_TYPE	int
,	O
DEBUG_LINKAGE_NONE	int
)	O
;	O
if	O
(	O
nm	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
nm	pointer
->	O
u	union
.	O
type	enum
=	O
t	pointer
;	O
n	long
->	O
name	pointer
=	O
nm	pointer
;	O
return	O
t	pointer
;	O
}	O
debug_type	pointer
debug_tag_type	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_type_s	struct
*	O
t	pointer
;	O
struct	O
debug_named_type	struct
*	O
n	long
;	O
struct	O
debug_name	struct
*	O
nm	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
if	O
(	O
info	pointer
->	O
current_file	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_tag_type: no current file"	pointer
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
if	O
(	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_TAGGED	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
type	enum
;	O
debug_error	function
(	O
_	O
(	O
"debug_tag_type: extra tag attempted"	pointer
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
t	pointer
=	O
debug_make_type	function
(	O
info	pointer
,	O
DEBUG_KIND_TAGGED	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
n	long
=	O
(	O
struct	O
debug_named_type	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
n	long
)	O
;	O
memset	function
(	O
n	long
,	O
0	int
,	O
sizeof	O
*	O
n	long
)	O
;	O
n	long
->	O
type	enum
=	O
type	enum
;	O
t	pointer
->	O
u	union
.	O
knamed	pointer
=	O
n	long
;	O
nm	pointer
=	O
debug_add_to_namespace	function
(	O
info	pointer
,	O
&	O
info	pointer
->	O
current_file	pointer
->	O
globals	pointer
,	O
name	pointer
,	O
DEBUG_OBJECT_TAG	int
,	O
DEBUG_LINKAGE_NONE	int
)	O
;	O
if	O
(	O
nm	pointer
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
nm	pointer
->	O
u	union
.	O
tag	pointer
=	O
t	pointer
;	O
n	long
->	O
name	pointer
=	O
nm	pointer
;	O
return	O
t	pointer
;	O
}	O
bfd_boolean	int
debug_record_type_size	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_type	pointer
type	enum
,	O
unsigned	O
int	O
size	int
)	O
{	O
if	O
(	O
type	enum
->	O
size	int
!=	O
0	int
&&	O
type	enum
->	O
size	int
!=	O
size	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Warning: changing type size from %d to %d\n"	pointer
)	O
,	O
type	enum
->	O
size	int
,	O
size	int
)	O
;	O
type	enum
->	O
size	int
=	O
size	int
;	O
return	O
TRUE	int
;	O
}	O
debug_type	pointer
debug_find_named_type	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_block	struct
*	O
b	pointer
;	O
struct	O
debug_file	struct
*	O
f	struct
;	O
if	O
(	O
info	pointer
->	O
current_unit	pointer
==	O
NULL	O
)	O
{	O
debug_error	function
(	O
_	O
(	O
"debug_find_named_type: no current compilation unit"	pointer
)	O
)	O
;	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
for	O
(	O
b	pointer
=	O
info	pointer
->	O
current_block	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
parent	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
locals	pointer
!=	O
NULL	O
)	O
{	O
struct	O
debug_name	struct
*	O
n	long
;	O
for	O
(	O
n	long
=	O
b	pointer
->	O
locals	pointer
->	O
list	pointer
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
{	O
if	O
(	O
n	long
->	O
kind	enum
==	O
DEBUG_OBJECT_TYPE	int
&&	O
n	long
->	O
name	pointer
[	O
0	int
]	O
==	O
name	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
n	long
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
n	long
->	O
u	union
.	O
type	enum
;	O
}	O
}	O
}	O
for	O
(	O
f	struct
=	O
info	pointer
->	O
current_unit	pointer
->	O
files	pointer
;	O
f	struct
!=	O
NULL	O
;	O
f	struct
=	O
f	struct
->	O
next	pointer
)	O
{	O
if	O
(	O
f	struct
->	O
globals	pointer
!=	O
NULL	O
)	O
{	O
struct	O
debug_name	struct
*	O
n	long
;	O
for	O
(	O
n	long
=	O
f	struct
->	O
globals	pointer
->	O
list	pointer
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
{	O
if	O
(	O
n	long
->	O
kind	enum
==	O
DEBUG_OBJECT_TYPE	int
&&	O
n	long
->	O
name	pointer
[	O
0	int
]	O
==	O
name	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
n	long
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
n	long
->	O
u	union
.	O
type	enum
;	O
}	O
}	O
}	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
debug_type	pointer
debug_find_tagged_type	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
enum	O
debug_type_kind	enum
kind	enum
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_unit	struct
*	O
u	union
;	O
for	O
(	O
u	union
=	O
info	pointer
->	O
units	pointer
;	O
u	union
!=	O
NULL	O
;	O
u	union
=	O
u	union
->	O
next	pointer
)	O
{	O
struct	O
debug_file	struct
*	O
f	struct
;	O
for	O
(	O
f	struct
=	O
u	union
->	O
files	pointer
;	O
f	struct
!=	O
NULL	O
;	O
f	struct
=	O
f	struct
->	O
next	pointer
)	O
{	O
struct	O
debug_name	struct
*	O
n	long
;	O
if	O
(	O
f	struct
->	O
globals	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
n	long
=	O
f	struct
->	O
globals	pointer
->	O
list	pointer
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
{	O
if	O
(	O
n	long
->	O
kind	enum
==	O
DEBUG_OBJECT_TAG	int
&&	O
(	O
kind	enum
==	O
DEBUG_KIND_ILLEGAL	int
||	O
n	long
->	O
u	union
.	O
tag	pointer
->	O
kind	enum
==	O
kind	enum
)	O
&&	O
n	long
->	O
name	pointer
[	O
0	int
]	O
==	O
name	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
n	long
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
n	long
->	O
u	union
.	O
tag	pointer
;	O
}	O
}	O
}	O
}	O
return	O
DEBUG_TYPE_NULL	O
;	O
}	O
static	O
struct	O
debug_type_s	struct
*	O
debug_get_real_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
,	O
struct	O
debug_type_real_list	struct
*	O
list	pointer
)	O
{	O
struct	O
debug_type_real_list	struct
*	O
l	pointer
;	O
struct	O
debug_type_real_list	struct
rl	struct
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
default	O
:	O
return	O
type	enum
;	O
case	O
DEBUG_KIND_INDIRECT	int
:	O
case	O
DEBUG_KIND_NAMED	int
:	O
case	O
DEBUG_KIND_TAGGED	int
:	O
break	O
;	O
}	O
for	O
(	O
l	pointer
=	O
list	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
l	pointer
->	O
t	pointer
==	O
type	enum
||	O
l	pointer
==	O
l	pointer
->	O
next	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"debug_get_real_type: circular debug information for %s\n"	pointer
)	O
,	O
debug_get_type_name	function
(	O
handle	pointer
,	O
type	enum
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
rl	struct
.	O
next	pointer
=	O
list	pointer
;	O
rl	struct
.	O
t	pointer
=	O
type	enum
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
default	O
:	O
case	O
DEBUG_KIND_INDIRECT	int
:	O
if	O
(	O
*	O
type	enum
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
!=	O
NULL	O
)	O
return	O
debug_get_real_type	function
(	O
handle	pointer
,	O
*	O
type	enum
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
,	O
&	O
rl	struct
)	O
;	O
return	O
type	enum
;	O
case	O
DEBUG_KIND_NAMED	int
:	O
case	O
DEBUG_KIND_TAGGED	int
:	O
return	O
debug_get_real_type	function
(	O
handle	pointer
,	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
type	enum
,	O
&	O
rl	struct
)	O
;	O
}	O
}	O
enum	O
debug_type_kind	enum
debug_get_type_kind	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_KIND_ILLEGAL	int
;	O
type	enum
=	O
debug_get_real_type	function
(	O
handle	pointer
,	O
type	enum
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_KIND_ILLEGAL	int
;	O
return	O
type	enum
->	O
kind	enum
;	O
}	O
const	O
char	O
*	O
debug_get_type_name	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
if	O
(	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_INDIRECT	int
)	O
{	O
if	O
(	O
*	O
type	enum
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
!=	O
NULL	O
)	O
return	O
debug_get_type_name	function
(	O
handle	pointer
,	O
*	O
type	enum
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
)	O
;	O
return	O
type	enum
->	O
u	union
.	O
kindirect	pointer
->	O
tag	pointer
;	O
}	O
if	O
(	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_NAMED	int
||	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_TAGGED	int
)	O
return	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
->	O
name	pointer
;	O
return	O
NULL	O
;	O
}	O
bfd_vma	long
debug_get_type_size	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
type	enum
->	O
size	int
!=	O
0	int
)	O
return	O
type	enum
->	O
size	int
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
default	O
:	O
return	O
0	int
;	O
case	O
DEBUG_KIND_INDIRECT	int
:	O
if	O
(	O
*	O
type	enum
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
!=	O
NULL	O
)	O
return	O
debug_get_type_size	function
(	O
handle	pointer
,	O
*	O
type	enum
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
)	O
;	O
return	O
0	int
;	O
case	O
DEBUG_KIND_NAMED	int
:	O
case	O
DEBUG_KIND_TAGGED	int
:	O
return	O
debug_get_type_size	function
(	O
handle	pointer
,	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
type	enum
)	O
;	O
}	O
}	O
debug_type	pointer
debug_get_return_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
type	enum
=	O
debug_get_real_type	function
(	O
handle	pointer
,	O
type	enum
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
DEBUG_TYPE_NULL	O
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
default	O
:	O
return	O
DEBUG_TYPE_NULL	O
;	O
case	O
DEBUG_KIND_FUNCTION	int
:	O
return	O
type	enum
->	O
u	union
.	O
kfunction	pointer
->	O
return_type	pointer
;	O
case	O
DEBUG_KIND_METHOD	int
:	O
return	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
return_type	pointer
;	O
}	O
}	O
const	O
debug_type	pointer
*	O
debug_get_parameter_types	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
,	O
bfd_boolean	int
*	O
pvarargs	pointer
)	O
{	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
NULL	O
;	O
type	enum
=	O
debug_get_real_type	function
(	O
handle	pointer
,	O
type	enum
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
default	O
:	O
return	O
NULL	O
;	O
case	O
DEBUG_KIND_FUNCTION	int
:	O
*	O
pvarargs	pointer
=	O
type	enum
->	O
u	union
.	O
kfunction	pointer
->	O
varargs	int
;	O
return	O
type	enum
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
;	O
case	O
DEBUG_KIND_METHOD	int
:	O
*	O
pvarargs	pointer
=	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
varargs	int
;	O
return	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
;	O
}	O
}	O
debug_type	pointer
debug_get_target_type	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
NULL	O
;	O
type	enum
=	O
debug_get_real_type	function
(	O
handle	pointer
,	O
type	enum
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
default	O
:	O
return	O
NULL	O
;	O
case	O
DEBUG_KIND_POINTER	int
:	O
return	O
type	enum
->	O
u	union
.	O
kpointer	pointer
;	O
case	O
DEBUG_KIND_REFERENCE	int
:	O
return	O
type	enum
->	O
u	union
.	O
kreference	pointer
;	O
case	O
DEBUG_KIND_CONST	int
:	O
return	O
type	enum
->	O
u	union
.	O
kconst	pointer
;	O
case	O
DEBUG_KIND_VOLATILE	int
:	O
return	O
type	enum
->	O
u	union
.	O
kvolatile	pointer
;	O
}	O
}	O
const	O
debug_field	pointer
*	O
debug_get_fields	function
(	O
void	O
*	O
handle	pointer
,	O
debug_type	pointer
type	enum
)	O
{	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
NULL	O
;	O
type	enum
=	O
debug_get_real_type	function
(	O
handle	pointer
,	O
type	enum
,	O
NULL	O
)	O
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
return	O
NULL	O
;	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
default	O
:	O
return	O
NULL	O
;	O
case	O
DEBUG_KIND_STRUCT	int
:	O
case	O
DEBUG_KIND_UNION	int
:	O
case	O
DEBUG_KIND_CLASS	int
:	O
case	O
DEBUG_KIND_UNION_CLASS	int
:	O
return	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
fields	pointer
;	O
}	O
}	O
debug_type	pointer
debug_get_field_type	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_field	pointer
field	pointer
)	O
{	O
if	O
(	O
field	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
field	pointer
->	O
type	enum
;	O
}	O
const	O
char	O
*	O
debug_get_field_name	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_field	pointer
field	pointer
)	O
{	O
if	O
(	O
field	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
field	pointer
->	O
name	pointer
;	O
}	O
bfd_vma	long
debug_get_field_bitpos	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_field	pointer
field	pointer
)	O
{	O
if	O
(	O
field	pointer
==	O
NULL	O
||	O
field	pointer
->	O
static_member	int
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
return	O
field	pointer
->	O
u	union
.	O
f	struct
.	O
bitpos	int
;	O
}	O
bfd_vma	long
debug_get_field_bitsize	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_field	pointer
field	pointer
)	O
{	O
if	O
(	O
field	pointer
==	O
NULL	O
||	O
field	pointer
->	O
static_member	int
)	O
return	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
return	O
field	pointer
->	O
u	union
.	O
f	struct
.	O
bitsize	int
;	O
}	O
enum	O
debug_visibility	enum
debug_get_field_visibility	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_field	pointer
field	pointer
)	O
{	O
if	O
(	O
field	pointer
==	O
NULL	O
)	O
return	O
DEBUG_VISIBILITY_IGNORE	int
;	O
return	O
field	pointer
->	O
visibility	enum
;	O
}	O
const	O
char	O
*	O
debug_get_field_physname	function
(	O
void	O
*	O
handle	pointer
ATTRIBUTE_UNUSED	O
,	O
debug_field	pointer
field	pointer
)	O
{	O
if	O
(	O
field	pointer
==	O
NULL	O
||	O
!	O
field	pointer
->	O
static_member	int
)	O
return	O
NULL	O
;	O
return	O
field	pointer
->	O
u	union
.	O
s	pointer
.	O
physname	pointer
;	O
}	O
bfd_boolean	int
debug_write	function
(	O
void	O
*	O
handle	pointer
,	O
const	O
struct	O
debug_write_fns	struct
*	O
fns	pointer
,	O
void	O
*	O
fhandle	pointer
)	O
{	O
struct	O
debug_handle	struct
*	O
info	pointer
=	O
(	O
struct	O
debug_handle	struct
*	O
)	O
handle	pointer
;	O
struct	O
debug_unit	struct
*	O
u	union
;	O
++	O
info	pointer
->	O
mark	int
;	O
info	pointer
->	O
base_id	int
=	O
info	pointer
->	O
class_id	int
;	O
info	pointer
->	O
id_list	pointer
=	O
NULL	O
;	O
for	O
(	O
u	union
=	O
info	pointer
->	O
units	pointer
;	O
u	union
!=	O
NULL	O
;	O
u	union
=	O
u	union
->	O
next	pointer
)	O
{	O
struct	O
debug_file	struct
*	O
f	struct
;	O
bfd_boolean	int
first_file	int
;	O
info	pointer
->	O
current_write_lineno	pointer
=	O
u	union
->	O
linenos	pointer
;	O
info	pointer
->	O
current_write_lineno_index	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
start_compilation_unit	pointer
)	O
(	O
fhandle	pointer
,	O
u	union
->	O
files	pointer
->	O
filename	pointer
)	O
)	O
return	O
FALSE	int
;	O
first_file	int
=	O
TRUE	int
;	O
for	O
(	O
f	struct
=	O
u	union
->	O
files	pointer
;	O
f	struct
!=	O
NULL	O
;	O
f	struct
=	O
f	struct
->	O
next	pointer
)	O
{	O
struct	O
debug_name	struct
*	O
n	long
;	O
if	O
(	O
first_file	int
)	O
first_file	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
start_source	pointer
)	O
(	O
fhandle	pointer
,	O
f	struct
->	O
filename	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
f	struct
->	O
globals	pointer
!=	O
NULL	O
)	O
for	O
(	O
n	long
=	O
f	struct
->	O
globals	pointer
->	O
list	pointer
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
if	O
(	O
!	O
debug_write_name	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
n	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
debug_write_linenos	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
debug_write_name	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
const	O
struct	O
debug_write_fns	struct
*	O
fns	pointer
,	O
void	O
*	O
fhandle	pointer
,	O
struct	O
debug_name	struct
*	O
n	long
)	O
{	O
switch	O
(	O
n	long
->	O
kind	enum
)	O
{	O
case	O
DEBUG_OBJECT_TYPE	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
n	long
->	O
u	union
.	O
type	enum
,	O
n	long
)	O
||	O
!	O
(	O
*	O
fns	pointer
->	O
typdef	pointer
)	O
(	O
fhandle	pointer
,	O
n	long
->	O
name	pointer
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
case	O
DEBUG_OBJECT_TAG	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
n	long
->	O
u	union
.	O
tag	pointer
,	O
n	long
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
tag	pointer
)	O
(	O
fhandle	pointer
,	O
n	long
->	O
name	pointer
)	O
;	O
case	O
DEBUG_OBJECT_VARIABLE	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
n	long
->	O
u	union
.	O
variable	pointer
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
variable	pointer
)	O
(	O
fhandle	pointer
,	O
n	long
->	O
name	pointer
,	O
n	long
->	O
u	union
.	O
variable	pointer
->	O
kind	enum
,	O
n	long
->	O
u	union
.	O
variable	pointer
->	O
val	array
)	O
;	O
case	O
DEBUG_OBJECT_FUNCTION	int
:	O
return	O
debug_write_function	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
n	long
->	O
name	pointer
,	O
n	long
->	O
linkage	enum
,	O
n	long
->	O
u	union
.	O
function	pointer
)	O
;	O
case	O
DEBUG_OBJECT_INT_CONSTANT	int
:	O
return	O
(	O
*	O
fns	pointer
->	O
int_constant	pointer
)	O
(	O
fhandle	pointer
,	O
n	long
->	O
name	pointer
,	O
n	long
->	O
u	union
.	O
int_constant	pointer
)	O
;	O
case	O
DEBUG_OBJECT_FLOAT_CONSTANT	int
:	O
return	O
(	O
*	O
fns	pointer
->	O
float_constant	pointer
)	O
(	O
fhandle	pointer
,	O
n	long
->	O
name	pointer
,	O
n	long
->	O
u	union
.	O
float_constant	pointer
)	O
;	O
case	O
DEBUG_OBJECT_TYPED_CONSTANT	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
n	long
->	O
u	union
.	O
typed_constant	pointer
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
typed_constant	pointer
)	O
(	O
fhandle	pointer
,	O
n	long
->	O
name	pointer
,	O
n	long
->	O
u	union
.	O
typed_constant	pointer
->	O
val	array
)	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
debug_write_type	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
const	O
struct	O
debug_write_fns	struct
*	O
fns	pointer
,	O
void	O
*	O
fhandle	pointer
,	O
struct	O
debug_type_s	struct
*	O
type	enum
,	O
struct	O
debug_name	struct
*	O
name	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
int	O
is	int
;	O
const	O
char	O
*	O
tag	pointer
=	O
NULL	O
;	O
if	O
(	O
type	enum
==	O
DEBUG_TYPE_NULL	O
)	O
return	O
(	O
*	O
fns	pointer
->	O
empty_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
if	O
(	O
(	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_NAMED	int
||	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_TAGGED	int
)	O
&&	O
(	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
->	O
mark	int
==	O
info	pointer
->	O
mark	int
||	O
(	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_TAGGED	int
&&	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
!=	O
name	pointer
)	O
)	O
)	O
{	O
if	O
(	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_NAMED	int
)	O
return	O
(	O
*	O
fns	pointer
->	O
typedef_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
->	O
name	pointer
)	O
;	O
else	O
{	O
struct	O
debug_type_s	struct
*	O
real	pointer
;	O
unsigned	O
int	O
id	int
;	O
real	pointer
=	O
debug_get_real_type	function
(	O
(	O
void	O
*	O
)	O
info	pointer
,	O
type	enum
,	O
NULL	O
)	O
;	O
if	O
(	O
real	pointer
==	O
NULL	O
)	O
return	O
(	O
*	O
fns	pointer
->	O
empty_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
id	int
=	O
0	int
;	O
if	O
(	O
(	O
real	pointer
->	O
kind	enum
==	O
DEBUG_KIND_STRUCT	int
||	O
real	pointer
->	O
kind	enum
==	O
DEBUG_KIND_UNION	int
||	O
real	pointer
->	O
kind	enum
==	O
DEBUG_KIND_CLASS	int
||	O
real	pointer
->	O
kind	enum
==	O
DEBUG_KIND_UNION_CLASS	int
)	O
&&	O
real	pointer
->	O
u	union
.	O
kclass	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
real	pointer
->	O
u	union
.	O
kclass	pointer
->	O
id	int
<=	O
info	pointer
->	O
base_id	int
)	O
{	O
if	O
(	O
!	O
debug_set_class_id	function
(	O
info	pointer
,	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
->	O
name	pointer
,	O
real	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
id	int
=	O
real	pointer
->	O
u	union
.	O
kclass	pointer
->	O
id	int
;	O
}	O
return	O
(	O
*	O
fns	pointer
->	O
tag_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
->	O
name	pointer
,	O
id	int
,	O
real	pointer
->	O
kind	enum
)	O
;	O
}	O
}	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
name	pointer
->	O
mark	int
=	O
info	pointer
->	O
mark	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
&&	O
type	enum
->	O
kind	enum
!=	O
DEBUG_KIND_NAMED	int
&&	O
type	enum
->	O
kind	enum
!=	O
DEBUG_KIND_TAGGED	int
)	O
{	O
assert	O
(	O
name	pointer
->	O
kind	enum
==	O
DEBUG_OBJECT_TAG	int
)	O
;	O
tag	pointer
=	O
name	pointer
->	O
name	pointer
;	O
}	O
switch	O
(	O
type	enum
->	O
kind	enum
)	O
{	O
case	O
DEBUG_KIND_ILLEGAL	int
:	O
debug_error	function
(	O
_	O
(	O
"debug_write_type: illegal type encountered"	pointer
)	O
)	O
;	O
return	O
FALSE	int
;	O
case	O
DEBUG_KIND_INDIRECT	int
:	O
return	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
*	O
type	enum
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
,	O
name	pointer
)	O
;	O
case	O
DEBUG_KIND_VOID	int
:	O
return	O
(	O
*	O
fns	pointer
->	O
void_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
case	O
DEBUG_KIND_INT	int
:	O
return	O
(	O
*	O
fns	pointer
->	O
int_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
size	int
,	O
type	enum
->	O
u	union
.	O
kint	int
)	O
;	O
case	O
DEBUG_KIND_FLOAT	int
:	O
return	O
(	O
*	O
fns	pointer
->	O
float_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
size	int
)	O
;	O
case	O
DEBUG_KIND_COMPLEX	int
:	O
return	O
(	O
*	O
fns	pointer
->	O
complex_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
size	int
)	O
;	O
case	O
DEBUG_KIND_BOOL	int
:	O
return	O
(	O
*	O
fns	pointer
->	O
bool_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
size	int
)	O
;	O
case	O
DEBUG_KIND_STRUCT	int
:	O
case	O
DEBUG_KIND_UNION	int
:	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
<=	O
info	pointer
->	O
base_id	int
)	O
{	O
if	O
(	O
!	O
debug_set_class_id	function
(	O
info	pointer
,	O
tag	pointer
,	O
type	enum
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
info	pointer
->	O
mark	int
==	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
mark	int
)	O
{	O
assert	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
>	O
info	pointer
->	O
base_id	int
)	O
;	O
return	O
(	O
*	O
fns	pointer
->	O
tag_type	pointer
)	O
(	O
fhandle	pointer
,	O
tag	pointer
,	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
,	O
type	enum
->	O
kind	enum
)	O
;	O
}	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
mark	int
=	O
info	pointer
->	O
mark	int
;	O
}	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
start_struct_type	pointer
)	O
(	O
fhandle	pointer
,	O
tag	pointer
,	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
!=	O
NULL	O
?	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
:	O
0	int
)	O
,	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_STRUCT	int
,	O
type	enum
->	O
size	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
!=	O
NULL	O
&&	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
fields	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
fields	pointer
[	O
i	pointer
]	O
!=	O
NULL	O
;	O
i	pointer
++	O
)	O
{	O
struct	O
debug_field_s	struct
*	O
f	struct
;	O
f	struct
=	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
fields	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
f	struct
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
||	O
!	O
(	O
*	O
fns	pointer
->	O
struct_field	pointer
)	O
(	O
fhandle	pointer
,	O
f	struct
->	O
name	pointer
,	O
f	struct
->	O
u	union
.	O
f	struct
.	O
bitpos	int
,	O
f	struct
->	O
u	union
.	O
f	struct
.	O
bitsize	int
,	O
f	struct
->	O
visibility	enum
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
return	O
(	O
*	O
fns	pointer
->	O
end_struct_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
case	O
DEBUG_KIND_CLASS	int
:	O
case	O
DEBUG_KIND_UNION_CLASS	int
:	O
return	O
debug_write_class_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
,	O
tag	pointer
)	O
;	O
case	O
DEBUG_KIND_ENUM	int
:	O
if	O
(	O
type	enum
->	O
u	union
.	O
kenum	pointer
==	O
NULL	O
)	O
return	O
(	O
*	O
fns	pointer
->	O
enum_type	pointer
)	O
(	O
fhandle	pointer
,	O
tag	pointer
,	O
(	O
const	O
char	O
*	O
*	O
)	O
NULL	O
,	O
(	O
bfd_signed_vma	long
*	O
)	O
NULL	O
)	O
;	O
return	O
(	O
*	O
fns	pointer
->	O
enum_type	pointer
)	O
(	O
fhandle	pointer
,	O
tag	pointer
,	O
type	enum
->	O
u	union
.	O
kenum	pointer
->	O
names	pointer
,	O
type	enum
->	O
u	union
.	O
kenum	pointer
->	O
values	pointer
)	O
;	O
case	O
DEBUG_KIND_POINTER	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kpointer	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
pointer_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
case	O
DEBUG_KIND_FUNCTION	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kfunction	pointer
->	O
return_type	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
type	enum
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
==	O
NULL	O
)	O
is	int
=	O
-	O
1	int
;	O
else	O
{	O
for	O
(	O
is	int
=	O
0	int
;	O
type	enum
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
[	O
is	int
]	O
!=	O
NULL	O
;	O
is	int
++	O
)	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
[	O
is	int
]	O
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
(	O
*	O
fns	pointer
->	O
function_type	pointer
)	O
(	O
fhandle	pointer
,	O
is	int
,	O
type	enum
->	O
u	union
.	O
kfunction	pointer
->	O
varargs	int
)	O
;	O
case	O
DEBUG_KIND_REFERENCE	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kreference	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
reference_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
case	O
DEBUG_KIND_RANGE	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
krange	pointer
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
range_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
krange	pointer
->	O
lower	long
,	O
type	enum
->	O
u	union
.	O
krange	pointer
->	O
upper	long
)	O
;	O
case	O
DEBUG_KIND_ARRAY	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
karray	pointer
->	O
element_type	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
||	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
karray	pointer
->	O
range_type	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
array_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
karray	pointer
->	O
lower	long
,	O
type	enum
->	O
u	union
.	O
karray	pointer
->	O
upper	long
,	O
type	enum
->	O
u	union
.	O
karray	pointer
->	O
stringp	int
)	O
;	O
case	O
DEBUG_KIND_SET	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kset	pointer
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
set_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kset	pointer
->	O
bitstringp	int
)	O
;	O
case	O
DEBUG_KIND_OFFSET	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
koffset	pointer
->	O
base_type	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
||	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
koffset	pointer
->	O
target_type	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
offset_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
case	O
DEBUG_KIND_METHOD	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
return_type	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
==	O
NULL	O
)	O
is	int
=	O
-	O
1	int
;	O
else	O
{	O
for	O
(	O
is	int
=	O
0	int
;	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
[	O
is	int
]	O
!=	O
NULL	O
;	O
is	int
++	O
)	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
[	O
is	int
]	O
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
domain_type	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
domain_type	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
(	O
*	O
fns	pointer
->	O
method_type	pointer
)	O
(	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
domain_type	pointer
!=	O
NULL	O
,	O
is	int
,	O
type	enum
->	O
u	union
.	O
kmethod	pointer
->	O
varargs	int
)	O
;	O
case	O
DEBUG_KIND_CONST	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kconst	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
const_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
case	O
DEBUG_KIND_VOLATILE	int
:	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
kvolatile	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
return	O
(	O
*	O
fns	pointer
->	O
volatile_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
case	O
DEBUG_KIND_NAMED	int
:	O
return	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
;	O
case	O
DEBUG_KIND_TAGGED	int
:	O
return	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
type	enum
,	O
type	enum
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
)	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
debug_write_class_type	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
const	O
struct	O
debug_write_fns	struct
*	O
fns	pointer
,	O
void	O
*	O
fhandle	pointer
,	O
struct	O
debug_type_s	struct
*	O
type	enum
,	O
const	O
char	O
*	O
tag	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
unsigned	O
int	O
id	int
;	O
struct	O
debug_type_s	struct
*	O
vptrbase	pointer
;	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
==	O
NULL	O
)	O
{	O
id	int
=	O
0	int
;	O
vptrbase	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
<=	O
info	pointer
->	O
base_id	int
)	O
{	O
if	O
(	O
!	O
debug_set_class_id	function
(	O
info	pointer
,	O
tag	pointer
,	O
type	enum
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
info	pointer
->	O
mark	int
==	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
mark	int
)	O
{	O
assert	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
>	O
info	pointer
->	O
base_id	int
)	O
;	O
return	O
(	O
*	O
fns	pointer
->	O
tag_type	pointer
)	O
(	O
fhandle	pointer
,	O
tag	pointer
,	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
,	O
type	enum
->	O
kind	enum
)	O
;	O
}	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
mark	int
=	O
info	pointer
->	O
mark	int
;	O
id	int
=	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
;	O
vptrbase	pointer
=	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
vptrbase	pointer
;	O
if	O
(	O
vptrbase	pointer
!=	O
NULL	O
&&	O
vptrbase	pointer
!=	O
type	enum
)	O
{	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
vptrbase	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
start_class_type	pointer
)	O
(	O
fhandle	pointer
,	O
tag	pointer
,	O
id	int
,	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_CLASS	int
,	O
type	enum
->	O
size	int
,	O
vptrbase	pointer
!=	O
NULL	O
,	O
vptrbase	pointer
==	O
type	enum
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
fields	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
fields	pointer
[	O
i	pointer
]	O
!=	O
NULL	O
;	O
i	pointer
++	O
)	O
{	O
struct	O
debug_field_s	struct
*	O
f	struct
;	O
f	struct
=	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
fields	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
f	struct
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
f	struct
->	O
static_member	int
)	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
class_static_member	pointer
)	O
(	O
fhandle	pointer
,	O
f	struct
->	O
name	pointer
,	O
f	struct
->	O
u	union
.	O
s	pointer
.	O
physname	pointer
,	O
f	struct
->	O
visibility	enum
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
struct_field	pointer
)	O
(	O
fhandle	pointer
,	O
f	struct
->	O
name	pointer
,	O
f	struct
->	O
u	union
.	O
f	struct
.	O
bitpos	int
,	O
f	struct
->	O
u	union
.	O
f	struct
.	O
bitsize	int
,	O
f	struct
->	O
visibility	enum
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
baseclasses	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
baseclasses	pointer
[	O
i	pointer
]	O
!=	O
NULL	O
;	O
i	pointer
++	O
)	O
{	O
struct	O
debug_baseclass_s	struct
*	O
b	pointer
;	O
b	pointer
=	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
baseclasses	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
b	pointer
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
class_baseclass	pointer
)	O
(	O
fhandle	pointer
,	O
b	pointer
->	O
bitpos	int
,	O
b	pointer
->	O
is_virtual	int
,	O
b	pointer
->	O
visibility	enum
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
methods	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
methods	pointer
[	O
i	pointer
]	O
!=	O
NULL	O
;	O
i	pointer
++	O
)	O
{	O
struct	O
debug_method_s	struct
*	O
m	pointer
;	O
unsigned	O
int	O
j	int
;	O
m	pointer
=	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
methods	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
class_start_method	pointer
)	O
(	O
fhandle	pointer
,	O
m	pointer
->	O
name	pointer
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
m	pointer
->	O
variants	pointer
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
struct	O
debug_method_variant_s	struct
*	O
v	pointer
;	O
v	pointer
=	O
m	pointer
->	O
variants	pointer
[	O
j	int
]	O
;	O
if	O
(	O
v	pointer
->	O
context	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
v	pointer
->	O
context	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
v	pointer
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
v	pointer
->	O
voffset	long
!=	O
VOFFSET_STATIC_METHOD	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
class_method_variant	pointer
)	O
(	O
fhandle	pointer
,	O
v	pointer
->	O
physname	pointer
,	O
v	pointer
->	O
visibility	enum
,	O
v	pointer
->	O
constp	int
,	O
v	pointer
->	O
volatilep	int
,	O
v	pointer
->	O
voffset	long
,	O
v	pointer
->	O
context	pointer
!=	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
class_static_method_variant	pointer
)	O
(	O
fhandle	pointer
,	O
v	pointer
->	O
physname	pointer
,	O
v	pointer
->	O
visibility	enum
,	O
v	pointer
->	O
constp	int
,	O
v	pointer
->	O
volatilep	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
class_end_method	pointer
)	O
(	O
fhandle	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
return	O
(	O
*	O
fns	pointer
->	O
end_class_type	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
debug_write_function	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
const	O
struct	O
debug_write_fns	struct
*	O
fns	pointer
,	O
void	O
*	O
fhandle	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
enum	O
debug_object_linkage	enum
linkage	enum
,	O
struct	O
debug_function	struct
*	O
function	pointer
)	O
{	O
struct	O
debug_parameter	struct
*	O
p	pointer
;	O
struct	O
debug_block	struct
*	O
b	pointer
;	O
if	O
(	O
!	O
debug_write_linenos	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
function	pointer
->	O
blocks	pointer
->	O
start	long
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
function	pointer
->	O
return_type	pointer
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
start_function	pointer
)	O
(	O
fhandle	pointer
,	O
name	pointer
,	O
linkage	enum
==	O
DEBUG_LINKAGE_GLOBAL	int
)	O
)	O
return	O
FALSE	int
;	O
for	O
(	O
p	pointer
=	O
function	pointer
->	O
parameters	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
debug_write_type	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
p	pointer
->	O
type	enum
,	O
(	O
struct	O
debug_name	struct
*	O
)	O
NULL	O
)	O
||	O
!	O
(	O
*	O
fns	pointer
->	O
function_parameter	pointer
)	O
(	O
fhandle	pointer
,	O
p	pointer
->	O
name	pointer
,	O
p	pointer
->	O
kind	enum
,	O
p	pointer
->	O
val	array
)	O
)	O
return	O
FALSE	int
;	O
}	O
for	O
(	O
b	pointer
=	O
function	pointer
->	O
blocks	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
debug_write_block	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
b	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
(	O
*	O
fns	pointer
->	O
end_function	pointer
)	O
(	O
fhandle	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
debug_write_block	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
const	O
struct	O
debug_write_fns	struct
*	O
fns	pointer
,	O
void	O
*	O
fhandle	pointer
,	O
struct	O
debug_block	struct
*	O
block	pointer
)	O
{	O
struct	O
debug_name	struct
*	O
n	long
;	O
struct	O
debug_block	struct
*	O
b	pointer
;	O
if	O
(	O
!	O
debug_write_linenos	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
block	pointer
->	O
start	long
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
block	pointer
->	O
locals	pointer
!=	O
NULL	O
||	O
block	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
start_block	pointer
)	O
(	O
fhandle	pointer
,	O
block	pointer
->	O
start	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
block	pointer
->	O
locals	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
n	long
=	O
block	pointer
->	O
locals	pointer
->	O
list	pointer
;	O
n	long
!=	O
NULL	O
;	O
n	long
=	O
n	long
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
debug_write_name	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
n	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
for	O
(	O
b	pointer
=	O
block	pointer
->	O
children	pointer
;	O
b	pointer
!=	O
NULL	O
;	O
b	pointer
=	O
b	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
debug_write_block	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
b	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
debug_write_linenos	function
(	O
info	pointer
,	O
fns	pointer
,	O
fhandle	pointer
,	O
block	pointer
->	O
end	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
block	pointer
->	O
locals	pointer
!=	O
NULL	O
||	O
block	pointer
->	O
parent	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
end_block	pointer
)	O
(	O
fhandle	pointer
,	O
block	pointer
->	O
end	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
debug_write_linenos	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
const	O
struct	O
debug_write_fns	struct
*	O
fns	pointer
,	O
void	O
*	O
fhandle	pointer
,	O
bfd_vma	long
address	long
)	O
{	O
while	O
(	O
info	pointer
->	O
current_write_lineno	pointer
!=	O
NULL	O
)	O
{	O
struct	O
debug_lineno	struct
*	O
l	pointer
;	O
l	pointer
=	O
info	pointer
->	O
current_write_lineno	pointer
;	O
while	O
(	O
info	pointer
->	O
current_write_lineno_index	int
<	O
DEBUG_LINENO_COUNT	int
)	O
{	O
if	O
(	O
l	pointer
->	O
linenos	pointer
[	O
info	pointer
->	O
current_write_lineno_index	int
]	O
==	O
(	O
unsigned	O
long	O
)	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
l	pointer
->	O
addrs	array
[	O
info	pointer
->	O
current_write_lineno_index	int
]	O
>=	O
address	long
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
(	O
*	O
fns	pointer
->	O
lineno	pointer
)	O
(	O
fhandle	pointer
,	O
l	pointer
->	O
file	pointer
->	O
filename	pointer
,	O
l	pointer
->	O
linenos	pointer
[	O
info	pointer
->	O
current_write_lineno_index	int
]	O
,	O
l	pointer
->	O
addrs	array
[	O
info	pointer
->	O
current_write_lineno_index	int
]	O
)	O
)	O
return	O
FALSE	int
;	O
++	O
info	pointer
->	O
current_write_lineno_index	int
;	O
}	O
info	pointer
->	O
current_write_lineno	pointer
=	O
l	pointer
->	O
next	pointer
;	O
info	pointer
->	O
current_write_lineno_index	int
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
debug_set_class_id	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
const	O
char	O
*	O
tag	pointer
,	O
struct	O
debug_type_s	struct
*	O
type	enum
)	O
{	O
struct	O
debug_class_type	struct
*	O
c	pointer
;	O
struct	O
debug_class_id	struct
*	O
l	pointer
;	O
assert	O
(	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_STRUCT	int
||	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_UNION	int
||	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_CLASS	int
||	O
type	enum
->	O
kind	enum
==	O
DEBUG_KIND_UNION_CLASS	int
)	O
;	O
c	pointer
=	O
type	enum
->	O
u	union
.	O
kclass	pointer
;	O
if	O
(	O
c	pointer
->	O
id	int
>	O
info	pointer
->	O
base_id	int
)	O
return	O
TRUE	int
;	O
for	O
(	O
l	pointer
=	O
info	pointer
->	O
id_list	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
l	pointer
->	O
type	enum
->	O
kind	enum
!=	O
type	enum
->	O
kind	enum
)	O
continue	O
;	O
if	O
(	O
tag	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
l	pointer
->	O
tag	pointer
!=	O
NULL	O
)	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
l	pointer
->	O
tag	pointer
==	O
NULL	O
||	O
l	pointer
->	O
tag	pointer
[	O
0	int
]	O
!=	O
tag	pointer
[	O
0	int
]	O
||	O
strcmp	function
(	O
l	pointer
->	O
tag	pointer
,	O
tag	pointer
)	O
!=	O
0	int
)	O
continue	O
;	O
}	O
if	O
(	O
debug_type_samep	function
(	O
info	pointer
,	O
l	pointer
->	O
type	enum
,	O
type	enum
)	O
)	O
{	O
c	pointer
->	O
id	int
=	O
l	pointer
->	O
type	enum
->	O
u	union
.	O
kclass	pointer
->	O
id	int
;	O
return	O
TRUE	int
;	O
}	O
}	O
++	O
info	pointer
->	O
class_id	int
;	O
c	pointer
->	O
id	int
=	O
info	pointer
->	O
class_id	int
;	O
l	pointer
=	O
(	O
struct	O
debug_class_id	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
*	O
l	pointer
)	O
;	O
memset	function
(	O
l	pointer
,	O
0	int
,	O
sizeof	O
*	O
l	pointer
)	O
;	O
l	pointer
->	O
type	enum
=	O
type	enum
;	O
l	pointer
->	O
tag	pointer
=	O
tag	pointer
;	O
l	pointer
->	O
next	pointer
=	O
info	pointer
->	O
id_list	pointer
;	O
info	pointer
->	O
id_list	pointer
=	O
l	pointer
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
debug_type_samep	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
struct	O
debug_type_s	struct
*	O
t1	pointer
,	O
struct	O
debug_type_s	struct
*	O
t2	pointer
)	O
{	O
struct	O
debug_type_compare_list	struct
*	O
l	pointer
;	O
struct	O
debug_type_compare_list	struct
top	struct
;	O
bfd_boolean	int
ret	pointer
;	O
if	O
(	O
t1	pointer
==	O
NULL	O
)	O
return	O
t2	pointer
==	O
NULL	O
;	O
if	O
(	O
t2	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
while	O
(	O
t1	pointer
->	O
kind	enum
==	O
DEBUG_KIND_INDIRECT	int
)	O
{	O
t1	pointer
=	O
*	O
t1	pointer
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
;	O
if	O
(	O
t1	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
while	O
(	O
t2	pointer
->	O
kind	enum
==	O
DEBUG_KIND_INDIRECT	int
)	O
{	O
t2	pointer
=	O
*	O
t2	pointer
->	O
u	union
.	O
kindirect	pointer
->	O
slot	pointer
;	O
if	O
(	O
t2	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
t1	pointer
==	O
t2	pointer
)	O
return	O
TRUE	int
;	O
if	O
(	O
t1	pointer
->	O
kind	enum
==	O
DEBUG_KIND_NAMED	int
&&	O
t2	pointer
->	O
kind	enum
==	O
DEBUG_KIND_TAGGED	int
)	O
return	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
knamed	pointer
->	O
type	enum
,	O
t2	pointer
)	O
;	O
else	O
if	O
(	O
t1	pointer
->	O
kind	enum
==	O
DEBUG_KIND_TAGGED	int
&&	O
t2	pointer
->	O
kind	enum
==	O
DEBUG_KIND_NAMED	int
)	O
return	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
,	O
t2	pointer
->	O
u	union
.	O
knamed	pointer
->	O
type	enum
)	O
;	O
if	O
(	O
t1	pointer
->	O
kind	enum
!=	O
t2	pointer
->	O
kind	enum
||	O
t1	pointer
->	O
size	int
!=	O
t2	pointer
->	O
size	int
)	O
return	O
FALSE	int
;	O
switch	O
(	O
t1	pointer
->	O
kind	enum
)	O
{	O
default	O
:	O
break	O
;	O
case	O
DEBUG_KIND_VOID	int
:	O
case	O
DEBUG_KIND_FLOAT	int
:	O
case	O
DEBUG_KIND_COMPLEX	int
:	O
case	O
DEBUG_KIND_BOOL	int
:	O
return	O
TRUE	int
;	O
case	O
DEBUG_KIND_INT	int
:	O
return	O
t1	pointer
->	O
u	union
.	O
kint	int
==	O
t2	pointer
->	O
u	union
.	O
kint	int
;	O
}	O
for	O
(	O
l	pointer
=	O
info	pointer
->	O
compare_list	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
l	pointer
->	O
t1	pointer
==	O
t1	pointer
&&	O
l	pointer
->	O
t2	pointer
==	O
t2	pointer
)	O
return	O
TRUE	int
;	O
}	O
top	struct
.	O
t1	pointer
=	O
t1	pointer
;	O
top	struct
.	O
t2	pointer
=	O
t2	pointer
;	O
top	struct
.	O
next	pointer
=	O
info	pointer
->	O
compare_list	pointer
;	O
info	pointer
->	O
compare_list	pointer
=	O
&	O
top	struct
;	O
switch	O
(	O
t1	pointer
->	O
kind	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
ret	pointer
=	O
FALSE	int
;	O
break	O
;	O
case	O
DEBUG_KIND_STRUCT	int
:	O
case	O
DEBUG_KIND_UNION	int
:	O
case	O
DEBUG_KIND_CLASS	int
:	O
case	O
DEBUG_KIND_UNION_CLASS	int
:	O
if	O
(	O
t1	pointer
->	O
u	union
.	O
kclass	pointer
==	O
NULL	O
)	O
ret	pointer
=	O
t2	pointer
->	O
u	union
.	O
kclass	pointer
==	O
NULL	O
;	O
else	O
if	O
(	O
t2	pointer
->	O
u	union
.	O
kclass	pointer
==	O
NULL	O
)	O
ret	pointer
=	O
FALSE	int
;	O
else	O
if	O
(	O
t1	pointer
->	O
u	union
.	O
kclass	pointer
->	O
id	int
>	O
info	pointer
->	O
base_id	int
&&	O
t1	pointer
->	O
u	union
.	O
kclass	pointer
->	O
id	int
==	O
t2	pointer
->	O
u	union
.	O
kclass	pointer
->	O
id	int
)	O
ret	pointer
=	O
TRUE	int
;	O
else	O
ret	pointer
=	O
debug_class_type_samep	function
(	O
info	pointer
,	O
t1	pointer
,	O
t2	pointer
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_ENUM	int
:	O
if	O
(	O
t1	pointer
->	O
u	union
.	O
kenum	pointer
==	O
NULL	O
)	O
ret	pointer
=	O
t2	pointer
->	O
u	union
.	O
kenum	pointer
==	O
NULL	O
;	O
else	O
if	O
(	O
t2	pointer
->	O
u	union
.	O
kenum	pointer
==	O
NULL	O
)	O
ret	pointer
=	O
FALSE	int
;	O
else	O
{	O
const	O
char	O
*	O
*	O
pn1	pointer
,	O
*	O
*	O
pn2	pointer
;	O
bfd_signed_vma	long
*	O
pv1	pointer
,	O
*	O
pv2	pointer
;	O
pn1	pointer
=	O
t1	pointer
->	O
u	union
.	O
kenum	pointer
->	O
names	pointer
;	O
pn2	pointer
=	O
t2	pointer
->	O
u	union
.	O
kenum	pointer
->	O
names	pointer
;	O
pv1	pointer
=	O
t1	pointer
->	O
u	union
.	O
kenum	pointer
->	O
values	pointer
;	O
pv2	pointer
=	O
t2	pointer
->	O
u	union
.	O
kenum	pointer
->	O
values	pointer
;	O
while	O
(	O
*	O
pn1	pointer
!=	O
NULL	O
&&	O
*	O
pn2	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
*	O
pn1	pointer
!=	O
*	O
*	O
pn2	pointer
||	O
*	O
pv1	pointer
!=	O
*	O
pv2	pointer
||	O
strcmp	function
(	O
*	O
pn1	pointer
,	O
*	O
pn2	pointer
)	O
!=	O
0	int
)	O
break	O
;	O
++	O
pn1	pointer
;	O
++	O
pn2	pointer
;	O
++	O
pv1	pointer
;	O
++	O
pv2	pointer
;	O
}	O
ret	pointer
=	O
*	O
pn1	pointer
==	O
NULL	O
&&	O
*	O
pn2	pointer
==	O
NULL	O
;	O
}	O
break	O
;	O
case	O
DEBUG_KIND_POINTER	int
:	O
ret	pointer
=	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
kpointer	pointer
,	O
t2	pointer
->	O
u	union
.	O
kpointer	pointer
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_FUNCTION	int
:	O
if	O
(	O
t1	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
varargs	int
!=	O
t2	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
varargs	int
||	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
return_type	pointer
,	O
t2	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
return_type	pointer
)	O
||	O
(	O
(	O
t1	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
==	O
NULL	O
)	O
!=	O
(	O
t2	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
==	O
NULL	O
)	O
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
else	O
if	O
(	O
t1	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
==	O
NULL	O
)	O
ret	pointer
=	O
TRUE	int
;	O
else	O
{	O
struct	O
debug_type_s	struct
*	O
*	O
a1	pointer
,	O
*	O
*	O
a2	pointer
;	O
a1	pointer
=	O
t1	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
;	O
a2	pointer
=	O
t2	pointer
->	O
u	union
.	O
kfunction	pointer
->	O
arg_types	pointer
;	O
while	O
(	O
*	O
a1	pointer
!=	O
NULL	O
&&	O
*	O
a2	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
*	O
a1	pointer
,	O
*	O
a2	pointer
)	O
)	O
break	O
;	O
++	O
a1	pointer
;	O
++	O
a2	pointer
;	O
}	O
ret	pointer
=	O
*	O
a1	pointer
==	O
NULL	O
&&	O
*	O
a2	pointer
==	O
NULL	O
;	O
}	O
break	O
;	O
case	O
DEBUG_KIND_REFERENCE	int
:	O
ret	pointer
=	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
kreference	pointer
,	O
t2	pointer
->	O
u	union
.	O
kreference	pointer
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_RANGE	int
:	O
ret	pointer
=	O
(	O
t1	pointer
->	O
u	union
.	O
krange	pointer
->	O
lower	long
==	O
t2	pointer
->	O
u	union
.	O
krange	pointer
->	O
lower	long
&&	O
t1	pointer
->	O
u	union
.	O
krange	pointer
->	O
upper	long
==	O
t2	pointer
->	O
u	union
.	O
krange	pointer
->	O
upper	long
&&	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
krange	pointer
->	O
type	enum
,	O
t2	pointer
->	O
u	union
.	O
krange	pointer
->	O
type	enum
)	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_ARRAY	int
:	O
ret	pointer
=	O
(	O
t1	pointer
->	O
u	union
.	O
karray	pointer
->	O
lower	long
==	O
t2	pointer
->	O
u	union
.	O
karray	pointer
->	O
lower	long
&&	O
t1	pointer
->	O
u	union
.	O
karray	pointer
->	O
upper	long
==	O
t2	pointer
->	O
u	union
.	O
karray	pointer
->	O
upper	long
&&	O
t1	pointer
->	O
u	union
.	O
karray	pointer
->	O
stringp	int
==	O
t2	pointer
->	O
u	union
.	O
karray	pointer
->	O
stringp	int
&&	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
karray	pointer
->	O
element_type	pointer
,	O
t2	pointer
->	O
u	union
.	O
karray	pointer
->	O
element_type	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_SET	int
:	O
ret	pointer
=	O
(	O
t1	pointer
->	O
u	union
.	O
kset	pointer
->	O
bitstringp	int
==	O
t2	pointer
->	O
u	union
.	O
kset	pointer
->	O
bitstringp	int
&&	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
kset	pointer
->	O
type	enum
,	O
t2	pointer
->	O
u	union
.	O
kset	pointer
->	O
type	enum
)	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_OFFSET	int
:	O
ret	pointer
=	O
(	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
koffset	pointer
->	O
base_type	pointer
,	O
t2	pointer
->	O
u	union
.	O
koffset	pointer
->	O
base_type	pointer
)	O
&&	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
koffset	pointer
->	O
target_type	pointer
,	O
t2	pointer
->	O
u	union
.	O
koffset	pointer
->	O
target_type	pointer
)	O
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_METHOD	int
:	O
if	O
(	O
t1	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
varargs	int
!=	O
t2	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
varargs	int
||	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
return_type	pointer
,	O
t2	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
return_type	pointer
)	O
||	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
domain_type	pointer
,	O
t2	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
domain_type	pointer
)	O
||	O
(	O
(	O
t1	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
==	O
NULL	O
)	O
!=	O
(	O
t2	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
==	O
NULL	O
)	O
)	O
)	O
ret	pointer
=	O
FALSE	int
;	O
else	O
if	O
(	O
t1	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
==	O
NULL	O
)	O
ret	pointer
=	O
TRUE	int
;	O
else	O
{	O
struct	O
debug_type_s	struct
*	O
*	O
a1	pointer
,	O
*	O
*	O
a2	pointer
;	O
a1	pointer
=	O
t1	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
;	O
a2	pointer
=	O
t2	pointer
->	O
u	union
.	O
kmethod	pointer
->	O
arg_types	pointer
;	O
while	O
(	O
*	O
a1	pointer
!=	O
NULL	O
&&	O
*	O
a2	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
*	O
a1	pointer
,	O
*	O
a2	pointer
)	O
)	O
break	O
;	O
++	O
a1	pointer
;	O
++	O
a2	pointer
;	O
}	O
ret	pointer
=	O
*	O
a1	pointer
==	O
NULL	O
&&	O
*	O
a2	pointer
==	O
NULL	O
;	O
}	O
break	O
;	O
case	O
DEBUG_KIND_CONST	int
:	O
ret	pointer
=	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
kconst	pointer
,	O
t2	pointer
->	O
u	union
.	O
kconst	pointer
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_VOLATILE	int
:	O
ret	pointer
=	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
kvolatile	pointer
,	O
t2	pointer
->	O
u	union
.	O
kvolatile	pointer
)	O
;	O
break	O
;	O
case	O
DEBUG_KIND_NAMED	int
:	O
case	O
DEBUG_KIND_TAGGED	int
:	O
ret	pointer
=	O
(	O
strcmp	function
(	O
t1	pointer
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
->	O
name	pointer
,	O
t2	pointer
->	O
u	union
.	O
knamed	pointer
->	O
name	pointer
->	O
name	pointer
)	O
==	O
0	int
&&	O
debug_type_samep	function
(	O
info	pointer
,	O
t1	pointer
->	O
u	union
.	O
knamed	pointer
->	O
type	enum
,	O
t2	pointer
->	O
u	union
.	O
knamed	pointer
->	O
type	enum
)	O
)	O
;	O
break	O
;	O
}	O
info	pointer
->	O
compare_list	pointer
=	O
top	struct
.	O
next	pointer
;	O
return	O
ret	pointer
;	O
}	O
static	O
bfd_boolean	int
debug_class_type_samep	function
(	O
struct	O
debug_handle	struct
*	O
info	pointer
,	O
struct	O
debug_type_s	struct
*	O
t1	pointer
,	O
struct	O
debug_type_s	struct
*	O
t2	pointer
)	O
{	O
struct	O
debug_class_type	struct
*	O
c1	pointer
,	O
*	O
c2	pointer
;	O
c1	pointer
=	O
t1	pointer
->	O
u	union
.	O
kclass	pointer
;	O
c2	pointer
=	O
t2	pointer
->	O
u	union
.	O
kclass	pointer
;	O
if	O
(	O
(	O
c1	pointer
->	O
fields	pointer
==	O
NULL	O
)	O
!=	O
(	O
c2	pointer
->	O
fields	pointer
==	O
NULL	O
)	O
||	O
(	O
c1	pointer
->	O
baseclasses	pointer
==	O
NULL	O
)	O
!=	O
(	O
c2	pointer
->	O
baseclasses	pointer
==	O
NULL	O
)	O
||	O
(	O
c1	pointer
->	O
methods	pointer
==	O
NULL	O
)	O
!=	O
(	O
c2	pointer
->	O
methods	pointer
==	O
NULL	O
)	O
||	O
(	O
c1	pointer
->	O
vptrbase	pointer
==	O
NULL	O
)	O
!=	O
(	O
c2	pointer
->	O
vptrbase	pointer
==	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
c1	pointer
->	O
fields	pointer
!=	O
NULL	O
)	O
{	O
struct	O
debug_field_s	struct
*	O
*	O
pf1	pointer
,	O
*	O
*	O
pf2	pointer
;	O
for	O
(	O
pf1	pointer
=	O
c1	pointer
->	O
fields	pointer
,	O
pf2	pointer
=	O
c2	pointer
->	O
fields	pointer
;	O
*	O
pf1	pointer
!=	O
NULL	O
&&	O
*	O
pf2	pointer
!=	O
NULL	O
;	O
pf1	pointer
++	O
,	O
pf2	pointer
++	O
)	O
{	O
struct	O
debug_field_s	struct
*	O
f1	pointer
,	O
*	O
f2	pointer
;	O
f1	pointer
=	O
*	O
pf1	pointer
;	O
f2	pointer
=	O
*	O
pf2	pointer
;	O
if	O
(	O
f1	pointer
->	O
name	pointer
[	O
0	int
]	O
!=	O
f2	pointer
->	O
name	pointer
[	O
0	int
]	O
||	O
f1	pointer
->	O
visibility	enum
!=	O
f2	pointer
->	O
visibility	enum
||	O
f1	pointer
->	O
static_member	int
!=	O
f2	pointer
->	O
static_member	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
f1	pointer
->	O
static_member	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
f1	pointer
->	O
u	union
.	O
s	pointer
.	O
physname	pointer
,	O
f2	pointer
->	O
u	union
.	O
s	pointer
.	O
physname	pointer
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
f1	pointer
->	O
u	union
.	O
f	struct
.	O
bitpos	int
!=	O
f2	pointer
->	O
u	union
.	O
f	struct
.	O
bitpos	int
||	O
f1	pointer
->	O
u	union
.	O
f	struct
.	O
bitsize	int
!=	O
f2	pointer
->	O
u	union
.	O
f	struct
.	O
bitsize	int
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
f1	pointer
->	O
name	pointer
,	O
f2	pointer
->	O
name	pointer
)	O
!=	O
0	int
||	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
debug_get_real_type	function
(	O
(	O
void	O
*	O
)	O
info	pointer
,	O
f1	pointer
->	O
type	enum
,	O
NULL	O
)	O
,	O
debug_get_real_type	function
(	O
(	O
void	O
*	O
)	O
info	pointer
,	O
f2	pointer
->	O
type	enum
,	O
NULL	O
)	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
*	O
pf1	pointer
!=	O
NULL	O
||	O
*	O
pf2	pointer
!=	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
c1	pointer
->	O
vptrbase	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
c1	pointer
->	O
vptrbase	pointer
,	O
c2	pointer
->	O
vptrbase	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
c1	pointer
->	O
baseclasses	pointer
!=	O
NULL	O
)	O
{	O
struct	O
debug_baseclass_s	struct
*	O
*	O
pb1	pointer
,	O
*	O
*	O
pb2	pointer
;	O
for	O
(	O
pb1	pointer
=	O
c1	pointer
->	O
baseclasses	pointer
,	O
pb2	pointer
=	O
c2	pointer
->	O
baseclasses	pointer
;	O
*	O
pb1	pointer
!=	O
NULL	O
&&	O
*	O
pb2	pointer
!=	O
NULL	O
;	O
++	O
pb1	pointer
,	O
++	O
pb2	pointer
)	O
{	O
struct	O
debug_baseclass_s	struct
*	O
b1	pointer
,	O
*	O
b2	pointer
;	O
b1	pointer
=	O
*	O
pb1	pointer
;	O
b2	pointer
=	O
*	O
pb2	pointer
;	O
if	O
(	O
b1	pointer
->	O
bitpos	int
!=	O
b2	pointer
->	O
bitpos	int
||	O
b1	pointer
->	O
is_virtual	int
!=	O
b2	pointer
->	O
is_virtual	int
||	O
b1	pointer
->	O
visibility	enum
!=	O
b2	pointer
->	O
visibility	enum
||	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
b1	pointer
->	O
type	enum
,	O
b2	pointer
->	O
type	enum
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
*	O
pb1	pointer
!=	O
NULL	O
||	O
*	O
pb2	pointer
!=	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
c1	pointer
->	O
methods	pointer
!=	O
NULL	O
)	O
{	O
struct	O
debug_method_s	struct
*	O
*	O
pm1	pointer
,	O
*	O
*	O
pm2	pointer
;	O
for	O
(	O
pm1	pointer
=	O
c1	pointer
->	O
methods	pointer
,	O
pm2	pointer
=	O
c2	pointer
->	O
methods	pointer
;	O
*	O
pm1	pointer
!=	O
NULL	O
&&	O
*	O
pm2	pointer
!=	O
NULL	O
;	O
++	O
pm1	pointer
,	O
++	O
pm2	pointer
)	O
{	O
struct	O
debug_method_s	struct
*	O
m1	pointer
,	O
*	O
m2	pointer
;	O
m1	pointer
=	O
*	O
pm1	pointer
;	O
m2	pointer
=	O
*	O
pm2	pointer
;	O
if	O
(	O
m1	pointer
->	O
name	pointer
[	O
0	int
]	O
!=	O
m2	pointer
->	O
name	pointer
[	O
0	int
]	O
||	O
strcmp	function
(	O
m1	pointer
->	O
name	pointer
,	O
m2	pointer
->	O
name	pointer
)	O
!=	O
0	int
||	O
(	O
m1	pointer
->	O
variants	pointer
==	O
NULL	O
)	O
!=	O
(	O
m2	pointer
->	O
variants	pointer
==	O
NULL	O
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
m1	pointer
->	O
variants	pointer
==	O
NULL	O
)	O
{	O
struct	O
debug_method_variant_s	struct
*	O
*	O
pv1	pointer
,	O
*	O
*	O
pv2	pointer
;	O
for	O
(	O
pv1	pointer
=	O
m1	pointer
->	O
variants	pointer
,	O
pv2	pointer
=	O
m2	pointer
->	O
variants	pointer
;	O
*	O
pv1	pointer
!=	O
NULL	O
&&	O
*	O
pv2	pointer
!=	O
NULL	O
;	O
++	O
pv1	pointer
,	O
++	O
pv2	pointer
)	O
{	O
struct	O
debug_method_variant_s	struct
*	O
v1	pointer
,	O
*	O
v2	pointer
;	O
v1	pointer
=	O
*	O
pv1	pointer
;	O
v2	pointer
=	O
*	O
pv2	pointer
;	O
if	O
(	O
v1	pointer
->	O
physname	pointer
[	O
0	int
]	O
!=	O
v2	pointer
->	O
physname	pointer
[	O
0	int
]	O
||	O
v1	pointer
->	O
visibility	enum
!=	O
v2	pointer
->	O
visibility	enum
||	O
v1	pointer
->	O
constp	int
!=	O
v2	pointer
->	O
constp	int
||	O
v1	pointer
->	O
volatilep	int
!=	O
v2	pointer
->	O
volatilep	int
||	O
v1	pointer
->	O
voffset	long
!=	O
v2	pointer
->	O
voffset	long
||	O
(	O
v1	pointer
->	O
context	pointer
==	O
NULL	O
)	O
!=	O
(	O
v2	pointer
->	O
context	pointer
==	O
NULL	O
)	O
||	O
strcmp	function
(	O
v1	pointer
->	O
physname	pointer
,	O
v2	pointer
->	O
physname	pointer
)	O
!=	O
0	int
||	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
v1	pointer
->	O
type	enum
,	O
v2	pointer
->	O
type	enum
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
v1	pointer
->	O
context	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
debug_type_samep	function
(	O
info	pointer
,	O
v1	pointer
->	O
context	pointer
,	O
v2	pointer
->	O
context	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
*	O
pv1	pointer
!=	O
NULL	O
||	O
*	O
pv2	pointer
!=	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
*	O
pm1	pointer
!=	O
NULL	O
||	O
*	O
pm2	pointer
!=	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
