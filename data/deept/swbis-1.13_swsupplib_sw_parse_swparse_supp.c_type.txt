extern	O
int	O
swparse_outputfd	int
;	O
int	O
swparse_construct_attribute	function
(	O
STROB	struct
*	O
strb	pointer
,	O
int	O
uxfio_ofd	int
,	O
char	O
*	O
src	pointer
,	O
int	O
cmd	int
,	O
int	O
level	int
,	O
char	O
s_keytype	char
,	O
int	O
form_flag	int
)	O
;	O
static	O
int	O
do_indent_only	function
(	O
STROB	struct
*	O
strb	pointer
,	O
int	O
outputfd	int
,	O
int	O
level	int
)	O
;	O
static	O
int	O
do_not_warn_utf	int
;	O
static	O
void	O
squash_non_ascii_chars	function
(	O
unsigned	O
char	O
*	O
ptr	pointer
)	O
{	O
unsigned	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
ptr	pointer
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
<=	O
127	int
)	O
{	O
;	O
}	O
else	O
{	O
memmove	function
(	O
s	pointer
,	O
s	pointer
+	O
1	int
,	O
(	O
size_t	long
)	O
(	O
strlen	function
(	O
(	O
char	O
*	O
)	O
(	O
s	pointer
+	O
1	int
)	O
)	O
+	O
1	int
)	O
)	O
;	O
}	O
s	pointer
++	O
;	O
}	O
}	O
static	O
void	O
check_keyword	function
(	O
char	O
*	O
w	pointer
)	O
{	O
}	O
static	O
int	O
check_ignores	function
(	O
char	O
*	O
line	pointer
,	O
char	O
*	O
*	O
ignores	pointer
)	O
{	O
char	O
*	O
*	O
sp	pointer
=	O
ignores	pointer
;	O
while	O
(	O
*	O
sp	pointer
)	O
{	O
if	O
(	O
strncmp	function
(	O
line	pointer
,	O
*	O
sp	pointer
,	O
strlen	function
(	O
*	O
sp	pointer
)	O
)	O
==	O
0	int
)	O
return	O
1	int
;	O
sp	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
do_indent_only	function
(	O
STROB	struct
*	O
strb	pointer
,	O
int	O
outputfd	int
,	O
int	O
level	int
)	O
{	O
char	O
*	O
keyword	pointer
=	O
strob_get_str	function
(	O
strb	pointer
)	O
;	O
char	O
*	O
value	int
=	O
strchr	function
(	O
strob_get_str	function
(	O
strb	pointer
)	O
,	O
(	O
int	O
)	O
' '	O
)	O
;	O
if	O
(	O
value	int
)	O
{	O
*	O
value	int
=	O
'\0'	O
;	O
value	int
++	O
;	O
return	O
swdef_write_attribute	function
(	O
keyword	pointer
,	O
value	int
,	O
level	int
,	O
0	int
,	O
'A'	O
,	O
outputfd	int
)	O
;	O
}	O
else	O
{	O
return	O
swdef_write_attribute	function
(	O
keyword	pointer
,	O
value	int
,	O
level	int
,	O
(	O
int	O
)	O
0	int
,	O
'O'	O
,	O
outputfd	int
)	O
;	O
}	O
}	O
int	O
swparse_write_attribute_att	function
(	O
int	O
outputfd	int
,	O
char	O
*	O
key	pointer
,	O
char	O
*	O
val	array
,	O
int	O
level	int
,	O
int	O
form_flag	int
)	O
{	O
int	O
ret	int
,	O
newlen	pointer
;	O
STROB	struct
*	O
strb	pointer
;	O
char	O
*	O
p	pointer
;	O
strb	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
check_keyword	function
(	O
key	pointer
)	O
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
key	pointer
)	O
;	O
strob_strcat	function
(	O
strb	pointer
,	O
" "	pointer
)	O
;	O
swparse_expand_n	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
&	O
p	pointer
)	O
,	O
&	O
newlen	pointer
,	O
val	array
)	O
;	O
strob_strcat	function
(	O
strb	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
swbis_free	O
(	O
p	pointer
)	O
;	O
ret	int
=	O
swparse_construct_attribute	function
(	O
strb	pointer
,	O
outputfd	int
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
,	O
SWPARSE_ACMD_EMIT	int
,	O
level	int
,	O
SWPARSE_MD_TYPE_ATT	char
,	O
form_flag	int
)	O
;	O
strob_close	function
(	O
strb	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swparse_ignore_attribute	function
(	O
int	O
filetype	pointer
,	O
int	O
location	int
,	O
char	O
*	O
line	pointer
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
psf_file_ignores	array
[	O
]	O
=	O
{	O
"cksum "	pointer
,	O
"compressed_cksum "	pointer
,	O
"compressed_size "	pointer
,	O
"compression_state "	pointer
,	O
"compression_type "	pointer
,	O
"size "	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
psf_fileset_ignores	array
[	O
]	O
=	O
{	O
"location "	pointer
,	O
"media_sequence_number "	pointer
,	O
"size "	pointer
,	O
"state "	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
psf_bundle_ignores	array
[	O
]	O
=	O
{	O
"location "	pointer
,	O
"qualifier "	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
psf_distribution_ignores	array
[	O
]	O
=	O
{	O
"uuid "	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
info_file_ignores	array
[	O
]	O
=	O
{	O
"source "	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
index_ignores	array
[	O
]	O
=	O
{	O
"size "	pointer
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
if	O
(	O
filetype	pointer
==	O
SWPARSE_SWDEF_FILETYPE_INFO	int
)	O
{	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_FILE	int
)	O
{	O
ret	int
=	O
check_ignores	function
(	O
line	pointer
,	O
info_file_ignores	array
)	O
;	O
}	O
}	O
else	O
if	O
(	O
filetype	pointer
==	O
SWPARSE_SWDEF_FILETYPE_PSF	int
)	O
{	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_FILE	int
)	O
{	O
ret	int
=	O
check_ignores	function
(	O
line	pointer
,	O
psf_file_ignores	array
)	O
;	O
}	O
else	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_CONTROL_FILE	int
)	O
{	O
ret	int
=	O
check_ignores	function
(	O
line	pointer
,	O
psf_file_ignores	array
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
ret	int
=	O
!	O
strncmp	function
(	O
line	pointer
,	O
"result "	pointer
,	O
strlen	function
(	O
"result "	pointer
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_FILESET	int
)	O
{	O
ret	int
=	O
check_ignores	function
(	O
line	pointer
,	O
psf_fileset_ignores	array
)	O
;	O
}	O
else	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_BUNDLE	int
)	O
{	O
ret	int
=	O
check_ignores	function
(	O
line	pointer
,	O
psf_bundle_ignores	array
)	O
;	O
}	O
else	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_DISTRIBUTION	int
)	O
{	O
ret	int
=	O
check_ignores	function
(	O
line	pointer
,	O
psf_distribution_ignores	array
)	O
;	O
}	O
}	O
else	O
if	O
(	O
filetype	pointer
==	O
SWPARSE_SWDEF_FILETYPE_INDEX	int
)	O
{	O
ret	int
=	O
check_ignores	function
(	O
line	pointer
,	O
index_ignores	array
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
swparse_write_attribute_obj	function
(	O
int	O
outputfd	int
,	O
char	O
*	O
key	pointer
,	O
int	O
level	int
,	O
int	O
form_flag	int
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
strb	pointer
;	O
check_keyword	function
(	O
key	pointer
)	O
;	O
if	O
(	O
form_flag	int
&	O
SWPARSE_FORM_INDENT	O
)	O
{	O
return	O
swdef_write_keyword	function
(	O
key	pointer
,	O
level	int
,	O
'O'	O
,	O
outputfd	int
)	O
;	O
}	O
strb	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
key	pointer
)	O
;	O
ret	int
=	O
swparse_construct_attribute	function
(	O
strb	pointer
,	O
outputfd	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
SWPARSE_ACMD_EMIT	int
,	O
level	int
,	O
SWPARSE_MD_TYPE_OBJ	char
,	O
form_flag	int
)	O
;	O
strob_close	function
(	O
strb	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swparse_set_do_not_warn_utf	function
(	O
void	O
)	O
{	O
do_not_warn_utf	int
=	O
1	int
;	O
}	O
void	O
swparse_unset_do_not_warn_utf	function
(	O
void	O
)	O
{	O
do_not_warn_utf	int
=	O
0	int
;	O
}	O
int	O
swparse_construct_attribute	function
(	O
STROB	struct
*	O
strb	pointer
,	O
int	O
outputfd	int
,	O
char	O
*	O
src	pointer
,	O
int	O
cmd	int
,	O
int	O
level	int
,	O
char	O
s_keytype	char
,	O
int	O
form_flag	int
)	O
{	O
static	O
STROB	struct
*	O
ustore	pointer
;	O
char	O
*	O
ptr	pointer
,	O
*	O
eptr	pointer
;	O
char	O
*	O
p	pointer
;	O
char	O
l_swws	array
[	O
]	O
=	O
"                                       "	pointer
;	O
int	O
newlen	pointer
,	O
ret	int
=	O
0	int
,	O
value_length	int
;	O
int	O
extra_len	int
;	O
if	O
(	O
level	int
>	O
10	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
form_flag	int
&	O
SWPARSE_FORM_INDENT	O
)	O
&&	O
cmd	int
==	O
SWPARSE_ACMD_EMIT	int
)	O
{	O
return	O
do_indent_only	function
(	O
strb	pointer
,	O
outputfd	int
,	O
level	int
)	O
;	O
}	O
l_swws	array
[	O
level	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
form_flag	int
&	O
SWPARSE_FORM_MKUP	O
)	O
||	O
(	O
(	O
form_flag	int
&	O
SWPARSE_FORM_ALL	O
)	O
==	O
0	int
)	O
)	O
{	O
extra_len	int
=	O
0	int
;	O
}	O
else	O
{	O
extra_len	int
=	O
SWPARSE_MKUP_RES	int
;	O
}	O
if	O
(	O
cmd	int
==	O
SWPARSE_ACMD_COPY	int
)	O
{	O
swparse_expand_n	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
&	O
p	pointer
)	O
,	O
&	O
newlen	pointer
,	O
src	pointer
)	O
;	O
strob_strcpy	function
(	O
strb	pointer
,	O
p	pointer
)	O
;	O
swbis_free	O
(	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
cmd	int
==	O
SWPARSE_ACMD_CAT	int
)	O
{	O
swparse_expand_n	function
(	O
(	O
void	O
*	O
*	O
)	O
(	O
&	O
p	pointer
)	O
,	O
&	O
newlen	pointer
,	O
src	pointer
)	O
;	O
strob_strcat	function
(	O
strb	pointer
,	O
p	pointer
)	O
;	O
swbis_free	O
(	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
cmd	int
==	O
SWPARSE_ACMD_EMIT	int
)	O
{	O
int	O
memlen	int
;	O
ptr	pointer
=	O
strob_str	function
(	O
strb	pointer
)	O
;	O
if	O
(	O
!	O
strlen	function
(	O
ptr	pointer
)	O
)	O
{	O
strob_strcat	function
(	O
strb	pointer
,	O
"\"\""	pointer
)	O
;	O
ptr	pointer
=	O
strob_str	function
(	O
strb	pointer
)	O
;	O
}	O
swlib_process_hex_escapes	function
(	O
ptr	pointer
)	O
;	O
if	O
(	O
utf8_valid	function
(	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
ptr	pointer
,	O
(	O
unsigned	O
int	O
)	O
strlen	function
(	O
ptr	pointer
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
ustore	pointer
)	O
ustore	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
swlib_expand_escapes	function
(	O
NULL	O
,	O
NULL	O
,	O
ptr	pointer
,	O
ustore	pointer
)	O
;	O
if	O
(	O
do_not_warn_utf	int
==	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: invalid UTF-8 characters: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strob_str	function
(	O
ustore	pointer
)	O
)	O
;	O
}	O
memlen	int
=	O
strlen	function
(	O
ptr	pointer
)	O
+	O
level	int
+	O
6	int
+	O
extra_len	int
;	O
eptr	pointer
=	O
malloc	function
(	O
memlen	int
)	O
;	O
strob_setlen	function
(	O
strb	pointer
,	O
memlen	int
)	O
;	O
ptr	pointer
=	O
strob_str	function
(	O
strb	pointer
)	O
;	O
if	O
(	O
form_flag	int
&	O
SWPARSE_FORM_MKUP	O
)	O
{	O
snprintf	function
(	O
eptr	pointer
,	O
memlen	int
,	O
"%c%02d%s%s\n"	pointer
,	O
s_keytype	char
,	O
level	int
,	O
l_swws	array
,	O
ptr	pointer
)	O
;	O
eptr	pointer
[	O
memlen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
form_flag	int
&	O
SWPARSE_FORM_MKUP_LEN	O
)	O
{	O
p	pointer
=	O
ptr	pointer
;	O
while	O
(	O
*	O
p	pointer
&&	O
!	O
isspace	function
(	O
(	O
int	O
)	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
p	pointer
++	O
;	O
value_length	int
=	O
strlen	function
(	O
p	pointer
)	O
;	O
snprintf	function
(	O
eptr	pointer
,	O
memlen	int
,	O
"%-"	pointer
SWPARSE_MKUP_LEN_WIDTH_C	pointer
"d %c%02d %s\n"	pointer
,	O
value_length	int
,	O
s_keytype	char
,	O
level	int
,	O
ptr	pointer
)	O
;	O
eptr	pointer
[	O
memlen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
ret	int
=	O
uxfio_write	function
(	O
outputfd	int
,	O
eptr	pointer
,	O
strlen	function
(	O
eptr	pointer
)	O
)	O
;	O
swbis_free	O
(	O
eptr	pointer
)	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
swparse_print_filename	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
char	O
*	O
filetype	pointer
,	O
char	O
*	O
ws_level_string	pointer
,	O
char	O
*	O
lex_filename	pointer
,	O
int	O
form_flag	int
)	O
{	O
int	O
value_length	int
;	O
if	O
(	O
form_flag	int
&	O
SWPARSE_FORM_MKUP	O
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
len	int
,	O
"F%02d %s%s %s\n"	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
ws_level_string	pointer
)	O
+	O
1	int
,	O
ws_level_string	pointer
,	O
filetype	pointer
,	O
lex_filename	pointer
)	O
;	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
uxfio_write	function
(	O
swparse_outputfd	int
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
else	O
{	O
value_length	int
=	O
strlen	function
(	O
lex_filename	pointer
)	O
;	O
snprintf	function
(	O
buf	pointer
,	O
len	int
,	O
"%-"	pointer
SWPARSE_MKUP_LEN_WIDTH_C	pointer
"d F%02d %s%s %s\n"	pointer
,	O
(	O
int	O
)	O
value_length	int
,	O
(	O
int	O
)	O
strlen	function
(	O
ws_level_string	pointer
)	O
+	O
1	int
,	O
ws_level_string	pointer
,	O
filetype	pointer
,	O
lex_filename	pointer
)	O
;	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
uxfio_write	function
(	O
swparse_outputfd	int
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swparse_print_filename_by_fd	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
int	O
fd	int
,	O
char	O
*	O
filetype	pointer
,	O
char	O
*	O
ws_level_string	pointer
,	O
char	O
*	O
lex_filename	pointer
,	O
int	O
form_flag	int
)	O
{	O
{	O
swparse_outputfd	int
=	O
fd	int
;	O
return	O
swparse_print_filename	function
(	O
buf	pointer
,	O
len	int
,	O
filetype	pointer
,	O
ws_level_string	pointer
,	O
lex_filename	pointer
,	O
form_flag	int
)	O
;	O
}	O
}	O
int	O
utf8_valid	function
(	O
const	O
unsigned	O
char	O
*	O
buf	pointer
,	O
unsigned	O
int	O
len	int
)	O
{	O
const	O
unsigned	O
char	O
*	O
endbuf	pointer
=	O
buf	pointer
+	O
len	int
;	O
unsigned	O
char	O
byte2mask	char
=	O
0x00	int
,	O
c	int
;	O
int	O
trailing	int
=	O
0	int
;	O
while	O
(	O
buf	pointer
!=	O
endbuf	pointer
)	O
{	O
c	int
=	O
*	O
buf	pointer
++	O
;	O
if	O
(	O
trailing	int
)	O
{	O
if	O
(	O
(	O
c	int
&	O
0xC0	int
)	O
==	O
0x80	int
)	O
{	O
if	O
(	O
byte2mask	char
)	O
{	O
if	O
(	O
c	int
&	O
byte2mask	char
)	O
byte2mask	char
=	O
0x00	int
;	O
else	O
return	O
0	int
;	O
}	O
trailing	int
--	O
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
c	int
&	O
0x80	int
)	O
==	O
0x00	int
)	O
continue	O
;	O
else	O
if	O
(	O
(	O
c	int
&	O
0xE0	int
)	O
==	O
0xC0	int
)	O
if	O
(	O
c	int
&	O
0x1E	int
)	O
trailing	int
=	O
1	int
;	O
else	O
return	O
0	int
;	O
else	O
if	O
(	O
(	O
c	int
&	O
0xF0	int
)	O
==	O
0xE0	int
)	O
{	O
if	O
(	O
!	O
(	O
c	int
&	O
0x0F	int
)	O
)	O
byte2mask	char
=	O
0x20	int
;	O
trailing	int
=	O
2	int
;	O
}	O
else	O
if	O
(	O
(	O
c	int
&	O
0xF8	int
)	O
==	O
0xF0	int
)	O
{	O
if	O
(	O
!	O
(	O
c	int
&	O
0x07	int
)	O
)	O
byte2mask	char
=	O
0x30	int
;	O
trailing	int
=	O
3	int
;	O
}	O
else	O
if	O
(	O
(	O
c	int
&	O
0xFC	int
)	O
==	O
0xF8	int
)	O
{	O
if	O
(	O
!	O
(	O
c	int
&	O
0x03	int
)	O
)	O
byte2mask	char
=	O
0x38	int
;	O
trailing	int
=	O
4	int
;	O
}	O
else	O
if	O
(	O
(	O
c	int
&	O
0xFE	int
)	O
==	O
0xFC	int
)	O
{	O
if	O
(	O
!	O
(	O
c	int
&	O
0x01	int
)	O
)	O
byte2mask	char
=	O
0x3C	int
;	O
trailing	int
=	O
5	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
return	O
trailing	int
==	O
0	int
;	O
}	O
