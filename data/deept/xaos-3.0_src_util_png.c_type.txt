char	O
*	O
writepng	function
(	O
FILE	O
*	O
file	pointer
,	O
struct	O
image	pointer
*	O
image	pointer
)	O
{	O
png_structp	O
png_ptr	O
;	O
png_infop	O
info_ptr	O
;	O
png_color	O
palette	O
[	O
256	int
]	O
;	O
volatile	O
unsigned	O
short	O
a	short
=	O
255	int
;	O
volatile	O
unsigned	O
char	O
*	O
b	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
a	short
;	O
static	O
char	O
text	array
[	O
]	O
=	O
"XaoS"	pointer
XaoS_VERSION	O
" - an realtime interactive fractal zoomer"	pointer
;	O
static	O
png_text	O
comments	array
[	O
]	O
=	O
{	O
{	O
-	O
1	int
,	O
"Software"	pointer
,	O
text	array
,	O
sizeof	O
(	O
text	array
)	O
}	O
}	O
;	O
errno	O
=	O
-	O
1	int
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
{	O
return	O
strerror	O
(	O
errno	O
)	O
;	O
}	O
png_ptr	O
=	O
png_create_write_struct	function
(	O
PNG_LIBPNG_VER_STRING	O
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
(	O
png_error_ptr	O
)	O
NULL	O
,	O
(	O
png_error_ptr	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
png_ptr	O
)	O
return	O
"Unable to initialize pnglib"	pointer
;	O
info_ptr	O
=	O
png_create_info_struct	function
(	O
png_ptr	O
)	O
;	O
if	O
(	O
!	O
info_ptr	O
)	O
{	O
png_destroy_write_struct	function
(	O
&	O
png_ptr	O
,	O
(	O
png_infopp	O
)	O
NULL	O
)	O
;	O
return	O
"No memory to create png info structure"	pointer
;	O
}	O
if	O
(	O
setjmp	function
(	O
png_ptr	O
->	O
jmpbuf	O
)	O
)	O
{	O
png_destroy_write_struct	function
(	O
&	O
png_ptr	O
,	O
&	O
info_ptr	O
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
return	O
strerror	O
(	O
errno	O
)	O
;	O
}	O
png_init_io	function
(	O
png_ptr	O
,	O
file	pointer
)	O
;	O
png_set_filter	function
(	O
png_ptr	O
,	O
0	int
,	O
PNG_FILTER_NONE	O
|	O
PNG_FILTER_SUB	O
|	O
PNG_FILTER_PAETH	O
|	O
PNG_FILTER_UP	O
|	O
PNG_FILTER_AVG	O
)	O
;	O
png_set_compression_level	function
(	O
png_ptr	O
,	O
Z_DEFAULT_COMPRESSION	O
)	O
;	O
png_set_compression_mem_level	function
(	O
png_ptr	O
,	O
8	int
)	O
;	O
png_set_compression_strategy	function
(	O
png_ptr	O
,	O
Z_DEFAULT_STRATEGY	O
)	O
;	O
png_set_compression_window_bits	function
(	O
png_ptr	O
,	O
15	int
)	O
;	O
png_set_compression_method	function
(	O
png_ptr	O
,	O
8	int
)	O
;	O
info_ptr	O
->	O
width	O
=	O
image	pointer
->	O
width	O
;	O
info_ptr	O
->	O
height	O
=	O
image	pointer
->	O
height	O
;	O
info_ptr	O
->	O
gamma	O
=	O
0.5	int
;	O
info_ptr	O
->	O
valid	O
|=	O
PNG_INFO_gAMA	O
|	O
PNG_INFO_pHYs	O
;	O
info_ptr	O
->	O
x_pixels_per_unit	O
=	O
100	int
/	O
image	pointer
->	O
pixelwidth	O
;	O
info_ptr	O
->	O
y_pixels_per_unit	O
=	O
100	int
/	O
image	pointer
->	O
pixelheight	O
;	O
switch	O
(	O
image	pointer
->	O
palette	O
->	O
type	O
)	O
{	O
case	O
C256	O
:	O
{	O
int	O
i	int
;	O
info_ptr	O
->	O
color_type	O
=	O
PNG_COLOR_TYPE_PALETTE	O
;	O
info_ptr	O
->	O
bit_depth	O
=	O
image	pointer
->	O
bytesperpixel	O
*	O
8	int
;	O
info_ptr	O
->	O
palette	O
=	O
palette	O
;	O
info_ptr	O
->	O
valid	O
|=	O
PNG_INFO_PLTE	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
image	pointer
->	O
palette	O
->	O
end	O
;	O
i	int
++	O
)	O
info_ptr	O
->	O
palette	O
[	O
i	int
]	O
.	O
red	O
=	O
image	pointer
->	O
palette	O
->	O
rgb	O
[	O
i	int
]	O
[	O
0	int
]	O
,	O
info_ptr	O
->	O
palette	O
[	O
i	int
]	O
.	O
green	O
=	O
image	pointer
->	O
palette	O
->	O
rgb	O
[	O
i	int
]	O
[	O
1	int
]	O
,	O
info_ptr	O
->	O
palette	O
[	O
i	int
]	O
.	O
blue	O
=	O
image	pointer
->	O
palette	O
->	O
rgb	O
[	O
i	int
]	O
[	O
2	int
]	O
,	O
info_ptr	O
->	O
num_palette	O
=	O
image	pointer
->	O
palette	O
->	O
end	O
;	O
}	O
break	O
;	O
case	O
SMALLITER	O
:	O
case	O
LARGEITER	O
:	O
case	O
GRAYSCALE	O
:	O
info_ptr	O
->	O
color_type	O
=	O
PNG_COLOR_TYPE_GRAY	O
;	O
info_ptr	O
->	O
bit_depth	O
=	O
image	pointer
->	O
bytesperpixel	O
*	O
8	int
;	O
break	O
;	O
case	O
TRUECOLOR	O
:	O
case	O
TRUECOLORMI	O
:	O
case	O
TRUECOLOR24	O
:	O
case	O
HICOLOR	O
:	O
case	O
REALCOLOR	O
:	O
info_ptr	O
->	O
color_type	O
=	O
PNG_COLOR_TYPE_RGB	O
;	O
info_ptr	O
->	O
bit_depth	O
=	O
8	int
;	O
if	O
(	O
image	pointer
->	O
palette	O
->	O
type	O
&	O
(	O
TRUECOLOR	O
|	O
TRUECOLOR24	O
|	O
TRUECOLORMI	O
)	O
)	O
{	O
info_ptr	O
->	O
sig_bit	O
.	O
red	O
=	O
8	int
;	O
info_ptr	O
->	O
sig_bit	O
.	O
green	O
=	O
8	int
;	O
info_ptr	O
->	O
sig_bit	O
.	O
blue	O
=	O
8	int
;	O
}	O
else	O
{	O
info_ptr	O
->	O
sig_bit	O
.	O
red	O
=	O
5	int
;	O
info_ptr	O
->	O
sig_bit	O
.	O
green	O
=	O
5	int
;	O
info_ptr	O
->	O
sig_bit	O
.	O
blue	O
=	O
5	int
;	O
if	O
(	O
image	pointer
->	O
palette	O
->	O
type	O
==	O
HICOLOR	O
)	O
info_ptr	O
->	O
sig_bit	O
.	O
green	O
=	O
6	int
;	O
}	O
break	O
;	O
}	O
info_ptr	O
->	O
interlace_type	O
=	O
0	int
;	O
info_ptr	O
->	O
num_text	O
=	O
sizeof	O
(	O
comments	array
)	O
/	O
sizeof	O
(	O
png_text	O
)	O
;	O
info_ptr	O
->	O
text	array
=	O
comments	array
;	O
png_write_info	function
(	O
png_ptr	O
,	O
info_ptr	O
)	O
;	O
png_set_packing	function
(	O
png_ptr	O
)	O
;	O
if	O
(	O
image	pointer
->	O
palette	O
->	O
type	O
&	O
(	O
HICOLOR	O
|	O
REALCOLOR	O
|	O
TRUECOLOR	O
|	O
TRUECOLOR24	O
|	O
TRUECOLORMI	O
)	O
)	O
png_set_shift	function
(	O
png_ptr	O
,	O
&	O
(	O
info_ptr	O
->	O
sig_bit	O
)	O
)	O
;	O
if	O
(	O
*	O
b	pointer
==	O
255	int
)	O
png_set_swap	function
(	O
png_ptr	O
)	O
;	O
png_set_bgr	function
(	O
png_ptr	O
)	O
;	O
switch	O
(	O
image	pointer
->	O
palette	O
->	O
type	O
)	O
{	O
case	O
C256	O
:	O
case	O
GRAYSCALE	O
:	O
case	O
SMALLITER	O
:	O
case	O
LARGEITER	O
:	O
case	O
TRUECOLOR	O
:	O
{	O
int	O
i	int
,	O
y	int
;	O
unsigned	O
char	O
*	O
r	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
malloc	function
(	O
image	pointer
->	O
width	O
*	O
3	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
image	pointer
->	O
height	O
;	O
i	int
++	O
)	O
{	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
image	pointer
->	O
width	O
;	O
y	int
++	O
)	O
r	pointer
[	O
y	int
*	O
3	int
]	O
=	O
(	O
(	O
pixel32_t	O
*	O
*	O
)	O
image	pointer
->	O
currlines	O
)	O
[	O
i	int
]	O
[	O
y	int
]	O
&	O
255	int
,	O
r	pointer
[	O
y	int
*	O
3	int
+	O
1	int
]	O
=	O
(	O
(	O
(	O
pixel32_t	O
*	O
*	O
)	O
image	pointer
->	O
currlines	O
)	O
[	O
i	int
]	O
[	O
y	int
]	O
>>	O
8	int
)	O
&	O
255	int
,	O
r	pointer
[	O
y	int
*	O
3	int
+	O
2	int
]	O
=	O
(	O
(	O
(	O
pixel32_t	O
*	O
*	O
)	O
image	pointer
->	O
currlines	O
)	O
[	O
i	int
]	O
[	O
y	int
]	O
>>	O
16	int
)	O
&	O
255	int
;	O
png_write_rows	function
(	O
png_ptr	O
,	O
(	O
png_bytepp	O
)	O
&	O
r	pointer
,	O
1	int
)	O
;	O
}	O
}	O
break	O
;	O
}	O
png_write_end	function
(	O
png_ptr	O
,	O
info_ptr	O
)	O
;	O
png_destroy_write_struct	function
(	O
&	O
png_ptr	O
,	O
&	O
info_ptr	O
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
