static	O
SWICAT_PRE_SET	struct
*	O
swicat_pre_set_create	function
(	O
void	O
)	O
{	O
SWICAT_PRE_SET	struct
*	O
pre_set	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
SWICAT_PRE_SET	struct
)	O
)	O
;	O
pre_set	pointer
->	O
preM	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
pre_set	pointer
->	O
pre_fullfilledM	pointer
=	O
strar_open	function
(	O
)	O
;	O
return	O
pre_set	pointer
;	O
}	O
static	O
SWICAT_EX_SET	struct
*	O
swicat_ex_set_create	function
(	O
void	O
)	O
{	O
SWICAT_EX_SET	struct
*	O
ex_set	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
SWICAT_EX_SET	struct
)	O
)	O
;	O
ex_set	pointer
->	O
exM	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
ex_set	pointer
->	O
ex_violatedM	pointer
=	O
strar_open	function
(	O
)	O
;	O
return	O
ex_set	pointer
;	O
}	O
static	O
void	O
swicat_pre_set_delete	function
(	O
SWICAT_PRE_SET	struct
*	O
pre_set	pointer
)	O
{	O
strob_close	function
(	O
pre_set	pointer
->	O
preM	pointer
)	O
;	O
strar_close	function
(	O
pre_set	pointer
->	O
pre_fullfilledM	pointer
)	O
;	O
}	O
static	O
char	O
*	O
get_req_type	function
(	O
char	O
*	O
line	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
line	pointer
;	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
s	pointer
;	O
s	pointer
++	O
;	O
return	O
s	pointer
;	O
}	O
static	O
char	O
*	O
check_requisite_response	function
(	O
char	O
*	O
line	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
line	pointer
;	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
s	pointer
;	O
s	pointer
++	O
;	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
s	pointer
;	O
s	pointer
++	O
;	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
s	pointer
;	O
s	pointer
++	O
;	O
s	pointer
=	O
strchr	function
(	O
s	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
s	pointer
;	O
s	pointer
++	O
;	O
return	O
s	pointer
;	O
}	O
static	O
void	O
add_path_code	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"export SWPATH\n"	pointer
"gpath=$(getconf PATH)\n"	pointer
"case \"$gpath\" in\n"	pointer
"	\"\")\n"	pointer
"		SWPATH=\"$PATH\"\n"	pointer
"		;;\n"	pointer
"	*)\n"	pointer
"		SWPATH=\"${gpath}:${PATH}\"\n"	pointer
"		;;\n"	pointer
"esac\n"	pointer
)	O
;	O
}	O
static	O
char	O
*	O
evaluate_query	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICAT_REQ	struct
*	O
req	pointer
,	O
char	O
*	O
spec	pointer
,	O
STROB	struct
*	O
text	pointer
,	O
char	O
*	O
first_line	pointer
,	O
int	O
*	O
err	long
,	O
SWICAT_SL	struct
*	O
swicat_sl	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
ret	pointer
;	O
char	O
*	O
type	enum
;	O
STROB	struct
*	O
tmp	pointer
;	O
int	O
num	int
;	O
char	O
*	O
resp	pointer
;	O
SWICAT_PRE_SET	struct
*	O
pre_set	pointer
;	O
SWICAT_EX_SET	struct
*	O
ex_set	pointer
;	O
SWICAT_SC	struct
*	O
sc	pointer
;	O
sc	pointer
=	O
NULL	O
;	O
pre_set	pointer
=	O
NULL	O
;	O
ex_set	pointer
=	O
NULL	O
;	O
*	O
err	long
=	O
0	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
12	int
)	O
;	O
line	pointer
=	O
first_line	pointer
;	O
s	pointer
=	O
line	pointer
;	O
s	pointer
++	O
;	O
num	int
=	O
swlib_atoi	function
(	O
s	pointer
,	O
&	O
ret	pointer
)	O
;	O
if	O
(	O
ret	pointer
!=	O
0	int
)	O
{	O
*	O
err	long
=	O
1	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
swicat_sl	pointer
)	O
{	O
SWICAT_SQ	struct
*	O
sq	pointer
=	O
swicat_sq_create	function
(	O
)	O
;	O
sc	pointer
=	O
swicat_sc_create	function
(	O
)	O
;	O
swicat_sq_parse	function
(	O
sq	pointer
,	O
line	pointer
)	O
;	O
swicat_sc_set_sq	function
(	O
sc	pointer
,	O
sq	pointer
)	O
;	O
swicat_sl_add_sc	function
(	O
swicat_sl	pointer
,	O
sc	pointer
)	O
;	O
}	O
type	enum
=	O
get_req_type	function
(	O
line	pointer
)	O
;	O
if	O
(	O
type	enum
==	O
NULL	O
)	O
{	O
*	O
err	long
=	O
1	int
;	O
return	O
NULL	O
;	O
}	O
switch	O
(	O
*	O
type	enum
)	O
{	O
case	O
'P'	O
:	O
pre_set	pointer
=	O
swicat_pre_set_create	function
(	O
)	O
;	O
strob_strcpy	function
(	O
pre_set	pointer
->	O
preM	pointer
,	O
spec	pointer
)	O
;	O
vplob_add	function
(	O
req	pointer
->	O
pre_set_arrayM	pointer
,	O
pre_set	pointer
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
ex_set	pointer
=	O
swicat_ex_set_create	function
(	O
)	O
;	O
strob_strcpy	function
(	O
ex_set	pointer
->	O
exM	pointer
,	O
spec	pointer
)	O
;	O
vplob_add	function
(	O
req	pointer
->	O
ex_set_arrayM	pointer
,	O
ex_set	pointer
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
break	O
;	O
default	O
:	O
*	O
err	long
=	O
1	int
;	O
return	O
NULL	O
;	O
break	O
;	O
}	O
line	pointer
=	O
strob_strtok	function
(	O
text	pointer
,	O
NULL	O
,	O
"\r\n"	pointer
)	O
;	O
while	O
(	O
line	pointer
)	O
{	O
E_DEBUG2	O
(	O
"line=[%s]"	pointer
,	O
line	pointer
)	O
;	O
if	O
(	O
swicat_sl	pointer
)	O
{	O
SWICAT_SR	struct
*	O
sr	pointer
=	O
swicat_sr_create	function
(	O
)	O
;	O
swicat_sr_parse	function
(	O
sr	pointer
,	O
line	pointer
)	O
;	O
swicat_sc_add_sr	function
(	O
sc	pointer
,	O
sr	pointer
)	O
;	O
}	O
resp	pointer
=	O
check_requisite_response	function
(	O
line	pointer
)	O
;	O
E_DEBUG2	O
(	O
"resp=[%s]"	pointer
,	O
resp	pointer
)	O
;	O
switch	O
(	O
*	O
type	enum
)	O
{	O
case	O
'P'	O
:	O
if	O
(	O
resp	pointer
==	O
NULL	O
)	O
{	O
strar_add	function
(	O
req	pointer
->	O
failed_preM	pointer
,	O
spec	pointer
)	O
;	O
req	pointer
->	O
pre_resultM	int
=	O
1	int
;	O
}	O
else	O
{	O
strar_add	function
(	O
pre_set	pointer
->	O
pre_fullfilledM	pointer
,	O
resp	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'E'	O
:	O
if	O
(	O
resp	pointer
!=	O
NULL	O
)	O
{	O
strar_add	function
(	O
ex_set	pointer
->	O
ex_violatedM	pointer
,	O
resp	pointer
)	O
;	O
req	pointer
->	O
ex_resultM	int
=	O
1	int
;	O
}	O
else	O
{	O
strar_add	function
(	O
req	pointer
->	O
passed_exM	pointer
,	O
spec	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'C'	O
:	O
if	O
(	O
resp	pointer
==	O
NULL	O
)	O
{	O
strar_add	function
(	O
req	pointer
->	O
failed_coM	pointer
,	O
spec	pointer
)	O
;	O
req	pointer
->	O
co_resultM	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
line	pointer
=	O
strob_strtok	function
(	O
text	pointer
,	O
NULL	O
,	O
"\r\n"	pointer
)	O
;	O
if	O
(	O
line	pointer
&&	O
swlib_atoi	function
(	O
line	pointer
+	O
1	int
,	O
&	O
ret	pointer
)	O
==	O
num	int
&&	O
ret	pointer
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
line	pointer
;	O
}	O
void	O
shpat_to_regex	function
(	O
STROB	struct
*	O
buf	pointer
,	O
char	O
*	O
shell_pattern	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
i	int
;	O
i	int
=	O
0	int
;	O
strob_strcpy	function
(	O
buf	pointer
,	O
""	pointer
)	O
;	O
s	pointer
=	O
shell_pattern	pointer
;	O
strob_chr_index	function
(	O
buf	pointer
,	O
i	int
++	O
,	O
(	O
int	O
)	O
(	O
'^'	O
)	O
)	O
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'?'	O
)	O
{	O
strob_chr_index	function
(	O
buf	pointer
,	O
i	int
++	O
,	O
(	O
int	O
)	O
(	O
'.'	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'+'	O
)	O
{	O
strob_chr_index	function
(	O
buf	pointer
,	O
i	int
++	O
,	O
(	O
int	O
)	O
(	O
'\\'	O
)	O
)	O
;	O
strob_chr_index	function
(	O
buf	pointer
,	O
i	int
++	O
,	O
(	O
int	O
)	O
(	O
'+'	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'*'	O
)	O
{	O
strob_chr_index	function
(	O
buf	pointer
,	O
i	int
++	O
,	O
(	O
int	O
)	O
(	O
'.'	O
)	O
)	O
;	O
strob_chr_index	function
(	O
buf	pointer
,	O
i	int
++	O
,	O
(	O
int	O
)	O
(	O
'*'	O
)	O
)	O
;	O
}	O
else	O
{	O
strob_chr_index	function
(	O
buf	pointer
,	O
i	int
++	O
,	O
(	O
int	O
)	O
(	O
*	O
s	pointer
)	O
)	O
;	O
}	O
s	pointer
++	O
;	O
}	O
strob_chr_index	function
(	O
buf	pointer
,	O
i	int
++	O
,	O
(	O
int	O
)	O
(	O
'$'	O
)	O
)	O
;	O
}	O
int	O
write_query_blob	function
(	O
GB	struct
*	O
G	pointer
,	O
SWVERID	struct
*	O
swverid	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
STROB	struct
*	O
tmp	pointer
,	O
int	O
query_num	int
,	O
char	O
*	O
req_type	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
awkregex	pointer
;	O
char	O
*	O
tmpval	pointer
;	O
struct	O
VER_ID	struct
*	O
verid	pointer
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SW_SOC_SPEC=\"%s\"\n"	pointer
,	O
swverid	pointer
->	O
source_copyM	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_UTIL_NAME=\"%s\"\n"	pointer
"SWBIS_CL_TARGET_TARGET=\"%s\"\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
G	pointer
->	O
g_cl_target_targetM	pointer
!=	O
NULL	O
?	O
G	pointer
->	O
g_cl_target_targetM	pointer
:	O
"(unset)"	pointer
)	O
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_SOC_SPEC1=\".*\"\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_SOC_SPEC2=\".*\"\n"	pointer
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
s	pointer
=	O
cplob_val	function
(	O
swverid	pointer
->	O
taglistM	pointer
,	O
i	int
)	O
)	O
)	O
{	O
if	O
(	O
i	int
<	O
2	int
)	O
{	O
strob_strcpy	function
(	O
tmp	pointer
,	O
s	pointer
)	O
;	O
shpat_to_regex	function
(	O
tmp	pointer
,	O
s	pointer
)	O
;	O
awkregex	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_SOC_SPEC%d=\"%s\"\n"	pointer
,	O
i	int
+	O
1	int
,	O
awkregex	pointer
)	O
;	O
}	O
else	O
{	O
;	O
}	O
i	int
++	O
;	O
}	O
verid	pointer
=	O
swverid_get_verid	function
(	O
swverid	pointer
,	O
SWVERID_VERIDS_VENDOR_TAG	pointer
,	O
1	int
)	O
;	O
if	O
(	O
verid	pointer
==	O
NULL	O
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_VENDOR_TAG=\".*\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
tmpval	pointer
=	O
verid	pointer
->	O
valueM	int
;	O
shpat_to_regex	function
(	O
tmp	pointer
,	O
tmpval	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_VENDOR_TAG=\"%s\"\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
if	O
(	O
req_type	pointer
)	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_REQ_TYPE=\"%s\"\n"	pointer
,	O
req_type	pointer
)	O
;	O
if	O
(	O
query_num	int
>=	O
0	int
)	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_QUERY_NUM=\"%d\"\n"	pointer
,	O
query_num	int
)	O
;	O
verid	pointer
=	O
swverid_get_verid	function
(	O
swverid	pointer
,	O
SWVERID_VERIDS_REVISION	pointer
,	O
1	int
)	O
;	O
if	O
(	O
verid	pointer
==	O
NULL	O
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_REVISION_SPEC=\".*\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
tmpval	pointer
=	O
verid	pointer
->	O
valueM	int
;	O
if	O
(	O
strcmp	function
(	O
tmpval	pointer
,	O
"*"	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_REVISION_SPEC=\".*\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
tmp	pointer
,	O
tmpval	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_REVISION_SPEC=\"%s\"\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_REVISION_RELOP=\"%s\"\n"	pointer
,	O
verid	pointer
->	O
rel_opM	array
)	O
;	O
}	O
verid	pointer
=	O
swverid_get_verid	function
(	O
swverid	pointer
,	O
SWVERID_VERIDS_REVISION	pointer
,	O
2	int
)	O
;	O
if	O
(	O
verid	pointer
==	O
NULL	O
)	O
{	O
;	O
}	O
else	O
{	O
tmpval	pointer
=	O
verid	pointer
->	O
valueM	int
;	O
if	O
(	O
strcmp	function
(	O
tmpval	pointer
,	O
"*"	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_REVISION2_SPEC=\".*\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
tmp	pointer
,	O
tmpval	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_REVISION2_SPEC=\"%s\"\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_REVISION2_RELOP=\"%s\"\n"	pointer
,	O
verid	pointer
->	O
rel_opM	array
)	O
;	O
}	O
verid	pointer
=	O
swverid_get_verid	function
(	O
swverid	pointer
,	O
SWVERID_VERIDS_CATALOG_INSTANCE	pointer
,	O
1	int
)	O
;	O
if	O
(	O
verid	pointer
==	O
NULL	O
)	O
{	O
tmpval	pointer
=	O
"*"	pointer
;	O
}	O
else	O
{	O
tmpval	pointer
=	O
verid	pointer
->	O
valueM	int
;	O
}	O
shpat_to_regex	function
(	O
tmp	pointer
,	O
tmpval	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_INSTANCE=\"%s\"\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
verid	pointer
=	O
swverid_get_verid	function
(	O
swverid	pointer
,	O
SWVERID_VERIDS_LOCATION	pointer
,	O
1	int
)	O
;	O
if	O
(	O
verid	pointer
==	O
NULL	O
)	O
{	O
tmpval	pointer
=	O
"*"	pointer
;	O
}	O
else	O
{	O
tmpval	pointer
=	O
verid	pointer
->	O
valueM	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
tmpval	pointer
,	O
"/"	pointer
)	O
==	O
0	int
||	O
strlen	function
(	O
tmpval	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_LOCATION_SPEC=\"^/$|^$\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
shpat_to_regex	function
(	O
tmp	pointer
,	O
tmpval	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_LOCATION_SPEC=\"%s\"\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
verid	pointer
=	O
swverid_get_verid	function
(	O
swverid	pointer
,	O
SWVERID_VERIDS_QUALIFIER	pointer
,	O
1	int
)	O
;	O
if	O
(	O
verid	pointer
==	O
NULL	O
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_QUALIFIER_SPEC=\".*\"\n"	pointer
)	O
;	O
}	O
else	O
{	O
tmpval	pointer
=	O
verid	pointer
->	O
valueM	int
;	O
shpat_to_regex	function
(	O
tmp	pointer
,	O
tmpval	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
"SWBIS_QUALIFIER_SPEC=\"%s\"\n"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
write_shell_assign1	function
(	O
STROB	struct
*	O
buf	pointer
,	O
char	O
*	O
varname	pointer
,	O
char	O
*	O
value	int
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s=\"${%s:=\"%s\"}\"\n"	pointer
,	O
varname	pointer
,	O
varname	pointer
,	O
value	int
)	O
;	O
}	O
static	O
void	O
write_swbis_env_vars	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
)	O
{	O
return	O
;	O
}	O
static	O
void	O
form_absolute_control_dir	function
(	O
STROB	struct
*	O
tmp	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
control_script_pkg_dir	pointer
,	O
char	O
*	O
*	O
script_name	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
)	O
;	O
swlib_unix_dircat	function
(	O
tmp	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_entryM	pointer
)	O
;	O
swlib_unix_dircat	function
(	O
tmp	pointer
,	O
SWINSTALL_INCAT_NAME	pointer
)	O
;	O
swlib_unix_dircat	function
(	O
tmp	pointer
,	O
control_script_pkg_dir	pointer
)	O
;	O
swlib_squash_trailing_slash	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
swlib_squash_double_slash	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
swlib_check_clean_absolute_path	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
)	O
SWLIB_FATAL	O
(	O
"internal error: form_absolute_control_dir-1"	pointer
)	O
;	O
s	pointer
=	O
strrchr	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
'/'	O
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
s	pointer
++	O
;	O
*	O
script_name	pointer
=	O
s	pointer
;	O
}	O
else	O
{	O
SWLIB_FATAL	O
(	O
"internal error: form_absolute_control_dir-2"	pointer
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
write_state	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWI_XFILE	struct
*	O
xx	pointer
,	O
int	O
do_if_active	int
)	O
{	O
if	O
(	O
do_if_active	int
&&	O
!	O
(	O
xx	pointer
->	O
baseM	struct
.	O
is_activeM	int
)	O
)	O
return	O
;	O
if	O
(	O
strcmp	function
(	O
xx	pointer
->	O
stateM	array
,	O
SW_STATE_UNSET	pointer
)	O
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"    "	pointer
SW_A_state	pointer
" %s\n"	pointer
,	O
xx	pointer
->	O
stateM	array
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
write_times	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWI_BASE	struct
*	O
xx	pointer
,	O
int	O
do_if_active	int
)	O
{	O
time_t	long
caltime	long
;	O
caltime	long
=	O
(	O
time_t	long
)	O
(	O
xx	pointer
->	O
create_timeM	long
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"    "	pointer
SW_A_create_time	pointer
" %lu # %s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
xx	pointer
->	O
create_timeM	long
)	O
,	O
ctime	function
(	O
&	O
caltime	long
)	O
)	O
;	O
caltime	long
=	O
(	O
time_t	long
)	O
(	O
xx	pointer
->	O
mod_timeM	long
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"    "	pointer
SW_A_mod_time	pointer
" %lu # %s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
xx	pointer
->	O
mod_timeM	long
)	O
,	O
ctime	function
(	O
&	O
caltime	long
)	O
)	O
;	O
}	O
static	O
void	O
add_env_entry_localdefault	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
value	int
,	O
STROB	struct
*	O
buf	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
value	int
)	O
{	O
s	pointer
=	O
value	int
;	O
}	O
else	O
{	O
s	pointer
=	O
getenv	function
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
!	O
s	pointer
)	O
s	pointer
=	O
""	pointer
;	O
write_shell_assign1	function
(	O
buf	pointer
,	O
name	pointer
,	O
s	pointer
)	O
;	O
}	O
static	O
void	O
add_env_entry	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
value	int
,	O
STROB	struct
*	O
buf	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
value	int
)	O
{	O
s	pointer
=	O
value	int
;	O
}	O
else	O
{	O
s	pointer
=	O
getenv	function
(	O
name	pointer
)	O
;	O
}	O
if	O
(	O
s	pointer
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s=\"%s\"\n"	pointer
,	O
name	pointer
,	O
s	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"export %s\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
}	O
static	O
int	O
write_dependency_assertion_script	function
(	O
SWI	struct
*	O
swi	pointer
,	O
SWVERID	struct
*	O
dep_spec	pointer
,	O
STROB	struct
*	O
buf	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
squash_null_block	function
(	O
char	O
*	O
start	int
,	O
int	O
len	int
)	O
{	O
char	O
*	O
first_null	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
done	int
;	O
int	O
nn	int
;	O
if	O
(	O
len	int
<=	O
0	int
)	O
return	O
0	int
;	O
first_null	pointer
=	O
start	int
+	O
strlen	function
(	O
start	int
)	O
;	O
s	pointer
=	O
first_null	pointer
;	O
nn	int
=	O
0	int
;	O
while	O
(	O
(	O
s	pointer
-	O
start	int
)	O
<	O
len	int
&&	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
nn	int
++	O
;	O
s	pointer
++	O
;	O
}	O
done	int
=	O
(	O
int	O
)	O
(	O
s	pointer
-	O
start	int
)	O
;	O
if	O
(	O
done	int
>=	O
len	int
)	O
{	O
return	O
0	int
;	O
}	O
memmove	function
(	O
first_null	pointer
,	O
s	pointer
,	O
(	O
(	O
char	O
*	O
)	O
(	O
start	int
+	O
len	int
)	O
)	O
-	O
s	pointer
)	O
;	O
memset	function
(	O
start	int
+	O
(	O
len	int
-	O
nn	int
)	O
,	O
'\0'	O
,	O
nn	int
)	O
;	O
return	O
nn	int
;	O
}	O
static	O
void	O
write_attributes	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWHEADER	struct
*	O
swheader	pointer
,	O
int	O
index	function
)	O
{	O
char	O
*	O
line	pointer
;	O
int	O
level	int
;	O
char	O
*	O
keyword	pointer
;	O
char	O
*	O
value	int
;	O
swheader_store_state	function
(	O
swheader	pointer
,	O
NULL	O
)	O
;	O
swheader_set_current_offset	function
(	O
swheader	pointer
,	O
index	function
)	O
;	O
while	O
(	O
(	O
line	pointer
=	O
swheader_get_next_attribute	function
(	O
swheader	pointer
)	O
)	O
)	O
{	O
keyword	pointer
=	O
swheaderline_get_keyword	function
(	O
line	pointer
)	O
;	O
value	int
=	O
swheaderline_get_value	function
(	O
line	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
level	int
=	O
swheaderline_get_level	function
(	O
line	pointer
)	O
;	O
swdef_write_keyword_to_buffer	function
(	O
buf	pointer
,	O
keyword	pointer
,	O
level	int
,	O
SWPARSE_MD_TYPE_ATT	char
)	O
;	O
swdef_write_value_to_buffer	function
(	O
buf	pointer
,	O
value	int
)	O
;	O
}	O
swheader_restore_state	function
(	O
swheader	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
write_isf_excludes	function
(	O
STROB	struct
*	O
ibuf	pointer
,	O
SWI	struct
*	O
swi	pointer
)	O
{	O
int	O
fd	int
;	O
int	O
n	long
;	O
char	O
*	O
s	pointer
;	O
STROB	struct
*	O
buf	pointer
;	O
fd	int
=	O
swi	pointer
->	O
pending_file_conflicts_fdM	int
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
;	O
buf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
uxfio_lseek	function
(	O
fd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
while	O
(	O
(	O
n	long
=	O
swgp_read_line	function
(	O
fd	int
,	O
(	O
STROB	struct
*	O
)	O
buf	pointer
,	O
DO_NOT_APPEND	int
)	O
)	O
>	O
0	int
)	O
{	O
s	pointer
=	O
strob_str	function
(	O
buf	pointer
)	O
;	O
while	O
(	O
swlib_squash_trailing_char	function
(	O
s	pointer
,	O
'\n'	O
)	O
==	O
0	int
)	O
;	O
strob_sprintf	function
(	O
ibuf	pointer
,	O
0	int
,	O
SW_A_excluded_from_install	pointer
" "	pointer
"\"%s\"\n"	pointer
,	O
s	pointer
)	O
;	O
}	O
strob_close	function
(	O
buf	pointer
)	O
;	O
}	O
int	O
swicat_write_installed_software	function
(	O
SWI	struct
*	O
swi	pointer
,	O
int	O
ofd	int
)	O
{	O
STROB	struct
*	O
buf	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
int	O
ret	pointer
;	O
swicat_isf_installed_software	function
(	O
buf	pointer
,	O
swi	pointer
)	O
;	O
ret	pointer
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
ofd	int
,	O
(	O
void	O
*	O
)	O
(	O
strob_str	function
(	O
buf	pointer
)	O
)	O
,	O
strob_strlen	function
(	O
buf	pointer
)	O
)	O
;	O
strob_close	function
(	O
buf	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
swicat_isf_all_scripts	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWI_SCRIPTS	struct
*	O
xx	pointer
,	O
int	O
do_if_active	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
SWI_MAX_OBJ	int
&&	O
xx	pointer
->	O
swi_coM	array
[	O
i	int
]	O
)	O
{	O
swicat_isf_control_script	function
(	O
buf	pointer
,	O
xx	pointer
->	O
swi_coM	array
[	O
i	int
]	O
,	O
do_if_active	int
)	O
;	O
i	int
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swicat_isf_control_script	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWI_CONTROL_SCRIPT	struct
*	O
xx	pointer
,	O
int	O
do_if_active	int
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
SW_A_control_file	pointer
"\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\t"	pointer
SW_A_tag	pointer
" %s\n"	pointer
,	O
xx	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\t"	pointer
SW_A_result	pointer
" %s\n"	pointer
,	O
swi_control_script_posix_result	function
(	O
xx	pointer
)	O
)	O
;	O
if	O
(	O
xx	pointer
->	O
resultM	int
>=	O
0	int
)	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\t"	pointer
SW_A_return_code	pointer
" %d\n"	pointer
,	O
xx	pointer
->	O
resultM	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swicat_isf_fileset	function
(	O
SWI	struct
*	O
swi	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
SWI_XFILE	struct
*	O
xfile	pointer
,	O
int	O
do_if_active	int
)	O
{	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
SW_A_fileset	pointer
"\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"    "	pointer
SW_A_location	pointer
" %s\n"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
locationM	pointer
?	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
locationM	pointer
:	O
"/"	pointer
)	O
;	O
write_attributes	function
(	O
buf	pointer
,	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
,	O
xfile	pointer
->	O
baseM	struct
.	O
header_indexM	int
)	O
;	O
write_state	function
(	O
buf	pointer
,	O
xfile	pointer
,	O
do_if_active	int
)	O
;	O
write_times	function
(	O
buf	pointer
,	O
(	O
SWI_BASE	struct
*	O
)	O
&	O
(	O
xfile	pointer
->	O
baseM	struct
)	O
,	O
1	int
)	O
;	O
swicat_isf_all_scripts	function
(	O
buf	pointer
,	O
xfile	pointer
->	O
swi_scM	pointer
,	O
do_if_active	int
)	O
;	O
write_isf_excludes	function
(	O
buf	pointer
,	O
swi	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swicat_isf_product	function
(	O
SWI	struct
*	O
swi	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
SWI_PRODUCT	struct
*	O
prod	pointer
,	O
int	O
do_if_active	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
SWHEADER	struct
*	O
swheader	pointer
;	O
swheader	pointer
=	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
SW_A_product	pointer
"\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
SW_A_location	pointer
" %s\n"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
locationM	pointer
?	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
locationM	pointer
:	O
"/"	pointer
)	O
;	O
write_attributes	function
(	O
buf	pointer
,	O
SWI_INDEX_HEADER	O
(	O
swi	pointer
)	O
,	O
prod	pointer
->	O
p_baseM	struct
.	O
header_indexM	int
)	O
;	O
write_times	function
(	O
buf	pointer
,	O
(	O
SWI_BASE	struct
*	O
)	O
&	O
(	O
prod	pointer
->	O
p_baseM	struct
)	O
,	O
1	int
)	O
;	O
swicat_isf_all_scripts	function
(	O
buf	pointer
,	O
prod	pointer
->	O
xfileM	pointer
->	O
swi_scM	pointer
,	O
do_if_active	int
)	O
;	O
while	O
(	O
i	int
<	O
SWI_MAX_OBJ	int
&&	O
prod	pointer
->	O
swi_coM	array
[	O
i	int
]	O
)	O
{	O
swicat_isf_fileset	function
(	O
swi	pointer
,	O
buf	pointer
,	O
prod	pointer
->	O
swi_coM	array
[	O
i	int
]	O
,	O
do_if_active	int
)	O
;	O
i	int
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swicat_isf_installed_software	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
)	O
{	O
SWI_PRODUCT	struct
*	O
prod	pointer
;	O
prod	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
0	int
]	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
SW_A_installed_software	pointer
"\n"	pointer
)	O
;	O
swicat_isf_product	function
(	O
swi	pointer
,	O
buf	pointer
,	O
prod	pointer
,	O
1	int
)	O
;	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
swi_coM	array
[	O
1	int
]	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"multiple products not supported\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swicat_env	function
(	O
STROB	struct
*	O
buf	pointer
,	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
control_script_pkg_dir	pointer
,	O
char	O
*	O
tag	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
char	O
*	O
tmp_s	pointer
;	O
add_env_entry	function
(	O
"LC_CTYPE"	pointer
,	O
""	pointer
,	O
buf	pointer
)	O
;	O
add_env_entry	function
(	O
"LC_MESSAGES"	pointer
,	O
""	pointer
,	O
buf	pointer
)	O
;	O
add_env_entry	function
(	O
"LC_TIME"	pointer
,	O
""	pointer
,	O
buf	pointer
)	O
;	O
add_env_entry	function
(	O
"TZ"	pointer
,	O
""	pointer
,	O
buf	pointer
)	O
;	O
add_env_entry	function
(	O
"LANG"	pointer
,	O
"C"	pointer
,	O
buf	pointer
)	O
;	O
add_env_entry	function
(	O
"LC_ALL"	pointer
,	O
"C"	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
)	O
{	O
add_env_entry	function
(	O
"SW_ROOT_DIRECTORY"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
target_pathM	pointer
,	O
buf	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"warning: swi->swi_pkgM->target_pathM is null, using /\n"	pointer
)	O
;	O
add_env_entry	function
(	O
"SW_ROOT_DIRECTORY"	pointer
,	O
"/"	pointer
,	O
buf	pointer
)	O
;	O
}	O
add_env_entry	function
(	O
"SW_PATH"	pointer
,	O
"$PATH"	pointer
,	O
buf	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
strlen	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_software_catalogM	pointer
)	O
)	O
;	O
tmp_s	pointer
=	O
strstr	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_entryM	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_software_catalogM	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
tmp_s	pointer
!=	O
NULL	O
)	O
;	O
tmp_s	pointer
+=	O
strlen	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_software_catalogM	pointer
)	O
;	O
while	O
(	O
*	O
tmp_s	pointer
==	O
'/'	O
)	O
tmp_s	pointer
++	O
;	O
add_env_entry	function
(	O
"SWBIS_CATALOG_ENTRY"	pointer
,	O
tmp_s	pointer
,	O
buf	pointer
)	O
;	O
add_env_entry	function
(	O
"SW_CATALOG"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
catalog_entryM	pointer
,	O
buf	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
locationM	pointer
!=	O
NULL	O
)	O
;	O
add_env_entry	function
(	O
"SW_LOCATION"	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
locationM	pointer
,	O
buf	pointer
)	O
;	O
add_path_code	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
*	O
(	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_software_catalogM	pointer
)	O
==	O
'/'	O
)	O
{	O
add_env_entry	function
(	O
"SW_SESSION_OPTIONS"	pointer
,	O
"${SW_CATALOG}/"	pointer
SW_A_session_options	pointer
,	O
buf	pointer
)	O
;	O
}	O
else	O
{	O
add_env_entry	function
(	O
"SW_SESSION_OPTIONS"	pointer
,	O
"${SW_ROOT_DIRECTORY}/${SW_CATALOG}/"	pointer
SW_A_session_options	pointer
,	O
buf	pointer
)	O
;	O
}	O
strob_strcpy	function
(	O
tmp	pointer
,	O
""	pointer
)	O
;	O
swverid_print	function
(	O
SWI_GET_PRODUCT	O
(	O
swi	pointer
,	O
0	int
)	O
->	O
p_baseM	struct
.	O
swveridM	pointer
,	O
tmp	pointer
)	O
;	O
add_env_entry	function
(	O
"SW_SOFTWARE_SPEC"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
buf	pointer
)	O
;	O
strob_strcat	function
(	O
buf	pointer
,	O
". \"${SW_SESSION_OPTIONS}\"\n"	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swicat_make_options_file	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
strob_strcpy	function
(	O
buf	pointer
,	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
swicat_write_auto_comment	function
(	O
STROB	struct
*	O
buf	pointer
,	O
char	O
*	O
filename	pointer
)	O
{	O
time_t	long
caltime	long
;	O
time	struct
(	O
&	O
caltime	long
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"# %s\n"	pointer
"# Automatically generated by %s version %s on %s"	pointer
"#\n"	pointer
,	O
filename	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
SWBIS_RELEASE	pointer
,	O
ctime	function
(	O
&	O
caltime	long
)	O
)	O
;	O
}	O
void	O
swicat_construct_controlsh_taglist	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
sw_selections	pointer
,	O
STROB	struct
*	O
list	pointer
)	O
{	O
int	O
i	int
;	O
int	O
j	int
;	O
SWI_PACKAGE	struct
*	O
package	pointer
;	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWI_XFILE	struct
*	O
fileset	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
strob_strcpy	function
(	O
list	pointer
,	O
""	pointer
)	O
;	O
package	pointer
=	O
swi	pointer
->	O
swi_pkgM	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SWI_MAX_OBJ	int
;	O
i	int
++	O
)	O
{	O
product	pointer
=	O
package	pointer
->	O
swi_coM	array
[	O
i	int
]	O
;	O
if	O
(	O
product	pointer
)	O
{	O
SWLIB_ASSERT	O
(	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
!=	O
NULL	O
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
)	O
;	O
if	O
(	O
swlib_check_clean_path	function
(	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
)	O
)	O
SWLIB_ASSERT	O
(	O
0	int
)	O
;	O
strob_sprintf	function
(	O
list	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
SWI_MAX_OBJ	int
;	O
j	int
++	O
)	O
{	O
fileset	pointer
=	O
product	pointer
->	O
swi_coM	array
[	O
j	int
]	O
;	O
if	O
(	O
fileset	pointer
)	O
{	O
SWLIB_ASSERT	O
(	O
fileset	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
swlib_check_clean_path	function
(	O
fileset	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
)	O
SWLIB_ASSERT	O
(	O
0	int
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
product	pointer
->	O
p_baseM	struct
.	O
b_tagM	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
"."	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
fileset	pointer
->	O
baseM	struct
.	O
b_tagM	pointer
)	O
;	O
strob_sprintf	function
(	O
list	pointer
,	O
STROB_DO_APPEND	int
,	O
" %s"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
else	O
break	O
;	O
}	O
}	O
else	O
break	O
;	O
strob_sprintf	function
(	O
list	pointer
,	O
STROB_DO_APPEND	int
,	O
" "	pointer
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
int	O
swicat_write_script_cases	function
(	O
SWI	struct
*	O
swi	pointer
,	O
STROB	struct
*	O
buf	pointer
,	O
char	O
*	O
sw_selection	pointer
)	O
{	O
int	O
ret	pointer
;	O
char	O
*	O
product_tag	pointer
;	O
char	O
*	O
fileset_tag	pointer
;	O
SWVERID	struct
*	O
swverid_spec	pointer
;	O
SWVERID	struct
*	O
swverid	pointer
;	O
CPLOB	struct
*	O
taglist	pointer
;	O
SWI_PRODUCT	struct
*	O
product	pointer
;	O
SWI_XFILE	struct
*	O
xfile	pointer
;	O
SWI_SCRIPTS	struct
*	O
scripts	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
E_DEBUG2	O
(	O
"sw_selection=[%s]"	pointer
,	O
sw_selection	pointer
)	O
;	O
swverid	pointer
=	O
swverid_open	function
(	O
SW_A_product	pointer
,	O
NULL	O
)	O
;	O
taglist	pointer
=	O
swverid_u_parse_swspec	function
(	O
swverid	pointer
,	O
sw_selection	pointer
)	O
;	O
E_DEBUG2	O
(	O
"swverid_print = [%s]"	pointer
,	O
swverid_show_object_debug	function
(	O
swverid	pointer
,	O
NULL	O
,	O
""	pointer
)	O
)	O
;	O
product_tag	pointer
=	O
cplob_val	function
(	O
taglist	pointer
,	O
0	int
)	O
;	O
fileset_tag	pointer
=	O
cplob_val	function
(	O
taglist	pointer
,	O
1	int
)	O
;	O
product	pointer
=	O
swi_find_product_by_swsel	function
(	O
swi	pointer
->	O
swi_pkgM	pointer
,	O
product_tag	pointer
,	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
SWLIB_ASSERT	O
(	O
product	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
fileset_tag	pointer
)	O
{	O
xfile	pointer
=	O
swi_find_fileset_by_swsel	function
(	O
product	pointer
,	O
fileset_tag	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
xfile	pointer
=	O
product	pointer
->	O
xfileM	pointer
;	O
}	O
SWLIB_ASSERT	O
(	O
xfile	pointer
!=	O
NULL	O
)	O
;	O
scripts	pointer
=	O
xfile	pointer
->	O
swi_scM	pointer
;	O
SWLIB_ASSERT	O
(	O
scripts	pointer
!=	O
NULL	O
)	O
;	O
swverid_spec	pointer
=	O
swverid_copy	function
(	O
SWI_GET_PRODUCT	O
(	O
swi	pointer
,	O
0	int
)	O
->	O
p_baseM	struct
.	O
swveridM	pointer
)	O
;	O
if	O
(	O
fileset_tag	pointer
)	O
{	O
cplob_add_nta	function
(	O
swverid_spec	pointer
->	O
taglistM	pointer
,	O
strdup	function
(	O
fileset_tag	pointer
)	O
)	O
;	O
}	O
swverid_print	function
(	O
swverid_spec	pointer
,	O
tmp	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
STROB_DO_APPEND	int
,	O
"\t#\n"	pointer
"\t# write script cases here\n"	pointer
"\t#\n"	pointer
)	O
;	O
add_env_entry	function
(	O
"SW_SOFTWARE_SPEC"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
buf	pointer
)	O
;	O
ret	pointer
=	O
swi_afile_write_script_cases	function
(	O
scripts	pointer
,	O
buf	pointer
,	O
swi	pointer
->	O
swi_pkgM	pointer
->	O
installed_software_catalogM	pointer
)	O
;	O
ret	pointer
=	O
0	int
;	O
SWLIB_ASSERT	O
(	O
ret	pointer
==	O
0	int
)	O
;	O
swverid_close	function
(	O
swverid	pointer
)	O
;	O
swverid_close	function
(	O
swverid_spec	pointer
)	O
;	O
cplob_close	function
(	O
taglist	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swicat_r_get_installed_catalog	function
(	O
GB	struct
*	O
G	pointer
,	O
VPLOB	union
*	O
swspecs	pointer
,	O
char	O
*	O
target_path	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
int	O
swicat_write_isc_script	function
(	O
STROB	struct
*	O
script_buf	pointer
,	O
GB	struct
*	O
G	pointer
,	O
VPLOB	union
*	O
swspecs	pointer
,	O
VPLOB	union
*	O
swspecs_pre	pointer
,	O
VPLOB	union
*	O
swspecs_co	pointer
,	O
VPLOB	union
*	O
swspecs_ex	pointer
,	O
char	O
*	O
list_vform	pointer
)	O
{	O
int	O
query_num	int
;	O
int	O
i	int
;	O
SWVERID	struct
*	O
swverid	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
shell_lib_buf	pointer
;	O
char	O
*	O
list_lform	pointer
;	O
char	O
*	O
isc_path	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
shell_lib_buf	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
strob_strcpy	function
(	O
script_buf	pointer
,	O
""	pointer
)	O
;	O
isc_path	pointer
=	O
get_opta_isc	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_installed_software_catalog	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
list_vform	pointer
,	O
SWICAT_FORM_TAR1	pointer
)	O
==	O
0	int
)	O
{	O
list_lform	pointer
=	O
SWICAT_FORM_DIR1	pointer
;	O
}	O
else	O
{	O
list_lform	pointer
=	O
list_vform	pointer
;	O
}	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
STROB_DO_APPEND	int
,	O
CSHID	O
"export sw_retval\n"	pointer
"export SW_SOC_SPEC\n"	pointer
"export SWBIS_SOC_SPEC1\n"	pointer
"export SWBIS_SOC_SPEC2\n"	pointer
"export SWBIS_VENDOR_TAG\n"	pointer
"export SWBIS_REVISION_SPEC\n"	pointer
"export SWBIS_REVISION_RELOP\n"	pointer
"export SWBIS_REVISION2_SPEC\n"	pointer
"export SWBIS_REVISION2_RELOP\n"	pointer
"export SWBIS_LOCATION_SPEC\n"	pointer
"export SWBIS_QUALIFIER_SPEC\n"	pointer
"export SWBIS_INSTANCE\n"	pointer
"export SWBIS_QUERY_NUM\n"	pointer
"export SWBIS_LIST_FORM\n"	pointer
"export SWBIS_REQ_TYPE\n"	pointer
"export SWBIS_UTIL_NAME\n"	pointer
"export SWBIS_CL_TARGET_TARGET\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
,	O
shlib_get_function_text_by_name	function
(	O
"shls_false_"	pointer
,	O
tmp	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_apply_socspec"	pointer
,	O
tmp	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_get_verid_list"	pointer
,	O
tmp	pointer
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
list_vform	pointer
,	O
SWICAT_FORM_TAR1	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
CSHID	O
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
,	O
shlib_get_function_text_by_name	function
(	O
"shls_false_"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_check_for_gnu_tar"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_missing_which"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_write_cat_ar"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
)	O
;	O
}	O
if	O
(	O
isc_path	pointer
)	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"cd \"%s\"\n"	pointer
,	O
isc_path	pointer
)	O
;	O
else	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"(exit 1);\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"case $? in\n"	pointer
"	0)\n"	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"sw_retval=0\n"	pointer
"(\n"	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"SWBIS_LIST_FORM=\"%s\"\n"	pointer
,	O
list_lform	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"dd bs=512 count=1 of=/dev/null 2>/dev/null\n"	pointer
)	O
;	O
i	int
=	O
0	int
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"(\n"	pointer
)	O
;	O
if	O
(	O
swspecs	pointer
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
vplob_get_nstore	function
(	O
swspecs	pointer
)	O
<=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swverid	pointer
=	O
swverid_open	function
(	O
NULL	O
,	O
"*"	pointer
)	O
;	O
if	O
(	O
swverid	pointer
==	O
NULL	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
vplob_add	function
(	O
swspecs	pointer
,	O
(	O
void	O
*	O
)	O
swverid	pointer
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
"Looping over swspecs"	pointer
)	O
;	O
while	O
(	O
(	O
swverid	pointer
=	O
vplob_val	function
(	O
swspecs	pointer
,	O
i	int
++	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"in swpec number [%d]"	pointer
,	O
i	int
)	O
;	O
write_query_blob	function
(	O
G	pointer
,	O
swverid	pointer
,	O
script_buf	pointer
,	O
tmp	pointer
,	O
-	O
1	int
,	O
NULL	O
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"shls_get_verid_list | shls_apply_socspec\n"	pointer
"\n"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
swspecs_pre	pointer
||	O
swspecs_co	pointer
||	O
swspecs_ex	pointer
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
query_num	int
=	O
0	int
;	O
i	int
=	O
0	int
;	O
if	O
(	O
swspecs_pre	pointer
)	O
{	O
E_DEBUG	O
(	O
"have swspecs_pre"	pointer
)	O
;	O
while	O
(	O
(	O
swverid	pointer
=	O
vplob_val	function
(	O
swspecs_pre	pointer
,	O
i	int
++	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"in swpec number [%d]"	pointer
,	O
i	int
)	O
;	O
write_query_blob	function
(	O
G	pointer
,	O
swverid	pointer
,	O
script_buf	pointer
,	O
tmp	pointer
,	O
query_num	int
,	O
SWICAT_REQ_TYPE_P	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"shls_get_verid_list | shls_apply_socspec\n"	pointer
"\n"	pointer
)	O
;	O
query_num	int
++	O
;	O
}	O
}	O
i	int
=	O
0	int
;	O
if	O
(	O
swspecs_co	pointer
)	O
{	O
E_DEBUG	O
(	O
"have swspecs_co"	pointer
)	O
;	O
while	O
(	O
(	O
swverid	pointer
=	O
vplob_val	function
(	O
swspecs_co	pointer
,	O
i	int
++	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"in swpec number [%d]"	pointer
,	O
i	int
)	O
;	O
write_query_blob	function
(	O
G	pointer
,	O
swverid	pointer
,	O
script_buf	pointer
,	O
tmp	pointer
,	O
query_num	int
,	O
SWICAT_REQ_TYPE_C	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"shls_get_verid_list | shls_apply_socspec\n"	pointer
"\n"	pointer
)	O
;	O
query_num	int
++	O
;	O
}	O
}	O
i	int
=	O
0	int
;	O
if	O
(	O
swspecs_ex	pointer
)	O
{	O
E_DEBUG	O
(	O
"have swspecs_ex"	pointer
)	O
;	O
while	O
(	O
(	O
swverid	pointer
=	O
vplob_val	function
(	O
swspecs_ex	pointer
,	O
i	int
++	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"in swpec number [%d]"	pointer
,	O
i	int
)	O
;	O
write_query_blob	function
(	O
G	pointer
,	O
swverid	pointer
,	O
script_buf	pointer
,	O
tmp	pointer
,	O
query_num	int
,	O
SWICAT_REQ_TYPE_E	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"shls_get_verid_list | shls_apply_socspec\n"	pointer
"\n"	pointer
)	O
;	O
query_num	int
++	O
;	O
}	O
}	O
if	O
(	O
query_num	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"have no blobs whatsoever"	pointer
)	O
;	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
"dd if=/dev/null 2>/dev/null\n"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"internal error in swicat_write_isc_script()\n"	pointer
)	O
;	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
list_vform	pointer
,	O
SWICAT_FORM_TAR1	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
")\n"	pointer
") | shls_write_cat_ar\n"	pointer
)	O
;	O
}	O
else	O
{	O
swlib_append_synct_eof	function
(	O
script_buf	pointer
)	O
;	O
}	O
strob_sprintf	function
(	O
script_buf	pointer
,	O
1	int
,	O
";;\n"	pointer
"	*)\n"	pointer
"	echo \"internal error: bad installed_software_catalog path in swicat_write_isc_script\"\n"	pointer
"	sw_retval=1\n"	pointer
"	;;\n"	pointer
"esac\n"	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
shell_lib_buf	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swicat_squash_null_bytes	function
(	O
int	O
fd	int
)	O
{	O
int	O
ret	pointer
;	O
off_t	long
len	int
;	O
off_t	long
current_pos	long
;	O
char	O
*	O
mem	pointer
;	O
int	O
nn	int
;	O
off_t	long
newlen	pointer
;	O
current_pos	long
=	O
uxfio_lseek	function
(	O
fd	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
SWLIB_ASSERT	O
(	O
current_pos	long
>=	O
0	int
)	O
;	O
len	int
=	O
uxfio_lseek	function
(	O
fd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_END	int
)	O
;	O
SWLIB_ASSERT	O
(	O
len	int
>=	O
0	int
)	O
;	O
mem	pointer
=	O
(	O
char	O
*	O
)	O
uxfio_get_fd_mem	function
(	O
fd	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
SWLIB_ASSERT	O
(	O
mem	pointer
!=	O
NULL	O
)	O
;	O
nn	int
=	O
0	int
;	O
newlen	pointer
=	O
len	int
;	O
while	O
(	O
(	O
nn	int
=	O
squash_null_block	function
(	O
mem	pointer
,	O
(	O
int	O
)	O
newlen	pointer
)	O
)	O
>	O
0	int
)	O
{	O
newlen	pointer
-=	O
nn	int
;	O
}	O
if	O
(	O
nn	int
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ret	pointer
=	O
uxfio_lseek	function
(	O
fd	int
,	O
current_pos	long
,	O
SEEK_SET	int
)	O
;	O
SWLIB_ASSERT	O
(	O
ret	pointer
>=	O
0	int
)	O
;	O
ret	pointer
=	O
uxfio_ftruncate	function
(	O
fd	int
,	O
strlen	function
(	O
mem	pointer
)	O
)	O
;	O
SWLIB_ASSERT	O
(	O
ret	pointer
>=	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swicat_req_get_pre_result	function
(	O
SWICAT_REQ	struct
*	O
req	pointer
)	O
{	O
return	O
req	pointer
->	O
pre_resultM	int
;	O
}	O
int	O
swicat_req_get_ex_result	function
(	O
SWICAT_REQ	struct
*	O
req	pointer
)	O
{	O
return	O
req	pointer
->	O
ex_resultM	int
;	O
}	O
int	O
swicat_req_print	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICAT_REQ	struct
*	O
req	pointer
)	O
{	O
int	O
i	int
;	O
int	O
nn	int
;	O
char	O
*	O
s	pointer
;	O
if	O
(	O
req	pointer
->	O
pre_resultM	int
!=	O
0	int
)	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
s	pointer
=	O
strar_get	function
(	O
req	pointer
->	O
failed_preM	pointer
,	O
i	int
++	O
)	O
)	O
)	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_1	int
,	O
"prereqisite failed: %s\n"	pointer
,	O
s	pointer
)	O
;	O
}	O
else	O
{	O
SWICAT_PRE_SET	struct
*	O
pre_set	pointer
;	O
char	O
*	O
pre	pointer
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
pre_set	pointer
=	O
(	O
SWICAT_PRE_SET	struct
*	O
)	O
vplob_val	function
(	O
req	pointer
->	O
pre_set_arrayM	pointer
,	O
i	int
++	O
)	O
)	O
)	O
{	O
nn	int
=	O
0	int
;	O
while	O
(	O
(	O
pre	pointer
=	O
strar_get	function
(	O
pre_set	pointer
->	O
pre_fullfilledM	pointer
,	O
nn	int
++	O
)	O
)	O
)	O
{	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_1	int
,	O
"prereqisite '%s' filled by: %s:\n"	pointer
,	O
strob_str	function
(	O
pre_set	pointer
->	O
preM	pointer
)	O
,	O
pre	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
req	pointer
->	O
ex_resultM	int
!=	O
0	int
)	O
{	O
SWICAT_EX_SET	struct
*	O
ex_set	pointer
;	O
char	O
*	O
ex	pointer
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
ex_set	pointer
=	O
(	O
SWICAT_EX_SET	struct
*	O
)	O
vplob_val	function
(	O
req	pointer
->	O
ex_set_arrayM	pointer
,	O
i	int
++	O
)	O
)	O
)	O
{	O
nn	int
=	O
0	int
;	O
while	O
(	O
(	O
ex	pointer
=	O
strar_get	function
(	O
ex_set	pointer
->	O
ex_violatedM	pointer
,	O
nn	int
++	O
)	O
)	O
)	O
{	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_1	int
,	O
"exreqisite '%s' failed: %s:\n"	pointer
,	O
strob_str	function
(	O
ex_set	pointer
->	O
exM	pointer
)	O
,	O
ex	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
s	pointer
=	O
strar_get	function
(	O
req	pointer
->	O
passed_exM	pointer
,	O
i	int
++	O
)	O
)	O
)	O
sw_l_msg	function
(	O
G	pointer
,	O
SWC_VERBOSE_3	int
,	O
"exrereqisite passed: %s\n"	pointer
,	O
s	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swicat_req_analyze	function
(	O
GB	struct
*	O
G	pointer
,	O
SWICAT_REQ	struct
*	O
req	pointer
,	O
char	O
*	O
query_text	pointer
,	O
SWICAT_SL	struct
*	O
*	O
swicat_sl_p	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
STROB	struct
*	O
text	pointer
;	O
STROB	struct
*	O
rec	pointer
;	O
int	O
err	long
;	O
char	O
*	O
spec	pointer
;	O
SWICAT_SL	struct
*	O
swicat_sl	pointer
;	O
E_DEBUG2	O
(	O
"query text=[%s]"	pointer
,	O
query_text	pointer
)	O
;	O
text	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
swicat_sl_p	pointer
)	O
{	O
*	O
swicat_sl_p	pointer
=	O
NULL	O
;	O
swicat_sl	pointer
=	O
swicat_sl_create	function
(	O
)	O
;	O
}	O
else	O
{	O
swicat_sl	pointer
=	O
NULL	O
;	O
}	O
err	long
=	O
0	int
;	O
line	pointer
=	O
strob_strtok	function
(	O
text	pointer
,	O
query_text	pointer
,	O
"\r\n"	pointer
)	O
;	O
while	O
(	O
line	pointer
)	O
{	O
if	O
(	O
*	O
line	pointer
!=	O
'Q'	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
spec	pointer
=	O
line	pointer
;	O
spec	pointer
=	O
strchr	function
(	O
spec	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
spec	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
spec	pointer
=	O
strchr	function
(	O
++	O
spec	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
spec	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
spec	pointer
++	O
;	O
line	pointer
=	O
evaluate_query	function
(	O
G	pointer
,	O
req	pointer
,	O
spec	pointer
,	O
text	pointer
,	O
line	pointer
,	O
&	O
err	long
,	O
swicat_sl	pointer
)	O
;	O
}	O
strob_close	function
(	O
text	pointer
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
{	O
if	O
(	O
swicat_sl	pointer
)	O
swicat_sl_delete	function
(	O
swicat_sl	pointer
)	O
;	O
if	O
(	O
swicat_sl_p	pointer
)	O
*	O
swicat_sl_p	pointer
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
swicat_sl_p	pointer
)	O
*	O
swicat_sl_p	pointer
=	O
swicat_sl	pointer
;	O
return	O
0	int
;	O
}	O
SWICAT_REQ	struct
*	O
swicat_req_create	function
(	O
void	O
)	O
{	O
SWICAT_REQ	struct
*	O
req	pointer
;	O
req	pointer
=	O
(	O
SWICAT_REQ	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWICAT_REQ	struct
)	O
)	O
;	O
req	pointer
->	O
failed_preM	pointer
=	O
strar_open	function
(	O
)	O
;	O
req	pointer
->	O
failed_coM	pointer
=	O
strar_open	function
(	O
)	O
;	O
req	pointer
->	O
passed_exM	pointer
=	O
strar_open	function
(	O
)	O
;	O
req	pointer
->	O
pre_resultM	int
=	O
0	int
;	O
req	pointer
->	O
ex_resultM	int
=	O
0	int
;	O
req	pointer
->	O
co_resultM	int
=	O
0	int
;	O
req	pointer
->	O
ex_set_arrayM	pointer
=	O
vplob_open	function
(	O
)	O
;	O
req	pointer
->	O
pre_set_arrayM	pointer
=	O
vplob_open	function
(	O
)	O
;	O
req	pointer
->	O
slM	pointer
=	O
NULL	O
;	O
return	O
req	pointer
;	O
}	O
void	O
swicat_req_delete	function
(	O
SWICAT_REQ	struct
*	O
req	pointer
)	O
{	O
strar_close	function
(	O
req	pointer
->	O
failed_preM	pointer
)	O
;	O
strar_close	function
(	O
req	pointer
->	O
failed_coM	pointer
)	O
;	O
strar_close	function
(	O
req	pointer
->	O
passed_exM	pointer
)	O
;	O
vplob_close	function
(	O
req	pointer
->	O
ex_set_arrayM	pointer
)	O
;	O
vplob_close	function
(	O
req	pointer
->	O
pre_set_arrayM	pointer
)	O
;	O
free	function
(	O
req	pointer
)	O
;	O
}	O
