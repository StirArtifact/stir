enum	O
trace_type	enum
{	O
TRACE_UDP	int
,	O
TRACE_ICMP	int
,	O
TRACE_1393	int
}	O
;	O
typedef	O
struct	O
trace	struct
{	O
int	O
icmpfd	int
,	O
udpfd	int
;	O
enum	O
trace_type	enum
type	enum
;	O
struct	O
sockaddr_in	struct
to	struct
,	O
from	struct
;	O
int	O
ttl	char
;	O
struct	O
timeval	struct
tsent	struct
;	O
}	O
trace_t	struct
;	O
void	O
trace_init	function
(	O
trace_t	struct
*	O
t	pointer
,	O
const	O
struct	O
sockaddr_in	struct
to	struct
,	O
const	O
enum	O
trace_type	enum
type	enum
)	O
;	O
void	O
trace_inc_ttl	function
(	O
trace_t	struct
*	O
t	pointer
)	O
;	O
void	O
trace_inc_port	function
(	O
trace_t	struct
*	O
t	pointer
)	O
;	O
void	O
trace_port	function
(	O
trace_t	struct
*	O
t	pointer
,	O
const	O
unsigned	O
short	O
port	short
)	O
;	O
int	O
trace_read	function
(	O
trace_t	struct
*	O
t	pointer
)	O
;	O
int	O
trace_write	function
(	O
trace_t	struct
*	O
t	pointer
)	O
;	O
int	O
trace_udp_sock	function
(	O
trace_t	struct
*	O
t	pointer
)	O
;	O
int	O
trace_icmp_sock	function
(	O
trace_t	struct
*	O
t	pointer
)	O
;	O
void	O
do_try	function
(	O
trace_t	struct
*	O
trace	struct
,	O
const	O
int	O
hop	int
,	O
const	O
int	O
max_hops	int
,	O
const	O
int	O
max_tries	int
)	O
;	O
char	O
*	O
get_hostname	function
(	O
struct	O
in_addr	struct
*	O
addr	pointer
)	O
;	O
int	O
stop	int
=	O
0	int
;	O
int	O
pid	int
=	O
0	int
;	O
static	O
char	O
*	O
hostname	pointer
=	O
NULL	O
;	O
char	O
addrstr	array
[	O
INET6_ADDRSTRLEN	int
]	O
;	O
struct	O
sockaddr_in	struct
dest	struct
;	O
static	O
enum	O
trace_type	enum
opt_type	enum
=	O
TRACE_ICMP	int
;	O
int	O
opt_port	int
=	O
33434	int
;	O
int	O
opt_max_hops	int
=	O
64	int
;	O
static	O
int	O
opt_max_tries	int
=	O
3	int
;	O
int	O
opt_resolve_hostnames	int
=	O
0	int
;	O
const	O
char	O
args_doc	pointer
[	O
]	O
=	O
"HOST"	pointer
;	O
const	O
char	O
doc	pointer
[	O
]	O
=	O
"Print the route packets trace to network host."	pointer
;	O
const	O
char	O
*	O
program_authors	array
[	O
]	O
=	O
{	O
"Elian Gidoni"	pointer
,	O
NULL	O
}	O
;	O
enum	O
{	O
OPT_RESOLVE	int
=	O
256	int
}	O
;	O
static	O
struct	O
argp_option	struct
argp_options	array
[	O
]	O
=	O
{	O
{	O
"port"	pointer
,	O
'p'	O
,	O
"PORT"	pointer
,	O
0	int
,	O
"use destination PORT port (default: 33434)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"resolve-hostnames"	pointer
,	O
OPT_RESOLVE	int
,	O
NULL	O
,	O
0	int
,	O
"resolve hostnames"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"tries"	pointer
,	O
'q'	O
,	O
"NUM"	pointer
,	O
0	int
,	O
"send NUM probe packets per hop (default: 3)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"type"	pointer
,	O
'M'	O
,	O
"METHOD"	pointer
,	O
0	int
,	O
"use METHOD (`icmp' or `udp') for traceroute "	pointer
"operations"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
static	O
bool	bool
host_is_given	bool
=	O
false	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
'p'	O
:	O
opt_port	int
=	O
strtoul	function
(	O
arg	pointer
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
||	O
opt_port	int
==	O
0	int
||	O
opt_port	int
>	O
65536	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"invalid port number `%s'"	pointer
,	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_RESOLVE	int
:	O
opt_resolve_hostnames	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
opt_max_tries	int
=	O
(	O
int	O
)	O
strtol	function
(	O
arg	pointer
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
argp_error	function
(	O
state	pointer
,	O
"invalid value (`%s' near `%s')"	pointer
,	O
arg	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
opt_max_tries	int
<	O
1	int
||	O
opt_max_tries	int
>	O
10	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"number of tries should be between 1 and 10"	pointer
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"icmp"	pointer
)	O
==	O
0	int
)	O
opt_type	enum
=	O
TRACE_ICMP	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"udp"	pointer
)	O
==	O
0	int
)	O
opt_type	enum
=	O
TRACE_UDP	int
;	O
else	O
argp_error	function
(	O
state	pointer
,	O
"invalid method"	pointer
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	int
:	O
host_is_given	bool
=	O
true	int
;	O
hostname	pointer
=	O
xstrdup	function
(	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
ARGP_KEY_SUCCESS	int
:	O
if	O
(	O
!	O
host_is_given	bool
)	O
argp_error	function
(	O
state	pointer
,	O
"missing host operand"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
argp_options	array
,	O
parse_opt	function
,	O
args_doc	pointer
,	O
doc	pointer
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
addrinfo	struct
hints	struct
,	O
*	O
res	pointer
;	O
trace_t	struct
trace	struct
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"traceroute"	pointer
,	O
program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_family	int
=	O
AF_INET	O
;	O
hints	struct
.	O
ai_flags	int
=	O
AI_CANONNAME	int
;	O
if	O
(	O
(	O
hostname	pointer
==	O
NULL	O
)	O
||	O
(	O
*	O
hostname	pointer
==	O
'\0'	O
)	O
||	O
getaddrinfo	function
(	O
hostname	pointer
,	O
NULL	O
,	O
&	O
hints	struct
,	O
&	O
res	pointer
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"unknown host"	pointer
)	O
;	O
memcpy	function
(	O
&	O
dest	struct
,	O
res	pointer
->	O
ai_addr	pointer
,	O
res	pointer
->	O
ai_addrlen	int
)	O
;	O
dest	struct
.	O
sin_port	short
=	O
htons	function
(	O
opt_port	int
)	O
;	O
getnameinfo	function
(	O
res	pointer
->	O
ai_addr	pointer
,	O
res	pointer
->	O
ai_addrlen	int
,	O
addrstr	array
,	O
sizeof	O
(	O
addrstr	array
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NUMERICHOST	int
)	O
;	O
printf	function
(	O
"traceroute to %s (%s), %d hops max\n"	pointer
,	O
res	pointer
->	O
ai_canonname	pointer
,	O
addrstr	array
,	O
opt_max_hops	int
)	O
;	O
freeaddrinfo	function
(	O
res	pointer
)	O
;	O
trace_init	function
(	O
&	O
trace	struct
,	O
dest	struct
,	O
opt_type	enum
)	O
;	O
int	O
hop	int
=	O
1	int
;	O
while	O
(	O
!	O
stop	int
)	O
{	O
if	O
(	O
hop	int
>	O
opt_max_hops	int
)	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
do_try	function
(	O
&	O
trace	struct
,	O
hop	int
,	O
opt_max_hops	int
,	O
opt_max_tries	int
)	O
;	O
trace_inc_ttl	function
(	O
&	O
trace	struct
)	O
;	O
trace_inc_port	function
(	O
&	O
trace	struct
)	O
;	O
hop	int
++	O
;	O
}	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
do_try	function
(	O
trace_t	struct
*	O
trace	struct
,	O
const	O
int	O
hop	int
,	O
const	O
int	O
max_hops	int
,	O
const	O
int	O
max_tries	int
)	O
{	O
fd_set	struct
readset	struct
;	O
int	O
ret	int
,	O
tries	int
,	O
readonly	int
=	O
0	int
;	O
struct	O
timeval	struct
now	struct
,	O
time	struct
;	O
double	O
triptime	double
=	O
0.0	int
;	O
uint32_t	int
prev_addr	int
=	O
0	int
;	O
printf	function
(	O
" %d  "	pointer
,	O
hop	int
)	O
;	O
for	O
(	O
tries	int
=	O
0	int
;	O
tries	int
<	O
max_tries	int
;	O
tries	int
++	O
)	O
{	O
FD_ZERO	O
(	O
&	O
readset	struct
)	O
;	O
FD_SET	O
(	O
trace_icmp_sock	function
(	O
trace	struct
)	O
,	O
&	O
readset	struct
)	O
;	O
time	struct
.	O
tv_sec	long
=	O
TIME_INTERVAL	int
;	O
time	struct
.	O
tv_usec	long
=	O
0	int
;	O
if	O
(	O
!	O
readonly	int
)	O
trace_write	function
(	O
trace	struct
)	O
;	O
ret	int
=	O
select	function
(	O
FD_SETSIZE	O
,	O
&	O
readset	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
time	struct
)	O
;	O
gettimeofday	function
(	O
&	O
now	struct
,	O
NULL	O
)	O
;	O
now	struct
.	O
tv_usec	long
-=	O
trace	struct
->	O
tsent	struct
.	O
tv_usec	long
;	O
now	struct
.	O
tv_sec	long
-=	O
trace	struct
->	O
tsent	struct
.	O
tv_sec	long
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
EINTR	int
:	O
break	O
;	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
EPERM	int
,	O
"select failed"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
printf	function
(	O
" * "	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
FD_ISSET	O
(	O
trace_icmp_sock	function
(	O
trace	struct
)	O
,	O
&	O
readset	struct
)	O
)	O
{	O
triptime	double
=	O
(	O
(	O
double	O
)	O
now	struct
.	O
tv_sec	long
)	O
*	O
1000.0	int
+	O
(	O
(	O
double	O
)	O
now	struct
.	O
tv_usec	long
)	O
/	O
1000.0	int
;	O
if	O
(	O
trace_read	function
(	O
trace	struct
)	O
)	O
{	O
tries	int
--	O
;	O
readonly	int
=	O
1	int
;	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
tries	int
==	O
0	int
||	O
prev_addr	int
!=	O
trace	struct
->	O
from	struct
.	O
sin_addr	struct
.	O
s_addr	int
)	O
printf	function
(	O
" %s (%s) "	pointer
,	O
inet_ntoa	function
(	O
trace	struct
->	O
from	struct
.	O
sin_addr	struct
)	O
,	O
get_hostname	function
(	O
&	O
trace	struct
->	O
from	struct
.	O
sin_addr	struct
)	O
)	O
;	O
printf	function
(	O
"%.3fms "	pointer
,	O
triptime	double
)	O
;	O
}	O
prev_addr	int
=	O
trace	struct
->	O
from	struct
.	O
sin_addr	struct
.	O
s_addr	int
;	O
}	O
}	O
readonly	int
=	O
0	int
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
char	O
*	O
get_hostname	function
(	O
struct	O
in_addr	struct
*	O
addr	pointer
)	O
{	O
if	O
(	O
opt_resolve_hostnames	int
)	O
{	O
struct	O
hostent	struct
*	O
info	pointer
=	O
gethostbyaddr	function
(	O
(	O
char	O
*	O
)	O
addr	pointer
,	O
sizeof	O
(	O
*	O
addr	pointer
)	O
,	O
AF_INET	O
)	O
;	O
if	O
(	O
info	pointer
!=	O
NULL	O
)	O
return	O
info	pointer
->	O
h_name	pointer
;	O
}	O
return	O
inet_ntoa	function
(	O
*	O
addr	pointer
)	O
;	O
}	O
void	O
trace_init	function
(	O
trace_t	struct
*	O
t	pointer
,	O
const	O
struct	O
sockaddr_in	struct
to	struct
,	O
const	O
enum	O
trace_type	enum
type	enum
)	O
{	O
const	O
int	O
*	O
ttlp	pointer
;	O
assert	O
(	O
t	pointer
)	O
;	O
ttlp	pointer
=	O
&	O
t	pointer
->	O
ttl	char
;	O
t	pointer
->	O
type	enum
=	O
type	enum
;	O
t	pointer
->	O
to	struct
=	O
to	struct
;	O
t	pointer
->	O
ttl	char
=	O
TRACE_TTL	int
;	O
if	O
(	O
t	pointer
->	O
type	enum
==	O
TRACE_UDP	int
)	O
{	O
t	pointer
->	O
udpfd	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
t	pointer
->	O
udpfd	int
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"socket"	pointer
)	O
;	O
if	O
(	O
setsockopt	function
(	O
t	pointer
->	O
udpfd	int
,	O
IPPROTO_IP	int
,	O
IP_TTL	int
,	O
ttlp	pointer
,	O
sizeof	O
(	O
*	O
ttlp	pointer
)	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"setsockopt"	pointer
)	O
;	O
}	O
if	O
(	O
t	pointer
->	O
type	enum
==	O
TRACE_ICMP	int
||	O
t	pointer
->	O
type	enum
==	O
TRACE_UDP	int
)	O
{	O
struct	O
protoent	struct
*	O
protocol	char
=	O
getprotobyname	function
(	O
"icmp"	pointer
)	O
;	O
if	O
(	O
protocol	char
)	O
{	O
t	pointer
->	O
icmpfd	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_RAW	int
,	O
protocol	char
->	O
p_proto	int
)	O
;	O
if	O
(	O
t	pointer
->	O
icmpfd	int
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"socket"	pointer
)	O
;	O
if	O
(	O
setsockopt	function
(	O
t	pointer
->	O
icmpfd	int
,	O
IPPROTO_IP	int
,	O
IP_TTL	int
,	O
ttlp	pointer
,	O
sizeof	O
(	O
*	O
ttlp	pointer
)	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"setsockopt"	pointer
)	O
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"can't find supplied protocol 'icmp'"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
}	O
}	O
void	O
trace_port	function
(	O
trace_t	struct
*	O
t	pointer
,	O
const	O
unsigned	O
short	O
int	O
port	short
)	O
{	O
assert	O
(	O
t	pointer
)	O
;	O
if	O
(	O
port	short
<	O
IPPORT_RESERVED	int
)	O
t	pointer
->	O
to	struct
.	O
sin_port	short
=	O
TRACE_UDP_PORT	int
;	O
else	O
t	pointer
->	O
to	struct
.	O
sin_port	short
=	O
port	short
;	O
}	O
int	O
trace_read	function
(	O
trace_t	struct
*	O
t	pointer
)	O
{	O
int	O
len	char
;	O
unsigned	O
char	O
data	array
[	O
56	int
]	O
;	O
struct	O
ip	struct
*	O
ip	struct
;	O
icmphdr_t	struct
*	O
ic	pointer
;	O
socklen_t	int
siz	int
;	O
assert	O
(	O
t	pointer
)	O
;	O
siz	int
=	O
sizeof	O
(	O
t	pointer
->	O
from	struct
)	O
;	O
len	char
=	O
recvfrom	function
(	O
t	pointer
->	O
icmpfd	int
,	O
(	O
char	O
*	O
)	O
data	array
,	O
56	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
t	pointer
->	O
from	struct
,	O
&	O
siz	int
)	O
;	O
if	O
(	O
len	char
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"recvfrom"	pointer
)	O
;	O
icmp_generic_decode	function
(	O
data	array
,	O
56	int
,	O
&	O
ip	struct
,	O
&	O
ic	pointer
)	O
;	O
switch	O
(	O
t	pointer
->	O
type	enum
)	O
{	O
case	O
TRACE_UDP	int
:	O
{	O
unsigned	O
short	O
*	O
port	short
;	O
if	O
(	O
(	O
ic	pointer
->	O
icmp_type	char
!=	O
ICMP_TIME_EXCEEDED	int
&&	O
ic	pointer
->	O
icmp_type	char
!=	O
ICMP_DEST_UNREACH	int
)	O
||	O
(	O
ic	pointer
->	O
icmp_type	char
==	O
ICMP_DEST_UNREACH	int
&&	O
ic	pointer
->	O
icmp_code	char
!=	O
ICMP_PORT_UNREACH	int
)	O
)	O
return	O
-	O
1	int
;	O
port	short
=	O
(	O
unsigned	O
short	O
*	O
)	O
&	O
ic	pointer
->	O
icmp_ip	O
+	O
11	int
;	O
if	O
(	O
*	O
port	short
!=	O
t	pointer
->	O
to	struct
.	O
sin_port	short
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ic	pointer
->	O
icmp_code	char
==	O
ICMP_PORT_UNREACH	int
)	O
stop	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
TRACE_ICMP	int
:	O
if	O
(	O
ic	pointer
->	O
icmp_type	char
!=	O
ICMP_TIME_EXCEEDED	int
&&	O
ic	pointer
->	O
icmp_type	char
!=	O
ICMP_ECHOREPLY	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ic	pointer
->	O
icmp_type	char
==	O
ICMP_ECHOREPLY	int
&&	O
(	O
ic	pointer
->	O
icmp_seq	O
!=	O
pid	int
||	O
ic	pointer
->	O
icmp_id	O
!=	O
pid	int
)	O
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
ic	pointer
->	O
icmp_type	char
==	O
ICMP_TIME_EXCEEDED	int
)	O
{	O
unsigned	O
short	O
*	O
seq	pointer
=	O
(	O
unsigned	O
short	O
*	O
)	O
&	O
ic	pointer
->	O
icmp_ip	O
+	O
12	int
;	O
unsigned	O
short	O
*	O
ident	int
=	O
(	O
unsigned	O
short	O
*	O
)	O
&	O
ic	pointer
->	O
icmp_ip	O
+	O
13	int
;	O
if	O
(	O
*	O
seq	pointer
!=	O
pid	int
||	O
*	O
ident	int
!=	O
pid	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ip	struct
->	O
ip_src	struct
.	O
s_addr	int
==	O
dest	struct
.	O
sin_addr	struct
.	O
s_addr	int
)	O
stop	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
trace_write	function
(	O
trace_t	struct
*	O
t	pointer
)	O
{	O
int	O
len	char
;	O
assert	O
(	O
t	pointer
)	O
;	O
switch	O
(	O
t	pointer
->	O
type	enum
)	O
{	O
case	O
TRACE_UDP	int
:	O
{	O
char	O
data	array
[	O
]	O
=	O
"SUPERMAN"	pointer
;	O
len	char
=	O
sendto	function
(	O
t	pointer
->	O
udpfd	int
,	O
(	O
char	O
*	O
)	O
data	array
,	O
sizeof	O
(	O
data	array
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
t	pointer
->	O
to	struct
,	O
sizeof	O
(	O
t	pointer
->	O
to	struct
)	O
)	O
;	O
if	O
(	O
len	char
<	O
0	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
ECONNRESET	int
:	O
break	O
;	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"sendto"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
gettimeofday	function
(	O
&	O
t	pointer
->	O
tsent	struct
,	O
NULL	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"gettimeofday"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
TRACE_ICMP	int
:	O
{	O
icmphdr_t	struct
hdr	struct
;	O
if	O
(	O
icmp_echo_encode	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
hdr	struct
,	O
sizeof	O
(	O
hdr	struct
)	O
,	O
pid	int
,	O
pid	int
)	O
)	O
return	O
-	O
1	int
;	O
len	char
=	O
sendto	function
(	O
t	pointer
->	O
icmpfd	int
,	O
(	O
char	O
*	O
)	O
&	O
hdr	struct
,	O
sizeof	O
(	O
hdr	struct
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
t	pointer
->	O
to	struct
,	O
sizeof	O
(	O
t	pointer
->	O
to	struct
)	O
)	O
;	O
if	O
(	O
len	char
<	O
0	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
ECONNRESET	int
:	O
break	O
;	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"sendto"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
gettimeofday	function
(	O
&	O
t	pointer
->	O
tsent	struct
,	O
NULL	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"gettimeofday"	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
trace_udp_sock	function
(	O
trace_t	struct
*	O
t	pointer
)	O
{	O
return	O
(	O
t	pointer
!=	O
NULL	O
?	O
t	pointer
->	O
udpfd	int
:	O
-	O
1	int
)	O
;	O
}	O
int	O
trace_icmp_sock	function
(	O
trace_t	struct
*	O
t	pointer
)	O
{	O
return	O
(	O
t	pointer
!=	O
NULL	O
?	O
t	pointer
->	O
icmpfd	int
:	O
-	O
1	int
)	O
;	O
}	O
void	O
trace_inc_ttl	function
(	O
trace_t	struct
*	O
t	pointer
)	O
{	O
int	O
fd	int
;	O
const	O
int	O
*	O
ttlp	pointer
;	O
assert	O
(	O
t	pointer
)	O
;	O
ttlp	pointer
=	O
&	O
t	pointer
->	O
ttl	char
;	O
t	pointer
->	O
ttl	char
++	O
;	O
fd	int
=	O
(	O
t	pointer
->	O
type	enum
==	O
TRACE_UDP	int
?	O
t	pointer
->	O
udpfd	int
:	O
t	pointer
->	O
icmpfd	int
)	O
;	O
if	O
(	O
setsockopt	function
(	O
fd	int
,	O
IPPROTO_IP	int
,	O
IP_TTL	int
,	O
ttlp	pointer
,	O
sizeof	O
(	O
*	O
ttlp	pointer
)	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"setsockopt"	pointer
)	O
;	O
}	O
void	O
trace_inc_port	function
(	O
trace_t	struct
*	O
t	pointer
)	O
{	O
assert	O
(	O
t	pointer
)	O
;	O
if	O
(	O
t	pointer
->	O
type	enum
==	O
TRACE_UDP	int
)	O
t	pointer
->	O
to	struct
.	O
sin_port	short
=	O
htons	function
(	O
ntohs	function
(	O
t	pointer
->	O
to	struct
.	O
sin_port	short
)	O
+	O
1	int
)	O
;	O
}	O
