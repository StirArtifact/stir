static	O
void	O
free_display	function
(	O
DISPLAY_LINE	struct
*	O
*	O
display	pointer
)	O
;	O
static	O
DISPLAY_LINE	struct
*	O
*	O
make_display	function
(	O
int	O
width	long
,	O
int	O
height	long
)	O
;	O
DISPLAY_LINE	struct
*	O
*	O
the_display	pointer
=	O
NULL	O
;	O
int	O
display_inhibited	int
=	O
0	int
;	O
void	O
display_initialize_display	function
(	O
int	O
width	long
,	O
int	O
height	long
)	O
{	O
free_display	function
(	O
the_display	pointer
)	O
;	O
the_display	pointer
=	O
make_display	function
(	O
width	long
,	O
height	long
)	O
;	O
display_clear_display	function
(	O
the_display	pointer
)	O
;	O
}	O
void	O
display_clear_display	function
(	O
DISPLAY_LINE	struct
*	O
*	O
display	pointer
)	O
{	O
register	O
int	O
i	int
;	O
signal_block_winch	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
display	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
display	pointer
[	O
i	int
]	O
->	O
text	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
display	pointer
[	O
i	int
]	O
->	O
textlen	int
=	O
0	int
;	O
display	pointer
[	O
i	int
]	O
->	O
inverse	int
=	O
0	int
;	O
}	O
signal_unblock_winch	function
(	O
)	O
;	O
}	O
int	O
display_was_interrupted_p	int
=	O
0	int
;	O
void	O
display_update_display	function
(	O
void	O
)	O
{	O
register	O
WINDOW	struct
*	O
win	pointer
;	O
signal_block_winch	function
(	O
)	O
;	O
display_was_interrupted_p	int
=	O
0	int
;	O
for	O
(	O
win	pointer
=	O
windows	pointer
;	O
win	pointer
;	O
win	pointer
=	O
win	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
win	pointer
->	O
flags	int
&	O
W_WindowVisible	int
)	O
==	O
0	int
||	O
(	O
win	pointer
->	O
flags	int
&	O
W_UpdateWindow	int
)	O
==	O
0	int
||	O
win	pointer
->	O
height	long
==	O
0	int
)	O
continue	O
;	O
display_update_one_window	function
(	O
win	pointer
)	O
;	O
if	O
(	O
display_was_interrupted_p	int
)	O
break	O
;	O
}	O
display_update_one_window	function
(	O
the_echo_area	pointer
)	O
;	O
signal_unblock_winch	function
(	O
)	O
;	O
}	O
static	O
int	O
find_diff	function
(	O
const	O
char	O
*	O
a	pointer
,	O
size_t	long
alen	long
,	O
const	O
char	O
*	O
b	pointer
,	O
size_t	long
blen	long
,	O
int	O
*	O
ppos	pointer
)	O
{	O
mbi_iterator_t	struct
itra	struct
,	O
itrb	struct
;	O
int	O
i	int
;	O
int	O
pos	int
=	O
0	int
;	O
int	O
first_escape	int
=	O
-	O
1	int
;	O
int	O
escape_pos	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
mbi_init	O
(	O
itra	struct
,	O
a	pointer
,	O
alen	long
)	O
,	O
mbi_init	O
(	O
itrb	struct
,	O
b	pointer
,	O
blen	long
)	O
;	O
mbi_avail	O
(	O
itra	struct
)	O
&&	O
mbi_avail	O
(	O
itrb	struct
)	O
;	O
i	int
+=	O
wcwidth	function
(	O
itra	struct
.	O
cur	struct
.	O
wc	int
)	O
,	O
mbi_advance	O
(	O
itra	struct
)	O
,	O
mbi_advance	O
(	O
itrb	struct
)	O
)	O
{	O
if	O
(	O
mb_cmp	O
(	O
mbi_cur	O
(	O
itra	struct
)	O
,	O
mbi_cur	O
(	O
itrb	struct
)	O
)	O
)	O
break	O
;	O
if	O
(	O
first_escape	int
==	O
-	O
1	int
&&	O
*	O
mbi_cur_ptr	O
(	O
itra	struct
)	O
==	O
'\033'	O
)	O
{	O
first_escape	int
=	O
i	int
;	O
escape_pos	int
=	O
pos	int
;	O
}	O
pos	int
+=	O
mb_len	O
(	O
mbi_cur	O
(	O
itra	struct
)	O
)	O
;	O
}	O
if	O
(	O
mbi_avail	O
(	O
itra	struct
)	O
||	O
mbi_avail	O
(	O
itrb	struct
)	O
)	O
{	O
if	O
(	O
first_escape	int
!=	O
-	O
1	int
)	O
{	O
*	O
ppos	pointer
=	O
escape_pos	int
;	O
return	O
first_escape	int
;	O
}	O
else	O
{	O
*	O
ppos	pointer
=	O
pos	int
;	O
return	O
i	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
display_update_line	function
(	O
long	O
pl_num	long
,	O
char	O
*	O
printed_line	pointer
,	O
long	O
pl_bytes	long
,	O
long	O
pl_chars	long
)	O
{	O
DISPLAY_LINE	struct
*	O
*	O
display	pointer
=	O
the_display	pointer
;	O
DISPLAY_LINE	struct
*	O
entry	pointer
;	O
entry	pointer
=	O
display	pointer
[	O
pl_num	long
]	O
;	O
if	O
(	O
entry	pointer
)	O
{	O
int	O
i	int
,	O
off	long
;	O
if	O
(	O
entry	pointer
->	O
inverse	int
)	O
{	O
terminal_goto_xy	function
(	O
0	int
,	O
pl_num	long
)	O
;	O
terminal_clear_to_eol	function
(	O
)	O
;	O
entry	pointer
->	O
inverse	int
=	O
0	int
;	O
entry	pointer
->	O
text	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
entry	pointer
->	O
textlen	int
=	O
0	int
;	O
}	O
i	int
=	O
find_diff	function
(	O
printed_line	pointer
,	O
pl_bytes	long
,	O
entry	pointer
->	O
text	pointer
,	O
strlen	function
(	O
entry	pointer
->	O
text	pointer
)	O
,	O
&	O
off	long
)	O
;	O
if	O
(	O
i	int
!=	O
-	O
1	int
)	O
{	O
terminal_goto_xy	function
(	O
i	int
,	O
pl_num	long
)	O
;	O
terminal_put_text	function
(	O
printed_line	pointer
+	O
off	long
)	O
;	O
if	O
(	O
(	O
pl_chars	long
<	O
screenwidth	int
&&	O
pl_chars	long
<	O
entry	pointer
->	O
textlen	int
)	O
||	O
entry	pointer
->	O
inverse	int
)	O
terminal_clear_to_eol	function
(	O
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
printed_line	pointer
)	O
>	O
(	O
unsigned	O
int	O
)	O
screenwidth	int
)	O
entry	pointer
->	O
text	pointer
=	O
xrealloc	function
(	O
entry	pointer
->	O
text	pointer
,	O
strlen	function
(	O
printed_line	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
entry	pointer
->	O
text	pointer
+	O
off	long
,	O
printed_line	pointer
+	O
off	long
)	O
;	O
entry	pointer
->	O
textlen	int
=	O
pl_chars	long
;	O
entry	pointer
->	O
inverse	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
info_any_buffered_input_p	function
(	O
)	O
)	O
{	O
display_was_interrupted_p	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
decide_if_in_reference	function
(	O
long	O
off	long
,	O
int	O
*	O
in_ref	pointer
,	O
REFERENCE	struct
*	O
*	O
references	pointer
,	O
int	O
*	O
ref_index	pointer
)	O
{	O
int	O
i	int
=	O
*	O
ref_index	pointer
;	O
int	O
m	int
=	O
*	O
in_ref	pointer
;	O
for	O
(	O
;	O
(	O
references	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
references	pointer
[	O
i	int
]	O
->	O
start	int
>	O
off	long
)	O
break	O
;	O
m	int
=	O
1	int
;	O
if	O
(	O
references	pointer
[	O
i	int
]	O
->	O
end	int
>	O
off	long
)	O
break	O
;	O
m	int
=	O
0	int
;	O
}	O
*	O
ref_index	pointer
=	O
i	int
;	O
*	O
in_ref	pointer
=	O
m	int
;	O
}	O
static	O
int	O
writing_out	int
;	O
static	O
void	O
wrap_terminal_switch_rendition	function
(	O
struct	O
text_buffer	struct
*	O
printed_line	pointer
,	O
RENDITION	struct
rendition1	struct
,	O
RENDITION	struct
rendition2	struct
,	O
RENDITION	struct
rendition3	struct
)	O
{	O
long	O
int	O
desired_rendition	long
=	O
0	int
;	O
desired_rendition	long
=	O
rendition1	struct
.	O
value	union
;	O
desired_rendition	long
&=	O
~	O
rendition2	struct
.	O
mask	long
;	O
desired_rendition	long
|=	O
rendition2	struct
.	O
value	union
;	O
desired_rendition	long
&=	O
~	O
rendition3	struct
.	O
mask	long
;	O
desired_rendition	long
|=	O
rendition3	struct
.	O
value	union
;	O
if	O
(	O
writing_out	int
==	O
WRITEOUT	int
)	O
terminal_switch_rendition	function
(	O
desired_rendition	long
)	O
;	O
else	O
{	O
desired_rendition	long
=	O
~	O
desired_rendition	long
;	O
text_buffer_add_string	function
(	O
printed_line	pointer
,	O
"\033"	pointer
,	O
1	int
)	O
;	O
text_buffer_add_string	function
(	O
printed_line	pointer
,	O
(	O
char	O
*	O
)	O
&	O
desired_rendition	long
,	O
sizeof	O
(	O
long	O
)	O
)	O
;	O
}	O
}	O
static	O
MATCH_STATE	struct
*	O
matches	pointer
;	O
static	O
REFERENCE	struct
*	O
*	O
refs	pointer
;	O
static	O
size_t	long
match_index	pointer
;	O
static	O
int	O
ref_index	pointer
;	O
static	O
int	O
pl_chars	long
;	O
static	O
int	O
ref_highlighted	int
;	O
static	O
int	O
pl_num	long
;	O
RENDITION	struct
ref_rendition	struct
=	O
{	O
UNDERLINE_MASK	int
,	O
UNDERLINE_MASK	int
}	O
;	O
RENDITION	struct
hl_ref_rendition	struct
=	O
{	O
UNDERLINE_MASK	int
,	O
0	int
}	O
;	O
RENDITION	struct
match_rendition	struct
=	O
{	O
STANDOUT_MASK	int
,	O
STANDOUT_MASK	int
}	O
;	O
static	O
void	O
display_process_line	function
(	O
WINDOW	struct
*	O
win	pointer
,	O
mbi_iterator_t	struct
*	O
iter_inout	pointer
,	O
struct	O
text_buffer	struct
*	O
tb_printed_line	pointer
,	O
int	O
*	O
delim	pointer
)	O
{	O
mbi_iterator_t	struct
iter	pointer
;	O
const	O
char	O
*	O
cur_ptr	pointer
;	O
size_t	long
pchars	pointer
=	O
0	int
;	O
size_t	long
pbytes	pointer
=	O
0	int
;	O
char	O
*	O
rep	pointer
;	O
int	O
in_match	pointer
=	O
0	int
;	O
int	O
in_ref	pointer
=	O
0	int
,	O
in_ref_proper	int
=	O
0	int
;	O
RENDITION	struct
empty	struct
=	O
{	O
0	int
,	O
0	int
}	O
;	O
int	O
point_in_line	int
;	O
if	O
(	O
win	pointer
->	O
point	long
>=	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
+	O
pl_num	long
]	O
&&	O
win	pointer
->	O
point	long
<	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
+	O
pl_num	long
+	O
1	int
]	O
)	O
point_in_line	int
=	O
1	int
;	O
else	O
point_in_line	int
=	O
0	int
;	O
iter	pointer
=	O
*	O
iter_inout	pointer
;	O
while	O
(	O
1	int
)	O
{	O
int	O
was_in_ref_proper	int
=	O
in_ref_proper	int
;	O
int	O
was_in_match	int
=	O
in_match	pointer
;	O
if	O
(	O
!	O
mbi_avail	O
(	O
iter	pointer
)	O
)	O
break	O
;	O
cur_ptr	pointer
=	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
;	O
if	O
(	O
matches	pointer
&&	O
matches_ready	function
(	O
matches	pointer
)	O
&&	O
!	O
at_end_of_matches	function
(	O
matches	pointer
,	O
match_index	pointer
)	O
)	O
{	O
int	O
was_in_match	int
=	O
in_match	pointer
;	O
decide_if_in_match	function
(	O
cur_ptr	pointer
-	O
win	pointer
->	O
node	pointer
->	O
contents	pointer
,	O
&	O
in_match	pointer
,	O
matches	pointer
,	O
&	O
match_index	pointer
)	O
;	O
if	O
(	O
!	O
was_in_match	int
&&	O
in_match	pointer
&&	O
writing_out	int
==	O
DEFAULT	int
)	O
writing_out	int
=	O
COLLECT	int
;	O
}	O
if	O
(	O
refs	pointer
&&	O
refs	pointer
[	O
ref_index	pointer
]	O
)	O
{	O
int	O
was_in_ref	int
=	O
in_ref	pointer
;	O
decide_if_in_reference	function
(	O
cur_ptr	pointer
-	O
win	pointer
->	O
node	pointer
->	O
contents	pointer
,	O
&	O
in_ref	pointer
,	O
refs	pointer
,	O
&	O
ref_index	pointer
)	O
;	O
if	O
(	O
was_in_ref	int
&&	O
!	O
in_ref	pointer
)	O
{	O
in_ref_proper	int
=	O
ref_highlighted	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
was_in_ref	int
&&	O
in_ref	pointer
)	O
{	O
if	O
(	O
writing_out	int
==	O
DEFAULT	int
)	O
writing_out	int
=	O
COLLECT	int
;	O
if	O
(	O
point_in_line	int
&&	O
win	pointer
->	O
point	long
<	O
refs	pointer
[	O
ref_index	pointer
]	O
->	O
end	int
)	O
{	O
point_in_line	int
=	O
0	int
;	O
ref_highlighted	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
point_in_line	int
&&	O
(	O
!	O
refs	pointer
[	O
ref_index	pointer
+	O
1	int
]	O
||	O
refs	pointer
[	O
ref_index	pointer
+	O
1	int
]	O
->	O
start	int
>=	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
+	O
pl_num	long
+	O
1	int
]	O
)	O
)	O
{	O
point_in_line	int
=	O
0	int
;	O
ref_highlighted	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
win	pointer
->	O
point	long
>=	O
refs	pointer
[	O
ref_index	pointer
]	O
->	O
start	int
&&	O
win	pointer
->	O
point	long
<	O
refs	pointer
[	O
ref_index	pointer
]	O
->	O
end	int
)	O
{	O
ref_highlighted	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
win	pointer
->	O
point	long
>=	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
+	O
pl_num	long
+	O
1	int
]	O
&&	O
win	pointer
->	O
point	long
<	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
+	O
pl_num	long
+	O
2	int
]	O
&&	O
refs	pointer
[	O
ref_index	pointer
]	O
->	O
end	int
>=	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
+	O
pl_num	long
+	O
1	int
]	O
&&	O
(	O
!	O
refs	pointer
[	O
ref_index	pointer
+	O
1	int
]	O
||	O
refs	pointer
[	O
ref_index	pointer
+	O
1	int
]	O
->	O
start	int
>=	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
+	O
pl_num	long
+	O
2	int
]	O
)	O
)	O
{	O
ref_highlighted	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
in_ref	pointer
&&	O
!	O
in_ref_proper	int
&&	O
!	O
strchr	function
(	O
" \t"	pointer
,	O
*	O
cur_ptr	pointer
)	O
)	O
in_ref_proper	int
=	O
1	int
;	O
if	O
(	O
was_in_ref_proper	int
!=	O
in_ref_proper	int
||	O
was_in_match	int
!=	O
in_match	pointer
)	O
{	O
RENDITION	struct
ref	pointer
=	O
{	O
0	int
,	O
0	int
}	O
;	O
RENDITION	struct
match	struct
=	O
{	O
0	int
,	O
0	int
}	O
;	O
if	O
(	O
in_ref_proper	int
)	O
ref	pointer
=	O
ref_highlighted	int
&&	O
hl_ref_rendition	struct
.	O
mask	long
?	O
hl_ref_rendition	struct
:	O
ref_rendition	struct
;	O
if	O
(	O
in_match	pointer
)	O
match	struct
=	O
match_rendition	struct
;	O
if	O
(	O
!	O
ref_highlighted	int
)	O
{	O
wrap_terminal_switch_rendition	function
(	O
tb_printed_line	pointer
,	O
ref	pointer
,	O
match	struct
,	O
empty	struct
)	O
;	O
}	O
else	O
{	O
wrap_terminal_switch_rendition	function
(	O
tb_printed_line	pointer
,	O
match	struct
,	O
ref	pointer
,	O
empty	struct
)	O
;	O
}	O
}	O
rep	pointer
=	O
printed_representation	function
(	O
&	O
iter	pointer
,	O
delim	pointer
,	O
pl_chars	long
,	O
&	O
pchars	pointer
,	O
&	O
pbytes	pointer
)	O
;	O
if	O
(	O
*	O
delim	pointer
||	O
pl_chars	long
+	O
pchars	pointer
>=	O
win	pointer
->	O
width	long
)	O
break	O
;	O
if	O
(	O
rep	pointer
)	O
{	O
if	O
(	O
writing_out	int
!=	O
WRITEOUT	int
)	O
text_buffer_add_string	function
(	O
tb_printed_line	pointer
,	O
rep	pointer
,	O
pbytes	pointer
)	O
;	O
else	O
terminal_write_chars	function
(	O
rep	pointer
,	O
pbytes	pointer
)	O
;	O
pl_chars	long
+=	O
pchars	pointer
;	O
}	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
}	O
if	O
(	O
writing_out	int
!=	O
DEFAULT	int
)	O
wrap_terminal_switch_rendition	function
(	O
tb_printed_line	pointer
,	O
empty	struct
,	O
empty	struct
,	O
empty	struct
)	O
;	O
*	O
iter_inout	pointer
=	O
iter	pointer
;	O
}	O
int	O
display_update_node_text	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
static	O
struct	O
text_buffer	struct
tb_printed_line	pointer
;	O
mbi_iterator_t	struct
iter	pointer
;	O
mbi_iterator_t	struct
bol_iter	struct
;	O
int	O
bol_ref_index	int
=	O
0	int
,	O
bol_match_index	int
=	O
0	int
;	O
int	O
bol_ref_highlighted	int
;	O
int	O
finish	int
;	O
matches	pointer
=	O
0	int
;	O
refs	pointer
=	O
0	int
;	O
if	O
(	O
match_rendition	struct
.	O
mask	long
)	O
matches	pointer
=	O
&	O
win	pointer
->	O
matches	pointer
;	O
if	O
(	O
ref_rendition	struct
.	O
mask	long
||	O
hl_ref_rendition	struct
.	O
mask	long
)	O
refs	pointer
=	O
win	pointer
->	O
node	pointer
->	O
references	pointer
;	O
pl_num	long
=	O
0	int
;	O
ref_highlighted	int
=	O
0	int
;	O
writing_out	int
=	O
DEFAULT	int
;	O
ref_index	pointer
=	O
match_index	pointer
=	O
0	int
;	O
mbi_init	O
(	O
iter	pointer
,	O
win	pointer
->	O
node	pointer
->	O
contents	pointer
+	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
]	O
,	O
win	pointer
->	O
node	pointer
->	O
nodelen	long
-	O
win	pointer
->	O
line_starts	pointer
[	O
win	pointer
->	O
pagetop	long
]	O
)	O
;	O
mbi_avail	O
(	O
iter	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
delim	pointer
;	O
mbi_copy	O
(	O
&	O
bol_iter	struct
,	O
&	O
iter	pointer
)	O
;	O
bol_ref_index	int
=	O
ref_index	pointer
;	O
bol_match_index	int
=	O
match_index	pointer
;	O
bol_ref_highlighted	int
=	O
ref_highlighted	int
;	O
start_of_line	O
:	O
pl_chars	long
=	O
0	int
;	O
text_buffer_reset	O
(	O
&	O
tb_printed_line	pointer
)	O
;	O
delim	pointer
=	O
0	int
;	O
if	O
(	O
pl_num	long
==	O
win	pointer
->	O
height	long
)	O
break	O
;	O
if	O
(	O
win	pointer
->	O
first_row	long
+	O
pl_num	long
>=	O
screenheight	int
)	O
break	O
;	O
display_process_line	function
(	O
win	pointer
,	O
&	O
iter	pointer
,	O
&	O
tb_printed_line	pointer
,	O
&	O
delim	pointer
)	O
;	O
text_buffer_add_char	function
(	O
&	O
tb_printed_line	pointer
,	O
'\0'	O
)	O
;	O
finish	int
=	O
0	int
;	O
if	O
(	O
writing_out	int
==	O
DEFAULT	int
)	O
{	O
finish	int
=	O
display_update_line	function
(	O
win	pointer
->	O
first_row	long
+	O
pl_num	long
,	O
text_buffer_base	O
(	O
&	O
tb_printed_line	pointer
)	O
,	O
text_buffer_off	O
(	O
&	O
tb_printed_line	pointer
)	O
-	O
1	int
,	O
pl_chars	long
)	O
;	O
}	O
else	O
if	O
(	O
writing_out	int
==	O
COLLECT	int
)	O
{	O
DISPLAY_LINE	struct
*	O
entry	pointer
=	O
the_display	pointer
[	O
win	pointer
->	O
first_row	long
+	O
pl_num	long
]	O
;	O
if	O
(	O
strcmp	function
(	O
tb_printed_line	pointer
.	O
base	pointer
,	O
the_display	pointer
[	O
win	pointer
->	O
first_row	long
+	O
pl_num	long
]	O
->	O
text	pointer
)	O
)	O
{	O
if	O
(	O
tb_printed_line	pointer
.	O
off	long
>	O
screenwidth	int
)	O
{	O
entry	pointer
->	O
text	pointer
=	O
xrealloc	function
(	O
entry	pointer
->	O
text	pointer
,	O
tb_printed_line	pointer
.	O
off	long
+	O
1	int
)	O
;	O
}	O
strcpy	function
(	O
entry	pointer
->	O
text	pointer
,	O
tb_printed_line	pointer
.	O
base	pointer
)	O
;	O
entry	pointer
->	O
textlen	int
=	O
0	int
;	O
entry	pointer
->	O
inverse	int
=	O
1	int
;	O
mbi_copy	O
(	O
&	O
iter	pointer
,	O
&	O
bol_iter	struct
)	O
;	O
mbi_avail	O
(	O
bol_iter	struct
)	O
;	O
ref_index	pointer
=	O
bol_ref_index	int
;	O
match_index	pointer
=	O
bol_match_index	int
;	O
terminal_goto_xy	function
(	O
0	int
,	O
win	pointer
->	O
first_row	long
+	O
pl_num	long
)	O
;	O
ref_highlighted	int
=	O
bol_ref_highlighted	int
;	O
writing_out	int
=	O
WRITEOUT	int
;	O
goto	O
start_of_line	O
;	O
}	O
else	O
writing_out	int
=	O
DEFAULT	int
;	O
}	O
else	O
{	O
terminal_clear_to_eol	function
(	O
)	O
;	O
writing_out	int
=	O
DEFAULT	int
;	O
}	O
if	O
(	O
delim	pointer
)	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
else	O
if	O
(	O
win	pointer
->	O
first_row	long
+	O
pl_num	long
<=	O
the_screen	pointer
->	O
height	long
-	O
2	int
)	O
{	O
terminal_goto_xy	function
(	O
win	pointer
->	O
width	long
-	O
1	int
,	O
win	pointer
->	O
first_row	long
+	O
pl_num	long
)	O
;	O
if	O
(	O
!	O
(	O
win	pointer
->	O
flags	int
&	O
W_NoWrap	int
)	O
)	O
terminal_put_text	function
(	O
"\\"	pointer
)	O
;	O
else	O
{	O
terminal_put_text	function
(	O
"$"	pointer
)	O
;	O
for	O
(	O
;	O
mbi_avail	O
(	O
iter	pointer
)	O
;	O
mbi_advance	O
(	O
iter	pointer
)	O
)	O
if	O
(	O
mb_len	O
(	O
mbi_cur	O
(	O
iter	pointer
)	O
)	O
==	O
1	int
&&	O
*	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
==	O
'\n'	O
)	O
{	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
break	O
;	O
}	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
pl_num	long
++	O
;	O
if	O
(	O
finish	int
)	O
break	O
;	O
if	O
(	O
!	O
mbi_avail	O
(	O
iter	pointer
)	O
)	O
break	O
;	O
}	O
return	O
pl_num	long
;	O
}	O
void	O
display_update_one_window	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
size_t	long
line_index	long
=	O
0	int
;	O
DISPLAY_LINE	struct
*	O
*	O
display	pointer
=	O
the_display	pointer
;	O
signal_block_winch	function
(	O
)	O
;	O
if	O
(	O
display_inhibited	int
)	O
{	O
display_was_interrupted_p	int
=	O
1	int
;	O
goto	O
funexit	O
;	O
}	O
if	O
(	O
win	pointer
->	O
height	long
<=	O
0	int
||	O
win	pointer
->	O
width	long
<=	O
0	int
)	O
goto	O
funexit	O
;	O
if	O
(	O
(	O
win	pointer
->	O
first_row	long
<	O
0	int
)	O
||	O
(	O
win	pointer
->	O
first_row	long
>	O
the_screen	pointer
->	O
height	long
)	O
)	O
goto	O
funexit	O
;	O
if	O
(	O
!	O
(	O
win	pointer
->	O
flags	int
&	O
W_InhibitMode	int
)	O
)	O
{	O
window_make_modeline	function
(	O
win	pointer
)	O
;	O
line_index	long
=	O
win	pointer
->	O
first_row	long
+	O
win	pointer
->	O
height	long
;	O
if	O
(	O
(	O
!	O
display	pointer
[	O
line_index	long
]	O
->	O
inverse	int
||	O
(	O
strcmp	function
(	O
display	pointer
[	O
line_index	long
]	O
->	O
text	pointer
,	O
win	pointer
->	O
modeline	pointer
)	O
!=	O
0	int
)	O
)	O
&&	O
line_index	long
<	O
the_screen	pointer
->	O
height	long
)	O
{	O
terminal_goto_xy	function
(	O
0	int
,	O
line_index	long
)	O
;	O
terminal_begin_inverse	function
(	O
)	O
;	O
terminal_put_text	function
(	O
win	pointer
->	O
modeline	pointer
)	O
;	O
terminal_end_inverse	function
(	O
)	O
;	O
strcpy	function
(	O
display	pointer
[	O
line_index	long
]	O
->	O
text	pointer
,	O
win	pointer
->	O
modeline	pointer
)	O
;	O
display	pointer
[	O
line_index	long
]	O
->	O
inverse	int
=	O
1	int
;	O
display	pointer
[	O
line_index	long
]	O
->	O
textlen	int
=	O
strlen	function
(	O
win	pointer
->	O
modeline	pointer
)	O
;	O
}	O
}	O
if	O
(	O
win	pointer
->	O
node	pointer
)	O
{	O
if	O
(	O
!	O
win	pointer
->	O
line_starts	pointer
)	O
calculate_line_starts	function
(	O
win	pointer
)	O
;	O
line_index	long
=	O
display_update_node_text	function
(	O
win	pointer
)	O
;	O
if	O
(	O
display_was_interrupted_p	int
)	O
goto	O
funexit	O
;	O
}	O
for	O
(	O
;	O
line_index	long
<	O
win	pointer
->	O
height	long
;	O
line_index	long
++	O
)	O
{	O
DISPLAY_LINE	struct
*	O
entry	pointer
=	O
display	pointer
[	O
win	pointer
->	O
first_row	long
+	O
line_index	long
]	O
;	O
if	O
(	O
entry	pointer
->	O
textlen	int
||	O
entry	pointer
->	O
inverse	int
)	O
{	O
entry	pointer
->	O
textlen	int
=	O
0	int
;	O
entry	pointer
->	O
text	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
entry	pointer
->	O
inverse	int
=	O
0	int
;	O
terminal_goto_xy	function
(	O
0	int
,	O
win	pointer
->	O
first_row	long
+	O
line_index	long
)	O
;	O
terminal_clear_to_eol	function
(	O
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
info_any_buffered_input_p	function
(	O
)	O
)	O
{	O
display_was_interrupted_p	int
=	O
1	int
;	O
goto	O
funexit	O
;	O
}	O
}	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
win	pointer
->	O
flags	int
&=	O
~	O
W_UpdateWindow	int
;	O
funexit	O
:	O
signal_unblock_winch	function
(	O
)	O
;	O
}	O
static	O
void	O
display_scroll_region	function
(	O
int	O
start	int
,	O
int	O
end	int
,	O
int	O
amount	int
)	O
{	O
int	O
i	int
;	O
DISPLAY_LINE	struct
*	O
temp	pointer
;	O
terminal_scroll_region	function
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
if	O
(	O
amount	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
end	int
-	O
1	int
;	O
i	int
>=	O
start	int
+	O
amount	int
;	O
i	int
--	O
)	O
{	O
temp	pointer
=	O
the_display	pointer
[	O
i	int
]	O
;	O
the_display	pointer
[	O
i	int
]	O
=	O
the_display	pointer
[	O
i	int
-	O
amount	int
]	O
;	O
the_display	pointer
[	O
i	int
-	O
amount	int
]	O
=	O
temp	pointer
;	O
}	O
for	O
(	O
i	int
=	O
start	int
;	O
i	int
<	O
start	int
+	O
amount	int
&&	O
i	int
<	O
end	int
;	O
i	int
++	O
)	O
{	O
the_display	pointer
[	O
i	int
]	O
->	O
text	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
the_display	pointer
[	O
i	int
]	O
->	O
textlen	int
=	O
0	int
;	O
the_display	pointer
[	O
i	int
]	O
->	O
inverse	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
amount	int
*=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
start	int
;	O
i	int
<=	O
end	int
-	O
1	int
-	O
amount	int
;	O
i	int
++	O
)	O
{	O
temp	pointer
=	O
the_display	pointer
[	O
i	int
]	O
;	O
the_display	pointer
[	O
i	int
]	O
=	O
the_display	pointer
[	O
i	int
+	O
amount	int
]	O
;	O
the_display	pointer
[	O
i	int
+	O
amount	int
]	O
=	O
temp	pointer
;	O
}	O
for	O
(	O
i	int
=	O
end	int
-	O
1	int
;	O
i	int
>=	O
end	int
-	O
amount	int
&&	O
i	int
>=	O
start	int
;	O
i	int
--	O
)	O
{	O
the_display	pointer
[	O
i	int
]	O
->	O
text	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
the_display	pointer
[	O
i	int
]	O
->	O
textlen	int
=	O
0	int
;	O
the_display	pointer
[	O
i	int
]	O
->	O
inverse	int
=	O
0	int
;	O
}	O
}	O
}	O
void	O
display_scroll_display	function
(	O
int	O
start	int
,	O
int	O
end	int
,	O
int	O
amount	int
)	O
{	O
register	O
int	O
i	int
,	O
last	int
;	O
DISPLAY_LINE	struct
*	O
temp	pointer
;	O
if	O
(	O
!	O
terminal_can_scroll	int
&&	O
!	O
terminal_can_scroll_region	int
)	O
return	O
;	O
if	O
(	O
!	O
the_display	pointer
[	O
0	int
]	O
)	O
return	O
;	O
if	O
(	O
info_any_buffered_input_p	function
(	O
)	O
)	O
return	O
;	O
if	O
(	O
terminal_can_scroll_region	int
)	O
{	O
display_scroll_region	function
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
amount	int
<	O
0	int
)	O
start	int
-=	O
amount	int
;	O
else	O
end	int
-=	O
amount	int
;	O
terminal_scroll_terminal	function
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
if	O
(	O
amount	int
>	O
0	int
)	O
{	O
last	int
=	O
end	int
+	O
amount	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
(	O
end	int
-	O
start	int
)	O
;	O
i	int
++	O
)	O
{	O
temp	pointer
=	O
the_display	pointer
[	O
last	int
-	O
i	int
]	O
;	O
the_display	pointer
[	O
last	int
-	O
i	int
]	O
=	O
the_display	pointer
[	O
end	int
-	O
i	int
]	O
;	O
the_display	pointer
[	O
end	int
-	O
i	int
]	O
=	O
temp	pointer
;	O
}	O
for	O
(	O
i	int
=	O
start	int
;	O
i	int
!=	O
(	O
start	int
+	O
amount	int
)	O
;	O
i	int
++	O
)	O
{	O
the_display	pointer
[	O
i	int
]	O
->	O
text	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
the_display	pointer
[	O
i	int
]	O
->	O
textlen	int
=	O
0	int
;	O
the_display	pointer
[	O
i	int
]	O
->	O
inverse	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
last	int
=	O
start	int
+	O
amount	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
end	int
-	O
start	int
)	O
;	O
i	int
++	O
)	O
{	O
temp	pointer
=	O
the_display	pointer
[	O
last	int
+	O
i	int
]	O
;	O
the_display	pointer
[	O
last	int
+	O
i	int
]	O
=	O
the_display	pointer
[	O
start	int
+	O
i	int
]	O
;	O
the_display	pointer
[	O
start	int
+	O
i	int
]	O
=	O
temp	pointer
;	O
}	O
for	O
(	O
i	int
=	O
end	int
+	O
amount	int
;	O
i	int
!=	O
end	int
;	O
i	int
++	O
)	O
{	O
the_display	pointer
[	O
i	int
]	O
->	O
text	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
the_display	pointer
[	O
i	int
]	O
->	O
textlen	int
=	O
0	int
;	O
the_display	pointer
[	O
i	int
]	O
->	O
inverse	int
=	O
0	int
;	O
}	O
}	O
}	O
void	O
display_scroll_line_starts	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
old_pagetop	int
,	O
long	O
*	O
old_starts	pointer
,	O
int	O
old_count	int
)	O
{	O
register	O
int	O
i	int
,	O
old	int
,	O
new	int
;	O
int	O
last_new	int
,	O
last_old	int
;	O
int	O
old_first	int
,	O
new_first	int
;	O
int	O
unchanged_at_top	int
=	O
0	int
;	O
int	O
already_scrolled	int
=	O
0	int
;	O
old_first	int
=	O
old_pagetop	int
;	O
new_first	int
=	O
window	pointer
->	O
pagetop	long
;	O
last_new	int
=	O
window	pointer
->	O
pagetop	long
+	O
(	O
window	pointer
->	O
height	long
-	O
1	int
)	O
;	O
if	O
(	O
last_new	int
>	O
window	pointer
->	O
line_count	long
)	O
last_new	int
=	O
window	pointer
->	O
line_count	long
-	O
1	int
;	O
last_old	int
=	O
old_pagetop	int
+	O
(	O
window	pointer
->	O
height	long
-	O
1	int
)	O
;	O
if	O
(	O
last_old	int
>	O
old_count	int
)	O
last_old	int
=	O
old_count	int
-	O
1	int
;	O
for	O
(	O
old	int
=	O
old_first	int
,	O
new	int
=	O
new_first	int
;	O
old	int
<	O
last_old	int
&&	O
new	int
<	O
last_new	int
;	O
old	int
++	O
,	O
new	int
++	O
)	O
if	O
(	O
old_starts	pointer
[	O
old	int
]	O
!=	O
window	pointer
->	O
line_starts	pointer
[	O
new	int
]	O
)	O
break	O
;	O
else	O
unchanged_at_top	int
++	O
;	O
for	O
(	O
old	int
=	O
old_first	int
+	O
unchanged_at_top	int
;	O
old	int
<	O
last_old	int
;	O
old	int
++	O
)	O
{	O
for	O
(	O
new	int
=	O
new_first	int
;	O
new	int
<	O
last_new	int
;	O
new	int
++	O
)	O
if	O
(	O
old_starts	pointer
[	O
old	int
]	O
==	O
window	pointer
->	O
line_starts	pointer
[	O
new	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
old	int
+	O
i	int
)	O
<	O
last_old	int
;	O
i	int
++	O
)	O
if	O
(	O
old_starts	pointer
[	O
old	int
+	O
i	int
]	O
!=	O
window	pointer
->	O
line_starts	pointer
[	O
new	int
+	O
i	int
]	O
)	O
break	O
;	O
{	O
int	O
start	int
,	O
end	int
,	O
amount	int
;	O
start	int
=	O
(	O
window	pointer
->	O
first_row	long
+	O
(	O
(	O
old	int
+	O
already_scrolled	int
)	O
-	O
old_pagetop	int
)	O
)	O
;	O
amount	int
=	O
new	int
-	O
(	O
old	int
+	O
already_scrolled	int
)	O
;	O
end	int
=	O
window	pointer
->	O
first_row	long
+	O
window	pointer
->	O
height	long
;	O
if	O
(	O
amount	int
>	O
0	int
)	O
end	int
-=	O
amount	int
;	O
if	O
(	O
(	O
end	int
-	O
start	int
)	O
>	O
0	int
)	O
{	O
display_scroll_display	function
(	O
start	int
,	O
end	int
,	O
amount	int
)	O
;	O
old	int
+=	O
i	int
;	O
already_scrolled	int
+=	O
amount	int
;	O
}	O
}	O
}	O
}	O
}	O
void	O
display_cursor_at_point	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
int	O
vpos	int
,	O
hpos	int
;	O
vpos	int
=	O
window_line_of_point	function
(	O
window	pointer
)	O
-	O
window	pointer
->	O
pagetop	long
+	O
window	pointer
->	O
first_row	long
;	O
hpos	int
=	O
window_get_cursor_column	function
(	O
window	pointer
)	O
;	O
terminal_goto_xy	function
(	O
hpos	int
,	O
vpos	int
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
static	O
DISPLAY_LINE	struct
*	O
*	O
make_display	function
(	O
int	O
width	long
,	O
int	O
height	long
)	O
{	O
register	O
int	O
i	int
;	O
DISPLAY_LINE	struct
*	O
*	O
display	pointer
;	O
display	pointer
=	O
xmalloc	function
(	O
(	O
1	int
+	O
height	long
)	O
*	O
sizeof	O
(	O
DISPLAY_LINE	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
height	long
;	O
i	int
++	O
)	O
{	O
display	pointer
[	O
i	int
]	O
=	O
xmalloc	function
(	O
sizeof	O
(	O
DISPLAY_LINE	struct
)	O
)	O
;	O
display	pointer
[	O
i	int
]	O
->	O
text	pointer
=	O
xmalloc	function
(	O
1	int
+	O
width	long
)	O
;	O
display	pointer
[	O
i	int
]	O
->	O
textlen	int
=	O
0	int
;	O
display	pointer
[	O
i	int
]	O
->	O
inverse	int
=	O
0	int
;	O
}	O
display	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
return	O
display	pointer
;	O
}	O
static	O
void	O
free_display	function
(	O
DISPLAY_LINE	struct
*	O
*	O
display	pointer
)	O
{	O
register	O
int	O
i	int
;	O
register	O
DISPLAY_LINE	struct
*	O
display_line	pointer
;	O
if	O
(	O
!	O
display	pointer
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
display_line	pointer
=	O
display	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
free	function
(	O
display_line	pointer
->	O
text	pointer
)	O
;	O
free	function
(	O
display_line	pointer
)	O
;	O
}	O
free	function
(	O
display	pointer
)	O
;	O
}	O
