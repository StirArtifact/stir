FFD	function
(	O
Ftagbody	int
)	O
(	O
object	int
body	int
)	O
{	O
object	int
*	O
old_top	O
=	O
vs_top	O
;	O
object	int
*	O
VOL	O
new_top	O
;	O
object	int
*	O
tinf	O
;	O
object	int
*	O
VOL	O
tinf_base	O
;	O
object	int
*	O
env	O
=	O
lex_env	O
;	O
object	int
id	O
=	O
alloc_frame_id	O
(	O
)	O
;	O
VOL	O
object	int
bodysv	O
=	O
body	int
;	O
object	int
label	O
;	O
enum	O
type	O
item_type	enum
;	O
vs_push	function
(	O
id	O
)	O
;	O
lex_copy	function
(	O
)	O
;	O
tinf_base	O
=	O
vs_top	O
;	O
while	O
(	O
!	O
endp	function
(	O
body	int
)	O
)	O
{	O
label	O
=	O
MMcar	function
(	O
body	int
)	O
;	O
item_type	enum
=	O
type_of	function
(	O
label	O
)	O
;	O
if	O
(	O
item_type	enum
==	O
t_symbol	O
||	O
item_type	enum
==	O
t_fixnum	O
||	O
item_type	enum
==	O
t_bignum	O
)	O
{	O
lex_tag_bind	function
(	O
label	O
,	O
id	O
)	O
;	O
vs_push	function
(	O
label	O
)	O
;	O
vs_push	function
(	O
MMcdr	function
(	O
body	int
)	O
)	O
;	O
}	O
body	int
=	O
MMcdr	function
(	O
body	int
)	O
;	O
}	O
new_top	O
=	O
vs_top	O
;	O
frs_push	function
(	O
FRS_CATCH	O
,	O
id	O
)	O
;	O
body	int
=	O
bodysv	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
label	O
=	O
cdr	function
(	O
nlj_tag	O
)	O
;	O
nlj_active	O
=	O
FALSE	O
;	O
for	O
(	O
tinf	O
=	O
tinf_base	O
;	O
tinf	O
<	O
new_top	O
&&	O
!	O
eql	function
(	O
tinf	O
[	O
0	int
]	O
,	O
label	O
)	O
;	O
tinf	O
+=	O
2	int
)	O
;	O
if	O
(	O
tinf	O
>=	O
new_top	O
)	O
FEerror	function
(	O
"Someone tried to RETURN-FROM a TAGBODY."	pointer
,	O
0	int
)	O
;	O
body	int
=	O
tinf	O
[	O
1	int
]	O
;	O
}	O
while	O
(	O
body	int
!=	O
Cnil	O
)	O
{	O
vs_top	O
=	O
new_top	O
;	O
item_type	enum
=	O
type_of	function
(	O
MMcar	function
(	O
body	int
)	O
)	O
;	O
if	O
(	O
item_type	enum
!=	O
t_symbol	O
&&	O
item_type	enum
!=	O
t_fixnum	O
&&	O
item_type	enum
!=	O
t_bignum	O
)	O
eval	function
(	O
MMcar	function
(	O
body	int
)	O
)	O
;	O
body	int
=	O
MMcdr	function
(	O
body	int
)	O
;	O
}	O
frs_pop	function
(	O
)	O
;	O
lex_env	O
=	O
env	O
;	O
vs_base	O
=	O
old_top	O
;	O
vs_top	O
=	O
old_top	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fprog	int
)	O
(	O
VOL	O
object	int
arg	int
)	O
{	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
struct	O
bind_temp	O
*	O
start	pointer
;	O
object	int
body	int
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
endp	function
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
arg	int
)	O
;	O
make_nil_block	function
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
start	pointer
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
let_var_list	function
(	O
arg	int
->	O
c	O
.	O
c_car	O
)	O
;	O
body	int
=	O
let_bind	function
(	O
arg	int
->	O
c	O
.	O
c_cdr	O
,	O
start	pointer
,	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
)	O
;	O
vs_top	O
=	O
(	O
object	int
*	O
)	O
start	pointer
;	O
vs_push	function
(	O
body	int
)	O
;	O
Ftagbody	int
(	O
body	int
)	O
;	O
END	O
:	O
bds_unwind	function
(	O
old_bds_top	O
)	O
;	O
frs_pop	function
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
static	O
void	O
FFN	function
(	O
FprogA	int
)	O
(	O
VOL	O
object	int
arg	int
)	O
{	O
object	int
*	O
oldlex	O
=	O
lex_env	O
;	O
struct	O
bind_temp	O
*	O
start	pointer
;	O
object	int
body	int
;	O
bds_ptr	O
old_bds_top	O
=	O
bds_top	O
;	O
if	O
(	O
endp	function
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
arg	int
)	O
;	O
make_nil_block	function
(	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
goto	O
END	O
;	O
}	O
start	pointer
=	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
;	O
let_var_list	function
(	O
arg	int
->	O
c	O
.	O
c_car	O
)	O
;	O
body	int
=	O
letA_bind	function
(	O
arg	int
->	O
c	O
.	O
c_cdr	O
,	O
start	pointer
,	O
(	O
struct	O
bind_temp	O
*	O
)	O
vs_top	O
)	O
;	O
vs_top	O
=	O
(	O
object	int
*	O
)	O
start	pointer
;	O
vs_push	function
(	O
body	int
)	O
;	O
Ftagbody	int
(	O
body	int
)	O
;	O
END	O
:	O
bds_unwind	function
(	O
old_bds_top	O
)	O
;	O
frs_pop	function
(	O
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fgo	int
)	O
(	O
object	int
args	int
)	O
{	O
object	int
lex_tag	O
;	O
frame_ptr	O
fr	O
;	O
if	O
(	O
endp	function
(	O
args	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
args	int
)	O
;	O
if	O
(	O
!	O
endp	function
(	O
MMcdr	function
(	O
args	int
)	O
)	O
)	O
FEtoo_many_argumentsF	function
(	O
args	int
)	O
;	O
lex_tag	O
=	O
lex_tag_sch	function
(	O
MMcar	function
(	O
args	int
)	O
)	O
;	O
if	O
(	O
MMnull	function
(	O
lex_tag	O
)	O
)	O
FEerror	function
(	O
"~S is an undefined tag."	pointer
,	O
1	int
,	O
MMcar	function
(	O
args	int
)	O
)	O
;	O
fr	O
=	O
frs_sch	function
(	O
MMcaddr	function
(	O
lex_tag	O
)	O
)	O
;	O
if	O
(	O
fr	O
==	O
NULL	O
)	O
FEerror	function
(	O
"The tag ~S is missing."	pointer
,	O
1	int
,	O
MMcar	function
(	O
args	int
)	O
)	O
;	O
vs_push	function
(	O
MMcons	function
(	O
MMcaddr	function
(	O
lex_tag	O
)	O
,	O
MMcar	function
(	O
lex_tag	O
)	O
)	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
unwind	function
(	O
fr	O
,	O
vs_top	O
[	O
-	O
1	int
]	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fprogv	int
)	O
(	O
object	int
args	int
)	O
{	O
object	int
*	O
top	O
;	O
object	int
symbols	O
;	O
object	int
values	O
;	O
bds_ptr	O
old_bds_top	O
;	O
object	int
var	O
;	O
if	O
(	O
endp	function
(	O
args	int
)	O
||	O
endp	function
(	O
MMcdr	function
(	O
args	int
)	O
)	O
)	O
FEtoo_few_argumentsF	function
(	O
args	int
)	O
;	O
old_bds_top	O
=	O
bds_top	O
;	O
top	O
=	O
vs_top	O
;	O
eval	function
(	O
MMcar	function
(	O
args	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
symbols	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_push	function
(	O
symbols	O
)	O
;	O
eval	function
(	O
MMcadr	function
(	O
args	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
values	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_push	function
(	O
values	O
)	O
;	O
while	O
(	O
!	O
endp	function
(	O
symbols	O
)	O
)	O
{	O
var	O
=	O
MMcar	function
(	O
symbols	O
)	O
;	O
if	O
(	O
type_of	function
(	O
var	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	function
(	O
var	O
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
var	O
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
FEerror	function
(	O
"Cannot bind the constant ~S."	pointer
,	O
1	int
,	O
var	O
)	O
;	O
if	O
(	O
endp	function
(	O
values	O
)	O
)	O
{	O
bds_bind	function
(	O
var	O
,	O
OBJNULL	O
)	O
;	O
}	O
else	O
{	O
bds_bind	function
(	O
var	O
,	O
MMcar	function
(	O
values	O
)	O
)	O
;	O
values	O
=	O
MMcdr	function
(	O
values	O
)	O
;	O
}	O
symbols	O
=	O
MMcdr	function
(	O
symbols	O
)	O
;	O
}	O
Fprogn	function
(	O
MMcddr	function
(	O
args	int
)	O
)	O
;	O
bds_unwind	function
(	O
old_bds_top	O
)	O
;	O
}	O
FFD	function
(	O
Fprogn	function
)	O
(	O
object	int
body	int
)	O
{	O
if	O
(	O
endp	function
(	O
body	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
body	int
)	O
)	O
;	O
body	int
=	O
MMcdr	function
(	O
body	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
body	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
FFN	function
(	O
Fprog1	int
)	O
(	O
object	int
arg	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
arg	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
for	O
(	O
arg	int
=	O
MMcdr	function
(	O
arg	int
)	O
;	O
!	O
endp	function
(	O
arg	int
)	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
,	O
arg	int
=	O
MMcdr	function
(	O
arg	int
)	O
)	O
eval	function
(	O
MMcar	function
(	O
arg	int
)	O
)	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
}	O
static	O
void	O
FFN	function
(	O
Fprog2	int
)	O
(	O
object	int
arg	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
arg	int
)	O
||	O
endp	function
(	O
MMcdr	function
(	O
arg	int
)	O
)	O
)	O
FEtoo_few_argumentsF	function
(	O
arg	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
arg	int
=	O
MMcdr	function
(	O
arg	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
for	O
(	O
arg	int
=	O
MMcdr	function
(	O
arg	int
)	O
;	O
!	O
endp	function
(	O
arg	int
)	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
,	O
arg	int
=	O
MMcdr	function
(	O
arg	int
)	O
)	O
eval	function
(	O
MMcar	function
(	O
arg	int
)	O
)	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
}	O
void	O
gcl_init_prog	function
(	O
void	O
)	O
{	O
make_special_form	function
(	O
"TAGBODY"	pointer
,	O
Ftagbody	int
)	O
;	O
make_special_form	function
(	O
"PROG"	pointer
,	O
Fprog	int
)	O
;	O
make_special_form	function
(	O
"PROG*"	pointer
,	O
FprogA	int
)	O
;	O
make_special_form	function
(	O
"GO"	pointer
,	O
Fgo	int
)	O
;	O
make_special_form	function
(	O
"PROGV"	pointer
,	O
Fprogv	int
)	O
;	O
sLprogn	O
=	O
make_special_form	function
(	O
"PROGN"	pointer
,	O
Fprogn	function
)	O
;	O
make_special_form	function
(	O
"PROG1"	pointer
,	O
Fprog1	int
)	O
;	O
make_special_form	function
(	O
"PROG2"	pointer
,	O
Fprog2	int
)	O
;	O
}	O
