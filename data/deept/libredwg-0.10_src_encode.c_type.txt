bool	bool
is_dwg_object	function
(	O
const	O
char	O
*	O
name	pointer
)	O
;	O
bool	bool
is_dwg_entity	function
(	O
const	O
char	O
*	O
name	pointer
)	O
;	O
static	O
unsigned	O
int	O
loglevel	int
;	O
static	O
unsigned	O
int	O
cur_ver	int
=	O
0	int
;	O
typedef	O
struct	O
{	O
unsigned	O
long	O
handle	pointer
;	O
long	O
address	long
;	O
BITCODE_BL	int
index	short
;	O
}	O
Object_Map	struct
;	O
static	O
int	O
encode_preR13	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
)	O
;	O
static	O
int	O
dwg_encode_entity	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
)	O
;	O
static	O
int	O
dwg_encode_object	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
dat	pointer
)	O
;	O
static	O
int	O
dwg_encode_common_entity_handle_data	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
;	O
static	O
int	O
dwg_encode_header_variables	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
int	O
dwg_encode_variable_type	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
;	O
void	O
dwg_encode_handleref	function
(	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
;	O
void	O
dwg_encode_handleref_with_code	function
(	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
,	O
unsigned	O
int	O
code	char
)	O
;	O
int	O
dwg_encode_add_object	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
unsigned	O
long	O
address	long
)	O
;	O
static	O
int	O
dwg_encode_xdata	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object_XRECORD	struct
*	O
restrict	O
obj	pointer
,	O
int	O
size	char
)	O
;	O
static	O
BITCODE_RL	int
encode_patch_RLsize	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
long	O
unsigned	O
int	O
pvzadr	long
)	O
{	O
unsigned	O
long	O
pos	long
;	O
BITCODE_RL	int
size	char
;	O
if	O
(	O
dat	pointer
->	O
bit	char
)	O
{	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
dat	pointer
->	O
byte	char
++	O
;	O
}	O
size	char
=	O
dat	pointer
->	O
byte	char
-	O
pvzadr	long
-	O
4	int
;	O
pos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
assert	O
(	O
pvzadr	long
)	O
;	O
bit_set_position	function
(	O
dat	pointer
,	O
pvzadr	long
*	O
8	int
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"size: "	pointer
FORMAT_RL	O
" [RL] @%lu\n"	pointer
,	O
size	char
,	O
pvzadr	long
)	O
;	O
bit_set_position	function
(	O
dat	pointer
,	O
pos	long
)	O
;	O
return	O
size	char
;	O
}	O
AFL_GCC_TOOBIG	O
int	O
dwg_encode	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
)	O
{	O
int	O
ckr_missing	int
=	O
1	int
;	O
int	O
error	int
=	O
0	int
;	O
BITCODE_BL	int
i	int
,	O
j	int
;	O
long	O
unsigned	O
int	O
section_address	long
;	O
unsigned	O
char	O
pvzbit	char
;	O
long	O
unsigned	O
int	O
pvzadr	long
;	O
long	O
unsigned	O
int	O
pvzadr_2	long
;	O
unsigned	O
int	O
ckr	int
;	O
unsigned	O
int	O
sec_size	int
=	O
0	int
;	O
long	O
unsigned	O
int	O
last_offset	long
;	O
BITCODE_BL	int
last_handle	int
;	O
Object_Map	struct
*	O
omap	pointer
;	O
Bit_Chain	struct
*	O
hdl_dat	pointer
;	O
const	O
char	O
*	O
section_names	array
[	O
]	O
=	O
{	O
"AcDb:Header"	pointer
,	O
"AcDb:Classes"	pointer
,	O
"AcDb:Handles"	pointer
,	O
"2NDHEADER"	pointer
,	O
"MEASUREMENT"	pointer
,	O
"AcDb:AuxHeader"	pointer
}	O
;	O
if	O
(	O
dwg	pointer
->	O
opts	int
)	O
loglevel	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
bit_chain_alloc	function
(	O
dat	pointer
)	O
;	O
hdl_dat	pointer
=	O
dat	pointer
;	O
strcpy	function
(	O
(	O
char	O
*	O
)	O
dat	pointer
->	O
chain	pointer
,	O
version_codes	array
[	O
dwg	pointer
->	O
header	struct
.	O
version	short
]	O
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
!=	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
)	O
LOG_TRACE	O
(	O
"Encode version %s from version %s\n"	pointer
,	O
version_codes	array
[	O
dwg	pointer
->	O
header	struct
.	O
version	short
]	O
,	O
version_codes	array
[	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
]	O
)	O
else	O
LOG_TRACE	O
(	O
"Encode version %s\n"	pointer
,	O
version_codes	array
[	O
dwg	pointer
->	O
header	struct
.	O
version	short
]	O
)	O
dat	pointer
->	O
byte	char
+=	O
6	int
;	O
{	O
struct	O
Dwg_Header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
_obj	pointer
->	O
dwg_version	int
)	O
{	O
_obj	pointer
->	O
is_maint	char
=	O
0	int
;	O
switch	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
)	O
{	O
case	O
R_9	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x11	int
;	O
break	O
;	O
case	O
R_10	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x12	int
;	O
break	O
;	O
case	O
R_11	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x13	int
;	O
break	O
;	O
case	O
R_13	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x15	int
;	O
break	O
;	O
case	O
R_14	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x16	int
;	O
break	O
;	O
case	O
R_2000	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x17	int
;	O
_obj	pointer
->	O
is_maint	char
=	O
0xf	int
;	O
break	O
;	O
case	O
R_2004	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x19	int
;	O
_obj	pointer
->	O
is_maint	char
=	O
0x68	int
;	O
break	O
;	O
case	O
R_2007	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x1b	int
;	O
_obj	pointer
->	O
is_maint	char
=	O
0x32	int
;	O
break	O
;	O
case	O
R_2010	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x1d	int
;	O
_obj	pointer
->	O
is_maint	char
=	O
0x6d	int
;	O
break	O
;	O
case	O
R_2013	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x1f	int
;	O
_obj	pointer
->	O
is_maint	char
=	O
0x7d	int
;	O
break	O
;	O
case	O
R_2018	int
:	O
_obj	pointer
->	O
dwg_version	int
=	O
0x21	int
;	O
_obj	pointer
->	O
is_maint	char
=	O
0x4	int
;	O
break	O
;	O
case	O
R_INVALID	int
:	O
case	O
R_AFTER	int
:	O
case	O
R_1_1	int
:	O
case	O
R_1_2	int
:	O
case	O
R_1_4	int
:	O
case	O
R_2_0	int
:	O
case	O
R_2_1	int
:	O
case	O
R_2_5	int
:	O
case	O
R_2_6	int
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
!	O
_obj	pointer
->	O
app_dwg_version	char
)	O
_obj	pointer
->	O
app_dwg_version	char
=	O
_obj	pointer
->	O
dwg_version	int
;	O
}	O
if	O
(	O
!	O
_obj	pointer
->	O
codepage	int
)	O
_obj	pointer
->	O
codepage	int
=	O
30	int
;	O
}	O
section_address	long
=	O
dat	pointer
->	O
byte	char
;	O
PRE	O
(	O
R_13	int
)	O
{	O
LOG_ERROR	O
(	O
WE_CAN	O
"We don't encode preR13 tables, entities, blocks yet"	pointer
)	O
}	O
PRE	O
(	O
R_2004	int
)	O
{	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
||	O
(	O
dat	pointer
->	O
from_version	enum
>=	O
R_2004	int
&&	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
>	O
6	int
)	O
)	O
{	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
dwg	pointer
->	O
header	struct
.	O
version	short
<	O
R_2000	int
?	O
5	int
:	O
6	int
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header_vars	struct
.	O
HANDSEED	pointer
||	O
!	O
dwg	pointer
->	O
header_vars	struct
.	O
TDCREATE	struct
.	O
days	int
)	O
{	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
5	int
;	O
dat	pointer
->	O
from_version	enum
=	O
R_11	int
;	O
if	O
(	O
dat	pointer
->	O
version	short
<=	O
dat	pointer
->	O
from_version	enum
)	O
dat	pointer
->	O
from_version	enum
=	O
dat	pointer
->	O
version	short
-	O
1	int
;	O
}	O
}	O
LOG_TRACE	O
(	O
"num_sections: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
=	O
calloc	function
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
,	O
sizeof	O
(	O
Dwg_Section	struct
)	O
)	O
;	O
section_address	long
=	O
dat	pointer
->	O
byte	char
;	O
dat	pointer
->	O
byte	char
+=	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
*	O
9	int
)	O
;	O
bit_write_CRC	function
(	O
dat	pointer
,	O
0	int
,	O
0xC0C1	int
)	O
;	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_HEADER_END	int
)	O
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
>	O
5	int
)	O
{	O
struct	O
Dwg_AuxHeader	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
auxheader	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
assert	O
(	O
!	O
dat	pointer
->	O
bit	char
)	O
;	O
LOG_INFO	O
(	O
"\n=======> AuxHeader: %8u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_AUXHEADER_R2000	int
]	O
.	O
number	short
=	O
5	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_AUXHEADER_R2000	int
]	O
.	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
if	O
(	O
!	O
_obj	pointer
->	O
dwg_version	int
)	O
{	O
BITCODE_RS	short
tmpunknown	array
[	O
]	O
=	O
{	O
4	int
,	O
0x565	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
1	int
}	O
;	O
LOG_TRACE	O
(	O
"Use AuxHeader defaults...\n"	pointer
)	O
;	O
FIELD_VALUE	O
(	O
aux_intro	array
[	O
0	int
]	O
)	O
=	O
0xff	int
;	O
FIELD_VALUE	O
(	O
aux_intro	array
[	O
1	int
]	O
)	O
=	O
0x77	int
;	O
FIELD_VALUE	O
(	O
aux_intro	array
[	O
2	int
]	O
)	O
=	O
0x01	int
;	O
FIELD_VALUE	O
(	O
minus_1	int
)	O
=	O
-	O
1	int
;	O
FIELD_VALUE	O
(	O
dwg_version	int
)	O
=	O
dwg	pointer
->	O
header	struct
.	O
dwg_version	int
;	O
FIELD_VALUE	O
(	O
maint_version	int
)	O
=	O
dwg	pointer
->	O
header	struct
.	O
maint_version	int
;	O
FIELD_VALUE	O
(	O
dwg_version_1	short
)	O
=	O
dwg	pointer
->	O
header	struct
.	O
dwg_version	int
;	O
FIELD_VALUE	O
(	O
dwg_version_2	short
)	O
=	O
dwg	pointer
->	O
header	struct
.	O
dwg_version	int
;	O
FIELD_VALUE	O
(	O
maint_version_1	short
)	O
=	O
dwg	pointer
->	O
header	struct
.	O
maint_version	int
;	O
FIELD_VALUE	O
(	O
maint_version_2	short
)	O
=	O
dwg	pointer
->	O
header	struct
.	O
maint_version	int
;	O
memcpy	function
(	O
FIELD_VALUE	O
(	O
unknown_rs	array
)	O
,	O
tmpunknown	array
,	O
sizeof	O
(	O
tmpunknown	array
)	O
)	O
;	O
FIELD_VALUE	O
(	O
TDCREATE	struct
)	O
=	O
dwg	pointer
->	O
header_vars	struct
.	O
TDCREATE	struct
.	O
value	double
;	O
FIELD_VALUE	O
(	O
TDUPDATE	struct
)	O
=	O
dwg	pointer
->	O
header_vars	struct
.	O
TDUPDATE	struct
.	O
value	double
;	O
if	O
(	O
dwg	pointer
->	O
header_vars	struct
.	O
HANDSEED	pointer
)	O
FIELD_VALUE	O
(	O
HANDSEED	pointer
)	O
=	O
dwg	pointer
->	O
header_vars	struct
.	O
HANDSEED	pointer
->	O
absolute_ref	long
;	O
}	O
assert	O
(	O
!	O
dat	pointer
->	O
bit	char
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_AUXHEADER_R2000	int
]	O
.	O
size	char
=	O
dat	pointer
->	O
byte	char
-	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_AUXHEADER_R2000	int
]	O
.	O
address	long
;	O
}	O
}	O
VERSION	O
(	O
R_2007	int
)	O
{	O
LOG_ERROR	O
(	O
WE_CAN	O
"We don't encode R2007 sections yet"	pointer
)	O
return	O
DWG_ERR_NOTYETSUPPORTED	int
;	O
}	O
SINCE	O
(	O
R_2004	int
)	O
{	O
typedef	O
union	O
_system_section	union
{	O
unsigned	O
char	O
data	pointer
[	O
0x14	int
]	O
;	O
struct	O
{	O
uint32_t	int
section_type	int
;	O
uint32_t	int
decomp_data_size	int
;	O
uint32_t	int
comp_data_size	int
;	O
uint32_t	int
compression_type	int
;	O
uint32_t	int
checksum	int
;	O
}	O
fields	pointer
;	O
}	O
system_section	union
;	O
system_section	union
ss	union
;	O
Dwg_Section	struct
*	O
section	pointer
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
struct	O
Dwg_R2004_Header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
r2004_header	struct
;	O
const	O
int	O
size	char
=	O
sizeof	O
(	O
struct	O
Dwg_R2004_Header	struct
)	O
;	O
char	O
encrypted_data	array
[	O
size	char
]	O
;	O
unsigned	O
int	O
rseed	int
=	O
1	int
;	O
uint32_t	int
checksum	int
;	O
LOG_ERROR	O
(	O
WE_CAN	O
"We don't encode the R2004_section_map yet"	pointer
)	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
&&	O
!	O
dwg	pointer
->	O
header	struct
.	O
section_info	pointer
)	O
dwg	pointer
->	O
header	struct
.	O
section_info	pointer
=	O
calloc	function
(	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
,	O
sizeof	O
(	O
Dwg_Section_Info	struct
)	O
)	O
;	O
dat	pointer
->	O
byte	char
=	O
0x80	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
BITCODE_BL	int
)	O
size	char
;	O
i	int
++	O
)	O
{	O
rseed	int
*=	O
0x343fd	int
;	O
rseed	int
+=	O
0x269ec3	int
;	O
encrypted_data	array
[	O
i	int
]	O
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
^	O
(	O
rseed	int
>>	O
0x10	int
)	O
;	O
}	O
LOG_TRACE	O
(	O
"\n#### Write 2004 File Header ####\n"	pointer
)	O
;	O
dat	pointer
->	O
byte	char
=	O
0x80	int
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
0x80	int
>=	O
dat	pointer
->	O
size	char
-	O
1	int
)	O
{	O
dat	pointer
->	O
size	char
=	O
dat	pointer
->	O
byte	char
+	O
0x80	int
;	O
bit_chain_alloc	function
(	O
dat	pointer
)	O
;	O
}	O
memcpy	function
(	O
&	O
dat	pointer
->	O
chain	pointer
[	O
0x80	int
]	O
,	O
encrypted_data	array
,	O
size	char
)	O
;	O
LOG_INFO	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
dwg	pointer
->	O
r2004_header	struct
.	O
checksum	int
=	O
0	int
;	O
dwg	pointer
->	O
r2004_header	struct
.	O
checksum	int
=	O
dwg_section_page_checksum	function
(	O
0	int
,	O
dat	pointer
,	O
size	char
)	O
;	O
dat	pointer
->	O
byte	char
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_map_address	long
+	O
0x100	int
;	O
LOG_TRACE	O
(	O
"\n=== Write System Section (Section Page Map) ===\n"	pointer
)	O
;	O
dwg	pointer
->	O
r2004_header	struct
.	O
comp_data_size	int
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
decomp_data_size	int
;	O
dwg	pointer
->	O
r2004_header	struct
.	O
compression_type	int
=	O
0	int
;	O
FIELD_RL	O
(	O
section_type	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
decomp_data_size	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
comp_data_size	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
compression_type	int
,	O
0	int
)	O
;	O
dwg_section_page_checksum	function
(	O
dwg	pointer
->	O
r2004_header	struct
.	O
checksum	int
,	O
dat	pointer
,	O
size	char
)	O
;	O
FIELD_RL	O
(	O
checksum	int
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"\n"	pointer
)	O
LOG_WARN	O
(	O
"TODO write_R2004_section_map(dat, dwg)"	pointer
)	O
LOG_TRACE	O
(	O
"\n"	pointer
)	O
return	O
DWG_ERR_NOTYETSUPPORTED	int
;	O
}	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
)	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
=	O
dat	pointer
->	O
byte	char
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
LOG_TRACE	O
(	O
"\n=======> Thumbnail:       %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_THUMBNAIL_BEGIN	int
)	O
)	O
;	O
if	O
(	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
==	O
0	int
)	O
{	O
bit_write_RL	function
(	O
dat	pointer
,	O
5	int
)	O
;	O
LOG_TRACE	O
(	O
"Thumbnail size: 5 [RL]\n"	pointer
)	O
;	O
bit_write_RC	function
(	O
dat	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"Thumbnail num_pictures: 0 [RC]\n"	pointer
)	O
;	O
}	O
else	O
{	O
bit_write_TF	function
(	O
dat	pointer
,	O
(	O
char	O
*	O
)	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
;	O
}	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_THUMBNAIL_END	int
)	O
)	O
;	O
{	O
BITCODE_RL	int
size	char
;	O
dwg_bmp	function
(	O
dwg	pointer
,	O
&	O
size	char
)	O
;	O
if	O
(	O
size	char
>	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
LOG_ERROR	O
(	O
"BMP size overflow: %i > %lu\n"	pointer
,	O
size	char
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
;	O
}	O
LOG_TRACE	O
(	O
"         Thumbnail (end): %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
assert	O
(	O
!	O
dat	pointer
->	O
bit	char
)	O
;	O
LOG_INFO	O
(	O
"\n=======> Header Variables:   %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
0	int
]	O
.	O
number	short
=	O
0	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
0	int
]	O
.	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_VARIABLE_BEGIN	int
)	O
)	O
;	O
pvzadr	long
=	O
dat	pointer
->	O
byte	char
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
540	int
)	O
;	O
dwg_encode_header_variables	function
(	O
dat	pointer
,	O
hdl_dat	pointer
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
encode_patch_RLsize	function
(	O
dat	pointer
,	O
pvzadr	long
)	O
;	O
bit_write_CRC	function
(	O
dat	pointer
,	O
pvzadr	long
,	O
0xC0C1	int
)	O
;	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_VARIABLE_END	int
)	O
)	O
;	O
assert	O
(	O
(	O
long	O
)	O
dat	pointer
->	O
byte	char
>	O
(	O
long	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
0	int
]	O
.	O
address	long
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
0	int
]	O
.	O
size	char
=	O
(	O
BITCODE_RL	int
)	O
(	O
(	O
long	O
)	O
dat	pointer
->	O
byte	char
-	O
(	O
long	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
0	int
]	O
.	O
address	long
)	O
;	O
LOG_TRACE	O
(	O
"         Header Variables (end): %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
LOG_INFO	O
(	O
"\n=======> Classes: %4u (%d)\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
,	O
dwg	pointer
->	O
num_classes	short
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
number	short
=	O
1	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_CLASS_BEGIN	int
)	O
)	O
;	O
pvzadr	long
=	O
dat	pointer
->	O
byte	char
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
0	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dwg	pointer
->	O
num_classes	short
;	O
j	int
++	O
)	O
{	O
Dwg_Class	struct
*	O
klass	pointer
;	O
klass	pointer
=	O
&	O
dwg	pointer
->	O
dwg_class	pointer
[	O
j	int
]	O
;	O
bit_write_BS	function
(	O
dat	pointer
,	O
klass	pointer
->	O
number	short
)	O
;	O
bit_write_BS	function
(	O
dat	pointer
,	O
klass	pointer
->	O
proxyflag	short
)	O
;	O
bit_write_TV	function
(	O
dat	pointer
,	O
klass	pointer
->	O
appname	pointer
)	O
;	O
bit_write_TV	function
(	O
dat	pointer
,	O
klass	pointer
->	O
cppname	pointer
)	O
;	O
bit_write_TV	function
(	O
dat	pointer
,	O
klass	pointer
->	O
dxfname	pointer
)	O
;	O
bit_write_B	function
(	O
dat	pointer
,	O
klass	pointer
->	O
is_zombie	char
)	O
;	O
bit_write_BS	function
(	O
dat	pointer
,	O
klass	pointer
->	O
item_class_id	short
)	O
;	O
LOG_TRACE	O
(	O
"Class %d 0x%x %s\n"	pointer
" %s \"%s\" %d 0x%x\n"	pointer
,	O
klass	pointer
->	O
number	short
,	O
klass	pointer
->	O
proxyflag	short
,	O
klass	pointer
->	O
dxfname	pointer
,	O
klass	pointer
->	O
cppname	pointer
,	O
klass	pointer
->	O
appname	pointer
,	O
klass	pointer
->	O
is_zombie	char
,	O
klass	pointer
->	O
item_class_id	short
)	O
SINCE	O
(	O
R_2007	int
)	O
{	O
bit_write_BL	function
(	O
dat	pointer
,	O
klass	pointer
->	O
num_instances	int
)	O
;	O
bit_write_BL	function
(	O
dat	pointer
,	O
klass	pointer
->	O
dwg_version	int
)	O
;	O
bit_write_BL	function
(	O
dat	pointer
,	O
klass	pointer
->	O
maint_version	int
)	O
;	O
bit_write_BL	function
(	O
dat	pointer
,	O
klass	pointer
->	O
unknown_1	double
)	O
;	O
bit_write_BL	function
(	O
dat	pointer
,	O
klass	pointer
->	O
unknown_2	double
)	O
;	O
LOG_TRACE	O
(	O
" %d %d\n"	pointer
,	O
(	O
int	O
)	O
klass	pointer
->	O
num_instances	int
,	O
(	O
int	O
)	O
klass	pointer
->	O
dwg_version	int
)	O
;	O
}	O
}	O
assert	O
(	O
pvzadr	long
)	O
;	O
encode_patch_RLsize	function
(	O
dat	pointer
,	O
pvzadr	long
)	O
;	O
bit_write_CRC	function
(	O
dat	pointer
,	O
pvzadr	long
,	O
0xC0C1	int
)	O
;	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_CLASS_END	int
)	O
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
size	char
=	O
dat	pointer
->	O
byte	char
-	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
address	long
;	O
LOG_TRACE	O
(	O
"       Classes (end): %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
0x0DCA	int
)	O
;	O
LOG_TRACE	O
(	O
"unknown: %04X [RL]\n"	pointer
,	O
0x0DCA	int
)	O
;	O
LOG_INFO	O
(	O
"\n=======> Objects: %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
pvzadr	long
=	O
dat	pointer
->	O
byte	char
;	O
LOG_TRACE	O
(	O
"num_objects: %i\n"	pointer
,	O
dwg	pointer
->	O
num_objects	int
)	O
;	O
LOG_TRACE	O
(	O
"num_object_refs: %i\n"	pointer
,	O
dwg	pointer
->	O
num_object_refs	int
)	O
;	O
omap	pointer
=	O
(	O
Object_Map	struct
*	O
)	O
calloc	function
(	O
dwg	pointer
->	O
num_objects	int
,	O
sizeof	O
(	O
Object_Map	struct
)	O
)	O
;	O
if	O
(	O
!	O
omap	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
if	O
(	O
DWG_LOGLEVEL	O
>=	O
DWG_LOGLEVEL_HANDLE	int
)	O
{	O
LOG_HANDLE	O
(	O
"\nSorting objects...\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
OUTPUT	O
,	O
"Object(%3i): %4lX / idx: %u\n"	pointer
,	O
i	int
,	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
.	O
handle	pointer
.	O
value	double
,	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
.	O
index	short
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
{	O
omap	pointer
[	O
i	int
]	O
.	O
index	short
=	O
i	int
;	O
omap	pointer
[	O
i	int
]	O
.	O
handle	pointer
=	O
dwg	pointer
->	O
object	pointer
[	O
i	int
]	O
.	O
handle	pointer
.	O
value	double
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
{	O
Object_Map	struct
tmap	struct
;	O
j	int
=	O
i	int
;	O
tmap	struct
=	O
omap	pointer
[	O
i	int
]	O
;	O
while	O
(	O
j	int
>	O
0	int
&&	O
omap	pointer
[	O
j	int
-	O
1	int
]	O
.	O
handle	pointer
>	O
tmap	struct
.	O
handle	pointer
)	O
{	O
omap	pointer
[	O
j	int
]	O
=	O
omap	pointer
[	O
j	int
-	O
1	int
]	O
;	O
j	int
--	O
;	O
}	O
omap	pointer
[	O
j	int
]	O
=	O
tmap	struct
;	O
}	O
if	O
(	O
DWG_LOGLEVEL	O
>=	O
DWG_LOGLEVEL_HANDLE	int
)	O
{	O
LOG_HANDLE	O
(	O
"\nSorted handles:\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
OUTPUT	O
,	O
"Handle(%3i): %4lX / idx: %u\n"	pointer
,	O
i	int
,	O
omap	pointer
[	O
i	int
]	O
.	O
handle	pointer
,	O
omap	pointer
[	O
i	int
]	O
.	O
index	short
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
;	O
BITCODE_BL	int
index	short
=	O
omap	pointer
[	O
i	int
]	O
.	O
index	short
;	O
unsigned	O
long	O
hdloff	long
=	O
omap	pointer
[	O
i	int
]	O
.	O
handle	pointer
-	O
(	O
i	int
?	O
omap	pointer
[	O
i	int
-	O
1	int
]	O
.	O
handle	pointer
:	O
0	int
)	O
;	O
int	O
off	int
=	O
dat	pointer
->	O
byte	char
-	O
(	O
i	int
?	O
omap	pointer
[	O
i	int
-	O
1	int
]	O
.	O
address	long
:	O
0	int
)	O
;	O
unsigned	O
long	O
address	long
,	O
end_address	long
;	O
LOG_TRACE	O
(	O
"\n> Next object: "	pointer
FORMAT_BL	O
" Handleoff: %lX [UMC] Offset: %d [MC] @%lu\n"	pointer
"==========================================\n"	pointer
,	O
i	int
,	O
hdloff	long
,	O
off	int
,	O
dat	pointer
->	O
byte	char
)	O
;	O
omap	pointer
[	O
i	int
]	O
.	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
if	O
(	O
index	short
>	O
dwg	pointer
->	O
num_objects	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid object map index "	pointer
FORMAT_BL	O
", max "	pointer
FORMAT_BL	O
". Skipping"	pointer
,	O
index	short
,	O
dwg	pointer
->	O
num_objects	int
)	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
continue	O
;	O
}	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
index	short
]	O
;	O
assert	O
(	O
dat	pointer
->	O
byte	char
)	O
;	O
if	O
(	O
!	O
obj	pointer
->	O
parent	pointer
)	O
obj	pointer
->	O
parent	pointer
=	O
dwg	pointer
;	O
error	int
|=	O
dwg_encode_add_object	function
(	O
obj	pointer
,	O
dat	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_1_2	int
)	O
{	O
assert	O
(	O
dat	pointer
->	O
chain	pointer
[	O
0	int
]	O
==	O
'A'	O
)	O
;	O
assert	O
(	O
dat	pointer
->	O
chain	pointer
[	O
1	int
]	O
==	O
'C'	O
)	O
;	O
}	O
end_address	long
=	O
omap	pointer
[	O
i	int
]	O
.	O
address	long
+	O
(	O
unsigned	O
long	O
)	O
obj	pointer
->	O
size	char
;	O
if	O
(	O
end_address	long
>	O
dat	pointer
->	O
size	char
)	O
{	O
dat	pointer
->	O
size	char
=	O
end_address	long
;	O
bit_chain_alloc	function
(	O
dat	pointer
)	O
;	O
}	O
}	O
if	O
(	O
DWG_LOGLEVEL	O
>=	O
DWG_LOGLEVEL_HANDLE	int
)	O
{	O
LOG_HANDLE	O
(	O
"\nSorted objects:\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
LOG_HANDLE	O
(	O
"Object(%d): %lX / Address: %ld / Idx: %d\n"	pointer
,	O
i	int
,	O
omap	pointer
[	O
i	int
]	O
.	O
handle	pointer
,	O
omap	pointer
[	O
i	int
]	O
.	O
address	long
,	O
omap	pointer
[	O
i	int
]	O
.	O
index	short
)	O
;	O
}	O
bit_write_RS	function
(	O
dat	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"unknown crc?: %04X [RS]\n"	pointer
,	O
0	int
)	O
;	O
LOG_INFO	O
(	O
"\n=======> Object Map: %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
number	short
=	O
2	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
sec_size	int
=	O
0	int
;	O
pvzadr	long
=	O
dat	pointer
->	O
byte	char
;	O
dat	pointer
->	O
byte	char
+=	O
2	int
;	O
last_offset	long
=	O
0	int
;	O
last_handle	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_objects	int
;	O
i	int
++	O
)	O
{	O
BITCODE_BL	int
index	short
;	O
BITCODE_UMC	long
handleoff	long
;	O
BITCODE_MC	long
offset	double
;	O
index	short
=	O
omap	pointer
[	O
i	int
]	O
.	O
index	short
;	O
handleoff	long
=	O
omap	pointer
[	O
i	int
]	O
.	O
handle	pointer
-	O
last_handle	int
;	O
bit_write_UMC	function
(	O
dat	pointer
,	O
handleoff	long
)	O
;	O
LOG_HANDLE	O
(	O
"Handleoff(%3i): %4lX [UMC] (%4lX), "	pointer
,	O
index	short
,	O
handleoff	long
,	O
omap	pointer
[	O
i	int
]	O
.	O
handle	pointer
)	O
last_handle	int
=	O
omap	pointer
[	O
i	int
]	O
.	O
handle	pointer
;	O
offset	double
=	O
omap	pointer
[	O
i	int
]	O
.	O
address	long
-	O
last_offset	long
;	O
bit_write_MC	function
(	O
dat	pointer
,	O
offset	double
)	O
;	O
last_offset	long
=	O
omap	pointer
[	O
i	int
]	O
.	O
address	long
;	O
LOG_HANDLE	O
(	O
"Offset: %8d [MC] @%lu\n"	pointer
,	O
(	O
int	O
)	O
offset	double
,	O
last_offset	long
)	O
;	O
ckr_missing	int
=	O
1	int
;	O
if	O
(	O
dat	pointer
->	O
byte	char
-	O
pvzadr	long
>	O
2030	int
)	O
{	O
ckr_missing	int
=	O
0	int
;	O
sec_size	int
=	O
dat	pointer
->	O
byte	char
-	O
pvzadr	long
;	O
assert	O
(	O
pvzadr	long
)	O
;	O
dat	pointer
->	O
chain	pointer
[	O
pvzadr	long
]	O
=	O
sec_size	int
>>	O
8	int
;	O
dat	pointer
->	O
chain	pointer
[	O
pvzadr	long
+	O
1	int
]	O
=	O
sec_size	int
&	O
0xFF	int
;	O
LOG_TRACE	O
(	O
"Handles page size: %u [RS_LE] @%lu\n"	pointer
,	O
sec_size	int
,	O
pvzadr	long
)	O
;	O
bit_write_CRC_LE	function
(	O
dat	pointer
,	O
pvzadr	long
,	O
0xC0C1	int
)	O
;	O
pvzadr	long
=	O
dat	pointer
->	O
byte	char
;	O
dat	pointer
->	O
byte	char
+=	O
2	int
;	O
last_offset	long
=	O
0	int
;	O
last_handle	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
ckr_missing	int
)	O
{	O
sec_size	int
=	O
dat	pointer
->	O
byte	char
-	O
pvzadr	long
;	O
assert	O
(	O
pvzadr	long
)	O
;	O
dat	pointer
->	O
chain	pointer
[	O
pvzadr	long
]	O
=	O
sec_size	int
>>	O
8	int
;	O
dat	pointer
->	O
chain	pointer
[	O
pvzadr	long
+	O
1	int
]	O
=	O
sec_size	int
&	O
0xFF	int
;	O
LOG_TRACE	O
(	O
"Handles page size: %u [RS_LE] @%lu\n"	pointer
,	O
sec_size	int
,	O
pvzadr	long
)	O
;	O
bit_write_CRC_LE	function
(	O
dat	pointer
,	O
pvzadr	long
,	O
0xC0C1	int
)	O
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_1_2	int
)	O
{	O
assert	O
(	O
dat	pointer
->	O
chain	pointer
[	O
0	int
]	O
==	O
'A'	O
)	O
;	O
assert	O
(	O
dat	pointer
->	O
chain	pointer
[	O
1	int
]	O
==	O
'C'	O
)	O
;	O
}	O
pvzadr	long
=	O
dat	pointer
->	O
byte	char
;	O
assert	O
(	O
pvzadr	long
)	O
;	O
bit_write_RS_LE	function
(	O
dat	pointer
,	O
2	int
)	O
;	O
LOG_TRACE	O
(	O
"Handles page size: %u [RS_LE] @%lu\n"	pointer
,	O
2	int
,	O
pvzadr	long
)	O
;	O
bit_write_CRC_LE	function
(	O
dat	pointer
,	O
pvzadr	long
,	O
0xC0C1	int
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
size	char
=	O
dat	pointer
->	O
byte	char
-	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
address	long
;	O
free	function
(	O
omap	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_13	int
&&	O
dwg	pointer
->	O
second_header	struct
.	O
num_sections	int
>	O
3	int
)	O
{	O
struct	O
_dwg_second_header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
second_header	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
BITCODE_BL	int
vcount	int
;	O
assert	O
(	O
dat	pointer
->	O
byte	char
)	O
;	O
if	O
(	O
!	O
_obj	pointer
->	O
address	long
)	O
_obj	pointer
->	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
number	short
=	O
3	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
address	long
=	O
_obj	pointer
->	O
address	long
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
size	char
=	O
_obj	pointer
->	O
size	char
;	O
LOG_INFO	O
(	O
"\n=======> Second Header: %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_SECOND_HEADER_BEGIN	int
)	O
)	O
;	O
pvzadr	long
=	O
dat	pointer
->	O
byte	char
;	O
LOG_TRACE	O
(	O
"pvzadr: %u\n"	pointer
,	O
(	O
unsigned	O
)	O
pvzadr	long
)	O
;	O
if	O
(	O
!	O
_obj	pointer
->	O
size	char
&&	O
!	O
_obj	pointer
->	O
num_sections	int
)	O
{	O
LOG_TRACE	O
(	O
"Use second_header defaults...\n"	pointer
)	O
;	O
strcpy	function
(	O
(	O
char	O
*	O
)	O
&	O
_obj	pointer
->	O
version	short
[	O
0	int
]	O
,	O
&	O
version_codes	array
[	O
dwg	pointer
->	O
header	struct
.	O
version	short
]	O
[	O
0	int
]	O
)	O
;	O
memset	function
(	O
&	O
_obj	pointer
->	O
version	short
[	O
7	int
]	O
,	O
0	int
,	O
4	int
)	O
;	O
_obj	pointer
->	O
version	short
[	O
11	int
]	O
=	O
'\n'	O
;	O
_obj	pointer
->	O
unknown_10	short
=	O
0x10	int
;	O
_obj	pointer
->	O
unknown_rc4	array
[	O
0	int
]	O
=	O
0x84	int
;	O
_obj	pointer
->	O
unknown_rc4	array
[	O
1	int
]	O
=	O
0x74	int
;	O
_obj	pointer
->	O
unknown_rc4	array
[	O
2	int
]	O
=	O
0x78	int
;	O
_obj	pointer
->	O
unknown_rc4	array
[	O
3	int
]	O
=	O
0x1	int
;	O
_obj	pointer
->	O
junk_r14_1	int
=	O
1957593121	int
;	O
_obj	pointer
->	O
junk_r14_2	int
=	O
2559919056	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
<=	O
R_2000	int
)	O
{	O
_obj	pointer
->	O
num_sections	int
=	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
num_sections	int
;	O
i	int
++	O
)	O
{	O
_obj	pointer
->	O
section	pointer
[	O
i	int
]	O
.	O
nr	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
;	O
_obj	pointer
->	O
section	pointer
[	O
i	int
]	O
.	O
address	long
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
;	O
_obj	pointer
->	O
section	pointer
[	O
i	int
]	O
.	O
size	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
size	char
;	O
}	O
}	O
FIELD_RL	O
(	O
size	char
,	O
0	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
address	long
)	O
!=	O
(	O
BITCODE_RL	int
)	O
(	O
pvzadr	long
-	O
16	int
)	O
)	O
{	O
LOG_WARN	O
(	O
"second_header->address %u != %u"	pointer
,	O
FIELD_VALUE	O
(	O
address	long
)	O
,	O
(	O
unsigned	O
)	O
(	O
pvzadr	long
-	O
16	int
)	O
)	O
;	O
FIELD_VALUE	O
(	O
address	long
)	O
=	O
pvzadr	long
-	O
16	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
address	long
=	O
_obj	pointer
->	O
address	long
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
size	char
=	O
_obj	pointer
->	O
size	char
;	O
}	O
FIELD_BL	O
(	O
address	long
,	O
0	int
)	O
;	O
bit_write_TF	function
(	O
dat	pointer
,	O
(	O
char	O
*	O
)	O
_obj	pointer
->	O
version	short
,	O
12	int
)	O
;	O
LOG_TRACE	O
(	O
"version: %s [TFF 12]\n"	pointer
,	O
_obj	pointer
->	O
version	short
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
FIELD_B	O
(	O
null_b	array
[	O
i	int
]	O
,	O
0	int
)	O
;	O
FIELD_RC	O
(	O
unknown_10	short
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
FIELD_RC	O
(	O
unknown_rc4	array
[	O
i	int
]	O
,	O
0	int
)	O
;	O
UNTIL	O
(	O
R_2000	int
)	O
{	O
FIELD_RC	O
(	O
num_sections	int
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
FIELD_VALUE	O
(	O
num_sections	int
)	O
;	O
i	int
++	O
)	O
{	O
FIELD_RC	O
(	O
section	pointer
[	O
i	int
]	O
.	O
nr	char
,	O
0	int
)	O
;	O
FIELD_BL	O
(	O
section	pointer
[	O
i	int
]	O
.	O
address	long
,	O
0	int
)	O
;	O
FIELD_BLd	O
(	O
section	pointer
[	O
i	int
]	O
.	O
size	char
,	O
0	int
)	O
;	O
}	O
FIELD_BS	O
(	O
num_handlers	short
,	O
0	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
num_handlers	short
)	O
>	O
16	int
)	O
{	O
LOG_ERROR	O
(	O
"Second header num_handlers > 16: %d\n"	pointer
,	O
FIELD_VALUE	O
(	O
num_handlers	short
)	O
)	O
;	O
FIELD_VALUE	O
(	O
num_handlers	short
)	O
=	O
14	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
FIELD_VALUE	O
(	O
num_handlers	short
)	O
;	O
i	int
++	O
)	O
{	O
FIELD_RC	O
(	O
handlers	array
[	O
i	int
]	O
.	O
size	char
,	O
0	int
)	O
;	O
FIELD_RC	O
(	O
handlers	array
[	O
i	int
]	O
.	O
nr	char
,	O
0	int
)	O
;	O
FIELD_VECTOR	O
(	O
handlers	array
[	O
i	int
]	O
.	O
data	pointer
,	O
RC	O
,	O
handlers	array
[	O
i	int
]	O
.	O
size	char
,	O
0	int
)	O
;	O
}	O
_obj	pointer
->	O
size	char
=	O
encode_patch_RLsize	function
(	O
dat	pointer
,	O
pvzadr	long
)	O
;	O
bit_write_CRC	function
(	O
dat	pointer
,	O
pvzadr	long
,	O
0xC0C1	int
)	O
;	O
VERSION	O
(	O
R_14	int
)	O
{	O
FIELD_RL	O
(	O
junk_r14_1	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
junk_r14_2	int
,	O
0	int
)	O
;	O
}	O
}	O
bit_write_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_SECOND_HEADER_END	int
)	O
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
size	char
=	O
dat	pointer
->	O
byte	char
-	O
_obj	pointer
->	O
address	long
;	O
}	O
else	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
>	O
SECTION_2NDHEADER_R13	int
)	O
{	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
number	short
=	O
3	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
address	long
=	O
0	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
size	char
=	O
0	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
>	O
SECTION_MEASUREMENT_R13	int
)	O
{	O
LOG_INFO	O
(	O
"\n=======> MEASUREMENT: %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_MEASUREMENT_R13	int
]	O
.	O
number	short
=	O
4	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_MEASUREMENT_R13	int
]	O
.	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_MEASUREMENT_R13	int
]	O
.	O
size	char
=	O
4	int
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
(	O
BITCODE_RL	int
)	O
dwg	pointer
->	O
header_vars	struct
.	O
MEASUREMENT	short
)	O
;	O
LOG_TRACE	O
(	O
"HEADER.MEASUREMENT: %d [RL]\n"	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
MEASUREMENT	short
)	O
;	O
}	O
dat	pointer
->	O
size	char
=	O
dat	pointer
->	O
byte	char
;	O
LOG_INFO	O
(	O
"\nFinal DWG size: %u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
size	char
)	O
;	O
assert	O
(	O
section_address	long
)	O
;	O
dat	pointer
->	O
byte	char
=	O
section_address	long
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
LOG_INFO	O
(	O
"\n=======> section addresses: %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
;	O
j	int
++	O
)	O
{	O
bit_write_RC	function
(	O
dat	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
number	short
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
address	long
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"section[%u].number: %4d [RC] %s\n"	pointer
,	O
j	int
,	O
(	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
number	short
,	O
j	int
<	O
6	int
?	O
section_names	array
[	O
j	int
]	O
:	O
""	pointer
)	O
LOG_TRACE	O
(	O
"section[%u].offset: %4u [RL]\n"	pointer
,	O
j	int
,	O
(	O
unsigned	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
address	long
)	O
LOG_TRACE	O
(	O
"section[%u].size:   %4u [RL]\n"	pointer
,	O
j	int
,	O
(	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
size	char
)	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
size	char
>	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"section[%u] address or size overflow"	pointer
,	O
j	int
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
}	O
bit_write_CRC	function
(	O
dat	pointer
,	O
0	int
,	O
0	int
)	O
;	O
dat	pointer
->	O
byte	char
-=	O
2	int
;	O
ckr	int
=	O
bit_read_CRC	function
(	O
dat	pointer
)	O
;	O
dat	pointer
->	O
byte	char
-=	O
2	int
;	O
switch	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
{	O
case	O
3	int
:	O
ckr	int
^=	O
0xA598	int
;	O
break	O
;	O
case	O
4	int
:	O
ckr	int
^=	O
0x8101	int
;	O
break	O
;	O
case	O
5	int
:	O
ckr	int
^=	O
0x3CC4	int
;	O
break	O
;	O
case	O
6	int
:	O
ckr	int
^=	O
0x8461	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
bit_write_RS	function
(	O
dat	pointer
,	O
ckr	int
)	O
;	O
LOG_TRACE	O
(	O
"crc: %04X (from 0)\n"	pointer
,	O
ckr	int
)	O
;	O
return	O
0	int
;	O
}	O
AFL_GCC_POP	O
static	O
int	O
encode_preR13	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
)	O
{	O
return	O
DWG_ERR_NOTYETSUPPORTED	int
;	O
}	O
uint32_t	int
dwg_section_page_checksum	function
(	O
const	O
uint32_t	int
seed	short
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
uint32_t	int
size	char
)	O
{	O
uint32_t	int
sum1	int
=	O
seed	short
&	O
0xffff	int
;	O
uint32_t	int
sum2	int
=	O
seed	short
>>	O
0x10	int
;	O
unsigned	O
char	O
*	O
data	pointer
=	O
&	O
(	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
)	O
;	O
while	O
(	O
size	char
)	O
{	O
uint32_t	int
i	int
;	O
uint32_t	int
chunksize	int
=	O
size	char
<	O
0x15b0	int
?	O
size	char
:	O
0x15b0	int
;	O
size	char
-=	O
chunksize	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
chunksize	int
;	O
i	int
++	O
)	O
{	O
sum1	int
+=	O
*	O
data	pointer
++	O
;	O
sum2	int
+=	O
sum1	int
;	O
}	O
sum1	int
%=	O
0xFFF1	int
;	O
sum2	int
%=	O
0xFFF1	int
;	O
}	O
return	O
(	O
sum2	int
<<	O
0x10	int
)	O
|	O
(	O
sum1	int
&	O
0xffff	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
dxf_encode_alias	function
(	O
char	O
*	O
restrict	O
name	pointer
)	O
{	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"DICTIONARYWDFLT"	pointer
)	O
)	O
return	O
"ACDBDICTIONARYWDFLT"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"SECTIONVIEWSTYLE"	pointer
)	O
)	O
return	O
"ACDBSECTIONVIEWSTYLE"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"PLACEHOLDER"	pointer
)	O
)	O
return	O
"ACDBPLACEHOLDER"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"DETAILVIEWSTYLE"	pointer
)	O
)	O
return	O
"ACDBDETAILVIEWSTYLE"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ASSOCPERSSUBENTMANAGER"	pointer
)	O
)	O
return	O
"ACDBASSOCPERSSUBENTMANAGER"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"EVALUATION_GRAPH"	pointer
)	O
)	O
return	O
"ACAD_EVALUATION_GRAPH"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ASSOCACTION"	pointer
)	O
)	O
return	O
"ACDBASSOCACTION"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ASSOCALIGNEDDIMACTIONBODY"	pointer
)	O
)	O
return	O
"ACDBASSOCALIGNEDDIMACTIONBODY"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ASSOCOSNAPPOINTREFACTIONPARAM"	pointer
)	O
)	O
return	O
"ACDBASSOCOSNAPPOINTREFACTIONPARAM"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ASSOCVERTEXACTIONPARAM"	pointer
)	O
)	O
return	O
"ACDBASSOCVERTEXACTIONPARAM"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ASSOCGEOMDEPENDENCY"	pointer
)	O
)	O
return	O
"ACDBASSOCGEOMDEPENDENCY"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"ASSOCDEPENDENCY"	pointer
)	O
)	O
return	O
"ACDBASSOCDEPENDENCY"	pointer
;	O
else	O
if	O
(	O
strEQc	O
(	O
name	pointer
,	O
"TABLE"	pointer
)	O
)	O
return	O
"ACAD_TABLE"	pointer
;	O
else	O
return	O
NULL	O
;	O
}	O
Dwg_Class	struct
*	O
dwg_encode_get_class	function
(	O
Dwg_Data	struct
*	O
dwg	pointer
,	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
int	O
i	int
;	O
Dwg_Class	struct
*	O
klass	pointer
=	O
NULL	O
;	O
if	O
(	O
obj	pointer
->	O
dxfname	pointer
)	O
{	O
int	O
invalid_klass	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_classes	short
;	O
i	int
++	O
)	O
{	O
klass	pointer
=	O
&	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
;	O
if	O
(	O
!	O
klass	pointer
->	O
dxfname	pointer
)	O
{	O
invalid_klass	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
strEQ	O
(	O
obj	pointer
->	O
dxfname	pointer
,	O
klass	pointer
->	O
dxfname	pointer
)	O
)	O
{	O
obj	pointer
->	O
type	short
=	O
500	int
+	O
i	int
;	O
break	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
alias	pointer
=	O
dxf_encode_alias	function
(	O
obj	pointer
->	O
dxfname	pointer
)	O
;	O
if	O
(	O
alias	pointer
&&	O
klass	pointer
->	O
dxfname	pointer
&&	O
strEQ	O
(	O
alias	pointer
,	O
klass	pointer
->	O
dxfname	pointer
)	O
)	O
{	O
if	O
(	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_INDXF	int
)	O
obj	pointer
->	O
dxfname	pointer
=	O
strdup	function
(	O
(	O
char	O
*	O
)	O
alias	pointer
)	O
;	O
else	O
obj	pointer
->	O
dxfname	pointer
=	O
(	O
char	O
*	O
)	O
alias	pointer
;	O
obj	pointer
->	O
type	short
=	O
500	int
+	O
i	int
;	O
break	O
;	O
}	O
klass	pointer
=	O
NULL	O
;	O
if	O
(	O
invalid_klass	int
>	O
2	int
&&	O
!	O
(	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_INDXF	int
)	O
)	O
goto	O
search_by_index	O
;	O
}	O
}	O
}	O
else	O
{	O
search_by_index	O
:	O
i	int
=	O
obj	pointer
->	O
type	short
-	O
500	int
;	O
if	O
(	O
i	int
<	O
0	int
||	O
i	int
>=	O
(	O
int	O
)	O
dwg	pointer
->	O
num_classes	short
)	O
{	O
LOG_WARN	O
(	O
"Invalid object type %d, only %u classes"	pointer
,	O
obj	pointer
->	O
type	short
,	O
dwg	pointer
->	O
num_classes	short
)	O
;	O
return	O
NULL	O
;	O
}	O
klass	pointer
=	O
&	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
;	O
if	O
(	O
!	O
klass	pointer
||	O
!	O
klass	pointer
->	O
dxfname	pointer
)	O
return	O
NULL	O
;	O
obj	pointer
->	O
dxfname	pointer
=	O
klass	pointer
->	O
dxfname	pointer
;	O
}	O
return	O
klass	pointer
;	O
}	O
static	O
int	O
dwg_encode_variable_type	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
int	O
error	int
=	O
0	int
;	O
int	O
is_entity	int
;	O
Dwg_Class	struct
*	O
klass	pointer
=	O
dwg_encode_get_class	function
(	O
dwg	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
klass	pointer
)	O
return	O
DWG_ERR_INVALIDTYPE	int
;	O
is_entity	int
=	O
dwg_class_is_entity	function
(	O
klass	pointer
)	O
;	O
if	O
(	O
(	O
is_entity	int
&&	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_OBJECT	int
)	O
||	O
(	O
!	O
is_entity	int
&&	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
)	O
)	O
{	O
if	O
(	O
is_dwg_object	function
(	O
obj	pointer
->	O
name	pointer
)	O
)	O
{	O
if	O
(	O
is_entity	int
)	O
{	O
LOG_INFO	O
(	O
"Fixup Class %s item_class_id to %s for %s\n"	pointer
,	O
klass	pointer
->	O
dxfname	pointer
,	O
"OBJECT"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
klass	pointer
->	O
item_class_id	short
=	O
0x1f2	int
;	O
if	O
(	O
strNE	O
(	O
klass	pointer
->	O
dxfname	pointer
,	O
obj	pointer
->	O
dxfname	pointer
)	O
)	O
{	O
free	function
(	O
klass	pointer
->	O
dxfname	pointer
)	O
;	O
klass	pointer
->	O
dxfname	pointer
=	O
strdup	function
(	O
obj	pointer
->	O
dxfname	pointer
)	O
;	O
}	O
is_entity	int
=	O
0	int
;	O
}	O
else	O
{	O
LOG_INFO	O
(	O
"Fixup %s.supertype to %s\n"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"OBJECT"	pointer
)	O
;	O
obj	pointer
->	O
supertype	enum
=	O
DWG_SUPERTYPE_OBJECT	int
;	O
}	O
}	O
else	O
if	O
(	O
is_dwg_entity	function
(	O
obj	pointer
->	O
name	pointer
)	O
)	O
{	O
if	O
(	O
!	O
is_entity	int
)	O
{	O
LOG_INFO	O
(	O
"Fixup Class %s item_class_id to %s for %s\n"	pointer
,	O
klass	pointer
->	O
dxfname	pointer
,	O
"ENTITY"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
klass	pointer
->	O
item_class_id	short
=	O
0x1f3	int
;	O
if	O
(	O
strNE	O
(	O
klass	pointer
->	O
dxfname	pointer
,	O
obj	pointer
->	O
dxfname	pointer
)	O
)	O
{	O
free	function
(	O
klass	pointer
->	O
dxfname	pointer
)	O
;	O
klass	pointer
->	O
dxfname	pointer
=	O
strdup	function
(	O
obj	pointer
->	O
dxfname	pointer
)	O
;	O
}	O
is_entity	int
=	O
1	int
;	O
}	O
else	O
{	O
LOG_INFO	O
(	O
"Fixup %s.supertype to %s"	pointer
,	O
obj	pointer
->	O
name	pointer
,	O
"ENTITY"	pointer
)	O
;	O
obj	pointer
->	O
supertype	enum
=	O
DWG_SUPERTYPE_ENTITY	int
;	O
}	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"Illegal Class %s is_%s item_class_id for %s"	pointer
,	O
klass	pointer
->	O
dxfname	pointer
,	O
is_entity	int
?	O
"entity"	pointer
:	O
"object"	pointer
,	O
obj	pointer
->	O
name	pointer
)	O
;	O
return	O
DWG_ERR_INVALIDTYPE	int
;	O
}	O
}	O
if	O
(	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_INDXF	int
)	O
{	O
unsigned	O
long	O
pos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
dat	pointer
->	O
byte	char
=	O
obj	pointer
->	O
address	long
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
LOG_TRACE	O
(	O
"fixup Type: %d [BS] @%lu\n"	pointer
,	O
obj	pointer
->	O
type	short
,	O
obj	pointer
->	O
address	long
)	O
;	O
bit_write_BS	function
(	O
dat	pointer
,	O
obj	pointer
->	O
type	short
)	O
;	O
bit_set_position	function
(	O
dat	pointer
,	O
pos	long
)	O
;	O
}	O
LOG_WARN	O
(	O
"Unknown Class %s %d %s (0x%x%s)"	pointer
,	O
is_entity	int
?	O
"entity"	pointer
:	O
"object"	pointer
,	O
klass	pointer
->	O
number	short
,	O
klass	pointer
->	O
dxfname	pointer
,	O
klass	pointer
->	O
proxyflag	short
,	O
klass	pointer
->	O
is_zombie	char
?	O
"is_zombie"	pointer
:	O
""	pointer
)	O
return	O
DWG_ERR_UNHANDLEDCLASS	int
;	O
}	O
int	O
dwg_encode_add_object	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
unsigned	O
long	O
address	long
)	O
{	O
int	O
error	int
=	O
0	int
;	O
unsigned	O
long	O
oldpos	long
;	O
unsigned	O
long	O
end_address	long
=	O
address	long
+	O
obj	pointer
->	O
size	char
;	O
oldpos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
assert	O
(	O
address	long
)	O
;	O
dat	pointer
->	O
byte	char
=	O
address	long
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
LOG_INFO	O
(	O
"Object number: %lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
obj	pointer
->	O
index	short
)	O
;	O
if	O
(	O
obj	pointer
->	O
size	char
>	O
0x100000	int
)	O
{	O
LOG_ERROR	O
(	O
"Object size %u overflow"	pointer
,	O
obj	pointer
->	O
size	char
)	O
;	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
while	O
(	O
dat	pointer
->	O
byte	char
+	O
obj	pointer
->	O
size	char
>=	O
dat	pointer
->	O
size	char
)	O
bit_chain_alloc	function
(	O
dat	pointer
)	O
;	O
bit_write_MS	function
(	O
dat	pointer
,	O
obj	pointer
->	O
size	char
)	O
;	O
obj	pointer
->	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
PRE	O
(	O
R_2010	int
)	O
{	O
bit_write_BS	function
(	O
dat	pointer
,	O
obj	pointer
->	O
type	short
)	O
;	O
LOG_INFO	O
(	O
", Size: %d [MS], Type: %d [BS]\n"	pointer
,	O
obj	pointer
->	O
size	char
,	O
obj	pointer
->	O
type	short
)	O
}	O
LATER_VERSIONS	O
{	O
if	O
(	O
!	O
obj	pointer
->	O
handlestream_size	long
&&	O
obj	pointer
->	O
bitsize	int
)	O
obj	pointer
->	O
handlestream_size	long
=	O
obj	pointer
->	O
size	char
*	O
8	int
-	O
obj	pointer
->	O
bitsize	int
;	O
bit_write_UMC	function
(	O
dat	pointer
,	O
obj	pointer
->	O
handlestream_size	long
)	O
;	O
obj	pointer
->	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
bit_write_BOT	function
(	O
dat	pointer
,	O
obj	pointer
->	O
type	short
)	O
;	O
LOG_INFO	O
(	O
", Size: %d [MS], Hdlsize: %lu [UMC], Type: %d [BOT]\n"	pointer
,	O
obj	pointer
->	O
size	char
,	O
(	O
unsigned	O
long	O
)	O
obj	pointer
->	O
handlestream_size	long
,	O
obj	pointer
->	O
type	short
)	O
}	O
switch	O
(	O
obj	pointer
->	O
type	short
)	O
{	O
case	O
DWG_TYPE_TEXT	int
:	O
error	int
=	O
dwg_encode_TEXT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ATTRIB	int
:	O
error	int
=	O
dwg_encode_ATTRIB	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ATTDEF	int
:	O
error	int
=	O
dwg_encode_ATTDEF	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_BLOCK	int
:	O
error	int
=	O
dwg_encode_BLOCK	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ENDBLK	int
:	O
error	int
=	O
dwg_encode_ENDBLK	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_SEQEND	int
:	O
error	int
=	O
dwg_encode_SEQEND	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_INSERT	int
:	O
error	int
=	O
dwg_encode_INSERT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_MINSERT	int
:	O
error	int
=	O
dwg_encode_MINSERT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_2D	int
:	O
error	int
=	O
dwg_encode_VERTEX_2D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_3D	int
:	O
error	int
=	O
dwg_encode_VERTEX_3D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_MESH	int
:	O
error	int
=	O
dwg_encode_VERTEX_MESH	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_PFACE	int
:	O
error	int
=	O
dwg_encode_VERTEX_PFACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_PFACE_FACE	int
:	O
error	int
=	O
dwg_encode_VERTEX_PFACE_FACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_2D	int
:	O
error	int
=	O
dwg_encode_POLYLINE_2D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_3D	int
:	O
error	int
=	O
dwg_encode_POLYLINE_3D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ARC	int
:	O
error	int
=	O
dwg_encode_ARC	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_CIRCLE	int
:	O
error	int
=	O
dwg_encode_CIRCLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LINE	int
:	O
error	int
=	O
dwg_encode_LINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_ORDINATE	int
:	O
error	int
=	O
dwg_encode_DIMENSION_ORDINATE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_LINEAR	int
:	O
error	int
=	O
dwg_encode_DIMENSION_LINEAR	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_ALIGNED	int
:	O
error	int
=	O
dwg_encode_DIMENSION_ALIGNED	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_ANG3PT	int
:	O
error	int
=	O
dwg_encode_DIMENSION_ANG3PT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_ANG2LN	int
:	O
error	int
=	O
dwg_encode_DIMENSION_ANG2LN	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_RADIUS	int
:	O
error	int
=	O
dwg_encode_DIMENSION_RADIUS	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_DIAMETER	int
:	O
error	int
=	O
dwg_encode_DIMENSION_DIAMETER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POINT	int
:	O
error	int
=	O
dwg_encode_POINT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE__3DFACE	int
:	O
error	int
=	O
dwg_encode__3DFACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_PFACE	int
:	O
error	int
=	O
dwg_encode_POLYLINE_PFACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_MESH	int
:	O
error	int
=	O
dwg_encode_POLYLINE_MESH	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_SOLID	int
:	O
error	int
=	O
dwg_encode_SOLID	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_TRACE	int
:	O
error	int
=	O
dwg_encode_TRACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_SHAPE	int
:	O
error	int
=	O
dwg_encode_SHAPE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VIEWPORT	int
:	O
error	int
=	O
dwg_encode_VIEWPORT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ELLIPSE	int
:	O
error	int
=	O
dwg_encode_ELLIPSE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_SPLINE	int
:	O
error	int
=	O
dwg_encode_SPLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_REGION	int
:	O
error	int
=	O
dwg_encode_REGION	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE__3DSOLID	int
:	O
error	int
=	O
dwg_encode__3DSOLID	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_BODY	int
:	O
error	int
=	O
dwg_encode_BODY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_RAY	int
:	O
error	int
=	O
dwg_encode_RAY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_XLINE	int
:	O
error	int
=	O
dwg_encode_XLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DICTIONARY	int
:	O
error	int
=	O
dwg_encode_DICTIONARY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_MTEXT	int
:	O
error	int
=	O
dwg_encode_MTEXT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LEADER	int
:	O
error	int
=	O
dwg_encode_LEADER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_TOLERANCE	int
:	O
error	int
=	O
dwg_encode_TOLERANCE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_MLINE	int
:	O
error	int
=	O
dwg_encode_MLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_BLOCK_CONTROL	int
:	O
error	int
=	O
dwg_encode_BLOCK_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_BLOCK_HEADER	int
:	O
error	int
=	O
dwg_encode_BLOCK_HEADER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LAYER_CONTROL	int
:	O
error	int
=	O
dwg_encode_LAYER_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LAYER	int
:	O
error	int
=	O
dwg_encode_LAYER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_STYLE_CONTROL	int
:	O
error	int
=	O
dwg_encode_STYLE_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_STYLE	int
:	O
error	int
=	O
dwg_encode_STYLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LTYPE_CONTROL	int
:	O
error	int
=	O
dwg_encode_LTYPE_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LTYPE	int
:	O
error	int
=	O
dwg_encode_LTYPE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VIEW_CONTROL	int
:	O
error	int
=	O
dwg_encode_VIEW_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VIEW	int
:	O
error	int
=	O
dwg_encode_VIEW	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_UCS_CONTROL	int
:	O
error	int
=	O
dwg_encode_UCS_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_UCS	int
:	O
error	int
=	O
dwg_encode_UCS	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VPORT_CONTROL	int
:	O
error	int
=	O
dwg_encode_VPORT_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VPORT	int
:	O
error	int
=	O
dwg_encode_VPORT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_APPID_CONTROL	int
:	O
error	int
=	O
dwg_encode_APPID_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_APPID	int
:	O
error	int
=	O
dwg_encode_APPID	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMSTYLE_CONTROL	int
:	O
error	int
=	O
dwg_encode_DIMSTYLE_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMSTYLE	int
:	O
error	int
=	O
dwg_encode_DIMSTYLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VPORT_ENTITY_CONTROL	int
:	O
error	int
=	O
dwg_encode_VPORT_ENTITY_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VPORT_ENTITY_HEADER	int
:	O
error	int
=	O
dwg_encode_VPORT_ENTITY_HEADER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_GROUP	int
:	O
error	int
=	O
dwg_encode_GROUP	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_MLINESTYLE	int
:	O
error	int
=	O
dwg_encode_MLINESTYLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_OLE2FRAME	int
:	O
error	int
=	O
dwg_encode_OLE2FRAME	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DUMMY	int
:	O
error	int
=	O
dwg_encode_DUMMY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LONG_TRANSACTION	int
:	O
error	int
=	O
dwg_encode_LONG_TRANSACTION	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LWPOLYLINE	int
:	O
error	int
=	O
dwg_encode_LWPOLYLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_HATCH	int
:	O
error	int
=	O
dwg_encode_HATCH	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_XRECORD	int
:	O
error	int
=	O
dwg_encode_XRECORD	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_PLACEHOLDER	int
:	O
error	int
=	O
dwg_encode_PLACEHOLDER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_OLEFRAME	int
:	O
error	int
=	O
dwg_encode_OLEFRAME	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VBA_PROJECT	int
:	O
LOG_ERROR	O
(	O
"Unhandled Object VBA_PROJECT. Has its own section"	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LAYOUT	int
:	O
error	int
|=	O
dwg_encode_LAYOUT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_PROXY_ENTITY	int
:	O
error	int
=	O
dwg_encode_PROXY_ENTITY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_PROXY_OBJECT	int
:	O
error	int
=	O
dwg_encode_PROXY_OBJECT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
obj	pointer
->	O
parent	pointer
&&	O
obj	pointer
->	O
type	short
==	O
obj	pointer
->	O
parent	pointer
->	O
layout_type	int
&&	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LAYOUT	int
)	O
{	O
error	int
=	O
dwg_encode_LAYOUT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
dwg_encode_get_class	function
(	O
obj	pointer
->	O
parent	pointer
,	O
obj	pointer
)	O
;	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
parent	pointer
!=	O
NULL	O
&&	O
(	O
error	int
=	O
dwg_encode_variable_type	function
(	O
obj	pointer
->	O
parent	pointer
,	O
dat	pointer
,	O
obj	pointer
)	O
)	O
&	O
DWG_ERR_UNHANDLEDCLASS	int
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
int	O
is_entity	int
;	O
Dwg_Class	struct
*	O
klass	pointer
=	O
dwg_encode_get_class	function
(	O
dwg	pointer
,	O
obj	pointer
)	O
;	O
assert	O
(	O
address	long
)	O
;	O
dat	pointer
->	O
byte	char
=	O
address	long
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
bit_write_MS	function
(	O
dat	pointer
,	O
obj	pointer
->	O
size	char
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2010	int
)	O
{	O
bit_write_UMC	function
(	O
dat	pointer
,	O
obj	pointer
->	O
handlestream_size	long
)	O
;	O
bit_write_BOT	function
(	O
dat	pointer
,	O
obj	pointer
->	O
type	short
)	O
;	O
}	O
else	O
bit_write_BS	function
(	O
dat	pointer
,	O
obj	pointer
->	O
type	short
)	O
;	O
if	O
(	O
klass	pointer
)	O
is_entity	int
=	O
klass	pointer
->	O
item_class_id	short
==	O
0x1f2	int
&&	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
;	O
else	O
is_entity	int
=	O
obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_ENTITY	int
;	O
if	O
(	O
is_entity	int
)	O
error	int
=	O
dwg_encode_UNKNOWN_ENT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
else	O
error	int
=	O
dwg_encode_UNKNOWN_OBJ	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
obj	pointer
->	O
size	char
)	O
{	O
BITCODE_BL	int
pos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
assert	O
(	O
address	long
)	O
;	O
obj	pointer
->	O
size	char
=	O
dat	pointer
->	O
byte	char
-	O
address	long
-	O
2	int
;	O
if	O
(	O
dat	pointer
->	O
bit	char
)	O
obj	pointer
->	O
size	char
++	O
;	O
if	O
(	O
!	O
obj	pointer
->	O
bitsize	int
)	O
{	O
LOG_TRACE	O
(	O
"-bitsize calc from address (no handle) @%lu.%u\n"	pointer
,	O
dat	pointer
->	O
byte	char
,	O
dat	pointer
->	O
bit	char
)	O
;	O
obj	pointer
->	O
bitsize	int
=	O
pos	long
-	O
(	O
obj	pointer
->	O
address	long
*	O
8	int
)	O
;	O
}	O
bit_set_position	function
(	O
dat	pointer
,	O
address	long
*	O
8	int
)	O
;	O
if	O
(	O
obj	pointer
->	O
size	char
>	O
0x7fff	int
)	O
LOG_ERROR	O
(	O
"Unhandled size %u > 0x7fff"	pointer
,	O
(	O
unsigned	O
)	O
obj	pointer
->	O
size	char
)	O
;	O
bit_write_MS	function
(	O
dat	pointer
,	O
obj	pointer
->	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"-size: %u [MS] @%lu\n"	pointer
,	O
obj	pointer
->	O
size	char
,	O
address	long
)	O
;	O
SINCE	O
(	O
R_2013	int
)	O
{	O
if	O
(	O
!	O
obj	pointer
->	O
handlestream_size	long
&&	O
obj	pointer
->	O
bitsize	int
)	O
obj	pointer
->	O
handlestream_size	long
=	O
obj	pointer
->	O
size	char
*	O
8	int
-	O
obj	pointer
->	O
bitsize	int
;	O
bit_write_UMC	function
(	O
dat	pointer
,	O
obj	pointer
->	O
handlestream_size	long
)	O
;	O
LOG_TRACE	O
(	O
"-handlestream_size: %lu [UMC]\n"	pointer
,	O
obj	pointer
->	O
handlestream_size	long
)	O
;	O
}	O
SINCE	O
(	O
R_2000	int
)	O
{	O
if	O
(	O
obj	pointer
->	O
bitsize_pos	long
&&	O
obj	pointer
->	O
bitsize	int
)	O
{	O
bit_set_position	function
(	O
dat	pointer
,	O
obj	pointer
->	O
bitsize_pos	long
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
obj	pointer
->	O
bitsize	int
)	O
;	O
LOG_TRACE	O
(	O
"-bitsize: %u [RL] @%lu.%lu\n"	pointer
,	O
obj	pointer
->	O
bitsize	int
,	O
obj	pointer
->	O
bitsize_pos	long
/	O
8	int
,	O
obj	pointer
->	O
bitsize_pos	long
%	O
8	int
)	O
;	O
}	O
}	O
bit_set_position	function
(	O
dat	pointer
,	O
pos	long
)	O
;	O
}	O
if	O
(	O
dat	pointer
->	O
bit	char
)	O
LOG_TRACE	O
(	O
"padding: +%d [*B]\n"	pointer
,	O
8	int
-	O
dat	pointer
->	O
bit	char
)	O
while	O
(	O
dat	pointer
->	O
bit	char
)	O
bit_write_B	function
(	O
dat	pointer
,	O
1	int
)	O
;	O
end_address	long
=	O
obj	pointer
->	O
address	long
+	O
obj	pointer
->	O
size	char
;	O
if	O
(	O
end_address	long
!=	O
dat	pointer
->	O
byte	char
)	O
{	O
if	O
(	O
obj	pointer
->	O
size	char
)	O
LOG_WARN	O
(	O
"Wrong object size: %lu + %u = %lu != %lu: %ld off"	pointer
,	O
obj	pointer
->	O
address	long
,	O
obj	pointer
->	O
size	char
,	O
end_address	long
,	O
dat	pointer
->	O
byte	char
,	O
(	O
long	O
)	O
(	O
end_address	long
-	O
dat	pointer
->	O
byte	char
)	O
)	O
;	O
dat	pointer
->	O
byte	char
=	O
end_address	long
;	O
}	O
assert	O
(	O
!	O
dat	pointer
->	O
bit	char
)	O
;	O
bit_write_CRC	function
(	O
dat	pointer
,	O
address	long
,	O
0xC0C1	int
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
dwg_encode_eed_data	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Eed_Data	struct
*	O
restrict	O
data	pointer
,	O
const	O
int	O
size	char
,	O
const	O
int	O
i	int
)	O
{	O
bit_write_RC	function
(	O
dat	pointer
,	O
data	pointer
->	O
code	char
)	O
;	O
LOG_TRACE	O
(	O
"EED[%d] code: %d [RC] "	pointer
,	O
i	int
,	O
data	pointer
->	O
code	char
)	O
;	O
switch	O
(	O
data	pointer
->	O
code	char
)	O
{	O
case	O
0	int
:	O
{	O
PRE	O
(	O
R_2007	int
)	O
{	O
if	O
(	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
+	O
3	int
<=	O
size	char
)	O
{	O
if	O
(	O
!	O
*	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
string	array
)	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
=	O
0	int
;	O
bit_write_RC	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
)	O
;	O
bit_write_RS_LE	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
codepage	int
)	O
;	O
bit_write_TF	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
string	array
,	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
)	O
;	O
}	O
LOG_TRACE	O
(	O
"string: len=%d [RC] cp=%d [RS_LE] \"%s\" [TF]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
,	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
codepage	int
,	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
string	array
)	O
;	O
}	O
LATER_VERSIONS	O
{	O
BITCODE_RS	short
*	O
s	pointer
=	O
(	O
BITCODE_RS	short
*	O
)	O
&	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
string	array
;	O
if	O
(	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
*	O
2	int
+	O
2	int
<=	O
size	char
)	O
{	O
bit_write_RS	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
length	double
)	O
;	O
for	O
(	O
int	O
j	int
=	O
0	int
;	O
j	int
<	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
length	double
;	O
j	int
++	O
)	O
bit_write_RS	function
(	O
dat	pointer
,	O
*	O
s	pointer
++	O
)	O
;	O
}	O
else	O
bit_write_RS	function
(	O
dat	pointer
,	O
0	int
)	O
;	O
if	O
(	O
DWG_LOGLEVEL	O
>=	O
DWG_LOGLEVEL_TRACE	int
)	O
{	O
char	O
*	O
u8	pointer
=	O
bit_convert_TU	function
(	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
string	array
)	O
;	O
LOG_TRACE	O
(	O
"wstring: len=%d [RS] \"%s\" [TU]\n"	pointer
,	O
(	O
int	O
)	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
length	double
,	O
u8	pointer
)	O
;	O
free	function
(	O
u8	pointer
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
1	int
<=	O
size	char
)	O
bit_write_RC	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_2	struct
.	O
byte	char
)	O
;	O
LOG_TRACE	O
(	O
"byte: %d [RC]\n"	pointer
,	O
(	O
int	O
)	O
data	pointer
->	O
u	union
.	O
eed_2	struct
.	O
byte	char
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
4	int
<=	O
size	char
)	O
bit_write_RL	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_3	struct
.	O
layer	int
)	O
;	O
LOG_TRACE	O
(	O
"layer: %d [RL]\n"	pointer
,	O
(	O
int	O
)	O
data	pointer
->	O
u	union
.	O
eed_3	struct
.	O
layer	int
)	O
;	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
+	O
1	int
<=	O
size	char
)	O
{	O
bit_write_RC	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
length	double
)	O
;	O
bit_write_TF	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
data	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
length	double
)	O
;	O
}	O
LOG_TRACE	O
(	O
"binary: \"%s\" [TF %d]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
data	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
length	double
)	O
;	O
break	O
;	O
case	O
5	int
:	O
if	O
(	O
8	int
<=	O
size	char
)	O
bit_write_RLL	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_5	struct
.	O
entity	long
)	O
;	O
LOG_TRACE	O
(	O
"entity: 0x%lX [RLL]\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
data	pointer
->	O
u	union
.	O
eed_5	struct
.	O
entity	long
)	O
;	O
break	O
;	O
case	O
10	int
:	O
case	O
11	int
:	O
case	O
12	int
:	O
case	O
13	int
:	O
case	O
14	int
:	O
case	O
15	int
:	O
if	O
(	O
24	int
<=	O
size	char
)	O
{	O
bit_write_RD	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
x	double
)	O
;	O
bit_write_RD	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
y	double
)	O
;	O
bit_write_RD	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
z	double
)	O
;	O
}	O
LOG_TRACE	O
(	O
"3dpoint: (%f, %f, %f) [3RD]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
x	double
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
y	double
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
z	double
)	O
;	O
break	O
;	O
case	O
40	int
:	O
case	O
41	int
:	O
case	O
42	int
:	O
if	O
(	O
8	int
<=	O
size	char
)	O
bit_write_RD	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_40	struct
.	O
real	double
)	O
;	O
LOG_TRACE	O
(	O
"real: %f [RD]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_40	struct
.	O
real	double
)	O
;	O
break	O
;	O
case	O
70	int
:	O
if	O
(	O
2	int
<=	O
size	char
)	O
bit_write_RS	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_70	struct
.	O
rs	short
)	O
;	O
LOG_TRACE	O
(	O
"short: "	pointer
FORMAT_RS	O
" [RS]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_70	struct
.	O
rs	short
)	O
;	O
break	O
;	O
case	O
71	int
:	O
if	O
(	O
4	int
<=	O
size	char
)	O
bit_write_RL	function
(	O
dat	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_71	struct
.	O
rl	int
)	O
;	O
LOG_TRACE	O
(	O
"long: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_71	struct
.	O
rl	int
)	O
;	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"unknown EED code %d"	pointer
,	O
data	pointer
->	O
code	char
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
dwg_encode_eed	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
unsigned	O
long	O
off	int
=	O
obj	pointer
->	O
address	long
;	O
unsigned	O
long	O
last_handle	int
=	O
0	int
;	O
int	O
i	int
,	O
num_eed	int
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
num_eed	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_eed	int
;	O
i	int
++	O
)	O
{	O
Dwg_Eed	struct
*	O
eed	pointer
=	O
&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
eed	pointer
[	O
i	int
]	O
;	O
BITCODE_BS	short
size	char
=	O
eed	pointer
->	O
size	char
;	O
if	O
(	O
size	char
)	O
{	O
bit_write_BS	function
(	O
dat	pointer
,	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"EED[%d] size: "	pointer
FORMAT_BS	O
" [BS]\n"	pointer
,	O
i	int
,	O
size	char
)	O
;	O
LOG_POS	O
bit_write_H	function
(	O
dat	pointer
,	O
&	O
eed	pointer
->	O
handle	pointer
)	O
;	O
LOG_TRACE	O
(	O
"EED[%d] handle: "	pointer
FORMAT_H	pointer
" [H]\n"	pointer
,	O
i	int
,	O
ARGS_H	O
(	O
eed	pointer
->	O
handle	pointer
)	O
)	O
;	O
LOG_POS	O
if	O
(	O
eed	pointer
->	O
raw	pointer
)	O
{	O
last_handle	int
=	O
eed	pointer
->	O
handle	pointer
.	O
value	double
;	O
LOG_TRACE	O
(	O
"EED[%d] raw [TF %d]\n"	pointer
,	O
i	int
,	O
size	char
)	O
;	O
bit_write_TF	function
(	O
dat	pointer
,	O
eed	pointer
->	O
raw	pointer
,	O
size	char
)	O
;	O
LOG_TRACE_TF	O
(	O
eed	pointer
->	O
raw	pointer
,	O
size	char
)	O
;	O
}	O
else	O
if	O
(	O
eed	pointer
->	O
data	pointer
)	O
{	O
dwg_encode_eed_data	function
(	O
dat	pointer
,	O
eed	pointer
->	O
data	pointer
,	O
size	char
,	O
i	int
)	O
;	O
LOG_POS	O
}	O
}	O
else	O
if	O
(	O
eed	pointer
->	O
data	pointer
!=	O
NULL	O
&&	O
eed	pointer
->	O
handle	pointer
.	O
value	double
!=	O
last_handle	int
)	O
{	O
dwg_encode_eed_data	function
(	O
dat	pointer
,	O
eed	pointer
->	O
data	pointer
,	O
size	char
,	O
i	int
)	O
;	O
LOG_POS	O
}	O
}	O
bit_write_BS	function
(	O
dat	pointer
,	O
0	int
)	O
;	O
if	O
(	O
i	int
)	O
LOG_TRACE	O
(	O
"EED[%d] size: 0 [BS] (end)\n"	pointer
,	O
i	int
)	O
;	O
LOG_TRACE	O
(	O
"num_eed: %d\n"	pointer
,	O
num_eed	int
)	O
;	O
LOG_POS	O
return	O
0	int
;	O
}	O
static	O
int	O
dwg_encode_entity	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
int	O
error	int
=	O
0	int
;	O
Dwg_Object_Entity	struct
*	O
ent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
Dwg_Object_Entity	struct
*	O
_obj	pointer
=	O
ent	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
ent	pointer
->	O
dwg	pointer
;	O
if	O
(	O
!	O
obj	pointer
||	O
!	O
dat	pointer
)	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
PRE	O
(	O
R_13	int
)	O
{	O
if	O
(	O
FIELD_VALUE	O
(	O
flag_r11	char
)	O
&	O
4	int
&&	O
FIELD_VALUE	O
(	O
kind_r11	short
)	O
>	O
2	int
&&	O
FIELD_VALUE	O
(	O
kind_r11	short
)	O
!=	O
22	int
)	O
FIELD_RD	O
(	O
elevation_r11	double
,	O
30	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
flag_r11	char
)	O
&	O
8	int
)	O
FIELD_RD	O
(	O
thickness_r11	double
,	O
39	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
flag_r11	char
)	O
&	O
0x20	int
)	O
{	O
Dwg_Object_Ref	struct
*	O
hdl	array
=	O
dwg_decode_handleref_with_code	function
(	O
dat	pointer
,	O
obj	pointer
,	O
dwg	pointer
,	O
0	int
)	O
;	O
if	O
(	O
hdl	array
)	O
obj	pointer
->	O
handle	pointer
=	O
hdl	array
->	O
handleref	struct
;	O
}	O
if	O
(	O
FIELD_VALUE	O
(	O
extra_r11	char
)	O
&	O
4	int
)	O
FIELD_RS	O
(	O
paper_r11	short
,	O
0	int
)	O
;	O
}	O
SINCE	O
(	O
R_2007	int
)	O
{	O
*	O
str_dat	pointer
=	O
*	O
dat	pointer
;	O
}	O
VERSIONS	O
(	O
R_2000	int
,	O
R_2007	int
)	O
{	O
obj	pointer
->	O
bitsize_pos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
obj	pointer
->	O
bitsize	int
)	O
;	O
LOG_TRACE	O
(	O
"bitsize: %u [RL] (@%lu.%lu)\n"	pointer
,	O
obj	pointer
->	O
bitsize	int
,	O
obj	pointer
->	O
bitsize_pos	long
/	O
8	int
,	O
obj	pointer
->	O
bitsize_pos	long
%	O
8	int
)	O
;	O
}	O
if	O
(	O
obj	pointer
->	O
bitsize	int
)	O
obj	pointer
->	O
hdlpos	long
=	O
obj	pointer
->	O
address	long
*	O
8	int
+	O
obj	pointer
->	O
bitsize	int
;	O
SINCE	O
(	O
R_2007	int
)	O
{	O
SINCE	O
(	O
R_2010	int
)	O
{	O
if	O
(	O
obj	pointer
->	O
bitsize	int
)	O
{	O
obj	pointer
->	O
hdlpos	long
+=	O
8	int
;	O
LOG_HANDLE	O
(	O
"hdlpos: %lu\n"	pointer
,	O
obj	pointer
->	O
hdlpos	long
)	O
;	O
}	O
}	O
error	int
|=	O
obj_string_stream	function
(	O
dat	pointer
,	O
obj	pointer
,	O
str_dat	pointer
)	O
;	O
}	O
bit_write_H	function
(	O
dat	pointer
,	O
&	O
obj	pointer
->	O
handle	pointer
)	O
;	O
LOG_TRACE	O
(	O
"handle: "	pointer
FORMAT_H	pointer
" [H 5]\n"	pointer
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
)	O
PRE	O
(	O
R_13	int
)	O
{	O
return	O
DWG_ERR_NOTYETSUPPORTED	int
;	O
}	O
error	int
|=	O
dwg_encode_eed	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
dwg_encode_common_entity_handle_data	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
Dwg_Object_Entity	struct
*	O
ent	pointer
;	O
Dwg_Object_Entity	struct
*	O
_obj	pointer
;	O
BITCODE_BL	int
vcount	int
;	O
int	O
error	int
=	O
0	int
;	O
ent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
_obj	pointer
=	O
ent	pointer
;	O
return	O
error	int
;	O
}	O
void	O
dwg_encode_handleref	function
(	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
{	O
assert	O
(	O
obj	pointer
)	O
;	O
}	O
void	O
dwg_encode_handleref_with_code	function
(	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
,	O
unsigned	O
int	O
code	char
)	O
{	O
dwg_encode_handleref	function
(	O
hdl_dat	pointer
,	O
obj	pointer
,	O
dwg	pointer
,	O
ref	pointer
)	O
;	O
if	O
(	O
ref	pointer
->	O
absolute_ref	long
==	O
0	int
&&	O
ref	pointer
->	O
handleref	struct
.	O
code	char
!=	O
code	char
)	O
{	O
switch	O
(	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
{	O
case	O
0x06	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
+	O
1	int
)	O
;	O
break	O
;	O
case	O
0x08	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
-	O
1	int
)	O
;	O
break	O
;	O
case	O
0x0A	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
+	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
;	O
break	O
;	O
case	O
0x0C	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
-	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
break	O
;	O
case	O
0	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
break	O
;	O
default	O
:	O
LOG_WARN	O
(	O
"Invalid handle pointer code %d"	pointer
,	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
int	O
dwg_encode_object	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
int	O
error	int
=	O
0	int
;	O
Dwg_Object_Object	struct
*	O
ord	pointer
=	O
obj	pointer
->	O
tio	union
.	O
object	pointer
;	O
VERSIONS	O
(	O
R_2000	int
,	O
R_2007	int
)	O
{	O
obj	pointer
->	O
bitsize_pos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
obj	pointer
->	O
bitsize	int
)	O
;	O
LOG_INFO	O
(	O
"bitsize: "	pointer
FORMAT_RL	O
" [RL] (@%lu.%u)\n"	pointer
,	O
obj	pointer
->	O
bitsize	int
,	O
dat	pointer
->	O
byte	char
-	O
4	int
,	O
dat	pointer
->	O
bit	char
)	O
;	O
}	O
if	O
(	O
obj	pointer
->	O
bitsize	int
)	O
obj	pointer
->	O
hdlpos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
+	O
obj	pointer
->	O
bitsize	int
;	O
SINCE	O
(	O
R_2007	int
)	O
{	O
obj_string_stream	function
(	O
dat	pointer
,	O
obj	pointer
,	O
str_dat	pointer
)	O
;	O
}	O
bit_write_H	function
(	O
dat	pointer
,	O
&	O
obj	pointer
->	O
handle	pointer
)	O
;	O
LOG_TRACE	O
(	O
"handle: "	pointer
FORMAT_H	pointer
" [H 5]\n"	pointer
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
)	O
;	O
error	int
|=	O
dwg_encode_eed	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
VERSIONS	O
(	O
R_13	int
,	O
R_14	int
)	O
{	O
obj	pointer
->	O
bitsize_pos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
obj	pointer
->	O
bitsize	int
)	O
;	O
LOG_INFO	O
(	O
"bitsize: "	pointer
FORMAT_RL	O
" [RL] (@%lu.%u)\n"	pointer
,	O
obj	pointer
->	O
bitsize	int
,	O
dat	pointer
->	O
byte	char
-	O
4	int
,	O
dat	pointer
->	O
bit	char
)	O
;	O
}	O
bit_write_BL	function
(	O
dat	pointer
,	O
ord	pointer
->	O
num_reactors	int
)	O
;	O
LOG_TRACE	O
(	O
"num_reactors: "	pointer
FORMAT_BL	O
" [BL]\n"	pointer
,	O
ord	pointer
->	O
num_reactors	int
)	O
;	O
SINCE	O
(	O
R_2004	int
)	O
{	O
bit_write_B	function
(	O
dat	pointer
,	O
ord	pointer
->	O
xdic_missing_flag	char
)	O
;	O
LOG_TRACE	O
(	O
"xdic_missing_flag: "	pointer
FORMAT_B	pointer
" [B]\n"	pointer
,	O
ord	pointer
->	O
xdic_missing_flag	char
)	O
;	O
}	O
SINCE	O
(	O
R_2013	int
)	O
{	O
bit_write_B	function
(	O
dat	pointer
,	O
ord	pointer
->	O
has_ds_binary_data	char
)	O
;	O
LOG_TRACE	O
(	O
"has_ds_binary_data: "	pointer
FORMAT_B	pointer
" [B]\n"	pointer
,	O
ord	pointer
->	O
has_ds_binary_data	char
)	O
;	O
}	O
return	O
error	int
;	O
}	O
AFL_GCC_TOOBIG	O
static	O
int	O
dwg_encode_header_variables	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Header_Variables	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header_vars	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
int	O
old_from	int
=	O
(	O
int	O
)	O
dat	pointer
->	O
from_version	enum
;	O
if	O
(	O
!	O
_obj	pointer
->	O
HANDSEED	pointer
)	O
{	O
dwg	pointer
->	O
opts	int
|=	O
DWG_OPTS_MINIMAL	int
;	O
dat	pointer
->	O
from_version	enum
=	O
dat	pointer
->	O
version	short
-	O
1	int
;	O
LOG_TRACE	O
(	O
"encode from minimal DXF\n"	pointer
)	O
;	O
_obj	pointer
->	O
HANDSEED	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
)	O
)	O
;	O
_obj	pointer
->	O
HANDSEED	pointer
->	O
absolute_ref	long
=	O
0x72E	int
;	O
}	O
dat	pointer
->	O
from_version	enum
=	O
old_from	int
;	O
return	O
0	int
;	O
}	O
AFL_GCC_POP	O
static	O
int	O
dwg_encode_xdata	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object_XRECORD	struct
*	O
restrict	O
obj	pointer
,	O
int	O
num_databytes	int
)	O
{	O
Dwg_Resbuf	struct
*	O
rbuf	pointer
=	O
obj	pointer
->	O
xdata	pointer
;	O
enum	O
RES_BUF_VALUE_TYPE	enum
type	short
;	O
int	O
i	int
;	O
unsigned	O
j	int
=	O
0	int
;	O
BITCODE_BL	int
num_xdata	int
=	O
obj	pointer
->	O
num_xdata	int
;	O
unsigned	O
long	O
start	struct
=	O
dat	pointer
->	O
byte	char
,	O
end	struct
=	O
start	struct
+	O
num_databytes	int
;	O
int	O
error	int
=	O
0	int
;	O
while	O
(	O
rbuf	pointer
)	O
{	O
LOG_INSANE	O
(	O
"xdata[%u] type: "	pointer
FORMAT_RS	O
" [RS]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
type	short
)	O
bit_write_RS	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
type	short
=	O
get_base_value_type	function
(	O
rbuf	pointer
->	O
type	short
)	O
;	O
switch	O
(	O
type	short
)	O
{	O
case	O
VT_STRING	int
:	O
UNTIL	O
(	O
R_2007	int
)	O
{	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
3	int
+	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
>	O
end	struct
)	O
break	O
;	O
bit_write_RS	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
;	O
bit_write_RC	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
codepage	int
)	O
;	O
if	O
(	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
)	O
bit_write_TF	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
;	O
else	O
bit_write_TF	function
(	O
dat	pointer
,	O
(	O
char	O
*	O
)	O
""	pointer
,	O
0	int
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: \"%s\" [TF %d %d]\n"	pointer
,	O
j	int
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
}	O
LATER_VERSIONS	O
{	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
2	int
+	O
(	O
2	int
*	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
>	O
end	struct
||	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
<	O
0	int
)	O
break	O
;	O
bit_write_RS	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
;	O
i	int
++	O
)	O
bit_write_RS	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
[	O
i	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
VT_REAL	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
8	int
>	O
end	struct
)	O
break	O
;	O
bit_write_RD	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
dbl	double
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: %f [RD %d]\n"	pointer
,	O
j	int
,	O
rbuf	pointer
->	O
value	double
.	O
dbl	double
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_BOOL	int
:	O
case	O
VT_INT8	int
:	O
bit_write_RC	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
i8	char
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: %d [RC %d]\n"	pointer
,	O
j	int
,	O
(	O
int	O
)	O
rbuf	pointer
->	O
value	double
.	O
i8	char
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INT16	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
2	int
>	O
end	struct
)	O
break	O
;	O
bit_write_RS	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
i16	short
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: %d [RS %d]\n"	pointer
,	O
j	int
,	O
(	O
int	O
)	O
rbuf	pointer
->	O
value	double
.	O
i16	short
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INT32	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
4	int
>	O
end	struct
)	O
break	O
;	O
bit_write_RL	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
i32	int
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%d]: %ld [RL %d]\n"	pointer
,	O
j	int
,	O
(	O
long	O
)	O
rbuf	pointer
->	O
value	double
.	O
i32	int
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INT64	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
8	int
>	O
end	struct
)	O
break	O
;	O
bit_write_BLL	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
i64	long
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: "	pointer
FORMAT_BLL	O
" [BLL %d]\n"	pointer
,	O
j	int
,	O
rbuf	pointer
->	O
value	double
.	O
i64	long
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_POINT3D	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
24	int
>	O
end	struct
)	O
break	O
;	O
bit_write_RD	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
0	int
]	O
)	O
;	O
bit_write_RD	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
1	int
]	O
)	O
;	O
bit_write_RD	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
2	int
]	O
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: (%f,%f,%f) [3RD %d]\n"	pointer
,	O
j	int
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
0	int
]	O
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
1	int
]	O
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
2	int
]	O
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_BINARY	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
>	O
end	struct
)	O
break	O
;	O
bit_write_RC	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
;	O
bit_write_TF	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: [TF %d %d] "	pointer
,	O
j	int
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
LOG_TRACE_TF	O
(	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
;	O
break	O
;	O
case	O
VT_HANDLE	int
:	O
case	O
VT_OBJECTID	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
8	int
>	O
end	struct
)	O
break	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
bit_write_RC	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
hdl	array
[	O
i	int
]	O
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: "	pointer
FORMAT_H	pointer
" [H %d]\n"	pointer
,	O
j	int
,	O
ARGS_H	O
(	O
rbuf	pointer
->	O
value	double
.	O
h	struct
)	O
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INVALID	int
:	O
default	O
:	O
LOG_ERROR	O
(	O
"Invalid group code in xdata: %d"	pointer
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
error	int
=	O
DWG_ERR_INVALIDEED	int
;	O
break	O
;	O
}	O
rbuf	pointer
=	O
rbuf	pointer
->	O
next	pointer
;	O
if	O
(	O
j	int
>	O
obj	pointer
->	O
num_xdata	int
)	O
break	O
;	O
if	O
(	O
dat	pointer
->	O
byte	char
-	O
start	struct
>=	O
(	O
unsigned	O
long	O
)	O
num_databytes	int
)	O
break	O
;	O
j	int
++	O
;	O
}	O
if	O
(	O
obj	pointer
->	O
num_databytes	int
!=	O
dat	pointer
->	O
byte	char
-	O
start	struct
)	O
{	O
LOG_WARN	O
(	O
"xdata Written %lu, expected %d"	pointer
,	O
dat	pointer
->	O
byte	char
-	O
start	struct
,	O
obj	pointer
->	O
num_databytes	int
)	O
;	O
obj	pointer
->	O
num_databytes	int
=	O
dat	pointer
->	O
byte	char
-	O
start	struct
;	O
return	O
error	int
?	O
error	int
:	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
encrypt_sat1	function
(	O
BITCODE_BL	int
blocksize	int
,	O
BITCODE_RC	char
*	O
acis_data	pointer
,	O
int	O
*	O
idx	pointer
)	O
{	O
char	O
*	O
encr_sat_data	pointer
=	O
calloc	function
(	O
blocksize	int
,	O
1	int
)	O
;	O
int	O
i	int
=	O
*	O
idx	pointer
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
int	O
)	O
blocksize	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
acis_data	pointer
[	O
j	int
]	O
<=	O
32	int
)	O
encr_sat_data	pointer
[	O
i	int
++	O
]	O
=	O
acis_data	pointer
[	O
j	int
]	O
;	O
else	O
encr_sat_data	pointer
[	O
i	int
++	O
]	O
=	O
acis_data	pointer
[	O
j	int
]	O
-	O
159	int
;	O
}	O
*	O
idx	pointer
=	O
i	int
;	O
return	O
encr_sat_data	pointer
;	O
}	O
