static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_upg_opd.c,v 1.2 2014/04/17 20:27:28 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__db_build_bi	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_FH	struct
*	O
,	O
PAGE	struct
*	O
,	O
PAGE	struct
*	O
,	O
u_int32_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_build_ri	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_FH	struct
*	O
,	O
PAGE	struct
*	O
,	O
PAGE	struct
*	O
,	O
u_int32_t	int
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
__db_up_ovref	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_FH	struct
*	O
,	O
db_pgno_t	int
)	O
)	O
;	O
int	O
CDB___db_31_offdup	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
fhp	pointer
,	O
sorted	int
,	O
pgnop	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
real_name	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
int	O
sorted	int
;	O
db_pgno_t	int
*	O
pgnop	pointer
;	O
{	O
PAGE	struct
*	O
ipage	pointer
,	O
*	O
page	pointer
;	O
db_indx_t	short
indx	short
;	O
db_pgno_t	int
cur_cnt	int
,	O
i	int
,	O
next_cnt	int
,	O
pgno	int
,	O
*	O
pgno_cur	pointer
,	O
pgno_last	int
;	O
db_pgno_t	int
*	O
pgno_next	pointer
,	O
pgno_max	int
,	O
*	O
tmp	pointer
;	O
db_recno_t	int
nrecs	int
;	O
size_t	long
n	long
;	O
int	O
level	char
,	O
nomem	int
,	O
ret	int
;	O
ipage	pointer
=	O
page	pointer
=	O
NULL	O
;	O
pgno_cur	pointer
=	O
pgno_next	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
for	O
(	O
nrecs	int
=	O
0	int
,	O
cur_cnt	int
=	O
pgno_max	int
=	O
0	int
,	O
pgno	int
=	O
*	O
pgnop	pointer
;	O
pgno	int
!=	O
PGNO_INVALID	int
;	O
)	O
{	O
if	O
(	O
pgno_max	int
==	O
cur_cnt	int
)	O
{	O
pgno_max	int
+=	O
20	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_realloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
pgno_max	int
*	O
sizeof	O
(	O
db_pgno_t	int
)	O
,	O
NULL	O
,	O
&	O
pgno_cur	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
pgno_cur	pointer
[	O
cur_cnt	int
++	O
]	O
=	O
pgno	int
;	O
GET_PAGE	O
(	O
dbp	pointer
,	O
fhp	pointer
,	O
pgno	int
,	O
page	pointer
)	O
;	O
nrecs	int
+=	O
NUM_ENT	O
(	O
page	pointer
)	O
;	O
LEVEL	O
(	O
page	pointer
)	O
=	O
LEAFLEVEL	int
;	O
TYPE_SET	O
(	O
page	pointer
,	O
sorted	int
?	O
P_LDUP	int
:	O
P_LRECNO	int
)	O
;	O
ZERO_LSN	O
(	O
LSN	O
(	O
page	pointer
)	O
)	O
;	O
PUT_PAGE	O
(	O
dbp	pointer
,	O
fhp	pointer
,	O
pgno	int
,	O
page	pointer
)	O
;	O
pgno	int
=	O
NEXT_PGNO	O
(	O
page	pointer
)	O
;	O
}	O
if	O
(	O
cur_cnt	int
>	O
1	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
cur_cnt	int
*	O
sizeof	O
(	O
db_pgno_t	int
)	O
,	O
NULL	O
,	O
&	O
pgno_next	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lastpgno	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
fhp	pointer
,	O
&	O
pgno_last	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
ipage	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
PGNO	O
(	O
ipage	pointer
)	O
=	O
PGNO_INVALID	int
;	O
}	O
for	O
(	O
level	char
=	O
LEAFLEVEL	int
+	O
1	int
;	O
cur_cnt	int
>	O
1	int
;	O
++	O
level	char
)	O
{	O
for	O
(	O
indx	short
=	O
0	int
,	O
i	int
=	O
next_cnt	int
=	O
0	int
;	O
i	int
<	O
cur_cnt	int
;	O
)	O
{	O
if	O
(	O
indx	short
==	O
0	int
)	O
{	O
P_INIT	O
(	O
ipage	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
pgno_last	int
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
level	char
,	O
sorted	int
?	O
P_IBTREE	int
:	O
P_IRECNO	int
,	O
0	int
)	O
;	O
ZERO_LSN	O
(	O
LSN	O
(	O
ipage	pointer
)	O
)	O
;	O
pgno_next	pointer
[	O
next_cnt	int
++	O
]	O
=	O
pgno_last	int
++	O
;	O
}	O
GET_PAGE	O
(	O
dbp	pointer
,	O
fhp	pointer
,	O
pgno_cur	pointer
[	O
i	int
]	O
,	O
page	pointer
)	O
;	O
nomem	int
=	O
0	int
;	O
if	O
(	O
sorted	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
__db_build_bi	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
ipage	pointer
,	O
page	pointer
,	O
indx	short
,	O
&	O
nomem	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
__db_build_ri	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
ipage	pointer
,	O
page	pointer
,	O
indx	short
,	O
&	O
nomem	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
nomem	int
)	O
{	O
indx	short
=	O
0	int
;	O
PUT_PAGE	O
(	O
dbp	pointer
,	O
fhp	pointer
,	O
PGNO	O
(	O
ipage	pointer
)	O
,	O
ipage	pointer
)	O
;	O
}	O
else	O
{	O
++	O
indx	short
;	O
++	O
NUM_ENT	O
(	O
ipage	pointer
)	O
;	O
++	O
i	int
;	O
}	O
}	O
if	O
(	O
next_cnt	int
==	O
1	int
)	O
RE_NREC_SET	O
(	O
ipage	pointer
,	O
nrecs	int
)	O
;	O
PUT_PAGE	O
(	O
dbp	pointer
,	O
fhp	pointer
,	O
PGNO	O
(	O
ipage	pointer
)	O
,	O
ipage	pointer
)	O
;	O
cur_cnt	int
=	O
next_cnt	int
;	O
tmp	pointer
=	O
pgno_cur	pointer
;	O
pgno_cur	pointer
=	O
pgno_next	pointer
;	O
pgno_next	pointer
=	O
tmp	pointer
;	O
}	O
*	O
pgnop	pointer
=	O
pgno_cur	pointer
[	O
0	int
]	O
;	O
err	pointer
:	O
if	O
(	O
pgno_cur	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
pgno_cur	pointer
,	O
0	int
)	O
;	O
if	O
(	O
pgno_next	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
pgno_next	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ipage	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
ipage	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
if	O
(	O
page	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__db_build_bi	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
ipage	pointer
,	O
page	pointer
,	O
indx	short
,	O
nomemp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
PAGE	struct
*	O
ipage	pointer
,	O
*	O
page	pointer
;	O
u_int32_t	int
indx	short
;	O
int	O
*	O
nomemp	pointer
;	O
{	O
BINTERNAL	struct
bi	struct
,	O
*	O
child_bi	pointer
;	O
BKEYDATA	struct
*	O
child_bk	pointer
;	O
u_int8_t	char
*	O
p	pointer
;	O
int	O
ret	int
;	O
switch	O
(	O
TYPE	O
(	O
page	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
child_bi	pointer
=	O
GET_BINTERNAL	O
(	O
page	pointer
,	O
0	int
)	O
;	O
if	O
(	O
P_FREESPACE	O
(	O
ipage	pointer
)	O
<	O
BINTERNAL_PSIZE	O
(	O
child_bi	pointer
->	O
len	short
)	O
)	O
{	O
*	O
nomemp	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
ipage	pointer
->	O
inp	array
[	O
indx	short
]	O
=	O
HOFFSET	O
(	O
ipage	pointer
)	O
-=	O
BINTERNAL_SIZE	O
(	O
child_bi	pointer
->	O
len	short
)	O
;	O
p	pointer
=	O
P_ENTRY	O
(	O
ipage	pointer
,	O
indx	short
)	O
;	O
bi	struct
.	O
len	short
=	O
child_bi	pointer
->	O
len	short
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bi	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
PGNO	O
(	O
page	pointer
)	O
;	O
bi	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
page	pointer
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
&	O
bi	struct
,	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
)	O
;	O
p	pointer
+=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
child_bi	pointer
->	O
data	pointer
,	O
child_bi	pointer
->	O
len	short
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
child_bi	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
if	O
(	O
(	O
ret	int
=	O
__db_up_ovref	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
(	O
(	O
BOVERFLOW	struct
*	O
)	O
(	O
child_bi	pointer
->	O
data	pointer
)	O
)	O
->	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
P_LDUP	int
:	O
child_bk	pointer
=	O
GET_BKEYDATA	O
(	O
page	pointer
,	O
0	int
)	O
;	O
switch	O
(	O
B_TYPE	O
(	O
child_bk	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
if	O
(	O
P_FREESPACE	O
(	O
ipage	pointer
)	O
<	O
BINTERNAL_PSIZE	O
(	O
child_bk	pointer
->	O
len	short
)	O
)	O
{	O
*	O
nomemp	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
ipage	pointer
->	O
inp	array
[	O
indx	short
]	O
=	O
HOFFSET	O
(	O
ipage	pointer
)	O
-=	O
BINTERNAL_SIZE	O
(	O
child_bk	pointer
->	O
len	short
)	O
;	O
p	pointer
=	O
P_ENTRY	O
(	O
ipage	pointer
,	O
indx	short
)	O
;	O
bi	struct
.	O
len	short
=	O
child_bk	pointer
->	O
len	short
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bk	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
PGNO	O
(	O
page	pointer
)	O
;	O
bi	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
page	pointer
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
&	O
bi	struct
,	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
)	O
;	O
p	pointer
+=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
child_bk	pointer
->	O
data	pointer
,	O
child_bk	pointer
->	O
len	short
)	O
;	O
break	O
;	O
case	O
B_OVERFLOW	int
:	O
if	O
(	O
P_FREESPACE	O
(	O
ipage	pointer
)	O
<	O
BINTERNAL_PSIZE	O
(	O
BOVERFLOW_SIZE	O
)	O
)	O
{	O
*	O
nomemp	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
ipage	pointer
->	O
inp	array
[	O
indx	short
]	O
=	O
HOFFSET	O
(	O
ipage	pointer
)	O
-=	O
BINTERNAL_SIZE	O
(	O
BOVERFLOW_SIZE	O
)	O
;	O
p	pointer
=	O
P_ENTRY	O
(	O
ipage	pointer
,	O
indx	short
)	O
;	O
bi	struct
.	O
len	short
=	O
BOVERFLOW_SIZE	O
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bk	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
PGNO	O
(	O
page	pointer
)	O
;	O
bi	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
page	pointer
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
&	O
bi	struct
,	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
)	O
;	O
p	pointer
+=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
child_bk	pointer
,	O
BOVERFLOW_SIZE	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__db_up_ovref	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
(	O
(	O
BOVERFLOW	struct
*	O
)	O
child_bk	pointer
)	O
->	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
page	pointer
)	O
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
page	pointer
)	O
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_build_ri	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
ipage	pointer
,	O
page	pointer
,	O
indx	short
,	O
nomemp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
PAGE	struct
*	O
ipage	pointer
,	O
*	O
page	pointer
;	O
u_int32_t	int
indx	short
;	O
int	O
*	O
nomemp	pointer
;	O
{	O
if	O
(	O
dbp	pointer
||	O
fhp	pointer
)	O
{	O
}	O
RINTERNAL	struct
ri	struct
;	O
COMPQUIET	O
(	O
dbp	pointer
,	O
NULL	O
)	O
;	O
COMPQUIET	O
(	O
fhp	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
P_FREESPACE	O
(	O
ipage	pointer
)	O
<	O
RINTERNAL_PSIZE	O
)	O
{	O
*	O
nomemp	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
ri	struct
.	O
pgno	int
=	O
PGNO	O
(	O
page	pointer
)	O
;	O
ri	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
page	pointer
)	O
;	O
ipage	pointer
->	O
inp	array
[	O
indx	short
]	O
=	O
HOFFSET	O
(	O
ipage	pointer
)	O
-=	O
RINTERNAL_SIZE	O
;	O
memcpy	function
(	O
P_ENTRY	O
(	O
ipage	pointer
,	O
indx	short
)	O
,	O
&	O
ri	struct
,	O
RINTERNAL_SIZE	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__db_up_ovref	function
(	O
dbp	pointer
,	O
fhp	pointer
,	O
pgno	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
db_pgno_t	int
pgno	int
;	O
{	O
PAGE	struct
*	O
page	pointer
;	O
size_t	long
n	long
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
page	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
GET_PAGE	O
(	O
dbp	pointer
,	O
fhp	pointer
,	O
pgno	int
,	O
page	pointer
)	O
;	O
++	O
OV_REF	O
(	O
page	pointer
)	O
;	O
PUT_PAGE	O
(	O
dbp	pointer
,	O
fhp	pointer
,	O
pgno	int
,	O
page	pointer
)	O
;	O
err	pointer
:	O
CDB___os_free	function
(	O
page	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
