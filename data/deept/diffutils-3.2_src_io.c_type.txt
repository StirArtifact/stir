typedef	O
size_t	long
hash_value	long
;	O
verify	O
(	O
!	O
TYPE_SIGNED	O
(	O
hash_value	long
)	O
)	O
;	O
struct	O
equivclass	struct
{	O
lin	long
next	long
;	O
hash_value	long
hash	long
;	O
char	O
const	O
*	O
line	pointer
;	O
size_t	long
length	long
;	O
}	O
;	O
static	O
lin	long
*	O
buckets	pointer
;	O
static	O
size_t	long
nbuckets	long
;	O
static	O
struct	O
equivclass	struct
*	O
equivs	pointer
;	O
static	O
lin	long
equivs_index	long
;	O
static	O
lin	long
equivs_alloc	long
;	O
void	O
file_block_read	function
(	O
struct	O
file_data	struct
*	O
current	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
size	long
&&	O
!	O
current	pointer
->	O
eof	bool
)	O
{	O
size_t	long
s	long
=	O
block_read	function
(	O
current	pointer
->	O
desc	int
,	O
FILE_BUFFER	O
(	O
current	pointer
)	O
+	O
current	pointer
->	O
buffered	long
,	O
size	long
)	O
;	O
if	O
(	O
s	long
==	O
SIZE_MAX	O
)	O
pfatal_with_name	function
(	O
current	pointer
->	O
name	pointer
)	O
;	O
current	pointer
->	O
buffered	long
+=	O
s	long
;	O
current	pointer
->	O
eof	bool
=	O
s	long
<	O
size	long
;	O
}	O
}	O
static	O
bool	bool
sip	function
(	O
struct	O
file_data	struct
*	O
current	pointer
,	O
bool	bool
skip_test	bool
)	O
{	O
if	O
(	O
current	pointer
->	O
desc	int
<	O
0	int
)	O
{	O
current	pointer
->	O
bufsize	long
=	O
sizeof	O
(	O
word	O
)	O
;	O
current	pointer
->	O
buffer	pointer
=	O
xmalloc	function
(	O
current	pointer
->	O
bufsize	long
)	O
;	O
}	O
else	O
{	O
current	pointer
->	O
bufsize	long
=	O
buffer_lcm	function
(	O
sizeof	O
(	O
word	O
)	O
,	O
STAT_BLOCKSIZE	O
(	O
current	pointer
->	O
stat	struct
)	O
,	O
PTRDIFF_MAX	O
-	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
)	O
;	O
current	pointer
->	O
buffer	pointer
=	O
xmalloc	function
(	O
current	pointer
->	O
bufsize	long
)	O
;	O
if	O
(	O
!	O
skip_test	bool
)	O
{	O
file_block_read	function
(	O
current	pointer
,	O
current	pointer
->	O
bufsize	long
)	O
;	O
return	O
binary_file_p	O
(	O
current	pointer
->	O
buffer	pointer
,	O
current	pointer
->	O
buffered	long
)	O
;	O
}	O
}	O
current	pointer
->	O
buffered	long
=	O
0	int
;	O
current	pointer
->	O
eof	bool
=	O
false	int
;	O
return	O
false	int
;	O
}	O
static	O
void	O
slurp	function
(	O
struct	O
file_data	struct
*	O
current	pointer
)	O
{	O
size_t	long
cc	long
;	O
if	O
(	O
current	pointer
->	O
desc	int
<	O
0	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
S_ISREG	O
(	O
current	pointer
->	O
stat	struct
.	O
st_mode	int
)	O
)	O
{	O
size_t	long
file_size	long
=	O
current	pointer
->	O
stat	struct
.	O
st_size	long
;	O
cc	long
=	O
file_size	long
+	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
-	O
file_size	long
%	O
sizeof	O
(	O
word	O
)	O
;	O
if	O
(	O
file_size	long
!=	O
current	pointer
->	O
stat	struct
.	O
st_size	long
||	O
cc	long
<	O
file_size	long
||	O
PTRDIFF_MAX	O
<=	O
cc	long
)	O
xalloc_die	function
(	O
)	O
;	O
if	O
(	O
current	pointer
->	O
bufsize	long
<	O
cc	long
)	O
{	O
current	pointer
->	O
bufsize	long
=	O
cc	long
;	O
current	pointer
->	O
buffer	pointer
=	O
xrealloc	function
(	O
current	pointer
->	O
buffer	pointer
,	O
cc	long
)	O
;	O
}	O
if	O
(	O
current	pointer
->	O
buffered	long
<=	O
file_size	long
)	O
{	O
file_block_read	function
(	O
current	pointer
,	O
file_size	long
+	O
1	int
-	O
current	pointer
->	O
buffered	long
)	O
;	O
if	O
(	O
current	pointer
->	O
buffered	long
<=	O
file_size	long
)	O
return	O
;	O
}	O
}	O
file_block_read	function
(	O
current	pointer
,	O
current	pointer
->	O
bufsize	long
-	O
current	pointer
->	O
buffered	long
)	O
;	O
if	O
(	O
current	pointer
->	O
buffered	long
)	O
{	O
while	O
(	O
current	pointer
->	O
buffered	long
==	O
current	pointer
->	O
bufsize	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
2	int
-	O
sizeof	O
(	O
word	O
)	O
<	O
current	pointer
->	O
bufsize	long
)	O
xalloc_die	function
(	O
)	O
;	O
current	pointer
->	O
bufsize	long
*=	O
2	int
;	O
current	pointer
->	O
buffer	pointer
=	O
xrealloc	function
(	O
current	pointer
->	O
buffer	pointer
,	O
current	pointer
->	O
bufsize	long
)	O
;	O
file_block_read	function
(	O
current	pointer
,	O
current	pointer
->	O
bufsize	long
-	O
current	pointer
->	O
buffered	long
)	O
;	O
}	O
cc	long
=	O
current	pointer
->	O
buffered	long
+	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
;	O
current	pointer
->	O
bufsize	long
=	O
cc	long
-	O
cc	long
%	O
sizeof	O
(	O
word	O
)	O
;	O
current	pointer
->	O
buffer	pointer
=	O
xrealloc	function
(	O
current	pointer
->	O
buffer	pointer
,	O
current	pointer
->	O
bufsize	long
)	O
;	O
}	O
}	O
static	O
void	O
find_and_hash_each_line	function
(	O
struct	O
file_data	struct
*	O
current	pointer
)	O
{	O
char	O
const	O
*	O
p	pointer
=	O
current	pointer
->	O
prefix_end	pointer
;	O
lin	long
i	long
,	O
*	O
bucket	pointer
;	O
size_t	long
length	long
;	O
char	O
const	O
*	O
*	O
linbuf	pointer
=	O
current	pointer
->	O
linbuf	pointer
;	O
lin	long
alloc_lines	long
=	O
current	pointer
->	O
alloc_lines	long
;	O
lin	long
line	pointer
=	O
0	int
;	O
lin	long
linbuf_base	long
=	O
current	pointer
->	O
linbuf_base	long
;	O
lin	long
*	O
cureqs	pointer
=	O
xmalloc	function
(	O
alloc_lines	long
*	O
sizeof	O
*	O
cureqs	pointer
)	O
;	O
struct	O
equivclass	struct
*	O
eqs	pointer
=	O
equivs	pointer
;	O
lin	long
eqs_index	long
=	O
equivs_index	long
;	O
lin	long
eqs_alloc	long
=	O
equivs_alloc	long
;	O
char	O
const	O
*	O
suffix_begin	pointer
=	O
current	pointer
->	O
suffix_begin	pointer
;	O
char	O
const	O
*	O
bufend	pointer
=	O
FILE_BUFFER	O
(	O
current	pointer
)	O
+	O
current	pointer
->	O
buffered	long
;	O
bool	bool
ig_case	bool
=	O
ignore_case	bool
;	O
enum	O
DIFF_white_space	enum
ig_white_space	enum
=	O
ignore_white_space	enum
;	O
bool	bool
diff_length_compare_anyway	bool
=	O
ig_white_space	enum
!=	O
IGNORE_NO_WHITE_SPACE	int
;	O
bool	bool
same_length_diff_contents_compare_anyway	bool
=	O
diff_length_compare_anyway	bool
|	O
ig_case	bool
;	O
while	O
(	O
p	pointer
<	O
suffix_begin	pointer
)	O
{	O
char	O
const	O
*	O
ip	pointer
=	O
p	pointer
;	O
hash_value	long
h	long
=	O
0	int
;	O
unsigned	O
char	O
c	char
;	O
switch	O
(	O
ig_white_space	enum
)	O
{	O
case	O
IGNORE_ALL_SPACE	int
:	O
while	O
(	O
(	O
c	char
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\n'	O
)	O
if	O
(	O
!	O
isspace	function
(	O
c	char
)	O
)	O
h	long
=	O
HASH	O
(	O
h	long
,	O
ig_case	bool
?	O
tolower	function
(	O
c	char
)	O
:	O
c	char
)	O
;	O
break	O
;	O
case	O
IGNORE_SPACE_CHANGE	int
:	O
while	O
(	O
(	O
c	char
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
isspace	function
(	O
c	char
)	O
)	O
{	O
do	O
if	O
(	O
(	O
c	char
=	O
*	O
p	pointer
++	O
)	O
==	O
'\n'	O
)	O
goto	O
hashing_done	O
;	O
while	O
(	O
isspace	function
(	O
c	char
)	O
)	O
;	O
h	long
=	O
HASH	O
(	O
h	long
,	O
' '	O
)	O
;	O
}	O
h	long
=	O
HASH	O
(	O
h	long
,	O
ig_case	bool
?	O
tolower	function
(	O
c	char
)	O
:	O
c	char
)	O
;	O
}	O
break	O
;	O
case	O
IGNORE_TAB_EXPANSION	int
:	O
case	O
IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE	int
:	O
case	O
IGNORE_TRAILING_SPACE	int
:	O
{	O
size_t	long
column	long
=	O
0	int
;	O
while	O
(	O
(	O
c	char
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
ig_white_space	enum
&	O
IGNORE_TRAILING_SPACE	int
&&	O
isspace	function
(	O
c	char
)	O
)	O
{	O
char	O
const	O
*	O
p1	pointer
=	O
p	pointer
;	O
unsigned	O
char	O
c1	char
;	O
do	O
if	O
(	O
(	O
c1	char
=	O
*	O
p1	pointer
++	O
)	O
==	O
'\n'	O
)	O
{	O
p	pointer
=	O
p1	pointer
;	O
goto	O
hashing_done	O
;	O
}	O
while	O
(	O
isspace	function
(	O
c1	char
)	O
)	O
;	O
}	O
size_t	long
repetitions	long
=	O
1	int
;	O
if	O
(	O
ig_white_space	enum
&	O
IGNORE_TAB_EXPANSION	int
)	O
switch	O
(	O
c	char
)	O
{	O
case	O
'\b'	O
:	O
column	long
-=	O
0	int
<	O
column	long
;	O
break	O
;	O
case	O
'\t'	O
:	O
c	char
=	O
' '	O
;	O
repetitions	long
=	O
tabsize	long
-	O
column	long
%	O
tabsize	long
;	O
column	long
=	O
(	O
column	long
+	O
repetitions	long
<	O
column	long
?	O
0	int
:	O
column	long
+	O
repetitions	long
)	O
;	O
break	O
;	O
case	O
'\r'	O
:	O
column	long
=	O
0	int
;	O
break	O
;	O
default	O
:	O
column	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
ig_case	bool
)	O
c	char
=	O
tolower	function
(	O
c	char
)	O
;	O
do	O
h	long
=	O
HASH	O
(	O
h	long
,	O
c	char
)	O
;	O
while	O
(	O
--	O
repetitions	long
!=	O
0	int
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
ig_case	bool
)	O
while	O
(	O
(	O
c	char
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\n'	O
)	O
h	long
=	O
HASH	O
(	O
h	long
,	O
tolower	function
(	O
c	char
)	O
)	O
;	O
else	O
while	O
(	O
(	O
c	char
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\n'	O
)	O
h	long
=	O
HASH	O
(	O
h	long
,	O
c	char
)	O
;	O
break	O
;	O
}	O
hashing_done	O
:	O
;	O
bucket	pointer
=	O
&	O
buckets	pointer
[	O
h	long
%	O
nbuckets	long
]	O
;	O
length	long
=	O
p	pointer
-	O
ip	pointer
-	O
1	int
;	O
if	O
(	O
p	pointer
==	O
bufend	pointer
&&	O
current	pointer
->	O
missing_newline	bool
&&	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum
)	O
)	O
{	O
if	O
(	O
ig_white_space	enum
<	O
IGNORE_TRAILING_SPACE	int
)	O
bucket	pointer
=	O
&	O
buckets	pointer
[	O
-	O
1	int
]	O
;	O
}	O
for	O
(	O
i	long
=	O
*	O
bucket	pointer
;	O
;	O
i	long
=	O
eqs	pointer
[	O
i	long
]	O
.	O
next	long
)	O
if	O
(	O
!	O
i	long
)	O
{	O
i	long
=	O
eqs_index	long
++	O
;	O
if	O
(	O
i	long
==	O
eqs_alloc	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
(	O
2	int
*	O
sizeof	O
*	O
eqs	pointer
)	O
<=	O
eqs_alloc	long
)	O
xalloc_die	function
(	O
)	O
;	O
eqs_alloc	long
*=	O
2	int
;	O
eqs	pointer
=	O
xrealloc	function
(	O
eqs	pointer
,	O
eqs_alloc	long
*	O
sizeof	O
*	O
eqs	pointer
)	O
;	O
}	O
eqs	pointer
[	O
i	long
]	O
.	O
next	long
=	O
*	O
bucket	pointer
;	O
eqs	pointer
[	O
i	long
]	O
.	O
hash	long
=	O
h	long
;	O
eqs	pointer
[	O
i	long
]	O
.	O
line	pointer
=	O
ip	pointer
;	O
eqs	pointer
[	O
i	long
]	O
.	O
length	long
=	O
length	long
;	O
*	O
bucket	pointer
=	O
i	long
;	O
break	O
;	O
}	O
else	O
if	O
(	O
eqs	pointer
[	O
i	long
]	O
.	O
hash	long
==	O
h	long
)	O
{	O
char	O
const	O
*	O
eqline	pointer
=	O
eqs	pointer
[	O
i	long
]	O
.	O
line	pointer
;	O
if	O
(	O
eqs	pointer
[	O
i	long
]	O
.	O
length	long
==	O
length	long
)	O
{	O
if	O
(	O
memcmp	function
(	O
eqline	pointer
,	O
ip	pointer
,	O
length	long
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
same_length_diff_contents_compare_anyway	bool
)	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
diff_length_compare_anyway	bool
)	O
continue	O
;	O
if	O
(	O
!	O
lines_differ	function
(	O
eqline	pointer
,	O
ip	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
line	pointer
==	O
alloc_lines	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
3	int
<=	O
alloc_lines	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
cureqs	pointer
<=	O
2	int
*	O
alloc_lines	long
-	O
linbuf_base	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
linbuf	pointer
<=	O
alloc_lines	long
-	O
linbuf_base	long
)	O
xalloc_die	function
(	O
)	O
;	O
alloc_lines	long
=	O
2	int
*	O
alloc_lines	long
-	O
linbuf_base	long
;	O
cureqs	pointer
=	O
xrealloc	function
(	O
cureqs	pointer
,	O
alloc_lines	long
*	O
sizeof	O
*	O
cureqs	pointer
)	O
;	O
linbuf	pointer
+=	O
linbuf_base	long
;	O
linbuf	pointer
=	O
xrealloc	function
(	O
linbuf	pointer
,	O
(	O
alloc_lines	long
-	O
linbuf_base	long
)	O
*	O
sizeof	O
*	O
linbuf	pointer
)	O
;	O
linbuf	pointer
-=	O
linbuf_base	long
;	O
}	O
linbuf	pointer
[	O
line	pointer
]	O
=	O
ip	pointer
;	O
cureqs	pointer
[	O
line	pointer
]	O
=	O
i	long
;	O
++	O
line	pointer
;	O
}	O
current	pointer
->	O
buffered_lines	long
=	O
line	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
line	pointer
==	O
alloc_lines	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
3	int
<=	O
alloc_lines	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
cureqs	pointer
<=	O
2	int
*	O
alloc_lines	long
-	O
linbuf_base	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
linbuf	pointer
<=	O
alloc_lines	long
-	O
linbuf_base	long
)	O
xalloc_die	function
(	O
)	O
;	O
alloc_lines	long
=	O
2	int
*	O
alloc_lines	long
-	O
linbuf_base	long
;	O
linbuf	pointer
+=	O
linbuf_base	long
;	O
linbuf	pointer
=	O
xrealloc	function
(	O
linbuf	pointer
,	O
(	O
alloc_lines	long
-	O
linbuf_base	long
)	O
*	O
sizeof	O
*	O
linbuf	pointer
)	O
;	O
linbuf	pointer
-=	O
linbuf_base	long
;	O
}	O
linbuf	pointer
[	O
line	pointer
]	O
=	O
p	pointer
;	O
if	O
(	O
p	pointer
==	O
bufend	pointer
)	O
{	O
if	O
(	O
current	pointer
->	O
missing_newline	bool
&&	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum
)	O
)	O
linbuf	pointer
[	O
line	pointer
]	O
--	O
;	O
break	O
;	O
}	O
if	O
(	O
context	long
<=	O
i	long
&&	O
no_diff_means_no_output	bool
)	O
break	O
;	O
line	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
++	O
!=	O
'\n'	O
)	O
continue	O
;	O
}	O
current	pointer
->	O
linbuf	pointer
=	O
linbuf	pointer
;	O
current	pointer
->	O
valid_lines	long
=	O
line	pointer
;	O
current	pointer
->	O
alloc_lines	long
=	O
alloc_lines	long
;	O
current	pointer
->	O
equivs	pointer
=	O
cureqs	pointer
;	O
equivs	pointer
=	O
eqs	pointer
;	O
equivs_alloc	long
=	O
eqs_alloc	long
;	O
equivs_index	long
=	O
eqs_index	long
;	O
}	O
static	O
void	O
prepare_text	function
(	O
struct	O
file_data	struct
*	O
current	pointer
)	O
{	O
size_t	long
buffered	long
=	O
current	pointer
->	O
buffered	long
;	O
char	O
*	O
p	pointer
=	O
FILE_BUFFER	O
(	O
current	pointer
)	O
;	O
char	O
*	O
dst	pointer
;	O
if	O
(	O
buffered	long
==	O
0	int
||	O
p	pointer
[	O
buffered	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
current	pointer
->	O
missing_newline	bool
=	O
false	int
;	O
else	O
{	O
p	pointer
[	O
buffered	long
++	O
]	O
=	O
'\n'	O
;	O
current	pointer
->	O
missing_newline	bool
=	O
true	int
;	O
}	O
if	O
(	O
!	O
p	pointer
)	O
return	O
;	O
memset	function
(	O
p	pointer
+	O
buffered	long
,	O
0	int
,	O
sizeof	O
(	O
word	O
)	O
)	O
;	O
if	O
(	O
strip_trailing_cr	bool
&&	O
(	O
dst	pointer
=	O
memchr	function
(	O
p	pointer
,	O
'\r'	O
,	O
buffered	long
)	O
)	O
)	O
{	O
char	O
const	O
*	O
src	pointer
=	O
dst	pointer
;	O
char	O
const	O
*	O
srclim	pointer
=	O
p	pointer
+	O
buffered	long
;	O
do	O
dst	pointer
+=	O
!	O
(	O
(	O
*	O
dst	pointer
=	O
*	O
src	pointer
++	O
)	O
==	O
'\r'	O
&&	O
*	O
src	pointer
==	O
'\n'	O
)	O
;	O
while	O
(	O
src	pointer
<	O
srclim	pointer
)	O
;	O
buffered	long
-=	O
src	pointer
-	O
dst	pointer
;	O
}	O
current	pointer
->	O
buffered	long
=	O
buffered	long
;	O
}	O
static	O
lin	long
guess_lines	function
(	O
lin	long
n	long
,	O
size_t	long
s	long
,	O
size_t	long
t	long
)	O
{	O
size_t	long
guessed_bytes_per_line	long
=	O
n	long
<	O
10	int
?	O
32	int
:	O
s	long
/	O
(	O
n	long
-	O
1	int
)	O
;	O
lin	long
guessed_lines	long
=	O
MAX	O
(	O
1	int
,	O
t	long
/	O
guessed_bytes_per_line	long
)	O
;	O
return	O
MIN	O
(	O
guessed_lines	long
,	O
PTRDIFF_MAX	O
/	O
(	O
2	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
+	O
1	int
)	O
-	O
5	int
)	O
+	O
5	int
;	O
}	O
static	O
void	O
find_identical_ends	function
(	O
struct	O
file_data	struct
filevec	array
[	O
]	O
)	O
{	O
word	O
*	O
w0	pointer
,	O
*	O
w1	pointer
;	O
char	O
*	O
p0	pointer
,	O
*	O
p1	pointer
,	O
*	O
buffer0	pointer
,	O
*	O
buffer1	pointer
;	O
char	O
const	O
*	O
end0	pointer
,	O
*	O
beg0	pointer
;	O
char	O
const	O
*	O
*	O
linbuf0	pointer
,	O
*	O
*	O
linbuf1	pointer
;	O
lin	long
i	long
,	O
lines	long
;	O
size_t	long
n0	long
,	O
n1	long
;	O
lin	long
alloc_lines0	long
,	O
alloc_lines1	long
;	O
lin	long
buffered_prefix	long
,	O
prefix_count	long
,	O
prefix_mask	long
;	O
lin	long
middle_guess	long
,	O
suffix_guess	long
;	O
slurp	function
(	O
&	O
filevec	array
[	O
0	int
]	O
)	O
;	O
prepare_text	function
(	O
&	O
filevec	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
filevec	array
[	O
0	int
]	O
.	O
desc	int
!=	O
filevec	array
[	O
1	int
]	O
.	O
desc	int
)	O
{	O
slurp	function
(	O
&	O
filevec	array
[	O
1	int
]	O
)	O
;	O
prepare_text	function
(	O
&	O
filevec	array
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
filevec	array
[	O
1	int
]	O
.	O
buffer	pointer
=	O
filevec	array
[	O
0	int
]	O
.	O
buffer	pointer
;	O
filevec	array
[	O
1	int
]	O
.	O
bufsize	long
=	O
filevec	array
[	O
0	int
]	O
.	O
bufsize	long
;	O
filevec	array
[	O
1	int
]	O
.	O
buffered	long
=	O
filevec	array
[	O
0	int
]	O
.	O
buffered	long
;	O
filevec	array
[	O
1	int
]	O
.	O
missing_newline	bool
=	O
filevec	array
[	O
0	int
]	O
.	O
missing_newline	bool
;	O
}	O
w0	pointer
=	O
filevec	array
[	O
0	int
]	O
.	O
buffer	pointer
;	O
w1	pointer
=	O
filevec	array
[	O
1	int
]	O
.	O
buffer	pointer
;	O
p0	pointer
=	O
buffer0	pointer
=	O
(	O
char	O
*	O
)	O
w0	pointer
;	O
p1	pointer
=	O
buffer1	pointer
=	O
(	O
char	O
*	O
)	O
w1	pointer
;	O
n0	long
=	O
filevec	array
[	O
0	int
]	O
.	O
buffered	long
;	O
n1	long
=	O
filevec	array
[	O
1	int
]	O
.	O
buffered	long
;	O
if	O
(	O
p0	pointer
==	O
p1	pointer
)	O
p0	pointer
=	O
p1	pointer
+=	O
n1	long
;	O
else	O
{	O
if	O
(	O
n0	long
<	O
n1	long
)	O
p0	pointer
[	O
n0	long
]	O
=	O
~	O
p1	pointer
[	O
n0	long
]	O
;	O
else	O
p1	pointer
[	O
n1	long
]	O
=	O
~	O
p0	pointer
[	O
n1	long
]	O
;	O
while	O
(	O
*	O
w0	pointer
==	O
*	O
w1	pointer
)	O
w0	pointer
++	O
,	O
w1	pointer
++	O
;	O
p0	pointer
=	O
(	O
char	O
*	O
)	O
w0	pointer
;	O
p1	pointer
=	O
(	O
char	O
*	O
)	O
w1	pointer
;	O
while	O
(	O
*	O
p0	pointer
==	O
*	O
p1	pointer
)	O
p0	pointer
++	O
,	O
p1	pointer
++	O
;	O
if	O
(	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum
)	O
&&	O
(	O
(	O
buffer0	pointer
+	O
n0	long
-	O
filevec	array
[	O
0	int
]	O
.	O
missing_newline	bool
<	O
p0	pointer
)	O
!=	O
(	O
buffer1	pointer
+	O
n1	long
-	O
filevec	array
[	O
1	int
]	O
.	O
missing_newline	bool
<	O
p1	pointer
)	O
)	O
)	O
p0	pointer
--	O
,	O
p1	pointer
--	O
;	O
}	O
i	long
=	O
horizon_lines	long
;	O
while	O
(	O
p0	pointer
!=	O
buffer0	pointer
&&	O
(	O
p0	pointer
[	O
-	O
1	int
]	O
!=	O
'\n'	O
||	O
i	long
--	O
)	O
)	O
p0	pointer
--	O
,	O
p1	pointer
--	O
;	O
filevec	array
[	O
0	int
]	O
.	O
prefix_end	pointer
=	O
p0	pointer
;	O
filevec	array
[	O
1	int
]	O
.	O
prefix_end	pointer
=	O
p1	pointer
;	O
p0	pointer
=	O
buffer0	pointer
+	O
n0	long
;	O
p1	pointer
=	O
buffer1	pointer
+	O
n1	long
;	O
if	O
(	O
!	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum
)	O
||	O
filevec	array
[	O
0	int
]	O
.	O
missing_newline	bool
==	O
filevec	array
[	O
1	int
]	O
.	O
missing_newline	bool
)	O
{	O
end0	pointer
=	O
p0	pointer
;	O
beg0	pointer
=	O
filevec	array
[	O
0	int
]	O
.	O
prefix_end	pointer
+	O
(	O
n0	long
<	O
n1	long
?	O
0	int
:	O
n0	long
-	O
n1	long
)	O
;	O
while	O
(	O
p0	pointer
!=	O
beg0	pointer
)	O
if	O
(	O
*	O
--	O
p0	pointer
!=	O
*	O
--	O
p1	pointer
)	O
{	O
++	O
p0	pointer
,	O
++	O
p1	pointer
;	O
beg0	pointer
=	O
p0	pointer
;	O
break	O
;	O
}	O
i	long
=	O
horizon_lines	long
+	O
!	O
(	O
(	O
buffer0	pointer
==	O
p0	pointer
||	O
p0	pointer
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
&&	O
(	O
buffer1	pointer
==	O
p1	pointer
||	O
p1	pointer
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
)	O
;	O
while	O
(	O
i	long
--	O
&&	O
p0	pointer
!=	O
end0	pointer
)	O
while	O
(	O
*	O
p0	pointer
++	O
!=	O
'\n'	O
)	O
continue	O
;	O
p1	pointer
+=	O
p0	pointer
-	O
beg0	pointer
;	O
}	O
filevec	array
[	O
0	int
]	O
.	O
suffix_begin	pointer
=	O
p0	pointer
;	O
filevec	array
[	O
1	int
]	O
.	O
suffix_begin	pointer
=	O
p1	pointer
;	O
if	O
(	O
no_diff_means_no_output	bool
&&	O
!	O
function_regexp	struct
.	O
fastmap	pointer
&&	O
context	long
<	O
LIN_MAX	O
/	O
4	int
&&	O
context	long
<	O
n0	long
)	O
{	O
middle_guess	long
=	O
guess_lines	function
(	O
0	int
,	O
0	int
,	O
p0	pointer
-	O
filevec	array
[	O
0	int
]	O
.	O
prefix_end	pointer
)	O
;	O
suffix_guess	long
=	O
guess_lines	function
(	O
0	int
,	O
0	int
,	O
buffer0	pointer
+	O
n0	long
-	O
p0	pointer
)	O
;	O
for	O
(	O
prefix_count	long
=	O
1	int
;	O
prefix_count	long
<=	O
context	long
;	O
prefix_count	long
*=	O
2	int
)	O
continue	O
;	O
alloc_lines0	long
=	O
(	O
prefix_count	long
+	O
middle_guess	long
+	O
MIN	O
(	O
context	long
,	O
suffix_guess	long
)	O
)	O
;	O
}	O
else	O
{	O
prefix_count	long
=	O
0	int
;	O
alloc_lines0	long
=	O
guess_lines	function
(	O
0	int
,	O
0	int
,	O
n0	long
)	O
;	O
}	O
prefix_mask	long
=	O
prefix_count	long
-	O
1	int
;	O
lines	long
=	O
0	int
;	O
linbuf0	pointer
=	O
xmalloc	function
(	O
alloc_lines0	long
*	O
sizeof	O
*	O
linbuf0	pointer
)	O
;	O
p0	pointer
=	O
buffer0	pointer
;	O
if	O
(	O
!	O
(	O
no_diff_means_no_output	bool
&&	O
filevec	array
[	O
0	int
]	O
.	O
prefix_end	pointer
==	O
p0	pointer
&&	O
filevec	array
[	O
1	int
]	O
.	O
prefix_end	pointer
==	O
p1	pointer
)	O
)	O
{	O
end0	pointer
=	O
filevec	array
[	O
0	int
]	O
.	O
prefix_end	pointer
;	O
while	O
(	O
p0	pointer
!=	O
end0	pointer
)	O
{	O
lin	long
l	long
=	O
lines	long
++	O
&	O
prefix_mask	long
;	O
if	O
(	O
l	long
==	O
alloc_lines0	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
(	O
2	int
*	O
sizeof	O
*	O
linbuf0	pointer
)	O
<=	O
alloc_lines0	long
)	O
xalloc_die	function
(	O
)	O
;	O
alloc_lines0	long
*=	O
2	int
;	O
linbuf0	pointer
=	O
xrealloc	function
(	O
linbuf0	pointer
,	O
alloc_lines0	long
*	O
sizeof	O
*	O
linbuf0	pointer
)	O
;	O
}	O
linbuf0	pointer
[	O
l	long
]	O
=	O
p0	pointer
;	O
while	O
(	O
*	O
p0	pointer
++	O
!=	O
'\n'	O
)	O
continue	O
;	O
}	O
}	O
buffered_prefix	long
=	O
prefix_count	long
&&	O
context	long
<	O
lines	long
?	O
context	long
:	O
lines	long
;	O
middle_guess	long
=	O
guess_lines	function
(	O
lines	long
,	O
p0	pointer
-	O
buffer0	pointer
,	O
p1	pointer
-	O
filevec	array
[	O
1	int
]	O
.	O
prefix_end	pointer
)	O
;	O
suffix_guess	long
=	O
guess_lines	function
(	O
lines	long
,	O
p0	pointer
-	O
buffer0	pointer
,	O
buffer1	pointer
+	O
n1	long
-	O
p1	pointer
)	O
;	O
alloc_lines1	long
=	O
buffered_prefix	long
+	O
middle_guess	long
+	O
MIN	O
(	O
context	long
,	O
suffix_guess	long
)	O
;	O
if	O
(	O
alloc_lines1	long
<	O
buffered_prefix	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
linbuf1	pointer
<=	O
alloc_lines1	long
)	O
xalloc_die	function
(	O
)	O
;	O
linbuf1	pointer
=	O
xmalloc	function
(	O
alloc_lines1	long
*	O
sizeof	O
*	O
linbuf1	pointer
)	O
;	O
if	O
(	O
buffered_prefix	long
!=	O
lines	long
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
buffered_prefix	long
;	O
i	long
++	O
)	O
linbuf1	pointer
[	O
i	long
]	O
=	O
linbuf0	pointer
[	O
(	O
lines	long
-	O
context	long
+	O
i	long
)	O
&	O
prefix_mask	long
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
buffered_prefix	long
;	O
i	long
++	O
)	O
linbuf0	pointer
[	O
i	long
]	O
=	O
linbuf1	pointer
[	O
i	long
]	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
buffered_prefix	long
;	O
i	long
++	O
)	O
linbuf1	pointer
[	O
i	long
]	O
=	O
linbuf0	pointer
[	O
i	long
]	O
-	O
buffer0	pointer
+	O
buffer1	pointer
;	O
filevec	array
[	O
0	int
]	O
.	O
linbuf	pointer
=	O
linbuf0	pointer
+	O
buffered_prefix	long
;	O
filevec	array
[	O
1	int
]	O
.	O
linbuf	pointer
=	O
linbuf1	pointer
+	O
buffered_prefix	long
;	O
filevec	array
[	O
0	int
]	O
.	O
linbuf_base	long
=	O
filevec	array
[	O
1	int
]	O
.	O
linbuf_base	long
=	O
-	O
buffered_prefix	long
;	O
filevec	array
[	O
0	int
]	O
.	O
alloc_lines	long
=	O
alloc_lines0	long
-	O
buffered_prefix	long
;	O
filevec	array
[	O
1	int
]	O
.	O
alloc_lines	long
=	O
alloc_lines1	long
-	O
buffered_prefix	long
;	O
filevec	array
[	O
0	int
]	O
.	O
prefix_lines	long
=	O
filevec	array
[	O
1	int
]	O
.	O
prefix_lines	long
=	O
lines	long
;	O
}	O
static	O
unsigned	O
char	O
const	O
prime_offset	array
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
5	int
,	O
3	int
,	O
3	int
,	O
9	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
19	int
,	O
15	int
,	O
1	int
,	O
5	int
,	O
1	int
,	O
3	int
,	O
9	int
,	O
3	int
,	O
15	int
,	O
3	int
,	O
39	int
,	O
5	int
,	O
39	int
,	O
57	int
,	O
3	int
,	O
35	int
,	O
1	int
,	O
5	int
,	O
9	int
,	O
41	int
,	O
31	int
,	O
5	int
,	O
25	int
,	O
45	int
,	O
7	int
,	O
87	int
,	O
21	int
,	O
11	int
,	O
57	int
,	O
17	int
,	O
55	int
,	O
21	int
,	O
115	int
,	O
59	int
,	O
81	int
,	O
27	int
,	O
129	int
,	O
47	int
,	O
111	int
,	O
33	int
,	O
55	int
,	O
5	int
,	O
13	int
,	O
27	int
,	O
55	int
,	O
93	int
,	O
1	int
,	O
57	int
,	O
25	int
}	O
;	O
verify	O
(	O
sizeof	O
(	O
size_t	long
)	O
*	O
CHAR_BIT	O
<=	O
sizeof	O
prime_offset	array
)	O
;	O
bool	bool
read_files	function
(	O
struct	O
file_data	struct
filevec	array
[	O
]	O
,	O
bool	bool
pretend_binary	bool
)	O
{	O
int	O
i	long
;	O
bool	bool
skip_test	bool
=	O
text	bool
|	O
pretend_binary	bool
;	O
bool	bool
appears_binary	bool
=	O
pretend_binary	bool
|	O
sip	function
(	O
&	O
filevec	array
[	O
0	int
]	O
,	O
skip_test	bool
)	O
;	O
if	O
(	O
filevec	array
[	O
0	int
]	O
.	O
desc	int
!=	O
filevec	array
[	O
1	int
]	O
.	O
desc	int
)	O
appears_binary	bool
|=	O
sip	function
(	O
&	O
filevec	array
[	O
1	int
]	O
,	O
skip_test	bool
|	O
appears_binary	bool
)	O
;	O
else	O
{	O
filevec	array
[	O
1	int
]	O
.	O
buffer	pointer
=	O
filevec	array
[	O
0	int
]	O
.	O
buffer	pointer
;	O
filevec	array
[	O
1	int
]	O
.	O
bufsize	long
=	O
filevec	array
[	O
0	int
]	O
.	O
bufsize	long
;	O
filevec	array
[	O
1	int
]	O
.	O
buffered	long
=	O
filevec	array
[	O
0	int
]	O
.	O
buffered	long
;	O
}	O
if	O
(	O
appears_binary	bool
)	O
{	O
return	O
true	int
;	O
}	O
find_identical_ends	function
(	O
filevec	array
)	O
;	O
equivs_alloc	long
=	O
filevec	array
[	O
0	int
]	O
.	O
alloc_lines	long
+	O
filevec	array
[	O
1	int
]	O
.	O
alloc_lines	long
+	O
1	int
;	O
if	O
(	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
equivs	pointer
<=	O
equivs_alloc	long
)	O
xalloc_die	function
(	O
)	O
;	O
equivs	pointer
=	O
xmalloc	function
(	O
equivs_alloc	long
*	O
sizeof	O
*	O
equivs	pointer
)	O
;	O
equivs_index	long
=	O
1	int
;	O
for	O
(	O
i	long
=	O
9	int
;	O
(	O
size_t	long
)	O
1	int
<<	O
i	long
<	O
equivs_alloc	long
/	O
3	int
;	O
i	long
++	O
)	O
continue	O
;	O
nbuckets	long
=	O
(	O
(	O
size_t	long
)	O
1	int
<<	O
i	long
)	O
-	O
prime_offset	array
[	O
i	long
]	O
;	O
if	O
(	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
buckets	pointer
<=	O
nbuckets	long
)	O
xalloc_die	function
(	O
)	O
;	O
buckets	pointer
=	O
zalloc	function
(	O
(	O
nbuckets	long
+	O
1	int
)	O
*	O
sizeof	O
*	O
buckets	pointer
)	O
;	O
buckets	pointer
++	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
2	int
;	O
i	long
++	O
)	O
find_and_hash_each_line	function
(	O
&	O
filevec	array
[	O
i	long
]	O
)	O
;	O
filevec	array
[	O
0	int
]	O
.	O
equiv_max	long
=	O
filevec	array
[	O
1	int
]	O
.	O
equiv_max	long
=	O
equivs_index	long
;	O
free	function
(	O
equivs	pointer
)	O
;	O
free	function
(	O
buckets	pointer
-	O
1	int
)	O
;	O
return	O
false	int
;	O
}	O
