static	O
void	O
display	function
(	O
FTSENT	struct
*	O
,	O
FTSENT	struct
*	O
)	O
;	O
static	O
int	O
mastercmp	function
(	O
const	O
FTSENT	struct
*	O
*	O
,	O
const	O
FTSENT	struct
*	O
*	O
)	O
;	O
static	O
void	O
traverse	function
(	O
int	O
,	O
char	O
*	O
*	O
,	O
int	O
)	O
;	O
static	O
void	O
(	O
*	O
printfcn	pointer
)	O
(	O
DISPLAY	struct
*	O
)	O
;	O
static	O
int	O
(	O
*	O
sortfcn	pointer
)	O
(	O
const	O
FTSENT	struct
*	O
,	O
const	O
FTSENT	struct
*	O
)	O
;	O
long	O
blocksize	long
;	O
int	O
termwidth	int
=	O
80	int
;	O
int	O
sortkey	int
=	O
BY_NAME	int
;	O
int	O
f_accesstime	int
;	O
int	O
f_column	int
;	O
int	O
f_columnacross	int
;	O
int	O
f_flags	int
;	O
int	O
f_inode	int
;	O
int	O
f_listdir	int
;	O
int	O
f_listdot	int
;	O
int	O
f_longform	int
;	O
int	O
f_newline	int
;	O
int	O
f_nonprint	int
;	O
int	O
f_nosort	int
;	O
int	O
f_numericonly	int
;	O
int	O
f_recursive	int
;	O
int	O
f_reversesort	int
;	O
int	O
f_sectime	int
;	O
int	O
f_singlecol	int
;	O
int	O
f_size	int
;	O
int	O
f_statustime	int
;	O
int	O
f_stream	int
;	O
int	O
f_dirname	int
;	O
int	O
f_type	int
;	O
int	O
f_typedir	int
;	O
int	O
f_whiteout	int
;	O
int	O
rval	int
;	O
int	O
ls_main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
static	O
char	O
dot	array
[	O
]	O
=	O
"."	pointer
,	O
*	O
dotav	array
[	O
]	O
=	O
{	O
dot	array
,	O
NULL	O
}	O
;	O
struct	O
winsize	struct
win	struct
;	O
int	O
ch	int
,	O
fts_options	int
;	O
int	O
kflag	int
=	O
0	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
)	O
{	O
if	O
(	O
(	O
p	pointer
=	O
getenv	function
(	O
"COLUMNS"	pointer
)	O
)	O
!=	O
NULL	O
)	O
termwidth	int
=	O
atoi	function
(	O
p	pointer
)	O
;	O
else	O
if	O
(	O
ioctl	function
(	O
STDOUT_FILENO	int
,	O
TIOCGWINSZ	int
,	O
&	O
win	struct
)	O
==	O
0	int
&&	O
win	struct
.	O
ws_col	short
>	O
0	int
)	O
termwidth	int
=	O
win	struct
.	O
ws_col	short
;	O
f_column	int
=	O
f_nonprint	int
=	O
1	int
;	O
}	O
else	O
f_singlecol	int
=	O
1	int
;	O
if	O
(	O
!	O
getuid	function
(	O
)	O
)	O
f_listdot	int
=	O
1	int
;	O
fts_options	int
=	O
FTS_PHYSICAL	int
;	O
while	O
(	O
(	O
ch	int
=	O
getopt	function
(	O
argc	int
,	O
argv	pointer
,	O
"1ACFLRSTWacdfgiklmnopqrstux"	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'1'	O
:	O
f_singlecol	int
=	O
1	int
;	O
f_column	int
=	O
f_columnacross	int
=	O
f_longform	int
=	O
f_stream	int
=	O
0	int
;	O
break	O
;	O
case	O
'C'	O
:	O
f_column	int
=	O
1	int
;	O
f_longform	int
=	O
f_columnacross	int
=	O
f_singlecol	int
=	O
f_stream	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
f_longform	int
=	O
1	int
;	O
f_numericonly	int
=	O
0	int
;	O
f_column	int
=	O
f_columnacross	int
=	O
f_singlecol	int
=	O
f_stream	int
=	O
0	int
;	O
break	O
;	O
case	O
'm'	O
:	O
f_stream	int
=	O
1	int
;	O
f_column	int
=	O
f_columnacross	int
=	O
f_singlecol	int
=	O
0	int
;	O
f_singlecol	int
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
f_columnacross	int
=	O
1	int
;	O
f_column	int
=	O
f_longform	int
=	O
f_singlecol	int
=	O
f_stream	int
=	O
0	int
;	O
break	O
;	O
case	O
'n'	O
:	O
f_longform	int
=	O
1	int
;	O
f_numericonly	int
=	O
1	int
;	O
f_column	int
=	O
f_singlecol	int
=	O
0	int
;	O
break	O
;	O
case	O
'c'	O
:	O
f_statustime	int
=	O
1	int
;	O
f_accesstime	int
=	O
0	int
;	O
break	O
;	O
case	O
'u'	O
:	O
f_accesstime	int
=	O
1	int
;	O
f_statustime	int
=	O
0	int
;	O
break	O
;	O
case	O
'F'	O
:	O
f_type	int
=	O
1	int
;	O
break	O
;	O
case	O
'L'	O
:	O
fts_options	int
&=	O
~	O
FTS_PHYSICAL	int
;	O
fts_options	int
|=	O
FTS_LOGICAL	int
;	O
break	O
;	O
case	O
'R'	O
:	O
f_recursive	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
fts_options	int
|=	O
FTS_SEEDOT	int
;	O
case	O
'A'	O
:	O
f_listdot	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
f_listdir	int
=	O
1	int
;	O
f_recursive	int
=	O
0	int
;	O
break	O
;	O
case	O
'f'	O
:	O
f_nosort	int
=	O
1	int
;	O
break	O
;	O
case	O
'g'	O
:	O
break	O
;	O
case	O
'i'	O
:	O
f_inode	int
=	O
1	int
;	O
break	O
;	O
case	O
'k'	O
:	O
blocksize	long
=	O
1024	int
;	O
kflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
f_flags	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
f_typedir	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
f_nonprint	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
f_reversesort	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
sortkey	int
=	O
BY_SIZE	int
;	O
break	O
;	O
case	O
's'	O
:	O
f_size	int
=	O
1	int
;	O
break	O
;	O
case	O
'T'	O
:	O
f_sectime	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
sortkey	int
=	O
BY_TIME	int
;	O
break	O
;	O
case	O
'W'	O
:	O
f_whiteout	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
argc	int
-=	O
optind	int
;	O
argv	pointer
+=	O
optind	int
;	O
if	O
(	O
!	O
f_longform	int
&&	O
!	O
f_inode	int
&&	O
!	O
f_size	int
&&	O
!	O
f_type	int
&&	O
!	O
f_typedir	int
&&	O
sortkey	int
==	O
BY_NAME	int
)	O
fts_options	int
|=	O
FTS_NOSTAT	int
;	O
if	O
(	O
!	O
f_longform	int
&&	O
!	O
f_listdir	int
&&	O
!	O
f_type	int
)	O
fts_options	int
|=	O
FTS_COMFOLLOW	int
;	O
if	O
(	O
f_whiteout	int
)	O
fts_options	int
|=	O
FTS_WHITEOUT	int
;	O
if	O
(	O
f_longform	int
||	O
f_size	int
)	O
{	O
blocksize	long
=	O
1024	int
;	O
blocksize	long
/=	O
512	int
;	O
}	O
if	O
(	O
f_reversesort	int
)	O
{	O
switch	O
(	O
sortkey	int
)	O
{	O
case	O
BY_NAME	int
:	O
sortfcn	pointer
=	O
revnamecmp	function
;	O
break	O
;	O
case	O
BY_SIZE	int
:	O
sortfcn	pointer
=	O
revsizecmp	function
;	O
break	O
;	O
case	O
BY_TIME	int
:	O
if	O
(	O
f_accesstime	int
)	O
sortfcn	pointer
=	O
revacccmp	function
;	O
else	O
if	O
(	O
f_statustime	int
)	O
sortfcn	pointer
=	O
revstatcmp	function
;	O
else	O
sortfcn	pointer
=	O
revmodcmp	function
;	O
break	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
sortkey	int
)	O
{	O
case	O
BY_NAME	int
:	O
sortfcn	pointer
=	O
namecmp	function
;	O
break	O
;	O
case	O
BY_SIZE	int
:	O
sortfcn	pointer
=	O
sizecmp	function
;	O
break	O
;	O
case	O
BY_TIME	int
:	O
if	O
(	O
f_accesstime	int
)	O
sortfcn	pointer
=	O
acccmp	function
;	O
else	O
if	O
(	O
f_statustime	int
)	O
sortfcn	pointer
=	O
statcmp	function
;	O
else	O
sortfcn	pointer
=	O
modcmp	function
;	O
break	O
;	O
}	O
}	O
if	O
(	O
f_singlecol	int
)	O
printfcn	pointer
=	O
printscol	function
;	O
else	O
if	O
(	O
f_columnacross	int
)	O
printfcn	pointer
=	O
printacol	function
;	O
else	O
if	O
(	O
f_longform	int
)	O
printfcn	pointer
=	O
printlong	function
;	O
else	O
if	O
(	O
f_stream	int
)	O
printfcn	pointer
=	O
printstream	function
;	O
else	O
printfcn	pointer
=	O
printcol	function
;	O
if	O
(	O
argc	int
)	O
traverse	function
(	O
argc	int
,	O
argv	pointer
,	O
fts_options	int
)	O
;	O
else	O
traverse	function
(	O
1	int
,	O
dotav	array
,	O
fts_options	int
)	O
;	O
exit	function
(	O
rval	int
)	O
;	O
}	O
static	O
int	O
output	int
;	O
static	O
void	O
traverse	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
options	int
)	O
{	O
FTS	struct
*	O
ftsp	pointer
;	O
FTSENT	struct
*	O
p	pointer
,	O
*	O
chp	pointer
;	O
int	O
ch_options	int
;	O
if	O
(	O
(	O
ftsp	pointer
=	O
fts_open	function
(	O
argv	pointer
,	O
options	int
,	O
f_nosort	int
?	O
NULL	O
:	O
mastercmp	function
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: fts_open: %s"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
display	function
(	O
NULL	O
,	O
fts_children	function
(	O
ftsp	pointer
,	O
0	int
)	O
)	O
;	O
if	O
(	O
f_listdir	int
)	O
return	O
;	O
ch_options	int
=	O
!	O
f_recursive	int
&&	O
options	int
&	O
FTS_NOSTAT	int
?	O
FTS_NAMEONLY	int
:	O
0	int
;	O
while	O
(	O
(	O
p	pointer
=	O
fts_read	function
(	O
ftsp	pointer
)	O
)	O
!=	O
NULL	O
)	O
switch	O
(	O
p	pointer
->	O
fts_info	short
)	O
{	O
case	O
FTS_D	int
:	O
if	O
(	O
p	pointer
->	O
fts_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
p	pointer
->	O
fts_level	short
!=	O
FTS_ROOTLEVEL	int
&&	O
!	O
f_listdot	int
)	O
break	O
;	O
if	O
(	O
output	int
)	O
printf	function
(	O
"\n%s:\n"	pointer
,	O
p	pointer
->	O
fts_path	pointer
)	O
;	O
else	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
printf	function
(	O
"%s:\n"	pointer
,	O
p	pointer
->	O
fts_path	pointer
)	O
;	O
output	int
=	O
1	int
;	O
}	O
chp	pointer
=	O
fts_children	function
(	O
ftsp	pointer
,	O
ch_options	int
)	O
;	O
display	function
(	O
p	pointer
,	O
chp	pointer
)	O
;	O
if	O
(	O
!	O
f_recursive	int
&&	O
chp	pointer
!=	O
NULL	O
)	O
fts_set	function
(	O
ftsp	pointer
,	O
p	pointer
,	O
FTS_SKIP	int
)	O
;	O
break	O
;	O
case	O
FTS_DC	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: directory causes a cycle"	pointer
,	O
p	pointer
->	O
fts_name	array
)	O
;	O
break	O
;	O
case	O
FTS_DNR	int
:	O
case	O
FTS_ERR	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
p	pointer
->	O
fts_name	array
,	O
strerror	function
(	O
p	pointer
->	O
fts_errno	int
)	O
)	O
;	O
rval	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
errno	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fts_read: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
static	O
void	O
display	function
(	O
FTSENT	struct
*	O
p	pointer
,	O
FTSENT	struct
*	O
list	pointer
)	O
{	O
struct	O
stat	struct
*	O
sp	pointer
;	O
DISPLAY	struct
d	struct
;	O
FTSENT	struct
*	O
cur	pointer
;	O
NAMES	struct
*	O
np	pointer
;	O
unsigned	O
long	O
long	O
maxsize	long long
;	O
unsigned	O
long	O
btotal	long
,	O
maxblock	long
,	O
maxinode	long
,	O
maxlen	int
,	O
maxnlink	long
;	O
int	O
bcfile	int
,	O
flen	int
,	O
glen	int
,	O
ulen	int
,	O
maxflags	int
,	O
maxgroup	int
,	O
maxuser	int
;	O
int	O
entries	int
,	O
needstats	int
;	O
char	O
*	O
user	pointer
=	O
NULL	O
,	O
*	O
group	struct
=	O
NULL	O
,	O
buf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
uintmax_t	long
)	O
]	O
;	O
char	O
nuser	array
[	O
INT_BUFSIZE_BOUND	O
(	O
uintmax_t	long
)	O
]	O
,	O
ngroup	array
[	O
INT_BUFSIZE_BOUND	O
(	O
uintmax_t	long
)	O
]	O
;	O
char	O
*	O
flags	pointer
=	O
NULL	O
;	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
return	O
;	O
needstats	int
=	O
f_inode	int
||	O
f_longform	int
||	O
f_size	int
;	O
flen	int
=	O
0	int
;	O
btotal	long
=	O
maxblock	long
=	O
maxinode	long
=	O
maxlen	int
=	O
maxnlink	long
=	O
0	int
;	O
bcfile	int
=	O
0	int
;	O
maxuser	int
=	O
maxgroup	int
=	O
maxflags	int
=	O
0	int
;	O
maxsize	long long
=	O
0	int
;	O
for	O
(	O
cur	pointer
=	O
list	pointer
,	O
entries	int
=	O
0	int
;	O
cur	pointer
;	O
cur	pointer
=	O
cur	pointer
->	O
fts_link	pointer
)	O
{	O
if	O
(	O
cur	pointer
->	O
fts_info	short
==	O
FTS_ERR	int
||	O
cur	pointer
->	O
fts_info	short
==	O
FTS_NS	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
cur	pointer
->	O
fts_name	array
,	O
strerror	function
(	O
cur	pointer
->	O
fts_errno	int
)	O
)	O
;	O
cur	pointer
->	O
fts_number	long
=	O
NO_PRINT	int
;	O
rval	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
cur	pointer
->	O
fts_info	short
==	O
FTS_D	int
&&	O
!	O
f_listdir	int
)	O
{	O
cur	pointer
->	O
fts_number	long
=	O
NO_PRINT	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
cur	pointer
->	O
fts_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
!	O
f_listdot	int
)	O
{	O
cur	pointer
->	O
fts_number	long
=	O
NO_PRINT	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
cur	pointer
->	O
fts_namelen	short
>	O
maxlen	int
)	O
maxlen	int
=	O
cur	pointer
->	O
fts_namelen	short
;	O
if	O
(	O
needstats	int
)	O
{	O
sp	pointer
=	O
cur	pointer
->	O
fts_statp	pointer
;	O
if	O
(	O
sp	pointer
->	O
st_blocks	long
>	O
maxblock	long
)	O
maxblock	long
=	O
sp	pointer
->	O
st_blocks	long
;	O
if	O
(	O
sp	pointer
->	O
st_ino	long
>	O
maxinode	long
)	O
maxinode	long
=	O
sp	pointer
->	O
st_ino	long
;	O
if	O
(	O
sp	pointer
->	O
st_nlink	long
>	O
maxnlink	long
)	O
maxnlink	long
=	O
sp	pointer
->	O
st_nlink	long
;	O
if	O
(	O
sp	pointer
->	O
st_size	long
>	O
maxsize	long long
)	O
maxsize	long long
=	O
sp	pointer
->	O
st_size	long
;	O
btotal	long
+=	O
sp	pointer
->	O
st_blocks	long
;	O
if	O
(	O
f_longform	int
)	O
{	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
struct	O
group	struct
*	O
grp	pointer
;	O
if	O
(	O
!	O
f_numericonly	int
)	O
{	O
pwd	pointer
=	O
getpwuid	function
(	O
sp	pointer
->	O
st_uid	int
)	O
;	O
if	O
(	O
pwd	pointer
)	O
user	pointer
=	O
pwd	pointer
->	O
pw_name	pointer
;	O
grp	pointer
=	O
getgrgid	function
(	O
sp	pointer
->	O
st_gid	int
)	O
;	O
if	O
(	O
grp	pointer
)	O
group	struct
=	O
grp	pointer
->	O
gr_name	pointer
;	O
}	O
if	O
(	O
!	O
user	pointer
)	O
user	pointer
=	O
umaxtostr	function
(	O
sp	pointer
->	O
st_uid	int
,	O
nuser	array
)	O
;	O
if	O
(	O
!	O
group	struct
)	O
group	struct
=	O
umaxtostr	function
(	O
sp	pointer
->	O
st_gid	int
,	O
ngroup	array
)	O
;	O
if	O
(	O
(	O
ulen	int
=	O
strlen	function
(	O
user	pointer
)	O
)	O
>	O
maxuser	int
)	O
maxuser	int
=	O
ulen	int
;	O
if	O
(	O
(	O
glen	int
=	O
strlen	function
(	O
group	struct
)	O
)	O
>	O
maxgroup	int
)	O
maxgroup	int
=	O
glen	int
;	O
if	O
(	O
f_flags	int
)	O
{	O
flags	pointer
=	O
"-"	pointer
;	O
if	O
(	O
(	O
flen	int
=	O
strlen	function
(	O
flags	pointer
)	O
)	O
>	O
maxflags	int
)	O
maxflags	int
=	O
flen	int
;	O
}	O
else	O
flen	int
=	O
0	int
;	O
if	O
(	O
(	O
np	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
NAMES	struct
)	O
+	O
ulen	int
+	O
glen	int
+	O
flen	int
+	O
3	int
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"malloc: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
np	pointer
->	O
user	pointer
=	O
&	O
np	pointer
->	O
data	array
[	O
0	int
]	O
;	O
strcpy	function
(	O
np	pointer
->	O
user	pointer
,	O
user	pointer
)	O
;	O
np	pointer
->	O
group	struct
=	O
&	O
np	pointer
->	O
data	array
[	O
ulen	int
+	O
1	int
]	O
;	O
strcpy	function
(	O
np	pointer
->	O
group	struct
,	O
group	struct
)	O
;	O
if	O
(	O
S_ISCHR	O
(	O
sp	pointer
->	O
st_mode	int
)	O
||	O
S_ISBLK	O
(	O
sp	pointer
->	O
st_mode	int
)	O
)	O
bcfile	int
=	O
1	int
;	O
if	O
(	O
f_flags	int
)	O
{	O
np	pointer
->	O
flags	pointer
=	O
&	O
np	pointer
->	O
data	array
[	O
ulen	int
+	O
glen	int
+	O
2	int
]	O
;	O
strcpy	function
(	O
np	pointer
->	O
flags	pointer
,	O
flags	pointer
)	O
;	O
}	O
cur	pointer
->	O
fts_pointer	pointer
=	O
np	pointer
;	O
}	O
}	O
++	O
entries	int
;	O
}	O
if	O
(	O
!	O
entries	int
)	O
return	O
;	O
d	struct
.	O
list	pointer
=	O
list	pointer
;	O
d	struct
.	O
entries	int
=	O
entries	int
;	O
d	struct
.	O
maxlen	int
=	O
maxlen	int
;	O
if	O
(	O
needstats	int
)	O
{	O
d	struct
.	O
bcfile	int
=	O
bcfile	int
;	O
d	struct
.	O
btotal	long
=	O
btotal	long
;	O
d	struct
.	O
s_block	int
=	O
strlen	function
(	O
umaxtostr	function
(	O
maxblock	long
,	O
buf	array
)	O
)	O
;	O
d	struct
.	O
s_flags	int
=	O
maxflags	int
;	O
d	struct
.	O
s_group	int
=	O
maxgroup	int
;	O
d	struct
.	O
s_inode	int
=	O
strlen	function
(	O
umaxtostr	function
(	O
maxinode	long
,	O
buf	array
)	O
)	O
;	O
d	struct
.	O
s_nlink	int
=	O
strlen	function
(	O
umaxtostr	function
(	O
maxnlink	long
,	O
buf	array
)	O
)	O
;	O
d	struct
.	O
s_size	int
=	O
strlen	function
(	O
umaxtostr	function
(	O
maxsize	long long
,	O
buf	array
)	O
)	O
;	O
d	struct
.	O
s_user	int
=	O
maxuser	int
;	O
}	O
printfcn	pointer
(	O
&	O
d	struct
)	O
;	O
output	int
=	O
1	int
;	O
if	O
(	O
f_longform	int
)	O
for	O
(	O
cur	pointer
=	O
list	pointer
;	O
cur	pointer
;	O
cur	pointer
=	O
cur	pointer
->	O
fts_link	pointer
)	O
free	function
(	O
cur	pointer
->	O
fts_pointer	pointer
)	O
;	O
}	O
static	O
int	O
mastercmp	function
(	O
const	O
FTSENT	struct
*	O
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
*	O
b	pointer
)	O
{	O
int	O
a_info	int
,	O
b_info	int
;	O
a_info	int
=	O
(	O
*	O
a	pointer
)	O
->	O
fts_info	short
;	O
if	O
(	O
a_info	int
==	O
FTS_ERR	int
)	O
return	O
(	O
0	int
)	O
;	O
b_info	int
=	O
(	O
*	O
b	pointer
)	O
->	O
fts_info	short
;	O
if	O
(	O
b_info	int
==	O
FTS_ERR	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
a_info	int
==	O
FTS_NS	int
||	O
b_info	int
==	O
FTS_NS	int
)	O
{	O
if	O
(	O
b_info	int
!=	O
FTS_NS	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
a_info	int
!=	O
FTS_NS	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
return	O
(	O
namecmp	function
(	O
*	O
a	pointer
,	O
*	O
b	pointer
)	O
)	O
;	O
}	O
if	O
(	O
a_info	int
!=	O
b_info	int
&&	O
(	O
*	O
a	pointer
)	O
->	O
fts_level	short
==	O
FTS_ROOTLEVEL	int
&&	O
!	O
f_listdir	int
)	O
{	O
if	O
(	O
a_info	int
==	O
FTS_D	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
b_info	int
==	O
FTS_D	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
return	O
(	O
sortfcn	pointer
(	O
*	O
a	pointer
,	O
*	O
b	pointer
)	O
)	O
;	O
}	O
