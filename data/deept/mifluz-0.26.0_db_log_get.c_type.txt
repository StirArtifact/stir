static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: log_get.c,v 1.3 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
int	O
CDB_log_get	function
(	O
dbenv	pointer
,	O
alsn	pointer
,	O
dbt	struct
,	O
flags	int
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LSN	struct
*	O
alsn	pointer
;	O
DBT	struct
*	O
dbt	struct
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_LOG	struct
*	O
dblp	pointer
;	O
DB_LSN	struct
saved_lsn	struct
;	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lg_handle	pointer
,	O
DB_INIT_LOG	int
)	O
;	O
if	O
(	O
flags	int
!=	O
DB_CHECKPOINT	int
&&	O
flags	int
!=	O
DB_CURRENT	int
&&	O
flags	int
!=	O
DB_FIRST	int
&&	O
flags	int
!=	O
DB_LAST	int
&&	O
flags	int
!=	O
DB_NEXT	int
&&	O
flags	int
!=	O
DB_PREV	int
&&	O
flags	int
!=	O
DB_SET	int
)	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
"CDB_log_get"	pointer
,	O
1	int
)	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
{	O
if	O
(	O
flags	int
==	O
DB_NEXT	int
||	O
flags	int
==	O
DB_PREV	int
||	O
flags	int
==	O
DB_CURRENT	int
)	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
"CDB_log_get"	pointer
,	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_MALLOC	int
|	O
DB_DBT_REALLOC	int
|	O
DB_DBT_USERMEM	int
)	O
)	O
return	O
(	O
CDB___db_ferr	function
(	O
dbenv	pointer
,	O
"threaded data"	pointer
,	O
1	int
)	O
)	O
;	O
}	O
dblp	pointer
=	O
dbenv	pointer
->	O
lg_handle	pointer
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
saved_lsn	struct
=	O
*	O
alsn	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_get	function
(	O
dblp	pointer
,	O
alsn	pointer
,	O
dbt	struct
,	O
flags	int
,	O
0	int
)	O
)	O
==	O
0	int
&&	O
alsn	pointer
->	O
offset	int
==	O
0	int
)	O
{	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_FIRST	int
:	O
flags	int
=	O
DB_NEXT	int
;	O
break	O
;	O
case	O
DB_LAST	int
:	O
flags	int
=	O
DB_PREV	int
;	O
break	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dbt	struct
,	O
DB_DBT_MALLOC	int
)	O
)	O
{	O
CDB___os_free	function
(	O
dbt	struct
->	O
data	pointer
,	O
dbt	struct
->	O
size	int
)	O
;	O
dbt	struct
->	O
data	pointer
=	O
NULL	O
;	O
}	O
ret	int
=	O
CDB___log_get	function
(	O
dblp	pointer
,	O
alsn	pointer
,	O
dbt	struct
,	O
flags	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
ret	int
!=	O
0	int
)	O
*	O
alsn	pointer
=	O
saved_lsn	struct
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___log_get	function
(	O
dblp	pointer
,	O
alsn	pointer
,	O
dbt	struct
,	O
flags	int
,	O
silent	int
)	O
DB_LOG	struct
*	O
dblp	pointer
;	O
DB_LSN	struct
*	O
alsn	pointer
;	O
DBT	struct
*	O
dbt	struct
;	O
u_int32_t	int
flags	int
;	O
int	O
silent	int
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LSN	struct
nlsn	struct
;	O
HDR	struct
hdr	pointer
;	O
LOG	struct
*	O
lp	pointer
;	O
size_t	long
len	short
;	O
size_t	long
nr	long
;	O
int	O
cnt	int
,	O
ret	int
;	O
char	O
*	O
np	pointer
,	O
*	O
tbuf	pointer
;	O
const	O
char	O
*	O
fail	pointer
;	O
void	O
*	O
shortp	pointer
,	O
*	O
readp	pointer
;	O
u_int32_t	int
offset	int
;	O
u_int8_t	char
*	O
p	pointer
;	O
lp	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
fail	pointer
=	O
np	pointer
=	O
tbuf	pointer
=	O
NULL	O
;	O
dbenv	pointer
=	O
dblp	pointer
->	O
dbenv	pointer
;	O
nlsn	struct
=	O
dblp	pointer
->	O
c_lsn	struct
;	O
switch	O
(	O
flags	int
)	O
{	O
case	O
DB_CHECKPOINT	int
:	O
nlsn	struct
=	O
lp	pointer
->	O
chkpt_lsn	struct
;	O
if	O
(	O
IS_ZERO_LSN	O
(	O
nlsn	struct
)	O
)	O
{	O
ret	int
=	O
ENOENT	int
;	O
goto	O
err2	O
;	O
}	O
break	O
;	O
case	O
DB_NEXT	int
:	O
if	O
(	O
!	O
IS_ZERO_LSN	O
(	O
nlsn	struct
)	O
)	O
{	O
nlsn	struct
.	O
offset	int
+=	O
dblp	pointer
->	O
c_len	int
;	O
break	O
;	O
}	O
case	O
DB_FIRST	int
:	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_find	function
(	O
dblp	pointer
,	O
1	int
,	O
&	O
cnt	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err2	O
;	O
if	O
(	O
cnt	int
==	O
0	int
)	O
cnt	int
=	O
1	int
;	O
nlsn	struct
.	O
file	int
=	O
cnt	int
;	O
nlsn	struct
.	O
offset	int
=	O
0	int
;	O
break	O
;	O
case	O
DB_CURRENT	int
:	O
break	O
;	O
case	O
DB_PREV	int
:	O
if	O
(	O
!	O
IS_ZERO_LSN	O
(	O
nlsn	struct
)	O
)	O
{	O
if	O
(	O
nlsn	struct
.	O
offset	int
==	O
0	int
)	O
{	O
if	O
(	O
nlsn	struct
.	O
file	int
==	O
1	int
||	O
CDB___log_valid	function
(	O
dblp	pointer
,	O
nlsn	struct
.	O
file	int
-	O
1	int
,	O
0	int
)	O
!=	O
0	int
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
--	O
nlsn	struct
.	O
file	int
;	O
nlsn	struct
.	O
offset	int
=	O
dblp	pointer
->	O
c_off	int
;	O
}	O
else	O
nlsn	struct
.	O
offset	int
=	O
dblp	pointer
->	O
c_off	int
;	O
break	O
;	O
}	O
case	O
DB_LAST	int
:	O
nlsn	struct
.	O
file	int
=	O
lp	pointer
->	O
lsn	struct
.	O
file	int
;	O
nlsn	struct
.	O
offset	int
=	O
lp	pointer
->	O
lsn	struct
.	O
offset	int
-	O
lp	pointer
->	O
len	short
;	O
break	O
;	O
case	O
DB_SET	int
:	O
nlsn	struct
=	O
*	O
alsn	pointer
;	O
break	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
next_file	O
:	O
++	O
nlsn	struct
.	O
file	int
;	O
nlsn	struct
.	O
offset	int
=	O
0	int
;	O
}	O
if	O
(	O
nlsn	struct
.	O
file	int
>	O
lp	pointer
->	O
lsn	struct
.	O
file	int
||	O
(	O
nlsn	struct
.	O
file	int
==	O
lp	pointer
->	O
lsn	struct
.	O
file	int
&&	O
nlsn	struct
.	O
offset	int
>=	O
lp	pointer
->	O
lsn	struct
.	O
offset	int
)	O
)	O
return	O
(	O
DB_NOTFOUND	O
)	O
;	O
if	O
(	O
dblp	pointer
->	O
c_lsn	struct
.	O
file	int
!=	O
nlsn	struct
.	O
file	int
&&	O
F_ISSET	O
(	O
&	O
dblp	pointer
->	O
c_fh	struct
,	O
DB_FH_VALID	int
)	O
)	O
{	O
(	O
void	O
)	O
CDB___os_closehandle	function
(	O
&	O
dblp	pointer
->	O
c_fh	struct
)	O
;	O
}	O
if	O
(	O
nlsn	struct
.	O
file	int
==	O
lp	pointer
->	O
lsn	struct
.	O
file	int
&&	O
nlsn	struct
.	O
offset	int
>=	O
lp	pointer
->	O
w_off	int
)	O
{	O
p	pointer
=	O
dblp	pointer
->	O
bufp	pointer
+	O
(	O
nlsn	struct
.	O
offset	int
-	O
lp	pointer
->	O
w_off	int
)	O
;	O
memcpy	function
(	O
&	O
hdr	pointer
,	O
p	pointer
,	O
sizeof	O
(	O
HDR	struct
)	O
)	O
;	O
len	short
=	O
hdr	pointer
.	O
len	short
-	O
sizeof	O
(	O
HDR	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_retcopy	function
(	O
NULL	O
,	O
dbt	struct
,	O
p	pointer
+	O
sizeof	O
(	O
HDR	struct
)	O
,	O
len	short
,	O
&	O
dblp	pointer
->	O
c_dbt	struct
.	O
data	pointer
,	O
&	O
dblp	pointer
->	O
c_dbt	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
alloc_err	O
;	O
goto	O
cksum	int
;	O
}	O
shortp	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
&	O
dblp	pointer
->	O
c_fh	struct
,	O
DB_FH_VALID	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_name	function
(	O
dblp	pointer
,	O
nlsn	struct
.	O
file	int
,	O
&	O
np	pointer
,	O
&	O
dblp	pointer
->	O
c_fh	struct
,	O
DB_OSO_RDONLY	int
|	O
DB_OSO_SEQ	int
)	O
)	O
!=	O
0	int
)	O
{	O
fail	pointer
=	O
np	pointer
;	O
goto	O
err1	O
;	O
}	O
CDB___os_freestr	function
(	O
np	pointer
)	O
;	O
np	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
nlsn	struct
.	O
file	int
==	O
dblp	pointer
->	O
r_file	int
&&	O
nlsn	struct
.	O
offset	int
>	O
dblp	pointer
->	O
r_off	int
&&	O
nlsn	struct
.	O
offset	int
+	O
sizeof	O
(	O
HDR	struct
)	O
<	O
dblp	pointer
->	O
r_off	int
+	O
dblp	pointer
->	O
r_size	int
)	O
goto	O
got_header	O
;	O
readp	pointer
=	O
&	O
hdr	pointer
;	O
offset	int
=	O
nlsn	struct
.	O
offset	int
;	O
if	O
(	O
nlsn	struct
.	O
file	int
==	O
lp	pointer
->	O
lsn	struct
.	O
file	int
&&	O
offset	int
+	O
sizeof	O
(	O
HDR	struct
)	O
>	O
lp	pointer
->	O
w_off	int
)	O
nr	long
=	O
lp	pointer
->	O
w_off	int
-	O
offset	int
;	O
else	O
if	O
(	O
dblp	pointer
->	O
readbufp	pointer
==	O
NULL	O
)	O
nr	long
=	O
sizeof	O
(	O
HDR	struct
)	O
;	O
else	O
{	O
nr	long
=	O
lp	pointer
->	O
buffer_size	int
;	O
readp	pointer
=	O
dblp	pointer
->	O
readbufp	pointer
;	O
dblp	pointer
->	O
r_file	int
=	O
nlsn	struct
.	O
file	int
;	O
if	O
(	O
flags	int
==	O
DB_PREV	int
||	O
flags	int
==	O
DB_LAST	int
)	O
{	O
if	O
(	O
offset	int
<=	O
lp	pointer
->	O
buffer_size	int
/	O
2	int
)	O
offset	int
=	O
0	int
;	O
else	O
offset	int
=	O
offset	int
-	O
lp	pointer
->	O
buffer_size	int
/	O
2	int
;	O
}	O
if	O
(	O
nlsn	struct
.	O
file	int
==	O
lp	pointer
->	O
lsn	struct
.	O
file	int
&&	O
offset	int
+	O
nr	long
>	O
lp	pointer
->	O
lsn	struct
.	O
offset	int
)	O
nr	long
=	O
lp	pointer
->	O
lsn	struct
.	O
offset	int
-	O
offset	int
;	O
dblp	pointer
->	O
r_off	int
=	O
offset	int
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
c_fh	struct
,	O
0	int
,	O
0	int
,	O
offset	int
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
{	O
fail	pointer
=	O
"seek"	pointer
;	O
goto	O
err1	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
c_fh	struct
,	O
readp	pointer
,	O
nr	long
,	O
&	O
nr	long
)	O
)	O
!=	O
0	int
)	O
{	O
fail	pointer
=	O
"read"	pointer
;	O
goto	O
err1	O
;	O
}	O
if	O
(	O
nr	long
<	O
sizeof	O
(	O
HDR	struct
)	O
)	O
{	O
if	O
(	O
nr	long
==	O
0	int
)	O
{	O
if	O
(	O
flags	int
!=	O
DB_NEXT	int
||	O
nlsn	struct
.	O
file	int
==	O
lp	pointer
->	O
lsn	struct
.	O
file	int
)	O
goto	O
corrupt	O
;	O
goto	O
next_file	O
;	O
}	O
if	O
(	O
dblp	pointer
->	O
readbufp	pointer
!=	O
NULL	O
)	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
&	O
hdr	pointer
,	O
readp	pointer
,	O
nr	long
)	O
;	O
if	O
(	O
lp	pointer
->	O
b_off	long
<	O
sizeof	O
(	O
HDR	struct
)	O
-	O
nr	long
)	O
goto	O
corrupt	O
;	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
&	O
hdr	pointer
+	O
nr	long
,	O
dblp	pointer
->	O
bufp	pointer
,	O
sizeof	O
(	O
HDR	struct
)	O
-	O
nr	long
)	O
;	O
if	O
(	O
hdr	pointer
.	O
len	short
==	O
0	int
)	O
goto	O
next_file	O
;	O
shortp	pointer
=	O
dblp	pointer
->	O
bufp	pointer
+	O
(	O
sizeof	O
(	O
HDR	struct
)	O
-	O
nr	long
)	O
;	O
}	O
else	O
if	O
(	O
dblp	pointer
->	O
readbufp	pointer
!=	O
NULL	O
)	O
{	O
dblp	pointer
->	O
r_size	int
=	O
nr	long
;	O
got_header	O
:	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
&	O
hdr	pointer
,	O
dblp	pointer
->	O
readbufp	pointer
+	O
(	O
nlsn	struct
.	O
offset	int
-	O
dblp	pointer
->	O
r_off	int
)	O
,	O
sizeof	O
(	O
HDR	struct
)	O
)	O
;	O
}	O
if	O
(	O
hdr	pointer
.	O
len	short
==	O
0	int
)	O
goto	O
next_file	O
;	O
if	O
(	O
hdr	pointer
.	O
len	short
<=	O
sizeof	O
(	O
HDR	struct
)	O
||	O
hdr	pointer
.	O
len	short
>	O
lp	pointer
->	O
persist	struct
.	O
lg_max	int
)	O
goto	O
corrupt	O
;	O
len	short
=	O
hdr	pointer
.	O
len	short
-	O
sizeof	O
(	O
HDR	struct
)	O
;	O
if	O
(	O
shortp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
lp	pointer
->	O
b_off	long
<	O
(	O
(	O
u_int8_t	char
*	O
)	O
shortp	pointer
-	O
dblp	pointer
->	O
bufp	pointer
)	O
+	O
len	short
)	O
goto	O
corrupt	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_retcopy	function
(	O
NULL	O
,	O
dbt	struct
,	O
shortp	pointer
,	O
len	short
,	O
&	O
dblp	pointer
->	O
c_dbt	struct
.	O
data	pointer
,	O
&	O
dblp	pointer
->	O
c_dbt	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
alloc_err	O
;	O
goto	O
cksum	int
;	O
}	O
if	O
(	O
dblp	pointer
->	O
readbufp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
nlsn	struct
.	O
offset	int
+	O
hdr	pointer
.	O
len	short
<	O
dblp	pointer
->	O
r_off	int
+	O
dblp	pointer
->	O
r_size	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_retcopy	function
(	O
NULL	O
,	O
dbt	struct
,	O
dblp	pointer
->	O
readbufp	pointer
+	O
(	O
nlsn	struct
.	O
offset	int
-	O
dblp	pointer
->	O
r_off	int
)	O
+	O
sizeof	O
(	O
HDR	struct
)	O
,	O
len	short
,	O
&	O
dblp	pointer
->	O
c_dbt	struct
.	O
data	pointer
,	O
&	O
dblp	pointer
->	O
c_dbt	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
alloc_err	O
;	O
goto	O
cksum	int
;	O
}	O
else	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
c_fh	struct
,	O
0	int
,	O
0	int
,	O
nlsn	struct
.	O
offset	int
+	O
sizeof	O
(	O
HDR	struct
)	O
,	O
0	int
,	O
DB_OS_SEEK_SET	int
)	O
)	O
!=	O
0	int
)	O
{	O
fail	pointer
=	O
"seek"	pointer
;	O
goto	O
err1	O
;	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
len	short
,	O
NULL	O
,	O
&	O
tbuf	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err1	O
;	O
if	O
(	O
nlsn	struct
.	O
file	int
==	O
lp	pointer
->	O
lsn	struct
.	O
file	int
&&	O
nlsn	struct
.	O
offset	int
+	O
sizeof	O
(	O
HDR	struct
)	O
+	O
len	short
>	O
lp	pointer
->	O
w_off	int
)	O
nr	long
=	O
lp	pointer
->	O
w_off	int
-	O
(	O
nlsn	struct
.	O
offset	int
+	O
sizeof	O
(	O
HDR	struct
)	O
)	O
;	O
else	O
nr	long
=	O
len	short
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_read	function
(	O
dblp	pointer
->	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
c_fh	struct
,	O
tbuf	pointer
,	O
nr	long
,	O
&	O
nr	long
)	O
)	O
!=	O
0	int
)	O
{	O
fail	pointer
=	O
"read"	pointer
;	O
goto	O
err1	O
;	O
}	O
if	O
(	O
len	short
-	O
nr	long
>	O
lp	pointer
->	O
buffer_size	int
)	O
goto	O
corrupt	O
;	O
if	O
(	O
nr	long
!=	O
len	short
)	O
{	O
if	O
(	O
lp	pointer
->	O
b_off	long
<	O
len	short
-	O
nr	long
)	O
goto	O
corrupt	O
;	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
tbuf	pointer
+	O
nr	long
,	O
dblp	pointer
->	O
bufp	pointer
,	O
len	short
-	O
nr	long
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_retcopy	function
(	O
NULL	O
,	O
dbt	struct
,	O
tbuf	pointer
,	O
len	short
,	O
&	O
dblp	pointer
->	O
c_dbt	struct
.	O
data	pointer
,	O
&	O
dblp	pointer
->	O
c_dbt	struct
.	O
ulen	int
)	O
)	O
!=	O
0	int
)	O
goto	O
alloc_err	O
;	O
CDB___os_free	function
(	O
tbuf	pointer
,	O
0	int
)	O
;	O
tbuf	pointer
=	O
NULL	O
;	O
cksum	int
:	O
if	O
(	O
hdr	pointer
.	O
cksum	int
!=	O
CDB___ham_func4	function
(	O
dbt	struct
->	O
data	pointer
,	O
dbt	struct
->	O
size	int
)	O
)	O
{	O
if	O
(	O
!	O
silent	int
)	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_log_get: checksum mismatch"	pointer
)	O
;	O
goto	O
corrupt	O
;	O
}	O
dblp	pointer
->	O
c_off	int
=	O
hdr	pointer
.	O
prev	int
;	O
dblp	pointer
->	O
c_len	int
=	O
hdr	pointer
.	O
len	short
;	O
dblp	pointer
->	O
c_lsn	struct
=	O
*	O
alsn	pointer
=	O
nlsn	struct
;	O
return	O
(	O
0	int
)	O
;	O
corrupt	O
:	O
ret	int
=	O
EIO	int
;	O
fail	pointer
=	O
"read"	pointer
;	O
err1	O
:	O
if	O
(	O
!	O
silent	int
)	O
{	O
if	O
(	O
fail	pointer
==	O
NULL	O
)	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_log_get: %s"	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
else	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_log_get: %s: %s"	pointer
,	O
fail	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
alloc_err	O
:	O
if	O
(	O
!	O
silent	int
)	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Allocation failed: %lu"	pointer
,	O
(	O
u_long	long
)	O
len	short
)	O
;	O
}	O
err2	O
:	O
if	O
(	O
np	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
np	pointer
)	O
;	O
if	O
(	O
tbuf	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
tbuf	pointer
,	O
0	int
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
