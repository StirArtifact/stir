static	O
const	O
char	O
*	O
const	O
categories	array
[	O
]	O
=	O
{	O
"books"	pointer
,	O
"images"	pointer
,	O
"music"	pointer
,	O
"software"	pointer
,	O
"videos"	pointer
,	O
"other"	pointer
,	O
NULL	O
,	O
}	O
;	O
struct	O
Language	struct
{	O
const	O
char	O
*	O
dirname	pointer
;	O
const	O
char	O
*	O
longname	pointer
;	O
}	O
;	O
static	O
const	O
struct	O
Language	struct
languages	array
[	O
]	O
=	O
{	O
{	O
"no-lang"	pointer
,	O
"No language specified"	pointer
}	O
,	O
{	O
"en"	pointer
,	O
"English"	pointer
}	O
,	O
{	O
"de"	pointer
,	O
"German"	pointer
}	O
,	O
{	O
"fr"	pointer
,	O
"French"	pointer
}	O
,	O
{	O
"es"	pointer
,	O
"Spanish"	pointer
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
,	O
}	O
;	O
static	O
struct	O
MHD_Response	O
*	O
file_not_found_response	pointer
;	O
static	O
struct	O
MHD_Response	O
*	O
internal_error_response	pointer
;	O
static	O
struct	O
MHD_Response	O
*	O
cached_directory_response	pointer
;	O
static	O
struct	O
MHD_Response	O
*	O
request_refused_response	pointer
;	O
static	O
pthread_mutex_t	union
mutex	union
;	O
static	O
void	O
mark_as_html	function
(	O
struct	O
MHD_Response	O
*	O
response	pointer
)	O
{	O
(	O
void	O
)	O
MHD_add_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONTENT_TYPE	pointer
,	O
"text/html"	pointer
)	O
;	O
}	O
static	O
void	O
update_cached_response	function
(	O
struct	O
MHD_Response	O
*	O
response	pointer
)	O
{	O
(	O
void	O
)	O
pthread_mutex_lock	function
(	O
&	O
mutex	union
)	O
;	O
if	O
(	O
NULL	O
!=	O
cached_directory_response	pointer
)	O
MHD_destroy_response	function
(	O
cached_directory_response	pointer
)	O
;	O
cached_directory_response	pointer
=	O
response	pointer
;	O
(	O
void	O
)	O
pthread_mutex_unlock	function
(	O
&	O
mutex	union
)	O
;	O
}	O
struct	O
ResponseDataContext	struct
{	O
char	O
*	O
buf	pointer
;	O
size_t	long
buf_len	long
;	O
size_t	long
off	long
;	O
}	O
;	O
static	O
int	O
list_directory	function
(	O
struct	O
ResponseDataContext	struct
*	O
rdc	pointer
,	O
const	O
char	O
*	O
dirname	pointer
)	O
{	O
char	O
fullname	array
[	O
PATH_MAX	int
]	O
;	O
struct	O
stat	struct
sbuf	struct
;	O
DIR	struct
*	O
dir	pointer
;	O
struct	O
dirent	struct
*	O
de	pointer
;	O
if	O
(	O
NULL	O
==	O
(	O
dir	pointer
=	O
opendir	function
(	O
dirname	pointer
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
while	O
(	O
NULL	O
!=	O
(	O
de	pointer
=	O
readdir	function
(	O
dir	pointer
)	O
)	O
)	O
{	O
if	O
(	O
'.'	O
==	O
de	pointer
->	O
d_name	array
[	O
0	int
]	O
)	O
continue	O
;	O
if	O
(	O
sizeof	O
(	O
fullname	array
)	O
<=	O
(	O
unsigned	O
int	O
)	O
snprintf	function
(	O
fullname	array
,	O
sizeof	O
(	O
fullname	array
)	O
,	O
"%s/%s"	pointer
,	O
dirname	pointer
,	O
de	pointer
->	O
d_name	array
)	O
)	O
continue	O
;	O
if	O
(	O
0	int
!=	O
stat	struct
(	O
fullname	array
,	O
&	O
sbuf	struct
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
S_ISREG	O
(	O
sbuf	struct
.	O
st_mode	int
)	O
)	O
continue	O
;	O
if	O
(	O
rdc	pointer
->	O
off	long
+	O
1024	int
>	O
rdc	pointer
->	O
buf_len	long
)	O
{	O
void	O
*	O
r	pointer
;	O
if	O
(	O
(	O
2	int
*	O
rdc	pointer
->	O
buf_len	long
+	O
1024	int
)	O
<	O
rdc	pointer
->	O
buf_len	long
)	O
break	O
;	O
rdc	pointer
->	O
buf_len	long
=	O
2	int
*	O
rdc	pointer
->	O
buf_len	long
+	O
1024	int
;	O
if	O
(	O
NULL	O
==	O
(	O
r	pointer
=	O
realloc	function
(	O
rdc	pointer
->	O
buf	pointer
,	O
rdc	pointer
->	O
buf_len	long
)	O
)	O
)	O
break	O
;	O
rdc	pointer
->	O
buf	pointer
=	O
r	pointer
;	O
}	O
rdc	pointer
->	O
off	long
+=	O
snprintf	function
(	O
&	O
rdc	pointer
->	O
buf	pointer
[	O
rdc	pointer
->	O
off	long
]	O
,	O
rdc	pointer
->	O
buf_len	long
-	O
rdc	pointer
->	O
off	long
,	O
"<li><a href=\"/%s\">%s</a></li>\n"	pointer
,	O
fullname	array
,	O
de	pointer
->	O
d_name	array
)	O
;	O
}	O
(	O
void	O
)	O
closedir	function
(	O
dir	pointer
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
update_directory	function
(	O
)	O
{	O
static	O
size_t	long
initial_allocation	long
=	O
32	int
*	O
1024	int
;	O
struct	O
MHD_Response	O
*	O
response	pointer
;	O
struct	O
ResponseDataContext	struct
rdc	pointer
;	O
unsigned	O
int	O
language_idx	int
;	O
unsigned	O
int	O
category_idx	int
;	O
const	O
struct	O
Language	struct
*	O
language	pointer
;	O
const	O
char	O
*	O
category	pointer
;	O
char	O
dir_name	array
[	O
128	int
]	O
;	O
struct	O
stat	struct
sbuf	struct
;	O
rdc	pointer
.	O
buf_len	long
=	O
initial_allocation	long
;	O
if	O
(	O
NULL	O
==	O
(	O
rdc	pointer
.	O
buf	pointer
=	O
malloc	function
(	O
rdc	pointer
.	O
buf_len	long
)	O
)	O
)	O
{	O
update_cached_response	function
(	O
NULL	O
)	O
;	O
return	O
;	O
}	O
rdc	pointer
.	O
off	long
=	O
snprintf	function
(	O
rdc	pointer
.	O
buf	pointer
,	O
rdc	pointer
.	O
buf_len	long
,	O
"%s"	pointer
,	O
INDEX_PAGE_HEADER	O
)	O
;	O
for	O
(	O
language_idx	int
=	O
0	int
;	O
NULL	O
!=	O
languages	array
[	O
language_idx	int
]	O
.	O
dirname	pointer
;	O
language_idx	int
++	O
)	O
{	O
language	pointer
=	O
&	O
languages	array
[	O
language_idx	int
]	O
;	O
if	O
(	O
0	int
!=	O
stat	struct
(	O
language	pointer
->	O
dirname	pointer
,	O
&	O
sbuf	struct
)	O
)	O
continue	O
;	O
rdc	pointer
.	O
off	long
+=	O
snprintf	function
(	O
&	O
rdc	pointer
.	O
buf	pointer
[	O
rdc	pointer
.	O
off	long
]	O
,	O
rdc	pointer
.	O
buf_len	long
-	O
rdc	pointer
.	O
off	long
,	O
"<h2>%s</h2>\n"	pointer
,	O
language	pointer
->	O
longname	pointer
)	O
;	O
for	O
(	O
category_idx	int
=	O
0	int
;	O
NULL	O
!=	O
categories	array
[	O
category_idx	int
]	O
;	O
category_idx	int
++	O
)	O
{	O
category	pointer
=	O
categories	array
[	O
category_idx	int
]	O
;	O
snprintf	function
(	O
dir_name	array
,	O
sizeof	O
(	O
dir_name	array
)	O
,	O
"%s/%s"	pointer
,	O
language	pointer
->	O
dirname	pointer
,	O
category	pointer
)	O
;	O
if	O
(	O
0	int
!=	O
stat	struct
(	O
dir_name	array
,	O
&	O
sbuf	struct
)	O
)	O
continue	O
;	O
rdc	pointer
.	O
off	long
+=	O
snprintf	function
(	O
&	O
rdc	pointer
.	O
buf	pointer
[	O
rdc	pointer
.	O
off	long
]	O
,	O
rdc	pointer
.	O
buf_len	long
-	O
rdc	pointer
.	O
off	long
,	O
"<h3>%s</h3>\n"	pointer
,	O
category	pointer
)	O
;	O
if	O
(	O
MHD_NO	int
==	O
list_directory	function
(	O
&	O
rdc	pointer
,	O
dir_name	array
)	O
)	O
{	O
free	function
(	O
rdc	pointer
.	O
buf	pointer
)	O
;	O
update_cached_response	function
(	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
rdc	pointer
.	O
off	long
+=	O
snprintf	function
(	O
&	O
rdc	pointer
.	O
buf	pointer
[	O
rdc	pointer
.	O
off	long
]	O
,	O
rdc	pointer
.	O
buf_len	long
-	O
rdc	pointer
.	O
off	long
,	O
"%s"	pointer
,	O
INDEX_PAGE_FOOTER	pointer
)	O
;	O
initial_allocation	long
=	O
rdc	pointer
.	O
buf_len	long
;	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
rdc	pointer
.	O
off	long
,	O
rdc	pointer
.	O
buf	pointer
,	O
MHD_RESPMEM_MUST_FREE	int
)	O
;	O
mark_as_html	function
(	O
response	pointer
)	O
;	O
update_cached_response	function
(	O
response	pointer
)	O
;	O
}	O
struct	O
UploadContext	struct
{	O
int	O
fd	int
;	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
language	pointer
;	O
char	O
*	O
category	pointer
;	O
struct	O
MHD_PostProcessor	O
*	O
pp	pointer
;	O
struct	O
MHD_Connection	O
*	O
connection	pointer
;	O
struct	O
MHD_Response	O
*	O
response	pointer
;	O
}	O
;	O
static	O
int	O
do_append	function
(	O
char	O
*	O
*	O
ret	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
size	long
)	O
{	O
char	O
*	O
buf	pointer
;	O
size_t	long
old_len	long
;	O
if	O
(	O
NULL	O
==	O
*	O
ret	pointer
)	O
old_len	long
=	O
0	int
;	O
else	O
old_len	long
=	O
strlen	function
(	O
*	O
ret	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
buf	pointer
=	O
malloc	function
(	O
old_len	long
+	O
size	long
+	O
1	int
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
!=	O
*	O
ret	pointer
)	O
{	O
memcpy	function
(	O
buf	pointer
,	O
*	O
ret	pointer
,	O
old_len	long
)	O
;	O
free	function
(	O
*	O
ret	pointer
)	O
;	O
}	O
memcpy	function
(	O
&	O
buf	pointer
[	O
old_len	long
]	O
,	O
data	pointer
,	O
size	long
)	O
;	O
buf	pointer
[	O
old_len	long
+	O
size	long
]	O
=	O
'\0'	O
;	O
*	O
ret	pointer
=	O
buf	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
process_upload_data	function
(	O
void	O
*	O
cls	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
content_type	pointer
,	O
const	O
char	O
*	O
transfer_encoding	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
uint64_t	long
off	long
,	O
size_t	long
size	long
)	O
{	O
struct	O
UploadContext	struct
*	O
uc	pointer
=	O
cls	pointer
;	O
int	O
i	int
;	O
(	O
void	O
)	O
kind	enum
;	O
(	O
void	O
)	O
content_type	pointer
;	O
(	O
void	O
)	O
transfer_encoding	pointer
;	O
(	O
void	O
)	O
off	long
;	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
key	pointer
,	O
"category"	pointer
)	O
)	O
return	O
do_append	function
(	O
&	O
uc	pointer
->	O
category	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
key	pointer
,	O
"language"	pointer
)	O
)	O
return	O
do_append	function
(	O
&	O
uc	pointer
->	O
language	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
if	O
(	O
0	int
!=	O
strcmp	function
(	O
key	pointer
,	O
"upload"	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Ignoring unexpected form value `%s'\n"	pointer
,	O
key	pointer
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
NULL	O
==	O
filename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"No filename, aborting upload\n"	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
NULL	O
==	O
uc	pointer
->	O
category	pointer
)	O
||	O
(	O
NULL	O
==	O
uc	pointer
->	O
language	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Missing form data for upload `%s'\n"	pointer
,	O
filename	pointer
)	O
;	O
uc	pointer
->	O
response	pointer
=	O
request_refused_response	pointer
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
-	O
1	int
==	O
uc	pointer
->	O
fd	int
)	O
{	O
char	O
fn	array
[	O
PATH_MAX	int
]	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
strstr	function
(	O
filename	pointer
,	O
".."	pointer
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
filename	pointer
,	O
'/'	O
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
filename	pointer
,	O
'\\'	O
)	O
)	O
)	O
{	O
uc	pointer
->	O
response	pointer
=	O
request_refused_response	pointer
;	O
return	O
MHD_NO	int
;	O
}	O
(	O
void	O
)	O
mkdir	function
(	O
uc	pointer
->	O
language	pointer
,	O
S_IRWXU	O
)	O
;	O
snprintf	function
(	O
fn	array
,	O
sizeof	O
(	O
fn	array
)	O
,	O
"%s/%s"	pointer
,	O
uc	pointer
->	O
language	pointer
,	O
uc	pointer
->	O
category	pointer
)	O
;	O
(	O
void	O
)	O
mkdir	function
(	O
fn	array
,	O
S_IRWXU	O
)	O
;	O
snprintf	function
(	O
fn	array
,	O
sizeof	O
(	O
fn	array
)	O
,	O
"%s/%s/%s"	pointer
,	O
uc	pointer
->	O
language	pointer
,	O
uc	pointer
->	O
category	pointer
,	O
filename	pointer
)	O
;	O
for	O
(	O
i	int
=	O
strlen	function
(	O
fn	array
)	O
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
!	O
isprint	function
(	O
(	O
unsigned	O
char	O
)	O
fn	array
[	O
i	int
]	O
)	O
)	O
fn	array
[	O
i	int
]	O
=	O
'_'	O
;	O
uc	pointer
->	O
fd	int
=	O
open	function
(	O
fn	array
,	O
O_CREAT	int
|	O
O_EXCL	int
|	O
O_WRONLY	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
if	O
(	O
-	O
1	int
==	O
uc	pointer
->	O
fd	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error opening file `%s' for upload: %s\n"	pointer
,	O
fn	array
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
uc	pointer
->	O
response	pointer
=	O
request_refused_response	pointer
;	O
return	O
MHD_NO	int
;	O
}	O
uc	pointer
->	O
filename	pointer
=	O
strdup	function
(	O
fn	array
)	O
;	O
}	O
if	O
(	O
(	O
0	int
!=	O
size	long
)	O
&&	O
(	O
size	long
!=	O
(	O
size_t	long
)	O
write	pointer
(	O
uc	pointer
->	O
fd	int
,	O
data	pointer
,	O
size	long
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error writing to file `%s': %s\n"	pointer
,	O
uc	pointer
->	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
uc	pointer
->	O
response	pointer
=	O
internal_error_response	pointer
;	O
(	O
void	O
)	O
close	pointer
(	O
uc	pointer
->	O
fd	int
)	O
;	O
uc	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
if	O
(	O
NULL	O
!=	O
uc	pointer
->	O
filename	pointer
)	O
{	O
unlink	function
(	O
uc	pointer
->	O
filename	pointer
)	O
;	O
free	function
(	O
uc	pointer
->	O
filename	pointer
)	O
;	O
uc	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
response_completed_callback	function
(	O
void	O
*	O
cls	pointer
,	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
void	O
*	O
*	O
con_cls	pointer
,	O
enum	O
MHD_RequestTerminationCode	enum
toe	enum
)	O
{	O
struct	O
UploadContext	struct
*	O
uc	pointer
=	O
*	O
con_cls	pointer
;	O
(	O
void	O
)	O
cls	pointer
;	O
(	O
void	O
)	O
connection	pointer
;	O
(	O
void	O
)	O
toe	enum
;	O
if	O
(	O
NULL	O
==	O
uc	pointer
)	O
return	O
;	O
if	O
(	O
NULL	O
!=	O
uc	pointer
->	O
pp	pointer
)	O
{	O
MHD_destroy_post_processor	function
(	O
uc	pointer
->	O
pp	pointer
)	O
;	O
uc	pointer
->	O
pp	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
-	O
1	int
!=	O
uc	pointer
->	O
fd	int
)	O
{	O
(	O
void	O
)	O
close	pointer
(	O
uc	pointer
->	O
fd	int
)	O
;	O
if	O
(	O
NULL	O
!=	O
uc	pointer
->	O
filename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Upload of file `%s' failed (incomplete or aborted), removing file.\n"	pointer
,	O
uc	pointer
->	O
filename	pointer
)	O
;	O
(	O
void	O
)	O
unlink	function
(	O
uc	pointer
->	O
filename	pointer
)	O
;	O
}	O
}	O
if	O
(	O
NULL	O
!=	O
uc	pointer
->	O
filename	pointer
)	O
free	function
(	O
uc	pointer
->	O
filename	pointer
)	O
;	O
free	function
(	O
uc	pointer
)	O
;	O
}	O
static	O
int	O
return_directory_response	function
(	O
struct	O
MHD_Connection	O
*	O
connection	pointer
)	O
{	O
int	O
ret	pointer
;	O
(	O
void	O
)	O
pthread_mutex_lock	function
(	O
&	O
mutex	union
)	O
;	O
if	O
(	O
NULL	O
==	O
cached_directory_response	pointer
)	O
ret	pointer
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_INTERNAL_SERVER_ERROR	int
,	O
internal_error_response	pointer
)	O
;	O
else	O
ret	pointer
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_OK	int
,	O
cached_directory_response	pointer
)	O
;	O
(	O
void	O
)	O
pthread_mutex_unlock	function
(	O
&	O
mutex	union
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
int	O
generate_page	function
(	O
void	O
*	O
cls	pointer
,	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
const	O
char	O
*	O
method	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
const	O
char	O
*	O
upload_data	pointer
,	O
size_t	long
*	O
upload_data_size	pointer
,	O
void	O
*	O
*	O
ptr	pointer
)	O
{	O
struct	O
MHD_Response	O
*	O
response	pointer
;	O
int	O
ret	pointer
;	O
int	O
fd	int
;	O
struct	O
stat	struct
buf	pointer
;	O
(	O
void	O
)	O
cls	pointer
;	O
(	O
void	O
)	O
version	pointer
;	O
if	O
(	O
0	int
!=	O
strcmp	function
(	O
url	pointer
,	O
"/"	pointer
)	O
)	O
{	O
const	O
char	O
*	O
mime	pointer
;	O
if	O
(	O
(	O
0	int
!=	O
strcmp	function
(	O
method	pointer
,	O
MHD_HTTP_METHOD_GET	pointer
)	O
)	O
&&	O
(	O
0	int
!=	O
strcmp	function
(	O
method	pointer
,	O
MHD_HTTP_METHOD_HEAD	pointer
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
fd	int
=	O
-	O
1	int
;	O
if	O
(	O
(	O
NULL	O
==	O
strstr	function
(	O
&	O
url	pointer
[	O
1	int
]	O
,	O
".."	pointer
)	O
)	O
&&	O
(	O
'/'	O
!=	O
url	pointer
[	O
1	int
]	O
)	O
)	O
{	O
fd	int
=	O
open	function
(	O
&	O
url	pointer
[	O
1	int
]	O
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
(	O
-	O
1	int
!=	O
fd	int
)	O
&&	O
(	O
(	O
0	int
!=	O
fstat	function
(	O
fd	int
,	O
&	O
buf	pointer
)	O
)	O
||	O
(	O
!	O
S_ISREG	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
)	O
)	O
{	O
(	O
void	O
)	O
close	pointer
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
-	O
1	int
==	O
fd	int
)	O
return	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_NOT_FOUND	int
,	O
file_not_found_response	pointer
)	O
;	O
mime	pointer
=	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
(	O
response	pointer
=	O
MHD_create_response_from_fd	function
(	O
buf	pointer
.	O
st_size	long
,	O
fd	int
)	O
)	O
)	O
{	O
(	O
void	O
)	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
NULL	O
!=	O
mime	pointer
)	O
(	O
void	O
)	O
MHD_add_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONTENT_TYPE	pointer
,	O
mime	pointer
)	O
;	O
ret	pointer
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_OK	int
,	O
response	pointer
)	O
;	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
method	pointer
,	O
MHD_HTTP_METHOD_POST	pointer
)	O
)	O
{	O
struct	O
UploadContext	struct
*	O
uc	pointer
=	O
*	O
ptr	pointer
;	O
if	O
(	O
NULL	O
==	O
uc	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
(	O
uc	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
UploadContext	struct
)	O
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
memset	function
(	O
uc	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
UploadContext	struct
)	O
)	O
;	O
uc	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
uc	pointer
->	O
connection	pointer
=	O
connection	pointer
;	O
uc	pointer
->	O
pp	pointer
=	O
MHD_create_post_processor	function
(	O
connection	pointer
,	O
64	int
*	O
1024	int
,	O
&	O
process_upload_data	function
,	O
uc	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
uc	pointer
->	O
pp	pointer
)	O
{	O
free	function
(	O
uc	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
*	O
ptr	pointer
=	O
uc	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
0	int
!=	O
*	O
upload_data_size	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
uc	pointer
->	O
response	pointer
)	O
(	O
void	O
)	O
MHD_post_process	function
(	O
uc	pointer
->	O
pp	pointer
,	O
upload_data	pointer
,	O
*	O
upload_data_size	pointer
)	O
;	O
*	O
upload_data_size	pointer
=	O
0	int
;	O
return	O
MHD_YES	int
;	O
}	O
MHD_destroy_post_processor	function
(	O
uc	pointer
->	O
pp	pointer
)	O
;	O
uc	pointer
->	O
pp	pointer
=	O
NULL	O
;	O
if	O
(	O
-	O
1	int
!=	O
uc	pointer
->	O
fd	int
)	O
{	O
close	pointer
(	O
uc	pointer
->	O
fd	int
)	O
;	O
uc	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
NULL	O
!=	O
uc	pointer
->	O
response	pointer
)	O
{	O
return	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_FORBIDDEN	int
,	O
uc	pointer
->	O
response	pointer
)	O
;	O
}	O
else	O
{	O
update_directory	function
(	O
)	O
;	O
return	O
return_directory_response	function
(	O
connection	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
0	int
==	O
strcmp	function
(	O
method	pointer
,	O
MHD_HTTP_METHOD_GET	pointer
)	O
)	O
||	O
(	O
0	int
==	O
strcmp	function
(	O
method	pointer
,	O
MHD_HTTP_METHOD_HEAD	pointer
)	O
)	O
)	O
{	O
return	O
return_directory_response	function
(	O
connection	pointer
)	O
;	O
}	O
return	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_FORBIDDEN	int
,	O
request_refused_response	pointer
)	O
;	O
}	O
static	O
void	O
catcher	function
(	O
int	O
sig	int
)	O
{	O
(	O
void	O
)	O
sig	int
;	O
}	O
static	O
void	O
ignore_sigpipe	function
(	O
)	O
{	O
struct	O
sigaction	struct
oldsig	struct
;	O
struct	O
sigaction	struct
sig	int
;	O
sig	int
.	O
sa_handler	pointer
=	O
&	O
catcher	function
;	O
sigemptyset	function
(	O
&	O
sig	int
.	O
sa_mask	struct
)	O
;	O
sig	int
.	O
sa_flags	int
=	O
SA_INTERRUPT	int
;	O
if	O
(	O
0	int
!=	O
sigaction	struct
(	O
SIGPIPE	int
,	O
&	O
sig	int
,	O
&	O
oldsig	struct
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to install SIGPIPE handler: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
const	O
*	O
argv	pointer
)	O
{	O
struct	O
MHD_Daemon	O
*	O
d	pointer
;	O
unsigned	O
int	O
port	short
;	O
if	O
(	O
(	O
argc	int
!=	O
2	int
)	O
||	O
(	O
1	int
!=	O
sscanf	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"%u"	pointer
,	O
&	O
port	short
)	O
)	O
||	O
(	O
UINT16_MAX	O
<	O
port	short
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s PORT\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
ignore_sigpipe	function
(	O
)	O
;	O
(	O
void	O
)	O
pthread_mutex_init	function
(	O
&	O
mutex	union
,	O
NULL	O
)	O
;	O
file_not_found_response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
FILE_NOT_FOUND_PAGE	pointer
)	O
,	O
(	O
void	O
*	O
)	O
FILE_NOT_FOUND_PAGE	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
mark_as_html	function
(	O
file_not_found_response	pointer
)	O
;	O
request_refused_response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
REQUEST_REFUSED_PAGE	pointer
)	O
,	O
(	O
void	O
*	O
)	O
REQUEST_REFUSED_PAGE	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
mark_as_html	function
(	O
request_refused_response	pointer
)	O
;	O
internal_error_response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
INTERNAL_ERROR_PAGE	pointer
)	O
,	O
(	O
void	O
*	O
)	O
INTERNAL_ERROR_PAGE	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
mark_as_html	function
(	O
internal_error_response	pointer
)	O
;	O
update_directory	function
(	O
)	O
;	O
d	pointer
=	O
MHD_start_daemon	function
(	O
MHD_USE_AUTO	int
|	O
MHD_USE_INTERNAL_POLLING_THREAD	int
|	O
MHD_USE_ERROR_LOG	int
,	O
port	short
,	O
NULL	O
,	O
NULL	O
,	O
&	O
generate_page	function
,	O
NULL	O
,	O
MHD_OPTION_CONNECTION_MEMORY_LIMIT	int
,	O
(	O
size_t	long
)	O
(	O
256	int
*	O
1024	int
)	O
,	O
MHD_OPTION_CONNECTION_TIMEOUT	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
120	int
)	O
,	O
MHD_OPTION_THREAD_POOL_SIZE	int
,	O
(	O
unsigned	O
int	O
)	O
NUMBER_OF_THREADS	O
,	O
MHD_OPTION_NOTIFY_COMPLETED	int
,	O
&	O
response_completed_callback	function
,	O
NULL	O
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
NULL	O
==	O
d	pointer
)	O
return	O
1	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"HTTP server running. Press ENTER to stop the server\n"	pointer
)	O
;	O
(	O
void	O
)	O
getc	function
(	O
stdin	pointer
)	O
;	O
MHD_stop_daemon	function
(	O
d	pointer
)	O
;	O
MHD_destroy_response	function
(	O
file_not_found_response	pointer
)	O
;	O
MHD_destroy_response	function
(	O
request_refused_response	pointer
)	O
;	O
MHD_destroy_response	function
(	O
internal_error_response	pointer
)	O
;	O
update_cached_response	function
(	O
NULL	O
)	O
;	O
(	O
void	O
)	O
pthread_mutex_destroy	function
(	O
&	O
mutex	union
)	O
;	O
return	O
0	int
;	O
}	O
