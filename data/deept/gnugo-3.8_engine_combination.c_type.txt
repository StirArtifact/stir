static	O
void	O
find_double_threats	function
(	O
int	O
color	int
)	O
;	O
void	O
combinations	function
(	O
int	O
color	int
)	O
{	O
int	O
save_verbose	int
;	O
int	O
attack_point	pointer
;	O
signed	O
char	O
defense_points	array
[	O
BOARDMAX	O
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
aa_val	int
;	O
find_double_threats	function
(	O
color	int
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"\nlooking for combination attacks ...\n"	pointer
)	O
;	O
aa_val	int
=	O
atari_atari	function
(	O
color	int
,	O
&	O
attack_point	pointer
,	O
NULL	O
,	O
save_verbose	int
)	O
;	O
if	O
(	O
aa_val	int
>	O
0	int
)	O
{	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"Combination attack for %C with size %d found at %1m\n"	pointer
,	O
color	int
,	O
aa_val	int
,	O
attack_point	pointer
)	O
;	O
add_my_atari_atari_move	function
(	O
attack_point	pointer
,	O
aa_val	int
)	O
;	O
}	O
aa_val	int
=	O
atari_atari	function
(	O
other	int
,	O
&	O
attack_point	pointer
,	O
defense_points	array
,	O
save_verbose	int
)	O
;	O
if	O
(	O
aa_val	int
>	O
0	int
)	O
{	O
int	O
pos	int
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"Combination attack for %C with size %d found at %1m\n"	pointer
,	O
other	int
,	O
aa_val	int
,	O
attack_point	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
defense_points	array
[	O
pos	int
]	O
)	O
{	O
add_your_atari_atari_move	function
(	O
pos	int
,	O
aa_val	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"- defense at %1m\n"	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
void	O
find_double_threats	function
(	O
int	O
color	int
)	O
{	O
int	O
ii	int
;	O
int	O
k	int
;	O
int	O
l	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
int	O
num_a_threatened_groups	int
;	O
int	O
a_threatened_groups	array
[	O
MAX_THREATENED_STRINGS	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
continue	O
;	O
num_a_threatened_groups	int
=	O
get_attack_threats	function
(	O
ii	int
,	O
MAX_THREATENED_STRINGS	int
,	O
a_threatened_groups	array
)	O
;	O
if	O
(	O
num_a_threatened_groups	int
>	O
1	int
)	O
{	O
if	O
(	O
trymove	function
(	O
ii	int
,	O
color	int
,	O
"find_double_threats-A"	pointer
,	O
ii	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_a_threatened_groups	int
-	O
1	int
;	O
++	O
k	int
)	O
for	O
(	O
l	int
=	O
k	int
+	O
1	int
;	O
l	int
<	O
num_a_threatened_groups	int
;	O
++	O
l	int
)	O
{	O
if	O
(	O
board	pointer
[	O
a_threatened_groups	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
a_threatened_groups	array
[	O
l	int
]	O
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
!	O
attack	function
(	O
ii	int
,	O
NULL	O
)	O
)	O
{	O
TRACE	O
(	O
"Double threat at %1m, either %1m or %1m attacked.\n"	pointer
,	O
ii	int
,	O
a_threatened_groups	array
[	O
k	int
]	O
,	O
a_threatened_groups	array
[	O
l	int
]	O
)	O
;	O
add_either_move	function
(	O
ii	int
,	O
ATTACK_STRING	int
,	O
a_threatened_groups	array
[	O
k	int
]	O
,	O
ATTACK_STRING	int
,	O
a_threatened_groups	array
[	O
l	int
]	O
)	O
;	O
remove_attack_threat_move	function
(	O
ii	int
,	O
a_threatened_groups	array
[	O
k	int
]	O
)	O
;	O
remove_attack_threat_move	function
(	O
ii	int
,	O
a_threatened_groups	array
[	O
l	int
]	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
defend_both	function
(	O
a_threatened_groups	array
[	O
k	int
]	O
,	O
a_threatened_groups	array
[	O
l	int
]	O
)	O
)	O
{	O
TRACE	O
(	O
"Double threat at %1m, either %1m or %1m attacked.\n"	pointer
,	O
ii	int
,	O
a_threatened_groups	array
[	O
k	int
]	O
,	O
a_threatened_groups	array
[	O
l	int
]	O
)	O
;	O
add_either_move	function
(	O
ii	int
,	O
ATTACK_STRING	int
,	O
a_threatened_groups	array
[	O
k	int
]	O
,	O
ATTACK_STRING	int
,	O
a_threatened_groups	array
[	O
l	int
]	O
)	O
;	O
remove_attack_threat_move	function
(	O
ii	int
,	O
a_threatened_groups	array
[	O
k	int
]	O
)	O
;	O
remove_attack_threat_move	function
(	O
ii	int
,	O
a_threatened_groups	array
[	O
l	int
]	O
)	O
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
struct	O
aa_move	struct
{	O
int	O
move	pointer
;	O
int	O
target	int
[	O
AA_MAX_TARGETS_PER_MOVE	int
]	O
;	O
}	O
;	O
static	O
int	O
aa_status	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
forbidden	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
aa_values	array
[	O
BOARDMAX	O
]	O
;	O
static	O
void	O
compute_aa_status	function
(	O
int	O
color	int
,	O
const	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
compute_aa_values	function
(	O
int	O
color	int
)	O
;	O
static	O
int	O
get_aa_status	function
(	O
int	O
pos	int
)	O
;	O
static	O
int	O
do_atari_atari	function
(	O
int	O
color	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
signed	O
char	O
all_potential_defenses	array
[	O
BOARDMAX	O
]	O
,	O
int	O
last_friendly	int
,	O
int	O
save_verbose	int
,	O
int	O
minsize	int
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
atari_atari_succeeded	function
(	O
int	O
color	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
int	O
last_friendly	int
,	O
int	O
save_verbose	int
,	O
int	O
minsize	int
)	O
;	O
static	O
void	O
atari_atari_find_attack_moves	function
(	O
int	O
color	int
,	O
int	O
minsize	int
,	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
atari_atari_attack_patterns	function
(	O
int	O
color	int
,	O
int	O
minsize	int
,	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
atari_atari_attack_callback	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
;	O
static	O
int	O
atari_atari_find_defense_moves	function
(	O
int	O
targets	array
[	O
AA_MAX_TARGETS_PER_MOVE	int
]	O
,	O
int	O
moves	array
[	O
AA_MAX_MOVES	O
]	O
)	O
;	O
static	O
int	O
get_aa_value	function
(	O
int	O
str	int
)	O
;	O
static	O
int	O
update_aa_goal	function
(	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
new_goal	array
[	O
BOARDMAX	O
]	O
,	O
int	O
apos	int
,	O
int	O
color	int
)	O
;	O
static	O
void	O
aa_init_moves	function
(	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
)	O
;	O
static	O
void	O
aa_add_move	function
(	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
,	O
int	O
move	pointer
,	O
int	O
target	int
)	O
;	O
static	O
int	O
aa_move_known	function
(	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
,	O
int	O
move	pointer
,	O
int	O
target	int
)	O
;	O
static	O
void	O
aa_sort_moves	function
(	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
)	O
;	O
int	O
atari_atari	function
(	O
int	O
color	int
,	O
int	O
*	O
attack_move	pointer
,	O
signed	O
char	O
defense_moves	array
[	O
BOARDMAX	O
]	O
,	O
int	O
save_verbose	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
apos	int
;	O
int	O
dpos	int
;	O
int	O
aa_val	int
;	O
signed	O
char	O
saved_defense_moves	array
[	O
BOARDMAX	O
]	O
;	O
if	O
(	O
aa_depth	int
<	O
2	int
)	O
return	O
0	int
;	O
memset	function
(	O
forbidden	array
,	O
0	int
,	O
sizeof	O
(	O
forbidden	array
)	O
)	O
;	O
compute_aa_status	function
(	O
color	int
,	O
NULL	O
)	O
;	O
compute_aa_values	function
(	O
color	int
)	O
;	O
if	O
(	O
defense_moves	array
)	O
memset	function
(	O
defense_moves	array
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
aa_val	int
=	O
do_atari_atari	function
(	O
color	int
,	O
&	O
apos	int
,	O
&	O
dpos	int
,	O
defense_moves	array
,	O
NO_MOVE	O
,	O
save_verbose	int
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
aa_val	int
==	O
0	int
)	O
return	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
new_aa_val	int
;	O
if	O
(	O
attack_move	pointer
)	O
*	O
attack_move	pointer
=	O
apos	int
;	O
forbidden	array
[	O
apos	int
]	O
=	O
1	int
;	O
if	O
(	O
defense_moves	array
)	O
{	O
memcpy	function
(	O
saved_defense_moves	array
,	O
defense_moves	array
,	O
BOARDMAX	O
)	O
;	O
memset	function
(	O
defense_moves	array
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
}	O
new_aa_val	int
=	O
do_atari_atari	function
(	O
color	int
,	O
&	O
apos	int
,	O
&	O
dpos	int
,	O
defense_moves	array
,	O
NO_MOVE	O
,	O
save_verbose	int
,	O
aa_val	int
,	O
NULL	O
)	O
;	O
if	O
(	O
new_aa_val	int
==	O
0	int
)	O
break	O
;	O
else	O
aa_val	int
=	O
new_aa_val	int
;	O
}	O
if	O
(	O
defense_moves	array
)	O
{	O
int	O
pos	int
;	O
memcpy	function
(	O
defense_moves	array
,	O
saved_defense_moves	array
,	O
BOARDMAX	O
)	O
;	O
forbidden	array
[	O
apos	int
]	O
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
!	O
defense_moves	array
[	O
pos	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
trymove	function
(	O
pos	int
,	O
other	int
,	O
"atari_atari"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
defense_moves	array
[	O
pos	int
]	O
=	O
0	int
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"%1m deleted defense point, illegal\n"	pointer
,	O
pos	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
attack	function
(	O
pos	int
,	O
NULL	O
)	O
)	O
{	O
defense_moves	array
[	O
pos	int
]	O
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"%1m deleted defense point, unsafe\n"	pointer
,	O
pos	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
do_atari_atari	function
(	O
color	int
,	O
&	O
apos	int
,	O
&	O
dpos	int
,	O
NULL	O
,	O
NO_MOVE	O
,	O
save_verbose	int
,	O
aa_val	int
,	O
NULL	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"%1m deleted defense point, didn't work\n"	pointer
,	O
pos	int
)	O
;	O
defense_moves	array
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
return	O
aa_val	int
;	O
}	O
int	O
atari_atari_confirm_safety	function
(	O
int	O
color	int
,	O
int	O
move	pointer
,	O
int	O
*	O
defense	pointer
,	O
int	O
minsize	int
,	O
const	O
signed	O
char	O
saved_dragons	array
[	O
BOARDMAX	O
]	O
,	O
const	O
signed	O
char	O
saved_worms	array
[	O
BOARDMAX	O
]	O
)	O
{	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
defense_moves	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
blunder_size	function
;	O
mark_safe_stones	function
(	O
color	int
,	O
move	pointer
,	O
saved_dragons	array
,	O
saved_worms	array
,	O
safe_stones	array
)	O
;	O
blunder_size	function
=	O
atari_atari_blunder_size	function
(	O
color	int
,	O
move	pointer
,	O
defense_moves	array
,	O
safe_stones	array
)	O
;	O
if	O
(	O
defense	pointer
)	O
{	O
*	O
defense	pointer
=	O
NO_MOVE	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
defense_moves	array
[	O
pos	int
]	O
)	O
{	O
*	O
defense	pointer
=	O
pos	int
;	O
break	O
;	O
}	O
}	O
return	O
blunder_size	function
>=	O
minsize	int
;	O
}	O
int	O
atari_atari_blunder_size	function
(	O
int	O
color	int
,	O
int	O
move	pointer
,	O
signed	O
char	O
defense_moves	array
[	O
BOARDMAX	O
]	O
,	O
const	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
apos	int
;	O
int	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
int	O
aa_val	int
,	O
after_aa_val	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
signed	O
char	O
defense_points	array
[	O
BOARDMAX	O
]	O
;	O
int	O
last_forbidden	int
=	O
NO_MOVE	O
;	O
if	O
(	O
aa_depth	int
<	O
2	int
)	O
return	O
0	int
;	O
memset	function
(	O
forbidden	array
,	O
0	int
,	O
sizeof	O
(	O
forbidden	array
)	O
)	O
;	O
memset	function
(	O
defense_points	array
,	O
0	int
,	O
sizeof	O
(	O
defense_points	array
)	O
)	O
;	O
compute_aa_status	function
(	O
other	int
,	O
safe_stones	array
)	O
;	O
compute_aa_values	function
(	O
other	int
)	O
;	O
if	O
(	O
!	O
tryko	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
)	O
)	O
abortgo	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
"trymove"	pointer
,	O
move	pointer
)	O
;	O
increase_depth_values	function
(	O
)	O
;	O
aa_val	int
=	O
do_atari_atari	function
(	O
other	int
,	O
&	O
apos	int
,	O
&	O
defense_point	pointer
,	O
defense_points	array
,	O
NO_MOVE	O
,	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
after_aa_val	int
=	O
aa_val	int
;	O
if	O
(	O
aa_val	int
==	O
0	int
||	O
defense_point	pointer
==	O
NO_MOVE	O
)	O
{	O
popgo	function
(	O
)	O
;	O
decrease_depth_values	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
aa_val	int
>=	O
after_aa_val	int
&&	O
defense_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
forbidden	array
[	O
apos	int
]	O
=	O
1	int
;	O
last_forbidden	int
=	O
apos	int
;	O
aa_val	int
=	O
do_atari_atari	function
(	O
other	int
,	O
&	O
apos	int
,	O
&	O
defense_point	pointer
,	O
NULL	O
,	O
NO_MOVE	O
,	O
0	int
,	O
aa_val	int
,	O
NULL	O
)	O
;	O
}	O
popgo	function
(	O
)	O
;	O
decrease_depth_values	function
(	O
)	O
;	O
compute_aa_status	function
(	O
other	int
,	O
NULL	O
)	O
;	O
compute_aa_values	function
(	O
other	int
)	O
;	O
forbidden	array
[	O
last_forbidden	int
]	O
=	O
0	int
;	O
aa_val	int
=	O
do_atari_atari	function
(	O
other	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_MOVE	O
,	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
aa_val	int
>=	O
after_aa_val	int
)	O
return	O
0	int
;	O
if	O
(	O
defense_moves	array
)	O
{	O
int	O
pos	int
;	O
compute_aa_status	function
(	O
other	int
,	O
safe_stones	array
)	O
;	O
compute_aa_values	function
(	O
other	int
)	O
;	O
memcpy	function
(	O
defense_moves	array
,	O
defense_points	array
,	O
sizeof	O
(	O
defense_points	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
!	O
defense_moves	array
[	O
pos	int
]	O
||	O
pos	int
==	O
move	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
"atari_atari"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
defense_moves	array
[	O
pos	int
]	O
=	O
0	int
;	O
continue	O
;	O
}	O
increase_depth_values	function
(	O
)	O
;	O
if	O
(	O
attack	function
(	O
pos	int
,	O
NULL	O
)	O
)	O
{	O
defense_moves	array
[	O
pos	int
]	O
=	O
0	int
;	O
decrease_depth_values	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
tryko	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
)	O
)	O
abortgo	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
"trymove"	pointer
,	O
move	pointer
)	O
;	O
increase_depth_values	function
(	O
)	O
;	O
if	O
(	O
do_atari_atari	function
(	O
other	int
,	O
&	O
apos	int
,	O
&	O
defense_point	pointer
,	O
NULL	O
,	O
NO_MOVE	O
,	O
0	int
,	O
after_aa_val	int
,	O
NULL	O
)	O
>=	O
after_aa_val	int
)	O
defense_moves	array
[	O
pos	int
]	O
=	O
0	int
;	O
decrease_depth_values	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
decrease_depth_values	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
}	O
return	O
after_aa_val	int
-	O
aa_val	int
;	O
}	O
static	O
void	O
compute_aa_status	function
(	O
int	O
color	int
,	O
const	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
gg_assert	O
(	O
safe_stones	array
||	O
stackp	int
==	O
0	int
)	O
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
verbose	int
)	O
verbose	int
--	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
)	O
{	O
if	O
(	O
safe_stones	array
)	O
{	O
if	O
(	O
safe_stones	array
[	O
pos	int
]	O
)	O
aa_status	array
[	O
pos	int
]	O
=	O
ALIVE	int
;	O
else	O
aa_status	array
[	O
pos	int
]	O
=	O
DEAD	int
;	O
}	O
else	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
aa_status	array
[	O
pos	int
]	O
=	O
DEAD	int
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
CRITICAL	int
)	O
aa_status	array
[	O
pos	int
]	O
=	O
CRITICAL	int
;	O
else	O
if	O
(	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
worm	array
[	O
pos	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
!=	O
0	int
)	O
aa_status	array
[	O
pos	int
]	O
=	O
CRITICAL	int
;	O
else	O
aa_status	array
[	O
pos	int
]	O
=	O
DEAD	int
;	O
}	O
else	O
aa_status	array
[	O
pos	int
]	O
=	O
ALIVE	int
;	O
}	O
}	O
else	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
aa_status	array
[	O
pos	int
]	O
=	O
UNKNOWN	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
find_origin	function
(	O
pos	int
)	O
==	O
pos	int
&&	O
countlib	function
(	O
pos	int
)	O
==	O
2	int
&&	O
aa_status	array
[	O
pos	int
]	O
==	O
ALIVE	int
)	O
{	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
findlib	function
(	O
pos	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
is_self_atari	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
color	int
)	O
&&	O
is_self_atari	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
color	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
owl_substantial	function
(	O
pos	int
)	O
)	O
{	O
int	O
pos2	int
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
other	int
&&	O
find_origin	function
(	O
pos2	int
)	O
==	O
pos	int
)	O
aa_status	array
[	O
pos2	int
]	O
=	O
INSUBSTANTIAL	int
;	O
}	O
}	O
}	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
{	O
gprintf	function
(	O
"compute_aa_status() for %C\n"	pointer
,	O
color	int
)	O
;	O
gprintf	function
(	O
"aa_status: (ALIVE worms not listed)\n"	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
is_worm_origin	function
(	O
pos	int
,	O
pos	int
)	O
)	O
{	O
const	O
char	O
*	O
status	enum
=	O
"UNKNOWN (shouldn't happen)"	pointer
;	O
if	O
(	O
aa_status	array
[	O
pos	int
]	O
==	O
DEAD	int
)	O
status	enum
=	O
"DEAD"	pointer
;	O
else	O
if	O
(	O
aa_status	array
[	O
pos	int
]	O
==	O
CRITICAL	int
)	O
status	enum
=	O
"CRITICAL"	pointer
;	O
else	O
if	O
(	O
aa_status	array
[	O
pos	int
]	O
==	O
INSUBSTANTIAL	int
)	O
status	enum
=	O
"INSUBSTANTIAL"	pointer
;	O
if	O
(	O
aa_status	array
[	O
pos	int
]	O
!=	O
ALIVE	int
)	O
gprintf	function
(	O
"%1M: %s\n"	pointer
,	O
pos	int
,	O
status	enum
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
int	O
get_aa_status	function
(	O
int	O
pos	int
)	O
{	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_stones	int
;	O
int	O
k	int
;	O
if	O
(	O
aa_status	array
[	O
pos	int
]	O
!=	O
UNKNOWN	int
)	O
return	O
aa_status	array
[	O
pos	int
]	O
;	O
num_stones	int
=	O
findstones	function
(	O
pos	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
if	O
(	O
aa_status	array
[	O
stones	pointer
[	O
k	int
]	O
]	O
!=	O
UNKNOWN	int
)	O
return	O
aa_status	array
[	O
stones	pointer
[	O
k	int
]	O
]	O
;	O
return	O
UNKNOWN	int
;	O
}	O
static	O
int	O
do_atari_atari	function
(	O
int	O
color	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
signed	O
char	O
all_potential_defenses	array
[	O
BOARDMAX	O
]	O
,	O
int	O
last_friendly	int
,	O
int	O
save_verbose	int
,	O
int	O
minsize	int
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
;	O
int	O
num_defense_moves	int
;	O
int	O
defense_moves	array
[	O
AA_MAX_MOVES	O
]	O
;	O
int	O
pos	int
;	O
SGFTree	struct
*	O
save_sgf_dumptree	pointer
;	O
int	O
save_count_variations	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
{	O
gprintf	function
(	O
"%odo_atari_atari: "	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
gprintf	function
(	O
"%oforbidden moves: "	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
forbidden	array
[	O
pos	int
]	O
)	O
gprintf	function
(	O
"%o%1m "	pointer
,	O
pos	int
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
gprintf	function
(	O
"%ogoal: "	pointer
)	O
;	O
if	O
(	O
!	O
goal	pointer
)	O
gprintf	function
(	O
"none"	pointer
)	O
;	O
else	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	pointer
[	O
pos	int
]	O
)	O
gprintf	function
(	O
"%o%1m "	pointer
,	O
pos	int
)	O
;	O
}	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
last_friendly	int
!=	O
NO_MOVE	O
)	O
{	O
int	O
retval	int
;	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
retval	int
=	O
atari_atari_succeeded	function
(	O
color	int
,	O
attack_point	pointer
,	O
defense_point	pointer
,	O
last_friendly	int
,	O
save_verbose	int
,	O
minsize	int
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
if	O
(	O
retval	int
!=	O
0	int
)	O
{	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"attack found"	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
}	O
if	O
(	O
stackp	int
>	O
aa_depth	int
)	O
return	O
0	int
;	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
atari_atari_find_attack_moves	function
(	O
color	int
,	O
minsize	int
,	O
attacks	array
,	O
goal	pointer
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
!=	O
NO_MOVE	O
;	O
k	int
++	O
)	O
{	O
int	O
aa_val	int
;	O
int	O
str	int
=	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
0	int
]	O
;	O
int	O
apos	int
=	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
;	O
int	O
bpos	int
;	O
int	O
r	int
;	O
if	O
(	O
!	O
trymove	function
(	O
apos	int
,	O
color	int
,	O
"do_atari_atari-A"	pointer
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
all_potential_defenses	array
)	O
{	O
all_potential_defenses	array
[	O
apos	int
]	O
=	O
1	int
;	O
if	O
(	O
countlib	function
(	O
apos	int
)	O
<=	O
2	int
)	O
{	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
num_libs	int
=	O
findlib	function
(	O
apos	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
all_potential_defenses	array
[	O
libs	pointer
[	O
0	int
]	O
]	O
=	O
1	int
;	O
if	O
(	O
num_libs	int
==	O
2	int
)	O
all_potential_defenses	array
[	O
libs	pointer
[	O
1	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
)	O
{	O
if	O
(	O
save_verbose	int
||	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
)	O
gprintf	function
(	O
"%oError condition found by atari_atari\n"	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
aa_val	int
=	O
get_aa_value	function
(	O
str	int
)	O
;	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
num_defense_moves	int
=	O
atari_atari_find_defense_moves	function
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
,	O
defense_moves	array
)	O
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_defense_moves	int
;	O
r	int
++	O
)	O
{	O
bpos	int
=	O
defense_moves	array
[	O
r	int
]	O
;	O
if	O
(	O
all_potential_defenses	array
)	O
all_potential_defenses	array
[	O
bpos	int
]	O
=	O
1	int
;	O
if	O
(	O
trymove	function
(	O
bpos	int
,	O
other	int
,	O
"do_atari_atari-B"	pointer
,	O
str	int
)	O
)	O
{	O
int	O
new_aa_val	int
;	O
signed	O
char	O
new_goal	array
[	O
BOARDMAX	O
]	O
;	O
modify_depth_values	function
(	O
2	int
)	O
;	O
update_aa_goal	function
(	O
goal	pointer
,	O
new_goal	array
,	O
apos	int
,	O
color	int
)	O
;	O
new_aa_val	int
=	O
do_atari_atari	function
(	O
color	int
,	O
NULL	O
,	O
defense_point	pointer
,	O
all_potential_defenses	array
,	O
apos	int
,	O
save_verbose	int
,	O
minsize	int
,	O
new_goal	array
)	O
;	O
modify_depth_values	function
(	O
-	O
2	int
)	O
;	O
if	O
(	O
new_aa_val	int
<	O
aa_val	int
)	O
aa_val	int
=	O
new_aa_val	int
;	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
aa_val	int
==	O
0	int
)	O
break	O
;	O
}	O
popgo	function
(	O
)	O
;	O
if	O
(	O
aa_val	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
num_defense_moves	int
==	O
0	int
)	O
{	O
if	O
(	O
save_verbose	int
||	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
)	O
{	O
gprintf	function
(	O
"%oThe worm %1m can be attacked at %1m after "	pointer
,	O
str	int
,	O
apos	int
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	pointer
)	O
sgftreeAddComment	function
(	O
sgf_dumptree	pointer
,	O
"attack found"	pointer
)	O
;	O
}	O
if	O
(	O
attack_point	pointer
)	O
*	O
attack_point	pointer
=	O
apos	int
;	O
if	O
(	O
defense_point	pointer
)	O
{	O
save_sgf_dumptree	pointer
=	O
sgf_dumptree	pointer
;	O
save_count_variations	int
=	O
count_variations	int
;	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
!	O
find_defense	function
(	O
str	int
,	O
defense_point	pointer
)	O
)	O
*	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
(	O
*	O
defense_point	pointer
==	O
NO_MOVE	O
||	O
!	O
safe_move	function
(	O
*	O
defense_point	pointer
,	O
other	int
)	O
)	O
&&	O
safe_move	function
(	O
apos	int
,	O
other	int
)	O
)	O
*	O
defense_point	pointer
=	O
apos	int
;	O
sgf_dumptree	pointer
=	O
save_sgf_dumptree	pointer
;	O
count_variations	int
=	O
save_count_variations	int
;	O
}	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"%oreturn value:%d (%1m)\n"	pointer
,	O
aa_val	int
,	O
str	int
)	O
;	O
return	O
aa_val	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
atari_atari_succeeded	function
(	O
int	O
color	int
,	O
int	O
*	O
attack_point	pointer
,	O
int	O
*	O
defense_point	pointer
,	O
int	O
last_friendly	int
,	O
int	O
save_verbose	int
,	O
int	O
minsize	int
)	O
{	O
int	O
pos	int
;	O
int	O
apos	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
if	O
(	O
pos	int
!=	O
find_origin	function
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
minsize	int
>	O
0	int
&&	O
get_aa_value	function
(	O
pos	int
)	O
<	O
minsize	int
)	O
continue	O
;	O
if	O
(	O
get_aa_status	function
(	O
pos	int
)	O
!=	O
ALIVE	int
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
last_friendly	int
]	O
!=	O
EMPTY	int
&&	O
!	O
adjacent_strings	function
(	O
last_friendly	int
,	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
last_friendly	int
]	O
==	O
EMPTY	int
&&	O
!	O
liberty_of_string	function
(	O
last_friendly	int
,	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
gprintf	function
(	O
"Considering attack of %1m. depth = %d.\n"	pointer
,	O
pos	int
,	O
depth	int
)	O
;	O
if	O
(	O
attack	function
(	O
pos	int
,	O
&	O
apos	int
)	O
&&	O
!	O
forbidden	array
[	O
apos	int
]	O
)	O
{	O
if	O
(	O
save_verbose	int
||	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
)	O
{	O
gprintf	function
(	O
"%oThe worm %1m can be attacked at %1m after "	pointer
,	O
pos	int
,	O
apos	int
)	O
;	O
dump_stack	function
(	O
)	O
;	O
}	O
if	O
(	O
attack_point	pointer
)	O
*	O
attack_point	pointer
=	O
apos	int
;	O
if	O
(	O
defense_point	pointer
)	O
{	O
if	O
(	O
!	O
find_defense	function
(	O
pos	int
,	O
defense_point	pointer
)	O
)	O
{	O
if	O
(	O
safe_move	function
(	O
apos	int
,	O
other	int
)	O
)	O
*	O
defense_point	pointer
=	O
apos	int
;	O
else	O
*	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
}	O
}	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"%oreturn value:%d (%1m)\n"	pointer
,	O
get_aa_value	function
(	O
pos	int
)	O
,	O
pos	int
)	O
;	O
return	O
get_aa_value	function
(	O
pos	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
atari_atari_find_attack_moves	function
(	O
int	O
color	int
,	O
int	O
minsize	int
,	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
aa_init_moves	function
(	O
attacks	array
)	O
;	O
atari_atari_attack_patterns	function
(	O
color	int
,	O
minsize	int
,	O
attacks	array
,	O
goal	pointer
)	O
;	O
aa_sort_moves	function
(	O
attacks	array
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
{	O
gprintf	function
(	O
"Attack moves:"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
AA_MAX_MOVES	O
&&	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
!=	O
NO_MOVE	O
;	O
k	int
++	O
)	O
{	O
gprintf	function
(	O
"%o %1m("	pointer
,	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
gprintf	function
(	O
"%o%s%1m"	pointer
,	O
r	int
==	O
0	int
?	O
""	pointer
:	O
","	pointer
,	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
)	O
;	O
}	O
gprintf	function
(	O
"%o)"	pointer
)	O
;	O
}	O
gprintf	function
(	O
"%o\n"	pointer
)	O
;	O
}	O
}	O
static	O
int	O
current_minsize	int
;	O
static	O
struct	O
aa_move	struct
*	O
current_attacks	pointer
;	O
static	O
int	O
conditional_attack_point	array
[	O
BOARDMAX	O
]	O
;	O
static	O
void	O
atari_atari_attack_patterns	function
(	O
int	O
color	int
,	O
int	O
minsize	int
,	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
,	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
)	O
{	O
signed	O
char	O
revised_goal	array
[	O
BOARDMAX	O
]	O
;	O
current_minsize	int
=	O
minsize	int
;	O
current_attacks	pointer
=	O
attacks	array
;	O
memset	function
(	O
conditional_attack_point	array
,	O
0	int
,	O
sizeof	O
(	O
conditional_attack_point	array
)	O
)	O
;	O
if	O
(	O
goal	pointer
==	O
NULL	O
&&	O
update_aa_goal	function
(	O
goal	pointer
,	O
revised_goal	array
,	O
NO_MOVE	O
,	O
color	int
)	O
)	O
goal	pointer
=	O
revised_goal	array
;	O
matchpat	function
(	O
atari_atari_attack_callback	function
,	O
color	int
,	O
&	O
aa_attackpat_db	struct
,	O
NULL	O
,	O
goal	pointer
)	O
;	O
}	O
static	O
void	O
atari_atari_attack_callback	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
move	pointer
;	O
int	O
k	int
;	O
UNUSED	O
(	O
data	pointer
)	O
;	O
move	pointer
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
move_offset	int
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
forbidden	array
[	O
move	pointer
]	O
)	O
return	O
;	O
if	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
if	O
(	O
!	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
move	pointer
,	O
color	int
,	O
0	int
)	O
)	O
return	O
;	O
if	O
(	O
pattern	pointer
->	O
helper	pointer
)	O
if	O
(	O
!	O
pattern	pointer
->	O
helper	pointer
(	O
pattern	pointer
,	O
ll	int
,	O
move	pointer
,	O
color	int
)	O
)	O
return	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
++	O
k	int
)	O
{	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_X	int
)	O
{	O
int	O
str	int
=	O
find_origin	function
(	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
)	O
;	O
if	O
(	O
current_minsize	int
>	O
0	int
&&	O
get_aa_value	function
(	O
str	int
)	O
<	O
current_minsize	int
)	O
continue	O
;	O
if	O
(	O
aa_move_known	function
(	O
current_attacks	pointer
,	O
move	pointer
,	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
get_aa_status	function
(	O
str	int
)	O
!=	O
ALIVE	int
)	O
continue	O
;	O
if	O
(	O
!	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_s	int
)	O
&&	O
is_self_atari	function
(	O
move	pointer
,	O
color	int
)	O
)	O
{	O
if	O
(	O
countlib	function
(	O
str	int
)	O
>	O
2	int
)	O
continue	O
;	O
if	O
(	O
!	O
safe_move	function
(	O
move	pointer
,	O
color	int
)	O
)	O
continue	O
;	O
}	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"attack_callback"	pointer
,	O
str	int
)	O
)	O
{	O
int	O
acode	int
;	O
int	O
attack_point	pointer
=	O
NO_MOVE	O
;	O
if	O
(	O
!	O
board	pointer
[	O
str	int
]	O
)	O
acode	int
=	O
WIN	int
;	O
else	O
acode	int
=	O
attack	function
(	O
str	int
,	O
&	O
attack_point	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_c	int
)	O
&&	O
!	O
aa_move_known	function
(	O
current_attacks	pointer
,	O
move	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"aa_attack pattern %s+%d (conditional) found threat on %1m at %1m with code %d\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
str	int
,	O
move	pointer
,	O
acode	int
)	O
;	O
if	O
(	O
conditional_attack_point	array
[	O
move	pointer
]	O
==	O
NO_MOVE	O
)	O
conditional_attack_point	array
[	O
move	pointer
]	O
=	O
str	int
;	O
else	O
if	O
(	O
conditional_attack_point	array
[	O
move	pointer
]	O
!=	O
str	int
)	O
{	O
aa_add_move	function
(	O
current_attacks	pointer
,	O
move	pointer
,	O
conditional_attack_point	array
[	O
move	pointer
]	O
)	O
;	O
aa_add_move	function
(	O
current_attacks	pointer
,	O
move	pointer
,	O
str	int
)	O
;	O
}	O
}	O
else	O
{	O
aa_add_move	function
(	O
current_attacks	pointer
,	O
move	pointer
,	O
str	int
)	O
;	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"aa_attack pattern %s+%d found threat on %1m at %1m with code %d\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
str	int
,	O
move	pointer
,	O
acode	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
static	O
int	O
atari_atari_find_defense_moves	function
(	O
int	O
targets	array
[	O
AA_MAX_TARGETS_PER_MOVE	int
]	O
,	O
int	O
moves	array
[	O
AA_MAX_MOVES	O
]	O
)	O
{	O
int	O
num_moves	int
=	O
0	int
;	O
int	O
move	pointer
;	O
int	O
k	int
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
4	int
]	O
;	O
int	O
neighbors	int
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
int	O
r	int
,	O
s	int
;	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
&&	O
targets	array
[	O
r	int
]	O
!=	O
NO_MOVE	O
;	O
r	int
++	O
)	O
{	O
int	O
str	int
=	O
targets	array
[	O
r	int
]	O
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
!	O
find_defense	function
(	O
str	int
,	O
&	O
move	pointer
)	O
)	O
continue	O
;	O
moves	array
[	O
num_moves	int
++	O
]	O
=	O
move	pointer
;	O
if	O
(	O
num_moves	int
==	O
AA_MAX_MOVES	O
)	O
return	O
num_moves	int
;	O
mx	array
[	O
move	pointer
]	O
=	O
1	int
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
4	int
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
mx	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
&&	O
trymove	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
board	pointer
[	O
str	int
]	O
,	O
"aa_defend-A"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
moves	array
[	O
num_moves	int
++	O
]	O
=	O
libs	pointer
[	O
k	int
]	O
;	O
mx	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
=	O
1	int
;	O
}	O
popgo	function
(	O
)	O
;	O
if	O
(	O
num_moves	int
==	O
AA_MAX_MOVES	O
)	O
return	O
num_moves	int
;	O
}	O
}	O
neighbors	int
=	O
chainlinks	function
(	O
str	int
,	O
adjs	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
attack_point	pointer
;	O
if	O
(	O
attack	function
(	O
adjs	array
[	O
k	int
]	O
,	O
&	O
attack_point	pointer
)	O
==	O
WIN	int
&&	O
!	O
mx	array
[	O
attack_point	pointer
]	O
)	O
{	O
moves	array
[	O
num_moves	int
++	O
]	O
=	O
attack_point	pointer
;	O
if	O
(	O
num_moves	int
==	O
AA_MAX_MOVES	O
)	O
return	O
num_moves	int
;	O
mx	array
[	O
attack_point	pointer
]	O
=	O
1	int
;	O
}	O
liberties	pointer
=	O
findlib	function
(	O
adjs	array
[	O
k	int
]	O
,	O
3	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
liberties	pointer
<=	O
3	int
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
liberties	pointer
;	O
s	int
++	O
)	O
{	O
if	O
(	O
!	O
mx	array
[	O
libs	pointer
[	O
s	int
]	O
]	O
&&	O
!	O
is_self_atari	function
(	O
libs	pointer
[	O
s	int
]	O
,	O
board	pointer
[	O
str	int
]	O
)	O
&&	O
trymove	function
(	O
libs	pointer
[	O
s	int
]	O
,	O
board	pointer
[	O
str	int
]	O
,	O
"aa_defend-B"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
moves	array
[	O
num_moves	int
++	O
]	O
=	O
libs	pointer
[	O
s	int
]	O
;	O
mx	array
[	O
libs	pointer
[	O
s	int
]	O
]	O
=	O
1	int
;	O
}	O
popgo	function
(	O
)	O
;	O
if	O
(	O
num_moves	int
==	O
AA_MAX_MOVES	O
)	O
return	O
num_moves	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
debug	int
&	O
DEBUG_ATARI_ATARI	int
)	O
{	O
gprintf	function
(	O
"Defense moves for %1m:"	pointer
,	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
gprintf	function
(	O
"%o %1m"	pointer
,	O
moves	array
[	O
k	int
]	O
)	O
;	O
gprintf	function
(	O
"%o\n"	pointer
)	O
;	O
}	O
}	O
return	O
num_moves	int
;	O
}	O
static	O
void	O
compute_aa_values	function
(	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos	int
;	O
int	O
value	pointer
;	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
int	O
r	int
,	O
k	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
other	int
||	O
pos	int
!=	O
find_origin	function
(	O
pos	int
)	O
||	O
aa_status	array
[	O
pos	int
]	O
!=	O
ALIVE	int
)	O
{	O
aa_values	array
[	O
pos	int
]	O
=	O
0	int
;	O
continue	O
;	O
}	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
value	pointer
=	O
2	int
*	O
countstones	function
(	O
pos	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
if	O
(	O
!	O
mx	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
&&	O
(	O
whose_moyo	function
(	O
&	O
initial_black_influence	struct
,	O
libs	pointer
[	O
r	int
]	O
)	O
==	O
other	int
||	O
whose_moyo	function
(	O
&	O
initial_white_influence	struct
,	O
libs	pointer
[	O
r	int
]	O
)	O
==	O
other	int
)	O
)	O
{	O
mx	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
=	O
1	int
;	O
value	pointer
++	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
librd	int
=	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD1	O
(	O
librd	int
)	O
||	O
mx	array
[	O
librd	int
]	O
)	O
continue	O
;	O
mx	array
[	O
librd	int
]	O
=	O
1	int
;	O
if	O
(	O
board	pointer
[	O
librd	int
]	O
==	O
EMPTY	int
&&	O
(	O
whose_moyo	function
(	O
&	O
initial_black_influence	struct
,	O
librd	int
)	O
==	O
other	int
||	O
(	O
whose_moyo	function
(	O
&	O
initial_white_influence	struct
,	O
librd	int
)	O
==	O
other	int
)	O
)	O
)	O
value	pointer
++	O
;	O
}	O
}	O
aa_values	array
[	O
pos	int
]	O
=	O
value	pointer
;	O
if	O
(	O
1	int
)	O
DEBUG	O
(	O
DEBUG_ATARI_ATARI	int
,	O
"aa_value for %1m = %d\n"	pointer
,	O
pos	int
,	O
value	pointer
)	O
;	O
}	O
}	O
static	O
int	O
get_aa_value	function
(	O
int	O
str	int
)	O
{	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
k	int
;	O
int	O
num_stones	int
=	O
findstones	function
(	O
str	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	pointer
)	O
;	O
int	O
value	pointer
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
value	pointer
+=	O
aa_values	array
[	O
stones	pointer
[	O
k	int
]	O
]	O
;	O
return	O
value	pointer
;	O
}	O
static	O
int	O
update_aa_goal	function
(	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
new_goal	array
[	O
BOARDMAX	O
]	O
,	O
int	O
apos	int
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
dists	array
[	O
BOARDMAX	O
]	O
;	O
int	O
queue	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
queue_end	int
=	O
0	int
;	O
int	O
k	int
,	O
r	int
,	O
s	int
;	O
int	O
pos	int
;	O
if	O
(	O
goal	pointer
==	O
NULL	O
)	O
memset	function
(	O
new_goal	array
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
else	O
memcpy	function
(	O
new_goal	array
,	O
goal	pointer
,	O
BOARDMAX	O
)	O
;	O
memset	function
(	O
dists	array
,	O
0	int
,	O
sizeof	O
(	O
dists	array
)	O
)	O
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
)	O
{	O
dists	array
[	O
apos	int
]	O
=	O
1	int
;	O
queue	array
[	O
queue_end	int
++	O
]	O
=	O
apos	int
;	O
}	O
if	O
(	O
queue_end	int
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
queue_end	int
;	O
r	int
++	O
)	O
{	O
int	O
smallest_dist	int
=	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
int	O
best_index	int
=	O
-	O
1	int
;	O
gg_assert	O
(	O
queue_end	int
<	O
MAX_BOARD	int
*	O
MAX_BOARD	int
)	O
;	O
for	O
(	O
k	int
=	O
r	int
;	O
k	int
<	O
queue_end	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
dists	array
[	O
queue	array
[	O
k	int
]	O
]	O
<	O
smallest_dist	int
)	O
{	O
smallest_dist	int
=	O
dists	array
[	O
queue	array
[	O
k	int
]	O
]	O
;	O
best_index	int
=	O
k	int
;	O
}	O
}	O
if	O
(	O
best_index	int
!=	O
r	int
)	O
{	O
int	O
tmp	int
=	O
queue	array
[	O
r	int
]	O
;	O
queue	array
[	O
r	int
]	O
=	O
queue	array
[	O
best_index	int
]	O
;	O
queue	array
[	O
best_index	int
]	O
=	O
tmp	int
;	O
}	O
pos	int
=	O
queue	array
[	O
r	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
)	O
new_goal	array
[	O
pos	int
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos2	int
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
color	int
||	O
pos	int
==	O
apos	int
)	O
&&	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
ENQUEUE	O
(	O
pos2	int
,	O
dists	array
[	O
pos	int
]	O
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
other	int
&&	O
board	pointer
[	O
pos2	int
]	O
==	O
other	int
)	O
{	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
size	int
=	O
findstones	function
(	O
pos2	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	pointer
)	O
;	O
int	O
libs	pointer
=	O
countlib	function
(	O
pos2	int
)	O
;	O
int	O
deltadist	int
=	O
libs	pointer
-	O
3	int
;	O
if	O
(	O
deltadist	int
<	O
0	int
)	O
deltadist	int
=	O
0	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
size	int
;	O
s	int
++	O
)	O
ENQUEUE	O
(	O
stones	pointer
[	O
s	int
]	O
,	O
dists	array
[	O
pos	int
]	O
+	O
deltadist	int
)	O
;	O
}	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
aa_init_moves	function
(	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
)	O
{	O
attacks	array
[	O
0	int
]	O
.	O
move	pointer
=	O
NO_MOVE	O
;	O
}	O
static	O
void	O
aa_add_move	function
(	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
,	O
int	O
move	pointer
,	O
int	O
target	int
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
AA_MAX_MOVES	O
;	O
k	int
++	O
)	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
==	O
move	pointer
||	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
AA_MAX_MOVES	O
)	O
return	O
;	O
target	int
=	O
find_origin	function
(	O
target	int
)	O
;	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
==	O
NO_MOVE	O
)	O
{	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
=	O
move	pointer
;	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
0	int
]	O
=	O
target	int
;	O
if	O
(	O
AA_MAX_TARGETS_PER_MOVE	int
>	O
0	int
)	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
1	int
]	O
=	O
NO_MOVE	O
;	O
if	O
(	O
k	int
<	O
AA_MAX_MOVES	O
-	O
1	int
)	O
attacks	array
[	O
k	int
+	O
1	int
]	O
.	O
move	pointer
=	O
NO_MOVE	O
;	O
return	O
;	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
;	O
r	int
++	O
)	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
target	int
||	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
r	int
==	O
AA_MAX_TARGETS_PER_MOVE	int
)	O
return	O
;	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
target	int
)	O
return	O
;	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
=	O
target	int
;	O
if	O
(	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
-	O
1	int
)	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
+	O
1	int
]	O
=	O
NO_MOVE	O
;	O
}	O
static	O
int	O
aa_move_known	function
(	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
,	O
int	O
move	pointer
,	O
int	O
target	int
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
AA_MAX_MOVES	O
;	O
k	int
++	O
)	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
==	O
move	pointer
||	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
AA_MAX_MOVES	O
)	O
return	O
1	int
;	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
if	O
(	O
target	int
==	O
NO_MOVE	O
)	O
return	O
1	int
;	O
target	int
=	O
find_origin	function
(	O
target	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
;	O
r	int
++	O
)	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
target	int
||	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
r	int
==	O
AA_MAX_TARGETS_PER_MOVE	int
)	O
return	O
1	int
;	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
target	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
target_comp_func	function
(	O
const	O
void	O
*	O
a	char
,	O
const	O
void	O
*	O
b	char
)	O
{	O
int	O
asize	int
=	O
get_aa_value	function
(	O
*	O
(	O
(	O
const	O
int	O
*	O
)	O
a	char
)	O
)	O
;	O
int	O
bsize	int
=	O
get_aa_value	function
(	O
*	O
(	O
(	O
const	O
int	O
*	O
)	O
b	char
)	O
)	O
;	O
return	O
asize	int
-	O
bsize	int
;	O
}	O
static	O
int	O
move_comp_func	function
(	O
const	O
void	O
*	O
a	char
,	O
const	O
void	O
*	O
b	char
)	O
{	O
const	O
struct	O
aa_move	struct
*	O
aa	pointer
=	O
a	char
;	O
const	O
struct	O
aa_move	struct
*	O
bb	pointer
=	O
b	char
;	O
int	O
asize	int
=	O
get_aa_value	function
(	O
aa	pointer
->	O
target	int
[	O
0	int
]	O
)	O
;	O
int	O
bsize	int
=	O
get_aa_value	function
(	O
bb	pointer
->	O
target	int
[	O
0	int
]	O
)	O
;	O
return	O
asize	int
-	O
bsize	int
;	O
}	O
static	O
void	O
aa_sort_moves	function
(	O
struct	O
aa_move	struct
attacks	array
[	O
AA_MAX_MOVES	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
number_of_attacks	int
;	O
int	O
number_of_targets	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
AA_MAX_MOVES	O
&&	O
attacks	array
[	O
k	int
]	O
.	O
move	pointer
!=	O
NO_MOVE	O
;	O
k	int
++	O
)	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
AA_MAX_TARGETS_PER_MOVE	int
;	O
r	int
++	O
)	O
if	O
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
r	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
number_of_targets	int
=	O
r	int
;	O
gg_sort	function
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
,	O
number_of_targets	int
,	O
sizeof	O
(	O
attacks	array
[	O
k	int
]	O
.	O
target	int
[	O
0	int
]	O
)	O
,	O
target_comp_func	function
)	O
;	O
}	O
number_of_attacks	int
=	O
k	int
;	O
gg_sort	function
(	O
attacks	array
,	O
number_of_attacks	int
,	O
sizeof	O
(	O
attacks	array
[	O
0	int
]	O
)	O
,	O
move_comp_func	function
)	O
;	O
}	O
