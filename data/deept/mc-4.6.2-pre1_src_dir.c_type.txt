int	O
show_dot_files	int
=	O
1	int
;	O
int	O
show_backups	int
=	O
1	int
;	O
int	O
mix_all_files	int
=	O
0	int
;	O
static	O
int	O
reverse	int
=	O
1	int
;	O
static	O
int	O
case_sensitive	int
=	O
OS_SORT_CASE_SENSITIVE_DEFAULT	int
;	O
sort_orders_t	struct
sort_orders	array
[	O
SORT_TYPES_TOTAL	O
]	O
=	O
{	O
{	O
N_	O
(	O
"&Unsorted"	pointer
)	O
,	O
unsorted	function
}	O
,	O
{	O
N_	O
(	O
"&Name"	pointer
)	O
,	O
sort_name	function
}	O
,	O
{	O
N_	O
(	O
"&Extension"	pointer
)	O
,	O
sort_ext	function
}	O
,	O
{	O
N_	O
(	O
"&Modify time"	pointer
)	O
,	O
sort_time	function
}	O
,	O
{	O
N_	O
(	O
"&Access time"	pointer
)	O
,	O
sort_atime	function
}	O
,	O
{	O
N_	O
(	O
"C&Hange time"	pointer
)	O
,	O
sort_ctime	function
}	O
,	O
{	O
N_	O
(	O
"&Size"	pointer
)	O
,	O
sort_size	function
}	O
,	O
{	O
N_	O
(	O
"&Inode"	pointer
)	O
,	O
sort_inode	function
}	O
,	O
}	O
;	O
typedef	O
enum	O
{	O
STRCOLL_NO	int
,	O
STRCOLL_YES	int
,	O
STRCOLL_TEST	int
}	O
strcoll_status	enum
;	O
static	O
int	O
string_sortcomp	function
(	O
const	O
char	O
*	O
str1	pointer
,	O
const	O
char	O
*	O
str2	pointer
)	O
{	O
static	O
strcoll_status	enum
use_strcoll	enum
=	O
STRCOLL_TEST	int
;	O
if	O
(	O
case_sensitive	int
)	O
{	O
return	O
strcmp	function
(	O
str1	pointer
,	O
str2	pointer
)	O
;	O
}	O
if	O
(	O
use_strcoll	enum
==	O
STRCOLL_TEST	int
)	O
{	O
if	O
(	O
strcoll	function
(	O
"a"	pointer
,	O
"B"	pointer
)	O
*	O
strcoll	function
(	O
"B"	pointer
,	O
"c"	pointer
)	O
>	O
0	int
)	O
{	O
use_strcoll	enum
=	O
STRCOLL_YES	int
;	O
}	O
else	O
{	O
use_strcoll	enum
=	O
STRCOLL_NO	int
;	O
}	O
}	O
if	O
(	O
use_strcoll	enum
==	O
STRCOLL_NO	int
)	O
return	O
g_strcasecmp	function
(	O
str1	pointer
,	O
str2	pointer
)	O
;	O
else	O
return	O
strcoll	function
(	O
str1	pointer
,	O
str2	pointer
)	O
;	O
}	O
int	O
unsorted	function
(	O
const	O
file_entry	struct
*	O
a	pointer
,	O
const	O
file_entry	struct
*	O
b	pointer
)	O
{	O
(	O
void	O
)	O
a	pointer
;	O
(	O
void	O
)	O
b	pointer
;	O
return	O
0	int
;	O
}	O
int	O
sort_name	function
(	O
const	O
file_entry	struct
*	O
a	pointer
,	O
const	O
file_entry	struct
*	O
b	pointer
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	pointer
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	pointer
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
return	O
string_sortcomp	function
(	O
a	pointer
->	O
fname	pointer
,	O
b	pointer
->	O
fname	pointer
)	O
*	O
reverse	int
;	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_ext	function
(	O
const	O
file_entry	struct
*	O
a	pointer
,	O
const	O
file_entry	struct
*	O
b	pointer
)	O
{	O
const	O
char	O
*	O
exta	pointer
,	O
*	O
extb	pointer
;	O
int	O
r	pointer
;	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	pointer
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	pointer
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
{	O
exta	pointer
=	O
extension	function
(	O
a	pointer
->	O
fname	pointer
)	O
;	O
extb	pointer
=	O
extension	function
(	O
b	pointer
->	O
fname	pointer
)	O
;	O
r	pointer
=	O
string_sortcomp	function
(	O
exta	pointer
,	O
extb	pointer
)	O
;	O
if	O
(	O
r	pointer
)	O
return	O
r	pointer
*	O
reverse	int
;	O
else	O
return	O
sort_name	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_time	function
(	O
const	O
file_entry	struct
*	O
a	pointer
,	O
const	O
file_entry	struct
*	O
b	pointer
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	pointer
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	pointer
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
{	O
int	O
result	long
=	O
a	pointer
->	O
st	pointer
.	O
st_mtime	O
<	O
b	pointer
->	O
st	pointer
.	O
st_mtime	O
?	O
-	O
1	int
:	O
a	pointer
->	O
st	pointer
.	O
st_mtime	O
>	O
b	pointer
->	O
st	pointer
.	O
st_mtime	O
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
result	long
*	O
reverse	int
;	O
else	O
return	O
sort_name	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_ctime	function
(	O
const	O
file_entry	struct
*	O
a	pointer
,	O
const	O
file_entry	struct
*	O
b	pointer
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	pointer
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	pointer
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
{	O
int	O
result	long
=	O
a	pointer
->	O
st	pointer
.	O
st_ctime	O
<	O
b	pointer
->	O
st	pointer
.	O
st_ctime	O
?	O
-	O
1	int
:	O
a	pointer
->	O
st	pointer
.	O
st_ctime	O
>	O
b	pointer
->	O
st	pointer
.	O
st_ctime	O
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
result	long
*	O
reverse	int
;	O
else	O
return	O
sort_name	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_atime	function
(	O
const	O
file_entry	struct
*	O
a	pointer
,	O
const	O
file_entry	struct
*	O
b	pointer
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	pointer
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	pointer
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
{	O
int	O
result	long
=	O
a	pointer
->	O
st	pointer
.	O
st_atime	O
<	O
b	pointer
->	O
st	pointer
.	O
st_atime	O
?	O
-	O
1	int
:	O
a	pointer
->	O
st	pointer
.	O
st_atime	O
>	O
b	pointer
->	O
st	pointer
.	O
st_atime	O
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
result	long
*	O
reverse	int
;	O
else	O
return	O
sort_name	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_inode	function
(	O
const	O
file_entry	struct
*	O
a	pointer
,	O
const	O
file_entry	struct
*	O
b	pointer
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	pointer
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	pointer
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
return	O
(	O
a	pointer
->	O
st	pointer
.	O
st_ino	long
-	O
b	pointer
->	O
st	pointer
.	O
st_ino	long
)	O
*	O
reverse	int
;	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_size	function
(	O
const	O
file_entry	struct
*	O
a	pointer
,	O
const	O
file_entry	struct
*	O
b	pointer
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	pointer
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	pointer
)	O
;	O
int	O
result	long
=	O
0	int
;	O
if	O
(	O
ad	int
!=	O
bd	int
&&	O
!	O
mix_all_files	int
)	O
return	O
bd	int
-	O
ad	int
;	O
result	long
=	O
a	pointer
->	O
st	pointer
.	O
st_size	long
<	O
b	pointer
->	O
st	pointer
.	O
st_size	long
?	O
-	O
1	int
:	O
a	pointer
->	O
st	pointer
.	O
st_size	long
>	O
b	pointer
->	O
st	pointer
.	O
st_size	long
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
result	long
*	O
reverse	int
;	O
else	O
return	O
sort_name	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
}	O
void	O
do_sort	function
(	O
dir_list	struct
*	O
list	pointer
,	O
sortfn	function
*	O
sort	pointer
,	O
int	O
top	pointer
,	O
int	O
reverse_f	int
,	O
int	O
case_sensitive_f	int
)	O
{	O
int	O
dot_dot_found	int
=	O
0	int
;	O
if	O
(	O
top	pointer
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
list	pointer
->	O
list	pointer
[	O
0	int
]	O
.	O
fname	pointer
,	O
".."	pointer
)	O
)	O
dot_dot_found	int
=	O
1	int
;	O
reverse	int
=	O
reverse_f	int
?	O
-	O
1	int
:	O
1	int
;	O
case_sensitive	int
=	O
case_sensitive_f	int
;	O
qsort	function
(	O
&	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
dot_dot_found	int
]	O
,	O
top	pointer
+	O
1	int
-	O
dot_dot_found	int
,	O
sizeof	O
(	O
file_entry	struct
)	O
,	O
sort	pointer
)	O
;	O
}	O
void	O
clean_dir	function
(	O
dir_list	struct
*	O
list	pointer
,	O
int	O
count	int
)	O
{	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
count	int
;	O
i	array
++	O
)	O
{	O
g_free	function
(	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
)	O
;	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
=	O
0	int
;	O
}	O
}	O
static	O
int	O
add_dotdot_to_list	function
(	O
dir_list	struct
*	O
list	pointer
,	O
int	O
index	function
)	O
{	O
if	O
(	O
index	function
==	O
list	pointer
->	O
size	long
)	O
{	O
list	pointer
->	O
list	pointer
=	O
g_realloc	function
(	O
list	pointer
->	O
list	pointer
,	O
sizeof	O
(	O
file_entry	struct
)	O
*	O
(	O
list	pointer
->	O
size	long
+	O
RESIZE_STEPS	int
)	O
)	O
;	O
if	O
(	O
!	O
list	pointer
->	O
list	pointer
)	O
return	O
0	int
;	O
list	pointer
->	O
size	long
+=	O
RESIZE_STEPS	int
;	O
}	O
memset	function
(	O
&	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
index	function
]	O
,	O
0	int
,	O
sizeof	O
(	O
file_entry	struct
)	O
)	O
;	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
index	function
]	O
.	O
fnamelen	int
=	O
2	int
;	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
index	function
]	O
.	O
fname	pointer
=	O
g_strdup	function
(	O
".."	pointer
)	O
;	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
index	function
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
0	int
;	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
index	function
]	O
.	O
f	float
.	O
stale_link	int
=	O
0	int
;	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
index	function
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
0	int
;	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
index	function
]	O
.	O
f	float
.	O
marked	int
=	O
0	int
;	O
(	O
list	pointer
->	O
list	pointer
)	O
[	O
index	function
]	O
.	O
st	pointer
.	O
st_mode	int
=	O
040755	int
;	O
return	O
1	int
;	O
}	O
int	O
set_zero_dir	function
(	O
dir_list	struct
*	O
list	pointer
)	O
{	O
return	O
(	O
add_dotdot_to_list	function
(	O
list	pointer
,	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
handle_dirent	function
(	O
dir_list	struct
*	O
list	pointer
,	O
const	O
char	O
*	O
filter	pointer
,	O
struct	O
dirent	struct
*	O
dp	pointer
,	O
struct	O
stat	struct
*	O
buf1	pointer
,	O
int	O
next_free	int
,	O
int	O
*	O
link_to_dir	int
,	O
int	O
*	O
stale_link	int
)	O
{	O
if	O
(	O
dp	pointer
->	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
dp	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
dp	pointer
->	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
dp	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
'.'	O
&&	O
dp	pointer
->	O
d_name	array
[	O
2	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
show_dot_files	int
&&	O
(	O
dp	pointer
->	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
show_backups	int
&&	O
dp	pointer
->	O
d_name	array
[	O
NLENGTH	O
(	O
dp	pointer
)	O
-	O
1	int
]	O
==	O
'~'	O
)	O
return	O
0	int
;	O
if	O
(	O
mc_lstat	function
(	O
dp	pointer
->	O
d_name	array
,	O
buf1	pointer
)	O
==	O
-	O
1	int
)	O
{	O
memset	function
(	O
buf1	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
buf1	pointer
)	O
)	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
buf1	pointer
->	O
st_mode	int
)	O
)	O
tree_store_mark_checked	function
(	O
dp	pointer
->	O
d_name	array
)	O
;	O
*	O
link_to_dir	int
=	O
0	int
;	O
*	O
stale_link	int
=	O
0	int
;	O
if	O
(	O
S_ISLNK	O
(	O
buf1	pointer
->	O
st_mode	int
)	O
)	O
{	O
struct	O
stat	struct
buf2	struct
;	O
if	O
(	O
!	O
mc_stat	function
(	O
dp	pointer
->	O
d_name	array
,	O
&	O
buf2	struct
)	O
)	O
*	O
link_to_dir	int
=	O
S_ISDIR	O
(	O
buf2	struct
.	O
st_mode	int
)	O
!=	O
0	int
;	O
else	O
*	O
stale_link	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
S_ISDIR	O
(	O
buf1	pointer
->	O
st_mode	int
)	O
||	O
*	O
link_to_dir	int
)	O
&&	O
filter	pointer
&&	O
!	O
regexp_match	function
(	O
filter	pointer
,	O
dp	pointer
->	O
d_name	array
,	O
match_file	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
next_free	int
==	O
list	pointer
->	O
size	long
)	O
{	O
list	pointer
->	O
list	pointer
=	O
g_realloc	function
(	O
list	pointer
->	O
list	pointer
,	O
sizeof	O
(	O
file_entry	struct
)	O
*	O
(	O
list	pointer
->	O
size	long
+	O
RESIZE_STEPS	int
)	O
)	O
;	O
if	O
(	O
!	O
list	pointer
->	O
list	pointer
)	O
return	O
-	O
1	int
;	O
list	pointer
->	O
size	long
+=	O
RESIZE_STEPS	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
handle_path	function
(	O
dir_list	struct
*	O
list	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
buf1	pointer
,	O
int	O
next_free	int
,	O
int	O
*	O
link_to_dir	int
,	O
int	O
*	O
stale_link	int
)	O
{	O
if	O
(	O
path	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
path	pointer
[	O
1	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
path	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
path	pointer
[	O
1	int
]	O
==	O
'.'	O
&&	O
path	pointer
[	O
2	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
mc_lstat	function
(	O
path	pointer
,	O
buf1	pointer
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
S_ISDIR	O
(	O
buf1	pointer
->	O
st_mode	int
)	O
)	O
tree_store_mark_checked	function
(	O
path	pointer
)	O
;	O
*	O
link_to_dir	int
=	O
0	int
;	O
*	O
stale_link	int
=	O
0	int
;	O
if	O
(	O
S_ISLNK	O
(	O
buf1	pointer
->	O
st_mode	int
)	O
)	O
{	O
struct	O
stat	struct
buf2	struct
;	O
if	O
(	O
!	O
mc_stat	function
(	O
path	pointer
,	O
&	O
buf2	struct
)	O
)	O
*	O
link_to_dir	int
=	O
S_ISDIR	O
(	O
buf2	struct
.	O
st_mode	int
)	O
!=	O
0	int
;	O
else	O
*	O
stale_link	int
=	O
1	int
;	O
}	O
if	O
(	O
next_free	int
==	O
list	pointer
->	O
size	long
)	O
{	O
list	pointer
->	O
list	pointer
=	O
g_realloc	function
(	O
list	pointer
->	O
list	pointer
,	O
sizeof	O
(	O
file_entry	struct
)	O
*	O
(	O
list	pointer
->	O
size	long
+	O
RESIZE_STEPS	int
)	O
)	O
;	O
if	O
(	O
!	O
list	pointer
->	O
list	pointer
)	O
return	O
-	O
1	int
;	O
list	pointer
->	O
size	long
+=	O
RESIZE_STEPS	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
do_load_dir	function
(	O
const	O
char	O
*	O
path	pointer
,	O
dir_list	struct
*	O
list	pointer
,	O
sortfn	function
*	O
sort	pointer
,	O
int	O
reverse	int
,	O
int	O
case_sensitive	int
,	O
const	O
char	O
*	O
filter	pointer
)	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
int	O
status	int
,	O
link_to_dir	int
,	O
stale_link	int
;	O
int	O
next_free	int
=	O
0	int
;	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
set_zero_dir	function
(	O
list	pointer
)	O
==	O
0	int
)	O
return	O
next_free	int
;	O
next_free	int
++	O
;	O
dirp	pointer
=	O
mc_opendir	function
(	O
path	pointer
)	O
;	O
if	O
(	O
!	O
dirp	pointer
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot read directory contents"	pointer
)	O
)	O
;	O
return	O
next_free	int
;	O
}	O
tree_store_start_check	function
(	O
path	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
path	pointer
,	O
"/"	pointer
)	O
)	O
next_free	int
--	O
;	O
while	O
(	O
(	O
dp	pointer
=	O
mc_readdir	function
(	O
dirp	pointer
)	O
)	O
)	O
{	O
status	int
=	O
handle_dirent	function
(	O
list	pointer
,	O
filter	pointer
,	O
dp	pointer
,	O
&	O
st	pointer
,	O
next_free	int
,	O
&	O
link_to_dir	int
,	O
&	O
stale_link	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
{	O
tree_store_end_check	function
(	O
)	O
;	O
mc_closedir	function
(	O
dirp	pointer
)	O
;	O
return	O
next_free	int
;	O
}	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
fnamelen	int
=	O
NLENGTH	O
(	O
dp	pointer
)	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
fname	pointer
=	O
g_strdup	function
(	O
dp	pointer
->	O
d_name	array
)	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
marked	int
=	O
0	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
link_to_dir	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
stale_link	int
=	O
stale_link	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
0	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
st	pointer
=	O
st	pointer
;	O
next_free	int
++	O
;	O
if	O
(	O
!	O
(	O
next_free	int
%	O
32	int
)	O
)	O
rotate_dash	function
(	O
)	O
;	O
}	O
if	O
(	O
next_free	int
)	O
{	O
do_sort	function
(	O
list	pointer
,	O
sort	pointer
,	O
next_free	int
-	O
1	int
,	O
reverse	int
,	O
case_sensitive	int
)	O
;	O
}	O
mc_closedir	function
(	O
dirp	pointer
)	O
;	O
tree_store_end_check	function
(	O
)	O
;	O
return	O
next_free	int
;	O
}	O
int	O
link_isdir	function
(	O
const	O
file_entry	struct
*	O
file	pointer
)	O
{	O
if	O
(	O
file	pointer
->	O
f	float
.	O
link_to_dir	int
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
if_link_is_exe	function
(	O
const	O
char	O
*	O
full_name	pointer
,	O
const	O
file_entry	struct
*	O
file	pointer
)	O
{	O
struct	O
stat	struct
b	pointer
;	O
if	O
(	O
S_ISLNK	O
(	O
file	pointer
->	O
st	pointer
.	O
st_mode	int
)	O
&&	O
!	O
mc_stat	function
(	O
full_name	pointer
,	O
&	O
b	pointer
)	O
)	O
{	O
return	O
is_exe	function
(	O
b	pointer
.	O
st_mode	int
)	O
;	O
}	O
else	O
return	O
1	int
;	O
}	O
static	O
dir_list	struct
dir_copy	struct
=	O
{	O
0	int
,	O
0	int
}	O
;	O
static	O
void	O
alloc_dir_copy	function
(	O
int	O
size	long
)	O
{	O
int	O
i	array
;	O
if	O
(	O
dir_copy	struct
.	O
size	long
<	O
size	long
)	O
{	O
if	O
(	O
dir_copy	struct
.	O
list	pointer
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
dir_copy	struct
.	O
size	long
;	O
i	array
++	O
)	O
{	O
g_free	function
(	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
)	O
;	O
}	O
g_free	function
(	O
dir_copy	struct
.	O
list	pointer
)	O
;	O
dir_copy	struct
.	O
list	pointer
=	O
0	int
;	O
}	O
dir_copy	struct
.	O
list	pointer
=	O
g_new	O
(	O
file_entry	struct
,	O
size	long
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
size	long
;	O
i	array
++	O
)	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
=	O
0	int
;	O
dir_copy	struct
.	O
size	long
=	O
size	long
;	O
}	O
}	O
int	O
do_reload_dir	function
(	O
const	O
char	O
*	O
path	pointer
,	O
dir_list	struct
*	O
list	pointer
,	O
sortfn	function
*	O
sort	pointer
,	O
int	O
count	int
,	O
int	O
rev	int
,	O
int	O
case_sensitive	int
,	O
const	O
char	O
*	O
filter	pointer
)	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
int	O
next_free	int
=	O
0	int
;	O
int	O
i	array
,	O
status	int
,	O
link_to_dir	int
,	O
stale_link	int
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
marked_cnt	int
;	O
GHashTable	struct
*	O
marked_files	pointer
;	O
dirp	pointer
=	O
mc_opendir	function
(	O
path	pointer
)	O
;	O
if	O
(	O
!	O
dirp	pointer
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot read directory contents"	pointer
)	O
)	O
;	O
clean_dir	function
(	O
list	pointer
,	O
count	int
)	O
;	O
return	O
set_zero_dir	function
(	O
list	pointer
)	O
;	O
}	O
tree_store_start_check	function
(	O
path	pointer
)	O
;	O
marked_files	pointer
=	O
g_hash_table_new	function
(	O
g_str_hash	function
,	O
g_str_equal	function
)	O
;	O
alloc_dir_copy	function
(	O
list	pointer
->	O
size	long
)	O
;	O
for	O
(	O
marked_cnt	int
=	O
i	array
=	O
0	int
;	O
i	array
<	O
count	int
;	O
i	array
++	O
)	O
{	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
fnamelen	int
=	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
fnamelen	int
;	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
=	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
;	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
=	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
;	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
dir_size_computed	int
;	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
link_to_dir	int
;	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
stale_link	int
=	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
stale_link	int
;	O
if	O
(	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
{	O
g_hash_table_insert	function
(	O
marked_files	pointer
,	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
,	O
&	O
dir_copy	struct
.	O
list	pointer
[	O
i	array
]	O
)	O
;	O
marked_cnt	int
++	O
;	O
}	O
}	O
if	O
(	O
strcmp	function
(	O
path	pointer
,	O
"/"	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
set_zero_dir	function
(	O
list	pointer
)	O
==	O
0	int
)	O
{	O
clean_dir	function
(	O
list	pointer
,	O
count	int
)	O
;	O
clean_dir	function
(	O
&	O
dir_copy	struct
,	O
count	int
)	O
;	O
return	O
next_free	int
;	O
}	O
next_free	int
++	O
;	O
}	O
while	O
(	O
(	O
dp	pointer
=	O
mc_readdir	function
(	O
dirp	pointer
)	O
)	O
)	O
{	O
status	int
=	O
handle_dirent	function
(	O
list	pointer
,	O
filter	pointer
,	O
dp	pointer
,	O
&	O
st	pointer
,	O
next_free	int
,	O
&	O
link_to_dir	int
,	O
&	O
stale_link	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
{	O
mc_closedir	function
(	O
dirp	pointer
)	O
;	O
tree_store_end_check	function
(	O
)	O
;	O
g_hash_table_destroy	function
(	O
marked_files	pointer
)	O
;	O
return	O
next_free	int
;	O
}	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
marked	int
=	O
0	int
;	O
if	O
(	O
marked_cnt	int
>	O
0	int
)	O
{	O
if	O
(	O
(	O
g_hash_table_lookup	function
(	O
marked_files	pointer
,	O
dp	pointer
->	O
d_name	array
)	O
)	O
)	O
{	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
marked	int
=	O
1	int
;	O
marked_cnt	int
--	O
;	O
}	O
}	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
fnamelen	int
=	O
NLENGTH	O
(	O
dp	pointer
)	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
fname	pointer
=	O
g_strdup	function
(	O
dp	pointer
->	O
d_name	array
)	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
link_to_dir	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
stale_link	int
=	O
stale_link	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
0	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
st	pointer
=	O
st	pointer
;	O
next_free	int
++	O
;	O
if	O
(	O
!	O
(	O
next_free	int
%	O
16	int
)	O
)	O
rotate_dash	function
(	O
)	O
;	O
}	O
mc_closedir	function
(	O
dirp	pointer
)	O
;	O
tree_store_end_check	function
(	O
)	O
;	O
g_hash_table_destroy	function
(	O
marked_files	pointer
)	O
;	O
if	O
(	O
next_free	int
)	O
{	O
do_sort	function
(	O
list	pointer
,	O
sort	pointer
,	O
next_free	int
-	O
1	int
,	O
rev	int
,	O
case_sensitive	int
)	O
;	O
}	O
clean_dir	function
(	O
&	O
dir_copy	struct
,	O
count	int
)	O
;	O
return	O
next_free	int
;	O
}	O
