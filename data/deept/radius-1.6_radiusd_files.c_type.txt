typedef	O
struct	O
locus_name	struct
{	O
struct	O
locus_name	struct
*	O
next	pointer
;	O
char	O
*	O
filename	pointer
;	O
size_t	long
refcnt	long
;	O
}	O
Locus_symbol	struct
;	O
static	O
grad_symtab_t	struct
*	O
locus_tab	pointer
;	O
void	O
locus_dup	function
(	O
grad_locus_t	struct
*	O
dst	pointer
,	O
grad_locus_t	struct
*	O
src	pointer
)	O
{	O
Locus_symbol	struct
*	O
sp	pointer
;	O
if	O
(	O
!	O
locus_tab	pointer
)	O
locus_tab	pointer
=	O
grad_symtab_create	function
(	O
sizeof	O
(	O
Locus_symbol	struct
)	O
,	O
NULL	O
)	O
;	O
sp	pointer
=	O
(	O
Locus_symbol	struct
*	O
)	O
grad_sym_lookup_or_install	function
(	O
locus_tab	pointer
,	O
src	pointer
->	O
file	pointer
,	O
1	int
)	O
;	O
sp	pointer
->	O
refcnt	long
++	O
;	O
dst	pointer
->	O
file	pointer
=	O
sp	pointer
->	O
filename	pointer
;	O
dst	pointer
->	O
line	long
=	O
src	pointer
->	O
line	long
;	O
}	O
void	O
locus_free	function
(	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
Locus_symbol	struct
*	O
sp	pointer
=	O
(	O
Locus_symbol	struct
*	O
)	O
grad_sym_lookup	function
(	O
locus_tab	pointer
,	O
loc	struct
->	O
file	pointer
)	O
;	O
if	O
(	O
--	O
sp	pointer
->	O
refcnt	long
==	O
0	int
)	O
grad_symtab_delete	function
(	O
locus_tab	pointer
,	O
(	O
grad_symbol_t	struct
*	O
)	O
sp	pointer
)	O
;	O
}	O
grad_symtab_t	struct
*	O
user_tab	pointer
;	O
grad_symtab_t	struct
*	O
deny_tab	pointer
;	O
static	O
grad_list_t	struct
*	O
huntgroups	pointer
;	O
static	O
grad_list_t	struct
*	O
hints	pointer
;	O
static	O
grad_list_t	struct
*	O
clients	pointer
;	O
static	O
grad_list_t	struct
*	O
radck_type	struct
;	O
static	O
grad_keyword_t	struct
op_tab	array
[	O
]	O
=	O
{	O
{	O
"="	pointer
,	O
grad_operator_equal	int
}	O
,	O
{	O
"!="	pointer
,	O
grad_operator_not_equal	int
}	O
,	O
{	O
">"	pointer
,	O
grad_operator_greater_than	int
}	O
,	O
{	O
"<"	pointer
,	O
grad_operator_less_than	int
}	O
,	O
{	O
">="	pointer
,	O
grad_operator_greater_equal	int
}	O
,	O
{	O
"<="	pointer
,	O
grad_operator_less_equal	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
int	O
paircmp	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
check	pointer
,	O
char	O
*	O
pusername	pointer
)	O
;	O
int	O
fallthrough	function
(	O
grad_avp_t	struct
*	O
vp	pointer
)	O
;	O
static	O
int	O
portcmp	function
(	O
grad_avp_t	struct
*	O
check	pointer
,	O
grad_avp_t	struct
*	O
request	pointer
)	O
;	O
static	O
int	O
groupcmp	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
char	O
*	O
groupname	pointer
,	O
char	O
*	O
username	pointer
)	O
;	O
static	O
int	O
uidcmp	function
(	O
grad_avp_t	struct
*	O
check	pointer
,	O
char	O
*	O
username	pointer
)	O
;	O
static	O
void	O
matchrule_free	function
(	O
grad_matching_rule_t	struct
*	O
*	O
pl	pointer
)	O
;	O
static	O
int	O
matches	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
char	O
*	O
name	pointer
,	O
grad_matching_rule_t	struct
*	O
pl	pointer
,	O
char	O
*	O
matchpart	pointer
)	O
;	O
static	O
int	O
huntgroup_match	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
char	O
*	O
huntgroup	pointer
)	O
;	O
static	O
int	O
user_find_sym	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
*	O
check_pairs	pointer
,	O
grad_avp_t	struct
*	O
*	O
reply_pairs	pointer
)	O
;	O
static	O
grad_list_t	struct
*	O
file_read	function
(	O
int	O
cf_file	int
,	O
char	O
*	O
name	pointer
)	O
;	O
int	O
comp_op	function
(	O
enum	O
grad_operator	enum
op	enum
,	O
int	O
result	pointer
)	O
{	O
switch	O
(	O
op	enum
)	O
{	O
default	O
:	O
case	O
grad_operator_equal	int
:	O
if	O
(	O
result	pointer
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_not_equal	int
:	O
if	O
(	O
result	pointer
==	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_less_than	int
:	O
if	O
(	O
result	pointer
>=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_greater_than	int
:	O
if	O
(	O
result	pointer
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_less_equal	int
:	O
if	O
(	O
result	pointer
>	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
case	O
grad_operator_greater_equal	int
:	O
if	O
(	O
result	pointer
<	O
0	int
)	O
return	O
-	O
1	int
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
add_user_entry	function
(	O
void	O
*	O
closure	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
,	O
char	O
*	O
name	pointer
,	O
grad_avp_t	struct
*	O
check	pointer
,	O
grad_avp_t	struct
*	O
reply	pointer
)	O
{	O
grad_symtab_t	struct
*	O
symtab	pointer
=	O
closure	pointer
;	O
User_symbol	struct
*	O
sym	pointer
;	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
"DEFAULT"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
name	pointer
=	O
"DEFAULT"	pointer
;	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
"BEGIN"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
name	pointer
=	O
"BEGIN"	pointer
;	O
if	O
(	O
(	O
check	pointer
==	O
NULL	O
&&	O
reply	pointer
==	O
NULL	O
)	O
||	O
fix_check_pairs	function
(	O
GRAD_CF_USERS	int
,	O
loc	struct
,	O
name	pointer
,	O
&	O
check	pointer
)	O
||	O
fix_reply_pairs	function
(	O
GRAD_CF_USERS	int
,	O
loc	struct
,	O
name	pointer
,	O
&	O
reply	pointer
)	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"discarding user `%s'"	pointer
)	O
,	O
name	pointer
)	O
;	O
grad_avl_free	function
(	O
check	pointer
)	O
;	O
grad_avl_free	function
(	O
reply	pointer
)	O
;	O
return	O
0	int
;	O
}	O
sym	pointer
=	O
grad_sym_install	function
(	O
symtab	pointer
,	O
name	pointer
)	O
;	O
sym	pointer
->	O
check	pointer
=	O
check	pointer
;	O
sym	pointer
->	O
reply	pointer
=	O
reply	pointer
;	O
locus_dup	function
(	O
&	O
sym	pointer
->	O
loc	struct
,	O
loc	struct
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_user_entry	function
(	O
User_symbol	struct
*	O
sym	pointer
)	O
{	O
locus_free	function
(	O
&	O
sym	pointer
->	O
loc	struct
)	O
;	O
grad_avl_free	function
(	O
sym	pointer
->	O
check	pointer
)	O
;	O
grad_avl_free	function
(	O
sym	pointer
->	O
reply	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
temp_data	struct
{	O
int	O
cf_file	int
;	O
grad_list_t	struct
*	O
list	pointer
;	O
}	O
;	O
int	O
add_pairlist	function
(	O
void	O
*	O
closure	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
,	O
char	O
*	O
name	pointer
,	O
grad_avp_t	struct
*	O
lhs	pointer
,	O
grad_avp_t	struct
*	O
rhs	pointer
)	O
{	O
struct	O
temp_data	struct
*	O
data	pointer
=	O
closure	pointer
;	O
grad_matching_rule_t	struct
*	O
rule	pointer
;	O
if	O
(	O
(	O
lhs	pointer
==	O
NULL	O
&&	O
rhs	pointer
==	O
NULL	O
)	O
||	O
fix_check_pairs	function
(	O
data	pointer
->	O
cf_file	int
,	O
loc	struct
,	O
name	pointer
,	O
&	O
lhs	pointer
)	O
||	O
fix_reply_pairs	function
(	O
data	pointer
->	O
cf_file	int
,	O
loc	struct
,	O
name	pointer
,	O
&	O
rhs	pointer
)	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"discarding entry `%s'"	pointer
)	O
,	O
name	pointer
)	O
;	O
grad_avl_free	function
(	O
lhs	pointer
)	O
;	O
grad_avl_free	function
(	O
rhs	pointer
)	O
;	O
return	O
0	int
;	O
}	O
rule	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
grad_matching_rule_t	struct
)	O
)	O
;	O
rule	pointer
->	O
name	pointer
=	O
grad_estrdup	function
(	O
name	pointer
)	O
;	O
rule	pointer
->	O
lhs	pointer
=	O
lhs	pointer
;	O
rule	pointer
->	O
rhs	pointer
=	O
rhs	pointer
;	O
locus_dup	function
(	O
&	O
rule	pointer
->	O
loc	struct
,	O
loc	struct
)	O
;	O
grad_list_append	function
(	O
data	pointer
->	O
list	pointer
,	O
rule	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
read_users	function
(	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
!	O
user_tab	pointer
)	O
user_tab	pointer
=	O
grad_symtab_create	function
(	O
sizeof	O
(	O
User_symbol	struct
)	O
,	O
free_user_entry	function
)	O
;	O
return	O
grad_parse_rule_file	function
(	O
name	pointer
,	O
user_tab	pointer
,	O
add_user_entry	function
)	O
;	O
}	O
static	O
grad_list_t	struct
*	O
file_read	function
(	O
int	O
cf_file	int
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
temp_data	struct
tmp	struct
;	O
tmp	struct
.	O
cf_file	int
=	O
cf_file	int
;	O
tmp	struct
.	O
list	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_parse_rule_file	function
(	O
name	pointer
,	O
&	O
tmp	struct
,	O
add_pairlist	function
)	O
;	O
return	O
tmp	struct
.	O
list	pointer
;	O
}	O
enum	O
lookup_state	enum
{	O
LU_begin	int
,	O
LU_match	int
,	O
LU_default	int
}	O
;	O
typedef	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
enum	O
lookup_state	enum
state	pointer
;	O
User_symbol	struct
*	O
sym	pointer
;	O
}	O
USER_LOOKUP	struct
;	O
static	O
User_symbol	struct
*	O
user_lookup	function
(	O
char	O
*	O
name	pointer
,	O
USER_LOOKUP	struct
*	O
lptr	pointer
)	O
;	O
static	O
User_symbol	struct
*	O
user_next	function
(	O
USER_LOOKUP	struct
*	O
lptr	pointer
)	O
;	O
User_symbol	struct
*	O
user_lookup	function
(	O
char	O
*	O
name	pointer
,	O
USER_LOOKUP	struct
*	O
lptr	pointer
)	O
{	O
lptr	pointer
->	O
name	pointer
=	O
name	pointer
;	O
lptr	pointer
->	O
state	pointer
=	O
LU_begin	int
;	O
lptr	pointer
->	O
sym	pointer
=	O
grad_sym_lookup	function
(	O
user_tab	pointer
,	O
"BEGIN"	pointer
)	O
;	O
return	O
lptr	pointer
->	O
sym	pointer
?	O
lptr	pointer
->	O
sym	pointer
:	O
user_next	function
(	O
lptr	pointer
)	O
;	O
}	O
User_symbol	struct
*	O
user_next	function
(	O
USER_LOOKUP	struct
*	O
lptr	pointer
)	O
{	O
if	O
(	O
lptr	pointer
->	O
sym	pointer
&&	O
(	O
lptr	pointer
->	O
sym	pointer
=	O
grad_sym_next	function
(	O
(	O
grad_symbol_t	struct
*	O
)	O
lptr	pointer
->	O
sym	pointer
)	O
)	O
)	O
return	O
lptr	pointer
->	O
sym	pointer
;	O
switch	O
(	O
lptr	pointer
->	O
state	pointer
)	O
{	O
case	O
LU_begin	int
:	O
lptr	pointer
->	O
sym	pointer
=	O
grad_sym_lookup	function
(	O
user_tab	pointer
,	O
lptr	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
lptr	pointer
->	O
sym	pointer
)	O
{	O
lptr	pointer
->	O
state	pointer
=	O
LU_match	int
;	O
break	O
;	O
}	O
case	O
LU_match	int
:	O
lptr	pointer
->	O
state	pointer
=	O
LU_default	int
;	O
lptr	pointer
->	O
sym	pointer
=	O
grad_sym_lookup	function
(	O
user_tab	pointer
,	O
"DEFAULT"	pointer
)	O
;	O
break	O
;	O
case	O
LU_default	int
:	O
break	O
;	O
}	O
return	O
lptr	pointer
->	O
sym	pointer
;	O
}	O
static	O
int	O
match_user	function
(	O
User_symbol	struct
*	O
sym	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
*	O
check_pairs	pointer
,	O
grad_avp_t	struct
*	O
*	O
reply_pairs	pointer
)	O
;	O
int	O
user_find_sym	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
*	O
check_pairs	pointer
,	O
grad_avp_t	struct
*	O
*	O
reply_pairs	pointer
)	O
{	O
int	O
found	int
=	O
0	int
;	O
User_symbol	struct
*	O
sym	pointer
;	O
USER_LOOKUP	struct
lu	struct
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"looking for %s"	pointer
,	O
name	pointer
)	O
;	O
for	O
(	O
sym	pointer
=	O
user_lookup	function
(	O
name	pointer
,	O
&	O
lu	struct
)	O
;	O
sym	pointer
;	O
sym	pointer
=	O
user_next	function
(	O
&	O
lu	struct
)	O
)	O
{	O
if	O
(	O
match_user	function
(	O
sym	pointer
,	O
req	pointer
,	O
check_pairs	pointer
,	O
reply_pairs	pointer
)	O
)	O
{	O
if	O
(	O
lu	struct
.	O
state	pointer
!=	O
LU_begin	int
)	O
found	int
=	O
1	int
;	O
if	O
(	O
!	O
fallthrough	function
(	O
sym	pointer
->	O
reply	pointer
)	O
)	O
break	O
;	O
GRAD_DEBUG	O
(	O
1	int
,	O
"fall through"	pointer
)	O
;	O
lu	struct
.	O
sym	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
found	int
)	O
radiusd_sql_reply_attr_query	O
(	O
req	pointer
,	O
reply_pairs	pointer
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"returning %d"	pointer
,	O
found	int
)	O
;	O
return	O
found	int
;	O
}	O
int	O
match_user	function
(	O
User_symbol	struct
*	O
sym	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
*	O
check_pairs	pointer
,	O
grad_avp_t	struct
*	O
*	O
reply_pairs	pointer
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
;	O
grad_avp_t	struct
*	O
check_tmp	pointer
;	O
grad_avp_t	struct
*	O
reply_tmp	pointer
;	O
int	O
found	int
;	O
if	O
(	O
!	O
sym	pointer
)	O
return	O
0	int
;	O
found	int
=	O
0	int
;	O
do	O
{	O
check_tmp	pointer
=	O
grad_avl_dup	function
(	O
sym	pointer
->	O
check	pointer
)	O
;	O
radiusd_sql_check_attr_query	int
(	O
req	pointer
,	O
&	O
check_tmp	pointer
)	O
;	O
if	O
(	O
paircmp	function
(	O
req	pointer
,	O
check_tmp	pointer
,	O
NULL	O
)	O
)	O
{	O
grad_avl_free	function
(	O
check_tmp	pointer
)	O
;	O
continue	O
;	O
}	O
radius_req_register_locus	function
(	O
req	pointer
,	O
&	O
sym	pointer
->	O
loc	struct
)	O
;	O
found	int
=	O
1	int
;	O
for	O
(	O
p	pointer
=	O
grad_avl_find	function
(	O
sym	pointer
->	O
check	pointer
,	O
DA_MATCH_PROFILE	int
)	O
;	O
p	pointer
;	O
p	pointer
=	O
grad_avl_find	function
(	O
p	pointer
->	O
next	pointer
,	O
DA_MATCH_PROFILE	int
)	O
)	O
{	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"submatch: %s"	pointer
,	O
p	pointer
->	O
avp_strvalue	O
)	O
;	O
found	int
=	O
match_user	function
(	O
grad_sym_lookup	function
(	O
user_tab	pointer
,	O
p	pointer
->	O
avp_strvalue	O
)	O
,	O
req	pointer
,	O
check_pairs	pointer
,	O
reply_pairs	pointer
)	O
;	O
}	O
if	O
(	O
!	O
found	int
)	O
{	O
grad_avl_free	function
(	O
check_tmp	pointer
)	O
;	O
continue	O
;	O
}	O
reply_tmp	pointer
=	O
grad_avl_dup	function
(	O
sym	pointer
->	O
reply	pointer
)	O
;	O
grad_avl_merge	function
(	O
reply_pairs	pointer
,	O
&	O
reply_tmp	pointer
)	O
;	O
grad_avl_merge	function
(	O
check_pairs	pointer
,	O
&	O
check_tmp	pointer
)	O
;	O
grad_avl_free	function
(	O
reply_tmp	pointer
)	O
;	O
grad_avl_free	function
(	O
check_tmp	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
grad_avl_find	function
(	O
sym	pointer
->	O
reply	pointer
,	O
DA_MATCH_PROFILE	int
)	O
;	O
p	pointer
;	O
p	pointer
=	O
grad_avl_find	function
(	O
p	pointer
->	O
next	pointer
,	O
DA_MATCH_PROFILE	int
)	O
)	O
{	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"next: %s"	pointer
,	O
p	pointer
->	O
avp_strvalue	O
)	O
;	O
match_user	function
(	O
grad_sym_lookup	function
(	O
user_tab	pointer
,	O
p	pointer
->	O
avp_strvalue	O
)	O
,	O
req	pointer
,	O
check_pairs	pointer
,	O
reply_pairs	pointer
)	O
;	O
}	O
if	O
(	O
!	O
fallthrough	function
(	O
sym	pointer
->	O
reply	pointer
)	O
)	O
break	O
;	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"fall through near %s:%lu"	pointer
,	O
sym	pointer
->	O
loc	struct
.	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
sym	pointer
->	O
loc	struct
.	O
line	long
)	O
;	O
}	O
while	O
(	O
sym	pointer
=	O
grad_sym_next	function
(	O
(	O
grad_symbol_t	struct
*	O
)	O
sym	pointer
)	O
)	O
;	O
return	O
found	int
;	O
}	O
int	O
user_find	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
*	O
check_pairs	pointer
,	O
grad_avp_t	struct
*	O
*	O
reply_pairs	pointer
)	O
{	O
int	O
found	int
=	O
0	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"zero length username not permitted"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
found	int
=	O
user_find_sym	function
(	O
name	pointer
,	O
req	pointer
,	O
check_pairs	pointer
,	O
reply_pairs	pointer
)	O
;	O
if	O
(	O
!	O
found	int
)	O
return	O
-	O
1	int
;	O
grad_avl_delete	function
(	O
reply_pairs	pointer
,	O
DA_FALL_THROUGH	int
)	O
;	O
grad_avl_delete	function
(	O
reply_pairs	pointer
,	O
DA_MATCH_PROFILE	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
nextkn	function
(	O
char	O
*	O
*	O
sptr	pointer
,	O
char	O
*	O
token	pointer
,	O
int	O
toksize	int
)	O
{	O
char	O
*	O
start	pointer
;	O
while	O
(	O
*	O
*	O
sptr	pointer
&&	O
isws	O
(	O
*	O
*	O
sptr	pointer
)	O
)	O
++	O
(	O
*	O
sptr	pointer
)	O
;	O
if	O
(	O
!	O
*	O
*	O
sptr	pointer
)	O
return	O
-	O
1	int
;	O
start	pointer
=	O
token	pointer
;	O
if	O
(	O
*	O
*	O
sptr	pointer
==	O
'"'	O
)	O
{	O
(	O
*	O
sptr	pointer
)	O
++	O
;	O
while	O
(	O
toksize	int
&&	O
*	O
*	O
sptr	pointer
)	O
{	O
if	O
(	O
*	O
*	O
sptr	pointer
==	O
'\\'	O
&&	O
(	O
*	O
sptr	pointer
)	O
[	O
1	int
]	O
)	O
{	O
switch	O
(	O
*	O
++	O
*	O
sptr	pointer
)	O
{	O
default	O
:	O
*	O
token	pointer
++	O
=	O
*	O
*	O
sptr	pointer
;	O
break	O
;	O
case	O
'a'	O
:	O
*	O
token	pointer
++	O
=	O
'\a'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
token	pointer
++	O
=	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
token	pointer
++	O
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
token	pointer
++	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
token	pointer
++	O
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
token	pointer
++	O
=	O
'\t'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
*	O
token	pointer
++	O
=	O
'\v'	O
;	O
}	O
++	O
*	O
sptr	pointer
;	O
toksize	int
--	O
;	O
}	O
else	O
if	O
(	O
*	O
*	O
sptr	pointer
==	O
'"'	O
)	O
{	O
++	O
*	O
sptr	pointer
;	O
break	O
;	O
}	O
else	O
*	O
token	pointer
++	O
=	O
*	O
(	O
*	O
sptr	pointer
)	O
++	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
*	O
sptr	pointer
==	O
','	O
||	O
*	O
*	O
sptr	pointer
==	O
'='	O
||	O
*	O
*	O
sptr	pointer
==	O
'\n'	O
)	O
{	O
*	O
token	pointer
++	O
=	O
*	O
(	O
*	O
sptr	pointer
)	O
++	O
;	O
}	O
else	O
{	O
while	O
(	O
toksize	int
&&	O
*	O
*	O
sptr	pointer
&&	O
!	O
isdelim	O
(	O
*	O
*	O
sptr	pointer
)	O
)	O
{	O
*	O
token	pointer
++	O
=	O
*	O
(	O
*	O
sptr	pointer
)	O
++	O
;	O
toksize	int
--	O
;	O
}	O
}	O
*	O
token	pointer
=	O
0	int
;	O
return	O
start	pointer
[	O
0	int
]	O
;	O
}	O
int	O
userparse	function
(	O
char	O
*	O
buffer	pointer
,	O
grad_avp_t	struct
*	O
*	O
first_pair	pointer
,	O
char	O
*	O
*	O
errmsg	pointer
)	O
{	O
int	O
state	pointer
;	O
grad_dict_attr_t	struct
*	O
attr	pointer
=	O
NULL	O
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
int	O
op	enum
;	O
static	O
char	O
errbuf	array
[	O
512	int
]	O
;	O
char	O
token	pointer
[	O
256	int
]	O
;	O
grad_locus_t	struct
loc	struct
;	O
loc	struct
.	O
file	pointer
=	O
"<stdin>"	pointer
;	O
loc	struct
.	O
line	long
=	O
0	int
;	O
state	pointer
=	O
PS_LHS	int
;	O
while	O
(	O
nextkn	function
(	O
&	O
buffer	pointer
,	O
token	pointer
,	O
sizeof	O
(	O
token	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
PS_LHS	int
:	O
if	O
(	O
token	pointer
[	O
0	int
]	O
==	O
'\n'	O
||	O
token	pointer
[	O
0	int
]	O
==	O
'#'	O
)	O
continue	O
;	O
if	O
(	O
!	O
(	O
attr	pointer
=	O
grad_attr_name_to_dict	function
(	O
token	pointer
)	O
)	O
)	O
{	O
snprintf	function
(	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
,	O
_	O
(	O
"unknown attribute `%s/%s'"	pointer
)	O
,	O
token	pointer
,	O
buffer	pointer
)	O
;	O
*	O
errmsg	pointer
=	O
errbuf	array
;	O
return	O
-	O
1	int
;	O
}	O
state	pointer
=	O
PS_OPS	int
;	O
break	O
;	O
case	O
PS_OPS	int
:	O
op	enum
=	O
grad_xlat_keyword	function
(	O
op_tab	array
,	O
token	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
op	enum
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
,	O
_	O
(	O
"expected %s, but found %s"	pointer
)	O
,	O
_	O
(	O
"opcode"	pointer
)	O
,	O
token	pointer
)	O
;	O
*	O
errmsg	pointer
=	O
errbuf	array
;	O
return	O
-	O
1	int
;	O
}	O
state	pointer
=	O
PS_RHS	int
;	O
break	O
;	O
case	O
PS_RHS	int
:	O
pair	pointer
=	O
grad_create_pair	function
(	O
&	O
loc	struct
,	O
attr	pointer
->	O
name	pointer
,	O
op	enum
,	O
token	pointer
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
{	O
snprintf	function
(	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
,	O
_	O
(	O
"grad_create_pair failed on %s"	pointer
)	O
,	O
attr	pointer
->	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
grad_avl_merge	function
(	O
first_pair	pointer
,	O
&	O
pair	pointer
)	O
;	O
state	pointer
=	O
PS_END	int
;	O
break	O
;	O
case	O
PS_END	int
:	O
if	O
(	O
token	pointer
[	O
0	int
]	O
!=	O
','	O
&&	O
token	pointer
[	O
0	int
]	O
!=	O
'\n'	O
)	O
{	O
snprintf	function
(	O
errbuf	array
,	O
sizeof	O
(	O
errbuf	array
)	O
,	O
_	O
(	O
"expected %s, but found %s"	pointer
)	O
,	O
"','"	pointer
,	O
token	pointer
)	O
;	O
*	O
errmsg	pointer
=	O
errbuf	array
;	O
return	O
-	O
1	int
;	O
}	O
state	pointer
=	O
PS_LHS	int
;	O
break	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
avl_eval_rewrite	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_matching_rule_t	struct
*	O
rule	pointer
,	O
grad_avp_t	struct
*	O
p	pointer
)	O
{	O
for	O
(	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
attribute	int
==	O
DA_REWRITE_FUNCTION	int
&&	O
rewrite_eval	function
(	O
p	pointer
->	O
avp_strvalue	O
,	O
req	pointer
->	O
request	pointer
,	O
NULL	O
)	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
rule	pointer
->	O
loc	struct
,	O
"%s(): %s"	pointer
,	O
p	pointer
->	O
avp_strvalue	O
,	O
_	O
(	O
"not defined"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
void	O
rule_eval_rewrite	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_matching_rule_t	struct
*	O
rule	pointer
)	O
{	O
avl_eval_rewrite	function
(	O
req	pointer
,	O
rule	pointer
,	O
rule	pointer
->	O
rhs	pointer
)	O
;	O
avl_eval_rewrite	function
(	O
req	pointer
,	O
rule	pointer
,	O
rule	pointer
->	O
lhs	pointer
)	O
;	O
}	O
int	O
exec_program_wait	function
(	O
radiusd_request_t	struct
*	O
request	pointer
,	O
grad_avp_t	struct
*	O
rhs	pointer
,	O
grad_avp_t	struct
*	O
*	O
reply	pointer
,	O
grad_avp_t	struct
*	O
*	O
pfailed	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
grad_avp_t	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
rhs	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
attribute	int
==	O
DA_EXEC_PROGRAM_WAIT	int
)	O
{	O
radius_eval_avp	function
(	O
request	pointer
,	O
p	pointer
,	O
reply	pointer
?	O
*	O
reply	pointer
:	O
NULL	O
,	O
1	int
)	O
;	O
switch	O
(	O
p	pointer
->	O
avp_strvalue	O
[	O
0	int
]	O
)	O
{	O
case	O
'/'	O
:	O
rc	int
=	O
radius_exec_program	function
(	O
p	pointer
->	O
avp_strvalue	O
,	O
request	pointer
,	O
reply	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
rc	int
=	O
filter_auth	function
(	O
p	pointer
->	O
avp_strvalue	O
+	O
1	int
,	O
request	pointer
,	O
reply	pointer
)	O
;	O
break	O
;	O
default	O
:	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
request	pointer
->	O
request	pointer
,	O
_	O
(	O
"cannot execute `%s'"	pointer
)	O
,	O
p	pointer
->	O
avp_strvalue	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
pfailed	pointer
)	O
*	O
pfailed	pointer
=	O
p	pointer
;	O
break	O
;	O
}	O
}	O
}	O
return	O
rc	int
;	O
}	O
static	O
void	O
hints_eval_compat	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
name_pair	pointer
,	O
grad_matching_rule_t	struct
*	O
rule	pointer
)	O
{	O
grad_avp_t	struct
*	O
tmp	struct
;	O
if	O
(	O
(	O
tmp	struct
=	O
grad_avl_find	function
(	O
rule	pointer
->	O
rhs	pointer
,	O
DA_REPLACE_USER_NAME	int
)	O
)	O
||	O
(	O
tmp	struct
=	O
grad_avl_find	function
(	O
rule	pointer
->	O
lhs	pointer
,	O
DA_REPLACE_USER_NAME	int
)	O
)	O
)	O
{	O
char	O
*	O
ptr	pointer
;	O
struct	O
obstack	struct
hints_stk	struct
;	O
obstack_init	O
(	O
&	O
hints_stk	struct
)	O
;	O
ptr	pointer
=	O
radius_xlate	function
(	O
&	O
hints_stk	struct
,	O
tmp	struct
->	O
avp_strvalue	O
,	O
req	pointer
->	O
request	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ptr	pointer
)	O
grad_string_replace	function
(	O
&	O
name_pair	pointer
->	O
avp_strvalue	O
,	O
ptr	pointer
)	O
;	O
obstack_free	function
(	O
&	O
hints_stk	struct
,	O
NULL	O
)	O
;	O
}	O
rule_eval_rewrite	function
(	O
req	pointer
,	O
rule	pointer
)	O
;	O
}	O
int	O
hints_setup	function
(	O
radiusd_request_t	struct
*	O
req	pointer
)	O
{	O
char	O
newname	array
[	O
GRAD_STRING_LENGTH	int
]	O
;	O
grad_avp_t	struct
*	O
name_pair	pointer
;	O
grad_avp_t	struct
*	O
orig_name_pair	pointer
;	O
grad_avp_t	struct
*	O
tmp_name_pair	pointer
;	O
grad_avp_t	struct
*	O
tmp	struct
;	O
grad_matching_rule_t	struct
*	O
rule	pointer
;	O
int	O
matched	int
=	O
0	int
;	O
grad_iterator_t	struct
*	O
itr	pointer
;	O
switch	O
(	O
req	pointer
->	O
request	pointer
->	O
code	char
)	O
{	O
case	O
RT_ACCESS_ACCEPT	int
:	O
case	O
RT_ACCESS_REJECT	int
:	O
case	O
RT_ACCOUNTING_RESPONSE	int
:	O
case	O
RT_ACCESS_CHALLENGE	int
:	O
tmp	struct
=	O
grad_avp_create_integer	function
(	O
DA_PROXY_REPLIED	int
,	O
1	int
)	O
;	O
grad_avl_merge	function
(	O
&	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
&	O
tmp	struct
)	O
;	O
grad_avp_free	function
(	O
tmp	struct
)	O
;	O
break	O
;	O
case	O
RT_STATUS_SERVER	int
:	O
return	O
0	int
;	O
}	O
if	O
(	O
hints	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
name_pair	pointer
=	O
grad_avl_find	function
(	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_USER_NAME	int
)	O
)	O
==	O
NULL	O
)	O
{	O
tmp_name_pair	pointer
=	O
grad_avp_create_string	function
(	O
DA_USER_NAME	int
,	O
""	pointer
)	O
;	O
name_pair	pointer
=	O
tmp_name_pair	pointer
;	O
orig_name_pair	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
orig_name_pair	pointer
=	O
grad_avp_create_string	function
(	O
DA_ORIG_USER_NAME	int
,	O
name_pair	pointer
->	O
avp_strvalue	O
)	O
;	O
}	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"called for `%s'"	pointer
,	O
name_pair	pointer
->	O
avp_strvalue	O
)	O
;	O
if	O
(	O
grad_avl_find	function
(	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_FRAMED_PROTOCOL	int
)	O
!=	O
NULL	O
&&	O
grad_avl_find	function
(	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_SERVICE_TYPE	int
)	O
==	O
NULL	O
)	O
{	O
tmp	struct
=	O
grad_avp_create_integer	function
(	O
DA_SERVICE_TYPE	int
,	O
DV_SERVICE_TYPE_FRAMED_USER	int
)	O
;	O
if	O
(	O
tmp	struct
)	O
grad_avl_merge	function
(	O
&	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
&	O
tmp	struct
)	O
;	O
}	O
itr	pointer
=	O
grad_iterator_create	function
(	O
hints	pointer
)	O
;	O
for	O
(	O
rule	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
rule	pointer
;	O
rule	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
int	O
do_strip	int
;	O
grad_avp_t	struct
*	O
add	pointer
;	O
if	O
(	O
matches	function
(	O
req	pointer
,	O
name_pair	pointer
->	O
avp_strvalue	O
,	O
rule	pointer
,	O
newname	array
)	O
)	O
continue	O
;	O
matched	int
++	O
;	O
radius_req_register_locus	function
(	O
req	pointer
,	O
&	O
rule	pointer
->	O
loc	struct
)	O
;	O
GRAD_DEBUG3	O
(	O
1	int
,	O
"matched %s at %s:%lu"	pointer
,	O
rule	pointer
->	O
name	pointer
,	O
rule	pointer
->	O
loc	struct
.	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
rule	pointer
->	O
loc	struct
.	O
line	long
)	O
;	O
add	pointer
=	O
grad_avl_dup	function
(	O
rule	pointer
->	O
rhs	pointer
)	O
;	O
do_strip	int
=	O
1	int
;	O
if	O
(	O
(	O
tmp	struct
=	O
grad_avl_find	function
(	O
rule	pointer
->	O
rhs	pointer
,	O
DA_STRIP_USER_NAME	int
)	O
)	O
!=	O
NULL	O
||	O
(	O
tmp	struct
=	O
grad_avl_find	function
(	O
rule	pointer
->	O
lhs	pointer
,	O
DA_STRIP_USER_NAME	int
)	O
)	O
!=	O
NULL	O
)	O
do_strip	int
=	O
tmp	struct
->	O
avp_lvalue	O
;	O
if	O
(	O
do_strip	int
)	O
grad_string_replace	function
(	O
&	O
name_pair	pointer
->	O
avp_strvalue	O
,	O
newname	array
)	O
;	O
hints_eval_compat	function
(	O
req	pointer
,	O
name_pair	pointer
,	O
rule	pointer
)	O
;	O
exec_program_wait	function
(	O
req	pointer
,	O
rule	pointer
->	O
rhs	pointer
,	O
&	O
add	pointer
,	O
NULL	O
)	O
;	O
radius_eval_avl	function
(	O
req	pointer
,	O
add	pointer
)	O
;	O
grad_avl_delete	function
(	O
&	O
add	pointer
,	O
DA_STRIP_USER_NAME	int
)	O
;	O
grad_avl_delete	function
(	O
&	O
add	pointer
,	O
DA_REPLACE_USER_NAME	int
)	O
;	O
grad_avl_delete	function
(	O
&	O
add	pointer
,	O
DA_REWRITE_FUNCTION	int
)	O
;	O
grad_avl_merge	function
(	O
&	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
&	O
add	pointer
)	O
;	O
grad_avl_free	function
(	O
add	pointer
)	O
;	O
tmp	struct
=	O
grad_avl_find	function
(	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_USER_NAME	int
)	O
;	O
if	O
(	O
tmp	struct
)	O
name_pair	pointer
=	O
tmp	struct
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"new name is `%s'"	pointer
,	O
name_pair	pointer
->	O
avp_strvalue	O
)	O
;	O
name_pair	pointer
->	O
avp_strlength	O
=	O
strlen	function
(	O
name_pair	pointer
->	O
avp_strvalue	O
)	O
;	O
if	O
(	O
(	O
(	O
tmp	struct
=	O
grad_avl_find	function
(	O
rule	pointer
->	O
rhs	pointer
,	O
DA_FALL_THROUGH	int
)	O
)	O
!=	O
NULL	O
||	O
(	O
tmp	struct
=	O
grad_avl_find	function
(	O
rule	pointer
->	O
lhs	pointer
,	O
DA_FALL_THROUGH	int
)	O
)	O
!=	O
NULL	O
)	O
&&	O
tmp	struct
->	O
avp_lvalue	O
)	O
continue	O
;	O
break	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
if	O
(	O
matched	int
)	O
{	O
if	O
(	O
orig_name_pair	pointer
)	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
orig_name_pair	pointer
)	O
;	O
else	O
if	O
(	O
!	O
grad_avl_find	function
(	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_USER_NAME	int
)	O
)	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
tmp_name_pair	pointer
)	O
;	O
else	O
grad_avp_free	function
(	O
tmp_name_pair	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
orig_name_pair	pointer
)	O
grad_avp_free	function
(	O
orig_name_pair	pointer
)	O
;	O
else	O
grad_avp_free	function
(	O
tmp_name_pair	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
huntgroup_match	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
char	O
*	O
huntgroup	pointer
)	O
{	O
grad_matching_rule_t	struct
*	O
rule	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
;	O
if	O
(	O
!	O
huntgroups	pointer
)	O
return	O
0	int
;	O
itr	pointer
=	O
grad_iterator_create	function
(	O
huntgroups	pointer
)	O
;	O
for	O
(	O
rule	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
rule	pointer
;	O
rule	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
rule	pointer
->	O
name	pointer
,	O
huntgroup	pointer
)	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
paircmp	function
(	O
req	pointer
,	O
rule	pointer
->	O
lhs	pointer
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
GRAD_DEBUG3	O
(	O
1	int
,	O
"matched %s at %s:%lu"	pointer
,	O
rule	pointer
->	O
name	pointer
,	O
rule	pointer
->	O
loc	struct
.	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
rule	pointer
->	O
loc	struct
.	O
line	long
)	O
;	O
break	O
;	O
}	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
return	O
(	O
rule	pointer
!=	O
NULL	O
)	O
;	O
}	O
int	O
huntgroup_access	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
grad_avp_t	struct
*	O
pair	pointer
;	O
grad_matching_rule_t	struct
*	O
rule	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
;	O
int	O
r	pointer
=	O
1	int
;	O
if	O
(	O
huntgroups	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
itr	pointer
=	O
grad_iterator_create	function
(	O
huntgroups	pointer
)	O
;	O
for	O
(	O
rule	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
rule	pointer
;	O
rule	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
paircmp	function
(	O
radreq	pointer
,	O
rule	pointer
->	O
lhs	pointer
,	O
NULL	O
)	O
!=	O
0	int
)	O
continue	O
;	O
GRAD_DEBUG2	O
(	O
1	int
,	O
"matched huntgroup at %s:%lu"	pointer
,	O
rule	pointer
->	O
loc	struct
.	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
rule	pointer
->	O
loc	struct
.	O
line	long
)	O
;	O
r	pointer
=	O
paircmp	function
(	O
radreq	pointer
,	O
rule	pointer
->	O
rhs	pointer
,	O
NULL	O
)	O
==	O
0	int
;	O
break	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
if	O
(	O
rule	pointer
)	O
{	O
if	O
(	O
loc	struct
)	O
*	O
loc	struct
=	O
rule	pointer
->	O
loc	struct
;	O
radius_req_register_locus	function
(	O
radreq	pointer
,	O
&	O
rule	pointer
->	O
loc	struct
)	O
;	O
rule_eval_rewrite	function
(	O
radreq	pointer
,	O
rule	pointer
)	O
;	O
}	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"returning %d"	pointer
,	O
r	pointer
)	O
;	O
return	O
r	pointer
;	O
}	O
int	O
read_naslist_file	function
(	O
char	O
*	O
file	pointer
)	O
{	O
return	O
grad_nas_read_file	function
(	O
file	pointer
)	O
;	O
}	O
int	O
read_clients_entry	function
(	O
void	O
*	O
u	pointer
ARG_UNUSED	O
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
CLIENT	struct
*	O
cp	pointer
;	O
if	O
(	O
fc	int
!=	O
2	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"wrong number of fields"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
cp	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
CLIENT	struct
)	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
fv	pointer
[	O
0	int
]	O
,	O
"DEFAULT"	pointer
)	O
==	O
0	int
)	O
cp	pointer
->	O
netdef	struct
.	O
ipaddr	int
=	O
cp	pointer
->	O
netdef	struct
.	O
netmask	int
=	O
0	int
;	O
else	O
grad_ip_getnetaddr	function
(	O
fv	pointer
[	O
0	int
]	O
,	O
&	O
cp	pointer
->	O
netdef	struct
)	O
;	O
cp	pointer
->	O
secret	pointer
=	O
grad_estrdup	function
(	O
fv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
fc	int
==	O
3	int
)	O
GRAD_STRING_COPY	O
(	O
cp	pointer
->	O
shortname	array
,	O
fv	pointer
[	O
2	int
]	O
)	O
;	O
grad_ip_gethostname	function
(	O
cp	pointer
->	O
netdef	struct
.	O
ipaddr	int
,	O
cp	pointer
->	O
longname	array
,	O
sizeof	O
(	O
cp	pointer
->	O
longname	array
)	O
)	O
;	O
grad_list_append	function
(	O
clients	pointer
,	O
cp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
client_free	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
ARG_UNUSED	O
)	O
{	O
CLIENT	struct
*	O
cl	pointer
=	O
item	pointer
;	O
grad_free	function
(	O
cl	pointer
->	O
secret	pointer
)	O
;	O
grad_free	function
(	O
cl	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
read_clients_file	function
(	O
char	O
*	O
file	pointer
)	O
{	O
grad_list_destroy	function
(	O
&	O
clients	pointer
,	O
client_free	function
,	O
NULL	O
)	O
;	O
clients	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
return	O
grad_read_raddb_file	function
(	O
file	pointer
,	O
1	int
,	O
NULL	O
,	O
read_clients_entry	function
,	O
NULL	O
)	O
;	O
}	O
CLIENT	struct
*	O
client_lookup_ip	function
(	O
grad_uint32_t	int
ipaddr	int
)	O
{	O
CLIENT	struct
*	O
cl	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
clients	pointer
)	O
;	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
NULL	O
;	O
for	O
(	O
cl	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
cl	pointer
;	O
cl	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
if	O
(	O
grad_ip_in_net_p	function
(	O
&	O
cl	pointer
->	O
netdef	struct
,	O
ipaddr	int
)	O
)	O
{	O
char	O
ipbuf	array
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
char	O
maskbuf	array
[	O
GRAD_IPV4_STRING_LENGTH	int
]	O
;	O
GRAD_DEBUG4	O
(	O
10	int
,	O
"Found secret for %s/%s (%s): %s"	pointer
,	O
grad_ip_iptostr	function
(	O
cl	pointer
->	O
netdef	struct
.	O
ipaddr	int
,	O
ipbuf	array
)	O
,	O
grad_ip_iptostr	function
(	O
cl	pointer
->	O
netdef	struct
.	O
netmask	int
,	O
maskbuf	array
)	O
,	O
cl	pointer
->	O
longname	array
,	O
cl	pointer
->	O
secret	pointer
)	O
;	O
break	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
return	O
cl	pointer
;	O
}	O
char	O
*	O
client_lookup_name	function
(	O
grad_uint32_t	int
ipaddr	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
bufsize	long
)	O
{	O
CLIENT	struct
*	O
cl	pointer
;	O
if	O
(	O
(	O
cl	pointer
=	O
client_lookup_ip	function
(	O
ipaddr	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
cl	pointer
->	O
shortname	array
[	O
0	int
]	O
)	O
return	O
cl	pointer
->	O
shortname	array
;	O
else	O
return	O
cl	pointer
->	O
longname	array
;	O
}	O
return	O
grad_ip_gethostname	function
(	O
ipaddr	int
,	O
buf	pointer
,	O
bufsize	long
)	O
;	O
}	O
int	O
read_nastypes_entry	function
(	O
void	O
*	O
u	pointer
ARG_UNUSED	O
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
RADCK_TYPE	struct
*	O
mp	pointer
;	O
int	O
method	int
;	O
int	O
i	int
;	O
if	O
(	O
fc	int
<	O
2	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"too few fields"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
fv	pointer
[	O
1	int
]	O
,	O
"finger"	pointer
)	O
==	O
0	int
)	O
method	int
=	O
METHOD_FINGER	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
fv	pointer
[	O
1	int
]	O
,	O
"snmp"	pointer
)	O
==	O
0	int
)	O
method	int
=	O
METHOD_SNMP	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
fv	pointer
[	O
1	int
]	O
,	O
"ext"	pointer
)	O
==	O
0	int
)	O
method	int
=	O
METHOD_EXT	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
fv	pointer
[	O
1	int
]	O
,	O
"guile"	pointer
)	O
==	O
0	int
)	O
method	int
=	O
METHOD_GUILE	int
;	O
else	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"unknown method"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
mp	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
mp	pointer
)	O
)	O
;	O
mp	pointer
->	O
type	enum
=	O
grad_estrdup	function
(	O
fv	pointer
[	O
0	int
]	O
)	O
;	O
mp	pointer
->	O
method	int
=	O
method	int
;	O
mp	pointer
->	O
args	pointer
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
fc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
','	O
)	O
continue	O
;	O
if	O
(	O
fc	int
-	O
i	int
>	O
2	int
&&	O
fv	pointer
[	O
i	int
+	O
1	int
]	O
[	O
0	int
]	O
==	O
'='	O
)	O
{	O
grad_envar_assign	function
(	O
fv	pointer
[	O
i	int
]	O
,	O
fv	pointer
[	O
i	int
+	O
2	int
]	O
,	O
&	O
mp	pointer
->	O
args	pointer
)	O
;	O
i	int
+=	O
2	int
;	O
}	O
else	O
{	O
grad_envar_assign	function
(	O
fv	pointer
[	O
i	int
]	O
,	O
NULL	O
,	O
&	O
mp	pointer
->	O
args	pointer
)	O
;	O
}	O
}	O
grad_list_append	function
(	O
radck_type	struct
,	O
mp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_radck_type	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
ARG_UNUSED	O
)	O
{	O
RADCK_TYPE	struct
*	O
rp	pointer
=	O
item	pointer
;	O
grad_free	function
(	O
rp	pointer
->	O
type	enum
)	O
;	O
grad_envar_free_list	function
(	O
&	O
rp	pointer
->	O
args	pointer
)	O
;	O
grad_free	function
(	O
rp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
read_nastypes_file	function
(	O
char	O
*	O
file	pointer
)	O
{	O
grad_list_destroy	function
(	O
&	O
radck_type	struct
,	O
free_radck_type	function
,	O
NULL	O
)	O
;	O
radck_type	struct
=	O
grad_list_create	function
(	O
)	O
;	O
return	O
grad_read_raddb_file	function
(	O
file	pointer
,	O
0	int
,	O
",="	pointer
,	O
read_nastypes_entry	function
,	O
NULL	O
)	O
;	O
}	O
RADCK_TYPE	struct
*	O
find_radck_type	function
(	O
char	O
*	O
name	pointer
)	O
{	O
RADCK_TYPE	struct
*	O
tp	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
radck_type	struct
)	O
;	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
NULL	O
;	O
for	O
(	O
tp	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
tp	pointer
&&	O
strcmp	function
(	O
tp	pointer
->	O
type	enum
,	O
name	pointer
)	O
;	O
tp	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
;	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
return	O
tp	pointer
;	O
}	O
void	O
add_deny	function
(	O
char	O
*	O
user	pointer
)	O
{	O
grad_sym_install	function
(	O
deny_tab	pointer
,	O
user	pointer
)	O
;	O
}	O
int	O
read_denylist_entry	function
(	O
void	O
*	O
closure	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
int	O
*	O
denycnt	pointer
=	O
closure	pointer
;	O
if	O
(	O
fc	int
!=	O
1	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"wrong number of fields"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
get_deny	function
(	O
fv	pointer
[	O
0	int
]	O
)	O
)	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"user `%s' already found in %s"	pointer
)	O
,	O
fv	pointer
[	O
0	int
]	O
,	O
RADIUS_DENY	pointer
)	O
;	O
else	O
{	O
add_deny	function
(	O
fv	pointer
[	O
0	int
]	O
)	O
;	O
(	O
*	O
denycnt	pointer
)	O
++	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
read_deny_file	function
(	O
)	O
{	O
int	O
denycnt	pointer
;	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_DENY	pointer
)	O
;	O
if	O
(	O
deny_tab	pointer
)	O
grad_symtab_clear	function
(	O
deny_tab	pointer
)	O
;	O
else	O
deny_tab	pointer
=	O
grad_symtab_create	function
(	O
sizeof	O
(	O
grad_symbol_t	struct
)	O
,	O
NULL	O
)	O
;	O
denycnt	pointer
=	O
0	int
;	O
grad_read_raddb_file	function
(	O
name	pointer
,	O
0	int
,	O
NULL	O
,	O
read_denylist_entry	function
,	O
&	O
denycnt	pointer
)	O
;	O
grad_free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
denycnt	pointer
)	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
ngettext	function
(	O
"%d user disabled"	pointer
,	O
"%d users disabled"	pointer
,	O
denycnt	pointer
)	O
,	O
denycnt	pointer
)	O
;	O
}	O
int	O
get_deny	function
(	O
char	O
*	O
user	pointer
)	O
{	O
return	O
grad_sym_lookup	function
(	O
deny_tab	pointer
,	O
user	pointer
)	O
!=	O
NULL	O
;	O
}	O
int	O
fallthrough	function
(	O
grad_avp_t	struct
*	O
vp	pointer
)	O
{	O
grad_avp_t	struct
*	O
tmp	struct
;	O
return	O
(	O
tmp	struct
=	O
grad_avl_find	function
(	O
vp	pointer
,	O
DA_FALL_THROUGH	int
)	O
)	O
?	O
tmp	struct
->	O
avp_lvalue	O
:	O
0	int
;	O
}	O
int	O
portcmp	function
(	O
grad_avp_t	struct
*	O
check	pointer
,	O
grad_avp_t	struct
*	O
request	pointer
)	O
{	O
char	O
buf	pointer
[	O
GRAD_STRING_LENGTH	int
]	O
;	O
char	O
*	O
s	pointer
,	O
*	O
p	pointer
,	O
*	O
save	pointer
;	O
int	O
lo	int
,	O
hi	int
;	O
int	O
port	array
=	O
request	pointer
->	O
avp_lvalue	O
;	O
strcpy	function
(	O
buf	pointer
,	O
check	pointer
->	O
avp_strvalue	O
)	O
;	O
s	pointer
=	O
strtok_r	function
(	O
buf	pointer
,	O
","	pointer
,	O
&	O
save	pointer
)	O
;	O
while	O
(	O
s	pointer
)	O
{	O
if	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'-'	O
)	O
)	O
!=	O
NULL	O
)	O
p	pointer
++	O
;	O
else	O
p	pointer
=	O
s	pointer
;	O
lo	int
=	O
atoi	function
(	O
s	pointer
)	O
;	O
hi	int
=	O
atoi	function
(	O
p	pointer
)	O
;	O
if	O
(	O
lo	int
<=	O
port	array
&&	O
port	array
<=	O
hi	int
)	O
{	O
return	O
0	int
;	O
}	O
s	pointer
=	O
strtok_r	function
(	O
NULL	O
,	O
","	pointer
,	O
&	O
save	pointer
)	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
uidcmp	function
(	O
grad_avp_t	struct
*	O
check	pointer
,	O
char	O
*	O
username	pointer
)	O
{	O
struct	O
passwd	struct
pw	pointer
,	O
*	O
pwd	pointer
;	O
char	O
buffer	pointer
[	O
512	int
]	O
;	O
if	O
(	O
!	O
(	O
pwd	pointer
=	O
grad_getpwnam_r	function
(	O
username	pointer
,	O
&	O
pw	pointer
,	O
buffer	pointer
,	O
sizeof	O
buffer	pointer
)	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
pwd	pointer
->	O
pw_uid	int
-	O
check	pointer
->	O
avp_lvalue	O
;	O
}	O
static	O
int	O
system_groupcmp	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
char	O
*	O
groupname	pointer
,	O
char	O
*	O
username	pointer
)	O
{	O
struct	O
passwd	struct
pw	pointer
,	O
*	O
pwd	pointer
;	O
struct	O
group	struct
*	O
grp	pointer
;	O
char	O
*	O
*	O
member	pointer
;	O
char	O
pwbuf	pointer
[	O
512	int
]	O
;	O
int	O
retval	int
;	O
if	O
(	O
!	O
(	O
pwd	pointer
=	O
grad_getpwnam_r	function
(	O
username	pointer
,	O
&	O
pw	pointer
,	O
pwbuf	pointer
,	O
sizeof	O
pwbuf	pointer
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
(	O
grp	pointer
=	O
grad_getgrnam	function
(	O
groupname	pointer
)	O
)	O
)	O
return	O
1	int
;	O
retval	int
=	O
!	O
(	O
pwd	pointer
->	O
pw_gid	int
==	O
grp	pointer
->	O
gr_gid	int
)	O
;	O
for	O
(	O
member	pointer
=	O
grp	pointer
->	O
gr_mem	pointer
;	O
*	O
member	pointer
&&	O
retval	int
;	O
member	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
*	O
member	pointer
,	O
pwd	pointer
->	O
pw_name	pointer
)	O
==	O
0	int
)	O
retval	int
=	O
0	int
;	O
}	O
grad_free	function
(	O
grp	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
groupcmp	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
char	O
*	O
groupname	pointer
,	O
char	O
*	O
username	pointer
)	O
{	O
int	O
retval	int
;	O
return	O
system_groupcmp	function
(	O
req	pointer
,	O
groupname	pointer
,	O
username	pointer
)	O
&&	O
radiusd_sql_checkgroup	int
(	O
req	pointer
,	O
groupname	pointer
)	O
;	O
}	O
int	O
presufcmp	function
(	O
grad_avp_t	struct
*	O
check	pointer
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
rest	pointer
)	O
{	O
int	O
len	int
,	O
namelen	int
;	O
int	O
ret	int
=	O
-	O
1	int
;	O
GRAD_DEBUG3	O
(	O
1	int
,	O
"comparing %s and %s, check->attr is %d"	pointer
,	O
name	pointer
,	O
check	pointer
->	O
avp_strvalue	O
,	O
check	pointer
->	O
attribute	int
)	O
;	O
len	int
=	O
strlen	function
(	O
check	pointer
->	O
avp_strvalue	O
)	O
;	O
switch	O
(	O
check	pointer
->	O
attribute	int
)	O
{	O
case	O
DA_PREFIX	int
:	O
ret	int
=	O
strncmp	function
(	O
name	pointer
,	O
check	pointer
->	O
avp_strvalue	O
,	O
len	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
&&	O
rest	pointer
)	O
strcpy	function
(	O
rest	pointer
,	O
name	pointer
+	O
len	int
)	O
;	O
break	O
;	O
case	O
DA_SUFFIX	int
:	O
namelen	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
namelen	int
<	O
len	int
)	O
break	O
;	O
ret	int
=	O
strcmp	function
(	O
name	pointer
+	O
namelen	int
-	O
len	int
,	O
check	pointer
->	O
avp_strvalue	O
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
&&	O
rest	pointer
)	O
{	O
strncpy	function
(	O
rest	pointer
,	O
name	pointer
,	O
namelen	int
-	O
len	int
)	O
;	O
rest	pointer
[	O
namelen	int
-	O
len	int
]	O
=	O
0	int
;	O
}	O
break	O
;	O
}	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"returning %d"	pointer
,	O
ret	int
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
server_check_items	array
[	O
]	O
=	O
{	O
DA_EXPIRATION	int
,	O
DA_LOGIN_TIME	int
,	O
DA_USER_PASSWORD	int
,	O
DA_CRYPT_PASSWORD	int
,	O
DA_PASSWORD_LOCATION	int
,	O
DA_AUTH_TYPE	int
,	O
DA_PAM_AUTH	int
,	O
DA_SIMULTANEOUS_USE	int
,	O
DA_STRIP_USER_NAME	int
,	O
DA_REPLACE_USER_NAME	int
,	O
DA_REWRITE_FUNCTION	int
,	O
DA_ACCT_TYPE	int
,	O
DA_LOG_MODE_MASK	int
,	O
DA_MENU	int
,	O
DA_TERMINATION_MENU	int
,	O
DA_GROUP_NAME	int
,	O
DA_MATCH_PROFILE	int
,	O
DA_AUTH_DATA	int
}	O
;	O
int	O
server_attr	function
(	O
int	O
attr	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GRAD_NITEMS	O
(	O
server_check_items	array
)	O
;	O
i	int
++	O
)	O
if	O
(	O
server_check_items	array
[	O
i	int
]	O
==	O
attr	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
paircmp	function
(	O
radiusd_request_t	struct
*	O
request	pointer
,	O
grad_avp_t	struct
*	O
check	pointer
,	O
char	O
*	O
pusername	pointer
)	O
{	O
grad_avp_t	struct
*	O
check_item	pointer
=	O
check	pointer
;	O
grad_avp_t	struct
*	O
auth_item	pointer
;	O
char	O
username	pointer
[	O
GRAD_STRING_LENGTH	int
]	O
;	O
int	O
result	pointer
=	O
0	int
;	O
int	O
compare	int
;	O
char	O
*	O
save	pointer
;	O
if	O
(	O
!	O
pusername	pointer
)	O
pusername	pointer
=	O
username	pointer
;	O
while	O
(	O
result	pointer
==	O
0	int
&&	O
check_item	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
server_attr	function
(	O
check_item	pointer
->	O
attribute	int
)	O
)	O
{	O
check_item	pointer
=	O
check_item	pointer
->	O
next	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
20	int
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_DEBUG	int
,	O
"check_item: %s"	pointer
,	O
grad_format_pair	function
(	O
check_item	pointer
,	O
1	int
,	O
&	O
save	pointer
)	O
)	O
;	O
free	function
(	O
save	pointer
)	O
;	O
}	O
for	O
(	O
auth_item	pointer
=	O
request	pointer
->	O
request	pointer
->	O
avlist	pointer
;	O
auth_item	pointer
;	O
auth_item	pointer
=	O
auth_item	pointer
->	O
next	pointer
)	O
{	O
GRAD_DEBUG1	O
(	O
30	int
,	O
"trying %d"	pointer
,	O
auth_item	pointer
->	O
attribute	int
)	O
;	O
switch	O
(	O
check_item	pointer
->	O
attribute	int
)	O
{	O
case	O
DA_PREFIX	int
:	O
case	O
DA_SUFFIX	int
:	O
case	O
DA_GROUP_NAME	int
:	O
case	O
DA_GROUP	int
:	O
if	O
(	O
auth_item	pointer
->	O
attribute	int
!=	O
DA_USER_NAME	int
)	O
continue	O
;	O
case	O
DA_HUNTGROUP_NAME	int
:	O
case	O
DA_USER_UID	int
:	O
break	O
;	O
case	O
DA_HINT	int
:	O
if	O
(	O
auth_item	pointer
->	O
attribute	int
!=	O
check_item	pointer
->	O
attribute	int
)	O
continue	O
;	O
if	O
(	O
strcmp	function
(	O
check_item	pointer
->	O
avp_strvalue	O
,	O
auth_item	pointer
->	O
avp_strvalue	O
)	O
!=	O
0	int
)	O
continue	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
auth_item	pointer
->	O
attribute	int
!=	O
check_item	pointer
->	O
attribute	int
)	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
auth_item	pointer
==	O
NULL	O
)	O
{	O
result	pointer
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
GRAD_DEBUG_LEVEL	O
(	O
20	int
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_DEBUG	int
,	O
"auth_item: %s"	pointer
,	O
grad_format_pair	function
(	O
auth_item	pointer
,	O
1	int
,	O
&	O
save	pointer
)	O
)	O
;	O
free	function
(	O
save	pointer
)	O
;	O
}	O
compare	int
=	O
0	int
;	O
switch	O
(	O
check_item	pointer
->	O
type	enum
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
switch	O
(	O
check_item	pointer
->	O
attribute	int
)	O
{	O
case	O
DA_PREFIX	int
:	O
case	O
DA_SUFFIX	int
:	O
strcpy	function
(	O
pusername	pointer
,	O
auth_item	pointer
->	O
avp_strvalue	O
)	O
;	O
compare	int
=	O
presufcmp	function
(	O
check_item	pointer
,	O
auth_item	pointer
->	O
avp_strvalue	O
,	O
pusername	pointer
)	O
;	O
break	O
;	O
case	O
DA_NAS_PORT_ID	int
:	O
compare	int
=	O
portcmp	function
(	O
check_item	pointer
,	O
auth_item	pointer
)	O
;	O
break	O
;	O
case	O
DA_GROUP_NAME	int
:	O
case	O
DA_GROUP	int
:	O
strcpy	function
(	O
username	pointer
,	O
auth_item	pointer
->	O
avp_strvalue	O
)	O
;	O
compare	int
=	O
groupcmp	function
(	O
request	pointer
,	O
check_item	pointer
->	O
avp_strvalue	O
,	O
username	pointer
)	O
;	O
break	O
;	O
case	O
DA_HUNTGROUP_NAME	int
:	O
compare	int
=	O
!	O
huntgroup_match	function
(	O
request	pointer
,	O
check_item	pointer
->	O
avp_strvalue	O
)	O
;	O
break	O
;	O
default	O
:	O
compare	int
=	O
strcmp	function
(	O
auth_item	pointer
->	O
avp_strvalue	O
,	O
check_item	pointer
->	O
avp_strvalue	O
)	O
;	O
}	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
switch	O
(	O
check_item	pointer
->	O
attribute	int
)	O
{	O
case	O
DA_USER_UID	int
:	O
compare	int
=	O
uidcmp	function
(	O
check_item	pointer
,	O
username	pointer
)	O
;	O
break	O
;	O
}	O
case	O
GRAD_TYPE_IPADDR	int
:	O
compare	int
=	O
auth_item	pointer
->	O
avp_lvalue	O
-	O
check_item	pointer
->	O
avp_lvalue	O
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
break	O
;	O
}	O
GRAD_DEBUG1	O
(	O
20	int
,	O
"compare: %d"	pointer
,	O
compare	int
)	O
;	O
result	pointer
=	O
comp_op	function
(	O
check_item	pointer
->	O
operator	enum
,	O
compare	int
)	O
;	O
if	O
(	O
result	pointer
==	O
0	int
)	O
check_item	pointer
=	O
check_item	pointer
->	O
next	pointer
;	O
}	O
GRAD_DEBUG1	O
(	O
20	int
,	O
"returning %d"	pointer
,	O
result	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
static	O
int	O
matching_rule_free	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
ARG_UNUSED	O
)	O
{	O
grad_matching_rule_t	struct
*	O
p	pointer
=	O
item	pointer
;	O
if	O
(	O
p	pointer
->	O
name	pointer
)	O
grad_free	function
(	O
p	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
lhs	pointer
)	O
grad_avl_free	function
(	O
p	pointer
->	O
lhs	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
rhs	pointer
)	O
grad_avl_free	function
(	O
p	pointer
->	O
rhs	pointer
)	O
;	O
grad_free	function
(	O
p	pointer
)	O
;	O
}	O
struct	O
wild_match_range	struct
{	O
char	O
*	O
start	pointer
;	O
char	O
*	O
end	pointer
;	O
}	O
;	O
int	O
match_char_class	function
(	O
char	O
*	O
*	O
pexpr	pointer
,	O
char	O
c	pointer
)	O
{	O
int	O
res	int
;	O
int	O
rc	int
;	O
char	O
*	O
expr	pointer
=	O
*	O
pexpr	pointer
;	O
expr	pointer
++	O
;	O
if	O
(	O
*	O
expr	pointer
==	O
'^'	O
)	O
{	O
res	int
=	O
0	int
;	O
expr	pointer
++	O
;	O
}	O
else	O
res	int
=	O
1	int
;	O
if	O
(	O
*	O
expr	pointer
==	O
'-'	O
||	O
*	O
expr	pointer
==	O
']'	O
)	O
rc	int
=	O
c	pointer
==	O
*	O
expr	pointer
++	O
;	O
else	O
rc	int
=	O
!	O
res	int
;	O
for	O
(	O
;	O
*	O
expr	pointer
&&	O
*	O
expr	pointer
!=	O
']'	O
;	O
expr	pointer
++	O
)	O
{	O
if	O
(	O
rc	int
==	O
res	int
)	O
{	O
if	O
(	O
*	O
expr	pointer
==	O
'\\'	O
&&	O
expr	pointer
[	O
1	int
]	O
==	O
']'	O
)	O
expr	pointer
++	O
;	O
}	O
else	O
if	O
(	O
expr	pointer
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
*	O
expr	pointer
==	O
'\\'	O
)	O
rc	int
=	O
*	O
++	O
expr	pointer
==	O
c	pointer
;	O
else	O
{	O
rc	int
=	O
*	O
expr	pointer
<=	O
c	pointer
&&	O
c	pointer
<=	O
expr	pointer
[	O
2	int
]	O
;	O
expr	pointer
+=	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
expr	pointer
==	O
'\\'	O
&&	O
expr	pointer
[	O
1	int
]	O
==	O
']'	O
)	O
rc	int
==	O
*	O
++	O
expr	pointer
==	O
c	pointer
;	O
else	O
rc	int
=	O
*	O
expr	pointer
==	O
c	pointer
;	O
}	O
*	O
pexpr	pointer
=	O
*	O
expr	pointer
?	O
expr	pointer
+	O
1	int
:	O
expr	pointer
;	O
return	O
rc	int
==	O
res	int
;	O
}	O
int	O
_wild_match	function
(	O
char	O
*	O
expr	pointer
,	O
char	O
*	O
name	pointer
,	O
struct	O
wild_match_range	struct
*	O
r	pointer
)	O
{	O
int	O
c	pointer
;	O
while	O
(	O
expr	pointer
&&	O
*	O
expr	pointer
)	O
{	O
if	O
(	O
*	O
name	pointer
==	O
0	int
&&	O
*	O
expr	pointer
!=	O
'*'	O
)	O
return	O
WILD_ABORT	int
;	O
switch	O
(	O
*	O
expr	pointer
)	O
{	O
case	O
'*'	O
:	O
while	O
(	O
*	O
++	O
expr	pointer
==	O
'*'	O
)	O
;	O
if	O
(	O
*	O
expr	pointer
==	O
0	int
)	O
return	O
WILD_TRUE	int
;	O
while	O
(	O
*	O
name	pointer
)	O
{	O
int	O
res	int
=	O
_wild_match	function
(	O
expr	pointer
,	O
name	pointer
++	O
,	O
r	pointer
)	O
;	O
if	O
(	O
res	int
!=	O
WILD_FALSE	int
)	O
return	O
res	int
;	O
}	O
return	O
WILD_ABORT	int
;	O
case	O
'?'	O
:	O
expr	pointer
++	O
;	O
if	O
(	O
*	O
name	pointer
==	O
0	int
)	O
return	O
WILD_FALSE	int
;	O
name	pointer
++	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
expr	pointer
[	O
1	int
]	O
==	O
0	int
)	O
goto	O
def	int
;	O
c	pointer
=	O
*	O
++	O
expr	pointer
;	O
expr	pointer
++	O
;	O
if	O
(	O
c	pointer
==	O
'('	O
)	O
{	O
if	O
(	O
r	pointer
)	O
r	pointer
->	O
start	pointer
=	O
name	pointer
;	O
}	O
else	O
if	O
(	O
c	pointer
==	O
')'	O
)	O
{	O
if	O
(	O
r	pointer
)	O
r	pointer
->	O
end	pointer
=	O
name	pointer
;	O
}	O
else	O
{	O
if	O
(	O
*	O
name	pointer
!=	O
c	pointer
)	O
return	O
WILD_FALSE	int
;	O
name	pointer
++	O
;	O
}	O
break	O
;	O
case	O
'['	O
:	O
if	O
(	O
!	O
match_char_class	function
(	O
&	O
expr	pointer
,	O
*	O
name	pointer
)	O
)	O
return	O
WILD_FALSE	int
;	O
name	pointer
++	O
;	O
break	O
;	O
default	O
:	O
def	int
:	O
if	O
(	O
*	O
expr	pointer
!=	O
*	O
name	pointer
)	O
return	O
WILD_FALSE	int
;	O
expr	pointer
++	O
;	O
name	pointer
++	O
;	O
}	O
}	O
return	O
*	O
name	pointer
==	O
0	int
;	O
}	O
int	O
wild_match	function
(	O
char	O
*	O
expr	pointer
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
return_name	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
wild_match_range	struct
range	struct
;	O
range	struct
.	O
start	pointer
=	O
range	struct
.	O
end	pointer
=	O
NULL	O
;	O
rc	int
=	O
_wild_match	function
(	O
expr	pointer
,	O
name	pointer
,	O
&	O
range	struct
)	O
==	O
WILD_TRUE	int
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
range	struct
.	O
start	pointer
&&	O
range	struct
.	O
end	pointer
)	O
{	O
int	O
len	int
=	O
range	struct
.	O
end	pointer
-	O
range	struct
.	O
start	pointer
;	O
strncpy	function
(	O
return_name	pointer
,	O
range	struct
.	O
start	pointer
,	O
len	int
)	O
;	O
}	O
else	O
strncpy	function
(	O
return_name	pointer
,	O
name	pointer
,	O
GRAD_STRING_LENGTH	int
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
matches	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
char	O
*	O
name	pointer
,	O
grad_matching_rule_t	struct
*	O
pl	pointer
,	O
char	O
*	O
matchpart	pointer
)	O
{	O
memcpy	function
(	O
matchpart	pointer
,	O
name	pointer
,	O
GRAD_STRING_LENGTH	int
)	O
;	O
if	O
(	O
strncmp	function
(	O
pl	pointer
->	O
name	pointer
,	O
"DEFAULT"	pointer
,	O
7	int
)	O
==	O
0	int
||	O
wild_match	function
(	O
pl	pointer
->	O
name	pointer
,	O
name	pointer
,	O
matchpart	pointer
)	O
)	O
return	O
paircmp	function
(	O
req	pointer
,	O
pl	pointer
->	O
lhs	pointer
,	O
matchpart	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
reload_data	function
(	O
enum	O
reload_what	enum
what	enum
,	O
int	O
*	O
do_radck	pointer
)	O
;	O
static	O
int	O
realm_set_secret	function
(	O
grad_server_t	struct
*	O
srv	pointer
)	O
{	O
CLIENT	struct
*	O
client	struct
;	O
if	O
(	O
(	O
client	struct
=	O
client_lookup_ip	function
(	O
srv	pointer
->	O
addr	int
)	O
)	O
==	O
NULL	O
)	O
return	O
1	int
;	O
srv	pointer
->	O
secret	pointer
=	O
client	struct
->	O
secret	pointer
;	O
return	O
0	int
;	O
}	O
int	O
reload_data	function
(	O
enum	O
reload_what	enum
what	enum
,	O
int	O
*	O
do_radck	pointer
)	O
{	O
char	O
*	O
path	pointer
;	O
int	O
rc	int
=	O
0	int
;	O
switch	O
(	O
what	enum
)	O
{	O
case	O
reload_all	int
:	O
rc	int
+=	O
reload_data	function
(	O
reload_sql	int
,	O
do_radck	pointer
)	O
;	O
rc	int
+=	O
reload_data	function
(	O
reload_clients	int
,	O
do_radck	pointer
)	O
;	O
rc	int
+=	O
reload_data	function
(	O
reload_naslist	int
,	O
do_radck	pointer
)	O
;	O
rc	int
+=	O
reload_data	function
(	O
reload_realms	int
,	O
do_radck	pointer
)	O
;	O
rc	int
+=	O
reload_data	function
(	O
reload_deny	int
,	O
do_radck	pointer
)	O
;	O
break	O
;	O
case	O
reload_users	int
:	O
grad_symtab_clear	function
(	O
user_tab	pointer
)	O
;	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_USERS	pointer
)	O
;	O
if	O
(	O
read_users	function
(	O
path	pointer
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"can't load %s: exited"	pointer
)	O
,	O
path	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"%s reloaded."	pointer
)	O
,	O
path	pointer
)	O
;	O
*	O
do_radck	pointer
=	O
1	int
;	O
grad_free	function
(	O
path	pointer
)	O
;	O
break	O
;	O
case	O
reload_dict	int
:	O
if	O
(	O
grad_dict_init	function
(	O
)	O
)	O
rc	int
=	O
1	int
;	O
rc	int
+=	O
reload_data	function
(	O
reload_rewrite	int
,	O
do_radck	pointer
)	O
;	O
break	O
;	O
case	O
reload_huntgroups	int
:	O
grad_list_destroy	function
(	O
&	O
huntgroups	pointer
,	O
matching_rule_free	function
,	O
NULL	O
)	O
;	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_HUNTGROUPS	pointer
)	O
;	O
huntgroups	pointer
=	O
file_read	function
(	O
GRAD_CF_HUNTGROUPS	int
,	O
path	pointer
)	O
;	O
grad_free	function
(	O
path	pointer
)	O
;	O
break	O
;	O
case	O
reload_hints	int
:	O
grad_list_destroy	function
(	O
&	O
hints	pointer
,	O
matching_rule_free	function
,	O
NULL	O
)	O
;	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_HINTS	pointer
)	O
;	O
hints	pointer
=	O
file_read	function
(	O
GRAD_CF_HINTS	int
,	O
path	pointer
)	O
;	O
grad_free	function
(	O
path	pointer
)	O
;	O
if	O
(	O
!	O
use_dbm	int
)	O
*	O
do_radck	pointer
=	O
1	int
;	O
break	O
;	O
case	O
reload_clients	int
:	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_CLIENTS	pointer
)	O
;	O
if	O
(	O
read_clients_file	function
(	O
path	pointer
)	O
<	O
0	int
)	O
rc	int
=	O
1	int
;	O
grad_free	function
(	O
path	pointer
)	O
;	O
break	O
;	O
case	O
reload_naslist	int
:	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_NASTYPES	pointer
)	O
;	O
read_nastypes_file	function
(	O
path	pointer
)	O
;	O
grad_free	function
(	O
path	pointer
)	O
;	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_NASLIST	pointer
)	O
;	O
if	O
(	O
read_naslist_file	function
(	O
path	pointer
)	O
<	O
0	int
)	O
rc	int
=	O
1	int
;	O
grad_free	function
(	O
path	pointer
)	O
;	O
break	O
;	O
case	O
reload_realms	int
:	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
RADIUS_REALMS	pointer
)	O
;	O
if	O
(	O
grad_read_realms	function
(	O
path	pointer
,	O
auth_port	int
,	O
acct_port	int
,	O
realm_set_secret	function
)	O
<	O
0	int
)	O
rc	int
=	O
1	int
;	O
grad_free	function
(	O
path	pointer
)	O
;	O
break	O
;	O
case	O
reload_deny	int
:	O
read_deny_file	function
(	O
)	O
;	O
break	O
;	O
case	O
reload_sql	int
:	O
if	O
(	O
radiusd_sql_config	int
(	O
)	O
!=	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"SQL Error: SQL client could not be initialized"	pointer
)	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
rc	int
+=	O
reload_data	function
(	O
reload_dict	int
,	O
do_radck	pointer
)	O
;	O
break	O
;	O
case	O
reload_rewrite	int
:	O
rewrite_load_all	function
(	O
)	O
;	O
rc	int
+=	O
reload_data	function
(	O
reload_users	int
,	O
do_radck	pointer
)	O
;	O
rc	int
+=	O
reload_data	function
(	O
reload_huntgroups	int
,	O
do_radck	pointer
)	O
;	O
rc	int
+=	O
reload_data	function
(	O
reload_hints	int
,	O
do_radck	pointer
)	O
;	O
break	O
;	O
default	O
:	O
grad_log	function
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"INTERNAL ERROR: unknown reload code: %d"	pointer
)	O
,	O
what	enum
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
reload_config_file	function
(	O
enum	O
reload_what	enum
what	enum
)	O
{	O
int	O
do_radck	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
reload_data	function
(	O
what	enum
,	O
&	O
do_radck	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
do_radck	pointer
)	O
radck	function
(	O
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
dump_matching_rules	function
(	O
FILE	struct
*	O
fp	pointer
,	O
char	O
*	O
header	pointer
,	O
grad_list_t	struct
*	O
list	pointer
)	O
{	O
grad_matching_rule_t	struct
*	O
rule	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
list	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s {\n"	pointer
,	O
header	pointer
)	O
;	O
for	O
(	O
rule	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
rule	pointer
;	O
rule	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"\t%s:\n"	pointer
,	O
rule	pointer
->	O
name	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tlhs {\n"	pointer
)	O
;	O
grad_avl_fprint	function
(	O
fp	pointer
,	O
"\t\t"	pointer
,	O
1	int
,	O
rule	pointer
->	O
lhs	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\t}\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\trhs {\n"	pointer
)	O
;	O
grad_avl_fprint	function
(	O
fp	pointer
,	O
"\t\t"	pointer
,	O
1	int
,	O
rule	pointer
->	O
rhs	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\t}\n"	pointer
)	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"}\n"	pointer
)	O
;	O
}	O
int	O
dump_user	function
(	O
void	O
*	O
data	pointer
,	O
grad_symbol_t	struct
*	O
symbol	struct
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
data	pointer
;	O
User_symbol	struct
*	O
sym	pointer
=	O
(	O
User_symbol	struct
*	O
)	O
symbol	struct
;	O
fprintf	function
(	O
fp	pointer
,	O
"\t%s:\n"	pointer
,	O
sym	pointer
->	O
name	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\tlhs {\n"	pointer
)	O
;	O
grad_avl_fprint	function
(	O
fp	pointer
,	O
"\t\t"	pointer
,	O
1	int
,	O
sym	pointer
->	O
check	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\t}\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\trhs {\n"	pointer
)	O
;	O
grad_avl_fprint	function
(	O
fp	pointer
,	O
"\t\t"	pointer
,	O
1	int
,	O
sym	pointer
->	O
reply	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\t}\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
dump_users_db	function
(	O
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
char	O
*	O
name	pointer
=	O
grad_mkfilename	function
(	O
grad_log_dir	pointer
,	O
RADIUS_DUMPDB_NAME	pointer
)	O
;	O
fp	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't create parser output file `%s'"	pointer
)	O
,	O
RADIUS_DUMPDB_NAME	pointer
)	O
;	O
grad_free	function
(	O
name	pointer
)	O
;	O
return	O
;	O
}	O
fchmod	function
(	O
fileno	function
(	O
fp	pointer
)	O
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s {\n"	pointer
,	O
"users"	pointer
)	O
;	O
grad_symtab_iterate	function
(	O
user_tab	pointer
,	O
dump_user	function
,	O
fp	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"}\n"	pointer
)	O
;	O
dump_matching_rules	function
(	O
fp	pointer
,	O
"huntgroups"	pointer
,	O
huntgroups	pointer
)	O
;	O
dump_matching_rules	function
(	O
fp	pointer
,	O
"hints"	pointer
,	O
hints	pointer
)	O
;	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"dumped users database to %s"	pointer
)	O
,	O
RADIUS_DUMPDB_NAME	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
grad_free	function
(	O
name	pointer
)	O
;	O
}	O
void	O
strip_username	function
(	O
int	O
do_strip	int
,	O
char	O
*	O
name	pointer
,	O
grad_avp_t	struct
*	O
check_item	pointer
,	O
char	O
*	O
stripped_name	pointer
)	O
{	O
char	O
tmpname	array
[	O
GRAD_STRING_LENGTH	int
]	O
;	O
char	O
*	O
source_ptr	pointer
=	O
name	pointer
;	O
grad_avp_t	struct
*	O
presuf_item	pointer
,	O
*	O
tmp	struct
;	O
if	O
(	O
(	O
presuf_item	pointer
=	O
grad_avl_find	function
(	O
check_item	pointer
,	O
DA_PREFIX	int
)	O
)	O
==	O
NULL	O
)	O
presuf_item	pointer
=	O
grad_avl_find	function
(	O
check_item	pointer
,	O
DA_SUFFIX	int
)	O
;	O
if	O
(	O
presuf_item	pointer
)	O
{	O
if	O
(	O
tmp	struct
=	O
grad_avl_find	function
(	O
check_item	pointer
,	O
DA_STRIP_USER_NAME	int
)	O
)	O
do_strip	int
=	O
tmp	struct
->	O
avp_lvalue	O
;	O
if	O
(	O
do_strip	int
)	O
{	O
if	O
(	O
presufcmp	function
(	O
presuf_item	pointer
,	O
name	pointer
,	O
tmpname	array
)	O
==	O
0	int
)	O
source_ptr	pointer
=	O
tmpname	array
;	O
}	O
}	O
strcpy	function
(	O
stripped_name	pointer
,	O
source_ptr	pointer
)	O
;	O
}	O
