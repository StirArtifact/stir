static	O
char	O
vszDefOutFilename	array
[	O
]	O
=	O
"sim.out"	pointer
;	O
static	O
char	O
vszDefMCOutFilename	array
[	O
]	O
=	O
"simmc.out"	pointer
;	O
void	O
SaveOutputs	function
(	O
PEXPERIMENT	pointer
pexp	pointer
,	O
PDOUBLE	pointer
pdTout	pointer
)	O
{	O
static	O
PDOUBLE	pointer
rgdInterpStates	pointer
,	O
rgdInterpDeriv	pointer
;	O
int	O
i	int
,	O
j	int
,	O
index	function
;	O
PMODELINFO	pointer
pmod	pointer
=	O
pexp	pointer
->	O
pmodelinfo	pointer
;	O
POUTSPEC	pointer
pos	pointer
=	O
&	O
pexp	pointer
->	O
os	struct
;	O
extern	O
IFN	struct
vrgInputs	array
[	O
]	O
;	O
if	O
(	O
!	O
(	O
rgdInterpStates	pointer
)	O
||	O
!	O
(	O
rgdInterpDeriv	pointer
)	O
)	O
if	O
(	O
!	O
(	O
rgdInterpStates	pointer
=	O
InitdVector	function
(	O
GetNModelVars	function
(	O
)	O
)	O
)	O
||	O
!	O
(	O
rgdInterpDeriv	pointer
=	O
InitdVector	function
(	O
GetNModelVars	function
(	O
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"SaveOutputs"	pointer
,	O
NULL	O
)	O
;	O
memcpy	function
(	O
rgdInterpStates	pointer
,	O
pmod	pointer
->	O
pdModelVars	pointer
,	O
pmod	pointer
->	O
nModelVars	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
CalcDeriv	function
(	O
rgdInterpStates	pointer
,	O
rgdInterpDeriv	pointer
,	O
pdTout	pointer
)	O
;	O
CalcOutputs	function
(	O
rgdInterpStates	pointer
,	O
rgdInterpDeriv	pointer
,	O
pdTout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pos	pointer
->	O
nOutputs	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pos	pointer
->	O
piCurrentOut	pointer
[	O
i	int
]	O
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
i	int
]	O
&&	O
*	O
pdTout	pointer
==	O
pos	pointer
->	O
prgdOutputTimes	pointer
[	O
i	int
]	O
[	O
pos	pointer
->	O
piCurrentOut	pointer
[	O
i	int
]	O
]	O
)	O
{	O
double	O
dTmp	double
=	O
0	int
;	O
if	O
(	O
IsModelVar	function
(	O
pos	pointer
->	O
phvar_out	pointer
[	O
i	int
]	O
)	O
)	O
dTmp	double
=	O
rgdInterpStates	pointer
[	O
ModelIndex	function
(	O
pos	pointer
->	O
phvar_out	pointer
[	O
i	int
]	O
)	O
]	O
;	O
else	O
{	O
index	function
=	O
HINDEX	O
(	O
pos	pointer
->	O
phvar_out	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
IsInput	function
(	O
pos	pointer
->	O
phvar_out	pointer
[	O
i	int
]	O
)	O
&&	O
(	O
vrgInputs	array
[	O
index	function
]	O
.	O
iType	int
==	O
IFN_SPIKES	int
)	O
)	O
{	O
j	int
=	O
vrgInputs	array
[	O
index	function
]	O
.	O
iDoseCur	int
;	O
if	O
(	O
(	O
vrgInputs	array
[	O
index	function
]	O
.	O
rgT0s	pointer
[	O
j	int
]	O
==	O
pexp	pointer
->	O
dTime	double
)	O
&&	O
(	O
j	int
<	O
vrgInputs	array
[	O
index	function
]	O
.	O
nDoses	int
)	O
)	O
dTmp	double
=	O
vrgInputs	array
[	O
index	function
]	O
.	O
rgMags	pointer
[	O
j	int
]	O
;	O
else	O
dTmp	double
=	O
0	int
;	O
}	O
else	O
dTmp	double
=	O
GetVarValue	function
(	O
pos	pointer
->	O
phvar_out	pointer
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
fabs	function
(	O
dTmp	double
)	O
<	O
SO_EPSILON	O
)	O
dTmp	double
=	O
0.0	int
;	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
i	int
]	O
[	O
pos	pointer
->	O
piCurrentOut	pointer
[	O
i	int
]	O
++	O
]	O
=	O
dTmp	double
;	O
}	O
}	O
}	O
void	O
NextOutputTime	function
(	O
PEXPERIMENT	pointer
pexp	pointer
,	O
PDOUBLE	pointer
pdTout	pointer
,	O
PINT	pointer
piOut	pointer
)	O
{	O
if	O
(	O
pexp	pointer
->	O
dTime	double
<	O
pexp	pointer
->	O
dTfinal	double
)	O
{	O
if	O
(	O
++	O
*	O
piOut	pointer
<	O
pexp	pointer
->	O
os	struct
.	O
cDistinctTimes	int
)	O
{	O
*	O
pdTout	pointer
=	O
pexp	pointer
->	O
os	struct
.	O
rgdDistinctTimes	pointer
[	O
*	O
piOut	pointer
]	O
;	O
}	O
else	O
{	O
*	O
pdTout	pointer
=	O
pexp	pointer
->	O
dTfinal	double
;	O
}	O
}	O
}	O
int	O
WriteOneMod	function
(	O
PVOID	pointer
pData	pointer
,	O
PVOID	pointer
pInfo	pointer
)	O
{	O
PMCVAR	pointer
pmcvar	pointer
=	O
(	O
PMCVAR	pointer
)	O
pData	pointer
;	O
PFILE	pointer
pfile	pointer
=	O
(	O
PFILE	pointer
)	O
pInfo	pointer
;	O
if	O
(	O
!	O
IsInput	function
(	O
pmcvar	pointer
->	O
hvar	long
)	O
)	O
fprintf	function
(	O
pfile	pointer
,	O
"%g\t"	pointer
,	O
pmcvar	pointer
->	O
dVal	double
)	O
;	O
return	O
0	int
;	O
}	O
void	O
WriteMCHeader	function
(	O
PFILE	pointer
pfileOut	pointer
,	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
long	O
i	int
,	O
j	int
,	O
k	long
;	O
PMONTECARLO	pointer
pmc	pointer
=	O
&	O
panal	pointer
->	O
mc	struct
;	O
OUTSPEC	struct
*	O
pos	pointer
;	O
fprintf	function
(	O
pfileOut	pointer
,	O
"Iter"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pmc	pointer
->	O
nParms	long
;	O
i	int
++	O
)	O
fprintf	function
(	O
pfileOut	pointer
,	O
"\t%s"	pointer
,	O
GetVarName	function
(	O
pmc	pointer
->	O
rgpMCVar	pointer
[	O
i	int
]	O
->	O
hvar	long
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
i	int
++	O
)	O
{	O
pos	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	int
]	O
->	O
os	struct
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	int
++	O
)	O
{	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	int
]	O
;	O
k	long
++	O
)	O
fprintf	function
(	O
pfileOut	pointer
,	O
"\t%s_%ld.%ld"	pointer
,	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
j	int
]	O
,	O
i	int
+	O
1	int
,	O
k	long
+	O
1	int
)	O
;	O
}	O
}	O
fprintf	function
(	O
pfileOut	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
pfileOut	pointer
)	O
;	O
}	O
void	O
OpenMCFiles	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
PMONTECARLO	pointer
pmc	pointer
=	O
&	O
panal	pointer
->	O
mc	struct
;	O
if	O
(	O
panal	pointer
->	O
bCommandLineSpec	int
)	O
{	O
free	function
(	O
pmc	pointer
->	O
szMCOutfilename	pointer
)	O
;	O
panal	pointer
->	O
bAllocatedFileName	int
=	O
FALSE	int
;	O
pmc	pointer
->	O
szMCOutfilename	pointer
=	O
panal	pointer
->	O
szOutfilename	pointer
;	O
}	O
else	O
if	O
(	O
!	O
(	O
pmc	pointer
->	O
szMCOutfilename	pointer
)	O
)	O
pmc	pointer
->	O
szMCOutfilename	pointer
=	O
vszDefMCOutFilename	array
;	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
{	O
char	O
*	O
with_rank	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
6	int
+	O
strlen	function
(	O
pmc	pointer
->	O
szMCOutfilename	pointer
)	O
)	O
)	O
;	O
sprintf	function
(	O
with_rank	pointer
,	O
"%04d_%s"	pointer
,	O
panal	pointer
->	O
rank	int
,	O
pmc	pointer
->	O
szMCOutfilename	pointer
)	O
;	O
pmc	pointer
->	O
szMCOutfilename	pointer
=	O
with_rank	pointer
;	O
}	O
if	O
(	O
!	O
pmc	pointer
->	O
pfileMCOut	pointer
&&	O
!	O
(	O
pmc	pointer
->	O
pfileMCOut	pointer
=	O
fopen	function
(	O
pmc	pointer
->	O
szMCOutfilename	pointer
,	O
"w"	pointer
)	O
)	O
)	O
{	O
ReportError	function
(	O
NULL	O
,	O
RE_FATAL	int
|	O
RE_CANNOTOPEN	int
,	O
pmc	pointer
->	O
szMCOutfilename	pointer
,	O
"OpenMCFiles()"	pointer
)	O
;	O
}	O
WriteMCHeader	function
(	O
pmc	pointer
->	O
pfileMCOut	pointer
,	O
panal	pointer
)	O
;	O
}	O
void	O
CloseMCFiles	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
fclose	function
(	O
panal	pointer
->	O
mc	struct
.	O
pfileMCOut	pointer
)	O
;	O
printf	function
(	O
"\nWrote results to \"%s\"\n"	pointer
,	O
panal	pointer
->	O
mc	struct
.	O
szMCOutfilename	pointer
)	O
;	O
}	O
void	O
WriteMCOutput	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PMCPREDOUT	pointer
pmcpredout	pointer
)	O
{	O
PFILE	pointer
pfileMC	pointer
;	O
PMONTECARLO	pointer
pmc	pointer
=	O
&	O
panal	pointer
->	O
mc	struct
;	O
pfileMC	pointer
=	O
pmc	pointer
->	O
pfileMCOut	pointer
;	O
fprintf	function
(	O
pfileMC	pointer
,	O
"%ld\t"	pointer
,	O
panal	pointer
->	O
mc	struct
.	O
lRun	long
)	O
;	O
WriteArray	function
(	O
pfileMC	pointer
,	O
panal	pointer
->	O
mc	struct
.	O
nParms	long
,	O
panal	pointer
->	O
mc	struct
.	O
rgdParms	pointer
)	O
;	O
fprintf	function
(	O
pfileMC	pointer
,	O
"\t"	pointer
)	O
;	O
WriteArray	function
(	O
pfileMC	pointer
,	O
pmcpredout	pointer
->	O
nbrdy	long
,	O
pmcpredout	pointer
->	O
pred	pointer
)	O
;	O
fprintf	function
(	O
pfileMC	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
pfileMC	pointer
)	O
;	O
}	O
void	O
WriteNormalOutput	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
PEXPERIMENT	pointer
pexp	pointer
)	O
{	O
long	O
i	int
,	O
j	int
;	O
PFILE	pointer
pfile	pointer
;	O
POUTSPEC	pointer
pos	pointer
;	O
if	O
(	O
!	O
panal	pointer
)	O
return	O
;	O
pos	pointer
=	O
&	O
pexp	pointer
->	O
os	struct
;	O
if	O
(	O
!	O
panal	pointer
->	O
szOutfilename	pointer
)	O
panal	pointer
->	O
szOutfilename	pointer
=	O
vszDefOutFilename	array
;	O
if	O
(	O
panal	pointer
->	O
size	int
>	O
1	int
)	O
{	O
char	O
*	O
with_rank	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
5	int
+	O
strlen	function
(	O
panal	pointer
->	O
szOutfilename	pointer
)	O
)	O
)	O
;	O
sprintf	function
(	O
with_rank	pointer
,	O
"%4d%s"	pointer
,	O
panal	pointer
->	O
rank	int
,	O
panal	pointer
->	O
szOutfilename	pointer
)	O
;	O
panal	pointer
->	O
szOutfilename	pointer
=	O
with_rank	pointer
;	O
}	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
pfileOut	pointer
)	O
)	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
pfileOut	pointer
=	O
fopen	function
(	O
panal	pointer
->	O
szOutfilename	pointer
,	O
"w"	pointer
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_CANNOTOPEN	int
|	O
RE_FATAL	int
,	O
panal	pointer
->	O
szOutfilename	pointer
,	O
NULL	O
)	O
;	O
pfile	pointer
=	O
panal	pointer
->	O
pfileOut	pointer
;	O
fprintf	function
(	O
pfile	pointer
,	O
"Results of Simulation %d\n\n"	pointer
,	O
pexp	pointer
->	O
iExp	int
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"Time"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pos	pointer
->	O
nOutputs	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\t%s"	pointer
,	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
i	int
]	O
)	O
;	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	int
++	O
)	O
pos	pointer
->	O
piCurrentOut	pointer
[	O
j	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pos	pointer
->	O
cDistinctTimes	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"%g"	pointer
,	O
pos	pointer
->	O
rgdDistinctTimes	pointer
[	O
i	int
]	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
pos	pointer
->	O
piCurrentOut	pointer
[	O
j	int
]	O
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	int
]	O
&&	O
pos	pointer
->	O
rgdDistinctTimes	pointer
[	O
i	int
]	O
==	O
pos	pointer
->	O
prgdOutputTimes	pointer
[	O
j	int
]	O
[	O
pos	pointer
->	O
piCurrentOut	pointer
[	O
j	int
]	O
]	O
)	O
fprintf	function
(	O
pfile	pointer
,	O
"\t%g"	pointer
,	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
j	int
]	O
[	O
pos	pointer
->	O
piCurrentOut	pointer
[	O
j	int
]	O
++	O
]	O
)	O
;	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"\t"	pointer
)	O
;	O
}	O
fprintf	function
(	O
pfile	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
pfile	pointer
,	O
"\n\n"	pointer
)	O
;	O
}	O
