enum	O
{	O
Shannon	int
,	O
Var_Reduction	int
}	O
;	O
void	O
InitOptArrays	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
int	O
*	O
*	O
piDesign_mask	pointer
,	O
long	O
*	O
pnDesignPts	pointer
,	O
double	O
*	O
*	O
*	O
pdY	pointer
,	O
long	O
*	O
pnPreds	pointer
,	O
long	O
*	O
pnStartDecisionPts	pointer
,	O
double	O
*	O
*	O
pdVariance	pointer
,	O
double	O
*	O
*	O
pdIR	pointer
,	O
long	O
nSims	long
)	O
{	O
BOOL	int
bFound	int
;	O
int	O
i	long
,	O
j	long
,	O
k	int
;	O
OUTSPEC	struct
*	O
pos	pointer
;	O
*	O
pnPreds	pointer
=	O
*	O
pnDesignPts	pointer
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
i	long
++	O
)	O
{	O
pos	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
os	struct
;	O
bFound	int
=	O
FALSE	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	long
]	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
pos	pointer
->	O
prgdDataVals	pointer
)	O
{	O
(	O
*	O
pnDesignPts	pointer
)	O
++	O
;	O
bFound	int
=	O
TRUE	int
;	O
}	O
(	O
*	O
pnPreds	pointer
)	O
++	O
;	O
}	O
}	O
if	O
(	O
bFound	int
)	O
*	O
pnStartDecisionPts	pointer
=	O
*	O
pnPreds	pointer
;	O
}	O
if	O
(	O
*	O
pnDesignPts	pointer
==	O
0	int
)	O
{	O
printf	function
(	O
"Error: you must provide Data Statements "	pointer
)	O
;	O
printf	function
(	O
"for at least one Simulation to define design points - Exiting.\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
*	O
pnPreds	pointer
==	O
*	O
pnDesignPts	pointer
)	O
{	O
printf	function
(	O
"Error: you must provide at least one Simulation "	pointer
)	O
;	O
printf	function
(	O
"without Data Statements for utility computations - Exiting.\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
!	O
(	O
*	O
piDesign_mask	pointer
=	O
InitiVector	function
(	O
*	O
pnDesignPts	pointer
)	O
)	O
)	O
||	O
(	O
!	O
(	O
*	O
pdVariance	pointer
=	O
InitdVector	function
(	O
*	O
pnDesignPts	pointer
)	O
)	O
)	O
||	O
(	O
!	O
(	O
*	O
pdIR	pointer
=	O
InitdVector	function
(	O
nSims	long
)	O
)	O
)	O
||	O
(	O
!	O
(	O
*	O
pdY	pointer
=	O
InitdMatrix	function
(	O
nSims	long
,	O
*	O
pnPreds	pointer
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"InitOptArrays"	pointer
,	O
NULL	O
)	O
;	O
}	O
void	O
OpenOptFiles	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
if	O
(	O
panal	pointer
->	O
bCommandLineSpec	int
)	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
=	O
panal	pointer
->	O
szOutfilename	pointer
;	O
else	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
)	O
)	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
=	O
"simopt.default.out"	pointer
;	O
if	O
(	O
!	O
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
)	O
&&	O
!	O
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
=	O
fopen	function
(	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
,	O
"w"	pointer
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_FATAL	int
|	O
RE_CANNOTOPEN	int
,	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
,	O
"[in OpenOptFiles()]"	pointer
)	O
;	O
}	O
void	O
WriteOutHeader	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
int	O
criterion	int
)	O
{	O
int	O
i	long
,	O
j	long
,	O
k	int
;	O
OUTSPEC	struct
*	O
pos	pointer
;	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"iter\t"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
i	long
++	O
)	O
{	O
pos	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
os	struct
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	long
]	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
pos	pointer
->	O
prgdDataVals	pointer
)	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"T%g\t"	pointer
,	O
pos	pointer
->	O
prgdOutputTimes	pointer
[	O
j	long
]	O
[	O
k	int
]	O
)	O
;	O
}	O
}	O
}	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"Chosen\t"	pointer
)	O
;	O
if	O
(	O
criterion	int
==	O
Var_Reduction	int
)	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"Variance\tSD\tUtility\n"	pointer
)	O
;	O
fflush	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
)	O
;	O
}	O
void	O
SetupLikes	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
long	O
nPreds	long
,	O
PMCVAR	pointer
*	O
*	O
pLikes	pointer
)	O
{	O
BOOL	int
bFound	int
,	O
bLikeFound	int
;	O
long	O
i	long
,	O
j	long
,	O
k	int
,	O
m	long
,	O
n	int
;	O
long	O
nPts	long
=	O
0	int
;	O
OUTSPEC	struct
*	O
pos	pointer
;	O
PMCVAR	pointer
pMCVar	pointer
;	O
PMONTECARLO	pointer
pMC	pointer
=	O
&	O
panal	pointer
->	O
mc	struct
;	O
if	O
(	O
!	O
(	O
*	O
pLikes	pointer
=	O
(	O
PMCVAR	pointer
*	O
)	O
malloc	function
(	O
nPreds	long
*	O
sizeof	O
(	O
PMCVAR	pointer
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"SetupLikes"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
i	long
++	O
)	O
{	O
pos	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
os	struct
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	long
]	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
(	O
*	O
pLikes	pointer
)	O
[	O
nPts	long
]	O
=	O
(	O
PMCVAR	pointer
)	O
malloc	function
(	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"SetupLikes"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
pos	pointer
->	O
prgdDataVals	pointer
)	O
{	O
bLikeFound	int
=	O
FALSE	int
;	O
m	long
=	O
pMC	pointer
->	O
nSetParms	long
;	O
while	O
(	O
!	O
bLikeFound	int
)	O
{	O
bLikeFound	int
=	O
(	O
pMC	pointer
->	O
rgpMCVar	pointer
[	O
m	long
]	O
->	O
hvar	long
==	O
pos	pointer
->	O
phvar_out	pointer
[	O
j	long
]	O
)	O
;	O
if	O
(	O
!	O
bLikeFound	int
)	O
m	long
++	O
;	O
}	O
if	O
(	O
bLikeFound	int
)	O
{	O
pMCVar	pointer
=	O
pMC	pointer
->	O
rgpMCVar	pointer
[	O
m	long
]	O
;	O
SetParents	function
(	O
pMC	pointer
,	O
0	int
)	O
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
4	int
;	O
m	long
++	O
)	O
{	O
if	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
m	long
]	O
==	O
MCVP_PRED	int
)	O
{	O
bFound	int
=	O
FALSE	int
;	O
n	int
=	O
0	int
;	O
while	O
(	O
(	O
n	int
<	O
pos	pointer
->	O
nOutputs	int
)	O
&&	O
(	O
!	O
bFound	int
)	O
)	O
{	O
bFound	int
=	O
(	O
pMCVar	pointer
->	O
hParm	array
[	O
m	long
]	O
==	O
pos	pointer
->	O
phvar_out	pointer
[	O
n	int
]	O
)	O
;	O
if	O
(	O
!	O
bFound	int
)	O
n	int
++	O
;	O
}	O
if	O
(	O
bFound	int
)	O
{	O
pMCVar	pointer
->	O
pdParm	array
[	O
m	long
]	O
=	O
&	O
(	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
n	int
]	O
[	O
k	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Error: missing Print statement for parameter "	pointer
"number %ld of %s distribution - Exiting.\n\n"	pointer
,	O
j	long
,	O
pMCVar	pointer
->	O
pszName	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
pMCVar	pointer
->	O
iParmType	array
[	O
m	long
]	O
==	O
MCVP_DATA	int
)	O
{	O
bFound	int
=	O
FALSE	int
;	O
n	int
=	O
0	int
;	O
while	O
(	O
(	O
n	int
<	O
pos	pointer
->	O
nData	int
)	O
&&	O
(	O
!	O
bFound	int
)	O
)	O
{	O
bFound	int
=	O
(	O
pMCVar	pointer
->	O
hParm	array
[	O
m	long
]	O
==	O
pos	pointer
->	O
phvar_dat	pointer
[	O
n	int
]	O
)	O
;	O
if	O
(	O
!	O
bFound	int
)	O
n	int
++	O
;	O
}	O
if	O
(	O
bFound	int
)	O
{	O
pMCVar	pointer
->	O
pdParm	array
[	O
m	long
]	O
=	O
&	O
(	O
pos	pointer
->	O
prgdDataVals	pointer
[	O
n	int
]	O
[	O
k	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Error: no Data for %s in Simulation %ld "	pointer
"- Exiting.\n\n"	pointer
,	O
pMCVar	pointer
->	O
pszName	pointer
,	O
i	long
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
printf	function
(	O
"Error: missing Likelihood for %s - Exiting.\n\n"	pointer
,	O
pos	pointer
->	O
pszOutputNames	pointer
[	O
j	long
]	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
memcpy	function
(	O
(	O
*	O
pLikes	pointer
)	O
[	O
nPts	long
]	O
,	O
pMCVar	pointer
,	O
sizeof	O
(	O
MCVAR	struct
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
pLikes	pointer
)	O
[	O
nPts	long
]	O
=	O
NULL	O
;	O
}	O
nPts	long
=	O
nPts	long
+	O
1	int
;	O
}	O
}	O
}	O
}	O
int	O
Estimate_y	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
double	O
*	O
pdTheta	pointer
,	O
double	O
*	O
pdY	pointer
)	O
{	O
int	O
cNPred	int
=	O
0	int
;	O
int	O
i	long
,	O
j	long
,	O
k	int
;	O
OUTSPEC	struct
*	O
pos	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
;	O
i	long
++	O
)	O
{	O
InitModel	function
(	O
)	O
;	O
ModifyParms	function
(	O
panal	pointer
->	O
expGlobal	struct
.	O
plistParmMods	pointer
)	O
;	O
SetParms	function
(	O
panal	pointer
->	O
mc	struct
.	O
nSetParms	long
,	O
panal	pointer
->	O
mc	struct
.	O
rghvar	pointer
,	O
pdTheta	pointer
)	O
;	O
ModifyParms	function
(	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
plistParmMods	pointer
)	O
;	O
if	O
(	O
!	O
DoOneExperiment	function
(	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
)	O
)	O
{	O
printf	function
(	O
"Warning: Can't estimate y with parameters:\n"	pointer
)	O
;	O
WriteArray	function
(	O
stdout	pointer
,	O
panal	pointer
->	O
mc	struct
.	O
nSetParms	long
,	O
pdTheta	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
return	O
0	int
;	O
}	O
pos	pointer
=	O
&	O
panal	pointer
->	O
rgpExps	array
[	O
i	long
]	O
->	O
os	struct
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
pos	pointer
->	O
nOutputs	int
;	O
j	long
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pos	pointer
->	O
pcOutputTimes	pointer
[	O
j	long
]	O
;	O
k	int
++	O
)	O
{	O
pdY	pointer
[	O
cNPred	int
]	O
=	O
pos	pointer
->	O
prgdOutputVals	pointer
[	O
j	long
]	O
[	O
k	int
]	O
;	O
cNPred	int
++	O
;	O
}	O
}	O
}	O
return	O
1	int
;	O
}	O
void	O
ReadAndSimulate	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
long	O
nSetParms	long
,	O
double	O
*	O
*	O
pdY	pointer
,	O
long	O
nPreds	long
,	O
PMCVAR	pointer
*	O
pLikes	pointer
,	O
long	O
nSims	long
)	O
{	O
register	O
char	O
c	char
;	O
long	O
lDummy	long
,	O
iter	long
=	O
0	int
;	O
long	O
j	long
;	O
PDOUBLE	pointer
pdTheta	pointer
=	O
NULL	O
;	O
PDOUBLE	pointer
pdTheta_0	pointer
=	O
NULL	O
;	O
PDOUBLE	pointer
pdData	pointer
=	O
NULL	O
;	O
PDOUBLE	pointer
pdData_old	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
pfileRestart	pointer
=	O
panal	pointer
->	O
gd	struct
.	O
pfileRestart	pointer
;	O
if	O
(	O
!	O
(	O
pdTheta	pointer
=	O
InitdVector	function
(	O
nSetParms	long
)	O
)	O
||	O
!	O
(	O
pdTheta_0	pointer
=	O
InitdVector	function
(	O
nSetParms	long
)	O
)	O
||	O
!	O
(	O
pdData_old	pointer
=	O
InitdVector	function
(	O
nPreds	long
)	O
)	O
||	O
!	O
(	O
pdData	pointer
=	O
InitdVector	function
(	O
nPreds	long
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"ReadAndSimulate"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pfileRestart	pointer
)	O
&&	O
!	O
(	O
pfileRestart	pointer
=	O
fopen	function
(	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
,	O
"r"	pointer
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_FATAL	int
|	O
RE_CANNOTOPEN	int
,	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
,	O
"[in ReadAndSimulate()]"	pointer
)	O
;	O
do	O
{	O
c	char
=	O
getc	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
while	O
(	O
c	char
!=	O
'\n'	O
)	O
;	O
while	O
(	O
(	O
iter	long
<	O
nSims	long
)	O
&&	O
(	O
!	O
(	O
feof	function
(	O
pfileRestart	pointer
)	O
||	O
(	O
fscanf	function
(	O
pfileRestart	pointer
,	O
"%ld"	pointer
,	O
&	O
lDummy	long
)	O
==	O
EOF	O
)	O
)	O
)	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nSetParms	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
!	O
fscanf	function
(	O
pfileRestart	pointer
,	O
"%lg"	pointer
,	O
&	O
(	O
pdTheta	pointer
[	O
j	long
]	O
)	O
)	O
)	O
ReportError	function
(	O
NULL	O
,	O
RE_READERROR	int
|	O
RE_FATAL	int
,	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
,	O
NULL	O
)	O
;	O
else	O
panal	pointer
->	O
mc	struct
.	O
rgpMCVar	pointer
[	O
j	long
]	O
->	O
dVal	double
=	O
pdTheta	pointer
[	O
j	long
]	O
;	O
}	O
do	O
{	O
c	char
=	O
getc	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
while	O
(	O
c	char
!=	O
'\n'	O
)	O
;	O
Estimate_y	function
(	O
panal	pointer
,	O
pdTheta	pointer
,	O
pdY	pointer
[	O
iter	long
]	O
)	O
;	O
if	O
(	O
iter	long
==	O
0	int
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nSetParms	long
;	O
j	long
++	O
)	O
{	O
pdTheta_0	pointer
[	O
j	long
]	O
=	O
pdTheta	pointer
[	O
j	long
]	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nPreds	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
pLikes	pointer
[	O
j	long
]	O
!=	O
NULL	O
)	O
{	O
CalculateOneMCParm	function
(	O
pLikes	pointer
[	O
j	long
]	O
)	O
;	O
pdData_old	pointer
[	O
j	long
]	O
=	O
pLikes	pointer
[	O
j	long
]	O
->	O
dVal	double
;	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nPreds	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
pLikes	pointer
[	O
j	long
]	O
!=	O
NULL	O
)	O
{	O
CalculateOneMCParm	function
(	O
pLikes	pointer
[	O
j	long
]	O
)	O
;	O
pdData	pointer
[	O
j	long
]	O
=	O
pLikes	pointer
[	O
j	long
]	O
->	O
dVal	double
;	O
}	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nPreds	long
;	O
j	long
++	O
)	O
if	O
(	O
pLikes	pointer
[	O
j	long
]	O
!=	O
NULL	O
)	O
{	O
pLikes	pointer
[	O
j	long
]	O
->	O
dVal	double
=	O
pdData_old	pointer
[	O
j	long
]	O
;	O
pdY	pointer
[	O
iter	long
]	O
[	O
j	long
]	O
=	O
LnDensity	function
(	O
pLikes	pointer
[	O
j	long
]	O
,	O
panal	pointer
)	O
;	O
pdData_old	pointer
[	O
j	long
]	O
=	O
pdData	pointer
[	O
j	long
]	O
;	O
}	O
if	O
(	O
iter	long
==	O
nSims	long
-	O
1	int
)	O
{	O
Estimate_y	function
(	O
panal	pointer
,	O
pdTheta_0	pointer
,	O
pdY	pointer
[	O
0	int
]	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nPreds	long
;	O
j	long
++	O
)	O
if	O
(	O
pLikes	pointer
[	O
j	long
]	O
!=	O
NULL	O
)	O
{	O
pLikes	pointer
[	O
j	long
]	O
->	O
dVal	double
=	O
pdData_old	pointer
[	O
j	long
]	O
;	O
pdY	pointer
[	O
0	int
]	O
[	O
j	long
]	O
=	O
LnDensity	function
(	O
pLikes	pointer
[	O
j	long
]	O
,	O
panal	pointer
)	O
;	O
}	O
}	O
}	O
iter	long
++	O
;	O
}	O
if	O
(	O
iter	long
<	O
nSims	long
)	O
{	O
printf	function
(	O
"\nError: The number of lines in file %s is less than\n"	pointer
,	O
panal	pointer
->	O
gd	struct
.	O
szGrestart	pointer
)	O
;	O
printf	function
(	O
"       the number of lines to read (%ld) - Exiting\n"	pointer
,	O
nSims	long
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
fclose	function
(	O
pfileRestart	pointer
)	O
;	O
}	O
void	O
Do_Importance_Ratios	function
(	O
double	O
*	O
*	O
pdY	pointer
,	O
PMCVAR	pointer
*	O
pLikes	pointer
,	O
long	O
nSims	long
,	O
long	O
nPreds	long
,	O
long	O
nDesignPts	long
,	O
int	O
*	O
piDesign_mask	pointer
,	O
int	O
nDesignPt_tried	int
,	O
double	O
*	O
pdIR	pointer
)	O
{	O
long	O
i	long
,	O
j	long
,	O
k	int
;	O
double	O
dSumL	double
=	O
0	int
;	O
BOOL	int
bOn	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
nSims	long
;	O
k	int
++	O
)	O
{	O
pdIR	pointer
[	O
k	int
]	O
=	O
0	int
;	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nPreds	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
pLikes	pointer
[	O
i	long
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
j	long
==	O
nDesignPt_tried	int
)	O
bOn	int
=	O
!	O
piDesign_mask	pointer
[	O
j	long
]	O
;	O
else	O
bOn	int
=	O
piDesign_mask	pointer
[	O
j	long
]	O
;	O
if	O
(	O
bOn	int
)	O
pdIR	pointer
[	O
k	int
]	O
=	O
pdIR	pointer
[	O
k	int
]	O
+	O
pdY	pointer
[	O
k	int
]	O
[	O
i	long
]	O
;	O
j	long
++	O
;	O
}	O
}	O
pdIR	pointer
[	O
k	int
]	O
=	O
exp	function
(	O
pdIR	pointer
[	O
k	int
]	O
)	O
;	O
dSumL	double
=	O
dSumL	double
+	O
pdIR	pointer
[	O
k	int
]	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
nSims	long
;	O
k	int
++	O
)	O
pdIR	pointer
[	O
k	int
]	O
=	O
pdIR	pointer
[	O
k	int
]	O
/	O
dSumL	double
;	O
}	O
double	O
DoVariance	function
(	O
long	O
nDim	long
,	O
double	O
*	O
pdIR	pointer
,	O
double	O
*	O
*	O
pdX	pointer
,	O
long	O
istart	long
,	O
long	O
ifinish	long
)	O
{	O
long	O
i	long
,	O
j	long
;	O
register	O
double	O
ave	double
,	O
ss	double
,	O
dTmp	double
;	O
ss	double
=	O
0	int
;	O
for	O
(	O
i	long
=	O
istart	long
;	O
i	long
<	O
ifinish	long
;	O
i	long
++	O
)	O
{	O
ave	double
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nDim	long
;	O
j	long
++	O
)	O
{	O
ave	double
=	O
ave	double
+	O
pdIR	pointer
[	O
j	long
]	O
*	O
log	function
(	O
pdX	pointer
[	O
j	long
]	O
[	O
i	long
]	O
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nDim	long
;	O
j	long
++	O
)	O
{	O
dTmp	double
=	O
log	function
(	O
pdX	pointer
[	O
j	long
]	O
[	O
i	long
]	O
)	O
-	O
ave	double
;	O
ss	double
=	O
ss	double
+	O
pdIR	pointer
[	O
j	long
]	O
*	O
dTmp	double
*	O
dTmp	double
;	O
}	O
}	O
return	O
(	O
ss	double
/	O
(	O
double	O
)	O
(	O
ifinish	long
-	O
istart	long
)	O
)	O
;	O
}	O
void	O
Compute_utility	function
(	O
long	O
nDesignPts	long
,	O
int	O
*	O
piDesign_mask	pointer
,	O
double	O
*	O
dUtility	pointer
)	O
{	O
int	O
nPts	long
=	O
0	int
;	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nDesignPts	long
;	O
i	long
++	O
)	O
if	O
(	O
piDesign_mask	pointer
[	O
i	long
]	O
)	O
nPts	long
++	O
;	O
*	O
dUtility	pointer
=	O
-	O
2	int
*	O
nPts	long
;	O
}	O
void	O
WriteOptimOut	function
(	O
PANALYSIS	pointer
panal	pointer
,	O
long	O
iter	long
,	O
long	O
nDesignPts	long
,	O
int	O
criterion	int
,	O
double	O
*	O
pdVariance	pointer
,	O
int	O
*	O
piDesign_mask	pointer
,	O
long	O
iCrit	long
,	O
double	O
dCrit	double
,	O
double	O
dUtility	pointer
)	O
{	O
long	O
i	long
;	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"%ld\t"	pointer
,	O
iter	long
)	O
;	O
if	O
(	O
iCrit	long
<	O
nDesignPts	long
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nDesignPts	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
(	O
&	O
panal	pointer
->	O
mc	struct
)	O
->	O
style	int
==	O
forward	int
)	O
{	O
if	O
(	O
(	O
i	long
==	O
iCrit	long
)	O
||	O
!	O
(	O
piDesign_mask	pointer
[	O
i	long
]	O
)	O
)	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"%g\t"	pointer
,	O
pdVariance	pointer
[	O
i	long
]	O
)	O
;	O
else	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"0\t"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
piDesign_mask	pointer
[	O
i	long
]	O
)	O
)	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"0\t"	pointer
)	O
;	O
else	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"%g\t"	pointer
,	O
pdVariance	pointer
[	O
i	long
]	O
)	O
;	O
}	O
}	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"%ld\t"	pointer
,	O
iCrit	long
+	O
1	int
)	O
;	O
}	O
else	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
nDesignPts	long
;	O
i	long
++	O
)	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"0\t"	pointer
)	O
;	O
if	O
(	O
criterion	int
==	O
Var_Reduction	int
)	O
fprintf	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
,	O
"%g\t%g\t%g\n"	pointer
,	O
dCrit	double
,	O
sqrt	function
(	O
dCrit	double
)	O
,	O
dUtility	pointer
)	O
;	O
fflush	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
)	O
;	O
}	O
void	O
Importance_Resample	function
(	O
long	O
nSims	long
,	O
long	O
*	O
pIndex0	pointer
,	O
long	O
*	O
pIndex1	pointer
,	O
long	O
*	O
plDrawn	pointer
,	O
double	O
*	O
pdL	pointer
,	O
double	O
dSumL	double
)	O
{	O
long	O
i	long
,	O
j	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nSims	long
;	O
i	long
++	O
)	O
pdL	pointer
[	O
i	long
]	O
=	O
pdL	pointer
[	O
i	long
]	O
/	O
dSumL	double
;	O
j	long
=	O
0	int
;	O
do	O
{	O
i	long
=	O
(	O
long	O
)	O
floor	function
(	O
Randoms	function
(	O
)	O
*	O
nSims	long
)	O
;	O
if	O
(	O
Randoms	function
(	O
)	O
<	O
pdL	pointer
[	O
i	long
]	O
)	O
{	O
pIndex1	pointer
[	O
j	long
]	O
=	O
pIndex0	pointer
[	O
i	long
]	O
;	O
j	long
++	O
;	O
plDrawn	pointer
[	O
pIndex0	pointer
[	O
i	long
]	O
]	O
++	O
;	O
}	O
}	O
while	O
(	O
j	long
<	O
nSims	long
)	O
;	O
}	O
void	O
CloseOptFiles	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
if	O
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
)	O
{	O
fclose	function
(	O
panal	pointer
->	O
gd	struct
.	O
pfileOut	pointer
)	O
;	O
printf	function
(	O
"\nWrote results to \"%s\"\n"	pointer
,	O
panal	pointer
->	O
gd	struct
.	O
szGout	pointer
)	O
;	O
}	O
}	O
void	O
DoOptimalDesign	function
(	O
PANALYSIS	pointer
panal	pointer
)	O
{	O
PGIBBSDATA	pointer
pgd	pointer
=	O
&	O
panal	pointer
->	O
gd	struct
;	O
PMONTECARLO	pointer
pmc	pointer
=	O
&	O
panal	pointer
->	O
mc	struct
;	O
long	O
i	long
,	O
j	long
;	O
long	O
iBest	long
=	O
0	int
;	O
long	O
dim	int
;	O
long	O
nDesignPts	long
;	O
long	O
nPreds	long
;	O
long	O
nSims	long
=	O
pmc	pointer
->	O
nRuns	long
;	O
int	O
*	O
piDesign_mask	pointer
;	O
long	O
nDesignPt_tried	int
;	O
long	O
nStartDecisionPts	long
;	O
int	O
criterion	int
;	O
double	O
dBest	double
=	O
0	int
;	O
double	O
dUtility	pointer
=	O
0	int
;	O
double	O
*	O
pdIR	pointer
;	O
double	O
*	O
pdVariance	pointer
;	O
double	O
*	O
*	O
pdY	pointer
;	O
PMCVAR	pointer
*	O
pLikes	pointer
;	O
criterion	int
=	O
Var_Reduction	int
;	O
if	O
(	O
criterion	int
!=	O
Var_Reduction	int
)	O
{	O
printf	function
(	O
"Oooops, Shannon not implemented - exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
printf	function
(	O
"\nDoing analysis - Optimal Design %s %s - %d experiment%c\n"	pointer
,	O
(	O
pmc	pointer
->	O
style	int
==	O
forward	int
?	O
"forward"	pointer
:	O
"backward"	pointer
)	O
,	O
(	O
criterion	int
==	O
Var_Reduction	int
?	O
"variance reduction"	pointer
:	O
"Shannon"	pointer
)	O
,	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
,	O
(	O
panal	pointer
->	O
expGlobal	struct
.	O
iExp	int
>	O
1	int
?	O
's'	O
:	O
' '	O
)	O
)	O
;	O
OpenOptFiles	function
(	O
panal	pointer
)	O
;	O
InitOptArrays	function
(	O
panal	pointer
,	O
&	O
piDesign_mask	pointer
,	O
&	O
nDesignPts	long
,	O
&	O
pdY	pointer
,	O
&	O
nPreds	long
,	O
&	O
nStartDecisionPts	long
,	O
&	O
pdVariance	pointer
,	O
&	O
pdIR	pointer
,	O
nSims	long
)	O
;	O
SetupLikes	function
(	O
panal	pointer
,	O
nPreds	long
,	O
&	O
pLikes	pointer
)	O
;	O
if	O
(	O
!	O
(	O
pgd	pointer
->	O
szGrestart	pointer
)	O
)	O
{	O
printf	function
(	O
"Error: there must be a parameter sample file - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
{	O
ReadAndSimulate	function
(	O
panal	pointer
,	O
pmc	pointer
->	O
nSetParms	long
,	O
pdY	pointer
,	O
nPreds	long
,	O
pLikes	pointer
,	O
nSims	long
)	O
;	O
}	O
WriteOutHeader	function
(	O
panal	pointer
,	O
criterion	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nDesignPts	long
;	O
i	long
++	O
)	O
piDesign_mask	pointer
[	O
i	long
]	O
=	O
!	O
(	O
pmc	pointer
->	O
style	int
==	O
forward	int
)	O
;	O
if	O
(	O
criterion	int
==	O
Var_Reduction	int
)	O
{	O
if	O
(	O
pmc	pointer
->	O
style	int
==	O
backward	int
)	O
{	O
nDesignPt_tried	int
=	O
nDesignPts	long
+	O
1	int
;	O
Do_Importance_Ratios	function
(	O
pdY	pointer
,	O
pLikes	pointer
,	O
nSims	long
,	O
nPreds	long
,	O
nDesignPts	long
,	O
piDesign_mask	pointer
,	O
nDesignPt_tried	int
,	O
pdIR	pointer
)	O
;	O
dBest	double
=	O
DoVariance	function
(	O
nSims	long
,	O
pdIR	pointer
,	O
pdY	pointer
,	O
nStartDecisionPts	long
,	O
nPreds	long
)	O
;	O
}	O
else	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nSims	long
;	O
j	long
++	O
)	O
pdIR	pointer
[	O
j	long
]	O
=	O
1	int
/	O
(	O
double	O
)	O
nSims	long
;	O
dBest	double
=	O
DoVariance	function
(	O
nSims	long
,	O
pdIR	pointer
,	O
pdY	pointer
,	O
nStartDecisionPts	long
,	O
nPreds	long
)	O
;	O
}	O
}	O
iBest	long
=	O
nDesignPts	long
+	O
1	int
;	O
WriteOptimOut	function
(	O
panal	pointer
,	O
0	int
,	O
nDesignPts	long
,	O
criterion	int
,	O
pdVariance	pointer
,	O
piDesign_mask	pointer
,	O
iBest	long
,	O
dBest	double
,	O
dUtility	pointer
)	O
;	O
dim	int
=	O
(	O
(	O
pmc	pointer
->	O
style	int
==	O
backward	int
)	O
?	O
nDesignPts	long
-	O
1	int
:	O
nDesignPts	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
criterion	int
==	O
Var_Reduction	int
)	O
dBest	double
=	O
DBL_MAX	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nDesignPts	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
piDesign_mask	pointer
[	O
j	long
]	O
==	O
(	O
pmc	pointer
->	O
style	int
==	O
backward	int
)	O
)	O
{	O
nDesignPt_tried	int
=	O
j	long
;	O
pdVariance	pointer
[	O
j	long
]	O
=	O
0	int
;	O
if	O
(	O
criterion	int
==	O
Var_Reduction	int
)	O
{	O
Do_Importance_Ratios	function
(	O
pdY	pointer
,	O
pLikes	pointer
,	O
nSims	long
,	O
nPreds	long
,	O
nDesignPts	long
,	O
piDesign_mask	pointer
,	O
nDesignPt_tried	int
,	O
pdIR	pointer
)	O
;	O
pdVariance	pointer
[	O
j	long
]	O
=	O
DoVariance	function
(	O
nSims	long
,	O
pdIR	pointer
,	O
pdY	pointer
,	O
nStartDecisionPts	long
,	O
nPreds	long
)	O
;	O
}	O
if	O
(	O
dBest	double
>	O
pdVariance	pointer
[	O
j	long
]	O
)	O
{	O
dBest	double
=	O
pdVariance	pointer
[	O
j	long
]	O
;	O
iBest	long
=	O
j	long
;	O
}	O
}	O
}	O
piDesign_mask	pointer
[	O
iBest	long
]	O
=	O
!	O
piDesign_mask	pointer
[	O
iBest	long
]	O
;	O
WriteOptimOut	function
(	O
panal	pointer
,	O
i	long
+	O
1	int
,	O
nDesignPts	long
,	O
criterion	int
,	O
pdVariance	pointer
,	O
piDesign_mask	pointer
,	O
iBest	long
,	O
dBest	double
,	O
dUtility	pointer
)	O
;	O
printf	function
(	O
"%ld points design done\n"	pointer
,	O
i	long
+	O
1	int
)	O
;	O
}	O
if	O
(	O
pmc	pointer
->	O
style	int
==	O
backward	int
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nSims	long
;	O
j	long
++	O
)	O
pdIR	pointer
[	O
j	long
]	O
=	O
1	int
/	O
(	O
double	O
)	O
nSims	long
;	O
if	O
(	O
criterion	int
==	O
Var_Reduction	int
)	O
{	O
dBest	double
=	O
DoVariance	function
(	O
nSims	long
,	O
pdIR	pointer
,	O
pdY	pointer
,	O
nStartDecisionPts	long
,	O
nPreds	long
)	O
;	O
j	long
=	O
0	int
;	O
while	O
(	O
piDesign_mask	pointer
[	O
j	long
]	O
==	O
0	int
)	O
j	long
++	O
;	O
iBest	long
=	O
j	long
;	O
}	O
WriteOptimOut	function
(	O
panal	pointer
,	O
nDesignPts	long
,	O
nDesignPts	long
,	O
criterion	int
,	O
pdVariance	pointer
,	O
piDesign_mask	pointer
,	O
iBest	long
,	O
dBest	double
,	O
0	int
)	O
;	O
printf	function
(	O
"%ld points design done\n"	pointer
,	O
nDesignPts	long
)	O
;	O
}	O
free	function
(	O
piDesign_mask	pointer
)	O
;	O
CloseOptFiles	function
(	O
panal	pointer
)	O
;	O
}	O
