int	O
swlib_pipe_pump	function
(	O
int	O
ofd	int
,	O
int	O
suction_fd	int
)	O
;	O
static	O
long	O
shcmd_getgid	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
struct	O
group	struct
*	O
pw	pointer
;	O
if	O
(	O
strlen	function
(	O
cmd	pointer
->	O
group_	array
)	O
)	O
{	O
pw	pointer
=	O
getgrnam	function
(	O
cmd	pointer
->	O
group_	array
)	O
;	O
if	O
(	O
pw	pointer
)	O
{	O
return	O
pw	pointer
->	O
gr_gid	int
;	O
}	O
else	O
{	O
return	O
-	O
2	int
;	O
}	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
static	O
long	O
shcmd_getuid	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
if	O
(	O
strlen	function
(	O
cmd	pointer
->	O
user_	array
)	O
)	O
{	O
pw	pointer
=	O
getpwnam	function
(	O
cmd	pointer
->	O
user_	array
)	O
;	O
if	O
(	O
pw	pointer
)	O
{	O
return	O
(	O
long	O
)	O
(	O
pw	pointer
->	O
pw_uid	int
)	O
;	O
}	O
else	O
{	O
return	O
(	O
long	O
)	O
-	O
2	int
;	O
}	O
}	O
else	O
{	O
return	O
(	O
long	O
)	O
-	O
1	int
;	O
}	O
}	O
static	O
void	O
internal_redirect	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
int	O
srcfd	int
,	O
char	O
*	O
srcfile	pointer
,	O
int	O
dstfd	int
,	O
char	O
*	O
dstfile	pointer
,	O
int	O
append1	int
,	O
int	O
errfd	int
,	O
char	O
*	O
errfile	pointer
,	O
int	O
append2	int
)	O
{	O
int	O
fd	int
;	O
int	O
flags	int
;	O
mode_t	int
mode	int
;	O
if	O
(	O
srcfd	int
!=	O
0	int
||	O
srcfile	pointer
)	O
{	O
if	O
(	O
srcfd	int
==	O
STDIN_FILENO	int
&&	O
!	O
srcfile	pointer
)	O
{	O
;	O
}	O
else	O
if	O
(	O
srcfd	int
>	O
0	int
&&	O
!	O
srcfile	pointer
)	O
{	O
if	O
(	O
dup2	function
(	O
srcfd	int
,	O
STDIN_FILENO	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"src dup error\n"	pointer
)	O
;	O
}	O
close	pointer
(	O
srcfd	int
)	O
;	O
}	O
else	O
if	O
(	O
srcfile	pointer
)	O
{	O
if	O
(	O
(	O
fd	int
=	O
open	function
(	O
srcfile	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal: error opening %s\n"	pointer
,	O
srcfile	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fd	int
!=	O
STDIN_FILENO	int
)	O
{	O
dup2	function
(	O
fd	int
,	O
STDIN_FILENO	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal: internal error, invalid stdin redirection. \n"	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
dstfd	int
!=	O
STDOUT_FILENO	int
||	O
dstfile	pointer
)	O
{	O
if	O
(	O
dstfd	int
==	O
STDOUT_FILENO	int
&&	O
!	O
dstfile	pointer
)	O
{	O
;	O
}	O
else	O
if	O
(	O
dstfd	int
>	O
STDOUT_FILENO	int
&&	O
!	O
dstfile	pointer
)	O
{	O
if	O
(	O
dup2	function
(	O
dstfd	int
,	O
STDOUT_FILENO	int
)	O
!=	O
STDOUT_FILENO	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"dst dup error\n"	pointer
)	O
;	O
}	O
close	pointer
(	O
dstfd	int
)	O
;	O
}	O
else	O
if	O
(	O
dstfile	pointer
)	O
{	O
flags	int
=	O
O_WRONLY	int
|	O
O_CREAT	int
;	O
if	O
(	O
append1	int
)	O
{	O
flags	int
|=	O
O_APPEND	int
;	O
}	O
else	O
{	O
flags	int
|=	O
O_TRUNC	int
;	O
}	O
mode	int
=	O
umask	function
(	O
cmd	pointer
->	O
umask_	int
)	O
;	O
if	O
(	O
(	O
fd	int
=	O
open	function
(	O
dstfile	pointer
,	O
flags	int
,	O
0666	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal: error opening %s\n"	pointer
,	O
dstfile	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
umask	function
(	O
mode	int
)	O
;	O
if	O
(	O
fd	int
!=	O
STDOUT_FILENO	int
)	O
{	O
dup2	function
(	O
fd	int
,	O
STDOUT_FILENO	int
)	O
;	O
}	O
if	O
(	O
append1	int
)	O
{	O
if	O
(	O
lseek	function
(	O
1	int
,	O
0L	int
,	O
SEEK_END	int
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error seeking to end of %s\n"	pointer
,	O
dstfile	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal: internal error,"	pointer
" invalid stdout redirection. \n"	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
errfd	int
!=	O
STDERR_FILENO	int
||	O
errfile	pointer
)	O
{	O
if	O
(	O
errfd	int
==	O
STDERR_FILENO	int
&&	O
!	O
errfile	pointer
)	O
{	O
;	O
}	O
else	O
if	O
(	O
(	O
errfd	int
>	O
STDERR_FILENO	int
&&	O
!	O
errfile	pointer
)	O
||	O
errfd	int
==	O
STDOUT_FILENO	int
)	O
{	O
if	O
(	O
dup2	function
(	O
errfd	int
,	O
STDERR_FILENO	int
)	O
!=	O
STDERR_FILENO	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"err dup error\n"	pointer
)	O
;	O
}	O
close	pointer
(	O
errfd	int
)	O
;	O
}	O
else	O
if	O
(	O
errfile	pointer
)	O
{	O
flags	int
=	O
O_WRONLY	int
|	O
O_CREAT	int
;	O
if	O
(	O
append2	int
)	O
{	O
flags	int
|=	O
O_APPEND	int
;	O
}	O
else	O
{	O
flags	int
|=	O
O_TRUNC	int
;	O
}	O
mode	int
=	O
umask	function
(	O
cmd	pointer
->	O
umask_	int
)	O
;	O
if	O
(	O
(	O
fd	int
=	O
open	function
(	O
errfile	pointer
,	O
flags	int
,	O
0666	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal: error opening %s\n"	pointer
,	O
errfile	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
umask	function
(	O
mode	int
)	O
;	O
if	O
(	O
fd	int
!=	O
STDERR_FILENO	int
)	O
{	O
dup2	function
(	O
fd	int
,	O
STDERR_FILENO	int
)	O
;	O
}	O
if	O
(	O
append2	int
)	O
{	O
lseek	function
(	O
fd	int
,	O
0L	int
,	O
SEEK_END	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal: internal error,"	pointer
" invalid stderr redirection. \n"	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
static	O
SHCMD	struct
*	O
shcmd_common_open	function
(	O
void	O
)	O
{	O
mode_t	int
mode	int
=	O
(	O
mode_t	int
)	O
0	int
;	O
int	O
i	int
;	O
SHCMD	struct
*	O
shcmd	pointer
;	O
shcmd	pointer
=	O
(	O
SHCMD	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SHCMD	struct
)	O
)	O
;	O
if	O
(	O
shcmd	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
shcmd	pointer
->	O
argvector_	pointer
=	O
cplob_open	function
(	O
10	int
)	O
;	O
shcmd	pointer
->	O
argv_set_	int
=	O
0	int
;	O
shcmd	pointer
->	O
argv_	pointer
=	O
(	O
char	O
*	O
*	O
)	O
(	O
NULL	O
)	O
;	O
shcmd	pointer
->	O
argstring_	pointer
=	O
NULL	O
;	O
shcmd	pointer
->	O
cmdstring_	pointer
=	O
NULL	O
;	O
shcmd	pointer
->	O
closefd_	int
=	O
-	O
1	int
;	O
shcmd	pointer
->	O
pid_	int
=	O
0	int
;	O
shcmd	pointer
->	O
status_	int
=	O
0	int
;	O
shcmd	pointer
->	O
srcfd_	int
=	O
STDIN_FILENO	int
;	O
shcmd	pointer
->	O
dstfd_	int
=	O
STDOUT_FILENO	int
;	O
shcmd	pointer
->	O
errfd_	int
=	O
STDERR_FILENO	int
;	O
shcmd	pointer
->	O
dstfile_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
shcmd	pointer
->	O
srcfile_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
shcmd	pointer
->	O
errfile_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
shcmd	pointer
->	O
append1_	int
=	O
0	int
;	O
shcmd	pointer
->	O
append2_	int
=	O
0	int
;	O
shcmd	pointer
->	O
async_	int
=	O
0	int
;	O
shcmd	pointer
->	O
close_all_fd_	int
=	O
-	O
1	int
;	O
shcmd	pointer
->	O
child_gone_	int
=	O
0	int
;	O
shcmd	pointer
->	O
proc_error_	int
=	O
0	int
;	O
shcmd	pointer
->	O
esrch_	int
=	O
0	int
;	O
shcmd	pointer
->	O
envp_	pointer
=	O
environ	pointer
;	O
mode	int
=	O
umask	function
(	O
mode	int
)	O
;	O
umask	function
(	O
mode	int
)	O
;	O
shcmd	pointer
->	O
umask_	int
=	O
mode	int
;	O
(	O
shcmd	pointer
->	O
user_	array
)	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
(	O
shcmd	pointer
->	O
group_	array
)	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
shcmd	pointer
->	O
f_filter_	pointer
=	O
(	O
int	O
(	O
*	O
)	O
(	O
int	O
,	O
int	O
,	O
void	O
*	O
)	O
)	O
(	O
NULL	O
)	O
;	O
shcmd	pointer
->	O
f_filter_ctrl_	pointer
=	O
(	O
void	O
*	O
)	O
NULL	O
;	O
shcmd	pointer
->	O
f_exec_	pointer
=	O
shcmd_unix_execve	function
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CLOSE_LIST_LEN	O
;	O
i	int
++	O
)	O
{	O
shcmd	pointer
->	O
close_list_	array
[	O
i	int
]	O
=	O
-	O
1	int
;	O
}	O
return	O
shcmd	pointer
;	O
}	O
static	O
void	O
close_list	function
(	O
SHCMD	struct
*	O
shcmd	pointer
)	O
{	O
int	O
fd	int
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
CLOSE_LIST_LEN	O
)	O
{	O
fd	int
=	O
shcmd	pointer
->	O
close_list_	array
[	O
i	int
]	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
if	O
(	O
close	pointer
(	O
fd	int
)	O
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"shcmd : close_list_: fd=%d : %s\n"	pointer
,	O
fd	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
i	int
++	O
;	O
}	O
}	O
static	O
int	O
cmd_invoke	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
int	O
uid	int
;	O
int	O
gid	int
;	O
int	O
child_exitval	int
;	O
int	O
child_pid	int
;	O
int	O
srcfd	int
=	O
cmd	pointer
->	O
srcfd_	int
;	O
int	O
dstfd	int
=	O
cmd	pointer
->	O
dstfd_	int
;	O
child_pid	int
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
child_pid	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Can't create new process.\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
child_pid	int
==	O
0	int
)	O
{	O
if	O
(	O
cmd	pointer
->	O
closefd_	int
!=	O
-	O
1	int
)	O
close	pointer
(	O
cmd	pointer
->	O
closefd_	int
)	O
;	O
close_list	function
(	O
cmd	pointer
)	O
;	O
gid	int
=	O
(	O
gid_t	int
)	O
shcmd_getgid	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
shcmd_getgid	function
(	O
cmd	pointer
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
setgid	function
(	O
(	O
gid_t	int
)	O
(	O
shcmd_getgid	function
(	O
cmd	pointer
)	O
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"setgid failed in"	pointer
" shcmd_cmd_invoke, group=%s %s\n"	pointer
,	O
cmd	pointer
->	O
group_	array
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
gid	int
==	O
-	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"shcmd_getgid failed:"	pointer
" gid not found for group=%s"	pointer
,	O
cmd	pointer
->	O
group_	array
)	O
;	O
}	O
else	O
{	O
;	O
}	O
uid	int
=	O
(	O
uid_t	int
)	O
shcmd_getuid	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
uid	int
>=	O
0	int
)	O
{	O
if	O
(	O
setuid	function
(	O
(	O
uid_t	int
)	O
(	O
uid	int
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"setuid failed in"	pointer
" shcmd_cmd_invoke, user=%s %s\n"	pointer
,	O
cmd	pointer
->	O
user_	array
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
uid	int
==	O
-	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"shcmd_getuid failed:"	pointer
" uid not found for user=%s"	pointer
,	O
cmd	pointer
->	O
user_	array
)	O
;	O
}	O
else	O
{	O
;	O
}	O
internal_redirect	function
(	O
cmd	pointer
,	O
srcfd	int
,	O
cmd	pointer
->	O
srcfile_	pointer
,	O
dstfd	int
,	O
cmd	pointer
->	O
dstfile_	pointer
,	O
cmd	pointer
->	O
append1_	int
,	O
cmd	pointer
->	O
errfd_	int
,	O
cmd	pointer
->	O
errfile_	pointer
,	O
cmd	pointer
->	O
append2_	int
)	O
;	O
umask	function
(	O
cmd	pointer
->	O
umask_	int
)	O
;	O
if	O
(	O
cmd	pointer
->	O
argv_	pointer
&&	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
,	O
SHCMD_INTERNAL_FILTER	pointer
)	O
==	O
0	int
)	O
{	O
int	O
ret	int
;	O
if	O
(	O
cmd	pointer
->	O
f_filter_	pointer
)	O
{	O
ret	int
=	O
(	O
*	O
(	O
cmd	pointer
->	O
f_filter_	pointer
)	O
)	O
(	O
STDOUT_FILENO	int
,	O
STDIN_FILENO	int
,	O
cmd	pointer
->	O
f_filter_ctrl_	pointer
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
swlib_pipe_pump	function
(	O
STDOUT_FILENO	int
,	O
STDIN_FILENO	int
)	O
;	O
}	O
child_exitval	int
=	O
ret	int
<	O
0	int
?	O
1	int
:	O
0	int
;	O
}	O
else	O
if	O
(	O
cmd	pointer
->	O
argv_	pointer
&&	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
&&	O
strlen	function
(	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
)	O
)	O
{	O
(	O
*	O
(	O
cmd	pointer
->	O
f_exec_	pointer
)	O
)	O
(	O
cmd	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unable to execute %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
)	O
;	O
child_exitval	int
=	O
126	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"shcmd.c: illegal or null command name\n"	pointer
)	O
;	O
child_exitval	int
=	O
1	int
;	O
}	O
_exit	function
(	O
child_exitval	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
srcfd	int
>	O
0	int
)	O
close	pointer
(	O
srcfd	int
)	O
;	O
if	O
(	O
dstfd	int
>	O
1	int
)	O
close	pointer
(	O
dstfd	int
)	O
;	O
cmd	pointer
->	O
pid_	int
=	O
child_pid	int
;	O
return	O
child_pid	int
;	O
}	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
static	O
int	O
command_recurse	function
(	O
SHCMD	struct
*	O
*	O
cmd_vector	pointer
,	O
int	O
*	O
wpid	pointer
,	O
int	O
makepipe	int
,	O
int	O
*	O
pipefd	pointer
)	O
{	O
int	O
pid	int
;	O
int	O
pfd	array
[	O
2	int
]	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
(	O
cmd_vector	pointer
+	O
1	int
)	O
!=	O
NULL	O
)	O
{	O
command_recurse	function
(	O
cmd_vector	pointer
+	O
1	int
,	O
wpid	pointer
,	O
1	int
,	O
&	O
(	O
cmd_vector	pointer
[	O
0	int
]	O
->	O
dstfd_	int
)	O
)	O
;	O
}	O
if	O
(	O
makepipe	int
)	O
{	O
pipe	function
(	O
pfd	array
)	O
;	O
*	O
pipefd	pointer
=	O
pfd	array
[	O
1	int
]	O
;	O
cmd_vector	pointer
[	O
0	int
]	O
->	O
srcfd_	int
=	O
pfd	array
[	O
0	int
]	O
;	O
cmd_vector	pointer
[	O
0	int
]	O
->	O
closefd_	int
=	O
pfd	array
[	O
1	int
]	O
;	O
}	O
pid	int
=	O
cmd_invoke	function
(	O
*	O
cmd_vector	pointer
)	O
;	O
if	O
(	O
*	O
wpid	pointer
==	O
0	int
)	O
*	O
wpid	pointer
=	O
pid	int
;	O
return	O
*	O
wpid	pointer
;	O
}	O
}	O
void	O
shcmd_add_close_fd	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
int	O
ifd	int
)	O
{	O
int	O
fd	int
;	O
int	O
i	int
=	O
0	int
;	O
fd	int
=	O
shcmd	pointer
->	O
close_list_	array
[	O
i	int
]	O
;	O
while	O
(	O
fd	int
>=	O
0	int
&&	O
i	int
<	O
CLOSE_LIST_LEN	O
)	O
{	O
fd	int
=	O
shcmd	pointer
->	O
close_list_	array
[	O
++	O
i	int
]	O
;	O
}	O
if	O
(	O
i	int
<	O
CLOSE_LIST_LEN	O
)	O
{	O
shcmd	pointer
->	O
close_list_	array
[	O
i	int
]	O
=	O
ifd	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"shcmd_add_close_fd() internal error\n"	pointer
)	O
;	O
}	O
}	O
char	O
*	O
shcmd_find_in_path	function
(	O
char	O
*	O
ppath	pointer
,	O
char	O
*	O
pgm	pointer
)	O
{	O
char	O
*	O
retval	pointer
=	O
NULL	O
;	O
struct	O
stat	struct
st	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
name	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
strchr	function
(	O
pgm	pointer
,	O
'/'	O
)	O
)	O
{	O
ret	int
=	O
stat	struct
(	O
pgm	pointer
,	O
&	O
st	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
S_ISREG	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
return	O
NULL	O
;	O
return	O
pgm	pointer
;	O
}	O
if	O
(	O
!	O
ppath	pointer
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
name	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
ppath	pointer
,	O
":"	pointer
)	O
;	O
while	O
(	O
s	pointer
)	O
{	O
strob_strcpy	function
(	O
name	pointer
,	O
s	pointer
)	O
;	O
strob_strcat	function
(	O
name	pointer
,	O
"/"	pointer
)	O
;	O
strob_strcat	function
(	O
name	pointer
,	O
pgm	pointer
)	O
;	O
if	O
(	O
access	function
(	O
strob_str	function
(	O
name	pointer
)	O
,	O
X_OK	int
)	O
==	O
0	int
)	O
{	O
retval	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
name	pointer
)	O
)	O
;	O
break	O
;	O
}	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
":"	pointer
)	O
;	O
}	O
strob_close	function
(	O
name	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
retval	pointer
;	O
}	O
int	O
shcmd_apply_redirection	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
internal_redirect	function
(	O
cmd	pointer
,	O
cmd	pointer
->	O
srcfd_	int
,	O
cmd	pointer
->	O
srcfile_	pointer
,	O
cmd	pointer
->	O
dstfd_	int
,	O
cmd	pointer
->	O
dstfile_	pointer
,	O
cmd	pointer
->	O
append1_	int
,	O
cmd	pointer
->	O
errfd_	int
,	O
cmd	pointer
->	O
errfile_	pointer
,	O
cmd	pointer
->	O
append2_	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
shcmd_reap_child	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
int	O
flag	int
)	O
{	O
pid_t	int
pid	int
;	O
if	O
(	O
cmd	pointer
->	O
status_	int
||	O
cmd	pointer
->	O
child_gone_	int
)	O
{	O
cmd	pointer
->	O
child_gone_	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pid	int
=	O
waitpid	function
(	O
cmd	pointer
->	O
pid_	int
,	O
&	O
(	O
cmd	pointer
->	O
status_	int
)	O
,	O
flag	int
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"ERROR"	pointer
)	O
;	O
if	O
(	O
errno	O
==	O
ECHILD	int
)	O
{	O
E_DEBUG	O
(	O
"ECHILD"	pointer
)	O
;	O
cmd	pointer
->	O
child_gone_	int
=	O
1	int
;	O
}	O
cmd	pointer
->	O
proc_error_	int
=	O
1	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"shcmd: waitpid return error (pid=%d) for %s: %s\n"	pointer
,	O
(	O
int	O
)	O
(	O
cmd	pointer
->	O
pid_	int
)	O
,	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
E_DEBUG3	O
(	O
"Normal stop: pid=%d: %s"	pointer
,	O
(	O
int	O
)	O
(	O
cmd	pointer
->	O
pid_	int
)	O
,	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
)	O
;	O
E_DEBUG3	O
(	O
"exit value for %s is %d"	pointer
,	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
,	O
shcmd_get_exitval	function
(	O
cmd	pointer
)	O
)	O
;	O
cmd	pointer
->	O
child_gone_	int
=	O
1	int
;	O
}	O
return	O
pid	int
;	O
}	O
int	O
shcmd_cmdvec_wait	function
(	O
SHCMD	struct
*	O
*	O
cmd_vec	pointer
)	O
{	O
return	O
shcmd_wait	function
(	O
cmd_vec	pointer
)	O
;	O
}	O
int	O
shcmd_cmdvec_kill	function
(	O
SHCMD	struct
*	O
*	O
cmd_vec	pointer
,	O
int	O
from	int
,	O
int	O
direction	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
int	O
i	int
=	O
from	int
;	O
while	O
(	O
i	int
>=	O
0	int
&&	O
cmd_vec	pointer
[	O
i	int
]	O
)	O
{	O
if	O
(	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
status_	int
==	O
0	int
&&	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
esrch_	int
==	O
0	int
&&	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
child_gone_	int
==	O
0	int
)	O
{	O
ret	int
=	O
kill	function
(	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
pid_	int
,	O
SIGTERM	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ESRCH	int
)	O
{	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
esrch_	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
direction	int
==	O
SHC_DIR_UP	int
)	O
i	int
++	O
;	O
else	O
i	int
--	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
shcmd_cmdvec_wait2	function
(	O
SHCMD	struct
*	O
*	O
cmd_vec	pointer
)	O
{	O
SHCMD	struct
*	O
*	O
cmdv	pointer
=	O
cmd_vec	pointer
;	O
int	O
ncmds	int
=	O
0	int
;	O
int	O
ncmds_exited	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
ret	int
;	O
int	O
highest_index_with_error	int
;	O
while	O
(	O
*	O
cmdv	pointer
)	O
{	O
cmdv	pointer
++	O
;	O
ncmds	int
++	O
;	O
}	O
E_DEBUG2	O
(	O
"No. of commands in pipeline: ncmds = [%d]"	pointer
,	O
ncmds	int
)	O
;	O
i	int
=	O
0	int
;	O
highest_index_with_error	int
=	O
0	int
;	O
do	O
{	O
E_DEBUG	O
(	O
"Loop Begin"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
ncmds	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
E_DEBUG3	O
(	O
"calling reap_child for for cmd_vec[%d]: %s"	pointer
,	O
i	int
,	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
argv_	pointer
[	O
0	int
]	O
)	O
;	O
ret	int
=	O
shcmd_reap_child	function
(	O
cmd_vec	pointer
[	O
i	int
]	O
,	O
WNOHANG	int
)	O
;	O
E_DEBUG3	O
(	O
"finished reap_child for for cmd_vec[%d]: ret=%d"	pointer
,	O
i	int
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
>	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"good stop for %s"	pointer
,	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
argv_	pointer
[	O
0	int
]	O
)	O
;	O
ncmds_exited	int
++	O
;	O
}	O
else	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
child_gone_	int
==	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"still waiting on pid %d"	pointer
,	O
(	O
int	O
)	O
(	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
pid_	int
)	O
)	O
;	O
;	O
}	O
;	O
}	O
else	O
{	O
if	O
(	O
errno	O
==	O
ECHILD	int
)	O
{	O
E_DEBUG2	O
(	O
"ECHILD on pid %d"	pointer
,	O
(	O
int	O
)	O
(	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
pid_	int
)	O
)	O
;	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
proc_error_	int
=	O
1	int
;	O
ncmds_exited	int
++	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"shcmd: waitpid return error (line=%d) for [%d]: %s\n"	pointer
,	O
__LINE__	O
,	O
(	O
int	O
)	O
(	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
pid_	int
)	O
,	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
argv_	pointer
[	O
0	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
cmd_vec	pointer
[	O
i	int
]	O
->	O
proc_error_	int
)	O
{	O
if	O
(	O
i	int
>	O
highest_index_with_error	int
)	O
highest_index_with_error	int
=	O
i	int
;	O
}	O
}	O
if	O
(	O
highest_index_with_error	int
)	O
{	O
E_DEBUG2	O
(	O
"Killing commands at index=%d"	pointer
,	O
highest_index_with_error	int
)	O
;	O
shcmd_cmdvec_kill	function
(	O
cmd_vec	pointer
,	O
highest_index_with_error	int
,	O
SHC_DIR_UP	int
)	O
;	O
}	O
highest_index_with_error	int
=	O
0	int
;	O
E_DEBUG	O
(	O
"Sleeping"	pointer
)	O
;	O
usleep	function
(	O
100000	int
)	O
;	O
E_DEBUG	O
(	O
"Loop End"	pointer
)	O
;	O
}	O
while	O
(	O
ncmds_exited	int
<	O
ncmds	int
)	O
;	O
E_DEBUG	O
(	O
"Done"	pointer
)	O
;	O
return	O
shcmd_get_exitval	function
(	O
cmd_vec	pointer
[	O
ncmds	int
-	O
1	int
]	O
)	O
;	O
}	O
int	O
shcmd_wait	function
(	O
SHCMD	struct
*	O
*	O
cmd_vec	pointer
)	O
{	O
SHCMD	struct
*	O
*	O
cmdv	pointer
=	O
cmd_vec	pointer
;	O
pid_t	int
pid	int
;	O
int	O
ncmds	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
ret	int
;	O
while	O
(	O
*	O
cmdv	pointer
)	O
{	O
cmdv	pointer
++	O
;	O
ncmds	int
++	O
;	O
}	O
cmdv	pointer
--	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
shcmd_reap_child	function
(	O
*	O
cmdv	pointer
,	O
0	int
)	O
>	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ncmds	int
--	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ncmds	int
;	O
i	int
++	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pid	int
=	O
shcmd_reap_child	function
(	O
cmd_vec	pointer
[	O
i	int
]	O
,	O
0	int
)	O
;	O
}	O
}	O
ret	int
=	O
shcmd_get_exitval	function
(	O
*	O
cmdv	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
shcmd_cmdvec_exec	function
(	O
SHCMD	struct
*	O
*	O
cmd_vector	pointer
)	O
{	O
return	O
shcmd_command	function
(	O
cmd_vector	pointer
)	O
;	O
}	O
int	O
shcmd_unix_exec	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
if	O
(	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
close_all_fd_	int
>=	O
0	int
)	O
swgp_close_all_fd	function
(	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
close_all_fd_	int
)	O
;	O
return	O
execve	function
(	O
cmd	pointer
->	O
argv_	pointer
[	O
0	int
]	O
,	O
cmd	pointer
->	O
argv_	pointer
,	O
cmd	pointer
->	O
envp_	pointer
)	O
;	O
}	O
int	O
shcmd_unix_execvp	function
(	O
void	O
*	O
cmd	pointer
)	O
{	O
if	O
(	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
close_all_fd_	int
>=	O
0	int
)	O
swgp_close_all_fd	function
(	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
close_all_fd_	int
)	O
;	O
return	O
execvp	function
(	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
argv_	pointer
[	O
0	int
]	O
,	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
argv_	pointer
)	O
;	O
}	O
int	O
shcmd_unix_execve	function
(	O
void	O
*	O
cmd	pointer
)	O
{	O
if	O
(	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
close_all_fd_	int
>=	O
0	int
)	O
swgp_close_all_fd	function
(	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
close_all_fd_	int
)	O
;	O
return	O
execve	function
(	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
argv_	pointer
[	O
0	int
]	O
,	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
argv_	pointer
,	O
(	O
(	O
SHCMD	struct
*	O
)	O
cmd	pointer
)	O
->	O
envp_	pointer
)	O
;	O
}	O
int	O
shcmd_command	function
(	O
SHCMD	struct
*	O
*	O
cmd_vector	pointer
)	O
{	O
int	O
pids	int
=	O
0	int
;	O
return	O
command_recurse	function
(	O
cmd_vector	pointer
,	O
&	O
pids	int
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
int	O
shcmd_do_tainted_data_check	function
(	O
char	O
*	O
cmdstring	pointer
)	O
{	O
if	O
(	O
strpbrk	function
(	O
cmdstring	pointer
,	O
SHCMD_TAINTED_CHARS	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
SHCMD	struct
*	O
shcmd_open	function
(	O
void	O
)	O
{	O
return	O
shcmd_common_open	function
(	O
)	O
;	O
}	O
int	O
shcmd_cmdvec_debug_show_to_file	function
(	O
SHCMD	struct
*	O
*	O
vec	pointer
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
SHCMD	struct
*	O
*	O
pv	pointer
=	O
vec	pointer
;	O
while	O
(	O
*	O
pv	pointer
)	O
{	O
shcmd_debug_show_to_file	function
(	O
*	O
pv	pointer
,	O
file	pointer
)	O
;	O
pv	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
shcmd_debug_show	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
return	O
shcmd_debug_show_to_file	function
(	O
cmd	pointer
,	O
stderr	pointer
)	O
;	O
}	O
int	O
shcmd_debug_show_to_file	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
char	O
*	O
*	O
vec	pointer
=	O
cmd	pointer
->	O
argv_	pointer
;	O
if	O
(	O
cmd	pointer
->	O
cmdstring_	pointer
)	O
fprintf	function
(	O
file	pointer
,	O
"%p: command string = [%s]\n"	pointer
,	O
(	O
void	O
*	O
)	O
cmd	pointer
,	O
cmd	pointer
->	O
cmdstring_	pointer
)	O
;	O
else	O
fprintf	function
(	O
file	pointer
,	O
"%p: command string = nil\n"	pointer
,	O
(	O
void	O
*	O
)	O
cmd	pointer
)	O
;	O
if	O
(	O
vec	pointer
)	O
{	O
while	O
(	O
*	O
vec	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
"<[%s]>"	pointer
,	O
*	O
vec	pointer
)	O
;	O
vec	pointer
++	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
file	pointer
,	O
"nil\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
file	pointer
,	O
"\n     pid=%d exit value=%d\n"	pointer
,	O
(	O
int	O
)	O
(	O
cmd	pointer
->	O
pid_	int
)	O
,	O
shcmd_get_exitval	function
(	O
cmd	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"     status=%d, srcfd=%d; dstfd=%d\n"	pointer
,	O
cmd	pointer
->	O
status_	int
,	O
cmd	pointer
->	O
srcfd_	int
,	O
cmd	pointer
->	O
dstfd_	int
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
"     user=[%s] group=[%s]\n"	pointer
,	O
cmd	pointer
->	O
user_	array
,	O
cmd	pointer
->	O
group_	array
)	O
;	O
return	O
0	int
;	O
}	O
int	O
shcmd_write_command_to_buf	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
STROB	struct
*	O
tmp	pointer
)	O
{	O
char	O
*	O
*	O
arg	pointer
=	O
cmd	pointer
->	O
argv_	pointer
;	O
if	O
(	O
arg	pointer
)	O
{	O
while	O
(	O
*	O
arg	pointer
)	O
{	O
if	O
(	O
strpbrk	function
(	O
*	O
arg	pointer
,	O
"; &*?$|<>`\""	pointer
)	O
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
"'%s'"	pointer
,	O
*	O
arg	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strlen	function
(	O
*	O
arg	pointer
)	O
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
"''"	pointer
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
"%s"	pointer
,	O
*	O
arg	pointer
)	O
;	O
}	O
arg	pointer
++	O
;	O
if	O
(	O
*	O
arg	pointer
)	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
" "	pointer
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
shcmd_debug_show_command	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
shcmd_write_command_to_buf	function
(	O
cmd	pointer
,	O
tmp	pointer
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_DO_APPEND	int
,	O
"\n"	pointer
)	O
;	O
ret	int
=	O
uxfio_write	function
(	O
fd	int
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
strob_strlen	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
shcmd_close	function
(	O
SHCMD	struct
*	O
shcmd	pointer
)	O
{	O
cplob_close	function
(	O
shcmd	pointer
->	O
argvector_	pointer
)	O
;	O
if	O
(	O
shcmd	pointer
->	O
dstfile_	pointer
)	O
swbis_free	O
(	O
shcmd	pointer
->	O
dstfile_	pointer
)	O
;	O
if	O
(	O
shcmd	pointer
->	O
srcfile_	pointer
)	O
swbis_free	O
(	O
shcmd	pointer
->	O
srcfile_	pointer
)	O
;	O
if	O
(	O
shcmd	pointer
->	O
errfile_	pointer
)	O
swbis_free	O
(	O
shcmd	pointer
->	O
errfile_	pointer
)	O
;	O
if	O
(	O
shcmd	pointer
->	O
cmdstring_	pointer
)	O
swbis_free	O
(	O
shcmd	pointer
->	O
cmdstring_	pointer
)	O
;	O
if	O
(	O
shcmd	pointer
->	O
argv_	pointer
&&	O
!	O
shcmd	pointer
->	O
argv_set_	int
)	O
swbis_free	O
(	O
shcmd	pointer
->	O
argv_	pointer
)	O
;	O
if	O
(	O
shcmd	pointer
->	O
argstring_	pointer
)	O
swbis_free	O
(	O
shcmd	pointer
->	O
argstring_	pointer
)	O
;	O
swbis_free	O
(	O
shcmd	pointer
)	O
;	O
}	O
void	O
shcmd_set_exec_function	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
char	O
*	O
form	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
form	pointer
,	O
"execvp"	pointer
)	O
==	O
0	int
)	O
{	O
shcmd	pointer
->	O
f_exec_	pointer
=	O
shcmd_unix_execvp	function
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
form	pointer
,	O
"execve"	pointer
)	O
==	O
0	int
)	O
{	O
shcmd	pointer
->	O
f_exec_	pointer
=	O
shcmd_unix_execve	function
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"shcmd_set_exec_function:"	pointer
" no effect, invalid function\n"	pointer
)	O
;	O
}	O
}	O
void	O
shcmd_set_dstfd	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
int	O
fd	int
)	O
{	O
shcmd	pointer
->	O
dstfd_	int
=	O
fd	int
;	O
}	O
void	O
shcmd_set_append	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
int	O
do_append	int
)	O
{	O
shcmd_set_append1	function
(	O
shcmd	pointer
,	O
do_append	int
)	O
;	O
}	O
void	O
shcmd_set_append1	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
int	O
do_append	int
)	O
{	O
shcmd	pointer
->	O
append1_	int
=	O
do_append	int
;	O
}	O
void	O
shcmd_set_append2	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
int	O
do_append	int
)	O
{	O
shcmd	pointer
->	O
append2_	int
=	O
do_append	int
;	O
}	O
void	O
shcmd_set_srcfile	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
shcmd	pointer
->	O
srcfile_	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
}	O
void	O
shcmd_set_dstfile	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
shcmd	pointer
->	O
dstfile_	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
}	O
void	O
shcmd_set_errfile	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
shcmd	pointer
->	O
errfile_	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
}	O
void	O
shcmd_set_srcfd	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
int	O
fd	int
)	O
{	O
shcmd	pointer
->	O
srcfd_	int
=	O
fd	int
;	O
}	O
void	O
shcmd_set_errfd	function
(	O
SHCMD	struct
*	O
shcmd	pointer
,	O
int	O
fd	int
)	O
{	O
shcmd	pointer
->	O
errfd_	int
=	O
fd	int
;	O
}	O
int	O
shcmd_get_srcfd	function
(	O
SHCMD	struct
*	O
shcmd	pointer
)	O
{	O
return	O
shcmd	pointer
->	O
srcfd_	int
;	O
}	O
int	O
shcmd_get_dstfd	function
(	O
SHCMD	struct
*	O
shcmd	pointer
)	O
{	O
return	O
shcmd	pointer
->	O
dstfd_	int
;	O
}	O
int	O
shcmd_get_errfd	function
(	O
SHCMD	struct
*	O
shcmd	pointer
)	O
{	O
return	O
shcmd	pointer
->	O
errfd_	int
;	O
}	O
pid_t	int
shcmd_get_pid	function
(	O
SHCMD	struct
*	O
shcmd	pointer
)	O
{	O
return	O
shcmd	pointer
->	O
pid_	int
;	O
}	O
int	O
shcmd_get_exitval	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
if	O
(	O
cmd	pointer
->	O
pid_	int
&&	O
WIFEXITED	O
(	O
cmd	pointer
->	O
status_	int
)	O
)	O
{	O
return	O
WEXITSTATUS	O
(	O
cmd	pointer
->	O
status_	int
)	O
;	O
}	O
else	O
{	O
return	O
SHCMD_UNSET_EXITVAL	int
;	O
}	O
}	O
char	O
*	O
*	O
shcmd_get_envp	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
return	O
cmd	pointer
->	O
envp_	pointer
;	O
}	O
void	O
shcmd_set_envp	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
char	O
*	O
*	O
env	pointer
)	O
{	O
cmd	pointer
->	O
envp_	pointer
=	O
env	pointer
;	O
}	O
mode_t	int
shcmd_get_umask	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
return	O
cmd	pointer
->	O
umask_	int
;	O
}	O
void	O
shcmd_set_umask	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
mode_t	int
mode	int
)	O
{	O
cmd	pointer
->	O
umask_	int
=	O
(	O
int	O
)	O
mode	int
;	O
}	O
char	O
*	O
*	O
shcmd_get_argvector	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
return	O
cplob_get_list	function
(	O
cmd	pointer
->	O
argvector_	pointer
)	O
;	O
}	O
char	O
*	O
*	O
shcmd_add_arg	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
char	O
*	O
arg	pointer
)	O
{	O
cplob_add_nta	function
(	O
cmd	pointer
->	O
argvector_	pointer
,	O
strdup	function
(	O
arg	pointer
)	O
)	O
;	O
cmd	pointer
->	O
argv_set_	int
=	O
1	int
;	O
cmd	pointer
->	O
argv_	pointer
=	O
cplob_get_list	function
(	O
cmd	pointer
->	O
argvector_	pointer
)	O
;	O
return	O
cmd	pointer
->	O
argv_	pointer
;	O
}	O
void	O
shcmd_set_argv	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
cmd	pointer
->	O
argv_set_	int
=	O
1	int
;	O
cmd	pointer
->	O
argv_	pointer
=	O
argv	pointer
;	O
if	O
(	O
cmd	pointer
->	O
cmdstring_	pointer
)	O
swbis_free	O
(	O
cmd	pointer
->	O
cmdstring_	pointer
)	O
;	O
cmd	pointer
->	O
cmdstring_	pointer
=	O
strdup	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
void	O
shcmd_set_user	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
strncpy	function
(	O
cmd	pointer
->	O
user_	array
,	O
name	pointer
,	O
sizeof	O
(	O
cmd	pointer
->	O
user_	array
)	O
-	O
1	int
)	O
;	O
cmd	pointer
->	O
user_	array
[	O
sizeof	O
(	O
cmd	pointer
->	O
user_	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
void	O
shcmd_set_group	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
strncpy	function
(	O
cmd	pointer
->	O
group_	array
,	O
name	pointer
,	O
sizeof	O
(	O
cmd	pointer
->	O
group_	array
)	O
-	O
1	int
)	O
;	O
cmd	pointer
->	O
group_	array
[	O
sizeof	O
(	O
cmd	pointer
->	O
group_	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
char	O
*	O
shcmd_get_user	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
return	O
cmd	pointer
->	O
user_	array
;	O
}	O
char	O
*	O
shcmd_get_group	function
(	O
SHCMD	struct
*	O
cmd	pointer
)	O
{	O
return	O
cmd	pointer
->	O
group_	array
;	O
}	O
void	O
shcmd_set_lowest_close_fd	function
(	O
SHCMD	struct
*	O
cmd	pointer
,	O
int	O
fd	int
)	O
{	O
cmd	pointer
->	O
close_all_fd_	int
=	O
fd	int
;	O
}	O
SHCMD	struct
*	O
shcmd_get_last_command	function
(	O
SHCMD	struct
*	O
*	O
cmdvec	pointer
)	O
{	O
SHCMD	struct
*	O
*	O
v	int
;	O
SHCMD	struct
*	O
last	pointer
;	O
last	pointer
=	O
NULL	O
;	O
v	int
=	O
cmdvec	pointer
;	O
while	O
(	O
*	O
v	int
)	O
{	O
last	pointer
=	O
*	O
v	int
;	O
v	int
++	O
;	O
}	O
return	O
last	pointer
;	O
}	O
