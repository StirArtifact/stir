static	O
int	O
Cull_Object	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
int	O
this_id	int
)	O
;	O
int	O
mav_cityCellDraw	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
;	O
int	O
mav_compositeDrawWire	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
;	O
int	O
mav_occluderDraw	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
;	O
int	O
mav_billboardDraw	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
;	O
extern	O
MAV_class	O
*	O
mav_class_avatar	pointer
;	O
extern	O
MAV_class	O
*	O
mav_class_occluder	pointer
;	O
extern	O
MAV_class	O
*	O
mav_class_citycell	pointer
;	O
extern	O
MAV_class	O
*	O
mav_class_billboard	pointer
;	O
extern	O
int	O
num_visible_objects	int
;	O
extern	O
Visible_Object	O
*	O
visible_objects	pointer
;	O
extern	O
int	O
num_rendered_cells	int
;	O
extern	O
int	O
num_rendered_polygons	int
;	O
extern	O
int	O
current_frame	int
;	O
extern	O
int	O
wire	int
;	O
extern	O
int	O
max_rendered_cells	int
;	O
extern	O
int	O
culling	int
;	O
BB	O
bb_array	int
[	O
MAX_BILLBOARDS	O
]	O
;	O
float	O
object_dist	float
;	O
MAV_vector	O
object_pos	int
;	O
int	O
bb_pos	int
;	O
int	O
num_occluders	int
=	O
0	int
;	O
Candidate	O
candidate	int
;	O
struct	O
timeval	struct
starttime	struct
,	O
endtime	struct
;	O
double	O
cull_time	double
,	O
render_time	double
;	O
void	O
initTime	function
(	O
void	O
)	O
{	O
gettimeofday	function
(	O
&	O
starttime	struct
,	O
NULL	O
)	O
;	O
}	O
double	O
calcTime	function
(	O
void	O
)	O
{	O
int	O
elapsedSec	int
,	O
elapsedUSec	int
;	O
gettimeofday	function
(	O
&	O
endtime	struct
,	O
NULL	O
)	O
;	O
elapsedSec	int
=	O
endtime	struct
.	O
tv_sec	long
-	O
starttime	struct
.	O
tv_sec	long
;	O
elapsedUSec	int
=	O
endtime	struct
.	O
tv_usec	long
-	O
starttime	struct
.	O
tv_usec	long
;	O
return	O
1000.0	int
*	O
(	O
elapsedSec	int
+	O
elapsedUSec	int
/	O
1.0E+6	int
)	O
;	O
}	O
static	O
int	O
Compare_Object_Distances	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
Visible_Object	O
*	O
s1	O
,	O
*	O
s2	O
;	O
s1	O
=	O
(	O
Visible_Object	O
*	O
)	O
a	pointer
;	O
s2	O
=	O
(	O
Visible_Object	O
*	O
)	O
b	pointer
;	O
if	O
(	O
s1	O
->	O
dist	pointer
<	O
s2	O
->	O
dist	pointer
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
s1	O
->	O
dist	pointer
>	O
s2	O
->	O
dist	pointer
)	O
return	O
1	int
;	O
else	O
{	O
if	O
(	O
s1	O
->	O
obj	pointer
->	O
the_class	O
==	O
mav_class_occluder	pointer
&&	O
s2	O
->	O
obj	pointer
->	O
the_class	O
!=	O
mav_class_occluder	pointer
)	O
return	O
1	int
;	O
else	O
if	O
(	O
s1	O
->	O
obj	pointer
->	O
the_class	O
!=	O
mav_class_occluder	pointer
&&	O
s2	O
->	O
obj	pointer
->	O
the_class	O
==	O
mav_class_occluder	pointer
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
}	O
static	O
float	O
Find_Shortest_Distance	function
(	O
MAV_object	O
*	O
obj	pointer
)	O
{	O
MAV_BB	O
bb	O
;	O
MAV_vector	O
dr	O
;	O
mav_callbackBBExec	function
(	O
mav_win_left	O
,	O
obj	pointer
,	O
&	O
bb	O
)	O
;	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
>	O
bb	O
.	O
max	O
.	O
y	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
max	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
max	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
max	O
.	O
y	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
max	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
max	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
max	O
.	O
y	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
max	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
max	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
<	O
bb	O
.	O
min	O
.	O
y	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
min	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
min	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
min	O
.	O
y	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
min	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
min	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
;	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
min	O
.	O
y	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
min	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
dr	O
.	O
y	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
-	O
bb	O
.	O
min	O
.	O
y	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
y	float
*	O
dr	O
.	O
y	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
return	O
fabs	function
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
min	O
.	O
x	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
;	O
return	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
return	O
fabs	function
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb	O
.	O
max	O
.	O
x	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
return	O
fabs	function
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
return	O
fabs	function
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
return	O
0.0	int
;	O
}	O
}	O
}	O
}	O
static	O
int	O
Compare_Billboard_Distances	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
BB	O
*	O
b1	O
,	O
*	O
b2	O
;	O
b1	O
=	O
(	O
BB	O
*	O
)	O
a	pointer
;	O
b2	O
=	O
(	O
BB	O
*	O
)	O
b	pointer
;	O
if	O
(	O
b1	O
->	O
dist	pointer
>	O
b2	O
->	O
dist	pointer
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
b1	O
->	O
dist	pointer
<	O
b2	O
->	O
dist	pointer
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
void	O
Redisplay_Objects	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_visible_objects	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
visible_objects	pointer
[	O
i	int
]	O
.	O
visible	O
&&	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
->	O
the_class	O
!=	O
mav_class_billboard	pointer
)	O
{	O
object_dist	float
=	O
visible_objects	pointer
[	O
i	int
]	O
.	O
dist	pointer
;	O
mav_callbackDrawExec	function
(	O
mav_win_current	O
,	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
bb_pos	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bb_pos	int
;	O
i	int
++	O
)	O
{	O
object_pos	int
=	O
bb_array	int
[	O
i	int
]	O
.	O
pos	O
;	O
object_dist	float
=	O
bb_array	int
[	O
i	int
]	O
.	O
dist	pointer
;	O
mav_billboardDraw	function
(	O
bb_array	int
[	O
i	int
]	O
.	O
obj	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
}	O
void	O
Display_Objects	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
MAV_vector	O
dr	O
;	O
num_occluders	int
=	O
0	int
;	O
bb_pos	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_visible_objects	int
;	O
i	int
++	O
)	O
visible_objects	pointer
[	O
i	int
]	O
.	O
dist	pointer
=	O
Find_Shortest_Distance	function
(	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
)	O
;	O
qsort	function
(	O
(	O
void	O
*	O
)	O
visible_objects	pointer
,	O
num_visible_objects	int
,	O
sizeof	O
(	O
Visible_Object	O
)	O
,	O
Compare_Object_Distances	function
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_visible_objects	int
;	O
i	int
++	O
)	O
visible_objects	pointer
[	O
i	int
]	O
.	O
visible	O
=	O
culling	int
?	O
Cull_Object	function
(	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
,	O
i	int
)	O
:	O
1	int
;	O
cull_time	double
=	O
calcTime	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_visible_objects	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
visible_objects	pointer
[	O
i	int
]	O
.	O
visible	O
)	O
{	O
if	O
(	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
->	O
the_class	O
!=	O
mav_class_billboard	pointer
)	O
{	O
object_dist	float
=	O
visible_objects	pointer
[	O
i	int
]	O
.	O
dist	pointer
;	O
mav_callbackDrawExec	function
(	O
mav_win_current	O
,	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
obj	pointer
=	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
;	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
pos	O
.	O
x	float
=	O
0.0	int
;	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
pos	O
.	O
y	float
=	O
(	O
(	O
MAV_billboard	O
*	O
)	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
->	O
the_data	O
)	O
->	O
height	O
/	O
2.0	int
;	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
pos	O
.	O
z	float
=	O
0.0	int
;	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
pos	O
=	O
mav_vectorMult	function
(	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
pos	O
,	O
(	O
(	O
MAV_billboard	O
*	O
)	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
->	O
the_data	O
)	O
->	O
matrix	O
)	O
;	O
dr	O
.	O
x	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
-	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
pos	O
.	O
x	float
;	O
dr	O
.	O
z	float
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
-	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
pos	O
.	O
z	float
;	O
bb_array	int
[	O
bb_pos	int
]	O
.	O
dist	pointer
=	O
sqrt	function
(	O
dr	O
.	O
x	float
*	O
dr	O
.	O
x	float
+	O
dr	O
.	O
z	float
*	O
dr	O
.	O
z	float
)	O
;	O
bb_pos	int
++	O
;	O
}	O
}	O
}	O
if	O
(	O
bb_pos	int
>	O
0	int
)	O
{	O
if	O
(	O
!	O
wire	int
&&	O
bb_pos	int
>	O
1	int
)	O
qsort	function
(	O
(	O
void	O
*	O
)	O
bb_array	int
,	O
bb_pos	int
,	O
sizeof	O
(	O
BB	O
)	O
,	O
Compare_Billboard_Distances	function
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bb_pos	int
;	O
i	int
++	O
)	O
{	O
object_pos	int
=	O
bb_array	int
[	O
i	int
]	O
.	O
pos	O
;	O
object_dist	float
=	O
bb_array	int
[	O
i	int
]	O
.	O
dist	pointer
;	O
mav_billboardDraw	function
(	O
bb_array	int
[	O
i	int
]	O
.	O
obj	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
render_time	double
=	O
calcTime	function
(	O
)	O
-	O
cull_time	double
;	O
}	O
static	O
int	O
Lines_Intersect	function
(	O
MAV_vector	O
*	O
p1	pointer
,	O
MAV_vector	O
*	O
p2	pointer
,	O
MAV_vector	O
*	O
p3	pointer
,	O
MAV_vector	O
*	O
p4	pointer
,	O
MAV_vector	O
*	O
p	pointer
,	O
float	O
*	O
dist	pointer
)	O
{	O
register	O
float	O
Ax	float
,	O
Bx	float
,	O
Cx	float
,	O
Ay	float
,	O
By	float
,	O
Cy	float
,	O
d	float
,	O
e	float
,	O
f	float
;	O
register	O
float	O
x1lo	float
,	O
x1hi	float
,	O
y1lo	float
,	O
y1hi	float
;	O
Ax	float
=	O
p2	pointer
->	O
x	float
-	O
p1	pointer
->	O
x	float
;	O
Bx	float
=	O
p3	pointer
->	O
x	float
-	O
p4	pointer
->	O
x	float
;	O
if	O
(	O
Ax	float
<	O
0.0	int
)	O
{	O
x1lo	float
=	O
p2	pointer
->	O
x	float
;	O
x1hi	float
=	O
p1	pointer
->	O
x	float
;	O
}	O
else	O
{	O
x1hi	float
=	O
p2	pointer
->	O
x	float
;	O
x1lo	float
=	O
p1	pointer
->	O
x	float
;	O
}	O
if	O
(	O
Bx	float
>	O
0.0	int
)	O
{	O
if	O
(	O
x1hi	float
<=	O
p4	pointer
->	O
x	float
||	O
p3	pointer
->	O
x	float
<=	O
x1lo	float
)	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
x1hi	float
<=	O
p3	pointer
->	O
x	float
||	O
p4	pointer
->	O
x	float
<=	O
x1lo	float
)	O
return	O
0	int
;	O
}	O
Ay	float
=	O
p2	pointer
->	O
y	float
-	O
p1	pointer
->	O
y	float
;	O
By	float
=	O
p3	pointer
->	O
y	float
-	O
p4	pointer
->	O
y	float
;	O
if	O
(	O
Ay	float
<	O
0.0	int
)	O
{	O
y1lo	float
=	O
p2	pointer
->	O
y	float
;	O
y1hi	float
=	O
p1	pointer
->	O
y	float
;	O
}	O
else	O
{	O
y1hi	float
=	O
p2	pointer
->	O
y	float
;	O
y1lo	float
=	O
p1	pointer
->	O
y	float
;	O
}	O
if	O
(	O
By	float
>	O
0.0	int
)	O
{	O
if	O
(	O
y1hi	float
<=	O
p4	pointer
->	O
y	float
||	O
p3	pointer
->	O
y	float
<=	O
y1lo	float
)	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
y1hi	float
<=	O
p3	pointer
->	O
y	float
||	O
p4	pointer
->	O
y	float
<=	O
y1lo	float
)	O
return	O
0	int
;	O
}	O
Cx	float
=	O
p1	pointer
->	O
x	float
-	O
p3	pointer
->	O
x	float
;	O
Cy	float
=	O
p1	pointer
->	O
y	float
-	O
p3	pointer
->	O
y	float
;	O
d	float
=	O
By	float
*	O
Cx	float
-	O
Bx	float
*	O
Cy	float
;	O
f	float
=	O
Ay	float
*	O
Bx	float
-	O
Ax	float
*	O
By	float
;	O
if	O
(	O
f	float
>	O
0.0	int
)	O
{	O
if	O
(	O
d	float
<	O
0.0	int
||	O
d	float
>	O
f	float
)	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
d	float
>	O
0.0	int
||	O
d	float
<	O
f	float
)	O
return	O
0	int
;	O
}	O
e	float
=	O
Ax	float
*	O
Cy	float
-	O
Ay	float
*	O
Cx	float
;	O
if	O
(	O
f	float
>	O
0.0	int
)	O
{	O
if	O
(	O
e	float
<	O
0.0	int
||	O
e	float
>	O
f	float
)	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
e	float
>	O
0.0	int
||	O
e	float
<	O
f	float
)	O
return	O
0	int
;	O
}	O
if	O
(	O
fabs	function
(	O
f	float
)	O
<	O
1e-6	int
)	O
return	O
0	int
;	O
d	float
/=	O
f	float
;	O
p	pointer
->	O
x	float
=	O
p1	pointer
->	O
x	float
+	O
d	float
*	O
Ax	float
;	O
p	pointer
->	O
y	float
=	O
p1	pointer
->	O
y	float
+	O
d	float
*	O
Ay	float
;	O
*	O
dist	pointer
=	O
d	float
;	O
return	O
1	int
;	O
}	O
static	O
int	O
Point_In_Polygon	function
(	O
MAV_vector	O
*	O
pgon	pointer
,	O
int	O
numverts	int
,	O
MAV_vector	O
*	O
point	pointer
)	O
{	O
register	O
int	O
j	int
,	O
yflag0	int
,	O
yflag1	int
,	O
inside_flag	int
,	O
xflag0	int
;	O
register	O
float	O
ty	float
,	O
tx	float
;	O
register	O
MAV_vector	O
*	O
vtx0	pointer
,	O
*	O
vtx1	O
;	O
register	O
int	O
line_flag	int
;	O
register	O
int	O
v	int
=	O
0	int
;	O
tx	float
=	O
point	pointer
->	O
x	float
;	O
ty	float
=	O
point	pointer
->	O
y	float
;	O
vtx0	pointer
=	O
&	O
pgon	pointer
[	O
numverts	int
-	O
1	int
]	O
;	O
yflag0	int
=	O
(	O
vtx0	pointer
->	O
y	float
>=	O
ty	float
)	O
;	O
vtx1	O
=	O
&	O
pgon	pointer
[	O
v	int
]	O
;	O
inside_flag	int
=	O
0	int
;	O
line_flag	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
numverts	int
+	O
1	int
;	O
--	O
j	int
;	O
)	O
{	O
yflag1	int
=	O
(	O
vtx1	O
->	O
y	float
>=	O
ty	float
)	O
;	O
if	O
(	O
yflag0	int
!=	O
yflag1	int
)	O
{	O
xflag0	int
=	O
(	O
vtx0	pointer
->	O
x	float
>=	O
tx	float
)	O
;	O
if	O
(	O
xflag0	int
==	O
(	O
vtx1	O
->	O
x	float
>=	O
tx	float
)	O
)	O
{	O
if	O
(	O
xflag0	int
)	O
inside_flag	int
=	O
!	O
inside_flag	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
vtx1	O
->	O
x	float
-	O
(	O
vtx1	O
->	O
y	float
-	O
ty	float
)	O
*	O
(	O
vtx0	pointer
->	O
x	float
-	O
vtx1	O
->	O
x	float
)	O
/	O
(	O
vtx0	pointer
->	O
y	float
-	O
vtx1	O
->	O
y	float
)	O
)	O
>=	O
tx	float
)	O
{	O
inside_flag	int
=	O
!	O
inside_flag	int
;	O
}	O
}	O
if	O
(	O
line_flag	int
)	O
return	O
(	O
inside_flag	int
)	O
;	O
line_flag	int
=	O
1	int
;	O
}	O
yflag0	int
=	O
yflag1	int
;	O
vtx0	pointer
=	O
vtx1	O
;	O
v	int
++	O
;	O
vtx1	O
=	O
&	O
pgon	pointer
[	O
v	int
]	O
;	O
}	O
return	O
(	O
inside_flag	int
)	O
;	O
}	O
static	O
MAV_vector	O
Transform_Point	function
(	O
float	O
x	float
,	O
float	O
y	float
,	O
float	O
z	float
)	O
{	O
MAV_matrix	O
*	O
mat	O
=	O
&	O
mav_win_left	O
->	O
pdvMat	O
;	O
MAV_vector	O
out	O
;	O
register	O
float	O
w	float
;	O
out	O
.	O
x	float
=	O
x	float
*	O
mat	O
->	O
mat	O
[	O
0	int
]	O
[	O
0	int
]	O
+	O
y	float
*	O
mat	O
->	O
mat	O
[	O
0	int
]	O
[	O
1	int
]	O
+	O
z	float
*	O
mat	O
->	O
mat	O
[	O
0	int
]	O
[	O
2	int
]	O
+	O
mat	O
->	O
mat	O
[	O
0	int
]	O
[	O
3	int
]	O
;	O
out	O
.	O
y	float
=	O
x	float
*	O
mat	O
->	O
mat	O
[	O
1	int
]	O
[	O
0	int
]	O
+	O
y	float
*	O
mat	O
->	O
mat	O
[	O
1	int
]	O
[	O
1	int
]	O
+	O
z	float
*	O
mat	O
->	O
mat	O
[	O
1	int
]	O
[	O
2	int
]	O
+	O
mat	O
->	O
mat	O
[	O
1	int
]	O
[	O
3	int
]	O
;	O
out	O
.	O
z	float
=	O
x	float
*	O
mat	O
->	O
mat	O
[	O
2	int
]	O
[	O
0	int
]	O
+	O
y	float
*	O
mat	O
->	O
mat	O
[	O
2	int
]	O
[	O
1	int
]	O
+	O
z	float
*	O
mat	O
->	O
mat	O
[	O
2	int
]	O
[	O
2	int
]	O
+	O
mat	O
->	O
mat	O
[	O
2	int
]	O
[	O
3	int
]	O
;	O
w	float
=	O
x	float
*	O
mat	O
->	O
mat	O
[	O
3	int
]	O
[	O
0	int
]	O
+	O
y	float
*	O
mat	O
->	O
mat	O
[	O
3	int
]	O
[	O
1	int
]	O
+	O
z	float
*	O
mat	O
->	O
mat	O
[	O
3	int
]	O
[	O
2	int
]	O
+	O
mat	O
->	O
mat	O
[	O
3	int
]	O
[	O
3	int
]	O
;	O
if	O
(	O
w	float
<	O
0.0	int
)	O
w	float
=	O
-	O
w	float
;	O
out	O
.	O
x	float
/=	O
w	float
;	O
out	O
.	O
y	float
/=	O
w	float
;	O
out	O
.	O
z	float
/=	O
w	float
;	O
return	O
out	O
;	O
}	O
static	O
int	O
CLIPt	function
(	O
float	O
denom	float
,	O
float	O
num	float
,	O
float	O
*	O
tE	pointer
,	O
float	O
*	O
tL	pointer
)	O
{	O
register	O
float	O
t	float
;	O
if	O
(	O
denom	float
>	O
0.0	int
)	O
{	O
t	float
=	O
num	float
/	O
denom	float
;	O
if	O
(	O
t	float
>	O
*	O
tL	pointer
)	O
return	O
0	int
;	O
else	O
if	O
(	O
t	float
>	O
*	O
tE	pointer
)	O
*	O
tE	pointer
=	O
t	float
;	O
}	O
else	O
if	O
(	O
denom	float
<	O
0.0	int
)	O
{	O
t	float
=	O
num	float
/	O
denom	float
;	O
if	O
(	O
t	float
<	O
*	O
tE	pointer
)	O
return	O
0	int
;	O
else	O
if	O
(	O
t	float
<	O
*	O
tL	pointer
)	O
*	O
tL	pointer
=	O
t	float
;	O
}	O
else	O
{	O
if	O
(	O
num	float
>	O
0.0	int
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
Liang_Barsky	function
(	O
MAV_vector	O
*	O
p0	pointer
,	O
MAV_vector	O
*	O
p1	pointer
)	O
{	O
register	O
float	O
dx	float
=	O
p1	pointer
->	O
x	float
-	O
p0	pointer
->	O
x	float
;	O
register	O
float	O
dy	float
=	O
p1	pointer
->	O
y	float
-	O
p0	pointer
->	O
y	float
;	O
float	O
tE	pointer
=	O
0.0	int
;	O
float	O
tL	pointer
=	O
1.0	int
;	O
if	O
(	O
fabs	function
(	O
dx	float
)	O
<	O
1e-6	int
&&	O
fabs	function
(	O
dy	float
)	O
<	O
1e-6	int
&&	O
PointInside	O
(	O
p0	pointer
->	O
x	float
,	O
p0	pointer
->	O
y	float
)	O
)	O
return	O
1	int
;	O
if	O
(	O
CLIPt	function
(	O
dx	float
,	O
-	O
1.0	int
-	O
p0	pointer
->	O
x	float
,	O
&	O
tE	pointer
,	O
&	O
tL	pointer
)	O
)	O
if	O
(	O
CLIPt	function
(	O
-	O
dx	float
,	O
p0	pointer
->	O
x	float
-	O
1.0	int
,	O
&	O
tE	pointer
,	O
&	O
tL	pointer
)	O
)	O
if	O
(	O
CLIPt	function
(	O
dy	float
,	O
-	O
1.0	int
-	O
p0	pointer
->	O
y	float
,	O
&	O
tE	pointer
,	O
&	O
tL	pointer
)	O
)	O
if	O
(	O
CLIPt	function
(	O
-	O
dy	float
,	O
p0	pointer
->	O
y	float
-	O
1.0	int
,	O
&	O
tE	pointer
,	O
&	O
tL	pointer
)	O
)	O
{	O
if	O
(	O
tL	pointer
<	O
1.0	int
)	O
{	O
p1	pointer
->	O
x	float
=	O
p0	pointer
->	O
x	float
+	O
tL	pointer
*	O
dx	float
;	O
p1	pointer
->	O
y	float
=	O
p0	pointer
->	O
y	float
+	O
tL	pointer
*	O
dy	float
;	O
}	O
if	O
(	O
tE	pointer
>	O
0.0	int
)	O
{	O
p0	pointer
->	O
x	float
=	O
p0	pointer
->	O
x	float
+	O
tE	pointer
*	O
dx	float
;	O
p0	pointer
->	O
y	float
=	O
p0	pointer
->	O
y	float
+	O
tE	pointer
*	O
dy	float
;	O
}	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
Build_Occluder	function
(	O
MAV_occluder	O
*	O
occluder	pointer
)	O
{	O
int	O
i	int
;	O
MAV_BB	O
bb	O
;	O
mav_BBAlign	function
(	O
occluder	pointer
->	O
occluder	pointer
,	O
occluder	pointer
->	O
matrix	O
,	O
&	O
bb	O
)	O
;	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
>	O
bb	O
.	O
max	O
.	O
y	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
occluder	pointer
->	O
num_vertices	O
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
<	O
bb	O
.	O
min	O
.	O
y	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
occluder	pointer
->	O
num_vertices	O
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
4	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
6	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
4	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
4	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
4	int
;	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
occluder	pointer
->	O
vertices	O
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
occluder	pointer
->	O
num_vertices	O
=	O
0	int
;	O
return	O
;	O
}	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
occluder	pointer
->	O
num_vertices	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
x	float
=	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
x	float
=	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
.	O
x	float
;	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
y	float
=	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
y	float
=	O
occluder	pointer
->	O
vertices	O
[	O
0	int
]	O
.	O
y	float
;	O
}	O
else	O
{	O
if	O
(	O
occluder	pointer
->	O
vertices	O
[	O
i	int
]	O
.	O
x	float
<	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
x	float
)	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
x	float
=	O
occluder	pointer
->	O
vertices	O
[	O
i	int
]	O
.	O
x	float
;	O
if	O
(	O
occluder	pointer
->	O
vertices	O
[	O
i	int
]	O
.	O
y	float
<	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
y	float
)	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
y	float
=	O
occluder	pointer
->	O
vertices	O
[	O
i	int
]	O
.	O
y	float
;	O
if	O
(	O
occluder	pointer
->	O
vertices	O
[	O
i	int
]	O
.	O
x	float
>	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
x	float
)	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
x	float
=	O
occluder	pointer
->	O
vertices	O
[	O
i	int
]	O
.	O
x	float
;	O
if	O
(	O
occluder	pointer
->	O
vertices	O
[	O
i	int
]	O
.	O
y	float
>	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
y	float
)	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
y	float
=	O
occluder	pointer
->	O
vertices	O
[	O
i	int
]	O
.	O
y	float
;	O
}	O
}	O
if	O
(	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
x	float
<	O
-	O
1.0	int
||	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
x	float
>	O
1.0	int
||	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
y	float
<	O
-	O
1.0	int
||	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
y	float
>	O
1.0	int
)	O
occluder	pointer
->	O
num_vertices	O
=	O
0	int
;	O
if	O
(	O
occluder	pointer
->	O
num_vertices	O
>	O
0	int
)	O
num_occluders	int
++	O
;	O
}	O
static	O
int	O
Build_Candidate	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
Candidate	O
*	O
candidate	int
)	O
{	O
int	O
i	int
;	O
MAV_vector	O
p	pointer
[	O
6	int
]	O
;	O
int	O
num_edges	int
=	O
0	int
;	O
MAV_vector	O
start	O
,	O
end	O
;	O
MAV_BB	O
bb	O
;	O
mav_callbackBBExec	function
(	O
mav_win_left	O
,	O
obj	pointer
,	O
&	O
bb	O
)	O
;	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
>	O
bb	O
.	O
max	O
.	O
y	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
num_edges	int
=	O
4	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	float
<	O
bb	O
.	O
min	O
.	O
y	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
num_edges	int
=	O
4	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
<	O
bb	O
.	O
min	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
num_edges	int
=	O
4	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	float
>	O
bb	O
.	O
max	O
.	O
x	float
)	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
6	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
4	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
5	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
{	O
num_edges	int
=	O
4	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
<	O
bb	O
.	O
min	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
4	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
min	O
.	O
z	float
)	O
;	O
}	O
else	O
if	O
(	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	float
>	O
bb	O
.	O
max	O
.	O
z	float
)	O
{	O
num_edges	int
=	O
4	int
;	O
p	pointer
[	O
0	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
max	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
2	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
min	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
p	pointer
[	O
3	int
]	O
=	O
Transform_Point	function
(	O
bb	O
.	O
min	O
.	O
x	float
,	O
bb	O
.	O
max	O
.	O
y	float
,	O
bb	O
.	O
max	O
.	O
z	float
)	O
;	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
candidate	int
->	O
num_edges	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_edges	int
;	O
i	int
++	O
)	O
{	O
start	O
=	O
p	pointer
[	O
i	int
]	O
;	O
end	O
=	O
(	O
i	int
==	O
num_edges	int
-	O
1	int
)	O
?	O
p	pointer
[	O
0	int
]	O
:	O
p	pointer
[	O
i	int
+	O
1	int
]	O
;	O
if	O
(	O
Liang_Barsky	function
(	O
&	O
start	O
,	O
&	O
end	O
)	O
)	O
{	O
candidate	int
->	O
edges	O
[	O
candidate	int
->	O
num_edges	int
]	O
.	O
start	O
=	O
start	O
;	O
candidate	int
->	O
edges	O
[	O
candidate	int
->	O
num_edges	int
]	O
.	O
end	O
=	O
end	O
;	O
candidate	int
->	O
edges	O
[	O
candidate	int
->	O
num_edges	int
]	O
.	O
visible	O
=	O
1	int
;	O
if	O
(	O
candidate	int
->	O
num_edges	int
==	O
0	int
)	O
{	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
x	float
=	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
x	float
=	O
start	O
.	O
x	float
;	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
y	float
=	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
y	float
=	O
start	O
.	O
y	float
;	O
}	O
else	O
{	O
if	O
(	O
start	O
.	O
x	float
<	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
x	float
)	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
x	float
=	O
start	O
.	O
x	float
;	O
if	O
(	O
start	O
.	O
y	float
<	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
y	float
)	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
y	float
=	O
start	O
.	O
y	float
;	O
if	O
(	O
start	O
.	O
x	float
>	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
x	float
)	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
x	float
=	O
start	O
.	O
x	float
;	O
if	O
(	O
start	O
.	O
y	float
>	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
y	float
)	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
y	float
=	O
start	O
.	O
y	float
;	O
}	O
if	O
(	O
end	O
.	O
x	float
<	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
x	float
)	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
x	float
=	O
end	O
.	O
x	float
;	O
if	O
(	O
end	O
.	O
y	float
<	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
y	float
)	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
y	float
=	O
end	O
.	O
y	float
;	O
if	O
(	O
end	O
.	O
x	float
>	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
x	float
)	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
x	float
=	O
end	O
.	O
x	float
;	O
if	O
(	O
end	O
.	O
y	float
>	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
y	float
)	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
y	float
=	O
end	O
.	O
y	float
;	O
candidate	int
->	O
num_edges	int
++	O
;	O
}	O
}	O
candidate	int
->	O
num_visible_edges	O
=	O
candidate	int
->	O
num_edges	int
;	O
if	O
(	O
candidate	int
->	O
num_edges	int
>	O
0	int
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
int	O
Compare_Intersection_Distances	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
Intersection	O
*	O
s1	O
,	O
*	O
s2	O
;	O
s1	O
=	O
(	O
Intersection	O
*	O
)	O
a	pointer
;	O
s2	O
=	O
(	O
Intersection	O
*	O
)	O
b	pointer
;	O
if	O
(	O
s1	O
->	O
dist	pointer
<	O
s2	O
->	O
dist	pointer
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
s1	O
->	O
dist	pointer
>	O
s2	O
->	O
dist	pointer
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
Clip_Candidate	function
(	O
Candidate	O
*	O
candidate	int
,	O
MAV_occluder	O
*	O
occluder	pointer
)	O
{	O
int	O
i	int
,	O
j	int
,	O
n	int
;	O
int	O
okay	int
;	O
int	O
jp1	int
;	O
MAV_vector	O
p	pointer
;	O
float	O
dist	pointer
;	O
int	O
num_intersections	int
;	O
Intersection	O
intersections	O
[	O
8	int
]	O
;	O
Intersection	O
tmp	O
;	O
int	O
inside	int
;	O
int	O
redo	int
;	O
if	O
(	O
(	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
x	float
<=	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
x	float
)	O
||	O
(	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
x	float
>=	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
x	float
)	O
||	O
(	O
candidate	int
->	O
bound	O
.	O
max	O
.	O
y	float
<=	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
y	float
)	O
||	O
(	O
candidate	int
->	O
bound	O
.	O
min	O
.	O
y	float
>=	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
y	float
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
candidate	int
->	O
num_edges	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
visible	O
)	O
{	O
okay	int
=	O
1	int
;	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
.	O
x	float
>	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
.	O
x	float
)	O
{	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
.	O
x	float
<=	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
x	float
)	O
okay	int
=	O
0	int
;	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
.	O
x	float
>=	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
x	float
)	O
okay	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
.	O
x	float
<=	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
x	float
)	O
okay	int
=	O
0	int
;	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
.	O
x	float
>=	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
x	float
)	O
okay	int
=	O
0	int
;	O
}	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
.	O
y	float
>	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
.	O
y	float
)	O
{	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
.	O
y	float
<=	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
y	float
)	O
okay	int
=	O
0	int
;	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
.	O
y	float
>=	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
y	float
)	O
okay	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
.	O
y	float
<=	O
occluder	pointer
->	O
bound	O
.	O
min	O
.	O
y	float
)	O
okay	int
=	O
0	int
;	O
if	O
(	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
.	O
y	float
>=	O
occluder	pointer
->	O
bound	O
.	O
max	O
.	O
y	float
)	O
okay	int
=	O
0	int
;	O
}	O
if	O
(	O
okay	int
)	O
{	O
num_intersections	int
=	O
2	int
;	O
intersections	O
[	O
0	int
]	O
.	O
p	pointer
=	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
;	O
intersections	O
[	O
0	int
]	O
.	O
dist	pointer
=	O
0.0	int
;	O
intersections	O
[	O
1	int
]	O
.	O
p	pointer
=	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
;	O
intersections	O
[	O
1	int
]	O
.	O
dist	pointer
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
occluder	pointer
->	O
num_vertices	O
;	O
j	int
++	O
)	O
{	O
jp1	int
=	O
(	O
j	int
==	O
occluder	pointer
->	O
num_vertices	O
-	O
1	int
)	O
?	O
0	int
:	O
j	int
+	O
1	int
;	O
if	O
(	O
Lines_Intersect	function
(	O
&	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
,	O
&	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
,	O
&	O
occluder	pointer
->	O
vertices	O
[	O
j	int
]	O
,	O
&	O
occluder	pointer
->	O
vertices	O
[	O
jp1	int
]	O
,	O
&	O
p	pointer
,	O
&	O
dist	pointer
)	O
)	O
{	O
intersections	O
[	O
num_intersections	int
]	O
.	O
p	pointer
=	O
p	pointer
;	O
intersections	O
[	O
num_intersections	int
]	O
.	O
dist	pointer
=	O
dist	pointer
;	O
num_intersections	int
++	O
;	O
}	O
}	O
if	O
(	O
num_intersections	int
==	O
2	int
)	O
{	O
if	O
(	O
Point_In_Polygon	function
(	O
occluder	pointer
->	O
vertices	O
,	O
occluder	pointer
->	O
num_vertices	O
,	O
&	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
)	O
)	O
{	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
visible	O
=	O
0	int
;	O
candidate	int
->	O
num_visible_edges	O
--	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
num_intersections	int
==	O
3	int
)	O
{	O
tmp	O
=	O
intersections	O
[	O
1	int
]	O
;	O
intersections	O
[	O
1	int
]	O
=	O
intersections	O
[	O
2	int
]	O
;	O
intersections	O
[	O
2	int
]	O
=	O
tmp	O
;	O
}	O
else	O
{	O
qsort	function
(	O
(	O
void	O
*	O
)	O
intersections	O
,	O
num_intersections	int
,	O
sizeof	O
(	O
Intersection	O
)	O
,	O
Compare_Intersection_Distances	function
)	O
;	O
}	O
inside	int
=	O
Point_In_Polygon	function
(	O
occluder	pointer
->	O
vertices	O
,	O
occluder	pointer
->	O
num_vertices	O
,	O
&	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
)	O
;	O
redo	int
=	O
0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
num_intersections	int
-	O
1	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
!	O
inside	int
)	O
{	O
if	O
(	O
redo	int
==	O
0	int
)	O
{	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
start	O
=	O
intersections	O
[	O
n	int
]	O
.	O
p	pointer
;	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
end	O
=	O
intersections	O
[	O
n	int
+	O
1	int
]	O
.	O
p	pointer
;	O
redo	int
=	O
1	int
;	O
}	O
else	O
{	O
candidate	int
->	O
edges	O
[	O
candidate	int
->	O
num_edges	int
]	O
.	O
start	O
=	O
intersections	O
[	O
n	int
]	O
.	O
p	pointer
;	O
candidate	int
->	O
edges	O
[	O
candidate	int
->	O
num_edges	int
]	O
.	O
end	O
=	O
intersections	O
[	O
n	int
+	O
1	int
]	O
.	O
p	pointer
;	O
candidate	int
->	O
edges	O
[	O
candidate	int
->	O
num_edges	int
]	O
.	O
visible	O
=	O
1	int
;	O
candidate	int
->	O
num_edges	int
++	O
;	O
candidate	int
->	O
num_visible_edges	O
++	O
;	O
}	O
}	O
inside	int
=	O
!	O
inside	int
;	O
}	O
if	O
(	O
!	O
redo	int
)	O
{	O
candidate	int
->	O
edges	O
[	O
i	int
]	O
.	O
visible	O
=	O
0	int
;	O
candidate	int
->	O
num_visible_edges	O
--	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
int	O
Cull_Object	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
int	O
this_id	int
)	O
{	O
int	O
i	int
;	O
MAV_occluder	O
*	O
occluder	pointer
;	O
if	O
(	O
num_occluders	int
>	O
0	int
)	O
{	O
if	O
(	O
Build_Candidate	function
(	O
obj	pointer
,	O
&	O
candidate	int
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
this_id	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
->	O
the_class	O
==	O
mav_class_occluder	pointer
)	O
{	O
occluder	pointer
=	O
(	O
MAV_occluder	O
*	O
)	O
visible_objects	pointer
[	O
i	int
]	O
.	O
obj	pointer
->	O
the_data	O
;	O
Clip_Candidate	function
(	O
&	O
candidate	int
,	O
occluder	pointer
)	O
;	O
if	O
(	O
candidate	int
.	O
num_visible_edges	O
==	O
0	int
)	O
return	O
0	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
obj	pointer
->	O
the_class	O
==	O
mav_class_occluder	pointer
)	O
Build_Occluder	function
(	O
(	O
MAV_occluder	O
*	O
)	O
obj	pointer
->	O
the_data	O
)	O
;	O
return	O
1	int
;	O
}	O
