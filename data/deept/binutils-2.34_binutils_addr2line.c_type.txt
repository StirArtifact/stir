static	O
bfd_boolean	int
unwind_inlines	int
;	O
static	O
bfd_boolean	int
with_addresses	int
;	O
static	O
bfd_boolean	int
with_functions	int
;	O
static	O
bfd_boolean	int
do_demangle	int
;	O
static	O
bfd_boolean	int
pretty_print	int
;	O
static	O
bfd_boolean	int
base_names	int
;	O
static	O
int	O
demangle_flags	int
=	O
DMGL_PARAMS	O
|	O
DMGL_ANSI	O
;	O
static	O
int	O
naddr	int
;	O
static	O
char	O
*	O
*	O
addr	pointer
;	O
static	O
asymbol	struct
*	O
*	O
syms	pointer
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"addresses"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"basenames"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"demangle"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"exe"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"functions"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"inlines"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"pretty-print"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"recurse-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"recursion-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"no-recurse-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"no-recursion-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"section"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'j'	O
}	O
,	O
{	O
"target"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'H'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
0	int
,	O
no_argument	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
,	O
int	O
)	O
;	O
static	O
void	O
slurp_symtab	function
(	O
bfd	struct
*	O
)	O
;	O
static	O
void	O
find_address_in_section	function
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
find_offset_in_section	function
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
)	O
;	O
static	O
void	O
translate_addresses	function
(	O
bfd	struct
*	O
,	O
asection	struct
*	O
)	O
;	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
status	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Usage: %s [option(s)] [addr(s)]\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" Convert addresses into line number/file name pairs.\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" If no addresses are specified on the command line, they will be read from stdin\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
" The options are:\n  @<file>                Read options from <file>\n  -a --addresses         Show addresses\n  -b --target=<bfdname>  Set the binary file format\n  -e --exe=<executable>  Set the input file name (default is a.out)\n  -i --inlines           Unwind inlined functions\n  -j --section=<name>    Read section-relative offsets instead of addresses\n  -p --pretty-print      Make the output easier to read for humans\n  -s --basenames         Strip directory names\n  -f --functions         Show function names\n  -C --demangle[=style]  Demangle function names\n  -R --recurse-limit     Enable a limit on recursion whilst demangling.  [Default]\n  -r --no-recurse-limit  Disable a limit on recursion whilst demangling\n  -h --help              Display this information\n  -v --version           Display the program's version\n\n"	pointer
)	O
)	O
;	O
list_supported_targets	function
(	O
program_name	pointer
,	O
stream	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
&&	O
status	int
==	O
0	int
)	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Report bugs to %s\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
void	O
slurp_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
long	O
storage	long
;	O
long	O
symcount	int
;	O
bfd_boolean	int
dynamic	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
bfd_get_file_flags	function
(	O
abfd	pointer
)	O
&	O
HAS_SYMS	int
)	O
==	O
0	int
)	O
return	O
;	O
storage	long
=	O
bfd_get_symtab_upper_bound	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
storage	long
==	O
0	int
)	O
{	O
storage	long
=	O
bfd_get_dynamic_symtab_upper_bound	O
(	O
abfd	pointer
)	O
;	O
dynamic	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
storage	long
<	O
0	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
syms	pointer
=	O
(	O
asymbol	struct
*	O
*	O
)	O
xmalloc	function
(	O
storage	long
)	O
;	O
if	O
(	O
dynamic	int
)	O
symcount	int
=	O
bfd_canonicalize_dynamic_symtab	O
(	O
abfd	pointer
,	O
syms	pointer
)	O
;	O
else	O
symcount	int
=	O
bfd_canonicalize_symtab	O
(	O
abfd	pointer
,	O
syms	pointer
)	O
;	O
if	O
(	O
symcount	int
<	O
0	int
)	O
bfd_fatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
symcount	int
==	O
0	int
&&	O
!	O
dynamic	int
&&	O
(	O
storage	long
=	O
bfd_get_dynamic_symtab_upper_bound	O
(	O
abfd	pointer
)	O
)	O
>	O
0	int
)	O
{	O
free	function
(	O
syms	pointer
)	O
;	O
syms	pointer
=	O
xmalloc	function
(	O
storage	long
)	O
;	O
symcount	int
=	O
bfd_canonicalize_dynamic_symtab	O
(	O
abfd	pointer
,	O
syms	pointer
)	O
;	O
}	O
if	O
(	O
symcount	int
<=	O
0	int
)	O
{	O
free	function
(	O
syms	pointer
)	O
;	O
syms	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
bfd_vma	long
pc	long
;	O
static	O
const	O
char	O
*	O
filename	pointer
;	O
static	O
const	O
char	O
*	O
functionname	pointer
;	O
static	O
unsigned	O
int	O
line	int
;	O
static	O
unsigned	O
int	O
discriminator	int
;	O
static	O
bfd_boolean	int
found	int
;	O
static	O
void	O
find_address_in_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
,	O
void	O
*	O
data	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
bfd_vma	long
vma	long
;	O
bfd_size_type	long
size	int
;	O
if	O
(	O
found	int
)	O
return	O
;	O
if	O
(	O
(	O
bfd_section_flags	function
(	O
section	pointer
)	O
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
return	O
;	O
vma	long
=	O
bfd_section_vma	function
(	O
section	pointer
)	O
;	O
if	O
(	O
pc	long
<	O
vma	long
)	O
return	O
;	O
size	int
=	O
bfd_section_size	function
(	O
section	pointer
)	O
;	O
if	O
(	O
pc	long
>=	O
vma	long
+	O
size	int
)	O
return	O
;	O
found	int
=	O
bfd_find_nearest_line_discriminator	O
(	O
abfd	pointer
,	O
section	pointer
,	O
syms	pointer
,	O
pc	long
-	O
vma	long
,	O
&	O
filename	pointer
,	O
&	O
functionname	pointer
,	O
&	O
line	int
,	O
&	O
discriminator	int
)	O
;	O
}	O
static	O
void	O
find_offset_in_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
)	O
{	O
bfd_size_type	long
size	int
;	O
if	O
(	O
found	int
)	O
return	O
;	O
if	O
(	O
(	O
bfd_section_flags	function
(	O
section	pointer
)	O
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
return	O
;	O
size	int
=	O
bfd_section_size	function
(	O
section	pointer
)	O
;	O
if	O
(	O
pc	long
>=	O
size	int
)	O
return	O
;	O
found	int
=	O
bfd_find_nearest_line_discriminator	O
(	O
abfd	pointer
,	O
section	pointer
,	O
syms	pointer
,	O
pc	long
,	O
&	O
filename	pointer
,	O
&	O
functionname	pointer
,	O
&	O
line	int
,	O
&	O
discriminator	int
)	O
;	O
}	O
static	O
void	O
translate_addresses	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
)	O
{	O
int	O
read_stdin	int
=	O
(	O
naddr	int
==	O
0	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
read_stdin	int
)	O
{	O
char	O
addr_hex	array
[	O
100	int
]	O
;	O
if	O
(	O
fgets	function
(	O
addr_hex	array
,	O
sizeof	O
addr_hex	array
,	O
stdin	pointer
)	O
==	O
NULL	O
)	O
break	O
;	O
pc	long
=	O
bfd_scan_vma	function
(	O
addr_hex	array
,	O
NULL	O
,	O
16	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
naddr	int
<=	O
0	int
)	O
break	O
;	O
--	O
naddr	int
;	O
pc	long
=	O
bfd_scan_vma	function
(	O
*	O
addr	pointer
++	O
,	O
NULL	O
,	O
16	int
)	O
;	O
}	O
if	O
(	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
==	O
bfd_target_elf_flavour	int
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
bfd_vma	long
sign	long
=	O
(	O
bfd_vma	long
)	O
1	int
<<	O
(	O
bed	pointer
->	O
s	pointer
->	O
arch_size	char
-	O
1	int
)	O
;	O
pc	long
&=	O
(	O
sign	long
<<	O
1	int
)	O
-	O
1	int
;	O
if	O
(	O
bed	pointer
->	O
sign_extend_vma	int
)	O
pc	long
=	O
(	O
pc	long
^	O
sign	long
)	O
-	O
sign	long
;	O
}	O
if	O
(	O
with_addresses	int
)	O
{	O
printf	function
(	O
"0x"	pointer
)	O
;	O
bfd_printf_vma	O
(	O
abfd	pointer
,	O
pc	long
)	O
;	O
if	O
(	O
pretty_print	int
)	O
printf	function
(	O
": "	pointer
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
found	int
=	O
FALSE	int
;	O
if	O
(	O
section	pointer
)	O
find_offset_in_section	function
(	O
abfd	pointer
,	O
section	pointer
)	O
;	O
else	O
bfd_map_over_sections	function
(	O
abfd	pointer
,	O
find_address_in_section	function
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
found	int
)	O
{	O
if	O
(	O
with_functions	int
)	O
{	O
if	O
(	O
pretty_print	int
)	O
printf	function
(	O
"?? "	pointer
)	O
;	O
else	O
printf	function
(	O
"??\n"	pointer
)	O
;	O
}	O
printf	function
(	O
"??:0\n"	pointer
)	O
;	O
}	O
else	O
{	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
with_functions	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
char	O
*	O
alloc	pointer
=	O
NULL	O
;	O
name	pointer
=	O
functionname	pointer
;	O
if	O
(	O
name	pointer
==	O
NULL	O
||	O
*	O
name	pointer
==	O
'\0'	O
)	O
name	pointer
=	O
"??"	pointer
;	O
else	O
if	O
(	O
do_demangle	int
)	O
{	O
alloc	pointer
=	O
bfd_demangle	function
(	O
abfd	pointer
,	O
name	pointer
,	O
demangle_flags	int
)	O
;	O
if	O
(	O
alloc	pointer
!=	O
NULL	O
)	O
name	pointer
=	O
alloc	pointer
;	O
}	O
printf	function
(	O
"%s"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
pretty_print	int
)	O
printf	function
(	O
_	O
(	O
" at "	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
alloc	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc	pointer
)	O
;	O
}	O
if	O
(	O
base_names	int
&&	O
filename	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
h	pointer
;	O
h	pointer
=	O
strrchr	function
(	O
filename	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
filename	pointer
=	O
h	pointer
+	O
1	int
;	O
}	O
printf	function
(	O
"%s:"	pointer
,	O
filename	pointer
?	O
filename	pointer
:	O
"??"	pointer
)	O
;	O
if	O
(	O
line	int
!=	O
0	int
)	O
{	O
if	O
(	O
discriminator	int
!=	O
0	int
)	O
printf	function
(	O
"%u (discriminator %u)\n"	pointer
,	O
line	int
,	O
discriminator	int
)	O
;	O
else	O
printf	function
(	O
"%u\n"	pointer
,	O
line	int
)	O
;	O
}	O
else	O
printf	function
(	O
"?\n"	pointer
)	O
;	O
if	O
(	O
!	O
unwind_inlines	int
)	O
found	int
=	O
FALSE	int
;	O
else	O
found	int
=	O
bfd_find_inliner_info	O
(	O
abfd	pointer
,	O
&	O
filename	pointer
,	O
&	O
functionname	pointer
,	O
&	O
line	int
)	O
;	O
if	O
(	O
!	O
found	int
)	O
break	O
;	O
if	O
(	O
pretty_print	int
)	O
printf	function
(	O
_	O
(	O
" (inlined by) "	pointer
)	O
)	O
;	O
}	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
}	O
static	O
int	O
process_file	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
const	O
char	O
*	O
section_name	pointer
,	O
const	O
char	O
*	O
target	pointer
)	O
{	O
bfd	struct
*	O
abfd	pointer
;	O
asection	struct
*	O
section	pointer
;	O
char	O
*	O
*	O
matching	pointer
;	O
if	O
(	O
get_file_size	function
(	O
file_name	pointer
)	O
<	O
1	int
)	O
return	O
1	int
;	O
abfd	pointer
=	O
bfd_openr	function
(	O
file_name	pointer
,	O
target	pointer
)	O
;	O
if	O
(	O
abfd	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
file_name	pointer
)	O
;	O
abfd	pointer
->	O
flags	int
|=	O
BFD_DECOMPRESS	int
;	O
if	O
(	O
bfd_check_format	function
(	O
abfd	pointer
,	O
bfd_archive	int
)	O
)	O
fatal	function
(	O
_	O
(	O
"%s: cannot get addresses from archive"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
if	O
(	O
!	O
bfd_check_format_matches	function
(	O
abfd	pointer
,	O
bfd_object	int
,	O
&	O
matching	pointer
)	O
)	O
{	O
bfd_nonfatal	function
(	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_file_ambiguously_recognized	int
)	O
{	O
list_matching_formats	function
(	O
matching	pointer
)	O
;	O
free	function
(	O
matching	pointer
)	O
;	O
}	O
xexit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
section_name	pointer
!=	O
NULL	O
)	O
{	O
section	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
section_name	pointer
)	O
;	O
if	O
(	O
section	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"%s: cannot find section %s"	pointer
)	O
,	O
file_name	pointer
,	O
section_name	pointer
)	O
;	O
}	O
else	O
section	pointer
=	O
NULL	O
;	O
slurp_symtab	function
(	O
abfd	pointer
)	O
;	O
translate_addresses	function
(	O
abfd	pointer
,	O
section	pointer
)	O
;	O
if	O
(	O
syms	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
syms	pointer
)	O
;	O
syms	pointer
=	O
NULL	O
;	O
}	O
bfd_close	function
(	O
abfd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
file_name	pointer
;	O
const	O
char	O
*	O
section_name	pointer
;	O
char	O
*	O
target	pointer
;	O
int	O
c	struct
;	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
program_name	pointer
=	O
*	O
argv	pointer
;	O
xmalloc_set_program_name	function
(	O
program_name	pointer
)	O
;	O
bfd_set_error_program_name	function
(	O
program_name	pointer
)	O
;	O
expandargv	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
bfd_init	function
(	O
)	O
!=	O
BFD_INIT_MAGIC	O
)	O
fatal	function
(	O
_	O
(	O
"fatal error: libbfd ABI mismatch"	pointer
)	O
)	O
;	O
set_default_bfd_target	function
(	O
)	O
;	O
file_name	pointer
=	O
NULL	O
;	O
section_name	pointer
=	O
NULL	O
;	O
target	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
c	struct
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"ab:Ce:rRsfHhij:pVv"	pointer
,	O
long_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	struct
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'a'	O
:	O
with_addresses	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'b'	O
:	O
target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'C'	O
:	O
do_demangle	int
=	O
TRUE	int
;	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
{	O
enum	O
demangling_styles	enum
style	enum
;	O
style	enum
=	O
cplus_demangle_name_to_style	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
style	enum
==	O
unknown_demangling	int
)	O
fatal	function
(	O
_	O
(	O
"unknown demangling style `%s'"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
cplus_demangle_set_style	function
(	O
style	enum
)	O
;	O
}	O
break	O
;	O
case	O
'r'	O
:	O
demangle_flags	int
|=	O
DMGL_NO_RECURSE_LIMIT	O
;	O
break	O
;	O
case	O
'R'	O
:	O
demangle_flags	int
&=	O
~	O
DMGL_NO_RECURSE_LIMIT	O
;	O
break	O
;	O
case	O
'e'	O
:	O
file_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
's'	O
:	O
base_names	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'f'	O
:	O
with_functions	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'p'	O
:	O
pretty_print	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'v'	O
:	O
case	O
'V'	O
:	O
print_version	function
(	O
"addr2line"	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
'H'	O
:	O
usage	function
(	O
stdout	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
unwind_inlines	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'j'	O
:	O
section_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
file_name	pointer
==	O
NULL	O
)	O
file_name	pointer
=	O
"a.out"	pointer
;	O
addr	pointer
=	O
argv	pointer
+	O
optind	int
;	O
naddr	int
=	O
argc	int
-	O
optind	int
;	O
return	O
process_file	function
(	O
file_name	pointer
,	O
section_name	pointer
,	O
target	pointer
)	O
;	O
}	O
