int	O
iconveh_open	O
(	O
const	O
char	O
*	O
to_codeset	O
,	O
const	O
char	O
*	O
from_codeset	O
,	O
iconveh_t	O
*	O
cdp	O
)	O
{	O
iconv_t	O
cd	O
;	O
iconv_t	O
cd1	O
;	O
iconv_t	O
cd2	O
;	O
cd	O
=	O
iconv_open	O
(	O
to_codeset	O
,	O
from_codeset	O
)	O
;	O
if	O
(	O
STRCASEEQ	O
(	O
from_codeset	O
,	O
"UTF-8"	pointer
,	O
'U'	O
,	O
'T'	O
,	O
'F'	O
,	O
'-'	O
,	O
'8'	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
)	O
cd1	O
=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
;	O
else	O
{	O
cd1	O
=	O
iconv_open	O
(	O
"UTF-8"	pointer
,	O
from_codeset	O
)	O
;	O
if	O
(	O
cd1	O
==	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
if	O
(	O
cd	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	O
(	O
cd	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
STRCASEEQ	O
(	O
to_codeset	O
,	O
"UTF-8"	pointer
,	O
'U'	O
,	O
'T'	O
,	O
'F'	O
,	O
'-'	O
,	O
'8'	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
)	O
cd2	O
=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
;	O
else	O
{	O
cd2	O
=	O
iconv_open	O
(	O
to_codeset	O
,	O
"UTF-8"	pointer
)	O
;	O
if	O
(	O
cd2	O
==	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
if	O
(	O
cd1	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	O
(	O
cd1	O
)	O
;	O
if	O
(	O
cd	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	O
(	O
cd	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
cdp	O
->	O
cd	O
=	O
cd	O
;	O
cdp	O
->	O
cd1	O
=	O
cd1	O
;	O
cdp	O
->	O
cd2	O
=	O
cd2	O
;	O
return	O
0	int
;	O
}	O
int	O
iconveh_close	O
(	O
const	O
iconveh_t	O
*	O
cd	O
)	O
{	O
if	O
(	O
cd	O
->	O
cd2	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
iconv_close	O
(	O
cd	O
->	O
cd2	O
)	O
<	O
0	int
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
if	O
(	O
cd	O
->	O
cd1	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	O
(	O
cd	O
->	O
cd1	O
)	O
;	O
if	O
(	O
cd	O
->	O
cd	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	O
(	O
cd	O
->	O
cd	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
cd	O
->	O
cd1	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
iconv_close	O
(	O
cd	O
->	O
cd1	O
)	O
<	O
0	int
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
if	O
(	O
cd	O
->	O
cd	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	O
(	O
cd	O
->	O
cd	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
cd	O
->	O
cd	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
iconv_close	O
(	O
cd	O
->	O
cd	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
size_t	O
iconv_carefully	O
(	O
iconv_t	O
cd	O
,	O
const	O
char	O
*	O
*	O
inbuf	O
,	O
size_t	O
*	O
inbytesleft	O
,	O
char	O
*	O
*	O
outbuf	O
,	O
size_t	O
*	O
outbytesleft	O
,	O
bool	O
*	O
incremented	O
)	O
{	O
const	O
char	O
*	O
inptr	O
=	O
*	O
inbuf	O
;	O
const	O
char	O
*	O
inptr_end	O
=	O
inptr	O
+	O
*	O
inbytesleft	O
;	O
char	O
*	O
outptr	O
=	O
*	O
outbuf	O
;	O
size_t	O
outsize	O
=	O
*	O
outbytesleft	O
;	O
const	O
char	O
*	O
inptr_before	O
;	O
size_t	O
res	O
;	O
do	O
{	O
size_t	O
insize	O
;	O
inptr_before	O
=	O
inptr	O
;	O
res	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
for	O
(	O
insize	O
=	O
1	int
;	O
inptr	O
+	O
insize	O
<=	O
inptr_end	O
;	O
insize	O
++	O
)	O
{	O
res	O
=	O
iconv	O
(	O
cd	O
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	O
,	O
&	O
insize	O
,	O
&	O
outptr	O
,	O
&	O
outsize	O
)	O
;	O
if	O
(	O
!	O
(	O
res	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
EINVAL	O
)	O
)	O
break	O
;	O
if	O
(	O
inptr	O
>	O
inptr_before	O
)	O
{	O
res	O
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
res	O
==	O
0	int
)	O
{	O
*	O
outbuf	O
=	O
outptr	O
;	O
*	O
outbytesleft	O
=	O
outsize	O
;	O
}	O
}	O
while	O
(	O
res	O
==	O
0	int
&&	O
inptr	O
<	O
inptr_end	O
)	O
;	O
*	O
inbuf	O
=	O
inptr	O
;	O
*	O
inbytesleft	O
=	O
inptr_end	O
-	O
inptr	O
;	O
if	O
(	O
res	O
!=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
res	O
>	O
0	int
)	O
{	O
*	O
incremented	O
=	O
(	O
inptr	O
>	O
inptr_before	O
)	O
;	O
errno	O
=	O
EILSEQ	O
;	O
return	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
*	O
incremented	O
=	O
false	O
;	O
return	O
res	O
;	O
}	O
}	O
static	O
size_t	O
iconv_carefully_1	O
(	O
iconv_t	O
cd	O
,	O
const	O
char	O
*	O
*	O
inbuf	O
,	O
size_t	O
*	O
inbytesleft	O
,	O
char	O
*	O
*	O
outbuf	O
,	O
size_t	O
*	O
outbytesleft	O
,	O
bool	O
*	O
incremented	O
)	O
{	O
const	O
char	O
*	O
inptr_before	O
=	O
*	O
inbuf	O
;	O
const	O
char	O
*	O
inptr	O
=	O
inptr_before	O
;	O
const	O
char	O
*	O
inptr_end	O
=	O
inptr_before	O
+	O
*	O
inbytesleft	O
;	O
char	O
*	O
outptr	O
=	O
*	O
outbuf	O
;	O
size_t	O
outsize	O
=	O
*	O
outbytesleft	O
;	O
size_t	O
res	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
size_t	O
insize	O
;	O
for	O
(	O
insize	O
=	O
1	int
;	O
inptr_before	O
+	O
insize	O
<=	O
inptr_end	O
;	O
insize	O
++	O
)	O
{	O
inptr	O
=	O
inptr_before	O
;	O
res	O
=	O
iconv	O
(	O
cd	O
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	O
,	O
&	O
insize	O
,	O
&	O
outptr	O
,	O
&	O
outsize	O
)	O
;	O
if	O
(	O
!	O
(	O
res	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
EINVAL	O
)	O
)	O
break	O
;	O
if	O
(	O
inptr	O
>	O
inptr_before	O
)	O
{	O
res	O
=	O
0	int
;	O
break	O
;	O
}	O
}	O
*	O
inbuf	O
=	O
inptr	O
;	O
*	O
inbytesleft	O
=	O
inptr_end	O
-	O
inptr	O
;	O
if	O
(	O
res	O
!=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
res	O
>	O
0	int
)	O
{	O
*	O
incremented	O
=	O
(	O
inptr	O
>	O
inptr_before	O
)	O
;	O
errno	O
=	O
EILSEQ	O
;	O
return	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
res	O
!=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
*	O
outbuf	O
=	O
outptr	O
;	O
*	O
outbytesleft	O
=	O
outsize	O
;	O
}	O
*	O
incremented	O
=	O
false	O
;	O
return	O
res	O
;	O
}	O
static	O
size_t	O
utf8conv_carefully	O
(	O
bool	O
one_character_only	O
,	O
const	O
char	O
*	O
*	O
inbuf	O
,	O
size_t	O
*	O
inbytesleft	O
,	O
char	O
*	O
*	O
outbuf	O
,	O
size_t	O
*	O
outbytesleft	O
,	O
bool	O
*	O
incremented	O
)	O
{	O
const	O
char	O
*	O
inptr	O
=	O
*	O
inbuf	O
;	O
size_t	O
insize	O
=	O
*	O
inbytesleft	O
;	O
char	O
*	O
outptr	O
=	O
*	O
outbuf	O
;	O
size_t	O
outsize	O
=	O
*	O
outbytesleft	O
;	O
size_t	O
res	O
;	O
res	O
=	O
0	int
;	O
do	O
{	O
ucs4_t	O
uc	O
;	O
int	O
n	O
;	O
int	O
m	O
;	O
n	O
=	O
u8_mbtoucr	O
(	O
&	O
uc	O
,	O
(	O
const	O
uint8_t	O
*	O
)	O
inptr	O
,	O
insize	O
)	O
;	O
if	O
(	O
n	O
<	O
0	int
)	O
{	O
errno	O
=	O
(	O
n	O
==	O
-	O
2	int
?	O
EINVAL	O
:	O
EILSEQ	O
)	O
;	O
n	O
=	O
u8_mbtouc	O
(	O
&	O
uc	O
,	O
(	O
const	O
uint8_t	O
*	O
)	O
inptr	O
,	O
insize	O
)	O
;	O
inptr	O
+=	O
n	O
;	O
insize	O
-=	O
n	O
;	O
res	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
*	O
incremented	O
=	O
true	O
;	O
break	O
;	O
}	O
if	O
(	O
outsize	O
==	O
0	int
)	O
{	O
errno	O
=	O
E2BIG	O
;	O
res	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
*	O
incremented	O
=	O
false	O
;	O
break	O
;	O
}	O
m	O
=	O
u8_uctomb	O
(	O
(	O
uint8_t	O
*	O
)	O
outptr	O
,	O
uc	O
,	O
outsize	O
)	O
;	O
if	O
(	O
m	O
==	O
-	O
2	int
)	O
{	O
errno	O
=	O
E2BIG	O
;	O
res	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
*	O
incremented	O
=	O
false	O
;	O
break	O
;	O
}	O
inptr	O
+=	O
n	O
;	O
insize	O
-=	O
n	O
;	O
if	O
(	O
m	O
==	O
-	O
1	int
)	O
{	O
errno	O
=	O
EILSEQ	O
;	O
res	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
*	O
incremented	O
=	O
true	O
;	O
break	O
;	O
}	O
outptr	O
+=	O
m	O
;	O
outsize	O
-=	O
m	O
;	O
}	O
while	O
(	O
!	O
one_character_only	O
&&	O
insize	O
>	O
0	int
)	O
;	O
*	O
inbuf	O
=	O
inptr	O
;	O
*	O
inbytesleft	O
=	O
insize	O
;	O
*	O
outbuf	O
=	O
outptr	O
;	O
*	O
outbytesleft	O
=	O
outsize	O
;	O
return	O
res	O
;	O
}	O
static	O
int	O
mem_cd_iconveh_internal	O
(	O
const	O
char	O
*	O
src	O
,	O
size_t	O
srclen	O
,	O
iconv_t	O
cd	O
,	O
iconv_t	O
cd1	O
,	O
iconv_t	O
cd2	O
,	O
enum	O
iconv_ilseq_handler	O
handler	O
,	O
size_t	O
extra_alloc	O
,	O
size_t	O
*	O
offsets	O
,	O
char	O
*	O
*	O
resultp	O
,	O
size_t	O
*	O
lengthp	O
)	O
{	O
union	O
{	O
unsigned	O
int	O
align	O
;	O
char	O
buf	O
[	O
tmpbufsize	int
]	O
;	O
}	O
tmp	O
;	O
char	O
*	O
initial_result	O
;	O
char	O
*	O
result	O
;	O
size_t	O
allocated	O
;	O
size_t	O
length	O
;	O
size_t	O
last_length	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
*	O
resultp	O
!=	O
NULL	O
&&	O
*	O
lengthp	O
>=	O
sizeof	O
(	O
tmpbuf	O
)	O
)	O
{	O
initial_result	O
=	O
*	O
resultp	O
;	O
allocated	O
=	O
*	O
lengthp	O
;	O
}	O
else	O
{	O
initial_result	O
=	O
tmpbuf	O
;	O
allocated	O
=	O
sizeof	O
(	O
tmpbuf	O
)	O
;	O
}	O
result	O
=	O
initial_result	O
;	O
if	O
(	O
cd	O
==	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
goto	O
indirectly	O
;	O
if	O
(	O
offsets	O
!=	O
NULL	O
)	O
{	O
size_t	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
srclen	O
;	O
i	O
++	O
)	O
offsets	O
[	O
i	O
]	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
last_length	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
}	O
length	O
=	O
0	int
;	O
{	O
const	O
char	O
*	O
inptr	O
=	O
src	O
;	O
size_t	O
insize	O
=	O
srclen	O
;	O
iconv	O
(	O
cd	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
insize	O
>	O
0	int
)	O
{	O
char	O
*	O
outptr	O
=	O
result	O
+	O
length	O
;	O
size_t	O
outsize	O
=	O
allocated	O
-	O
extra_alloc	O
-	O
length	O
;	O
bool	O
incremented	O
;	O
size_t	O
res	O
;	O
bool	O
grow	O
;	O
if	O
(	O
offsets	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
length	O
!=	O
last_length	O
)	O
{	O
offsets	O
[	O
inptr	O
-	O
src	O
]	O
=	O
length	O
;	O
last_length	O
=	O
length	O
;	O
}	O
res	O
=	O
iconv_carefully_1	O
(	O
cd	O
,	O
&	O
inptr	O
,	O
&	O
insize	O
,	O
&	O
outptr	O
,	O
&	O
outsize	O
,	O
&	O
incremented	O
)	O
;	O
}	O
else	O
res	O
=	O
iconv_carefully	O
(	O
cd	O
,	O
&	O
inptr	O
,	O
&	O
insize	O
,	O
&	O
outptr	O
,	O
&	O
outsize	O
,	O
&	O
incremented	O
)	O
;	O
length	O
=	O
outptr	O
-	O
result	O
;	O
grow	O
=	O
(	O
length	O
+	O
extra_alloc	O
>	O
allocated	O
/	O
2	int
)	O
;	O
if	O
(	O
res	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
E2BIG	O
)	O
grow	O
=	O
true	O
;	O
else	O
if	O
(	O
errno	O
==	O
EINVAL	O
)	O
break	O
;	O
else	O
if	O
(	O
errno	O
==	O
EILSEQ	O
&&	O
handler	O
!=	O
iconveh_error	O
)	O
{	O
if	O
(	O
cd2	O
==	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
length	O
+	O
1	int
+	O
extra_alloc	O
>	O
allocated	O
)	O
{	O
char	O
*	O
memory	O
;	O
allocated	O
=	O
2	int
*	O
allocated	O
;	O
if	O
(	O
length	O
+	O
1	int
+	O
extra_alloc	O
>	O
allocated	O
)	O
abort	O
(	O
)	O
;	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memory	O
=	O
(	O
char	O
*	O
)	O
malloc	O
(	O
allocated	O
)	O
;	O
else	O
memory	O
=	O
(	O
char	O
*	O
)	O
realloc	O
(	O
result	O
,	O
allocated	O
)	O
;	O
if	O
(	O
memory	O
==	O
NULL	O
)	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memcpy	O
(	O
memory	O
,	O
initial_result	O
,	O
length	O
)	O
;	O
result	O
=	O
memory	O
;	O
grow	O
=	O
false	O
;	O
}	O
if	O
(	O
!	O
incremented	O
)	O
{	O
if	O
(	O
insize	O
==	O
0	int
)	O
abort	O
(	O
)	O
;	O
inptr	O
++	O
;	O
insize	O
--	O
;	O
}	O
result	O
[	O
length	O
]	O
=	O
'?'	O
;	O
length	O
++	O
;	O
}	O
else	O
goto	O
indirectly	O
;	O
}	O
else	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
insize	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
grow	O
)	O
{	O
char	O
*	O
memory	O
;	O
allocated	O
=	O
2	int
*	O
allocated	O
;	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memory	O
=	O
(	O
char	O
*	O
)	O
malloc	O
(	O
allocated	O
)	O
;	O
else	O
memory	O
=	O
(	O
char	O
*	O
)	O
realloc	O
(	O
result	O
,	O
allocated	O
)	O
;	O
if	O
(	O
memory	O
==	O
NULL	O
)	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memcpy	O
(	O
memory	O
,	O
initial_result	O
,	O
length	O
)	O
;	O
result	O
=	O
memory	O
;	O
}	O
}	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
outptr	O
=	O
result	O
+	O
length	O
;	O
size_t	O
outsize	O
=	O
allocated	O
-	O
extra_alloc	O
-	O
length	O
;	O
size_t	O
res	O
;	O
res	O
=	O
iconv	O
(	O
cd	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
outptr	O
,	O
&	O
outsize	O
)	O
;	O
length	O
=	O
outptr	O
-	O
result	O
;	O
if	O
(	O
res	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
E2BIG	O
)	O
{	O
char	O
*	O
memory	O
;	O
allocated	O
=	O
2	int
*	O
allocated	O
;	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memory	O
=	O
(	O
char	O
*	O
)	O
malloc	O
(	O
allocated	O
)	O
;	O
else	O
memory	O
=	O
(	O
char	O
*	O
)	O
realloc	O
(	O
result	O
,	O
allocated	O
)	O
;	O
if	O
(	O
memory	O
==	O
NULL	O
)	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memcpy	O
(	O
memory	O
,	O
initial_result	O
,	O
length	O
)	O
;	O
result	O
=	O
memory	O
;	O
}	O
else	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
break	O
;	O
}	O
goto	O
done	O
;	O
indirectly	O
:	O
if	O
(	O
offsets	O
!=	O
NULL	O
)	O
{	O
size_t	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
srclen	O
;	O
i	O
++	O
)	O
offsets	O
[	O
i	O
]	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
last_length	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
}	O
length	O
=	O
0	int
;	O
{	O
const	O
bool	O
slowly	O
=	O
(	O
offsets	O
!=	O
NULL	O
||	O
handler	O
==	O
iconveh_error	O
)	O
;	O
char	O
utf8buf	O
[	O
utf8bufsize	int
+	O
1	int
]	O
;	O
size_t	O
utf8len	O
=	O
0	int
;	O
const	O
char	O
*	O
in1ptr	O
=	O
src	O
;	O
size_t	O
in1size	O
=	O
srclen	O
;	O
bool	O
do_final_flush1	O
=	O
true	O
;	O
bool	O
do_final_flush2	O
=	O
true	O
;	O
if	O
(	O
cd1	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
iconv	O
(	O
cd1	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
cd2	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
iconv	O
(	O
cd2	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
in1size	O
>	O
0	int
||	O
do_final_flush1	O
||	O
utf8len	O
>	O
0	int
||	O
do_final_flush2	O
)	O
{	O
char	O
*	O
out1ptr	O
=	O
utf8buf	O
+	O
utf8len	O
;	O
size_t	O
out1size	O
=	O
utf8bufsize	int
-	O
utf8len	O
;	O
bool	O
incremented1	O
;	O
size_t	O
res1	O
;	O
int	O
errno1	O
;	O
if	O
(	O
in1size	O
>	O
0	int
)	O
{	O
if	O
(	O
offsets	O
!=	O
NULL	O
&&	O
length	O
!=	O
last_length	O
)	O
{	O
offsets	O
[	O
in1ptr	O
-	O
src	O
]	O
=	O
length	O
;	O
last_length	O
=	O
length	O
;	O
}	O
if	O
(	O
cd1	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
slowly	O
)	O
res1	O
=	O
iconv_carefully_1	O
(	O
cd1	O
,	O
&	O
in1ptr	O
,	O
&	O
in1size	O
,	O
&	O
out1ptr	O
,	O
&	O
out1size	O
,	O
&	O
incremented1	O
)	O
;	O
else	O
res1	O
=	O
iconv_carefully	O
(	O
cd1	O
,	O
&	O
in1ptr	O
,	O
&	O
in1size	O
,	O
&	O
out1ptr	O
,	O
&	O
out1size	O
,	O
&	O
incremented1	O
)	O
;	O
}	O
else	O
{	O
res1	O
=	O
utf8conv_carefully	O
(	O
slowly	O
,	O
&	O
in1ptr	O
,	O
&	O
in1size	O
,	O
&	O
out1ptr	O
,	O
&	O
out1size	O
,	O
&	O
incremented1	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
do_final_flush1	O
)	O
{	O
if	O
(	O
cd1	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
res1	O
=	O
iconv	O
(	O
cd1	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
out1ptr	O
,	O
&	O
out1size	O
)	O
;	O
else	O
res1	O
=	O
0	int
;	O
do_final_flush1	O
=	O
false	O
;	O
incremented1	O
=	O
true	O
;	O
}	O
else	O
{	O
res1	O
=	O
0	int
;	O
incremented1	O
=	O
true	O
;	O
}	O
if	O
(	O
res1	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
!	O
(	O
errno	O
==	O
E2BIG	O
||	O
errno	O
==	O
EINVAL	O
||	O
errno	O
==	O
EILSEQ	O
)	O
)	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
res1	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
EILSEQ	O
&&	O
handler	O
!=	O
iconveh_error	O
)	O
{	O
if	O
(	O
!	O
incremented1	O
)	O
{	O
if	O
(	O
in1size	O
==	O
0	int
)	O
abort	O
(	O
)	O
;	O
in1ptr	O
++	O
;	O
in1size	O
--	O
;	O
}	O
*	O
out1ptr	O
++	O
=	O
'?'	O
;	O
res1	O
=	O
0	int
;	O
}	O
errno1	O
=	O
errno	O
;	O
utf8len	O
=	O
out1ptr	O
-	O
utf8buf	O
;	O
if	O
(	O
offsets	O
!=	O
NULL	O
||	O
in1size	O
==	O
0	int
||	O
utf8len	O
>	O
utf8bufsize	int
/	O
2	int
||	O
(	O
res1	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
errno1	O
==	O
E2BIG	O
)	O
)	O
{	O
const	O
char	O
*	O
in2ptr	O
=	O
utf8buf	O
;	O
size_t	O
in2size	O
=	O
utf8len	O
;	O
while	O
(	O
in2size	O
>	O
0	int
||	O
(	O
in1size	O
==	O
0	int
&&	O
!	O
do_final_flush1	O
&&	O
do_final_flush2	O
)	O
)	O
{	O
char	O
*	O
out2ptr	O
=	O
result	O
+	O
length	O
;	O
size_t	O
out2size	O
=	O
allocated	O
-	O
extra_alloc	O
-	O
length	O
;	O
bool	O
incremented2	O
;	O
size_t	O
res2	O
;	O
bool	O
grow	O
;	O
if	O
(	O
in2size	O
>	O
0	int
)	O
{	O
if	O
(	O
cd2	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
res2	O
=	O
iconv_carefully	O
(	O
cd2	O
,	O
&	O
in2ptr	O
,	O
&	O
in2size	O
,	O
&	O
out2ptr	O
,	O
&	O
out2size	O
,	O
&	O
incremented2	O
)	O
;	O
else	O
res2	O
=	O
utf8conv_carefully	O
(	O
false	O
,	O
&	O
in2ptr	O
,	O
&	O
in2size	O
,	O
&	O
out2ptr	O
,	O
&	O
out2size	O
,	O
&	O
incremented2	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
cd2	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
res2	O
=	O
iconv	O
(	O
cd2	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
out2ptr	O
,	O
&	O
out2size	O
)	O
;	O
else	O
res2	O
=	O
0	int
;	O
do_final_flush2	O
=	O
false	O
;	O
incremented2	O
=	O
true	O
;	O
}	O
length	O
=	O
out2ptr	O
-	O
result	O
;	O
grow	O
=	O
(	O
length	O
+	O
extra_alloc	O
>	O
allocated	O
/	O
2	int
)	O
;	O
if	O
(	O
res2	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
E2BIG	O
)	O
grow	O
=	O
true	O
;	O
else	O
if	O
(	O
errno	O
==	O
EINVAL	O
)	O
break	O
;	O
else	O
if	O
(	O
errno	O
==	O
EILSEQ	O
&&	O
handler	O
!=	O
iconveh_error	O
)	O
{	O
char	O
scratchbuf	O
[	O
10	int
]	O
;	O
size_t	O
scratchlen	O
;	O
ucs4_t	O
uc	O
;	O
const	O
char	O
*	O
inptr	O
;	O
size_t	O
insize	O
;	O
size_t	O
res	O
;	O
if	O
(	O
incremented2	O
)	O
{	O
if	O
(	O
u8_prev	O
(	O
&	O
uc	O
,	O
(	O
const	O
uint8_t	O
*	O
)	O
in2ptr	O
,	O
(	O
const	O
uint8_t	O
*	O
)	O
utf8buf	O
)	O
==	O
NULL	O
)	O
abort	O
(	O
)	O
;	O
}	O
else	O
{	O
int	O
n	O
;	O
if	O
(	O
in2size	O
==	O
0	int
)	O
abort	O
(	O
)	O
;	O
n	O
=	O
u8_mbtouc_unsafe	O
(	O
&	O
uc	O
,	O
(	O
const	O
uint8_t	O
*	O
)	O
in2ptr	O
,	O
in2size	O
)	O
;	O
in2ptr	O
+=	O
n	O
;	O
in2size	O
-=	O
n	O
;	O
}	O
if	O
(	O
handler	O
==	O
iconveh_escape_sequence	O
)	O
{	O
static	O
char	O
hex	O
[	O
16	int
]	O
=	O
"0123456789ABCDEF"	pointer
;	O
scratchlen	O
=	O
0	int
;	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
'\\'	O
;	O
if	O
(	O
uc	O
<	O
0x10000	int
)	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
'u'	O
;	O
else	O
{	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
'U'	O
;	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
hex	O
[	O
(	O
uc	O
>>	O
28	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
hex	O
[	O
(	O
uc	O
>>	O
24	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
hex	O
[	O
(	O
uc	O
>>	O
20	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
hex	O
[	O
(	O
uc	O
>>	O
16	int
)	O
&	O
15	int
]	O
;	O
}	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
hex	O
[	O
(	O
uc	O
>>	O
12	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
hex	O
[	O
(	O
uc	O
>>	O
8	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
hex	O
[	O
(	O
uc	O
>>	O
4	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	O
[	O
scratchlen	O
++	O
]	O
=	O
hex	O
[	O
uc	O
&	O
15	int
]	O
;	O
}	O
else	O
{	O
scratchbuf	O
[	O
0	int
]	O
=	O
'?'	O
;	O
scratchlen	O
=	O
1	int
;	O
}	O
inptr	O
=	O
scratchbuf	O
;	O
insize	O
=	O
scratchlen	O
;	O
if	O
(	O
cd2	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
res	O
=	O
iconv	O
(	O
cd2	O
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	O
,	O
&	O
insize	O
,	O
&	O
out2ptr	O
,	O
&	O
out2size	O
)	O
;	O
else	O
{	O
if	O
(	O
out2size	O
>=	O
insize	O
)	O
{	O
memcpy	O
(	O
out2ptr	O
,	O
inptr	O
,	O
insize	O
)	O
;	O
out2ptr	O
+=	O
insize	O
;	O
out2size	O
-=	O
insize	O
;	O
inptr	O
+=	O
insize	O
;	O
insize	O
=	O
0	int
;	O
res	O
=	O
0	int
;	O
}	O
else	O
{	O
errno	O
=	O
E2BIG	O
;	O
res	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
}	O
}	O
length	O
=	O
out2ptr	O
-	O
result	O
;	O
if	O
(	O
res	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
E2BIG	O
)	O
{	O
char	O
*	O
memory	O
;	O
allocated	O
=	O
2	int
*	O
allocated	O
;	O
if	O
(	O
length	O
+	O
1	int
+	O
extra_alloc	O
>	O
allocated	O
)	O
abort	O
(	O
)	O
;	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memory	O
=	O
(	O
char	O
*	O
)	O
malloc	O
(	O
allocated	O
)	O
;	O
else	O
memory	O
=	O
(	O
char	O
*	O
)	O
realloc	O
(	O
result	O
,	O
allocated	O
)	O
;	O
if	O
(	O
memory	O
==	O
NULL	O
)	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memcpy	O
(	O
memory	O
,	O
initial_result	O
,	O
length	O
)	O
;	O
result	O
=	O
memory	O
;	O
grow	O
=	O
false	O
;	O
out2ptr	O
=	O
result	O
+	O
length	O
;	O
out2size	O
=	O
allocated	O
-	O
extra_alloc	O
-	O
length	O
;	O
if	O
(	O
cd2	O
!=	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
res	O
=	O
iconv	O
(	O
cd2	O
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	O
,	O
&	O
insize	O
,	O
&	O
out2ptr	O
,	O
&	O
out2size	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
out2size	O
>=	O
insize	O
)	O
)	O
abort	O
(	O
)	O
;	O
memcpy	O
(	O
out2ptr	O
,	O
inptr	O
,	O
insize	O
)	O
;	O
out2ptr	O
+=	O
insize	O
;	O
out2size	O
-=	O
insize	O
;	O
inptr	O
+=	O
insize	O
;	O
insize	O
=	O
0	int
;	O
res	O
=	O
0	int
;	O
}	O
length	O
=	O
out2ptr	O
-	O
result	O
;	O
}	O
if	O
(	O
res	O
!=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
&&	O
res	O
>	O
0	int
)	O
{	O
errno	O
=	O
EILSEQ	O
;	O
res	O
=	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
res	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
(	O
in2size	O
>	O
0	int
||	O
(	O
in1size	O
==	O
0	int
&&	O
!	O
do_final_flush1	O
&&	O
do_final_flush2	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
grow	O
)	O
{	O
char	O
*	O
memory	O
;	O
allocated	O
=	O
2	int
*	O
allocated	O
;	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memory	O
=	O
(	O
char	O
*	O
)	O
malloc	O
(	O
allocated	O
)	O
;	O
else	O
memory	O
=	O
(	O
char	O
*	O
)	O
realloc	O
(	O
result	O
,	O
allocated	O
)	O
;	O
if	O
(	O
memory	O
==	O
NULL	O
)	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	O
==	O
initial_result	O
)	O
memcpy	O
(	O
memory	O
,	O
initial_result	O
,	O
length	O
)	O
;	O
result	O
=	O
memory	O
;	O
}	O
}	O
if	O
(	O
in2size	O
>	O
0	int
)	O
memmove	O
(	O
utf8buf	O
,	O
in2ptr	O
,	O
in2size	O
)	O
;	O
utf8len	O
=	O
in2size	O
;	O
}	O
if	O
(	O
res1	O
==	O
(	O
size_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno1	O
==	O
EINVAL	O
)	O
in1size	O
=	O
0	int
;	O
else	O
if	O
(	O
errno1	O
==	O
EILSEQ	O
)	O
{	O
if	O
(	O
result	O
!=	O
initial_result	O
)	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
errno1	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
}	O
done	O
:	O
if	O
(	O
result	O
==	O
tmpbuf	O
)	O
{	O
size_t	O
memsize	O
=	O
length	O
+	O
extra_alloc	O
;	O
if	O
(	O
*	O
resultp	O
!=	O
NULL	O
&&	O
*	O
lengthp	O
>=	O
memsize	O
)	O
result	O
=	O
*	O
resultp	O
;	O
else	O
{	O
char	O
*	O
memory	O
;	O
memory	O
=	O
(	O
char	O
*	O
)	O
malloc	O
(	O
memsize	O
>	O
0	int
?	O
memsize	O
:	O
1	int
)	O
;	O
if	O
(	O
memory	O
!=	O
NULL	O
)	O
result	O
=	O
memory	O
;	O
else	O
{	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
memcpy	O
(	O
result	O
,	O
tmpbuf	O
,	O
length	O
)	O
;	O
}	O
else	O
if	O
(	O
result	O
!=	O
*	O
resultp	O
&&	O
length	O
+	O
extra_alloc	O
<	O
allocated	O
)	O
{	O
size_t	O
memsize	O
=	O
length	O
+	O
extra_alloc	O
;	O
char	O
*	O
memory	O
;	O
memory	O
=	O
(	O
char	O
*	O
)	O
realloc	O
(	O
result	O
,	O
memsize	O
>	O
0	int
?	O
memsize	O
:	O
1	int
)	O
;	O
if	O
(	O
memory	O
!=	O
NULL	O
)	O
result	O
=	O
memory	O
;	O
}	O
*	O
resultp	O
=	O
result	O
;	O
*	O
lengthp	O
=	O
length	O
;	O
return	O
0	int
;	O
}	O
int	O
mem_cd_iconveh	O
(	O
const	O
char	O
*	O
src	O
,	O
size_t	O
srclen	O
,	O
const	O
iconveh_t	O
*	O
cd	O
,	O
enum	O
iconv_ilseq_handler	O
handler	O
,	O
size_t	O
*	O
offsets	O
,	O
char	O
*	O
*	O
resultp	O
,	O
size_t	O
*	O
lengthp	O
)	O
{	O
return	O
mem_cd_iconveh_internal	O
(	O
src	O
,	O
srclen	O
,	O
cd	O
->	O
cd	O
,	O
cd	O
->	O
cd1	O
,	O
cd	O
->	O
cd2	O
,	O
handler	O
,	O
0	int
,	O
offsets	O
,	O
resultp	O
,	O
lengthp	O
)	O
;	O
}	O
char	O
*	O
str_cd_iconveh	O
(	O
const	O
char	O
*	O
src	O
,	O
const	O
iconveh_t	O
*	O
cd	O
,	O
enum	O
iconv_ilseq_handler	O
handler	O
)	O
{	O
char	O
*	O
result	O
=	O
NULL	O
;	O
size_t	O
length	O
=	O
0	int
;	O
int	O
retval	O
=	O
mem_cd_iconveh_internal	O
(	O
src	O
,	O
strlen	O
(	O
src	O
)	O
,	O
cd	O
->	O
cd	O
,	O
cd	O
->	O
cd1	O
,	O
cd	O
->	O
cd2	O
,	O
handler	O
,	O
1	int
,	O
NULL	O
,	O
&	O
result	O
,	O
&	O
length	O
)	O
;	O
if	O
(	O
retval	O
<	O
0	int
)	O
{	O
if	O
(	O
result	O
!=	O
NULL	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
}	O
return	O
NULL	O
;	O
}	O
result	O
[	O
length	O
]	O
=	O
'\0'	O
;	O
return	O
result	O
;	O
}	O
int	O
mem_iconveh	O
(	O
const	O
char	O
*	O
src	O
,	O
size_t	O
srclen	O
,	O
const	O
char	O
*	O
from_codeset	O
,	O
const	O
char	O
*	O
to_codeset	O
,	O
enum	O
iconv_ilseq_handler	O
handler	O
,	O
size_t	O
*	O
offsets	O
,	O
char	O
*	O
*	O
resultp	O
,	O
size_t	O
*	O
lengthp	O
)	O
{	O
if	O
(	O
srclen	O
==	O
0	int
)	O
{	O
*	O
lengthp	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
offsets	O
==	O
NULL	O
&&	O
c_strcasecmp	O
(	O
from_codeset	O
,	O
to_codeset	O
)	O
==	O
0	int
)	O
{	O
char	O
*	O
result	O
;	O
if	O
(	O
*	O
resultp	O
!=	O
NULL	O
&&	O
*	O
lengthp	O
>=	O
srclen	O
)	O
result	O
=	O
*	O
resultp	O
;	O
else	O
{	O
result	O
=	O
(	O
char	O
*	O
)	O
malloc	O
(	O
srclen	O
)	O
;	O
if	O
(	O
result	O
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
memcpy	O
(	O
result	O
,	O
src	O
,	O
srclen	O
)	O
;	O
*	O
resultp	O
=	O
result	O
;	O
*	O
lengthp	O
=	O
srclen	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
iconveh_t	O
cd	O
;	O
char	O
*	O
result	O
;	O
size_t	O
length	O
;	O
int	O
retval	O
;	O
if	O
(	O
iconveh_open	O
(	O
to_codeset	O
,	O
from_codeset	O
,	O
&	O
cd	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
result	O
=	O
*	O
resultp	O
;	O
length	O
=	O
*	O
lengthp	O
;	O
retval	O
=	O
mem_cd_iconveh	O
(	O
src	O
,	O
srclen	O
,	O
&	O
cd	O
,	O
handler	O
,	O
offsets	O
,	O
&	O
result	O
,	O
&	O
length	O
)	O
;	O
if	O
(	O
retval	O
<	O
0	int
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
iconveh_close	O
(	O
&	O
cd	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
}	O
else	O
{	O
if	O
(	O
iconveh_close	O
(	O
&	O
cd	O
)	O
<	O
0	int
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
if	O
(	O
result	O
!=	O
*	O
resultp	O
&&	O
result	O
!=	O
NULL	O
)	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
resultp	O
=	O
result	O
;	O
*	O
lengthp	O
=	O
length	O
;	O
}	O
return	O
retval	O
;	O
}	O
}	O
char	O
*	O
str_iconveh	O
(	O
const	O
char	O
*	O
src	O
,	O
const	O
char	O
*	O
from_codeset	O
,	O
const	O
char	O
*	O
to_codeset	O
,	O
enum	O
iconv_ilseq_handler	O
handler	O
)	O
{	O
if	O
(	O
*	O
src	O
==	O
'\0'	O
||	O
c_strcasecmp	O
(	O
from_codeset	O
,	O
to_codeset	O
)	O
==	O
0	int
)	O
{	O
char	O
*	O
result	O
=	O
strdup	O
(	O
src	O
)	O
;	O
if	O
(	O
result	O
==	O
NULL	O
)	O
errno	O
=	O
ENOMEM	O
;	O
return	O
result	O
;	O
}	O
else	O
{	O
iconveh_t	O
cd	O
;	O
char	O
*	O
result	O
;	O
if	O
(	O
iconveh_open	O
(	O
to_codeset	O
,	O
from_codeset	O
,	O
&	O
cd	O
)	O
<	O
0	int
)	O
return	O
NULL	O
;	O
result	O
=	O
str_cd_iconveh	O
(	O
src	O
,	O
&	O
cd	O
,	O
handler	O
)	O
;	O
if	O
(	O
result	O
==	O
NULL	O
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
iconveh_close	O
(	O
&	O
cd	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
}	O
else	O
{	O
if	O
(	O
iconveh_close	O
(	O
&	O
cd	O
)	O
<	O
0	int
)	O
{	O
int	O
saved_errno	O
=	O
errno	O
;	O
free	O
(	O
result	O
)	O
;	O
errno	O
=	O
saved_errno	O
;	O
return	O
NULL	O
;	O
}	O
}	O
return	O
result	O
;	O
}	O
}	O
