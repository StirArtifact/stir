static	O
error_t	O
op_null	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_getattr	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
struct	O
stat	O
st	struct
;	O
error_t	O
err	O
;	O
err	O
=	O
io_stat	function
(	O
c	pointer
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
!	O
err	O
)	O
*	O
reply	pointer
=	O
encode_fattr	function
(	O
*	O
reply	pointer
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
complete_setattr	function
(	O
mach_port_t	O
port	int
,	O
int	O
*	O
p	pointer
)	O
{	O
uid_t	O
uid	O
,	O
gid	O
;	O
off_t	O
size	O
;	O
time_value_t	O
atime	O
,	O
mtime	O
;	O
struct	O
stat	O
st	struct
;	O
error_t	O
err	O
;	O
err	O
=	O
io_stat	function
(	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
uid	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
gid	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
uid	O
==	O
-	O
1	int
)	O
uid	O
=	O
st	struct
.	O
st_uid	O
;	O
if	O
(	O
gid	O
==	O
-	O
1	int
)	O
gid	O
=	O
st	struct
.	O
st_gid	O
;	O
if	O
(	O
uid	O
!=	O
st	struct
.	O
st_uid	O
||	O
gid	O
!=	O
st	struct
.	O
st_gid	O
)	O
err	O
=	O
file_chown	function
(	O
port	int
,	O
uid	O
,	O
gid	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
size	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
size	O
!=	O
-	O
1	int
&&	O
size	O
!=	O
st	struct
.	O
st_size	O
)	O
err	O
=	O
file_set_size	function
(	O
port	int
,	O
size	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
atime	O
.	O
seconds	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
atime	O
.	O
microseconds	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
mtime	O
.	O
seconds	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
mtime	O
.	O
microseconds	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
atime	O
.	O
seconds	O
!=	O
-	O
1	int
&&	O
atime	O
.	O
microseconds	O
==	O
-	O
1	int
)	O
atime	O
.	O
microseconds	O
=	O
0	int
;	O
if	O
(	O
mtime	O
.	O
seconds	O
!=	O
-	O
1	int
&&	O
mtime	O
.	O
microseconds	O
==	O
-	O
1	int
)	O
mtime	O
.	O
microseconds	O
=	O
0	int
;	O
if	O
(	O
atime	O
.	O
seconds	O
==	O
-	O
1	int
)	O
atime	O
.	O
seconds	O
=	O
st	struct
.	O
st_atim	O
.	O
tv_sec	O
;	O
if	O
(	O
atime	O
.	O
microseconds	O
==	O
-	O
1	int
)	O
atime	O
.	O
microseconds	O
=	O
st	struct
.	O
st_atim	O
.	O
tv_nsec	O
/	O
1000	int
;	O
if	O
(	O
mtime	O
.	O
seconds	O
==	O
-	O
1	int
)	O
mtime	O
.	O
seconds	O
=	O
st	struct
.	O
st_mtim	O
.	O
tv_sec	O
;	O
if	O
(	O
mtime	O
.	O
microseconds	O
==	O
-	O
1	int
)	O
mtime	O
.	O
microseconds	O
=	O
st	struct
.	O
st_mtim	O
.	O
tv_nsec	O
/	O
1000	int
;	O
if	O
(	O
atime	O
.	O
seconds	O
!=	O
st	struct
.	O
st_atim	O
.	O
tv_sec	O
||	O
atime	O
.	O
microseconds	O
!=	O
st	struct
.	O
st_atim	O
.	O
tv_nsec	O
/	O
1000	int
||	O
mtime	O
.	O
seconds	O
!=	O
st	struct
.	O
st_mtim	O
.	O
tv_sec	O
||	O
mtime	O
.	O
microseconds	O
!=	O
st	struct
.	O
st_mtim	O
.	O
tv_nsec	O
/	O
1000	int
)	O
err	O
=	O
file_utimes	function
(	O
port	int
,	O
atime	O
,	O
mtime	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_setattr	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
mode_t	O
mode	O
;	O
struct	O
stat	O
st	struct
;	O
mode	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
mode	O
!=	O
-	O
1	int
)	O
err	O
=	O
file_chmod	function
(	O
c	pointer
->	O
port	int
,	O
mode	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
complete_setattr	function
(	O
c	pointer
->	O
port	int
,	O
p	pointer
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
io_stat	function
(	O
c	pointer
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
*	O
reply	pointer
=	O
encode_fattr	function
(	O
*	O
reply	pointer
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_lookup	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
error_t	O
err	O
;	O
char	O
*	O
name	pointer
;	O
retry_type	O
do_retry	O
;	O
char	O
retry_name	array
[	O
1024	int
]	O
;	O
mach_port_t	O
newport	O
;	O
struct	O
cache_handle	O
*	O
newc	pointer
;	O
struct	O
stat	O
st	struct
;	O
decode_name	function
(	O
p	pointer
,	O
&	O
name	pointer
)	O
;	O
err	O
=	O
dir_lookup	function
(	O
c	pointer
->	O
port	int
,	O
name	pointer
,	O
O_NOTRANS	O
,	O
0	int
,	O
&	O
do_retry	O
,	O
retry_name	array
,	O
&	O
newport	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
(	O
do_retry	O
!=	O
FS_RETRY_NORMAL	O
||	O
retry_name	array
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
err	O
=	O
EACCES	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
io_stat	function
(	O
newport	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
newc	pointer
=	O
create_cached_handle	function
(	O
c	pointer
->	O
handle	O
.	O
fs	O
,	O
c	pointer
,	O
newport	O
)	O
;	O
if	O
(	O
!	O
newc	pointer
)	O
return	O
ESTALE	O
;	O
*	O
reply	pointer
=	O
encode_fhandle	function
(	O
*	O
reply	pointer
,	O
newc	pointer
->	O
handle	O
.	O
array	O
)	O
;	O
*	O
reply	pointer
=	O
encode_fattr	function
(	O
*	O
reply	pointer
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_readlink	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
char	O
buf	array
[	O
2048	int
]	O
,	O
*	O
transp	pointer
=	O
buf	array
;	O
mach_msg_type_number_t	O
len	O
=	O
sizeof	O
(	O
buf	array
)	O
;	O
error_t	O
err	O
;	O
err	O
=	O
file_get_translator	function
(	O
c	pointer
->	O
port	int
,	O
&	O
transp	pointer
,	O
&	O
len	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
transp	pointer
!=	O
buf	array
)	O
munmap	function
(	O
transp	pointer
,	O
len	O
)	O
;	O
return	O
err	O
;	O
}	O
if	O
(	O
len	O
<	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
||	O
memcmp	O
(	O
transp	pointer
,	O
_HURD_SYMLINK	O
,	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
)	O
)	O
return	O
EINVAL	O
;	O
transp	pointer
+=	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
;	O
*	O
reply	pointer
=	O
encode_string	function
(	O
*	O
reply	pointer
,	O
transp	pointer
)	O
;	O
if	O
(	O
transp	pointer
!=	O
buf	array
)	O
munmap	function
(	O
transp	pointer
,	O
len	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	O
count_read_buffersize	function
(	O
int	O
*	O
p	pointer
,	O
int	O
version	int
)	O
{	O
p	pointer
++	O
;	O
return	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
}	O
static	O
error_t	O
op_read	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
off_t	O
offset	O
;	O
size_t	O
count	int
;	O
char	O
buf	array
[	O
2048	int
]	O
,	O
*	O
bp	pointer
=	O
buf	array
;	O
mach_msg_type_number_t	O
buflen	O
=	O
sizeof	O
(	O
buf	array
)	O
;	O
struct	O
stat	O
st	struct
;	O
error_t	O
err	O
;	O
offset	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
count	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
err	O
=	O
io_read	function
(	O
c	pointer
->	O
port	int
,	O
&	O
bp	pointer
,	O
&	O
buflen	O
,	O
offset	O
,	O
count	int
)	O
;	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
bp	pointer
!=	O
buf	array
)	O
munmap	function
(	O
bp	pointer
,	O
buflen	O
)	O
;	O
return	O
err	O
;	O
}	O
err	O
=	O
io_stat	function
(	O
c	pointer
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
*	O
reply	pointer
=	O
encode_fattr	function
(	O
*	O
reply	pointer
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
*	O
reply	pointer
=	O
encode_data	function
(	O
*	O
reply	pointer
,	O
bp	pointer
,	O
buflen	O
)	O
;	O
if	O
(	O
bp	pointer
!=	O
buf	array
)	O
munmap	function
(	O
bp	pointer
,	O
buflen	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_write	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
off_t	O
offset	O
;	O
size_t	O
count	int
;	O
error_t	O
err	O
;	O
mach_msg_type_number_t	O
amt	O
;	O
char	O
*	O
bp	pointer
;	O
struct	O
stat	O
st	struct
;	O
p	pointer
++	O
;	O
offset	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
p	pointer
++	O
;	O
count	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
bp	pointer
=	O
(	O
char	O
*	O
)	O
*	O
reply	pointer
;	O
while	O
(	O
count	int
)	O
{	O
err	O
=	O
io_write	function
(	O
c	pointer
->	O
port	int
,	O
bp	pointer
,	O
count	int
,	O
offset	O
,	O
&	O
amt	O
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
amt	O
==	O
0	int
)	O
return	O
EIO	O
;	O
count	int
-=	O
amt	O
;	O
bp	pointer
+=	O
amt	O
;	O
offset	O
+=	O
amt	O
;	O
}	O
file_sync	function
(	O
c	pointer
->	O
port	int
,	O
1	int
,	O
0	int
)	O
;	O
err	O
=	O
io_stat	function
(	O
c	pointer
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
*	O
reply	pointer
=	O
encode_fattr	function
(	O
*	O
reply	pointer
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_create	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
error_t	O
err	O
;	O
char	O
*	O
name	pointer
;	O
retry_type	O
do_retry	O
;	O
char	O
retry_name	array
[	O
1024	int
]	O
;	O
mach_port_t	O
newport	O
;	O
struct	O
cache_handle	O
*	O
newc	pointer
;	O
struct	O
stat	O
st	struct
;	O
mode_t	O
mode	O
;	O
int	O
statchanged	int
=	O
0	int
;	O
off_t	O
size	O
;	O
p	pointer
=	O
decode_name	function
(	O
p	pointer
,	O
&	O
name	pointer
)	O
;	O
mode	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
err	O
=	O
dir_lookup	function
(	O
c	pointer
->	O
port	int
,	O
name	pointer
,	O
O_NOTRANS	O
|	O
O_CREAT	O
|	O
O_TRUNC	O
,	O
mode	O
,	O
&	O
do_retry	O
,	O
retry_name	array
,	O
&	O
newport	O
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
(	O
do_retry	O
!=	O
FS_RETRY_NORMAL	O
||	O
retry_name	array
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
err	O
=	O
EACCES	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
io_stat	function
(	O
newport	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
errout	O
;	O
p	pointer
++	O
,	O
p	pointer
++	O
;	O
size	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
size	O
!=	O
-	O
1	int
&&	O
size	O
!=	O
st	struct
.	O
st_size	O
)	O
{	O
err	O
=	O
file_set_size	function
(	O
newport	O
,	O
size	O
)	O
;	O
statchanged	int
=	O
1	int
;	O
}	O
if	O
(	O
err	O
)	O
goto	O
errout	O
;	O
if	O
(	O
statchanged	int
)	O
err	O
=	O
io_stat	function
(	O
newport	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
{	O
errout	O
:	O
dir_unlink	function
(	O
c	pointer
->	O
port	int
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
err	O
;	O
}	O
free	function
(	O
name	pointer
)	O
;	O
newc	pointer
=	O
create_cached_handle	function
(	O
c	pointer
->	O
handle	O
.	O
fs	O
,	O
c	pointer
,	O
newport	O
)	O
;	O
if	O
(	O
!	O
newc	pointer
)	O
return	O
ESTALE	O
;	O
*	O
reply	pointer
=	O
encode_fhandle	function
(	O
*	O
reply	pointer
,	O
newc	pointer
->	O
handle	O
.	O
array	O
)	O
;	O
*	O
reply	pointer
=	O
encode_fattr	function
(	O
*	O
reply	pointer
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_remove	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
error_t	O
err	O
;	O
char	O
*	O
name	pointer
;	O
decode_name	function
(	O
p	pointer
,	O
&	O
name	pointer
)	O
;	O
err	O
=	O
dir_unlink	function
(	O
c	pointer
->	O
port	int
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_rename	function
(	O
struct	O
cache_handle	O
*	O
fromc	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
struct	O
cache_handle	O
*	O
toc	pointer
;	O
char	O
*	O
fromname	pointer
,	O
*	O
toname	pointer
;	O
error_t	O
err	O
=	O
0	int
;	O
p	pointer
=	O
decode_name	function
(	O
p	pointer
,	O
&	O
fromname	pointer
)	O
;	O
p	pointer
=	O
lookup_cache_handle	function
(	O
p	pointer
,	O
&	O
toc	pointer
,	O
fromc	pointer
->	O
ids	O
)	O
;	O
decode_name	function
(	O
p	pointer
,	O
&	O
toname	pointer
)	O
;	O
if	O
(	O
!	O
toc	pointer
)	O
err	O
=	O
ESTALE	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
dir_rename	function
(	O
fromc	pointer
->	O
port	int
,	O
fromname	pointer
,	O
toc	pointer
->	O
port	int
,	O
toname	pointer
,	O
0	int
)	O
;	O
free	function
(	O
fromname	pointer
)	O
;	O
free	function
(	O
toname	pointer
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_link	function
(	O
struct	O
cache_handle	O
*	O
filec	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
struct	O
cache_handle	O
*	O
dirc	pointer
;	O
char	O
*	O
name	pointer
;	O
error_t	O
err	O
=	O
0	int
;	O
p	pointer
=	O
lookup_cache_handle	function
(	O
p	pointer
,	O
&	O
dirc	pointer
,	O
filec	pointer
->	O
ids	O
)	O
;	O
decode_name	function
(	O
p	pointer
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
!	O
dirc	pointer
)	O
err	O
=	O
ESTALE	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
dir_link	function
(	O
dirc	pointer
->	O
port	int
,	O
filec	pointer
->	O
port	int
,	O
name	pointer
,	O
1	int
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_symlink	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
char	O
*	O
name	pointer
,	O
*	O
target	pointer
;	O
error_t	O
err	O
;	O
mode_t	O
mode	O
;	O
file_t	O
newport	O
=	O
MACH_PORT_NULL	O
;	O
size_t	O
len	O
;	O
char	O
*	O
buf	array
;	O
p	pointer
=	O
decode_name	function
(	O
p	pointer
,	O
&	O
name	pointer
)	O
;	O
p	pointer
=	O
decode_name	function
(	O
p	pointer
,	O
&	O
target	pointer
)	O
;	O
mode	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
mode	O
==	O
-	O
1	int
)	O
mode	O
=	O
0777	int
;	O
len	O
=	O
strlen	O
(	O
target	pointer
)	O
+	O
1	int
;	O
buf	array
=	O
alloca	O
(	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
+	O
len	O
)	O
;	O
memcpy	O
(	O
buf	array
,	O
_HURD_SYMLINK	O
,	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
)	O
;	O
memcpy	O
(	O
buf	array
+	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
,	O
target	pointer
,	O
len	O
)	O
;	O
err	O
=	O
dir_mkfile	function
(	O
c	pointer
->	O
port	int
,	O
O_WRITE	O
,	O
mode	O
,	O
&	O
newport	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
file_set_translator	function
(	O
newport	O
,	O
FS_TRANS_EXCL	O
|	O
FS_TRANS_SET	O
,	O
FS_TRANS_EXCL	O
|	O
FS_TRANS_SET	O
,	O
0	int
,	O
buf	array
,	O
sizeof	O
(	O
_HURD_SYMLINK	O
)	O
+	O
len	O
,	O
MACH_PORT_NULL	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
dir_link	function
(	O
c	pointer
->	O
port	int
,	O
newport	O
,	O
name	pointer
,	O
1	int
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
free	function
(	O
target	pointer
)	O
;	O
if	O
(	O
newport	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
newport	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_mkdir	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
char	O
*	O
name	pointer
;	O
mode_t	O
mode	O
;	O
retry_type	O
do_retry	O
;	O
char	O
retry_name	array
[	O
1024	int
]	O
;	O
mach_port_t	O
newport	O
;	O
struct	O
stat	O
st	struct
;	O
struct	O
cache_handle	O
*	O
newc	pointer
;	O
error_t	O
err	O
;	O
p	pointer
=	O
decode_name	function
(	O
p	pointer
,	O
&	O
name	pointer
)	O
;	O
mode	O
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
err	O
=	O
dir_mkdir	function
(	O
c	pointer
->	O
port	int
,	O
name	pointer
,	O
mode	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
return	O
err	O
;	O
}	O
err	O
=	O
dir_lookup	function
(	O
c	pointer
->	O
port	int
,	O
name	pointer
,	O
O_NOTRANS	O
,	O
0	int
,	O
&	O
do_retry	O
,	O
retry_name	array
,	O
&	O
newport	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
err	O
&&	O
(	O
do_retry	O
!=	O
FS_RETRY_NORMAL	O
||	O
retry_name	array
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
err	O
=	O
EACCES	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
!	O
err	O
)	O
err	O
=	O
io_stat	function
(	O
newport	O
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
newc	pointer
=	O
create_cached_handle	function
(	O
c	pointer
->	O
handle	O
.	O
fs	O
,	O
c	pointer
,	O
newport	O
)	O
;	O
if	O
(	O
!	O
newc	pointer
)	O
return	O
ESTALE	O
;	O
*	O
reply	pointer
=	O
encode_fhandle	function
(	O
*	O
reply	pointer
,	O
newc	pointer
->	O
handle	O
.	O
array	O
)	O
;	O
*	O
reply	pointer
=	O
encode_fattr	function
(	O
*	O
reply	pointer
,	O
&	O
st	struct
,	O
version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_rmdir	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
char	O
*	O
name	pointer
;	O
error_t	O
err	O
;	O
decode_name	function
(	O
p	pointer
,	O
&	O
name	pointer
)	O
;	O
err	O
=	O
dir_rmdir	function
(	O
c	pointer
->	O
port	int
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_readdir	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
int	O
cookie	int
;	O
unsigned	O
count	int
;	O
error_t	O
err	O
;	O
char	O
*	O
buf	array
;	O
struct	O
dirent	O
*	O
dp	pointer
;	O
size_t	O
bufsize	O
;	O
int	O
nentries	int
;	O
int	O
i	int
;	O
int	O
*	O
replystart	pointer
;	O
int	O
*	O
r	pointer
;	O
cookie	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
count	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
buf	array
=	O
(	O
char	O
*	O
)	O
0	int
;	O
bufsize	O
=	O
0	int
;	O
err	O
=	O
dir_readdir	function
(	O
c	pointer
->	O
port	int
,	O
&	O
buf	array
,	O
&	O
bufsize	O
,	O
cookie	int
,	O
-	O
1	int
,	O
count	int
,	O
&	O
nentries	int
)	O
;	O
if	O
(	O
err	O
)	O
{	O
if	O
(	O
buf	array
)	O
munmap	function
(	O
buf	array
,	O
bufsize	O
)	O
;	O
return	O
err	O
;	O
}	O
r	pointer
=	O
*	O
reply	pointer
;	O
if	O
(	O
nentries	int
==	O
0	int
)	O
{	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
0	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
1	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
dp	pointer
=	O
(	O
struct	O
dirent	O
*	O
)	O
buf	array
,	O
replystart	pointer
=	O
*	O
reply	pointer
;	O
(	O
(	O
char	O
*	O
)	O
dp	pointer
<	O
buf	array
+	O
bufsize	O
&&	O
i	int
<	O
nentries	int
&&	O
(	O
char	O
*	O
)	O
reply	pointer
<	O
(	O
char	O
*	O
)	O
replystart	pointer
+	O
count	int
)	O
;	O
i	int
++	O
,	O
dp	pointer
=	O
(	O
struct	O
dirent	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
dp	pointer
+	O
dp	pointer
->	O
d_reclen	O
)	O
)	O
{	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
1	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
dp	pointer
->	O
d_ino	O
)	O
;	O
r	pointer
=	O
encode_string	function
(	O
r	pointer
,	O
dp	pointer
->	O
d_name	O
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
i	int
+	O
cookie	int
+	O
1	int
)	O
;	O
}	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
0	int
)	O
;	O
*	O
(	O
r	pointer
++	O
)	O
=	O
htonl	function
(	O
0	int
)	O
;	O
}	O
*	O
reply	pointer
=	O
r	pointer
;	O
if	O
(	O
buf	array
)	O
munmap	function
(	O
buf	array
,	O
bufsize	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	O
count_readdir_buffersize	function
(	O
int	O
*	O
p	pointer
,	O
int	O
version	int
)	O
{	O
p	pointer
++	O
;	O
return	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
}	O
static	O
error_t	O
op_statfs	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
struct	O
statfs	O
st	struct
;	O
error_t	O
err	O
;	O
err	O
=	O
file_statfs	function
(	O
c	pointer
->	O
port	int
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
!	O
err	O
)	O
*	O
reply	pointer
=	O
encode_statfs	function
(	O
*	O
reply	pointer
,	O
&	O
st	struct
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
op_mnt	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
file_t	O
root	O
;	O
struct	O
cache_handle	O
*	O
newc	pointer
;	O
char	O
*	O
name	pointer
;	O
decode_name	function
(	O
p	pointer
,	O
&	O
name	pointer
)	O
;	O
root	O
=	O
file_name_lookup	function
(	O
name	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
root	O
)	O
{	O
free	function
(	O
name	pointer
)	O
;	O
return	O
errno	O
;	O
}	O
newc	pointer
=	O
create_cached_handle	function
(	O
enter_filesystem	function
(	O
name	pointer
,	O
root	O
)	O
,	O
c	pointer
,	O
root	O
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
newc	pointer
)	O
return	O
ESTALE	O
;	O
*	O
reply	pointer
=	O
encode_fhandle	function
(	O
*	O
reply	pointer
,	O
newc	pointer
->	O
handle	O
.	O
array	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
op_getport	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
,	O
int	O
*	O
p	pointer
,	O
int	O
*	O
*	O
reply	pointer
,	O
int	O
version	int
)	O
{	O
int	O
prog	int
,	O
vers	int
,	O
prot	int
;	O
prog	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
vers	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
prot	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
prot	int
!=	O
IPPROTO_UDP	O
)	O
*	O
(	O
*	O
reply	pointer
)	O
++	O
=	O
htonl	function
(	O
0	int
)	O
;	O
else	O
if	O
(	O
(	O
prog	int
==	O
MOUNTPROG	O
&&	O
vers	int
==	O
MOUNTVERS	O
)	O
||	O
(	O
prog	int
==	O
NFS_PROGRAM	O
&&	O
vers	int
==	O
NFS_VERSION	O
)	O
)	O
*	O
(	O
*	O
reply	pointer
)	O
++	O
=	O
htonl	function
(	O
NFS_PORT	O
)	O
;	O
else	O
if	O
(	O
prog	int
==	O
PMAPPROG	O
&&	O
vers	int
==	O
PMAPVERS	O
)	O
*	O
(	O
*	O
reply	pointer
)	O
++	O
=	O
htonl	function
(	O
PMAPPORT	O
)	O
;	O
else	O
*	O
(	O
*	O
reply	pointer
)	O
++	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
struct	O
proctable	O
nfs2table	struct
=	O
{	O
NFS2PROC_NULL	O
,	O
NFS2PROC_STATFS	O
,	O
{	O
{	O
op_null	function
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_getattr	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_setattr	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_lookup	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_readlink	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_read	function
,	O
count_read_buffersize	function
,	O
1	int
,	O
1	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_write	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_create	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_remove	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_rename	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_link	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_symlink	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_mkdir	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_rmdir	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_readdir	function
,	O
count_readdir_buffersize	function
,	O
1	int
,	O
1	int
}	O
,	O
{	O
op_statfs	function
,	O
0	int
,	O
1	int
,	O
1	int
}	O
,	O
}	O
}	O
;	O
struct	O
proctable	O
mounttable	struct
=	O
{	O
MOUNTPROC_NULL	O
,	O
MOUNTPROC_EXPORT	O
,	O
{	O
{	O
op_null	function
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_mnt	function
,	O
0	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_null	function
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_null	function
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
}	O
;	O
struct	O
proctable	O
pmaptable	struct
=	O
{	O
PMAPPROC_NULL	O
,	O
PMAPPROC_CALLIT	O
,	O
{	O
{	O
op_null	function
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
op_getport	function
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
}	O
;	O
