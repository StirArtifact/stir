void	O
mu_sieve_register_comparator	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
required	int
,	O
mu_sieve_comparator_t	pointer
is	pointer
,	O
mu_sieve_comparator_t	pointer
contains	pointer
,	O
mu_sieve_comparator_t	pointer
matches	pointer
,	O
mu_sieve_comparator_t	pointer
regex	pointer
,	O
mu_sieve_comparator_t	pointer
eq	pointer
)	O
{	O
mu_sieve_registry_t	struct
*	O
reg	long
=	O
mu_sieve_registry_add	function
(	O
mach	pointer
,	O
name	pointer
)	O
;	O
reg	long
->	O
type	int
=	O
mu_sieve_record_comparator	int
;	O
reg	long
->	O
required	int
=	O
required	int
;	O
reg	long
->	O
name	pointer
=	O
name	pointer
;	O
reg	long
->	O
v	array
.	O
comp	array
[	O
MU_SIEVE_MATCH_IS	int
]	O
=	O
is	pointer
;	O
reg	long
->	O
v	array
.	O
comp	array
[	O
MU_SIEVE_MATCH_CONTAINS	int
]	O
=	O
contains	pointer
;	O
reg	long
->	O
v	array
.	O
comp	array
[	O
MU_SIEVE_MATCH_MATCHES	int
]	O
=	O
matches	pointer
;	O
reg	long
->	O
v	array
.	O
comp	array
[	O
MU_SIEVE_MATCH_REGEX	int
]	O
=	O
regex	pointer
;	O
reg	long
->	O
v	array
.	O
comp	array
[	O
MU_SIEVE_MATCH_EQ	int
]	O
=	O
eq	pointer
;	O
}	O
mu_sieve_comparator_t	pointer
mu_sieve_comparator_lookup	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
matchtype	int
)	O
{	O
mu_sieve_registry_t	struct
*	O
reg	long
=	O
mu_sieve_registry_lookup	function
(	O
mach	pointer
,	O
name	pointer
,	O
mu_sieve_record_comparator	int
)	O
;	O
if	O
(	O
reg	long
&&	O
reg	long
->	O
v	array
.	O
comp	array
[	O
matchtype	int
]	O
)	O
return	O
reg	long
->	O
v	array
.	O
comp	array
[	O
matchtype	int
]	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
i_ascii_casemap_is	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
;	O
mu_sieve_comparator_t	pointer
mu_sieve_get_comparator	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
if	O
(	O
!	O
mach	pointer
->	O
comparator	pointer
)	O
return	O
i_ascii_casemap_is	function
;	O
return	O
mach	pointer
->	O
comparator	pointer
;	O
}	O
static	O
void	O
compile_pattern	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
regex_t	struct
*	O
preg	pointer
;	O
char	O
*	O
str	pointer
;	O
str	pointer
=	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
;	O
if	O
(	O
pattern	pointer
->	O
rx	pointer
)	O
{	O
if	O
(	O
!	O
pattern	pointer
->	O
changed	int
)	O
return	O
;	O
preg	pointer
=	O
pattern	pointer
->	O
rx	pointer
;	O
regfree	function
(	O
preg	pointer
)	O
;	O
}	O
else	O
preg	pointer
=	O
mu_sieve_malloc	function
(	O
mach	pointer
,	O
sizeof	O
(	O
*	O
preg	pointer
)	O
)	O
;	O
rc	int
=	O
regcomp	function
(	O
preg	pointer
,	O
str	pointer
,	O
REG_EXTENDED	int
|	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
size_t	long
size	long
=	O
regerror	function
(	O
rc	int
,	O
preg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
char	O
*	O
errbuf	array
=	O
malloc	function
(	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
errbuf	array
)	O
{	O
regerror	function
(	O
rc	int
,	O
preg	pointer
,	O
errbuf	array
,	O
size	long
)	O
;	O
mu_sieve_error	function
(	O
mach	pointer
,	O
_	O
(	O
"regex error: %s"	pointer
)	O
,	O
errbuf	array
)	O
;	O
free	function
(	O
errbuf	array
)	O
;	O
}	O
else	O
mu_sieve_error	function
(	O
mach	pointer
,	O
_	O
(	O
"regex error"	pointer
)	O
)	O
;	O
mu_sieve_abort	function
(	O
mach	pointer
)	O
;	O
}	O
pattern	pointer
->	O
rx	pointer
=	O
preg	pointer
;	O
}	O
static	O
void	O
compile_wildcard	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
regex_t	struct
*	O
preg	pointer
;	O
char	O
*	O
str	pointer
;	O
str	pointer
=	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
;	O
if	O
(	O
pattern	pointer
->	O
rx	pointer
)	O
{	O
if	O
(	O
!	O
pattern	pointer
->	O
changed	int
)	O
return	O
;	O
preg	pointer
=	O
pattern	pointer
->	O
rx	pointer
;	O
regfree	function
(	O
preg	pointer
)	O
;	O
}	O
else	O
preg	pointer
=	O
mu_sieve_malloc	function
(	O
mach	pointer
,	O
sizeof	O
(	O
*	O
preg	pointer
)	O
)	O
;	O
if	O
(	O
mu_sieve_has_variables	function
(	O
mach	pointer
)	O
)	O
flags	int
|=	O
MU_GLOBF_SUB	int
;	O
rc	int
=	O
mu_glob_compile	function
(	O
preg	pointer
,	O
str	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	function
(	O
mach	pointer
,	O
_	O
(	O
"can't compile pattern"	pointer
)	O
)	O
;	O
mu_sieve_abort	function
(	O
mach	pointer
)	O
;	O
}	O
pattern	pointer
->	O
rx	pointer
=	O
preg	pointer
;	O
}	O
static	O
int	O
comp_false	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
return	O
0	int
;	O
}	O
int	O
mu_sieve_match_part_checker	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
size_t	long
i	long
;	O
mu_sieve_value_t	struct
*	O
match	pointer
=	O
NULL	O
;	O
mu_sieve_comparator_t	pointer
compfun	pointer
=	O
NULL	O
;	O
char	O
*	O
compname	pointer
=	O
NULL	O
;	O
int	O
matchtype	int
;	O
if	O
(	O
mach	pointer
->	O
tagcount	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mach	pointer
->	O
tagcount	long
;	O
i	long
++	O
)	O
{	O
mu_sieve_value_t	struct
*	O
t	long
=	O
mu_sieve_get_tag_n	function
(	O
mach	pointer
,	O
i	long
)	O
;	O
if	O
(	O
strcmp	function
(	O
t	long
->	O
tag	pointer
,	O
"is"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
t	long
->	O
tag	pointer
,	O
"contains"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
t	long
->	O
tag	pointer
,	O
"matches"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
t	long
->	O
tag	pointer
,	O
"regex"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
t	long
->	O
tag	pointer
,	O
"count"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
t	long
->	O
tag	pointer
,	O
"value"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
match	pointer
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
t	long
->	O
locus	struct
,	O
_	O
(	O
"match type specified twice in call to `%s'"	pointer
)	O
,	O
mach	pointer
->	O
identifier	pointer
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
match	pointer
=	O
t	long
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
t	long
->	O
tag	pointer
,	O
"comparator"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
t	long
->	O
type	int
!=	O
SVT_STRING	int
)	O
abort	function
(	O
)	O
;	O
compname	pointer
=	O
mu_sieve_string	struct
(	O
mach	pointer
,	O
&	O
t	long
->	O
v	array
.	O
list	pointer
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
match	pointer
||	O
strcmp	function
(	O
match	pointer
->	O
tag	pointer
,	O
"is"	pointer
)	O
==	O
0	int
)	O
matchtype	int
=	O
MU_SIEVE_MATCH_IS	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
match	pointer
->	O
tag	pointer
,	O
"contains"	pointer
)	O
==	O
0	int
)	O
matchtype	int
=	O
MU_SIEVE_MATCH_CONTAINS	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
match	pointer
->	O
tag	pointer
,	O
"matches"	pointer
)	O
==	O
0	int
)	O
matchtype	int
=	O
MU_SIEVE_MATCH_MATCHES	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
match	pointer
->	O
tag	pointer
,	O
"regex"	pointer
)	O
==	O
0	int
)	O
matchtype	int
=	O
MU_SIEVE_MATCH_REGEX	int
;	O
else	O
if	O
(	O
match	pointer
->	O
type	int
==	O
SVT_STRING	int
)	O
{	O
char	O
*	O
str	pointer
=	O
mu_sieve_string	struct
(	O
mach	pointer
,	O
&	O
match	pointer
->	O
v	array
.	O
list	pointer
,	O
0	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
match	pointer
->	O
tag	pointer
,	O
"count"	pointer
)	O
==	O
0	int
)	O
{	O
mu_sieve_value_t	struct
*	O
val	pointer
;	O
mu_sieve_string_t	struct
*	O
argstr	pointer
;	O
if	O
(	O
compname	pointer
&&	O
strcmp	function
(	O
compname	pointer
,	O
"i;ascii-numeric"	pointer
)	O
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
match	pointer
->	O
locus	struct
,	O
_	O
(	O
"comparator %s is incompatible with "	pointer
":count in call to `%s'"	pointer
)	O
,	O
compname	pointer
,	O
mach	pointer
->	O
identifier	pointer
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
return	O
1	int
;	O
}	O
matchtype	int
=	O
MU_SIEVE_MATCH_LAST	int
;	O
compname	pointer
=	O
"false"	pointer
;	O
compfun	pointer
=	O
comp_false	function
;	O
val	pointer
=	O
mu_sieve_get_arg_untyped	function
(	O
mach	pointer
,	O
1	int
)	O
;	O
switch	O
(	O
val	pointer
->	O
type	int
)	O
{	O
case	O
SVT_STRING	int
:	O
break	O
;	O
case	O
SVT_STRING_LIST	int
:	O
if	O
(	O
val	pointer
->	O
v	array
.	O
list	pointer
.	O
count	long
==	O
1	int
)	O
break	O
;	O
default	O
:	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
val	pointer
->	O
locus	struct
,	O
_	O
(	O
":count requires second argument to be a list of one element"	pointer
)	O
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
return	O
1	int
;	O
}	O
argstr	pointer
=	O
mu_sieve_string_raw	function
(	O
mach	pointer
,	O
&	O
val	pointer
->	O
v	array
.	O
list	pointer
,	O
0	int
)	O
;	O
if	O
(	O
argstr	pointer
->	O
constant	long
)	O
{	O
char	O
*	O
p	pointer
=	O
mu_str_skip_class	function
(	O
argstr	pointer
->	O
orig	pointer
,	O
MU_CTYPE_DIGIT	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
val	pointer
->	O
locus	struct
,	O
_	O
(	O
"second argument cannot be converted to number"	pointer
)	O
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
else	O
matchtype	int
=	O
MU_SIEVE_MATCH_EQ	int
;	O
if	O
(	O
mu_sieve_str_to_relcmp	function
(	O
str	pointer
,	O
NULL	O
,	O
NULL	O
)	O
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
match	pointer
->	O
locus	struct
,	O
_	O
(	O
"invalid relational match `%s' in call to `%s'"	pointer
)	O
,	O
str	pointer
,	O
mach	pointer
->	O
identifier	pointer
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
mu_error	function
(	O
_	O
(	O
"%s:%d: INTERNAL ERROR, please report"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
compfun	pointer
)	O
{	O
if	O
(	O
!	O
compname	pointer
)	O
compname	pointer
=	O
"i;ascii-casemap"	pointer
;	O
compfun	pointer
=	O
mu_sieve_comparator_lookup	function
(	O
mach	pointer
,	O
compname	pointer
,	O
matchtype	int
)	O
;	O
if	O
(	O
!	O
compfun	pointer
)	O
{	O
if	O
(	O
match	pointer
)	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
match	pointer
->	O
locus	struct
,	O
_	O
(	O
"comparator `%s' is incompatible with match type `%s' in call to `%s'"	pointer
)	O
,	O
compname	pointer
,	O
match	pointer
->	O
tag	pointer
,	O
mach	pointer
->	O
identifier	pointer
)	O
;	O
else	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
mach	pointer
->	O
locus	struct
,	O
_	O
(	O
"comparator `%s' is incompatible with match type `%s' in call to `%s'"	pointer
)	O
,	O
compname	pointer
,	O
"is"	pointer
,	O
mach	pointer
->	O
identifier	pointer
)	O
;	O
mu_i_sv_error	function
(	O
mach	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
mach	pointer
->	O
comparator	pointer
=	O
compfun	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
regmatch	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
char	O
const	O
*	O
text	pointer
)	O
{	O
regex_t	struct
*	O
reg	long
=	O
pattern	pointer
->	O
rx	pointer
;	O
regmatch_t	struct
*	O
match_buf	pointer
=	O
NULL	O
;	O
size_t	long
match_count	long
=	O
0	int
;	O
if	O
(	O
mu_sieve_has_variables	function
(	O
mach	pointer
)	O
)	O
{	O
match_count	long
=	O
reg	long
->	O
re_nsub	long
+	O
1	int
;	O
while	O
(	O
mach	pointer
->	O
match_max	long
<	O
match_count	long
)	O
mu_i_sv_2nrealloc	function
(	O
mach	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
mach	pointer
->	O
match_buf	pointer
,	O
&	O
mach	pointer
->	O
match_max	long
,	O
sizeof	O
(	O
mach	pointer
->	O
match_buf	pointer
[	O
0	int
]	O
)	O
)	O
;	O
mach	pointer
->	O
match_count	long
=	O
match_count	long
;	O
mu_sieve_free	function
(	O
mach	pointer
,	O
mach	pointer
->	O
match_string	pointer
)	O
;	O
mach	pointer
->	O
match_string	pointer
=	O
mu_sieve_strdup	function
(	O
mach	pointer
,	O
text	pointer
)	O
;	O
match_buf	pointer
=	O
mach	pointer
->	O
match_buf	pointer
;	O
}	O
return	O
regexec	function
(	O
reg	long
,	O
text	pointer
,	O
match_count	long
,	O
match_buf	pointer
,	O
0	int
)	O
==	O
0	int
;	O
}	O
static	O
int	O
i_octet_is	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
return	O
strcmp	function
(	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
,	O
text	pointer
)	O
==	O
0	int
;	O
}	O
static	O
int	O
i_octet_contains	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
return	O
strstr	function
(	O
text	pointer
,	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
)	O
!=	O
NULL	O
;	O
}	O
static	O
int	O
i_octet_matches	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
compile_wildcard	function
(	O
mach	pointer
,	O
pattern	pointer
,	O
0	int
)	O
;	O
return	O
regmatch	function
(	O
mach	pointer
,	O
pattern	pointer
,	O
text	pointer
)	O
;	O
}	O
static	O
int	O
i_octet_regex	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
compile_pattern	function
(	O
mach	pointer
,	O
pattern	pointer
,	O
0	int
)	O
;	O
return	O
regmatch	function
(	O
mach	pointer
,	O
pattern	pointer
,	O
text	pointer
)	O
;	O
}	O
static	O
int	O
i_octet_eq	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
return	O
strcmp	function
(	O
text	pointer
,	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
)	O
;	O
}	O
static	O
int	O
i_ascii_casemap_is	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
return	O
mu_c_strcasecmp	function
(	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
,	O
text	pointer
)	O
==	O
0	int
;	O
}	O
static	O
int	O
i_ascii_casemap_contains	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
return	O
mu_c_strcasestr	function
(	O
text	pointer
,	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
)	O
!=	O
NULL	O
;	O
}	O
static	O
int	O
i_ascii_casemap_matches	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
compile_wildcard	function
(	O
mach	pointer
,	O
pattern	pointer
,	O
MU_GLOBF_ICASE	int
)	O
;	O
return	O
regmatch	function
(	O
mach	pointer
,	O
pattern	pointer
,	O
text	pointer
)	O
;	O
}	O
static	O
int	O
i_ascii_casemap_regex	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
compile_pattern	function
(	O
mach	pointer
,	O
pattern	pointer
,	O
REG_ICASE	O
)	O
;	O
return	O
regmatch	function
(	O
mach	pointer
,	O
pattern	pointer
,	O
text	pointer
)	O
;	O
}	O
static	O
int	O
i_ascii_casemap_eq	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
return	O
mu_c_strcasecmp	function
(	O
text	pointer
,	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
)	O
;	O
}	O
static	O
int	O
i_ascii_numeric_is	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
char	O
*	O
str	pointer
=	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
;	O
if	O
(	O
mu_isdigit	O
(	O
*	O
str	pointer
)	O
)	O
{	O
if	O
(	O
mu_isdigit	O
(	O
*	O
text	pointer
)	O
)	O
return	O
strtol	function
(	O
str	pointer
,	O
NULL	O
,	O
10	int
)	O
==	O
strtol	function
(	O
text	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
mu_isdigit	O
(	O
*	O
text	pointer
)	O
)	O
return	O
0	int
;	O
else	O
return	O
1	int
;	O
}	O
static	O
int	O
i_ascii_numeric_eq	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
mu_sieve_string_t	struct
*	O
pattern	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
char	O
*	O
str	pointer
=	O
mu_sieve_string_get	function
(	O
mach	pointer
,	O
pattern	pointer
)	O
;	O
if	O
(	O
mu_isdigit	O
(	O
*	O
str	pointer
)	O
)	O
{	O
if	O
(	O
mu_isdigit	O
(	O
*	O
text	pointer
)	O
)	O
{	O
size_t	long
a	pointer
=	O
strtoul	function
(	O
str	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
size_t	long
b	pointer
=	O
strtoul	function
(	O
text	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
b	pointer
>	O
a	pointer
)	O
return	O
1	int
;	O
else	O
if	O
(	O
b	pointer
<	O
a	pointer
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
else	O
return	O
1	int
;	O
}	O
else	O
return	O
1	int
;	O
}	O
void	O
mu_i_sv_register_standard_comparators	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
mu_sieve_register_comparator	function
(	O
mach	pointer
,	O
"i;octet"	pointer
,	O
1	int
,	O
i_octet_is	function
,	O
i_octet_contains	function
,	O
i_octet_matches	function
,	O
i_octet_regex	function
,	O
i_octet_eq	function
)	O
;	O
mu_sieve_register_comparator	function
(	O
mach	pointer
,	O
"i;ascii-casemap"	pointer
,	O
1	int
,	O
i_ascii_casemap_is	function
,	O
i_ascii_casemap_contains	function
,	O
i_ascii_casemap_matches	function
,	O
i_ascii_casemap_regex	function
,	O
i_ascii_casemap_eq	function
)	O
;	O
mu_sieve_register_comparator	function
(	O
mach	pointer
,	O
"i;ascii-numeric"	pointer
,	O
0	int
,	O
i_ascii_numeric_is	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
i_ascii_numeric_eq	function
)	O
;	O
}	O
