static	O
struct	O
vfs_class	struct
vfs_tarfs_ops	struct
;	O
enum	O
{	O
TAR_UNKNOWN	int
=	O
0	int
,	O
TAR_V7	int
,	O
TAR_USTAR	int
,	O
TAR_POSIX	int
,	O
TAR_GNU	int
}	O
;	O
struct	O
sparse	struct
{	O
char	O
offset	long
[	O
12	int
]	O
;	O
char	O
numbytes	array
[	O
12	int
]	O
;	O
}	O
;	O
struct	O
sp_array	struct
{	O
int	O
offset	long
;	O
int	O
numbytes	array
;	O
}	O
;	O
union	O
record	union
{	O
char	O
charptr	array
[	O
RECORDSIZE	int
]	O
;	O
struct	O
header	pointer
{	O
char	O
arch_name	array
[	O
NAMSIZ	int
]	O
;	O
char	O
mode	int
[	O
8	int
]	O
;	O
char	O
uid	array
[	O
8	int
]	O
;	O
char	O
gid	array
[	O
8	int
]	O
;	O
char	O
size	long
[	O
12	int
]	O
;	O
char	O
mtime	array
[	O
12	int
]	O
;	O
char	O
chksum	array
[	O
8	int
]	O
;	O
char	O
linkflag	char
;	O
char	O
arch_linkname	array
[	O
NAMSIZ	int
]	O
;	O
char	O
magic	array
[	O
8	int
]	O
;	O
char	O
uname	array
[	O
TUNMLEN	int
]	O
;	O
char	O
gname	array
[	O
TGNMLEN	int
]	O
;	O
char	O
devmajor	array
[	O
8	int
]	O
;	O
char	O
devminor	array
[	O
8	int
]	O
;	O
union	O
unused	union
{	O
char	O
prefix	pointer
[	O
PREFIX_SIZE	int
]	O
;	O
struct	O
oldgnu	struct
{	O
char	O
atime	array
[	O
12	int
]	O
;	O
char	O
ctime	function
[	O
12	int
]	O
;	O
char	O
offset	long
[	O
12	int
]	O
;	O
char	O
longnames	array
[	O
4	int
]	O
;	O
char	O
pad	char
;	O
struct	O
sparse	struct
sp	array
[	O
SPARSE_IN_HDR	int
]	O
;	O
char	O
isextended	char
;	O
char	O
realsize	array
[	O
12	int
]	O
;	O
}	O
oldgnu	struct
;	O
}	O
unused	union
;	O
}	O
header	pointer
;	O
struct	O
extended_header	struct
{	O
struct	O
sparse	struct
sp	array
[	O
21	int
]	O
;	O
char	O
isextended	char
;	O
}	O
ext_hdr	struct
;	O
}	O
;	O
static	O
long	O
tar_from_oct	function
(	O
int	O
digs	int
,	O
char	O
*	O
where	pointer
)	O
{	O
register	O
long	O
value	pointer
;	O
while	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
where	pointer
)	O
)	O
{	O
where	pointer
++	O
;	O
if	O
(	O
--	O
digs	int
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
value	pointer
=	O
0	int
;	O
while	O
(	O
digs	int
>	O
0	int
&&	O
isodigit	O
(	O
*	O
where	pointer
)	O
)	O
{	O
value	pointer
=	O
(	O
value	pointer
<<	O
3	int
)	O
|	O
(	O
*	O
where	pointer
++	O
-	O
'0'	O
)	O
;	O
--	O
digs	int
;	O
}	O
if	O
(	O
digs	int
>	O
0	int
&&	O
*	O
where	pointer
&&	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
where	pointer
)	O
)	O
return	O
-	O
1	int
;	O
return	O
value	pointer
;	O
}	O
static	O
void	O
tar_free_archive	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
archive	pointer
)	O
{	O
(	O
void	O
)	O
me	pointer
;	O
if	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
!=	O
-	O
1	int
)	O
mc_close	function
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
)	O
;	O
}	O
static	O
int	O
current_tar_position	int
=	O
0	int
;	O
static	O
int	O
tar_open_archive_int	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
vfs_s_super	struct
*	O
archive	pointer
)	O
{	O
int	O
result	long
,	O
type	enum
;	O
mode_t	int
mode	int
;	O
struct	O
vfs_s_inode	struct
*	O
root	pointer
;	O
result	long
=	O
mc_open	function
(	O
name	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
result	long
==	O
-	O
1	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot open tar archive\n%s"	pointer
)	O
,	O
name	pointer
)	O
;	O
ERRNOR	O
(	O
ENOENT	int
,	O
-	O
1	int
)	O
;	O
}	O
archive	pointer
->	O
name	pointer
=	O
g_strdup	function
(	O
name	pointer
)	O
;	O
mc_stat	function
(	O
name	pointer
,	O
&	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
st	pointer
)	O
)	O
;	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
=	O
-	O
1	int
;	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
=	O
TAR_UNKNOWN	int
;	O
type	enum
=	O
get_compression_type	function
(	O
result	long
)	O
;	O
mc_lseek	function
(	O
result	long
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
type	enum
!=	O
COMPRESSION_NONE	int
)	O
{	O
char	O
*	O
s	pointer
;	O
mc_close	function
(	O
result	long
)	O
;	O
s	pointer
=	O
g_strconcat	function
(	O
archive	pointer
->	O
name	pointer
,	O
decompress_extension	function
(	O
type	enum
)	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
result	long
=	O
mc_open	function
(	O
s	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
result	long
==	O
-	O
1	int
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot open tar archive\n%s"	pointer
)	O
,	O
s	pointer
)	O
;	O
g_free	function
(	O
s	pointer
)	O
;	O
if	O
(	O
result	long
==	O
-	O
1	int
)	O
ERRNOR	O
(	O
ENOENT	int
,	O
-	O
1	int
)	O
;	O
}	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
fd	int
=	O
result	long
;	O
mode	int
=	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
st	pointer
.	O
st_mode	int
&	O
07777	int
;	O
if	O
(	O
mode	int
&	O
0400	int
)	O
mode	int
|=	O
0100	int
;	O
if	O
(	O
mode	int
&	O
0040	int
)	O
mode	int
|=	O
0010	int
;	O
if	O
(	O
mode	int
&	O
0004	int
)	O
mode	int
|=	O
0001	int
;	O
mode	int
|=	O
S_IFDIR	O
;	O
root	pointer
=	O
vfs_s_new_inode	function
(	O
me	pointer
,	O
archive	pointer
,	O
&	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
st	pointer
)	O
;	O
root	pointer
->	O
st	pointer
.	O
st_mode	int
=	O
mode	int
;	O
root	pointer
->	O
data_offset	long
=	O
-	O
1	int
;	O
root	pointer
->	O
st	pointer
.	O
st_nlink	long
++	O
;	O
root	pointer
->	O
st	pointer
.	O
st_dev	long
=	O
MEDATA	O
->	O
rdev	long
++	O
;	O
archive	pointer
->	O
root	pointer
=	O
root	pointer
;	O
return	O
result	long
;	O
}	O
static	O
union	O
record	union
rec_buf	union
;	O
static	O
union	O
record	union
*	O
tar_get_next_record	function
(	O
struct	O
vfs_s_super	struct
*	O
archive	pointer
,	O
int	O
tard	int
)	O
{	O
int	O
n	long
;	O
(	O
void	O
)	O
archive	pointer
;	O
n	long
=	O
mc_read	function
(	O
tard	int
,	O
rec_buf	union
.	O
charptr	array
,	O
RECORDSIZE	int
)	O
;	O
if	O
(	O
n	long
!=	O
RECORDSIZE	int
)	O
return	O
NULL	O
;	O
current_tar_position	int
+=	O
RECORDSIZE	int
;	O
return	O
&	O
rec_buf	union
;	O
}	O
static	O
void	O
tar_skip_n_records	function
(	O
struct	O
vfs_s_super	struct
*	O
archive	pointer
,	O
int	O
tard	int
,	O
int	O
n	long
)	O
{	O
(	O
void	O
)	O
archive	pointer
;	O
mc_lseek	function
(	O
tard	int
,	O
n	long
*	O
RECORDSIZE	int
,	O
SEEK_CUR	int
)	O
;	O
current_tar_position	int
+=	O
n	long
*	O
RECORDSIZE	int
;	O
}	O
static	O
void	O
tar_fill_stat	function
(	O
struct	O
vfs_s_super	struct
*	O
archive	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
,	O
union	O
record	union
*	O
header	pointer
,	O
size_t	long
h_size	long
)	O
{	O
st	pointer
->	O
st_mode	int
=	O
tar_from_oct	function
(	O
8	int
,	O
header	pointer
->	O
header	pointer
.	O
mode	int
)	O
;	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_DIR	char
)	O
{	O
st	pointer
->	O
st_mode	int
|=	O
S_IFDIR	O
;	O
}	O
else	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_SYMLINK	char
)	O
{	O
st	pointer
->	O
st_mode	int
|=	O
S_IFLNK	O
;	O
}	O
else	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_CHR	char
)	O
{	O
st	pointer
->	O
st_mode	int
|=	O
S_IFCHR	O
;	O
}	O
else	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_BLK	char
)	O
{	O
st	pointer
->	O
st_mode	int
|=	O
S_IFBLK	O
;	O
}	O
else	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_FIFO	char
)	O
{	O
st	pointer
->	O
st_mode	int
|=	O
S_IFIFO	O
;	O
}	O
else	O
st	pointer
->	O
st_mode	int
|=	O
S_IFREG	O
;	O
st	pointer
->	O
st_rdev	long
=	O
0	int
;	O
switch	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
)	O
{	O
case	O
TAR_USTAR	int
:	O
case	O
TAR_POSIX	int
:	O
case	O
TAR_GNU	int
:	O
st	pointer
->	O
st_uid	int
=	O
*	O
header	pointer
->	O
header	pointer
.	O
uname	array
?	O
vfs_finduid	function
(	O
header	pointer
->	O
header	pointer
.	O
uname	array
)	O
:	O
tar_from_oct	function
(	O
8	int
,	O
header	pointer
->	O
header	pointer
.	O
uid	array
)	O
;	O
st	pointer
->	O
st_gid	int
=	O
*	O
header	pointer
->	O
header	pointer
.	O
gname	array
?	O
vfs_findgid	function
(	O
header	pointer
->	O
header	pointer
.	O
gname	array
)	O
:	O
tar_from_oct	function
(	O
8	int
,	O
header	pointer
->	O
header	pointer
.	O
gid	array
)	O
;	O
switch	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
)	O
{	O
case	O
LF_BLK	char
:	O
case	O
LF_CHR	char
:	O
st	pointer
->	O
st_rdev	long
=	O
(	O
tar_from_oct	function
(	O
8	int
,	O
header	pointer
->	O
header	pointer
.	O
devmajor	array
)	O
<<	O
8	int
)	O
|	O
tar_from_oct	function
(	O
8	int
,	O
header	pointer
->	O
header	pointer
.	O
devminor	array
)	O
;	O
}	O
default	O
:	O
st	pointer
->	O
st_uid	int
=	O
tar_from_oct	function
(	O
8	int
,	O
header	pointer
->	O
header	pointer
.	O
uid	array
)	O
;	O
st	pointer
->	O
st_gid	int
=	O
tar_from_oct	function
(	O
8	int
,	O
header	pointer
->	O
header	pointer
.	O
gid	array
)	O
;	O
}	O
st	pointer
->	O
st_size	long
=	O
h_size	long
;	O
st	pointer
->	O
st_mtime	O
=	O
tar_from_oct	function
(	O
1	int
+	O
12	int
,	O
header	pointer
->	O
header	pointer
.	O
mtime	array
)	O
;	O
st	pointer
->	O
st_atime	O
=	O
0	int
;	O
st	pointer
->	O
st_ctime	O
=	O
0	int
;	O
if	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
TAR_GNU	int
)	O
{	O
st	pointer
->	O
st_atime	O
=	O
tar_from_oct	function
(	O
1	int
+	O
12	int
,	O
header	pointer
->	O
header	pointer
.	O
unused	union
.	O
oldgnu	struct
.	O
atime	array
)	O
;	O
st	pointer
->	O
st_ctime	O
=	O
tar_from_oct	function
(	O
1	int
+	O
12	int
,	O
header	pointer
->	O
header	pointer
.	O
unused	union
.	O
oldgnu	struct
.	O
ctime	function
)	O
;	O
}	O
}	O
typedef	O
enum	O
{	O
STATUS_BADCHECKSUM	int
,	O
STATUS_SUCCESS	int
,	O
STATUS_EOFMARK	int
,	O
STATUS_EOF	int
}	O
ReadStatus	enum
;	O
static	O
ReadStatus	enum
tar_read_header	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
archive	pointer
,	O
int	O
tard	int
,	O
size_t	long
*	O
h_size	long
)	O
{	O
register	O
int	O
i	array
;	O
register	O
long	O
sum	long
,	O
signed_sum	long
,	O
recsum	long
;	O
register	O
char	O
*	O
p	pointer
;	O
register	O
union	O
record	union
*	O
header	pointer
;	O
static	O
char	O
*	O
next_long_name	pointer
=	O
NULL	O
,	O
*	O
next_long_link	pointer
=	O
NULL	O
;	O
recurse	O
:	O
header	pointer
=	O
tar_get_next_record	function
(	O
archive	pointer
,	O
tard	int
)	O
;	O
if	O
(	O
NULL	O
==	O
header	pointer
)	O
return	O
STATUS_EOF	int
;	O
recsum	long
=	O
tar_from_oct	function
(	O
8	int
,	O
header	pointer
->	O
header	pointer
.	O
chksum	array
)	O
;	O
sum	long
=	O
0	int
;	O
signed_sum	long
=	O
0	int
;	O
p	pointer
=	O
header	pointer
->	O
charptr	array
;	O
for	O
(	O
i	array
=	O
sizeof	O
(	O
*	O
header	pointer
)	O
;	O
--	O
i	array
>=	O
0	int
;	O
)	O
{	O
signed_sum	long
+=	O
*	O
p	pointer
;	O
sum	long
+=	O
0xFF	int
&	O
*	O
p	pointer
++	O
;	O
}	O
for	O
(	O
i	array
=	O
sizeof	O
(	O
header	pointer
->	O
header	pointer
.	O
chksum	array
)	O
;	O
--	O
i	array
>=	O
0	int
;	O
)	O
{	O
sum	long
-=	O
0xFF	int
&	O
header	pointer
->	O
header	pointer
.	O
chksum	array
[	O
i	array
]	O
;	O
signed_sum	long
-=	O
(	O
char	O
)	O
header	pointer
->	O
header	pointer
.	O
chksum	array
[	O
i	array
]	O
;	O
}	O
sum	long
+=	O
' '	O
*	O
sizeof	O
header	pointer
->	O
header	pointer
.	O
chksum	array
;	O
signed_sum	long
+=	O
' '	O
*	O
sizeof	O
header	pointer
->	O
header	pointer
.	O
chksum	array
;	O
if	O
(	O
sum	long
==	O
8	int
*	O
' '	O
)	O
return	O
STATUS_EOFMARK	int
;	O
if	O
(	O
sum	long
!=	O
recsum	long
&&	O
signed_sum	long
!=	O
recsum	long
)	O
return	O
STATUS_BADCHECKSUM	int
;	O
if	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
TAR_UNKNOWN	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
header	pointer
->	O
header	pointer
.	O
magic	array
,	O
TMAGIC	pointer
)	O
)	O
{	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_GLOBAL_EXTHDR	char
)	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
=	O
TAR_POSIX	int
;	O
else	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
=	O
TAR_USTAR	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
header	pointer
->	O
header	pointer
.	O
magic	array
,	O
OLDGNU_MAGIC	pointer
)	O
)	O
{	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
=	O
TAR_GNU	int
;	O
}	O
}	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
'\000'	O
)	O
{	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
arch_name	array
[	O
NAMSIZ	int
-	O
1	int
]	O
!=	O
'\0'	O
)	O
i	array
=	O
NAMSIZ	int
;	O
else	O
i	array
=	O
strlen	function
(	O
header	pointer
->	O
header	pointer
.	O
arch_name	array
)	O
;	O
if	O
(	O
i	array
&&	O
header	pointer
->	O
header	pointer
.	O
arch_name	array
[	O
i	array
-	O
1	int
]	O
==	O
'/'	O
)	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
=	O
LF_DIR	char
;	O
}	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_LINK	char
||	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_DIR	char
)	O
*	O
h_size	long
=	O
0	int
;	O
else	O
*	O
h_size	long
=	O
tar_from_oct	function
(	O
1	int
+	O
12	int
,	O
header	pointer
->	O
header	pointer
.	O
size	long
)	O
;	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_DUMPDIR	char
)	O
{	O
if	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
TAR_UNKNOWN	int
)	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
=	O
TAR_GNU	int
;	O
return	O
STATUS_SUCCESS	int
;	O
}	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_EXTHDR	char
||	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_GLOBAL_EXTHDR	char
)	O
{	O
if	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
TAR_UNKNOWN	int
)	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
=	O
TAR_POSIX	int
;	O
return	O
STATUS_SUCCESS	int
;	O
}	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_LONGNAME	char
||	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_LONGLINK	char
)	O
{	O
char	O
*	O
*	O
longp	pointer
;	O
char	O
*	O
bp	pointer
,	O
*	O
data	pointer
;	O
int	O
size	long
,	O
written	int
;	O
if	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
TAR_UNKNOWN	int
)	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
=	O
TAR_GNU	int
;	O
if	O
(	O
*	O
h_size	long
>	O
MC_MAXPATHLEN	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Inconsistent tar archive"	pointer
)	O
)	O
;	O
return	O
STATUS_BADCHECKSUM	int
;	O
}	O
longp	pointer
=	O
(	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_LONGNAME	char
)	O
?	O
&	O
next_long_name	pointer
:	O
&	O
next_long_link	pointer
)	O
;	O
g_free	function
(	O
*	O
longp	pointer
)	O
;	O
bp	pointer
=	O
*	O
longp	pointer
=	O
g_malloc	function
(	O
*	O
h_size	long
+	O
1	int
)	O
;	O
for	O
(	O
size	long
=	O
*	O
h_size	long
;	O
size	long
>	O
0	int
;	O
size	long
-=	O
written	int
)	O
{	O
data	pointer
=	O
tar_get_next_record	function
(	O
archive	pointer
,	O
tard	int
)	O
->	O
charptr	array
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
{	O
g_free	function
(	O
*	O
longp	pointer
)	O
;	O
*	O
longp	pointer
=	O
NULL	O
;	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Unexpected EOF on archive file"	pointer
)	O
)	O
;	O
return	O
STATUS_BADCHECKSUM	int
;	O
}	O
written	int
=	O
RECORDSIZE	int
;	O
if	O
(	O
written	int
>	O
size	long
)	O
written	int
=	O
size	long
;	O
memcpy	function
(	O
bp	pointer
,	O
data	pointer
,	O
written	int
)	O
;	O
bp	pointer
+=	O
written	int
;	O
}	O
if	O
(	O
bp	pointer
-	O
*	O
longp	pointer
==	O
MC_MAXPATHLEN	O
&&	O
bp	pointer
[	O
-	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
g_free	function
(	O
*	O
longp	pointer
)	O
;	O
*	O
longp	pointer
=	O
NULL	O
;	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Inconsistent tar archive"	pointer
)	O
)	O
;	O
return	O
STATUS_BADCHECKSUM	int
;	O
}	O
*	O
bp	pointer
=	O
0	int
;	O
goto	O
recurse	O
;	O
}	O
else	O
{	O
struct	O
stat	struct
st	pointer
;	O
struct	O
vfs_s_entry	struct
*	O
entry	pointer
;	O
struct	O
vfs_s_inode	struct
*	O
inode	pointer
,	O
*	O
parent	pointer
;	O
long	O
data_position	long
;	O
char	O
*	O
q	pointer
;	O
int	O
len	int
;	O
char	O
*	O
current_file_name	pointer
,	O
*	O
current_link_name	pointer
;	O
current_link_name	pointer
=	O
(	O
next_long_link	pointer
?	O
next_long_link	pointer
:	O
g_strndup	function
(	O
header	pointer
->	O
header	pointer
.	O
arch_linkname	array
,	O
NAMSIZ	int
)	O
)	O
;	O
len	int
=	O
strlen	function
(	O
current_link_name	pointer
)	O
;	O
if	O
(	O
len	int
>	O
1	int
&&	O
current_link_name	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'/'	O
)	O
current_link_name	pointer
[	O
len	int
-	O
1	int
]	O
=	O
0	int
;	O
current_file_name	pointer
=	O
NULL	O
;	O
switch	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
)	O
{	O
case	O
TAR_USTAR	int
:	O
case	O
TAR_POSIX	int
:	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
unused	union
.	O
prefix	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
char	O
*	O
temp_name	pointer
,	O
*	O
temp_prefix	pointer
;	O
temp_name	pointer
=	O
g_strndup	function
(	O
header	pointer
->	O
header	pointer
.	O
arch_name	array
,	O
NAMSIZ	int
)	O
;	O
temp_prefix	pointer
=	O
g_strndup	function
(	O
header	pointer
->	O
header	pointer
.	O
unused	union
.	O
prefix	pointer
,	O
PREFIX_SIZE	int
)	O
;	O
current_file_name	pointer
=	O
g_strconcat	function
(	O
temp_prefix	pointer
,	O
PATH_SEP_STR	pointer
,	O
temp_name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
temp_name	pointer
)	O
;	O
g_free	function
(	O
temp_prefix	pointer
)	O
;	O
}	O
break	O
;	O
case	O
TAR_GNU	int
:	O
if	O
(	O
next_long_name	pointer
!=	O
NULL	O
)	O
current_file_name	pointer
=	O
next_long_name	pointer
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
current_file_name	pointer
==	O
NULL	O
)	O
current_file_name	pointer
=	O
g_strndup	function
(	O
header	pointer
->	O
header	pointer
.	O
arch_name	array
,	O
NAMSIZ	int
)	O
;	O
canonicalize_pathname	function
(	O
current_file_name	pointer
)	O
;	O
len	int
=	O
strlen	function
(	O
current_file_name	pointer
)	O
;	O
data_position	long
=	O
current_tar_position	int
;	O
p	pointer
=	O
strrchr	function
(	O
current_file_name	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
p	pointer
=	O
current_file_name	pointer
;	O
q	pointer
=	O
current_file_name	pointer
+	O
len	int
;	O
}	O
else	O
{	O
*	O
(	O
p	pointer
++	O
)	O
=	O
0	int
;	O
q	pointer
=	O
current_file_name	pointer
;	O
}	O
parent	pointer
=	O
vfs_s_find_inode	function
(	O
me	pointer
,	O
archive	pointer
,	O
q	pointer
,	O
LINK_NO_FOLLOW	O
,	O
FL_MKDIR	int
)	O
;	O
if	O
(	O
parent	pointer
==	O
NULL	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Inconsistent tar archive"	pointer
)	O
)	O
;	O
return	O
STATUS_BADCHECKSUM	int
;	O
}	O
if	O
(	O
header	pointer
->	O
header	pointer
.	O
linkflag	char
==	O
LF_LINK	char
)	O
{	O
inode	pointer
=	O
vfs_s_find_inode	function
(	O
me	pointer
,	O
archive	pointer
,	O
current_link_name	pointer
,	O
LINK_NO_FOLLOW	O
,	O
0	int
)	O
;	O
if	O
(	O
inode	pointer
==	O
NULL	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Inconsistent tar archive"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
entry	pointer
=	O
vfs_s_new_entry	function
(	O
me	pointer
,	O
p	pointer
,	O
inode	pointer
)	O
;	O
vfs_s_insert_entry	function
(	O
me	pointer
,	O
parent	pointer
,	O
entry	pointer
)	O
;	O
g_free	function
(	O
current_link_name	pointer
)	O
;	O
goto	O
done	pointer
;	O
}	O
}	O
tar_fill_stat	function
(	O
archive	pointer
,	O
&	O
st	pointer
,	O
header	pointer
,	O
*	O
h_size	long
)	O
;	O
inode	pointer
=	O
vfs_s_new_inode	function
(	O
me	pointer
,	O
archive	pointer
,	O
&	O
st	pointer
)	O
;	O
inode	pointer
->	O
data_offset	long
=	O
data_position	long
;	O
if	O
(	O
*	O
current_link_name	pointer
)	O
{	O
inode	pointer
->	O
linkname	pointer
=	O
current_link_name	pointer
;	O
}	O
else	O
if	O
(	O
current_link_name	pointer
!=	O
next_long_link	pointer
)	O
{	O
g_free	function
(	O
current_link_name	pointer
)	O
;	O
}	O
entry	pointer
=	O
vfs_s_new_entry	function
(	O
me	pointer
,	O
p	pointer
,	O
inode	pointer
)	O
;	O
vfs_s_insert_entry	function
(	O
me	pointer
,	O
parent	pointer
,	O
entry	pointer
)	O
;	O
g_free	function
(	O
current_file_name	pointer
)	O
;	O
done	pointer
:	O
next_long_link	pointer
=	O
next_long_name	pointer
=	O
NULL	O
;	O
if	O
(	O
archive	pointer
->	O
u	union
.	O
arch	struct
.	O
type	enum
==	O
TAR_GNU	int
&&	O
header	pointer
->	O
header	pointer
.	O
unused	union
.	O
oldgnu	struct
.	O
isextended	char
)	O
{	O
while	O
(	O
tar_get_next_record	function
(	O
archive	pointer
,	O
tard	int
)	O
->	O
ext_hdr	struct
.	O
isextended	char
)	O
;	O
inode	pointer
->	O
data_offset	long
=	O
current_tar_position	int
;	O
}	O
return	O
STATUS_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
tar_open_archive	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
archive	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
char	O
*	O
op	pointer
)	O
{	O
ReadStatus	enum
status	int
=	O
STATUS_EOFMARK	int
;	O
ReadStatus	enum
prev_status	enum
;	O
int	O
tard	int
;	O
(	O
void	O
)	O
op	pointer
;	O
current_tar_position	int
=	O
0	int
;	O
if	O
(	O
(	O
tard	int
=	O
tar_open_archive_int	function
(	O
me	pointer
,	O
name	pointer
,	O
archive	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
h_size	long
;	O
prev_status	enum
=	O
status	int
;	O
status	int
=	O
tar_read_header	function
(	O
me	pointer
,	O
archive	pointer
,	O
tard	int
,	O
&	O
h_size	long
)	O
;	O
switch	O
(	O
status	int
)	O
{	O
case	O
STATUS_SUCCESS	int
:	O
tar_skip_n_records	function
(	O
archive	pointer
,	O
tard	int
,	O
(	O
h_size	long
+	O
RECORDSIZE	int
-	O
1	int
)	O
/	O
RECORDSIZE	int
)	O
;	O
continue	O
;	O
case	O
STATUS_BADCHECKSUM	int
:	O
switch	O
(	O
prev_status	enum
)	O
{	O
case	O
STATUS_EOFMARK	int
:	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Hmm,...\n%s\ndoesn't look like a tar archive."	pointer
)	O
,	O
name	pointer
)	O
;	O
case	O
STATUS_SUCCESS	int
:	O
case	O
STATUS_BADCHECKSUM	int
:	O
return	O
-	O
1	int
;	O
case	O
STATUS_EOF	int
:	O
return	O
0	int
;	O
}	O
case	O
STATUS_EOFMARK	int
:	O
status	int
=	O
prev_status	enum
;	O
case	O
STATUS_EOF	int
:	O
break	O
;	O
}	O
break	O
;	O
}	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
*	O
tar_super_check	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
archive_name	pointer
,	O
char	O
*	O
op	pointer
)	O
{	O
static	O
struct	O
stat	struct
stat_buf	struct
;	O
(	O
void	O
)	O
me	pointer
;	O
(	O
void	O
)	O
op	pointer
;	O
if	O
(	O
mc_stat	function
(	O
archive_name	pointer
,	O
&	O
stat_buf	struct
)	O
)	O
return	O
NULL	O
;	O
return	O
&	O
stat_buf	struct
;	O
}	O
static	O
int	O
tar_super_same	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
parc	pointer
,	O
const	O
char	O
*	O
archive_name	pointer
,	O
char	O
*	O
op	pointer
,	O
void	O
*	O
cookie	pointer
)	O
{	O
struct	O
stat	struct
*	O
archive_stat	pointer
=	O
cookie	pointer
;	O
(	O
void	O
)	O
me	pointer
;	O
(	O
void	O
)	O
op	pointer
;	O
if	O
(	O
strcmp	function
(	O
parc	pointer
->	O
name	pointer
,	O
archive_name	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
parc	pointer
->	O
u	union
.	O
arch	struct
.	O
st	pointer
.	O
st_mtime	O
<	O
archive_stat	pointer
->	O
st_mtime	O
)	O
{	O
(	O
*	O
vfs_tarfs_ops	struct
.	O
free	function
)	O
(	O
(	O
vfsid	pointer
)	O
parc	pointer
)	O
;	O
vfs_rmstamp	function
(	O
&	O
vfs_tarfs_ops	struct
,	O
(	O
vfsid	pointer
)	O
parc	pointer
)	O
;	O
return	O
2	int
;	O
}	O
vfs_stamp	function
(	O
&	O
vfs_tarfs_ops	struct
,	O
(	O
vfsid	pointer
)	O
parc	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
tar_read	function
(	O
void	O
*	O
fh	pointer
,	O
char	O
*	O
buffer	pointer
,	O
int	O
count	int
)	O
{	O
off_t	long
begin	pointer
=	O
FH	O
->	O
ino	pointer
->	O
data_offset	long
;	O
int	O
fd	int
=	O
FH_SUPER	O
->	O
u	union
.	O
arch	struct
.	O
fd	int
;	O
struct	O
vfs_class	struct
*	O
me	pointer
=	O
FH_SUPER	O
->	O
me	pointer
;	O
if	O
(	O
mc_lseek	function
(	O
fd	int
,	O
begin	pointer
+	O
FH	O
->	O
pos	pointer
,	O
SEEK_SET	int
)	O
!=	O
begin	pointer
+	O
FH	O
->	O
pos	pointer
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
count	int
=	O
MIN	O
(	O
count	int
,	O
FH	O
->	O
ino	pointer
->	O
st	pointer
.	O
st_size	long
-	O
FH	O
->	O
pos	pointer
)	O
;	O
if	O
(	O
(	O
count	int
=	O
mc_read	function
(	O
fd	int
,	O
buffer	pointer
,	O
count	int
)	O
)	O
==	O
-	O
1	int
)	O
ERRNOR	O
(	O
errno	O
,	O
-	O
1	int
)	O
;	O
FH	O
->	O
pos	pointer
+=	O
count	int
;	O
return	O
count	int
;	O
}	O
static	O
int	O
tar_fh_open	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
,	O
int	O
flags	enum
,	O
int	O
mode	int
)	O
{	O
(	O
void	O
)	O
fh	pointer
;	O
(	O
void	O
)	O
mode	int
;	O
if	O
(	O
(	O
flags	enum
&	O
O_ACCMODE	int
)	O
!=	O
O_RDONLY	int
)	O
ERRNOR	O
(	O
EROFS	int
,	O
-	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
init_tarfs	function
(	O
void	O
)	O
{	O
static	O
struct	O
vfs_s_subclass	struct
tarfs_subclass	struct
;	O
tarfs_subclass	struct
.	O
flags	enum
=	O
VFS_S_READONLY	int
;	O
tarfs_subclass	struct
.	O
archive_check	pointer
=	O
tar_super_check	function
;	O
tarfs_subclass	struct
.	O
archive_same	pointer
=	O
tar_super_same	function
;	O
tarfs_subclass	struct
.	O
open_archive	pointer
=	O
tar_open_archive	function
;	O
tarfs_subclass	struct
.	O
free_archive	pointer
=	O
tar_free_archive	function
;	O
tarfs_subclass	struct
.	O
fh_open	pointer
=	O
tar_fh_open	function
;	O
vfs_s_init_class	function
(	O
&	O
vfs_tarfs_ops	struct
,	O
&	O
tarfs_subclass	struct
)	O
;	O
vfs_tarfs_ops	struct
.	O
name	pointer
=	O
"tarfs"	pointer
;	O
vfs_tarfs_ops	struct
.	O
prefix	pointer
=	O
"utar"	pointer
;	O
vfs_tarfs_ops	struct
.	O
read	function
=	O
tar_read	function
;	O
vfs_tarfs_ops	struct
.	O
setctl	pointer
=	O
NULL	O
;	O
vfs_register_class	function
(	O
&	O
vfs_tarfs_ops	struct
)	O
;	O
}	O
