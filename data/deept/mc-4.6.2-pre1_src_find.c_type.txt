static	O
int	O
FIND_X	int
=	O
50	int
;	O
static	O
int	O
FIND2_X	int
=	O
64	int
;	O
enum	O
{	O
B_STOP	int
=	O
B_USER	int
+	O
1	int
,	O
B_AGAIN	int
,	O
B_PANELIZE	int
,	O
B_TREE	int
,	O
B_VIEW	int
}	O
;	O
typedef	O
enum	O
{	O
FIND_CONT	int
,	O
FIND_SUSPEND	int
,	O
FIND_ABORT	int
}	O
FindProgressStatus	enum
;	O
char	O
*	O
find_ignore_dirs	pointer
=	O
0	int
;	O
static	O
WInput	struct
*	O
in_start	pointer
;	O
static	O
WInput	struct
*	O
in_name	pointer
;	O
static	O
WInput	struct
*	O
in_with	pointer
;	O
static	O
WCheck	struct
*	O
case_sense	pointer
;	O
static	O
WCheck	struct
*	O
find_regex_cbox	pointer
;	O
static	O
int	O
running	int
=	O
0	int
;	O
static	O
char	O
*	O
find_pattern	pointer
;	O
static	O
char	O
*	O
content_pattern	pointer
;	O
static	O
int	O
count	int
;	O
static	O
int	O
matches	int
;	O
static	O
int	O
is_start	int
;	O
static	O
char	O
*	O
old_dir	pointer
;	O
static	O
int	O
resuming	int
;	O
static	O
int	O
last_line	int
;	O
static	O
int	O
last_pos	int
;	O
static	O
Dlg_head	struct
*	O
find_dlg	pointer
;	O
static	O
WButton	struct
*	O
stop_button	pointer
;	O
static	O
WLabel	struct
*	O
status_label	pointer
;	O
static	O
WListbox	struct
*	O
find_list	pointer
;	O
typedef	O
struct	O
dir_stack	struct
{	O
char	O
*	O
name	pointer
;	O
struct	O
dir_stack	struct
*	O
prev	pointer
;	O
}	O
dir_stack	struct
;	O
static	O
dir_stack	struct
*	O
dir_stack_base	pointer
=	O
0	int
;	O
static	O
struct	O
{	O
const	O
char	O
*	O
text	pointer
;	O
int	O
len	int
;	O
int	O
x	array
;	O
}	O
fbuts	array
[	O
]	O
=	O
{	O
{	O
N_	O
(	O
"&Suspend"	pointer
)	O
,	O
11	int
,	O
29	int
}	O
,	O
{	O
N_	O
(	O
"Con&tinue"	pointer
)	O
,	O
12	int
,	O
29	int
}	O
,	O
{	O
N_	O
(	O
"&Chdir"	pointer
)	O
,	O
11	int
,	O
3	int
}	O
,	O
{	O
N_	O
(	O
"&Again"	pointer
)	O
,	O
9	int
,	O
17	int
}	O
,	O
{	O
N_	O
(	O
"&Quit"	pointer
)	O
,	O
8	int
,	O
43	int
}	O
,	O
{	O
N_	O
(	O
"Pane&lize"	pointer
)	O
,	O
12	int
,	O
3	int
}	O
,	O
{	O
N_	O
(	O
"&View - F3"	pointer
)	O
,	O
13	int
,	O
20	int
}	O
,	O
{	O
N_	O
(	O
"&Edit - F4"	pointer
)	O
,	O
13	int
,	O
38	int
}	O
}	O
;	O
static	O
inline	O
char	O
*	O
add_to_list	function
(	O
const	O
char	O
*	O
text	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
return	O
listbox_add_item	function
(	O
find_list	pointer
,	O
0	int
,	O
0	int
,	O
text	pointer
,	O
data	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
stop_idle	function
(	O
void	O
*	O
data	pointer
)	O
{	O
set_idle_proc	function
(	O
data	pointer
,	O
0	int
)	O
;	O
}	O
static	O
inline	O
void	O
status_update	function
(	O
const	O
char	O
*	O
text	pointer
)	O
{	O
label_set_text	function
(	O
status_label	pointer
,	O
text	pointer
)	O
;	O
}	O
static	O
void	O
get_list_info	function
(	O
char	O
*	O
*	O
file	pointer
,	O
char	O
*	O
*	O
dir	pointer
)	O
{	O
listbox_get_current	function
(	O
find_list	pointer
,	O
file	pointer
,	O
dir	pointer
)	O
;	O
}	O
static	O
regex_t	struct
*	O
r	pointer
;	O
static	O
int	O
case_sensitive	int
=	O
1	int
;	O
static	O
gboolean	int
find_regex_flag	int
=	O
TRUE	O
;	O
static	O
int	O
find_recursively	int
=	O
1	int
;	O
static	O
cb_ret_t	enum
find_parm_callback	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
int	O
flags	enum
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_VALIDATE	int
:	O
if	O
(	O
(	O
h	pointer
->	O
ret_value	int
!=	O
B_ENTER	int
)	O
||	O
!	O
in_with	pointer
->	O
buffer	pointer
[	O
0	int
]	O
||	O
!	O
(	O
find_regex_cbox	pointer
->	O
state	pointer
&	O
C_BOOL	int
)	O
)	O
return	O
MSG_HANDLED	int
;	O
flags	enum
=	O
REG_EXTENDED	int
|	O
REG_NOSUB	O
;	O
if	O
(	O
!	O
(	O
case_sense	pointer
->	O
state	pointer
&	O
C_BOOL	int
)	O
)	O
flags	enum
|=	O
REG_ICASE	O
;	O
if	O
(	O
regcomp	function
(	O
r	pointer
,	O
in_with	pointer
->	O
buffer	pointer
,	O
flags	enum
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"  Malformed regular expression  "	pointer
)	O
)	O
;	O
dlg_select_widget	function
(	O
in_with	pointer
)	O
;	O
h	pointer
->	O
running	int
=	O
1	int
;	O
}	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
find_parameters	function
(	O
char	O
*	O
*	O
start_dir	pointer
,	O
char	O
*	O
*	O
pattern	pointer
,	O
char	O
*	O
*	O
content	pointer
)	O
{	O
int	O
return_value	int
;	O
char	O
*	O
temp_dir	pointer
;	O
static	O
const	O
char	O
*	O
case_label	pointer
=	O
N_	O
(	O
"case &Sensitive"	pointer
)	O
;	O
static	O
const	O
char	O
*	O
recurs_label	pointer
=	O
N_	O
(	O
"find Re&cursively"	pointer
)	O
;	O
WCheck	struct
*	O
recursively_cbox	pointer
;	O
static	O
char	O
*	O
in_contents	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
in_start_dir	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
in_start_name	pointer
=	O
NULL	O
;	O
static	O
const	O
char	O
*	O
labs	function
[	O
]	O
=	O
{	O
N_	O
(	O
"Start at:"	pointer
)	O
,	O
N_	O
(	O
"Filename:"	pointer
)	O
,	O
N_	O
(	O
"Content: "	pointer
)	O
}	O
;	O
static	O
const	O
char	O
*	O
buts	array
[	O
]	O
=	O
{	O
N_	O
(	O
"&OK"	pointer
)	O
,	O
N_	O
(	O
"&Tree"	pointer
)	O
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
}	O
;	O
static	O
int	O
ilen	int
=	O
30	int
,	O
istart	int
=	O
14	int
;	O
static	O
int	O
b0	int
=	O
3	int
,	O
b1	int
=	O
16	int
,	O
b2	int
=	O
36	int
;	O
static	O
int	O
i18n_flag	int
=	O
0	int
;	O
if	O
(	O
!	O
i18n_flag	int
)	O
{	O
register	O
int	O
i	array
=	O
sizeof	O
(	O
labs	function
)	O
/	O
sizeof	O
(	O
labs	function
[	O
0	int
]	O
)	O
;	O
int	O
l1	int
,	O
maxlen	int
=	O
0	int
;	O
while	O
(	O
i	array
--	O
)	O
{	O
l1	int
=	O
strlen	function
(	O
labs	function
[	O
i	array
]	O
=	O
_	O
(	O
labs	function
[	O
i	array
]	O
)	O
)	O
;	O
if	O
(	O
l1	int
>	O
maxlen	int
)	O
maxlen	int
=	O
l1	int
;	O
}	O
i	array
=	O
maxlen	int
+	O
ilen	int
+	O
7	int
;	O
if	O
(	O
i	array
>	O
FIND_X	int
)	O
FIND_X	int
=	O
i	array
;	O
for	O
(	O
i	array
=	O
sizeof	O
(	O
buts	array
)	O
/	O
sizeof	O
(	O
buts	array
[	O
0	int
]	O
)	O
,	O
l1	int
=	O
0	int
;	O
i	array
--	O
;	O
)	O
{	O
l1	int
+=	O
strlen	function
(	O
buts	array
[	O
i	array
]	O
=	O
_	O
(	O
buts	array
[	O
i	array
]	O
)	O
)	O
;	O
}	O
l1	int
+=	O
21	int
;	O
if	O
(	O
l1	int
>	O
FIND_X	int
)	O
FIND_X	int
=	O
l1	int
;	O
ilen	int
=	O
FIND_X	int
-	O
7	int
-	O
maxlen	int
;	O
istart	int
=	O
FIND_X	int
-	O
3	int
-	O
ilen	int
;	O
b1	int
=	O
b0	int
+	O
strlen	function
(	O
buts	array
[	O
0	int
]	O
)	O
+	O
7	int
;	O
b2	int
=	O
FIND_X	int
-	O
(	O
strlen	function
(	O
buts	array
[	O
2	int
]	O
)	O
+	O
6	int
)	O
;	O
i18n_flag	int
=	O
1	int
;	O
case_label	pointer
=	O
_	O
(	O
case_label	pointer
)	O
;	O
recurs_label	pointer
=	O
_	O
(	O
recurs_label	pointer
)	O
;	O
}	O
find_par_start	O
:	O
if	O
(	O
!	O
in_start_dir	pointer
)	O
in_start_dir	pointer
=	O
g_strdup	function
(	O
"."	pointer
)	O
;	O
if	O
(	O
!	O
in_start_name	pointer
)	O
in_start_name	pointer
=	O
g_strdup	function
(	O
easy_patterns	int
?	O
"*"	pointer
:	O
"."	pointer
)	O
;	O
if	O
(	O
!	O
in_contents	pointer
)	O
in_contents	pointer
=	O
g_strdup	function
(	O
""	pointer
)	O
;	O
find_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
FIND_Y	int
,	O
FIND_X	int
,	O
dialog_colors	array
,	O
find_parm_callback	function
,	O
"[Find File]"	pointer
,	O
_	O
(	O
"Find File"	pointer
)	O
,	O
DLG_CENTER	O
|	O
DLG_REVERSE	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
12	int
,	O
b2	int
,	O
B_CANCEL	int
,	O
NORMAL_BUTTON	int
,	O
buts	array
[	O
2	int
]	O
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
12	int
,	O
b1	int
,	O
B_TREE	int
,	O
NORMAL_BUTTON	int
,	O
buts	array
[	O
1	int
]	O
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
12	int
,	O
b0	int
,	O
B_ENTER	int
,	O
DEFPUSH_BUTTON	int
,	O
buts	array
[	O
0	int
]	O
,	O
0	int
)	O
)	O
;	O
recursively_cbox	pointer
=	O
check_new	function
(	O
6	int
,	O
istart	int
,	O
find_recursively	int
,	O
recurs_label	pointer
)	O
;	O
find_regex_cbox	pointer
=	O
check_new	function
(	O
10	int
,	O
istart	int
,	O
find_regex_flag	int
,	O
_	O
(	O
"&Regular expression"	pointer
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
find_regex_cbox	pointer
)	O
;	O
case_sense	pointer
=	O
check_new	function
(	O
9	int
,	O
istart	int
,	O
case_sensitive	int
,	O
case_label	pointer
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
case_sense	pointer
)	O
;	O
in_with	pointer
=	O
input_new	function
(	O
8	int
,	O
istart	int
,	O
INPUT_COLOR	O
,	O
ilen	int
,	O
in_contents	pointer
,	O
"content"	pointer
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
in_with	pointer
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
recursively_cbox	pointer
)	O
;	O
in_name	pointer
=	O
input_new	function
(	O
5	int
,	O
istart	int
,	O
INPUT_COLOR	O
,	O
ilen	int
,	O
in_start_name	pointer
,	O
"name"	pointer
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
in_name	pointer
)	O
;	O
in_start	pointer
=	O
input_new	function
(	O
3	int
,	O
istart	int
,	O
INPUT_COLOR	O
,	O
ilen	int
,	O
in_start_dir	pointer
,	O
"start"	pointer
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
in_start	pointer
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
label_new	function
(	O
8	int
,	O
3	int
,	O
labs	function
[	O
2	int
]	O
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
label_new	function
(	O
5	int
,	O
3	int
,	O
labs	function
[	O
1	int
]	O
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
label_new	function
(	O
3	int
,	O
3	int
,	O
labs	function
[	O
0	int
]	O
)	O
)	O
;	O
dlg_select_widget	function
(	O
in_name	pointer
)	O
;	O
run_dlg	function
(	O
find_dlg	pointer
)	O
;	O
switch	O
(	O
find_dlg	pointer
->	O
ret_value	int
)	O
{	O
case	O
B_CANCEL	int
:	O
return_value	int
=	O
0	int
;	O
break	O
;	O
case	O
B_TREE	int
:	O
temp_dir	pointer
=	O
g_strdup	function
(	O
in_start	pointer
->	O
buffer	pointer
)	O
;	O
case_sensitive	int
=	O
case_sense	pointer
->	O
state	pointer
&	O
C_BOOL	int
;	O
find_regex_flag	int
=	O
find_regex_cbox	pointer
->	O
state	pointer
&	O
C_BOOL	int
;	O
find_recursively	int
=	O
recursively_cbox	pointer
->	O
state	pointer
&	O
C_BOOL	int
;	O
destroy_dlg	function
(	O
find_dlg	pointer
)	O
;	O
g_free	function
(	O
in_start_dir	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
temp_dir	pointer
,	O
"."	pointer
)	O
==	O
0	int
)	O
{	O
g_free	function
(	O
temp_dir	pointer
)	O
;	O
temp_dir	pointer
=	O
g_strdup	function
(	O
current_panel	pointer
->	O
cwd	short
)	O
;	O
}	O
in_start_dir	pointer
=	O
tree_box	function
(	O
temp_dir	pointer
)	O
;	O
if	O
(	O
in_start_dir	pointer
)	O
g_free	function
(	O
temp_dir	pointer
)	O
;	O
else	O
in_start_dir	pointer
=	O
temp_dir	pointer
;	O
goto	O
find_par_start	O
;	O
break	O
;	O
default	O
:	O
g_free	function
(	O
in_contents	pointer
)	O
;	O
if	O
(	O
in_with	pointer
->	O
buffer	pointer
[	O
0	int
]	O
)	O
{	O
*	O
content	pointer
=	O
g_strdup	function
(	O
in_with	pointer
->	O
buffer	pointer
)	O
;	O
in_contents	pointer
=	O
g_strdup	function
(	O
*	O
content	pointer
)	O
;	O
}	O
else	O
{	O
*	O
content	pointer
=	O
in_contents	pointer
=	O
NULL	O
;	O
r	pointer
=	O
0	int
;	O
}	O
case_sensitive	int
=	O
case_sense	pointer
->	O
state	pointer
&	O
C_BOOL	int
;	O
find_regex_flag	int
=	O
find_regex_cbox	pointer
->	O
state	pointer
&	O
C_BOOL	int
;	O
find_recursively	int
=	O
recursively_cbox	pointer
->	O
state	pointer
&	O
C_BOOL	int
;	O
return_value	int
=	O
1	int
;	O
*	O
start_dir	pointer
=	O
g_strdup	function
(	O
in_start	pointer
->	O
buffer	pointer
)	O
;	O
*	O
pattern	pointer
=	O
g_strdup	function
(	O
in_name	pointer
->	O
buffer	pointer
)	O
;	O
g_free	function
(	O
in_start_dir	pointer
)	O
;	O
in_start_dir	pointer
=	O
g_strdup	function
(	O
*	O
start_dir	pointer
)	O
;	O
g_free	function
(	O
in_start_name	pointer
)	O
;	O
in_start_name	pointer
=	O
g_strdup	function
(	O
*	O
pattern	pointer
)	O
;	O
}	O
destroy_dlg	function
(	O
find_dlg	pointer
)	O
;	O
return	O
return_value	int
;	O
}	O
static	O
void	O
push_directory	function
(	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
dir_stack	struct
*	O
new	pointer
;	O
new	pointer
=	O
g_new	O
(	O
dir_stack	struct
,	O
1	int
)	O
;	O
new	pointer
->	O
name	pointer
=	O
concat_dir_and_file	function
(	O
dir	pointer
,	O
""	pointer
)	O
;	O
new	pointer
->	O
prev	pointer
=	O
dir_stack_base	pointer
;	O
dir_stack_base	pointer
=	O
new	pointer
;	O
}	O
static	O
char	O
*	O
pop_directory	function
(	O
void	O
)	O
{	O
char	O
*	O
name	pointer
;	O
dir_stack	struct
*	O
next	pointer
;	O
if	O
(	O
dir_stack_base	pointer
)	O
{	O
name	pointer
=	O
dir_stack_base	pointer
->	O
name	pointer
;	O
next	pointer
=	O
dir_stack_base	pointer
->	O
prev	pointer
;	O
g_free	function
(	O
dir_stack_base	pointer
)	O
;	O
dir_stack_base	pointer
=	O
next	pointer
;	O
return	O
name	pointer
;	O
}	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
insert_file	function
(	O
const	O
char	O
*	O
dir	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
tmp_name	pointer
;	O
static	O
char	O
*	O
dirname	pointer
;	O
while	O
(	O
dir	pointer
[	O
0	int
]	O
==	O
PATH_SEP	char
&&	O
dir	pointer
[	O
1	int
]	O
==	O
PATH_SEP	char
)	O
dir	pointer
++	O
;	O
if	O
(	O
old_dir	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
old_dir	pointer
,	O
dir	pointer
)	O
)	O
{	O
g_free	function
(	O
old_dir	pointer
)	O
;	O
old_dir	pointer
=	O
g_strdup	function
(	O
dir	pointer
)	O
;	O
dirname	pointer
=	O
add_to_list	function
(	O
dir	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
old_dir	pointer
=	O
g_strdup	function
(	O
dir	pointer
)	O
;	O
dirname	pointer
=	O
add_to_list	function
(	O
dir	pointer
,	O
NULL	O
)	O
;	O
}	O
tmp_name	pointer
=	O
g_strconcat	function
(	O
"    "	pointer
,	O
file	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
add_to_list	function
(	O
tmp_name	pointer
,	O
dirname	pointer
)	O
;	O
g_free	function
(	O
tmp_name	pointer
)	O
;	O
}	O
static	O
void	O
find_add_match	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
const	O
char	O
*	O
dir	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
int	O
p	pointer
=	O
++	O
matches	int
&	O
7	int
;	O
(	O
void	O
)	O
h	pointer
;	O
insert_file	function
(	O
dir	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
listbox_select_last	function
(	O
find_list	pointer
,	O
1	int
)	O
;	O
else	O
listbox_select_last	function
(	O
find_list	pointer
,	O
0	int
)	O
;	O
send_message	function
(	O
&	O
find_list	pointer
->	O
widget	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
if	O
(	O
p	pointer
==	O
7	int
)	O
mc_refresh	function
(	O
)	O
;	O
}	O
static	O
char	O
*	O
get_line_at	function
(	O
int	O
file_fd	int
,	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
pos	pointer
,	O
int	O
*	O
n_read	pointer
,	O
int	O
buf_size	long
,	O
int	O
*	O
has_newline	pointer
)	O
{	O
char	O
*	O
buffer	pointer
=	O
0	int
;	O
int	O
buffer_size	int
=	O
0	int
;	O
char	O
ch	int
=	O
0	int
;	O
int	O
i	array
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
pos	pointer
>=	O
*	O
n_read	pointer
)	O
{	O
*	O
pos	pointer
=	O
0	int
;	O
if	O
(	O
(	O
*	O
n_read	pointer
=	O
mc_read	function
(	O
file_fd	int
,	O
buf	pointer
,	O
buf_size	long
)	O
)	O
<=	O
0	int
)	O
break	O
;	O
}	O
ch	int
=	O
buf	pointer
[	O
(	O
*	O
pos	pointer
)	O
++	O
]	O
;	O
if	O
(	O
ch	int
==	O
0	int
)	O
{	O
if	O
(	O
i	array
==	O
0	int
)	O
continue	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
i	array
>=	O
buffer_size	int
-	O
1	int
)	O
{	O
buffer	pointer
=	O
g_realloc	function
(	O
buffer	pointer
,	O
buffer_size	int
+=	O
80	int
)	O
;	O
}	O
if	O
(	O
ch	int
==	O
'\n'	O
)	O
break	O
;	O
buffer	pointer
[	O
i	array
++	O
]	O
=	O
ch	int
;	O
}	O
*	O
has_newline	pointer
=	O
ch	int
?	O
1	int
:	O
0	int
;	O
if	O
(	O
buffer	pointer
)	O
{	O
buffer	pointer
[	O
i	array
]	O
=	O
0	int
;	O
}	O
return	O
buffer	pointer
;	O
}	O
static	O
FindProgressStatus	enum
check_find_events	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
Gpm_Event	struct
event	pointer
;	O
int	O
c	int
;	O
c	int
=	O
get_event	function
(	O
&	O
event	pointer
,	O
h	pointer
->	O
mouse_status	int
==	O
MOU_REPEAT	int
,	O
0	int
)	O
;	O
if	O
(	O
c	int
!=	O
EV_NONE	O
)	O
{	O
dlg_process_event	function
(	O
h	pointer
,	O
c	int
,	O
&	O
event	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
ret_value	int
==	O
B_ENTER	int
||	O
h	pointer
->	O
ret_value	int
==	O
B_CANCEL	int
||	O
h	pointer
->	O
ret_value	int
==	O
B_AGAIN	int
||	O
h	pointer
->	O
ret_value	int
==	O
B_PANELIZE	int
)	O
{	O
return	O
FIND_ABORT	int
;	O
}	O
if	O
(	O
!	O
(	O
h	pointer
->	O
flags	enum
&	O
DLG_WANT_IDLE	O
)	O
)	O
{	O
return	O
FIND_SUSPEND	int
;	O
}	O
}	O
return	O
FIND_CONT	int
;	O
}	O
static	O
int	O
search_content	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
const	O
char	O
*	O
directory	enum
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
struct	O
stat	struct
s	pointer
;	O
char	O
buffer	pointer
[	O
BUF_SMALL	int
]	O
;	O
char	O
*	O
fname	pointer
;	O
int	O
file_fd	int
;	O
int	O
ret_val	int
=	O
0	int
;	O
fname	pointer
=	O
concat_dir_and_file	function
(	O
directory	enum
,	O
filename	pointer
)	O
;	O
if	O
(	O
mc_stat	function
(	O
fname	pointer
,	O
&	O
s	pointer
)	O
!=	O
0	int
||	O
!	O
S_ISREG	O
(	O
s	pointer
.	O
st_mode	int
)	O
)	O
{	O
g_free	function
(	O
fname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
file_fd	int
=	O
mc_open	function
(	O
fname	pointer
,	O
O_RDONLY	int
)	O
;	O
g_free	function
(	O
fname	pointer
)	O
;	O
if	O
(	O
file_fd	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
g_snprintf	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
_	O
(	O
"Grepping in %s"	pointer
)	O
,	O
name_trunc	function
(	O
filename	pointer
,	O
FIND2_X_USE	O
)	O
)	O
;	O
status_update	function
(	O
buffer	pointer
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
enable_interrupt_key	O
(	O
)	O
;	O
got_interrupt	O
(	O
)	O
;	O
{	O
int	O
line	int
=	O
1	int
;	O
int	O
pos	pointer
=	O
0	int
;	O
int	O
n_read	pointer
=	O
0	int
;	O
int	O
has_newline	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
found	int
=	O
0	int
;	O
typedef	O
const	O
char	O
*	O
(	O
*	O
search_fn	pointer
)	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
search_fn	pointer
search_func	pointer
;	O
if	O
(	O
resuming	int
)	O
{	O
resuming	int
=	O
0	int
;	O
line	int
=	O
last_line	int
;	O
pos	pointer
=	O
last_pos	int
;	O
}	O
search_func	pointer
=	O
(	O
case_sensitive	int
)	O
?	O
cstrstr	function
:	O
cstrcasestr	function
;	O
while	O
(	O
(	O
p	pointer
=	O
get_line_at	function
(	O
file_fd	int
,	O
buffer	pointer
,	O
&	O
pos	pointer
,	O
&	O
n_read	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
&	O
has_newline	pointer
)	O
)	O
&&	O
(	O
ret_val	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
found	int
==	O
0	int
)	O
{	O
if	O
(	O
find_regex_flag	int
)	O
{	O
if	O
(	O
regexec	function
(	O
r	pointer
,	O
p	pointer
,	O
1	int
,	O
0	int
,	O
0	int
)	O
==	O
0	int
)	O
{	O
g_free	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
g_strdup_printf	function
(	O
"%d:%s"	pointer
,	O
line	int
,	O
filename	pointer
)	O
;	O
find_add_match	function
(	O
h	pointer
,	O
directory	enum
,	O
p	pointer
)	O
;	O
found	int
=	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
search_func	pointer
(	O
p	pointer
,	O
content_pattern	pointer
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
match	pointer
=	O
g_strdup_printf	function
(	O
"%d:%s"	pointer
,	O
line	int
,	O
filename	pointer
)	O
;	O
find_add_match	function
(	O
h	pointer
,	O
directory	enum
,	O
match	pointer
)	O
;	O
found	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
if	O
(	O
has_newline	pointer
)	O
{	O
line	int
++	O
;	O
found	int
=	O
0	int
;	O
}	O
g_free	function
(	O
p	pointer
)	O
;	O
if	O
(	O
(	O
line	int
&	O
0xff	int
)	O
==	O
0	int
)	O
{	O
FindProgressStatus	enum
res	enum
;	O
res	enum
=	O
check_find_events	function
(	O
h	pointer
)	O
;	O
switch	O
(	O
res	enum
)	O
{	O
case	O
FIND_ABORT	int
:	O
stop_idle	function
(	O
h	pointer
)	O
;	O
ret_val	int
=	O
1	int
;	O
break	O
;	O
case	O
FIND_SUSPEND	int
:	O
resuming	int
=	O
1	int
;	O
last_line	int
=	O
line	int
;	O
last_pos	int
=	O
pos	pointer
;	O
ret_val	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
mc_close	function
(	O
file_fd	int
)	O
;	O
return	O
ret_val	int
;	O
}	O
static	O
int	O
do_search	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
static	O
struct	O
dirent	struct
*	O
dp	pointer
=	O
0	int
;	O
static	O
DIR	struct
*	O
dirp	pointer
=	O
0	int
;	O
static	O
char	O
*	O
directory	enum
;	O
struct	O
stat	struct
tmp_stat	struct
;	O
static	O
int	O
pos	pointer
;	O
static	O
int	O
subdirs_left	int
=	O
0	int
;	O
if	O
(	O
!	O
h	pointer
)	O
{	O
if	O
(	O
dirp	pointer
)	O
{	O
mc_closedir	function
(	O
dirp	pointer
)	O
;	O
dirp	pointer
=	O
0	int
;	O
}	O
g_free	function
(	O
directory	enum
)	O
;	O
directory	enum
=	O
NULL	O
;	O
dp	pointer
=	O
0	int
;	O
return	O
1	int
;	O
}	O
do_search_begin	O
:	O
while	O
(	O
!	O
dp	pointer
)	O
{	O
if	O
(	O
dirp	pointer
)	O
{	O
mc_closedir	function
(	O
dirp	pointer
)	O
;	O
dirp	pointer
=	O
0	int
;	O
}	O
while	O
(	O
!	O
dirp	pointer
)	O
{	O
char	O
*	O
tmp	pointer
;	O
attrset	function
(	O
REVERSE_COLOR	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
tmp	pointer
=	O
pop_directory	function
(	O
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
{	O
running	int
=	O
0	int
;	O
status_update	function
(	O
_	O
(	O
"Finished"	pointer
)	O
)	O
;	O
stop_idle	function
(	O
h	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
find_ignore_dirs	pointer
)	O
{	O
int	O
found	int
;	O
char	O
*	O
temp_dir	pointer
=	O
g_strconcat	function
(	O
":"	pointer
,	O
tmp	pointer
,	O
":"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
found	int
=	O
strstr	function
(	O
find_ignore_dirs	pointer
,	O
temp_dir	pointer
)	O
!=	O
0	int
;	O
g_free	function
(	O
temp_dir	pointer
)	O
;	O
if	O
(	O
found	int
)	O
g_free	function
(	O
tmp	pointer
)	O
;	O
else	O
break	O
;	O
}	O
else	O
break	O
;	O
}	O
g_free	function
(	O
directory	enum
)	O
;	O
directory	enum
=	O
tmp	pointer
;	O
if	O
(	O
verbose	int
)	O
{	O
char	O
buffer	pointer
[	O
BUF_SMALL	int
]	O
;	O
g_snprintf	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
_	O
(	O
"Searching %s"	pointer
)	O
,	O
name_trunc	function
(	O
directory	enum
,	O
FIND2_X_USE	O
)	O
)	O
;	O
status_update	function
(	O
buffer	pointer
)	O
;	O
}	O
if	O
(	O
!	O
mc_stat	function
(	O
directory	enum
,	O
&	O
tmp_stat	struct
)	O
)	O
subdirs_left	int
=	O
tmp_stat	struct
.	O
st_nlink	long
-	O
2	int
;	O
else	O
subdirs_left	int
=	O
0	int
;	O
dirp	pointer
=	O
mc_opendir	function
(	O
directory	enum
)	O
;	O
}	O
dp	pointer
=	O
mc_readdir	function
(	O
dirp	pointer
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
dp	pointer
->	O
d_name	array
,	O
"."	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
dp	pointer
->	O
d_name	array
,	O
".."	pointer
)	O
==	O
0	int
)	O
{	O
dp	pointer
=	O
mc_readdir	function
(	O
dirp	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
subdirs_left	int
&&	O
find_recursively	int
&&	O
directory	enum
)	O
{	O
char	O
*	O
tmp_name	pointer
=	O
concat_dir_and_file	function
(	O
directory	enum
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
!	O
mc_lstat	function
(	O
tmp_name	pointer
,	O
&	O
tmp_stat	struct
)	O
&&	O
S_ISDIR	O
(	O
tmp_stat	struct
.	O
st_mode	int
)	O
)	O
{	O
push_directory	function
(	O
tmp_name	pointer
)	O
;	O
subdirs_left	int
--	O
;	O
}	O
g_free	function
(	O
tmp_name	pointer
)	O
;	O
}	O
if	O
(	O
regexp_match	function
(	O
find_pattern	pointer
,	O
dp	pointer
->	O
d_name	array
,	O
match_file	int
)	O
)	O
{	O
if	O
(	O
content_pattern	pointer
)	O
{	O
if	O
(	O
search_content	function
(	O
h	pointer
,	O
directory	enum
,	O
dp	pointer
->	O
d_name	array
)	O
)	O
{	O
return	O
1	int
;	O
}	O
}	O
else	O
find_add_match	function
(	O
h	pointer
,	O
directory	enum
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
}	O
dp	pointer
=	O
mc_readdir	function
(	O
dirp	pointer
)	O
;	O
count	int
++	O
;	O
if	O
(	O
!	O
(	O
count	int
&	O
31	int
)	O
)	O
{	O
const	O
char	O
*	O
rotating_dash	pointer
=	O
"|/-\\"	pointer
;	O
if	O
(	O
verbose	int
)	O
{	O
pos	pointer
=	O
(	O
pos	pointer
+	O
1	int
)	O
%	O
4	int
;	O
attrset	function
(	O
DLG_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
FIND2_Y	O
-	O
6	int
,	O
FIND2_X	int
-	O
4	int
)	O
;	O
addch	O
(	O
rotating_dash	pointer
[	O
pos	pointer
]	O
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
}	O
}	O
else	O
goto	O
do_search_begin	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
init_find_vars	function
(	O
void	O
)	O
{	O
char	O
*	O
dir	pointer
;	O
g_free	function
(	O
old_dir	pointer
)	O
;	O
old_dir	pointer
=	O
0	int
;	O
count	int
=	O
0	int
;	O
matches	int
=	O
0	int
;	O
while	O
(	O
(	O
dir	pointer
=	O
pop_directory	function
(	O
)	O
)	O
!=	O
NULL	O
)	O
g_free	function
(	O
dir	pointer
)	O
;	O
}	O
static	O
char	O
*	O
make_fullname	function
(	O
const	O
char	O
*	O
dirname	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
dirname	pointer
,	O
"."	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
dirname	pointer
,	O
"."	pointer
PATH_SEP_STR	pointer
)	O
==	O
0	int
)	O
return	O
g_strdup	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
dirname	pointer
,	O
"."	pointer
PATH_SEP_STR	pointer
,	O
2	int
)	O
==	O
0	int
)	O
return	O
concat_dir_and_file	function
(	O
dirname	pointer
+	O
2	int
,	O
filename	pointer
)	O
;	O
return	O
concat_dir_and_file	function
(	O
dirname	pointer
,	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
find_do_view_edit	function
(	O
int	O
unparsed_view	int
,	O
int	O
edit	int
,	O
char	O
*	O
dir	pointer
,	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
fullname	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
int	O
line	int
;	O
if	O
(	O
content_pattern	pointer
)	O
{	O
filename	pointer
=	O
strchr	function
(	O
file	pointer
+	O
4	int
,	O
':'	O
)	O
+	O
1	int
;	O
line	int
=	O
atoi	function
(	O
file	pointer
+	O
4	int
)	O
;	O
}	O
else	O
{	O
filename	pointer
=	O
file	pointer
+	O
4	int
;	O
line	int
=	O
0	int
;	O
}	O
fullname	pointer
=	O
make_fullname	function
(	O
dir	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
edit	int
)	O
do_edit_at_line	function
(	O
fullname	pointer
,	O
line	int
)	O
;	O
else	O
view_file_at_line	function
(	O
fullname	pointer
,	O
unparsed_view	int
,	O
use_internal_view	int
,	O
line	int
)	O
;	O
g_free	function
(	O
fullname	pointer
)	O
;	O
}	O
static	O
int	O
view_edit_currently_selected_file	function
(	O
int	O
unparsed_view	int
,	O
int	O
edit	int
)	O
{	O
WLEntry	struct
*	O
entry	pointer
=	O
find_list	pointer
->	O
current	pointer
;	O
char	O
*	O
dir	pointer
;	O
if	O
(	O
!	O
entry	pointer
)	O
return	O
MSG_NOT_HANDLED	int
;	O
dir	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
if	O
(	O
!	O
entry	pointer
->	O
text	pointer
||	O
!	O
dir	pointer
)	O
return	O
MSG_NOT_HANDLED	int
;	O
find_do_view_edit	function
(	O
unparsed_view	int
,	O
edit	int
,	O
dir	pointer
,	O
entry	pointer
->	O
text	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
static	O
cb_ret_t	enum
find_callback	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_KEY	int
:	O
if	O
(	O
parm	int
==	O
KEY_F	O
(	O
3	int
)	O
||	O
parm	int
==	O
KEY_F	O
(	O
13	int
)	O
)	O
{	O
int	O
unparsed_view	int
=	O
(	O
parm	int
==	O
KEY_F	O
(	O
13	int
)	O
)	O
;	O
return	O
view_edit_currently_selected_file	function
(	O
unparsed_view	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
parm	int
==	O
KEY_F	O
(	O
4	int
)	O
)	O
{	O
return	O
view_edit_currently_selected_file	function
(	O
0	int
,	O
1	int
)	O
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
DLG_IDLE	int
:	O
do_search	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
start_stop	function
(	O
int	O
button	int
)	O
{	O
(	O
void	O
)	O
button	int
;	O
running	int
=	O
is_start	int
;	O
set_idle_proc	function
(	O
find_dlg	pointer
,	O
running	int
)	O
;	O
is_start	int
=	O
!	O
is_start	int
;	O
status_update	function
(	O
is_start	int
?	O
_	O
(	O
"Stopped"	pointer
)	O
:	O
_	O
(	O
"Searching"	pointer
)	O
)	O
;	O
button_set_text	function
(	O
stop_button	pointer
,	O
fbuts	array
[	O
is_start	int
]	O
.	O
text	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
find_do_view_file	function
(	O
int	O
button	int
)	O
{	O
(	O
void	O
)	O
button	int
;	O
view_edit_currently_selected_file	function
(	O
0	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
find_do_edit_file	function
(	O
int	O
button	int
)	O
{	O
(	O
void	O
)	O
button	int
;	O
view_edit_currently_selected_file	function
(	O
0	int
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
setup_gui	function
(	O
void	O
)	O
{	O
static	O
int	O
i18n_flag	int
=	O
0	int
;	O
if	O
(	O
!	O
i18n_flag	int
)	O
{	O
register	O
int	O
i	array
=	O
sizeof	O
(	O
fbuts	array
)	O
/	O
sizeof	O
(	O
fbuts	array
[	O
0	int
]	O
)	O
;	O
while	O
(	O
i	array
--	O
)	O
fbuts	array
[	O
i	array
]	O
.	O
len	int
=	O
strlen	function
(	O
fbuts	array
[	O
i	array
]	O
.	O
text	pointer
=	O
_	O
(	O
fbuts	array
[	O
i	array
]	O
.	O
text	pointer
)	O
)	O
+	O
3	int
;	O
fbuts	array
[	O
2	int
]	O
.	O
len	int
+=	O
2	int
;	O
i18n_flag	int
=	O
1	int
;	O
}	O
{	O
int	O
l0	int
=	O
max	long
(	O
fbuts	array
[	O
0	int
]	O
.	O
len	int
,	O
fbuts	array
[	O
1	int
]	O
.	O
len	int
)	O
;	O
int	O
l1	int
=	O
fbuts	array
[	O
2	int
]	O
.	O
len	int
+	O
fbuts	array
[	O
3	int
]	O
.	O
len	int
+	O
l0	int
+	O
fbuts	array
[	O
4	int
]	O
.	O
len	int
;	O
int	O
l2	int
=	O
fbuts	array
[	O
5	int
]	O
.	O
len	int
+	O
fbuts	array
[	O
6	int
]	O
.	O
len	int
+	O
fbuts	array
[	O
7	int
]	O
.	O
len	int
;	O
int	O
r1	int
,	O
r2	int
;	O
FIND2_X	int
=	O
COLS	O
-	O
16	int
;	O
if	O
(	O
l1	int
+	O
9	int
>	O
FIND2_X	int
)	O
FIND2_X	int
=	O
l1	int
+	O
9	int
;	O
if	O
(	O
l2	int
+	O
8	int
>	O
FIND2_X	int
)	O
FIND2_X	int
=	O
l2	int
+	O
8	int
;	O
r1	int
=	O
(	O
FIND2_X	int
-	O
4	int
-	O
l1	int
)	O
%	O
5	int
;	O
l1	int
=	O
(	O
FIND2_X	int
-	O
4	int
-	O
l1	int
)	O
/	O
5	int
;	O
r2	int
=	O
(	O
FIND2_X	int
-	O
4	int
-	O
l2	int
)	O
%	O
4	int
;	O
l2	int
=	O
(	O
FIND2_X	int
-	O
4	int
-	O
l2	int
)	O
/	O
4	int
;	O
fbuts	array
[	O
2	int
]	O
.	O
x	array
=	O
2	int
+	O
r1	int
/	O
2	int
+	O
l1	int
;	O
fbuts	array
[	O
3	int
]	O
.	O
x	array
=	O
fbuts	array
[	O
2	int
]	O
.	O
x	array
+	O
fbuts	array
[	O
2	int
]	O
.	O
len	int
+	O
l1	int
;	O
fbuts	array
[	O
0	int
]	O
.	O
x	array
=	O
fbuts	array
[	O
3	int
]	O
.	O
x	array
+	O
fbuts	array
[	O
3	int
]	O
.	O
len	int
+	O
l1	int
;	O
fbuts	array
[	O
4	int
]	O
.	O
x	array
=	O
fbuts	array
[	O
0	int
]	O
.	O
x	array
+	O
l0	int
+	O
l1	int
;	O
fbuts	array
[	O
5	int
]	O
.	O
x	array
=	O
2	int
+	O
r2	int
/	O
2	int
+	O
l2	int
;	O
fbuts	array
[	O
6	int
]	O
.	O
x	array
=	O
fbuts	array
[	O
5	int
]	O
.	O
x	array
+	O
fbuts	array
[	O
5	int
]	O
.	O
len	int
+	O
l2	int
;	O
fbuts	array
[	O
7	int
]	O
.	O
x	array
=	O
fbuts	array
[	O
6	int
]	O
.	O
x	array
+	O
fbuts	array
[	O
6	int
]	O
.	O
len	int
+	O
l2	int
;	O
}	O
find_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
FIND2_Y	O
,	O
FIND2_X	int
,	O
dialog_colors	array
,	O
find_callback	function
,	O
"[Find File]"	pointer
,	O
_	O
(	O
"Find File"	pointer
)	O
,	O
DLG_CENTER	O
|	O
DLG_REVERSE	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
FIND2_Y	O
-	O
3	int
,	O
fbuts	array
[	O
7	int
]	O
.	O
x	array
,	O
B_VIEW	int
,	O
NORMAL_BUTTON	int
,	O
fbuts	array
[	O
7	int
]	O
.	O
text	pointer
,	O
find_do_edit_file	function
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
FIND2_Y	O
-	O
3	int
,	O
fbuts	array
[	O
6	int
]	O
.	O
x	array
,	O
B_VIEW	int
,	O
NORMAL_BUTTON	int
,	O
fbuts	array
[	O
6	int
]	O
.	O
text	pointer
,	O
find_do_view_file	function
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
FIND2_Y	O
-	O
3	int
,	O
fbuts	array
[	O
5	int
]	O
.	O
x	array
,	O
B_PANELIZE	int
,	O
NORMAL_BUTTON	int
,	O
fbuts	array
[	O
5	int
]	O
.	O
text	pointer
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
FIND2_Y	O
-	O
4	int
,	O
fbuts	array
[	O
4	int
]	O
.	O
x	array
,	O
B_CANCEL	int
,	O
NORMAL_BUTTON	int
,	O
fbuts	array
[	O
4	int
]	O
.	O
text	pointer
,	O
0	int
)	O
)	O
;	O
stop_button	pointer
=	O
button_new	function
(	O
FIND2_Y	O
-	O
4	int
,	O
fbuts	array
[	O
0	int
]	O
.	O
x	array
,	O
B_STOP	int
,	O
NORMAL_BUTTON	int
,	O
fbuts	array
[	O
0	int
]	O
.	O
text	pointer
,	O
start_stop	function
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
stop_button	pointer
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
FIND2_Y	O
-	O
4	int
,	O
fbuts	array
[	O
3	int
]	O
.	O
x	array
,	O
B_AGAIN	int
,	O
NORMAL_BUTTON	int
,	O
fbuts	array
[	O
3	int
]	O
.	O
text	pointer
,	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
button_new	function
(	O
FIND2_Y	O
-	O
4	int
,	O
fbuts	array
[	O
2	int
]	O
.	O
x	array
,	O
B_ENTER	int
,	O
DEFPUSH_BUTTON	int
,	O
fbuts	array
[	O
2	int
]	O
.	O
text	pointer
,	O
0	int
)	O
)	O
;	O
status_label	pointer
=	O
label_new	function
(	O
FIND2_Y	O
-	O
6	int
,	O
4	int
,	O
_	O
(	O
"Searching"	pointer
)	O
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
status_label	pointer
)	O
;	O
find_list	pointer
=	O
listbox_new	function
(	O
2	int
,	O
2	int
,	O
FIND2_X	int
-	O
4	int
,	O
FIND2_Y	O
-	O
9	int
,	O
0	int
)	O
;	O
add_widget	function
(	O
find_dlg	pointer
,	O
find_list	pointer
)	O
;	O
}	O
static	O
int	O
run_process	function
(	O
void	O
)	O
{	O
resuming	int
=	O
0	int
;	O
set_idle_proc	function
(	O
find_dlg	pointer
,	O
1	int
)	O
;	O
run_dlg	function
(	O
find_dlg	pointer
)	O
;	O
return	O
find_dlg	pointer
->	O
ret_value	int
;	O
}	O
static	O
void	O
kill_gui	function
(	O
void	O
)	O
{	O
set_idle_proc	function
(	O
find_dlg	pointer
,	O
0	int
)	O
;	O
destroy_dlg	function
(	O
find_dlg	pointer
)	O
;	O
}	O
static	O
int	O
find_file	function
(	O
char	O
*	O
start_dir	pointer
,	O
char	O
*	O
pattern	pointer
,	O
char	O
*	O
content	pointer
,	O
char	O
*	O
*	O
dirname	pointer
,	O
char	O
*	O
*	O
filename	pointer
)	O
{	O
int	O
return_value	int
=	O
0	int
;	O
char	O
*	O
dir	pointer
;	O
char	O
*	O
dir_tmp	pointer
,	O
*	O
file_tmp	pointer
;	O
setup_gui	function
(	O
)	O
;	O
find_pattern	pointer
=	O
pattern	pointer
;	O
content_pattern	pointer
=	O
content	pointer
;	O
init_find_vars	function
(	O
)	O
;	O
push_directory	function
(	O
start_dir	pointer
)	O
;	O
return_value	int
=	O
run_process	function
(	O
)	O
;	O
while	O
(	O
(	O
dir	pointer
=	O
pop_directory	function
(	O
)	O
)	O
!=	O
NULL	O
)	O
g_free	function
(	O
dir	pointer
)	O
;	O
get_list_info	function
(	O
&	O
file_tmp	pointer
,	O
&	O
dir_tmp	pointer
)	O
;	O
if	O
(	O
dir_tmp	pointer
)	O
*	O
dirname	pointer
=	O
g_strdup	function
(	O
dir_tmp	pointer
)	O
;	O
if	O
(	O
file_tmp	pointer
)	O
*	O
filename	pointer
=	O
g_strdup	function
(	O
file_tmp	pointer
)	O
;	O
if	O
(	O
return_value	int
==	O
B_PANELIZE	int
&&	O
*	O
filename	pointer
)	O
{	O
int	O
status	int
,	O
link_to_dir	int
,	O
stale_link	int
;	O
int	O
next_free	int
=	O
0	int
;	O
int	O
i	array
;	O
struct	O
stat	struct
st	pointer
;	O
WLEntry	struct
*	O
entry	pointer
=	O
find_list	pointer
->	O
list	pointer
;	O
dir_list	struct
*	O
list	pointer
=	O
&	O
current_panel	pointer
->	O
dir	pointer
;	O
char	O
*	O
name	pointer
;	O
for	O
(	O
i	array
=	O
0	int
;	O
entry	pointer
&&	O
i	array
<	O
find_list	pointer
->	O
count	int
;	O
entry	pointer
=	O
entry	pointer
->	O
next	pointer
,	O
i	array
++	O
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
!	O
entry	pointer
->	O
text	pointer
||	O
!	O
entry	pointer
->	O
data	pointer
)	O
continue	O
;	O
if	O
(	O
content_pattern	pointer
)	O
filename	pointer
=	O
strchr	function
(	O
entry	pointer
->	O
text	pointer
+	O
4	int
,	O
':'	O
)	O
+	O
1	int
;	O
else	O
filename	pointer
=	O
entry	pointer
->	O
text	pointer
+	O
4	int
;	O
name	pointer
=	O
make_fullname	function
(	O
entry	pointer
->	O
data	pointer
,	O
filename	pointer
)	O
;	O
status	int
=	O
handle_path	function
(	O
list	pointer
,	O
name	pointer
,	O
&	O
st	pointer
,	O
next_free	int
,	O
&	O
link_to_dir	int
,	O
&	O
stale_link	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
content_pattern	pointer
&&	O
next_free	int
>	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
list	pointer
->	O
list	pointer
[	O
next_free	int
-	O
1	int
]	O
.	O
fname	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
g_free	function
(	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
!	O
next_free	int
)	O
panel_clean_dir	function
(	O
current_panel	pointer
)	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
fnamelen	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
fname	pointer
=	O
name	pointer
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
marked	int
=	O
0	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
link_to_dir	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
stale_link	int
=	O
stale_link	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
0	int
;	O
list	pointer
->	O
list	pointer
[	O
next_free	int
]	O
.	O
st	pointer
=	O
st	pointer
;	O
next_free	int
++	O
;	O
if	O
(	O
!	O
(	O
next_free	int
&	O
15	int
)	O
)	O
rotate_dash	function
(	O
)	O
;	O
}	O
if	O
(	O
next_free	int
)	O
{	O
current_panel	pointer
->	O
count	int
=	O
next_free	int
;	O
current_panel	pointer
->	O
is_panelized	int
=	O
1	int
;	O
if	O
(	O
start_dir	pointer
[	O
0	int
]	O
==	O
PATH_SEP	char
)	O
{	O
strcpy	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
PATH_SEP_STR	pointer
)	O
;	O
chdir	function
(	O
PATH_SEP_STR	pointer
)	O
;	O
}	O
}	O
}	O
kill_gui	function
(	O
)	O
;	O
do_search	function
(	O
0	int
)	O
;	O
g_free	function
(	O
old_dir	pointer
)	O
;	O
old_dir	pointer
=	O
0	int
;	O
return	O
return_value	int
;	O
}	O
void	O
do_find	function
(	O
void	O
)	O
{	O
char	O
*	O
start_dir	pointer
=	O
NULL	O
,	O
*	O
pattern	pointer
=	O
NULL	O
,	O
*	O
content	pointer
=	O
NULL	O
;	O
char	O
*	O
filename	pointer
,	O
*	O
dirname	pointer
;	O
int	O
v	pointer
,	O
dir_and_file_set	int
;	O
regex_t	struct
rx	struct
;	O
for	O
(	O
r	pointer
=	O
&	O
rx	struct
;	O
find_parameters	function
(	O
&	O
start_dir	pointer
,	O
&	O
pattern	pointer
,	O
&	O
content	pointer
)	O
;	O
r	pointer
=	O
&	O
rx	struct
)	O
{	O
dirname	pointer
=	O
filename	pointer
=	O
NULL	O
;	O
is_start	int
=	O
0	int
;	O
v	pointer
=	O
find_file	function
(	O
start_dir	pointer
,	O
pattern	pointer
,	O
content	pointer
,	O
&	O
dirname	pointer
,	O
&	O
filename	pointer
)	O
;	O
g_free	function
(	O
start_dir	pointer
)	O
;	O
g_free	function
(	O
pattern	pointer
)	O
;	O
if	O
(	O
find_regex_flag	int
&&	O
r	pointer
)	O
regfree	function
(	O
r	pointer
)	O
;	O
if	O
(	O
v	pointer
==	O
B_ENTER	int
)	O
{	O
if	O
(	O
dirname	pointer
||	O
filename	pointer
)	O
{	O
if	O
(	O
dirname	pointer
)	O
{	O
do_cd	function
(	O
dirname	pointer
,	O
cd_exact	int
)	O
;	O
if	O
(	O
filename	pointer
)	O
try_to_select	function
(	O
current_panel	pointer
,	O
filename	pointer
+	O
(	O
content	pointer
?	O
(	O
strchr	function
(	O
filename	pointer
+	O
4	int
,	O
':'	O
)	O
-	O
filename	pointer
+	O
1	int
)	O
:	O
4	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
filename	pointer
)	O
do_cd	function
(	O
filename	pointer
,	O
cd_exact	int
)	O
;	O
select_item	function
(	O
current_panel	pointer
)	O
;	O
}	O
g_free	function
(	O
dirname	pointer
)	O
;	O
g_free	function
(	O
filename	pointer
)	O
;	O
break	O
;	O
}	O
g_free	function
(	O
content	pointer
)	O
;	O
dir_and_file_set	int
=	O
dirname	pointer
&&	O
filename	pointer
;	O
g_free	function
(	O
dirname	pointer
)	O
;	O
g_free	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
v	pointer
==	O
B_CANCEL	int
)	O
break	O
;	O
if	O
(	O
v	pointer
==	O
B_PANELIZE	int
)	O
{	O
if	O
(	O
dir_and_file_set	int
)	O
{	O
try_to_select	function
(	O
current_panel	pointer
,	O
NULL	O
)	O
;	O
panel_re_sort	function
(	O
current_panel	pointer
)	O
;	O
try_to_select	function
(	O
current_panel	pointer
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
