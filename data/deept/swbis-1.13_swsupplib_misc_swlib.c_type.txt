static	O
int	O
verbose_levelG	int
;	O
static	O
int	O
verbose_swbis_event_thresholdG	int
=	O
SWC_VERBOSE_4	int
;	O
static	O
uintmax_t	long
*	O
g_pstatbytes	pointer
=	O
NULL	O
;	O
static	O
struct	O
timespec	struct
*	O
io_req	pointer
=	O
(	O
struct	O
timespec	struct
*	O
)	O
NULL	O
;	O
static	O
int	O
g_burst_adjust	int
=	O
65000	int
;	O
static	O
pid_t	int
g_pax_header_pidG	int
=	O
0	int
;	O
void	O
swlib_set_pax_header_pid	function
(	O
pid_t	int
n	long
)	O
{	O
g_pax_header_pidG	int
=	O
n	long
;	O
}	O
pid_t	int
swlib_get_pax_header_pid	function
(	O
void	O
)	O
{	O
if	O
(	O
g_pax_header_pidG	int
==	O
0	int
)	O
{	O
g_pax_header_pidG	int
=	O
getpid	function
(	O
)	O
;	O
}	O
return	O
g_pax_header_pidG	int
;	O
}	O
static	O
ssize_t	long
synct_i_no_null_write	function
(	O
int	O
fd	int
,	O
char	O
*	O
buf	pointer
,	O
int	O
sz	int
)	O
{	O
int	O
ret	int
;	O
int	O
remains	int
;	O
int	O
excl_region	int
;	O
int	O
amount	long
;	O
int	O
retval	int
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
x	pointer
;	O
remains	int
=	O
sz	int
;	O
p	pointer
=	O
buf	pointer
;	O
retval	int
=	O
0	int
;	O
while	O
(	O
remains	int
>	O
0	int
)	O
{	O
amount	long
=	O
0	int
;	O
x	pointer
=	O
p	pointer
;	O
while	O
(	O
(	O
int	O
)	O
(	O
x	pointer
-	O
buf	pointer
)	O
<	O
sz	int
&&	O
*	O
x	pointer
)	O
{	O
amount	long
++	O
;	O
x	pointer
++	O
;	O
}	O
if	O
(	O
amount	long
>	O
sz	int
)	O
amount	long
=	O
sz	int
;	O
excl_region	int
=	O
remains	int
-	O
amount	long
;	O
E_DEBUG3	O
(	O
"amount=%d excl_region=%d"	pointer
,	O
amount	long
,	O
excl_region	int
)	O
;	O
ret	int
=	O
atomicio	function
(	O
uxfio_write	function
,	O
fd	int
,	O
p	pointer
,	O
amount	long
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ret	int
!=	O
amount	long
)	O
return	O
-	O
2	int
;	O
p	pointer
+=	O
ret	int
;	O
remains	int
-=	O
ret	int
;	O
retval	int
+=	O
ret	int
;	O
while	O
(	O
excl_region	int
>	O
0	int
&&	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
excl_region	int
--	O
;	O
remains	int
--	O
;	O
p	pointer
++	O
;	O
}	O
}	O
return	O
retval	int
;	O
}	O
static	O
ssize_t	long
synct_i_read_block	function
(	O
SYNCT	struct
*	O
synct	pointer
,	O
ssize_t	long
(	O
*	O
iof	pointer
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
,	O
int	O
fd	int
,	O
char	O
*	O
buf	pointer
)	O
{	O
ssize_t	long
ret	int
;	O
E_DEBUG2	O
(	O
"fd=%d"	pointer
,	O
fd	int
)	O
;	O
ret	int
=	O
(	O
iof	pointer
)	O
(	O
fd	int
,	O
buf	pointer
,	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
if	O
(	O
synct	pointer
->	O
debugfdM	int
>	O
0	int
)	O
write	pointer
(	O
synct	pointer
->	O
debugfdM	int
,	O
buf	pointer
,	O
ret	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: synct_i_read_block() error: ret=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
ret	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
-	O
ret	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
synct	pointer
->	O
countM	int
++	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
synct_check_for_possible_eof	function
(	O
SYNCT	struct
*	O
synct	pointer
)	O
{	O
unsigned	O
char	O
*	O
ibuf	pointer
;	O
unsigned	O
char	O
*	O
pos	pointer
;	O
int	O
i	int
;	O
ibuf	pointer
=	O
synct	pointer
->	O
bufM	pointer
;	O
pos	pointer
=	O
ibuf	pointer
;	O
i	int
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
(	O
int	O
)	O
(	O
pos	pointer
-	O
ibuf	pointer
)	O
<	O
SWLIB_SYNCT_BLOCKSIZE	int
&&	O
synct	pointer
->	O
mtM	pointer
[	O
i	int
]	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
pos	pointer
&&	O
*	O
pos	pointer
==	O
synct	pointer
->	O
mtM	pointer
[	O
i	int
]	O
)	O
{	O
E_DEBUG	O
(	O
"finding trailer string, so far so good"	pointer
)	O
;	O
i	int
++	O
;	O
}	O
else	O
if	O
(	O
*	O
pos	pointer
==	O
'\0'	O
&&	O
i	int
>	O
11	int
)	O
{	O
return	O
SYNCT_EOF_CONDITION_2	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"reset, bad match of trailer string"	pointer
)	O
;	O
return	O
SYNCT_EOF_CONDITION_0	int
;	O
}	O
pos	pointer
++	O
;	O
}	O
if	O
(	O
synct	pointer
->	O
mtM	pointer
[	O
i	int
]	O
==	O
'\0'	O
)	O
{	O
E_DEBUG	O
(	O
"found trailer"	pointer
)	O
;	O
return	O
SYNCT_EOF_CONDITION_1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"not found"	pointer
)	O
;	O
return	O
SYNCT_EOF_CONDITION_0	int
;	O
}	O
}	O
void	O
swlib_set_swbis_verbose_threshold	function
(	O
int	O
s	pointer
)	O
{	O
verbose_swbis_event_thresholdG	int
=	O
s	pointer
;	O
}	O
int	O
swlib_get_nopen	function
(	O
void	O
)	O
{	O
int	O
nopen	int
=	O
0	int
;	O
int	O
ret	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
200	int
)	O
;	O
++	O
i	int
)	O
{	O
ret	int
=	O
fcntl	function
(	O
i	int
,	O
F_GETFL	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
&&	O
errno	O
==	O
EBADF	int
)	O
{	O
;	O
}	O
else	O
{	O
nopen	int
++	O
;	O
}	O
}	O
return	O
nopen	int
;	O
}	O
void	O
e_msg	function
(	O
char	O
*	O
class	pointer
,	O
char	O
*	O
reason	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
char	O
*	O
function	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: %s: at %s:%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
class	pointer
,	O
reason	pointer
,	O
file	pointer
,	O
line	pointer
)	O
;	O
}	O
static	O
int	O
convert_hex_seq	function
(	O
int	O
d1	int
,	O
int	O
d2	int
)	O
{	O
int	O
n	long
;	O
n	long
=	O
d1	int
;	O
if	O
(	O
isdigit	function
(	O
n	long
)	O
==	O
0	int
&&	O
(	O
n	long
<	O
'\x41'	O
||	O
n	long
>	O
'\x46'	O
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
isdigit	function
(	O
n	long
)	O
==	O
0	int
)	O
d1	int
-=	O
7	int
;	O
n	long
=	O
d2	int
;	O
if	O
(	O
isdigit	function
(	O
n	long
)	O
==	O
0	int
&&	O
(	O
n	long
<	O
'\x41'	O
||	O
n	long
>	O
'\x46'	O
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
isdigit	function
(	O
n	long
)	O
==	O
0	int
)	O
d2	int
-=	O
7	int
;	O
return	O
(	O
16	int
*	O
(	O
d1	int
-	O
48	int
)	O
)	O
+	O
(	O
d2	int
-	O
48	int
)	O
;	O
}	O
static	O
char	O
*	O
does_have_hex_escape	function
(	O
char	O
*	O
src	pointer
,	O
int	O
*	O
value	long
)	O
{	O
char	O
*	O
t	pointer
;	O
char	O
*	O
seq	pointer
;	O
int	O
d1	int
;	O
int	O
d2	int
;	O
*	O
value	long
=	O
0	int
;	O
t	pointer
=	O
strstr	function
(	O
src	pointer
,	O
"\\x"	pointer
)	O
;	O
if	O
(	O
t	pointer
&&	O
(	O
t	pointer
==	O
src	pointer
||	O
*	O
(	O
t	pointer
-	O
1	int
)	O
!=	O
'\\'	O
)	O
)	O
{	O
seq	pointer
=	O
t	pointer
+	O
2	int
;	O
if	O
(	O
*	O
seq	pointer
==	O
'\0'	O
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
*	O
(	O
seq	pointer
+	O
1	int
)	O
==	O
'\0'	O
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
d1	int
=	O
toupper	function
(	O
(	O
int	O
)	O
(	O
*	O
seq	pointer
)	O
)	O
;	O
d2	int
=	O
toupper	function
(	O
(	O
int	O
)	O
(	O
*	O
(	O
seq	pointer
+	O
1	int
)	O
)	O
)	O
;	O
*	O
value	long
=	O
convert_hex_seq	function
(	O
d1	int
,	O
d2	int
)	O
;	O
if	O
(	O
*	O
value	long
<	O
0	int
)	O
{	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
{	O
return	O
t	pointer
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
process_all_hex_escapes	function
(	O
char	O
*	O
src	pointer
)	O
{	O
unsigned	O
char	O
*	O
s	pointer
;	O
unsigned	O
char	O
*	O
r	pointer
;	O
int	O
value	long
;	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
src	pointer
;	O
while	O
(	O
(	O
r	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
does_have_hex_escape	function
(	O
(	O
char	O
*	O
)	O
s	pointer
,	O
&	O
value	long
)	O
)	O
)	O
{	O
memmove	function
(	O
(	O
void	O
*	O
)	O
(	O
r	pointer
+	O
1	int
)	O
,	O
(	O
void	O
*	O
)	O
(	O
r	pointer
+	O
4	int
)	O
,	O
strlen	function
(	O
(	O
char	O
*	O
)	O
(	O
r	pointer
+	O
4	int
)	O
)	O
+	O
1	int
)	O
;	O
*	O
r	pointer
=	O
(	O
unsigned	O
char	O
)	O
(	O
value	long
)	O
;	O
s	pointer
=	O
(	O
r	pointer
+	O
1	int
)	O
;	O
}	O
}	O
int	O
swlib_doif_writeap	function
(	O
int	O
fd	int
,	O
STROB	struct
*	O
buffer	array
,	O
char	O
*	O
format	pointer
,	O
va_list	array
*	O
pap	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
aret	int
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
0	int
;	O
ret	int
=	O
strob_vsprintf	function
(	O
buffer	array
,	O
1	int
,	O
format	pointer
,	O
*	O
pap	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ret	int
=	O
strob_strlen	function
(	O
buffer	array
)	O
;	O
aret	int
=	O
atomicio	function
(	O
uxfio_write	function
,	O
fd	int
,	O
(	O
void	O
*	O
)	O
strob_str	function
(	O
buffer	array
)	O
,	O
strob_strlen	function
(	O
buffer	array
)	O
)	O
;	O
if	O
(	O
aret	int
!=	O
ret	int
)	O
return	O
-	O
1	int
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
nano_nanosleep	function
(	O
long	O
nsec	long
)	O
{	O
struct	O
timespec	struct
tt	struct
;	O
tt	struct
.	O
tv_sec	long
=	O
0	int
;	O
tt	struct
.	O
tv_nsec	long
=	O
nsec	long
;	O
return	O
nanosleep	function
(	O
&	O
tt	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
delay_sleep_pattern2	function
(	O
struct	O
timespec	struct
*	O
io_req	pointer
,	O
int	O
*	O
sleepbytes	pointer
,	O
int	O
c_amount	int
,	O
int	O
byteswritten	int
)	O
{	O
static	O
int	O
doneone	int
=	O
0	int
;	O
const	O
int	O
leaddiv	int
=	O
0	int
;	O
int	O
openssh_rcvd_adjust	int
=	O
g_burst_adjust	int
;	O
if	O
(	O
*	O
sleepbytes	pointer
>	O
openssh_rcvd_adjust	int
&&	O
(	O
leaddiv	int
==	O
0	int
||	O
(	O
byteswritten	int
>	O
(	O
c_amount	int
/	O
leaddiv	int
)	O
&&	O
byteswritten	int
<	O
(	O
c_amount	int
-	O
c_amount	int
/	O
leaddiv	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
verbose_levelG	int
>=	O
SWC_VERBOSE_3	int
&&	O
!	O
doneone	int
)	O
||	O
(	O
verbose_levelG	int
>=	O
SWC_VERBOSE_8	int
)	O
)	O
{	O
doneone	int
=	O
1	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: sshd efd race delay: sleeping %d microseconds every %d bytes\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
(	O
io_req	pointer
->	O
tv_nsec	long
)	O
/	O
1000	int
,	O
g_burst_adjust	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: sshd efd race delay: is not needed for openssh >=5.1\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
nano_nanosleep	function
(	O
io_req	pointer
->	O
tv_nsec	long
)	O
;	O
*	O
sleepbytes	pointer
=	O
0	int
;	O
}	O
}	O
static	O
int	O
form_abspath	function
(	O
STROB	struct
*	O
sb1	pointer
,	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
pcwd	pointer
)	O
{	O
char	O
cwd	short
[	O
200	int
]	O
;	O
if	O
(	O
*	O
s1	pointer
==	O
'/'	O
)	O
return	O
1	int
;	O
if	O
(	O
pcwd	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
getcwd	function
(	O
cwd	short
,	O
sizeof	O
(	O
cwd	short
)	O
-	O
2	int
)	O
==	O
NULL	O
)	O
{	O
SWLIB_FATAL	O
(	O
"path too long"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
strncpy	function
(	O
cwd	short
,	O
pcwd	pointer
,	O
sizeof	O
(	O
cwd	short
)	O
-	O
2	int
)	O
;	O
}	O
cwd	short
[	O
sizeof	O
(	O
cwd	short
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
strob_strcpy	function
(	O
sb1	pointer
,	O
cwd	short
)	O
;	O
swlib_unix_dircat	function
(	O
sb1	pointer
,	O
s1	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
intmax_t	long
swlib_i_digs_copy	function
(	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
intmax_t	long
count	long
,	O
FILE_DIGS	struct
*	O
digs	pointer
,	O
int	O
adjunct_ofd	int
,	O
ssize_t	long
(	O
*	O
f	pointer
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
{	O
intmax_t	long
n	long
;	O
intmax_t	long
am	long
;	O
intmax_t	long
wr	long
;	O
unsigned	O
char	O
buf	pointer
[	O
SHA_BLOCKSIZE	int
]	O
;	O
intmax_t	long
blocksize	long
=	O
SHA_BLOCKSIZE	int
;	O
intmax_t	long
amount	long
;	O
intmax_t	long
readamount	long
;	O
intmax_t	long
ret	int
;	O
intmax_t	long
retval	int
=	O
0	int
;	O
int	O
i	int
;	O
char	O
*	O
p5	pointer
;	O
char	O
*	O
p	pointer
;	O
MD5_CTX	struct
md5ctx	struct
;	O
int	O
digest_hex_bytes	int
=	O
40	int
;	O
int	O
sha512digest_hex_bytes	int
=	O
128	int
;	O
unsigned	O
char	O
res_sha1	array
[	O
21	int
]	O
;	O
unsigned	O
char	O
res_sha512	array
[	O
65	int
]	O
;	O
unsigned	O
char	O
sha1ctx	array
[	O
512	int
]	O
;	O
unsigned	O
char	O
sha512ctx	array
[	O
512	int
]	O
;	O
int	O
sleepbytes	pointer
=	O
0	int
;	O
int	O
timebytes	int
=	O
0	int
;	O
time_t	long
newt	long
;	O
time_t	long
oldt	long
;	O
oldt	long
=	O
newt	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_md5	short
==	O
DIGS_ENABLE_ON	int
)	O
swlib_md5_from_memblocks	function
(	O
&	O
md5ctx	struct
,	O
digs	pointer
->	O
md5	array
,	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
sha_block	function
(	O
(	O
void	O
*	O
)	O
sha1ctx	array
,	O
res_sha1	array
,	O
NULL	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
sha512_block	function
(	O
(	O
void	O
*	O
)	O
sha512ctx	array
,	O
res_sha512	array
,	O
NULL	O
,	O
-	O
1	int
)	O
;	O
do	O
{	O
if	O
(	O
count	long
>=	O
0	int
)	O
readamount	long
=	O
(	O
count	long
-	O
retval	int
)	O
>	O
blocksize	long
?	O
blocksize	long
:	O
(	O
count	long
-	O
retval	int
)	O
;	O
else	O
readamount	long
=	O
blocksize	long
;	O
n	long
=	O
(	O
*	O
f	pointer
)	O
(	O
ifd	int
,	O
buf	pointer
,	O
readamount	long
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
n	long
)	O
{	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_md5	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
p5	pointer
=	O
(	O
char	O
*	O
)	O
buf	pointer
;	O
am	long
=	O
n	long
;	O
while	O
(	O
am	long
>	O
0	int
)	O
{	O
amount	long
=	O
am	long
>	O
1024	int
?	O
1024	int
:	O
am	long
;	O
swlib_md5_from_memblocks	function
(	O
&	O
md5ctx	struct
,	O
digs	pointer
->	O
md5	array
,	O
(	O
unsigned	O
char	O
*	O
)	O
p5	pointer
,	O
amount	long
)	O
;	O
p5	pointer
+=	O
amount	long
;	O
am	long
-=	O
amount	long
;	O
}	O
}	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
sha_block	function
(	O
(	O
void	O
*	O
)	O
sha1ctx	array
,	O
res_sha1	array
,	O
buf	pointer
,	O
n	long
)	O
;	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
sha512_block	function
(	O
(	O
void	O
*	O
)	O
sha512ctx	array
,	O
res_sha512	array
,	O
buf	pointer
,	O
n	long
)	O
;	O
if	O
(	O
ofd	int
>	O
0	int
)	O
{	O
wr	long
=	O
(	O
intmax_t	long
)	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
uxfio_write	function
)	O
,	O
ofd	int
,	O
buf	pointer
,	O
n	long
)	O
;	O
if	O
(	O
wr	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
wr	long
=	O
n	long
;	O
}	O
retval	int
+=	O
wr	long
;	O
if	O
(	O
adjunct_ofd	int
>	O
0	int
)	O
{	O
ret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
uxfio_write	function
)	O
,	O
adjunct_ofd	int
,	O
buf	pointer
,	O
n	long
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
timebytes	int
+=	O
wr	long
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
io_req	pointer
&&	O
io_req	pointer
->	O
tv_nsec	long
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
sleepbytes	pointer
+=	O
wr	long
;	O
delay_sleep_pattern2	function
(	O
io_req	pointer
,	O
&	O
sleepbytes	pointer
,	O
count	long
,	O
retval	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
g_pstatbytes	pointer
&&	O
timebytes	int
>	O
10000	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
newt	long
=	O
time	struct
(	O
NULL	O
)	O
)	O
>	O
oldt	long
)	O
{	O
timebytes	int
=	O
0	int
;	O
oldt	long
=	O
newt	long
;	O
*	O
g_pstatbytes	pointer
=	O
retval	int
;	O
(	O
void	O
)	O
update_progress_meter	function
(	O
SIGALRM	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
n	long
==	O
0	int
)	O
break	O
;	O
}	O
while	O
(	O
retval	int
<	O
count	long
||	O
count	long
<	O
0	int
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_md5	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
swlib_md5_from_memblocks	function
(	O
&	O
md5ctx	struct
,	O
digs	pointer
->	O
md5	array
,	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
digs	pointer
->	O
md5	array
[	O
32	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
sha_block	function
(	O
(	O
void	O
*	O
)	O
sha1ctx	array
,	O
res_sha1	array
,	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
sha512_block	function
(	O
(	O
void	O
*	O
)	O
sha512ctx	array
,	O
res_sha512	array
,	O
(	O
unsigned	O
char	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_size	short
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
ubuf	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
ubuf	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s"	pointer
,	O
swlib_imaxtostr	function
(	O
retval	int
,	O
ubuf	pointer
)	O
)	O
;	O
swlib_strncpy	function
(	O
digs	pointer
->	O
size	array
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
sizeof	O
(	O
digs	pointer
->	O
size	array
)	O
)	O
;	O
strob_close	function
(	O
ubuf	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_sha1	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
p	pointer
=	O
digs	pointer
->	O
sha1	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
digest_hex_bytes	int
/	O
2	int
)	O
;	O
++	O
i	int
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"%02x"	pointer
,	O
res_sha1	array
[	O
i	int
]	O
)	O
;	O
p	pointer
+=	O
2	int
;	O
}	O
digs	pointer
->	O
sha1	array
[	O
digest_hex_bytes	int
]	O
=	O
'\0'	O
;	O
digs	pointer
->	O
sha1	array
[	O
40	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
digs	pointer
&&	O
digs	pointer
->	O
do_sha512	short
==	O
DIGS_ENABLE_ON	int
)	O
{	O
p	pointer
=	O
digs	pointer
->	O
sha512	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
sha512digest_hex_bytes	int
/	O
2	int
)	O
;	O
++	O
i	int
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"%02x"	pointer
,	O
res_sha512	array
[	O
i	int
]	O
)	O
;	O
p	pointer
+=	O
2	int
;	O
}	O
digs	pointer
->	O
sha512	array
[	O
sha512digest_hex_bytes	int
]	O
=	O
'\0'	O
;	O
}	O
return	O
retval	int
;	O
}	O
int	O
squash_trailing_char	function
(	O
char	O
*	O
path	pointer
,	O
char	O
ch	int
,	O
int	O
min_len	int
)	O
{	O
if	O
(	O
path	pointer
&&	O
(	O
(	O
int	O
)	O
strlen	function
(	O
path	pointer
)	O
>	O
min_len	int
)	O
&&	O
(	O
*	O
(	O
path	pointer
+	O
strlen	function
(	O
path	pointer
)	O
-	O
1	int
)	O
)	O
==	O
(	O
int	O
)	O
ch	int
)	O
{	O
(	O
*	O
(	O
path	pointer
+	O
strlen	function
(	O
path	pointer
)	O
-	O
1	int
)	O
)	O
=	O
'\0'	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
int	O
swlib_atoi	function
(	O
const	O
char	O
*	O
nptr	pointer
,	O
int	O
*	O
result	pointer
)	O
{	O
return	O
swlib_atoi2	function
(	O
nptr	pointer
,	O
(	O
char	O
*	O
*	O
)	O
(	O
NULL	O
)	O
,	O
result	pointer
)	O
;	O
}	O
int	O
swlib_atoi2	function
(	O
const	O
char	O
*	O
nptr	pointer
,	O
char	O
*	O
*	O
fp_endptr	pointer
,	O
int	O
*	O
result	pointer
)	O
{	O
long	O
ret	int
;	O
char	O
*	O
endptr	pointer
;	O
char	O
*	O
*	O
a_endptr	pointer
;	O
if	O
(	O
fp_endptr	pointer
)	O
a_endptr	pointer
=	O
fp_endptr	pointer
;	O
else	O
a_endptr	pointer
=	O
&	O
endptr	pointer
;	O
ret	int
=	O
strtol	function
(	O
nptr	pointer
,	O
a_endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
result	pointer
)	O
*	O
result	pointer
=	O
0	int
;	O
if	O
(	O
(	O
*	O
a_endptr	pointer
==	O
nptr	pointer
&&	O
ret	int
==	O
0	int
)	O
||	O
(	O
(	O
ret	int
==	O
LONG_MIN	O
||	O
ret	int
==	O
LONG_MAX	O
)	O
&&	O
errno	O
==	O
ERANGE	int
)	O
)	O
{	O
if	O
(	O
result	pointer
)	O
{	O
*	O
result	pointer
=	O
1	int
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: strtol error when converting [%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
nptr	pointer
)	O
;	O
}	O
return	O
(	O
int	O
)	O
ret	int
;	O
}	O
unsigned	O
long	O
int	O
swlib_atoul	function
(	O
const	O
char	O
*	O
nptr	pointer
,	O
int	O
*	O
result	pointer
,	O
char	O
*	O
*	O
fp_endptr	pointer
)	O
{	O
unsigned	O
long	O
int	O
ret	int
;	O
char	O
*	O
endptr	pointer
;	O
char	O
*	O
*	O
p_endptr	pointer
;	O
if	O
(	O
fp_endptr	pointer
==	O
NULL	O
)	O
p_endptr	pointer
=	O
&	O
endptr	pointer
;	O
else	O
p_endptr	pointer
=	O
fp_endptr	pointer
;	O
ret	int
=	O
strtoul	function
(	O
nptr	pointer
,	O
p_endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
result	pointer
)	O
*	O
result	pointer
=	O
0	int
;	O
if	O
(	O
(	O
endptr	pointer
==	O
nptr	pointer
&&	O
ret	int
==	O
0	int
)	O
||	O
(	O
(	O
ret	int
==	O
ULONG_MAX	O
)	O
&&	O
errno	O
==	O
ERANGE	int
)	O
)	O
{	O
if	O
(	O
result	pointer
)	O
{	O
*	O
result	pointer
=	O
1	int
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: strtoul error when converting [%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
nptr	pointer
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
uintmax_t	long
*	O
*	O
swlib_pump_get_ppstatbytes	function
(	O
void	O
)	O
{	O
return	O
&	O
g_pstatbytes	pointer
;	O
}	O
intmax_t	long
swlib_pump_amount8	function
(	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
intmax_t	long
amount	long
,	O
int	O
adjunct_ofd	int
,	O
FILE_DIGS	struct
*	O
digs	pointer
)	O
{	O
intmax_t	long
n	long
;	O
n	long
=	O
swlib_i_digs_copy	function
(	O
ofd	int
,	O
ifd	int
,	O
amount	long
,	O
digs	pointer
,	O
adjunct_ofd	int
,	O
taru_tape_buffered_read	function
)	O
;	O
return	O
n	long
;	O
}	O
struct	O
timespec	struct
*	O
swlib_get_io_req	function
(	O
void	O
)	O
{	O
return	O
io_req	pointer
;	O
}	O
int	O
*	O
swlib_burst_adjust_p	function
(	O
void	O
)	O
{	O
return	O
&	O
g_burst_adjust	int
;	O
}	O
struct	O
timespec	struct
*	O
*	O
swlib_get_io_req_p	function
(	O
void	O
)	O
{	O
return	O
&	O
io_req	pointer
;	O
}	O
int	O
swlib_test_verbose	function
(	O
struct	O
swEvents	struct
*	O
ev	pointer
,	O
int	O
verbose_level	int
,	O
int	O
swbis_event	int
,	O
int	O
is_swi_event	int
,	O
int	O
event_status	int
,	O
int	O
is_posix_event	int
)	O
{	O
if	O
(	O
(	O
ev	pointer
&&	O
(	O
verbose_level	int
>=	O
ev	pointer
->	O
verbose_threshholdM	int
)	O
)	O
||	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_1	int
&&	O
event_status	int
!=	O
0	int
)	O
||	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_3	int
&&	O
is_posix_event	int
)	O
||	O
(	O
verbose_level	int
>=	O
verbose_swbis_event_thresholdG	int
&&	O
swbis_event	int
)	O
||	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_6	int
&&	O
is_swi_event	int
)	O
||	O
(	O
verbose_level	int
>=	O
verbose_swbis_event_thresholdG	int
&&	O
!	O
is_swi_event	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
int	O
swlib_get_verbose_level	function
(	O
void	O
)	O
{	O
return	O
verbose_levelG	int
;	O
}	O
void	O
swlib_set_verbose_level	function
(	O
int	O
n	long
)	O
{	O
verbose_levelG	int
=	O
n	long
;	O
}	O
intmax_t	long
swlib_i_pipe_pump	function
(	O
int	O
suction_fd	int
,	O
int	O
discharge_fd	int
,	O
intmax_t	long
*	O
amount	long
,	O
int	O
adjunct_ofd	int
,	O
STROB	struct
*	O
obuf	pointer
,	O
ssize_t	long
(	O
*	O
thisfpread	pointer
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
{	O
int	O
commandFailed	int
=	O
0	int
;	O
int	O
pumpDead	int
=	O
0	int
;	O
int	O
bytes	int
;	O
int	O
ibytes	int
;	O
intmax_t	long
byteswritten	int
=	O
0	int
;	O
intmax_t	long
remains	int
;	O
intmax_t	long
c_amount	int
;	O
char	O
buf	pointer
[	O
SWLIB_PIPE_BUF	int
]	O
;	O
int	O
sleepbytes	pointer
=	O
0	int
;	O
if	O
(	O
obuf	pointer
)	O
{	O
strob_strcpy	function
(	O
obuf	pointer
,	O
""	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
c_amount	int
=	O
*	O
amount	long
;	O
if	O
(	O
c_amount	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
do	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
bytes	int
=	O
(	O
*	O
thisfpread	pointer
)	O
(	O
suction_fd	int
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
bytes	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
commandFailed	int
=	O
1	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
bytes	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
discharge_fd	int
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
uxfio_write	function
(	O
discharge_fd	int
,	O
buf	pointer
,	O
bytes	int
)	O
!=	O
bytes	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
commandFailed	int
=	O
2	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
adjunct_ofd	int
>=	O
0	int
)	O
{	O
if	O
(	O
uxfio_write	function
(	O
adjunct_ofd	int
,	O
buf	pointer
,	O
bytes	int
)	O
!=	O
bytes	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
commandFailed	int
=	O
3	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
obuf	pointer
)	O
{	O
strob_memcpy_at	function
(	O
obuf	pointer
,	O
(	O
size_t	long
)	O
byteswritten	int
,	O
buf	pointer
,	O
(	O
size_t	long
)	O
(	O
bytes	int
)	O
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
byteswritten	int
+=	O
bytes	int
;	O
if	O
(	O
io_req	pointer
&&	O
io_req	pointer
->	O
tv_nsec	long
)	O
{	O
sleepbytes	pointer
+=	O
bytes	int
;	O
delay_sleep_pattern2	function
(	O
io_req	pointer
,	O
&	O
sleepbytes	pointer
,	O
c_amount	int
,	O
byteswritten	int
)	O
;	O
}	O
}	O
while	O
(	O
!	O
pumpDead	int
)	O
;	O
if	O
(	O
obuf	pointer
)	O
{	O
strob_append_hidden_null	function
(	O
obuf	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
*	O
amount	long
=	O
byteswritten	int
;	O
return	O
commandFailed	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
remains	int
=	O
sizeof	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
(	O
c_amount	int
-	O
byteswritten	int
)	O
<	O
remains	int
)	O
{	O
remains	int
=	O
c_amount	int
-	O
byteswritten	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
do	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
bytes	int
=	O
(	O
*	O
thisfpread	pointer
)	O
(	O
suction_fd	int
,	O
buf	pointer
,	O
remains	int
)	O
;	O
if	O
(	O
bytes	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
commandFailed	int
=	O
1	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
bytes	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
bytes	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
discharge_fd	int
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ibytes	int
=	O
uxfio_write	function
(	O
discharge_fd	int
,	O
buf	pointer
,	O
bytes	int
)	O
;	O
if	O
(	O
adjunct_ofd	int
>=	O
0	int
)	O
{	O
ibytes	int
=	O
uxfio_write	function
(	O
adjunct_ofd	int
,	O
buf	pointer
,	O
bytes	int
)	O
;	O
}	O
}	O
else	O
{	O
ibytes	int
=	O
bytes	int
;	O
}	O
if	O
(	O
obuf	pointer
)	O
{	O
strob_memcpy_at	function
(	O
obuf	pointer
,	O
(	O
size_t	long
)	O
byteswritten	int
,	O
buf	pointer
,	O
(	O
size_t	long
)	O
(	O
bytes	int
)	O
)	O
;	O
}	O
if	O
(	O
ibytes	int
!=	O
bytes	int
)	O
{	O
SWBIS_ERROR_IMPL	O
(	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
commandFailed	int
=	O
2	int
;	O
pumpDead	int
=	O
1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
byteswritten	int
+=	O
bytes	int
;	O
if	O
(	O
(	O
c_amount	int
-	O
byteswritten	int
)	O
<	O
remains	int
)	O
{	O
if	O
(	O
(	O
remains	int
=	O
c_amount	int
-	O
byteswritten	int
)	O
>	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
{	O
remains	int
=	O
sizeof	O
(	O
buf	pointer
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
io_req	pointer
&&	O
io_req	pointer
->	O
tv_nsec	long
)	O
{	O
sleepbytes	pointer
+=	O
bytes	int
;	O
delay_sleep_pattern2	function
(	O
io_req	pointer
,	O
&	O
sleepbytes	pointer
,	O
c_amount	int
,	O
byteswritten	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
while	O
(	O
!	O
pumpDead	int
&&	O
remains	int
)	O
;	O
*	O
amount	long
=	O
byteswritten	int
;	O
if	O
(	O
obuf	pointer
)	O
{	O
strob_append_hidden_null	function
(	O
obuf	pointer
)	O
;	O
}	O
return	O
commandFailed	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
swlib_is_ascii_noaccept	function
(	O
char	O
*	O
str	pointer
,	O
char	O
*	O
acc	pointer
,	O
int	O
minlen	int
)	O
{	O
unsigned	O
char	O
*	O
s	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
!	O
str	pointer
||	O
(	O
(	O
int	O
)	O
strlen	function
(	O
str	pointer
)	O
<	O
minlen	int
)	O
)	O
return	O
1	int
;	O
ret	int
=	O
strpbrk	function
(	O
str	pointer
,	O
acc	pointer
)	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
ret	int
)	O
return	O
ret	int
;	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
;	O
while	O
(	O
s	pointer
&&	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
>	O
126	int
||	O
*	O
s	pointer
<	O
33	int
)	O
{	O
return	O
1	int
;	O
}	O
s	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swlib_tr	function
(	O
char	O
*	O
src	pointer
,	O
int	O
to	int
,	O
int	O
from	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
p1	pointer
;	O
p1	pointer
=	O
src	pointer
;	O
while	O
(	O
*	O
(	O
p1	pointer
++	O
)	O
)	O
{	O
if	O
(	O
*	O
(	O
p1	pointer
-	O
1	int
)	O
==	O
from	int
)	O
{	O
*	O
(	O
p1	pointer
-	O
1	int
)	O
=	O
to	int
;	O
ret	int
++	O
;	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
swlib_check_safe_path	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
s	pointer
)	O
return	O
1	int
;	O
if	O
(	O
!	O
strlen	function
(	O
s	pointer
)	O
)	O
return	O
5	int
;	O
if	O
(	O
strstr	function
(	O
s	pointer
,	O
".."	pointer
)	O
)	O
return	O
6	int
;	O
if	O
(	O
strchr	function
(	O
s	pointer
,	O
' '	O
)	O
)	O
return	O
7	int
;	O
return	O
swlib_is_sh_tainted_string	function
(	O
s	pointer
)	O
;	O
}	O
int	O
swlib_check_clean_path	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
s	pointer
)	O
return	O
1	int
;	O
if	O
(	O
!	O
strlen	function
(	O
s	pointer
)	O
)	O
return	O
2	int
;	O
if	O
(	O
strstr	function
(	O
s	pointer
,	O
"//"	pointer
)	O
)	O
return	O
3	int
;	O
if	O
(	O
strstr	function
(	O
s	pointer
,	O
".."	pointer
)	O
)	O
return	O
4	int
;	O
if	O
(	O
strchr	function
(	O
s	pointer
,	O
' '	O
)	O
)	O
return	O
5	int
;	O
if	O
(	O
swlib_is_sh_tainted_string	function
(	O
s	pointer
)	O
)	O
return	O
6	int
;	O
return	O
strpbrk	function
(	O
s	pointer
,	O
SWBIS_WS_TAINTED_CHARS	pointer
)	O
?	O
7	int
:	O
0	int
;	O
}	O
int	O
swlib_check_clean_absolute_path	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
s	pointer
)	O
return	O
1	int
;	O
if	O
(	O
!	O
strlen	function
(	O
s	pointer
)	O
)	O
return	O
2	int
;	O
if	O
(	O
*	O
s	pointer
!=	O
'/'	O
)	O
return	O
3	int
;	O
return	O
swlib_check_clean_path	function
(	O
s	pointer
)	O
;	O
}	O
int	O
swlib_check_clean_relative_path	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
s	pointer
)	O
return	O
1	int
;	O
if	O
(	O
*	O
s	pointer
==	O
'/'	O
)	O
return	O
2	int
;	O
return	O
swlib_check_clean_path	function
(	O
s	pointer
)	O
;	O
}	O
int	O
swlib_check_legal_tag_value	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
s	pointer
)	O
return	O
0	int
;	O
return	O
strpbrk	function
(	O
s	pointer
,	O
":.,"	pointer
)	O
?	O
1	int
:	O
0	int
;	O
}	O
int	O
swlib_is_sh_tainted_string	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
s	pointer
)	O
return	O
0	int
;	O
return	O
strpbrk	function
(	O
s	pointer
,	O
SWBIS_TAINTED_CHARS	pointer
)	O
?	O
1	int
:	O
0	int
;	O
}	O
void	O
swlib_is_sh_tainted_string_fatal	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
s	pointer
)	O
return	O
;	O
if	O
(	O
strpbrk	function
(	O
s	pointer
,	O
SWBIS_TAINTED_CHARS	pointer
)	O
?	O
1	int
:	O
0	int
)	O
{	O
SWLIB_FATAL	O
(	O
"tainted string"	pointer
)	O
;	O
}	O
return	O
;	O
}	O
ssize_t	long
swlib_safe_read	function
(	O
int	O
fd	int
,	O
void	O
*	O
buf	pointer
,	O
size_t	long
nbyte	long
)	O
{	O
int	O
n	long
=	O
0	int
,	O
nret	int
=	O
1	int
;	O
char	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
buf	pointer
)	O
;	O
while	O
(	O
n	long
<	O
(	O
int	O
)	O
nbyte	long
&&	O
nret	int
)	O
{	O
nret	int
=	O
uxfio_read	function
(	O
fd	int
,	O
p	pointer
+	O
n	long
,	O
nbyte	long
-	O
n	long
)	O
;	O
if	O
(	O
nret	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
||	O
errno	O
==	O
EAGAIN	int
)	O
{	O
continue	O
;	O
}	O
return	O
nret	int
;	O
}	O
n	long
+=	O
nret	int
;	O
}	O
return	O
n	long
;	O
}	O
void	O
swlib_swprog_assert	function
(	O
int	O
error_code	int
,	O
int	O
status	int
,	O
char	O
*	O
reason	pointer
,	O
char	O
*	O
version	array
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
char	O
*	O
function	pointer
)	O
{	O
if	O
(	O
error_code	int
!=	O
0	int
&&	O
error_code	int
<	O
SWBIS_PROGS_USER_ERROR	int
&&	O
error_code	int
>=	O
SWBIS_PROGS_IMPLEMENTATION_ERROR	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Error: code=[%d] : %s: version=[%s] file=[%s] line=[%d]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
error_code	int
,	O
reason	pointer
,	O
version	array
,	O
file	pointer
,	O
line	pointer
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O
else	O
if	O
(	O
error_code	int
!=	O
0	int
&&	O
error_code	int
>=	O
SWBIS_PROGS_USER_ERROR	int
)	O
{	O
exit	function
(	O
status	int
)	O
;	O
}	O
else	O
if	O
(	O
error_code	int
!=	O
0	int
&&	O
error_code	int
<	O
SWBIS_PROGS_IMPLEMENTATION_ERROR	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Internal Informative Warning: code=%d : %s version=[%s]"	pointer
", file=[%s], line=[%d]\n"	pointer
,	O
error_code	int
,	O
reason	pointer
,	O
version	array
,	O
file	pointer
,	O
line	pointer
)	O
;	O
}	O
}	O
void	O
swlib_exception	function
(	O
char	O
*	O
reason	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
char	O
*	O
function	pointer
)	O
{	O
e_msg	function
(	O
"program exception"	pointer
,	O
reason	pointer
,	O
file	pointer
,	O
line	pointer
,	O
function	pointer
)	O
;	O
}	O
void	O
swlib_internal_error	function
(	O
char	O
*	O
reason	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
char	O
*	O
function	pointer
)	O
{	O
e_msg	function
(	O
"internal implementation error"	pointer
,	O
reason	pointer
,	O
file	pointer
,	O
line	pointer
,	O
function	pointer
)	O
;	O
}	O
void	O
swlib_resource	function
(	O
char	O
*	O
reason	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
char	O
*	O
function	pointer
)	O
{	O
e_msg	function
(	O
"resource exception"	pointer
,	O
reason	pointer
,	O
file	pointer
,	O
line	pointer
,	O
function	pointer
)	O
;	O
}	O
void	O
swlib_fatal	function
(	O
char	O
*	O
reason	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
char	O
*	O
function	pointer
)	O
{	O
e_msg	function
(	O
"fatal error"	pointer
,	O
reason	pointer
,	O
file	pointer
,	O
line	pointer
,	O
function	pointer
)	O
;	O
exit	function
(	O
252	int
)	O
;	O
}	O
void	O
swlib_assertion_fatal	function
(	O
int	O
assertion_result	int
,	O
char	O
*	O
reason	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
char	O
*	O
function	pointer
)	O
{	O
if	O
(	O
assertion_result	int
==	O
0	int
)	O
swlib_fatal	function
(	O
reason	pointer
,	O
file	pointer
,	O
line	pointer
,	O
function	pointer
)	O
;	O
}	O
int	O
swlib_squash_trailing_char	function
(	O
char	O
*	O
path	pointer
,	O
char	O
ch	int
)	O
{	O
return	O
squash_trailing_char	function
(	O
path	pointer
,	O
ch	int
,	O
0	int
)	O
;	O
}	O
void	O
swlib_squash_all_trailing_vnewline	function
(	O
char	O
*	O
path	pointer
)	O
{	O
while	O
(	O
1	int
)	O
if	O
(	O
squash_trailing_char	function
(	O
path	pointer
,	O
'\n'	O
,	O
0	int
)	O
==	O
0	int
)	O
{	O
squash_trailing_char	function
(	O
path	pointer
,	O
'\r'	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
void	O
swlib_squash_trailing_vnewline	function
(	O
char	O
*	O
path	pointer
)	O
{	O
squash_trailing_char	function
(	O
path	pointer
,	O
'\r'	O
,	O
0	int
)	O
;	O
squash_trailing_char	function
(	O
path	pointer
,	O
'\n'	O
,	O
0	int
)	O
;	O
}	O
void	O
swlib_squash_trailing_slash	function
(	O
char	O
*	O
path	pointer
)	O
{	O
squash_trailing_char	function
(	O
path	pointer
,	O
'/'	O
,	O
1	int
)	O
;	O
return	O
;	O
}	O
void	O
swlib_squash_embedded_dot_slash	function
(	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
p1	pointer
;	O
p1	pointer
=	O
strstr	function
(	O
path	pointer
,	O
"/./"	pointer
)	O
;	O
if	O
(	O
p1	pointer
&&	O
p1	pointer
!=	O
path	pointer
)	O
{	O
memmove	function
(	O
p1	pointer
+	O
1	int
,	O
p1	pointer
+	O
3	int
,	O
strlen	function
(	O
p1	pointer
+	O
2	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
p1	pointer
&&	O
p1	pointer
==	O
path	pointer
)	O
{	O
memmove	function
(	O
p1	pointer
+	O
1	int
,	O
p1	pointer
+	O
3	int
,	O
strlen	function
(	O
p1	pointer
+	O
2	int
)	O
)	O
;	O
}	O
}	O
void	O
swlib_squash_double_slash	function
(	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
p1	pointer
;	O
while	O
(	O
(	O
p1	pointer
=	O
strstr	function
(	O
path	pointer
,	O
"//"	pointer
)	O
)	O
!=	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
)	O
memmove	function
(	O
p1	pointer
,	O
p1	pointer
+	O
1	int
,	O
strlen	function
(	O
p1	pointer
)	O
)	O
;	O
}	O
char	O
*	O
swlib_return_no_leading	function
(	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
path	pointer
,	O
"/"	pointer
)	O
)	O
==	O
path	pointer
)	O
&&	O
1	int
)	O
return	O
++	O
path	pointer
;	O
if	O
(	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
path	pointer
,	O
"./"	pointer
)	O
)	O
==	O
path	pointer
)	O
&&	O
1	int
)	O
return	O
path	pointer
+=	O
2	int
;	O
return	O
path	pointer
;	O
}	O
void	O
swlib_squash_all_dot_slash	function
(	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
swlib_squash_leading_dot_slash	function
(	O
path	pointer
)	O
;	O
s	pointer
=	O
strstr	function
(	O
path	pointer
,	O
"/./"	pointer
)	O
;	O
while	O
(	O
s	pointer
)	O
{	O
swlib_squash_embedded_dot_slash	function
(	O
path	pointer
)	O
;	O
s	pointer
=	O
strstr	function
(	O
path	pointer
,	O
"/./"	pointer
)	O
;	O
}	O
}	O
void	O
swlib_squash_leading_dot_slash	function
(	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
p1	pointer
;	O
if	O
(	O
strlen	function
(	O
path	pointer
)	O
>=	O
3	int
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
path	pointer
,	O
"./"	pointer
,	O
2	int
)	O
)	O
{	O
p1	pointer
=	O
path	pointer
;	O
memmove	function
(	O
p1	pointer
,	O
p1	pointer
+	O
2	int
,	O
strlen	function
(	O
p1	pointer
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
void	O
swlib_toggle_trailing_slashdot	function
(	O
char	O
*	O
mode	array
,	O
char	O
*	O
name	array
,	O
int	O
*	O
pflag	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
mode	array
,	O
"drop"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	function
(	O
name	array
)	O
<	O
2	int
)	O
{	O
*	O
pflag	pointer
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
name	array
+	O
strlen	function
(	O
name	array
)	O
-	O
2	int
,	O
"/."	pointer
)	O
==	O
0	int
)	O
{	O
*	O
(	O
name	array
+	O
strlen	function
(	O
name	array
)	O
-	O
2	int
)	O
=	O
'\0'	O
;	O
*	O
pflag	pointer
=	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
pflag	pointer
)	O
{	O
strcat	function
(	O
name	array
,	O
"/."	pointer
)	O
;	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
}	O
void	O
swlib_toggle_leading_dotslash	function
(	O
char	O
*	O
mode	array
,	O
char	O
*	O
name	array
,	O
int	O
*	O
pflag	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
mode	array
,	O
"drop"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	function
(	O
name	array
)	O
<	O
2	int
)	O
{	O
*	O
pflag	pointer
=	O
0	int
;	O
return	O
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
name	array
,	O
"./"	pointer
,	O
2	int
)	O
==	O
0	int
&&	O
strlen	function
(	O
name	array
)	O
>	O
2	int
)	O
{	O
memmove	function
(	O
name	array
,	O
name	array
+	O
2	int
,	O
strlen	function
(	O
name	array
)	O
-	O
1	int
)	O
;	O
*	O
pflag	pointer
=	O
1	int
;	O
}	O
else	O
{	O
*	O
pflag	pointer
=	O
0	int
;	O
return	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
pflag	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
name	array
,	O
"."	pointer
)	O
==	O
0	int
)	O
{	O
strcat	function
(	O
name	array
,	O
"/"	pointer
)	O
;	O
}	O
else	O
{	O
memmove	function
(	O
name	array
+	O
2	int
,	O
name	array
,	O
strlen	function
(	O
name	array
)	O
+	O
1	int
)	O
;	O
*	O
name	array
=	O
'.'	O
;	O
*	O
(	O
name	array
+	O
1	int
)	O
=	O
'/'	O
;	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
}	O
}	O
void	O
swlib_toggle_trailing_slash	function
(	O
char	O
*	O
mode	array
,	O
char	O
*	O
name	array
,	O
int	O
*	O
pflag	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
mode	array
,	O
"drop"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	function
(	O
name	array
)	O
>	O
1	int
&&	O
name	array
[	O
strlen	function
(	O
name	array
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
{	O
name	array
[	O
strlen	function
(	O
name	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
*	O
pflag	pointer
=	O
1	int
;	O
}	O
else	O
{	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
pflag	pointer
)	O
{	O
name	array
[	O
strlen	function
(	O
name	array
)	O
]	O
=	O
'/'	O
;	O
}	O
}	O
}	O
void	O
swlib_squash_leading_slash	function
(	O
char	O
*	O
name	array
)	O
{	O
if	O
(	O
*	O
name	array
==	O
'/'	O
)	O
{	O
memmove	function
(	O
name	array
,	O
name	array
+	O
1	int
,	O
strlen	function
(	O
name	array
)	O
)	O
;	O
}	O
}	O
char	O
*	O
swlib_return_relative_path	function
(	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
s	pointer
=	O
path	pointer
;	O
while	O
(	O
*	O
s	pointer
==	O
'/'	O
)	O
s	pointer
++	O
;	O
return	O
s	pointer
;	O
}	O
void	O
swlib_squash_all_leading_slash	function
(	O
char	O
*	O
name	array
)	O
{	O
int	O
s	pointer
;	O
int	O
i	int
;	O
if	O
(	O
!	O
name	array
)	O
return	O
;	O
s	pointer
=	O
strlen	function
(	O
name	array
)	O
;	O
i	int
=	O
(	O
*	O
name	array
==	O
'/'	O
)	O
;	O
while	O
(	O
*	O
name	array
==	O
'/'	O
)	O
swlib_squash_leading_slash	function
(	O
name	array
)	O
;	O
if	O
(	O
i	int
&&	O
s	pointer
&&	O
strlen	function
(	O
name	array
)	O
==	O
0	int
)	O
{	O
strcpy	function
(	O
name	array
,	O
"."	pointer
)	O
;	O
}	O
}	O
void	O
swlib_toggle_leading_slash	function
(	O
char	O
*	O
mode	array
,	O
char	O
*	O
name	array
,	O
int	O
*	O
pflag	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
mode	array
,	O
"drop"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
name	array
==	O
'/'	O
&&	O
strlen	function
(	O
name	array
)	O
>	O
1	int
)	O
{	O
memmove	function
(	O
name	array
,	O
name	array
+	O
1	int
,	O
strlen	function
(	O
name	array
)	O
)	O
;	O
*	O
pflag	pointer
=	O
1	int
;	O
}	O
else	O
{	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
mode	array
,	O
"restore"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
pflag	pointer
)	O
{	O
memmove	function
(	O
name	array
+	O
1	int
,	O
name	array
,	O
strlen	function
(	O
name	array
)	O
+	O
1	int
)	O
;	O
*	O
name	array
=	O
'/'	O
;	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
}	O
void	O
swlib_slashclean	function
(	O
char	O
*	O
path	pointer
)	O
{	O
swlib_squash_double_slash	function
(	O
path	pointer
)	O
;	O
swlib_squash_leading_dot_slash	function
(	O
path	pointer
)	O
;	O
swlib_squash_trailing_slash	function
(	O
path	pointer
)	O
;	O
return	O
;	O
}	O
int	O
swlib_process_hex_escapes	function
(	O
char	O
*	O
s1	pointer
)	O
{	O
process_all_hex_escapes	function
(	O
s1	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swlib_compare_8859	function
(	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
s2	pointer
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
so1	pointer
;	O
STROB	struct
*	O
so2	pointer
;	O
so1	pointer
=	O
NULL	O
;	O
so2	pointer
=	O
NULL	O
;	O
if	O
(	O
strchr	function
(	O
s1	pointer
,	O
'\\'	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"unexpanding S1 [%s]"	pointer
,	O
s2	pointer
)	O
;	O
so1	pointer
=	O
strob_open	function
(	O
strlen	function
(	O
s1	pointer
)	O
)	O
;	O
swlib_unexpand_escapes	function
(	O
so1	pointer
,	O
s1	pointer
)	O
;	O
s1	pointer
=	O
strob_str	function
(	O
so1	pointer
)	O
;	O
process_all_hex_escapes	function
(	O
s1	pointer
)	O
;	O
}	O
if	O
(	O
strchr	function
(	O
s2	pointer
,	O
'\\'	O
)	O
!=	O
NULL	O
)	O
{	O
E_DEBUG2	O
(	O
"unexpanding S2 [%s]"	pointer
,	O
s2	pointer
)	O
;	O
so2	pointer
=	O
strob_open	function
(	O
strlen	function
(	O
s2	pointer
)	O
)	O
;	O
swlib_unexpand_escapes	function
(	O
so2	pointer
,	O
s2	pointer
)	O
;	O
s2	pointer
=	O
strob_str	function
(	O
so2	pointer
)	O
;	O
process_all_hex_escapes	function
(	O
s2	pointer
)	O
;	O
}	O
if	O
(	O
strchr	function
(	O
s1	pointer
,	O
'#'	O
)	O
||	O
strchr	function
(	O
s2	pointer
,	O
'#'	O
)	O
)	O
{	O
E_DEBUG3	O
(	O
"Comparing [%s] [%s]"	pointer
,	O
s1	pointer
,	O
s2	pointer
)	O
;	O
}	O
ret	int
=	O
swlib_dir_compare	function
(	O
s1	pointer
,	O
s2	pointer
,	O
SWC_FC_NOAB	int
)	O
;	O
if	O
(	O
so1	pointer
)	O
strob_close	function
(	O
so1	pointer
)	O
;	O
if	O
(	O
so2	pointer
)	O
strob_close	function
(	O
so2	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_vrelpath_compare	function
(	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
s2	pointer
,	O
char	O
*	O
cwd	short
)	O
{	O
if	O
(	O
(	O
(	O
*	O
s1	pointer
!=	O
'/'	O
)	O
&&	O
(	O
*	O
s2	pointer
!=	O
'/'	O
)	O
)	O
||	O
(	O
(	O
*	O
s1	pointer
==	O
'/'	O
)	O
&&	O
(	O
*	O
s2	pointer
==	O
'/'	O
)	O
)	O
)	O
{	O
return	O
swlib_dir_compare	function
(	O
s1	pointer
,	O
s2	pointer
,	O
SWC_FC_NOOP	int
)	O
;	O
}	O
else	O
{	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
if	O
(	O
form_abspath	function
(	O
tmp	pointer
,	O
s1	pointer
,	O
cwd	short
)	O
==	O
0	int
)	O
{	O
return	O
swlib_dir_compare	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
s2	pointer
,	O
SWC_FC_NOOP	int
)	O
;	O
}	O
else	O
if	O
(	O
form_abspath	function
(	O
tmp	pointer
,	O
s2	pointer
,	O
cwd	short
)	O
==	O
0	int
)	O
{	O
return	O
swlib_dir_compare	function
(	O
s1	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
SWC_FC_NOOP	int
)	O
;	O
}	O
else	O
{	O
SWLIB_ALLOC_ASSERT	O
(	O
0	int
)	O
;	O
;	O
}	O
}	O
SWLIB_ALLOC_ASSERT	O
(	O
0	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
int	O
swlib_basename_compare	function
(	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
s2	pointer
)	O
{	O
char	O
*	O
s1b	pointer
;	O
char	O
*	O
s2b	pointer
;	O
int	O
ret	int
;	O
s1b	pointer
=	O
strrchr	function
(	O
s1	pointer
,	O
'/'	O
)	O
;	O
s2b	pointer
=	O
strrchr	function
(	O
s2	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
s1b	pointer
&&	O
strlen	function
(	O
s1	pointer
)	O
&&	O
*	O
(	O
s1b	pointer
+	O
1	int
)	O
)	O
{	O
s1	pointer
=	O
s1b	pointer
+	O
1	int
;	O
}	O
if	O
(	O
s2b	pointer
&&	O
strlen	function
(	O
s2	pointer
)	O
&&	O
*	O
(	O
s2b	pointer
+	O
1	int
)	O
)	O
{	O
s2	pointer
=	O
s2b	pointer
+	O
1	int
;	O
}	O
ret	int
=	O
swlib_dir_compare	function
(	O
s1	pointer
,	O
s2	pointer
,	O
SWC_FC_NOOP	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_dir_compare	function
(	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
s2	pointer
,	O
int	O
FC_compare_flag	int
)	O
{	O
int	O
ret	int
;	O
int	O
leading_p1	int
=	O
0	int
;	O
int	O
leading_p2	int
=	O
0	int
;	O
int	O
leading_d1	int
=	O
0	int
;	O
int	O
leading_d2	int
=	O
0	int
;	O
int	O
trailing_p1	int
=	O
0	int
;	O
int	O
trailing_d1	int
=	O
0	int
;	O
int	O
trailing_p2	int
=	O
0	int
;	O
int	O
trailing_d2	int
=	O
0	int
;	O
if	O
(	O
FC_compare_flag	int
==	O
SWC_FC_NOAB	int
)	O
{	O
swlib_toggle_leading_slash	function
(	O
"drop"	pointer
,	O
s1	pointer
,	O
&	O
leading_p1	int
)	O
;	O
swlib_toggle_leading_slash	function
(	O
"drop"	pointer
,	O
s2	pointer
,	O
&	O
leading_p2	int
)	O
;	O
}	O
else	O
if	O
(	O
FC_compare_flag	int
==	O
SWC_FC_NORE	int
)	O
{	O
;	O
}	O
else	O
{	O
;	O
}	O
swlib_toggle_trailing_slash	function
(	O
"drop"	pointer
,	O
s1	pointer
,	O
&	O
trailing_p1	int
)	O
;	O
swlib_toggle_trailing_slash	function
(	O
"drop"	pointer
,	O
s2	pointer
,	O
&	O
trailing_p2	int
)	O
;	O
swlib_toggle_trailing_slashdot	function
(	O
"drop"	pointer
,	O
s1	pointer
,	O
&	O
trailing_d1	int
)	O
;	O
swlib_toggle_trailing_slashdot	function
(	O
"drop"	pointer
,	O
s2	pointer
,	O
&	O
trailing_d2	int
)	O
;	O
swlib_toggle_leading_dotslash	function
(	O
"drop"	pointer
,	O
s1	pointer
,	O
&	O
leading_d1	int
)	O
;	O
swlib_toggle_leading_dotslash	function
(	O
"drop"	pointer
,	O
s2	pointer
,	O
&	O
leading_d2	int
)	O
;	O
ret	int
=	O
strcmp	function
(	O
s1	pointer
,	O
s2	pointer
)	O
;	O
swlib_toggle_leading_dotslash	function
(	O
"restore"	pointer
,	O
s1	pointer
,	O
&	O
leading_d1	int
)	O
;	O
swlib_toggle_leading_dotslash	function
(	O
"restore"	pointer
,	O
s2	pointer
,	O
&	O
leading_d2	int
)	O
;	O
swlib_toggle_trailing_slashdot	function
(	O
"restore"	pointer
,	O
s1	pointer
,	O
&	O
trailing_d1	int
)	O
;	O
swlib_toggle_trailing_slashdot	function
(	O
"restore"	pointer
,	O
s2	pointer
,	O
&	O
trailing_d2	int
)	O
;	O
swlib_toggle_trailing_slash	function
(	O
"restore"	pointer
,	O
s1	pointer
,	O
&	O
trailing_p1	int
)	O
;	O
swlib_toggle_trailing_slash	function
(	O
"restore"	pointer
,	O
s2	pointer
,	O
&	O
trailing_p2	int
)	O
;	O
if	O
(	O
FC_compare_flag	int
==	O
SWC_FC_NOAB	int
)	O
{	O
swlib_toggle_leading_slash	function
(	O
"restore"	pointer
,	O
s1	pointer
,	O
&	O
leading_p1	int
)	O
;	O
swlib_toggle_leading_slash	function
(	O
"restore"	pointer
,	O
s2	pointer
,	O
&	O
leading_p2	int
)	O
;	O
}	O
else	O
if	O
(	O
FC_compare_flag	int
==	O
SWC_FC_NORE	int
)	O
{	O
;	O
}	O
else	O
{	O
;	O
}	O
return	O
ret	int
;	O
}	O
char	O
*	O
swlib_dirname	function
(	O
STROB	struct
*	O
dest	pointer
,	O
char	O
*	O
source	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
strob_strcpy	function
(	O
dest	pointer
,	O
source	pointer
)	O
;	O
s	pointer
=	O
strrchr	function
(	O
strob_str	function
(	O
dest	pointer
)	O
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
strob_strcpy	function
(	O
dest	pointer
,	O
"."	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
s	pointer
!=	O
strob_str	function
(	O
dest	pointer
)	O
)	O
*	O
s	pointer
=	O
'\0'	O
;	O
else	O
*	O
(	O
s	pointer
+	O
1	int
)	O
=	O
'\0'	O
;	O
}	O
return	O
strob_str	function
(	O
dest	pointer
)	O
;	O
}	O
char	O
*	O
swlib_basename	function
(	O
STROB	struct
*	O
dest	pointer
,	O
char	O
*	O
source	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
dest	pointer
==	O
NULL	O
)	O
{	O
s	pointer
=	O
strrchr	function
(	O
source	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
source	pointer
;	O
s	pointer
++	O
;	O
while	O
(	O
*	O
s	pointer
==	O
'/'	O
)	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
if	O
(	O
s	pointer
>	O
source	pointer
)	O
return	O
s	pointer
-	O
1	int
;	O
return	O
source	pointer
;	O
}	O
return	O
s	pointer
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
dest	pointer
,	O
source	pointer
)	O
;	O
s	pointer
=	O
swlib_basename	function
(	O
NULL	O
,	O
strob_str	function
(	O
dest	pointer
)	O
)	O
;	O
memmove	function
(	O
strob_str	function
(	O
dest	pointer
)	O
,	O
s	pointer
,	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
)	O
;	O
return	O
strob_str	function
(	O
dest	pointer
)	O
;	O
}	O
}	O
int	O
swlib_unix_dirtrunc	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
swlib_squash_trailing_slash	function
(	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
swlib_squash_all_dot_slash	function
(	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
s	pointer
=	O
strrchr	function
(	O
strob_str	function
(	O
buf	pointer
)	O
,	O
'/'	O
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
s	pointer
==	O
strob_str	function
(	O
buf	pointer
)	O
||	O
(	O
s	pointer
==	O
strob_str	function
(	O
buf	pointer
)	O
+	O
1	int
&&	O
(	O
int	O
)	O
(	O
*	O
strob_str	function
(	O
buf	pointer
)	O
)	O
==	O
'.'	O
)	O
||	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
*	O
s	pointer
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
int	O
swlib_unix_dirtrunc_n	function
(	O
STROB	struct
*	O
buf	pointer
,	O
int	O
n	long
)	O
{	O
int	O
i	int
;	O
int	O
ret	int
;	O
i	int
=	O
n	long
;	O
while	O
(	O
i	int
>	O
0	int
)	O
{	O
ret	int
=	O
swlib_unix_dirtrunc	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
break	O
;	O
i	int
--	O
;	O
}	O
return	O
n	long
-	O
i	int
;	O
}	O
int	O
swlib_unix_dircat	function
(	O
STROB	struct
*	O
dest	pointer
,	O
char	O
*	O
dirname	pointer
)	O
{	O
char	O
*	O
newp	pointer
;	O
char	O
*	O
s	pointer
=	O
strob_str	function
(	O
dest	pointer
)	O
;	O
if	O
(	O
!	O
dirname	pointer
||	O
strlen	function
(	O
dirname	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
)	O
{	O
if	O
(	O
s	pointer
[	O
strlen	function
(	O
s	pointer
)	O
-	O
1	int
]	O
!=	O
'/'	O
)	O
strob_strcat	function
(	O
dest	pointer
,	O
"/"	pointer
)	O
;	O
}	O
newp	pointer
=	O
swlib_strdup	function
(	O
dirname	pointer
)	O
;	O
SWLIB_ALLOC_ASSERT	O
(	O
newp	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
strob_strlen	function
(	O
dest	pointer
)	O
)	O
swlib_squash_leading_dot_slash	function
(	O
newp	pointer
)	O
;	O
strob_strcat	function
(	O
dest	pointer
,	O
newp	pointer
)	O
;	O
swlib_squash_double_slash	function
(	O
strob_str	function
(	O
dest	pointer
)	O
)	O
;	O
swbis_free	O
(	O
newp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swlib_resolve_path	function
(	O
char	O
*	O
ppath	pointer
,	O
int	O
*	O
depth	pointer
,	O
STROB	struct
*	O
resolved_path	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
int	O
startnames	int
=	O
0	int
;	O
int	O
count	long
=	O
0	int
;	O
int	O
numcomponents	int
=	O
0	int
;	O
char	O
*	O
path	pointer
=	O
swlib_strdup	function
(	O
ppath	pointer
)	O
;	O
char	O
*	O
s	pointer
;	O
swlib_slashclean	function
(	O
path	pointer
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
resolved_path	pointer
)	O
strob_strcpy	function
(	O
resolved_path	pointer
,	O
""	pointer
)	O
;	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
path	pointer
,	O
"/"	pointer
)	O
;	O
while	O
(	O
s	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
".."	pointer
)	O
==	O
0	int
&&	O
!	O
startnames	int
)	O
{	O
count	long
++	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"."	pointer
)	O
==	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
".."	pointer
)	O
==	O
0	int
&&	O
startnames	int
)	O
{	O
count	long
--	O
;	O
}	O
else	O
{	O
count	long
++	O
;	O
startnames	int
=	O
1	int
;	O
}	O
if	O
(	O
resolved_path	pointer
)	O
{	O
strob_strcat	function
(	O
resolved_path	pointer
,	O
s	pointer
)	O
;	O
strob_strcat	function
(	O
resolved_path	pointer
,	O
"/"	pointer
)	O
;	O
}	O
numcomponents	int
++	O
;	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
"/"	pointer
)	O
;	O
}	O
if	O
(	O
depth	pointer
)	O
*	O
depth	pointer
=	O
count	long
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
swbis_free	O
(	O
path	pointer
)	O
;	O
return	O
numcomponents	int
;	O
}	O
int	O
swlib_exec_filter	function
(	O
SHCMD	struct
*	O
*	O
cmd	int
,	O
int	O
src_fd	int
,	O
STROB	struct
*	O
output	pointer
)	O
{	O
int	O
input_pipe	array
[	O
2	int
]	O
;	O
int	O
ifd	int
,	O
ofd	int
,	O
i	int
=	O
0	int
;	O
int	O
childi	int
;	O
int	O
retval	int
;	O
int	O
status	int
;	O
int	O
cret	int
;	O
int	O
ret	int
;	O
retval	int
=	O
0	int
;	O
ifd	int
=	O
src_fd	int
;	O
while	O
(	O
cmd	int
[	O
i	int
]	O
)	O
i	int
++	O
;	O
ofd	int
=	O
shcmd_get_dstfd	function
(	O
cmd	int
[	O
--	O
i	int
]	O
)	O
;	O
input_pipe	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
input_pipe	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
ifd	int
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
pipe	function
(	O
input_pipe	array
)	O
;	O
childi	int
=	O
swfork	O
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
childi	int
==	O
0	int
)	O
{	O
int	O
ret	int
;	O
swgp_signal	function
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGTERM	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGUSR1	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGUSR2	int
,	O
SIG_DFL	O
)	O
;	O
if	O
(	O
ifd	int
!=	O
0	int
)	O
close	pointer
(	O
0	int
)	O
;	O
if	O
(	O
ifd	int
!=	O
1	int
)	O
close	pointer
(	O
1	int
)	O
;	O
close	pointer
(	O
input_pipe	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
ofd	int
)	O
;	O
retval	int
=	O
swlib_pump_amount	function
(	O
input_pipe	array
[	O
1	int
]	O
,	O
ifd	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
retval	int
<	O
0	int
)	O
ret	int
=	O
1	int
;	O
else	O
ret	int
=	O
0	int
;	O
_exit	function
(	O
ret	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
childi	int
<	O
0	int
)	O
{	O
SWLIB_INTERNAL	O
(	O
"swlib_exec_filter: 0001."	pointer
)	O
;	O
return	O
-	O
(	O
INT_MAX	O
)	O
;	O
}	O
close	pointer
(	O
input_pipe	array
[	O
1	int
]	O
)	O
;	O
shcmd_set_srcfd	function
(	O
cmd	int
[	O
0	int
]	O
,	O
input_pipe	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
output	pointer
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swlib_shcmd_output_strob	function
(	O
output	pointer
,	O
cmd	int
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
shcmd_command	function
(	O
cmd	int
)	O
;	O
}	O
close	pointer
(	O
input_pipe	array
[	O
0	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
cret	int
=	O
126	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
waitpid	function
(	O
childi	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
childi	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
cret	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
if	O
(	O
cret	int
!=	O
0	int
)	O
{	O
SWLIB_ERROR	O
(	O
""	pointer
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"child OK"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
SWLIB_ERROR	O
(	O
""	pointer
)	O
;	O
cret	int
=	O
127	int
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
SWLIB_ERROR2	O
(	O
"%s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
cret	int
=	O
0	int
;	O
if	O
(	O
output	pointer
)	O
swlib_shcmd_output_strob	function
(	O
output	pointer
,	O
cmd	int
)	O
;	O
else	O
shcmd_command	function
(	O
cmd	int
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
cret	int
==	O
127	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
shcmd_wait	function
(	O
cmd	int
)	O
;	O
}	O
E_DEBUG2	O
(	O
"retval=%d"	pointer
,	O
retval	int
)	O
;	O
E_DEBUG2	O
(	O
"cret=%d"	pointer
,	O
cret	int
)	O
;	O
return	O
(	O
retval	int
||	O
cret	int
)	O
;	O
}	O
SYNCT	struct
*	O
swlib_synct_create	function
(	O
void	O
)	O
{	O
SYNCT	struct
*	O
synct	pointer
=	O
(	O
SYNCT	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SYNCT	struct
)	O
)	O
;	O
int	O
len	int
;	O
len	int
=	O
(	O
3	int
*	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
+	O
1	int
;	O
synct	pointer
->	O
bufM	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
malloc	function
(	O
(	O
size_t	long
)	O
len	int
)	O
;	O
if	O
(	O
!	O
synct	pointer
->	O
bufM	pointer
)	O
_exit	function
(	O
44	int
)	O
;	O
memset	function
(	O
synct	pointer
->	O
bufM	pointer
,	O
(	O
int	O
)	O
(	O
'\0'	O
)	O
,	O
len	int
)	O
;	O
synct	pointer
->	O
tailM	pointer
=	O
synct	pointer
->	O
bufM	pointer
+	O
SWLIB_SYNCT_BLOCKSIZE	int
;	O
synct	pointer
->	O
countM	int
=	O
0	int
;	O
synct	pointer
->	O
mtM	pointer
=	O
strdup	function
(	O
SWBIS_SYNCT_EOF	O
)	O
;	O
synct	pointer
->	O
do_debugM	int
=	O
0	int
;	O
synct	pointer
->	O
debugfdM	int
=	O
-	O
1	int
;	O
return	O
synct	pointer
;	O
}	O
void	O
swlib_synct_delete	function
(	O
SYNCT	struct
*	O
synct	pointer
)	O
{	O
if	O
(	O
synct	pointer
->	O
countM	int
%	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Warning: swlib_synct_delete() block count error: %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
synct	pointer
->	O
countM	int
)	O
;	O
}	O
if	O
(	O
synct	pointer
->	O
debugfdM	int
>	O
0	int
)	O
close	pointer
(	O
synct	pointer
->	O
debugfdM	int
)	O
;	O
free	function
(	O
synct	pointer
->	O
mtM	pointer
)	O
;	O
free	function
(	O
synct	pointer
->	O
bufM	pointer
)	O
;	O
free	function
(	O
synct	pointer
)	O
;	O
}	O
int	O
swlib_synct_read	function
(	O
SYNCT	struct
*	O
synct	pointer
,	O
int	O
fd	int
,	O
void	O
*	O
userbuf	pointer
)	O
{	O
unsigned	O
char	O
*	O
ibuf	pointer
;	O
unsigned	O
char	O
*	O
tbuf	pointer
;	O
char	O
*	O
z	pointer
;	O
int	O
ret	int
;	O
int	O
tret	int
;	O
int	O
check_ret	int
;	O
ibuf	pointer
=	O
synct	pointer
->	O
bufM	pointer
;	O
tbuf	pointer
=	O
synct	pointer
->	O
tailM	pointer
;	O
E_DEBUG2	O
(	O
"fd = %d"	pointer
,	O
fd	int
)	O
;	O
ret	int
=	O
synct_i_read_block	function
(	O
synct	pointer
,	O
uxfio_sfa_read	function
,	O
fd	int
,	O
(	O
char	O
*	O
)	O
ibuf	pointer
)	O
;	O
E_DEBUG2	O
(	O
"synct_i_read_block() returned %d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
return	O
0	int
;	O
check_ret	int
=	O
synct_check_for_possible_eof	function
(	O
synct	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
check_ret	int
==	O
SYNCT_EOF_CONDITION_0	int
)	O
{	O
memcpy	function
(	O
userbuf	pointer
,	O
ibuf	pointer
,	O
ret	int
)	O
;	O
return	O
(	O
int	O
)	O
SWLIB_SYNCT_BLOCKSIZE	int
;	O
}	O
else	O
{	O
E_DEBUG2	O
(	O
"fd = %d"	pointer
,	O
fd	int
)	O
;	O
ret	int
=	O
synct_i_read_block	function
(	O
synct	pointer
,	O
uxfio_sfa_read	function
,	O
fd	int
,	O
(	O
char	O
*	O
)	O
tbuf	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
2	int
;	O
z	pointer
=	O
malloc	function
(	O
(	O
size_t	long
)	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
memset	function
(	O
z	pointer
,	O
'\0'	O
,	O
(	O
size_t	long
)	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
ret	int
=	O
memcmp	function
(	O
z	pointer
,	O
tbuf	pointer
,	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
free	function
(	O
z	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
check_ret	int
==	O
SYNCT_EOF_CONDITION_2	int
)	O
{	O
tret	int
=	O
1	int
;	O
while	O
(	O
tret	int
>	O
0	int
)	O
tret	int
=	O
synct_i_read_block	function
(	O
synct	pointer
,	O
timed_atomic_read5	function
,	O
fd	int
,	O
(	O
char	O
*	O
)	O
tbuf	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
memcpy	function
(	O
userbuf	pointer
,	O
ibuf	pointer
,	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
memcpy	function
(	O
(	O
(	O
char	O
*	O
)	O
userbuf	pointer
)	O
+	O
SWLIB_SYNCT_BLOCKSIZE	int
,	O
tbuf	pointer
,	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
return	O
(	O
int	O
)	O
(	O
2	int
*	O
SWLIB_SYNCT_BLOCKSIZE	int
)	O
;	O
}	O
}	O
return	O
-	O
2	int
;	O
}	O
int	O
swlib_synct_suck	function
(	O
int	O
ofd	int
,	O
int	O
ifd	int
)	O
{	O
int	O
ret	int
;	O
int	O
wret	int
;	O
int	O
wtotal	int
=	O
0	int
;	O
char	O
buf	pointer
[	O
SWLIB_SYNCT_BLOCKSIZE	int
+	O
SWLIB_SYNCT_BLOCKSIZE	int
+	O
1	int
]	O
;	O
SYNCT	struct
*	O
synct	pointer
;	O
synct	pointer
=	O
swlib_synct_create	function
(	O
)	O
;	O
do	O
{	O
ret	int
=	O
swlib_synct_read	function
(	O
synct	pointer
,	O
ifd	int
,	O
buf	pointer
)	O
;	O
E_DEBUG2	O
(	O
"swlib_synct_read returned %d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
>	O
0	int
)	O
{	O
wret	int
=	O
synct_i_no_null_write	function
(	O
ofd	int
,	O
buf	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
wret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
wtotal	int
+=	O
wret	int
;	O
}	O
}	O
while	O
(	O
ret	int
>	O
0	int
)	O
;	O
swlib_synct_delete	function
(	O
synct	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
return	O
wtotal	int
;	O
}	O
int	O
swlib_read_amount	function
(	O
int	O
suction_fd	int
,	O
intmax_t	long
amount	long
)	O
{	O
return	O
swlib_pump_amount	function
(	O
-	O
1	int
,	O
suction_fd	int
,	O
amount	long
)	O
;	O
}	O
int	O
swlib_pipe_pump	function
(	O
int	O
ofd	int
,	O
int	O
ifd	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
swlib_pump_amount	function
(	O
ofd	int
,	O
ifd	int
,	O
-	O
1	int
)	O
;	O
}	O
intmax_t	long
swlib_pump_amount	function
(	O
int	O
discharge_fd	int
,	O
int	O
suction_fd	int
,	O
intmax_t	long
amount	long
)	O
{	O
intmax_t	long
i	int
=	O
amount	long
;	O
if	O
(	O
swlib_i_pipe_pump	function
(	O
suction_fd	int
,	O
discharge_fd	int
,	O
&	O
i	int
,	O
-	O
1	int
,	O
NULL	O
,	O
uxfio_read	function
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
i	int
;	O
}	O
int	O
swlib_fork_to_make_unixfd	function
(	O
int	O
uxfio_fd	int
,	O
sigset_t	struct
*	O
blockmask	pointer
,	O
sigset_t	struct
*	O
defaultmask	pointer
,	O
int	O
*	O
ppid	pointer
)	O
{	O
int	O
upipe	array
[	O
2	int
]	O
;	O
pid_t	int
upid	int
;	O
if	O
(	O
ppid	pointer
)	O
*	O
ppid	pointer
=	O
(	O
int	O
)	O
0	int
;	O
if	O
(	O
uxfio_fd	int
<=	O
OPEN_MAX	int
)	O
return	O
uxfio_fd	int
;	O
if	O
(	O
pipe	function
(	O
upipe	array
)	O
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
upid	int
=	O
swndfork	function
(	O
blockmask	pointer
,	O
defaultmask	pointer
)	O
)	O
>	O
0	int
)	O
{	O
uxfio_close	function
(	O
uxfio_fd	int
)	O
;	O
close	pointer
(	O
upipe	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
ppid	pointer
)	O
*	O
ppid	pointer
=	O
(	O
int	O
)	O
upid	int
;	O
return	O
upipe	array
[	O
0	int
]	O
;	O
}	O
else	O
if	O
(	O
upid	int
==	O
0	int
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
close	pointer
(	O
upipe	array
[	O
0	int
]	O
)	O
;	O
ret	int
=	O
swlib_pipe_pump	function
(	O
upipe	array
[	O
1	int
]	O
,	O
uxfio_fd	int
)	O
;	O
if	O
(	O
ret	int
>=	O
0	int
)	O
ret	int
=	O
0	int
;	O
else	O
ret	int
=	O
255	int
;	O
_exit	function
(	O
ret	int
)	O
;	O
}	O
else	O
{	O
SWLIB_RESOURCE	O
(	O
"fork failed"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
swlib_is_c701_escape	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
(	O
c	int
==	O
'\"'	O
)	O
||	O
(	O
c	int
==	O
'#'	O
)	O
||	O
(	O
c	int
==	O
'\\'	O
)	O
||	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
int	O
swlib_is_ansi_escape	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
(	O
c	int
==	O
'n'	O
)	O
||	O
(	O
c	int
==	O
't'	O
)	O
||	O
(	O
c	int
==	O
'v'	O
)	O
||	O
(	O
c	int
==	O
'b'	O
)	O
||	O
(	O
c	int
==	O
'r'	O
)	O
||	O
(	O
c	int
==	O
'f'	O
)	O
||	O
(	O
c	int
==	O
'x'	O
)	O
||	O
(	O
c	int
==	O
'a'	O
)	O
||	O
(	O
c	int
==	O
'\\'	O
)	O
||	O
(	O
c	int
==	O
'?'	O
)	O
||	O
(	O
c	int
==	O
'\''	O
)	O
||	O
(	O
c	int
==	O
'\"'	O
)	O
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
swlib_c701_escaped_value	function
(	O
int	O
src	pointer
,	O
int	O
*	O
is_escape	pointer
)	O
{	O
*	O
is_escape	pointer
=	O
1	int
;	O
switch	O
(	O
src	pointer
)	O
{	O
case	O
'\\'	O
:	O
return	O
(	O
int	O
)	O
'\\'	O
;	O
break	O
;	O
case	O
'#'	O
:	O
return	O
(	O
int	O
)	O
'#'	O
;	O
break	O
;	O
case	O
'\"'	O
:	O
return	O
(	O
int	O
)	O
'\"'	O
;	O
break	O
;	O
}	O
*	O
is_escape	pointer
=	O
0	int
;	O
return	O
(	O
int	O
)	O
(	O
src	pointer
)	O
;	O
}	O
int	O
swlib_ansi_escaped_value	function
(	O
int	O
src	pointer
,	O
int	O
*	O
is_escape	pointer
)	O
{	O
*	O
is_escape	pointer
=	O
1	int
;	O
switch	O
(	O
src	pointer
)	O
{	O
case	O
'\\'	O
:	O
return	O
(	O
int	O
)	O
'\\'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
return	O
(	O
int	O
)	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
return	O
(	O
int	O
)	O
'\r'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
return	O
(	O
int	O
)	O
'\v'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
return	O
(	O
int	O
)	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
return	O
(	O
int	O
)	O
'\f'	O
;	O
break	O
;	O
}	O
*	O
is_escape	pointer
=	O
0	int
;	O
return	O
(	O
int	O
)	O
(	O
src	pointer
)	O
;	O
}	O
o__inline__	O
char	O
*	O
swlib_strdup	function
(	O
char	O
*	O
s	pointer
)	O
{	O
return	O
strdup	function
(	O
s	pointer
)	O
;	O
}	O
char	O
*	O
swlib_strncpy	function
(	O
char	O
*	O
dst	pointer
,	O
const	O
char	O
*	O
src	pointer
,	O
size_t	long
n	long
)	O
{	O
char	O
*	O
p	pointer
=	O
strncpy	function
(	O
dst	pointer
,	O
src	pointer
,	O
n	long
-	O
1	int
)	O
;	O
dst	pointer
[	O
n	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
p	pointer
;	O
}	O
int	O
swlib_writef	function
(	O
int	O
fd	int
,	O
STROB	struct
*	O
buffer	array
,	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
int	O
ret	int
;	O
int	O
newret	int
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
format	pointer
)	O
;	O
ret	int
=	O
strob_vsprintf	function
(	O
buffer	array
,	O
0	int
,	O
format	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
newret	int
=	O
atomicio	function
(	O
uxfio_write	function
,	O
fd	int
,	O
(	O
void	O
*	O
)	O
strob_str	function
(	O
buffer	array
)	O
,	O
(	O
size_t	long
)	O
(	O
ret	int
)	O
)	O
;	O
if	O
(	O
newret	int
!=	O
ret	int
)	O
return	O
-	O
1	int
;	O
return	O
newret	int
;	O
}	O
int	O
swlib_write_OLDcatalog_stream	function
(	O
XFORMAT	struct
*	O
package	pointer
,	O
int	O
ofd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taruib_write_catalog_stream	function
(	O
(	O
void	O
*	O
)	O
package	pointer
,	O
ofd	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_write_catalog_stream	function
(	O
XFORMAT	struct
*	O
package	pointer
,	O
int	O
ofd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taruib_write_catalog_stream	function
(	O
(	O
void	O
*	O
)	O
package	pointer
,	O
ofd	int
,	O
1	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_write_OLDstorage_stream	function
(	O
XFORMAT	struct
*	O
package	pointer
,	O
int	O
ofd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taruib_write_storage_stream	function
(	O
(	O
void	O
*	O
)	O
package	pointer
,	O
ofd	int
,	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_write_storage_stream	function
(	O
XFORMAT	struct
*	O
package	pointer
,	O
int	O
ofd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
taruib_write_storage_stream	function
(	O
(	O
void	O
*	O
)	O
package	pointer
,	O
ofd	int
,	O
1	int
,	O
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_write_signing_files	function
(	O
XFORMAT	struct
*	O
package	pointer
,	O
int	O
ofd	int
,	O
int	O
which_file	int
,	O
int	O
do_adjunct_md5	int
)	O
{	O
int	O
nullfd	int
;	O
int	O
ifd	int
=	O
xformat_get_ifd	function
(	O
package	pointer
)	O
;	O
int	O
ret	int
;	O
int	O
bytesret	int
;	O
int	O
retval	int
=	O
0	int
;	O
STROB	struct
*	O
namebuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
SWPATH	struct
*	O
swpath	pointer
=	O
swpath_open	function
(	O
""	pointer
)	O
;	O
char	O
*	O
name	array
;	O
char	O
nullblock	array
[	O
512	int
]	O
;	O
int	O
writeit	int
;	O
int	O
do_trailer	int
=	O
0	int
;	O
int	O
format	pointer
=	O
xformat_get_format	function
(	O
package	pointer
)	O
;	O
long	O
int	O
bytes	int
=	O
0	int
;	O
memset	function
(	O
nullblock	array
,	O
'\0'	O
,	O
sizeof	O
(	O
nullblock	array
)	O
)	O
;	O
if	O
(	O
!	O
swpath	pointer
)	O
return	O
-	O
21	int
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
return	O
-	O
32	int
;	O
nullfd	int
=	O
swbis_devnull_open	O
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
if	O
(	O
nullfd	int
<	O
0	int
)	O
return	O
-	O
2	int
;	O
while	O
(	O
(	O
ret	int
=	O
xformat_read_header	function
(	O
package	pointer
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
xformat_is_end_of_archive	function
(	O
package	pointer
)	O
)	O
{	O
break	O
;	O
}	O
xformat_get_name	function
(	O
package	pointer
,	O
namebuf	pointer
)	O
;	O
name	array
=	O
strob_str	function
(	O
namebuf	pointer
)	O
;	O
swpath_parse_path	function
(	O
swpath	pointer
,	O
name	array
)	O
;	O
if	O
(	O
swpath_get_is_catalog	function
(	O
swpath	pointer
)	O
==	O
SWPATH_CTYPE_DIR	O
)	O
{	O
if	O
(	O
which_file	int
==	O
0	int
)	O
writeit	int
=	O
nullfd	int
;	O
else	O
writeit	int
=	O
ofd	int
;	O
}	O
else	O
if	O
(	O
swpath_get_is_catalog	function
(	O
swpath	pointer
)	O
==	O
SWPATH_CTYPE_CAT	int
)	O
{	O
if	O
(	O
which_file	int
==	O
0	int
)	O
writeit	int
=	O
ofd	int
;	O
else	O
writeit	int
=	O
nullfd	int
;	O
}	O
else	O
if	O
(	O
swpath_get_is_catalog	function
(	O
swpath	pointer
)	O
==	O
SWPATH_CTYPE_STORE	int
)	O
{	O
if	O
(	O
which_file	int
==	O
0	int
)	O
{	O
do_trailer	int
=	O
1	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
do_adjunct_md5	int
)	O
{	O
int	O
filetype	pointer
=	O
xformat_get_tar_typeflag	function
(	O
package	pointer
)	O
;	O
if	O
(	O
filetype	pointer
!=	O
REGTYPE	char
&&	O
filetype	pointer
!=	O
DIRTYPE	char
)	O
writeit	int
=	O
nullfd	int
;	O
else	O
writeit	int
=	O
ofd	int
;	O
}	O
else	O
{	O
writeit	int
=	O
ofd	int
;	O
}	O
}	O
}	O
else	O
{	O
SWLIB_INTERNAL	O
(	O
"internal error returned by swpath_get_is_catalog"	pointer
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
bytesret	int
=	O
0	int
;	O
xformat_set_ofd	function
(	O
package	pointer
,	O
writeit	int
)	O
;	O
bytesret	int
+=	O
xformat_write_header	function
(	O
package	pointer
)	O
;	O
bytesret	int
+=	O
xformat_copy_pass	function
(	O
package	pointer
,	O
writeit	int
,	O
ifd	int
)	O
;	O
if	O
(	O
writeit	int
!=	O
nullfd	int
)	O
{	O
bytes	int
+=	O
bytesret	int
;	O
}	O
}	O
if	O
(	O
do_trailer	int
&&	O
(	O
format	pointer
==	O
arf_ustar	int
||	O
format	pointer
==	O
arf_tar	int
)	O
)	O
{	O
uxfio_write	function
(	O
ofd	int
,	O
nullblock	array
,	O
512	int
)	O
;	O
uxfio_write	function
(	O
ofd	int
,	O
nullblock	array
,	O
512	int
)	O
;	O
}	O
if	O
(	O
which_file	int
==	O
1	int
)	O
{	O
retval	int
+=	O
taru_write_archive_trailer	function
(	O
package	pointer
->	O
taruM	pointer
,	O
arf_ustar	int
,	O
ofd	int
,	O
512	int
,	O
(	O
int	O
)	O
bytes	int
,	O
xformat_get_tarheader_flags	function
(	O
package	pointer
)	O
)	O
;	O
}	O
swbis_devnull_close	O
(	O
nullfd	int
)	O
;	O
strob_close	function
(	O
namebuf	pointer
)	O
;	O
swpath_close	function
(	O
swpath	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swlib_kill_all_pids	function
(	O
pid_t	int
*	O
pid	int
,	O
int	O
num	int
,	O
int	O
signo	int
,	O
int	O
verbose_level	int
)	O
{	O
int	O
i	int
;	O
int	O
ret	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pid	int
[	O
i	int
]	O
>	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"swlib_kill_all_pids: kill[%d] signo=%d\n"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
signo	int
)	O
;	O
E_DEBUG3	O
(	O
"killing pid %d with signal %d"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
signo	int
)	O
;	O
if	O
(	O
kill	function
(	O
pid	int
[	O
i	int
]	O
,	O
signo	int
)	O
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"kill[%d] signo=%d : error : %s\n"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
signo	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
ret	int
++	O
;	O
}	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
swlib_update_pid_status	function
(	O
pid_t	int
keypid	int
,	O
int	O
value	long
,	O
pid_t	int
*	O
pid	int
,	O
int	O
*	O
status	int
,	O
int	O
len	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pid	int
[	O
i	int
]	O
==	O
keypid	int
)	O
{	O
status	int
[	O
i	int
]	O
=	O
value	long
;	O
pid	int
[	O
i	int
]	O
=	O
-	O
pid	int
[	O
i	int
]	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
swlib_wait_on_all_pids	function
(	O
pid_t	int
*	O
pid	int
,	O
int	O
num	int
,	O
int	O
*	O
status	int
,	O
int	O
flags	int
,	O
int	O
verbose_level	int
)	O
{	O
return	O
swlib_wait_on_all_pids_with_timeout	function
(	O
pid	int
,	O
num	int
,	O
status	int
,	O
flags	int
,	O
verbose_level	int
,	O
0	int
)	O
;	O
}	O
int	O
swlib_wait_on_pid_with_timeout	function
(	O
pid_t	int
pid	int
,	O
int	O
*	O
status	int
,	O
int	O
flags	int
,	O
int	O
verbose_level	int
,	O
int	O
fp_tmo	int
)	O
{	O
pid_t	int
apid	int
;	O
int	O
ret	int
;	O
apid	int
=	O
pid	int
;	O
ret	int
=	O
swlib_wait_on_all_pids_with_timeout	function
(	O
&	O
apid	int
,	O
1	int
,	O
status	int
,	O
flags	int
,	O
verbose_level	int
,	O
fp_tmo	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_wait_on_all_pids_with_timeout	function
(	O
pid_t	int
*	O
pid	int
,	O
int	O
num	int
,	O
int	O
*	O
status	int
,	O
int	O
flags	int
,	O
int	O
verbose_level	int
,	O
int	O
fp_tmo	int
)	O
{	O
time_t	long
now	long
;	O
time_t	long
start	int
;	O
int	O
wret	int
=	O
-	O
99	int
;	O
int	O
done	int
=	O
0	int
;	O
int	O
i	int
=	O
0	int
;	O
int	O
got_one	int
=	O
0	int
;	O
int	O
tmo	int
;	O
int	O
do_kill	int
;	O
do_kill	int
=	O
0	int
;	O
if	O
(	O
fp_tmo	int
<	O
0	int
)	O
{	O
do_kill	int
=	O
1	int
;	O
tmo	int
=	O
-	O
fp_tmo	int
;	O
}	O
else	O
{	O
tmo	int
=	O
fp_tmo	int
;	O
}	O
if	O
(	O
num	int
==	O
0	int
)	O
return	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
start	int
=	O
time	struct
(	O
NULL	O
)	O
;	O
now	long
=	O
start	int
;	O
while	O
(	O
!	O
done	int
&&	O
(	O
tmo	int
==	O
0	int
||	O
(	O
int	O
)	O
(	O
now	long
-	O
start	int
)	O
<	O
tmo	int
)	O
)	O
{	O
done	int
=	O
1	int
;	O
now	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pid	int
[	O
i	int
]	O
>	O
0	int
)	O
{	O
E_DEBUG2	O
(	O
"pid=%d"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
)	O
;	O
wret	int
=	O
waitpid	function
(	O
pid	int
[	O
i	int
]	O
,	O
&	O
status	int
[	O
i	int
]	O
,	O
flags	int
)	O
;	O
E_DEBUG2	O
(	O
"wret=%d"	pointer
,	O
wret	int
)	O
;	O
if	O
(	O
wret	int
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
NULL	O
,	O
STDERR_FILENO	int
,	O
"swlib_wait_on_all_pids[%d]: error : %d %s\n"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
status	int
[	O
i	int
]	O
=	O
0	int
;	O
pid	int
[	O
i	int
]	O
=	O
-	O
pid	int
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
wret	int
==	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
NULL	O
,	O
STDERR_FILENO	int
,	O
"swlib_wait_on_all_pids[%d]: returned zero waiting for process id %d\n"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
)	O
;	O
done	int
=	O
0	int
;	O
}	O
else	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_SWIDB	int
,	O
NULL	O
,	O
STDERR_FILENO	int
,	O
"swlib_wait_on_all_pids[%d]: returned exitval=%d\n"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
WEXITSTATUS	O
(	O
status	int
[	O
i	int
]	O
)	O
)	O
;	O
got_one	int
=	O
1	int
;	O
pid	int
[	O
i	int
]	O
=	O
-	O
pid	int
[	O
i	int
]	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG2	O
(	O
"already processed: pid=%d"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
)	O
;	O
;	O
}	O
}	O
if	O
(	O
flags	int
==	O
WNOHANG	int
)	O
done	int
=	O
1	int
;	O
}	O
if	O
(	O
do_kill	int
)	O
{	O
E_DEBUG	O
(	O
"killing pids SIGINT"	pointer
)	O
;	O
swlib_kill_all_pids	function
(	O
pid	int
,	O
num	int
,	O
SIGINT	int
,	O
3	int
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
E_DEBUG	O
(	O
"killing pids SIGKILL"	pointer
)	O
;	O
swlib_kill_all_pids	function
(	O
pid	int
,	O
num	int
,	O
SIGKILL	int
,	O
3	int
)	O
;	O
}	O
return	O
wret	int
;	O
}	O
int	O
swlib_sha1	function
(	O
int	O
uxfio_fd	int
,	O
char	O
*	O
digest	pointer
)	O
{	O
int	O
i	int
;	O
int	O
ret	int
;	O
unsigned	O
char	O
resblock	pointer
[	O
21	int
]	O
;	O
int	O
digest_hex_bytes	int
=	O
40	int
;	O
char	O
*	O
p	pointer
;	O
ret	int
=	O
sha_stream	function
(	O
uxfio_fd	int
,	O
resblock	pointer
)	O
;	O
p	pointer
=	O
digest	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
digest_hex_bytes	int
/	O
2	int
)	O
;	O
++	O
i	int
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"%02x"	pointer
,	O
resblock	pointer
[	O
i	int
]	O
)	O
;	O
p	pointer
+=	O
2	int
;	O
}	O
digest	pointer
[	O
digest_hex_bytes	int
]	O
=	O
'\0'	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_digests	function
(	O
int	O
ifd	int
,	O
char	O
*	O
md5	array
,	O
char	O
*	O
sha1	array
,	O
char	O
*	O
size	array
,	O
char	O
*	O
sha512	array
)	O
{	O
intmax_t	long
im	long
;	O
FILE_DIGS	struct
*	O
digs	pointer
;	O
digs	pointer
=	O
taru_digs_create	function
(	O
)	O
;	O
if	O
(	O
md5	array
)	O
digs	pointer
->	O
do_md5	short
=	O
DIGS_ENABLE_ON	int
;	O
if	O
(	O
sha1	array
)	O
digs	pointer
->	O
do_sha1	short
=	O
DIGS_ENABLE_ON	int
;	O
if	O
(	O
sha512	array
)	O
digs	pointer
->	O
do_sha512	short
=	O
DIGS_ENABLE_ON	int
;	O
if	O
(	O
size	array
)	O
digs	pointer
->	O
do_size	short
=	O
DIGS_ENABLE_ON	int
;	O
im	long
=	O
swlib_digs_copy	function
(	O
-	O
1	int
,	O
ifd	int
,	O
-	O
1	int
,	O
digs	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
md5	array
)	O
strcpy	function
(	O
md5	array
,	O
digs	pointer
->	O
md5	array
)	O
;	O
if	O
(	O
sha1	array
)	O
strcpy	function
(	O
sha1	array
,	O
digs	pointer
->	O
sha1	array
)	O
;	O
if	O
(	O
sha512	array
)	O
strcpy	function
(	O
sha512	array
,	O
digs	pointer
->	O
sha512	array
)	O
;	O
if	O
(	O
size	array
)	O
strcpy	function
(	O
size	array
,	O
digs	pointer
->	O
size	array
)	O
;	O
taru_digs_delete	function
(	O
digs	pointer
)	O
;	O
if	O
(	O
im	long
>=	O
0	int
)	O
return	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
intmax_t	long
swlib_md5_copy	function
(	O
int	O
ifd	int
,	O
intmax_t	long
count	long
,	O
char	O
*	O
md5	array
,	O
int	O
ofd	int
)	O
{	O
intmax_t	long
im	long
;	O
FILE_DIGS	struct
*	O
digs	pointer
;	O
digs	pointer
=	O
taru_digs_create	function
(	O
)	O
;	O
im	long
=	O
swlib_digs_copy	function
(	O
ofd	int
,	O
ifd	int
,	O
count	long
,	O
digs	pointer
,	O
-	O
1	int
)	O
;	O
strcpy	function
(	O
md5	array
,	O
digs	pointer
->	O
md5	array
)	O
;	O
taru_digs_delete	function
(	O
digs	pointer
)	O
;	O
return	O
im	long
;	O
}	O
intmax_t	long
swlib_digs_copy	function
(	O
int	O
ofd	int
,	O
int	O
ifd	int
,	O
intmax_t	long
count	long
,	O
FILE_DIGS	struct
*	O
digs	pointer
,	O
int	O
adjunct_ofd	int
)	O
{	O
intmax_t	long
n	long
;	O
n	long
=	O
swlib_i_digs_copy	function
(	O
ofd	int
,	O
ifd	int
,	O
count	long
,	O
digs	pointer
,	O
adjunct_ofd	int
,	O
swlib_safe_read	function
)	O
;	O
return	O
n	long
;	O
}	O
int	O
swlib_shcmd_output_fd	function
(	O
SHCMD	struct
*	O
*	O
cmdvec	pointer
)	O
{	O
int	O
status	int
;	O
SHCMD	struct
*	O
*	O
vc	pointer
;	O
SHCMD	struct
*	O
lastcmd	pointer
;	O
int	O
ot	array
[	O
2	int
]	O
;	O
pid_t	int
pid	int
;	O
int	O
fd	int
;	O
vc	pointer
=	O
cmdvec	pointer
;	O
while	O
(	O
*	O
vc	pointer
)	O
vc	pointer
++	O
;	O
if	O
(	O
vc	pointer
==	O
cmdvec	pointer
)	O
return	O
-	O
1	int
;	O
vc	pointer
--	O
;	O
lastcmd	pointer
=	O
*	O
vc	pointer
;	O
fd	int
=	O
uxfio_open	function
(	O
""	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
fd	int
;	O
uxfio_fcntl	function
(	O
fd	int
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_ON	int
)	O
;	O
uxfio_fcntl	function
(	O
fd	int
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
;	O
pipe	function
(	O
ot	array
)	O
;	O
pid	int
=	O
swfork	O
(	O
NULL	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
return	O
(	O
int	O
)	O
pid	int
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
swgp_signal	function
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGTERM	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGUSR1	int
,	O
SIG_DFL	O
)	O
;	O
swgp_signal	function
(	O
SIGUSR2	int
,	O
SIG_DFL	O
)	O
;	O
close	pointer
(	O
ot	array
[	O
0	int
]	O
)	O
;	O
shcmd_set_dstfd	function
(	O
lastcmd	pointer
,	O
ot	array
[	O
1	int
]	O
)	O
;	O
shcmd_cmdvec_exec	function
(	O
cmdvec	pointer
)	O
;	O
shcmd_cmdvec_wait2	function
(	O
cmdvec	pointer
)	O
;	O
close	pointer
(	O
ot	array
[	O
1	int
]	O
)	O
;	O
_exit	function
(	O
0	int
)	O
;	O
}	O
close	pointer
(	O
ot	array
[	O
1	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swlib_pipe_pump	function
(	O
fd	int
,	O
ot	array
[	O
0	int
]	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
uxfio_lseek	function
(	O
fd	int
,	O
(	O
off_t	long
)	O
(	O
0	int
)	O
,	O
SEEK_SET	int
)	O
;	O
close	pointer
(	O
ot	array
[	O
0	int
]	O
)	O
;	O
return	O
fd	int
;	O
}	O
int	O
swlib_shcmd_output_strob	function
(	O
STROB	struct
*	O
output	pointer
,	O
SHCMD	struct
*	O
*	O
cmdvec	pointer
)	O
{	O
char	O
*	O
base	int
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
int	O
data_len	int
=	O
0	int
;	O
int	O
buffer_len	int
=	O
0	int
;	O
int	O
fd	int
;	O
strob_strcpy	function
(	O
output	pointer
,	O
""	pointer
)	O
;	O
fd	int
=	O
swlib_shcmd_output_fd	function
(	O
cmdvec	pointer
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
uxfio_get_dynamic_buffer	function
(	O
fd	int
,	O
&	O
base	int
,	O
&	O
buffer_len	int
,	O
&	O
data_len	int
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
strob_strncat	function
(	O
output	pointer
,	O
base	int
,	O
data_len	int
)	O
;	O
uxfio_close	function
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
mode_t	int
swlib_apply_mode_umask	function
(	O
char	O
type	enum
,	O
mode_t	int
umask	function
,	O
mode_t	int
mode	array
)	O
{	O
if	O
(	O
mode	array
==	O
0	int
)	O
{	O
if	O
(	O
type	enum
==	O
SW_ITYPE_d	char
)	O
{	O
mode	array
=	O
0777	int
;	O
}	O
else	O
{	O
mode	array
=	O
0666	int
;	O
}	O
}	O
mode	array
&=	O
~	O
umask	function
;	O
return	O
mode	array
;	O
}	O
int	O
swlib_open_memfd	function
(	O
void	O
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
uxfio_open	function
(	O
""	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
fd	int
;	O
uxfio_fcntl	function
(	O
fd	int
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_ON	int
)	O
;	O
uxfio_fcntl	function
(	O
fd	int
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
;	O
return	O
fd	int
;	O
}	O
int	O
swlib_close_memfd	function
(	O
int	O
fd	int
)	O
{	O
return	O
uxfio_close	function
(	O
fd	int
)	O
;	O
}	O
int	O
swlib_pad_amount	function
(	O
int	O
fd	int
,	O
int	O
amount	long
)	O
{	O
char	O
nullblock	array
[	O
512	int
]	O
;	O
int	O
remains	int
=	O
amount	long
;	O
int	O
am	long
;	O
int	O
ret	int
;	O
int	O
count	long
=	O
0	int
;	O
memset	function
(	O
nullblock	array
,	O
'\0'	O
,	O
sizeof	O
(	O
nullblock	array
)	O
)	O
;	O
while	O
(	O
remains	int
>	O
0	int
)	O
{	O
if	O
(	O
remains	int
>	O
512	int
)	O
am	long
=	O
512	int
;	O
else	O
am	long
=	O
remains	int
;	O
if	O
(	O
am	long
<=	O
0	int
)	O
break	O
;	O
ret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
fd	int
,	O
nullblock	array
,	O
am	long
)	O
;	O
if	O
(	O
ret	int
<=	O
0	int
)	O
{	O
if	O
(	O
ret	int
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: write error: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
SWLIB_INTERNAL	O
(	O
""	pointer
)	O
;	O
if	O
(	O
count	long
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
-	O
count	long
;	O
}	O
count	long
+=	O
ret	int
;	O
remains	int
-=	O
ret	int
;	O
}	O
return	O
count	long
;	O
}	O
int	O
swlib_drop_root_privilege	function
(	O
void	O
)	O
{	O
int	O
ret	int
=	O
1	int
;	O
if	O
(	O
getuid	function
(	O
)	O
==	O
(	O
uid_t	int
)	O
(	O
0	int
)	O
)	O
{	O
uid_t	int
nob	int
;	O
if	O
(	O
taru_get_uid_by_name	function
(	O
AHS_USERNAME_NOBODY	pointer
,	O
&	O
nob	int
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Warning: the uname [%s] not found, not dropping privilege.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
AHS_USERNAME_NOBODY	pointer
)	O
;	O
ret	int
=	O
3	int
;	O
}	O
else	O
{	O
if	O
(	O
nob	int
<	O
10	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: User name 'nobody' has a uid of %d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
(	O
nob	int
)	O
)	O
;	O
}	O
if	O
(	O
setuid	function
(	O
nob	int
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: setuid(uid=%d) failed at %s:%d: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
nob	int
,	O
__FILE__	O
,	O
__LINE__	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
ret	int
=	O
2	int
;	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
return	O
ret	int
;	O
}	O
void	O
swlib_add_trailing_slash	function
(	O
STROB	struct
*	O
path	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
strob_str	function
(	O
path	pointer
)	O
;	O
if	O
(	O
!	O
strlen	function
(	O
p	pointer
)	O
)	O
{	O
strob_strcat	function
(	O
path	pointer
,	O
"/"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
(	O
p	pointer
+	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
)	O
!=	O
'/'	O
)	O
strob_strcat	function
(	O
path	pointer
,	O
"/"	pointer
)	O
;	O
}	O
int	O
swlib_altfnmatch	function
(	O
char	O
*	O
s1	pointer
,	O
char	O
*	O
s2	pointer
)	O
{	O
STROB	struct
*	O
tmp1	pointer
;	O
STROB	struct
*	O
tmp2	pointer
;	O
char	O
*	O
t1	pointer
;	O
char	O
*	O
t2	pointer
;	O
tmp1	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
tmp2	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
t1	pointer
=	O
strob_strtok	function
(	O
tmp1	pointer
,	O
s1	pointer
,	O
"|\n\r"	pointer
)	O
;	O
while	O
(	O
t1	pointer
)	O
{	O
t2	pointer
=	O
strob_strtok	function
(	O
tmp2	pointer
,	O
s2	pointer
,	O
"|\n\r"	pointer
)	O
;	O
while	O
(	O
t2	pointer
)	O
{	O
if	O
(	O
fnmatch	function
(	O
t1	pointer
,	O
t2	pointer
,	O
0	int
)	O
!=	O
FNM_NOMATCH	int
)	O
{	O
strob_close	function
(	O
tmp1	pointer
)	O
;	O
strob_close	function
(	O
tmp2	pointer
)	O
;	O
return	O
0	int
;	O
}	O
t2	pointer
=	O
strob_strtok	function
(	O
tmp2	pointer
,	O
NULL	O
,	O
"|\n\r"	pointer
)	O
;	O
}	O
t1	pointer
=	O
strob_strtok	function
(	O
tmp1	pointer
,	O
NULL	O
,	O
"|\n\r"	pointer
)	O
;	O
}	O
strob_close	function
(	O
tmp1	pointer
)	O
;	O
strob_close	function
(	O
tmp2	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
swlib_unexpand_escapes	function
(	O
STROB	struct
*	O
store	pointer
,	O
char	O
*	O
src	pointer
)	O
{	O
int	O
n	long
;	O
int	O
k	int
;	O
char	O
*	O
lp	pointer
;	O
int	O
retval	int
=	O
0	int
;	O
int	O
len	int
;	O
int	O
escaped_value	int
;	O
int	O
is_recognized	int
;	O
char	O
*	O
dst	pointer
;	O
if	O
(	O
store	pointer
==	O
(	O
STROB	struct
*	O
)	O
NULL	O
)	O
{	O
dst	pointer
=	O
src	pointer
;	O
}	O
else	O
{	O
strob_set_length	function
(	O
store	pointer
,	O
strlen	function
(	O
src	pointer
)	O
)	O
;	O
strob_strcpy	function
(	O
store	pointer
,	O
""	pointer
)	O
;	O
dst	pointer
=	O
strob_str	function
(	O
store	pointer
)	O
;	O
}	O
k	int
=	O
0	int
;	O
lp	pointer
=	O
src	pointer
;	O
len	int
=	O
0	int
;	O
n	long
=	O
strlen	function
(	O
src	pointer
)	O
;	O
while	O
(	O
k	int
<	O
n	long
)	O
{	O
if	O
(	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
==	O
'\\'	O
&&	O
*	O
(	O
lp	pointer
+	O
k	int
+	O
1	int
)	O
!=	O
'\0'	O
)	O
{	O
escaped_value	int
=	O
swlib_ansi_escaped_value	function
(	O
(	O
int	O
)	O
(	O
*	O
(	O
lp	pointer
+	O
k	int
+	O
1	int
)	O
)	O
,	O
&	O
is_recognized	int
)	O
;	O
if	O
(	O
!	O
is_recognized	int
)	O
{	O
escaped_value	int
=	O
swlib_c701_escaped_value	function
(	O
(	O
int	O
)	O
(	O
*	O
(	O
lp	pointer
+	O
k	int
+	O
1	int
)	O
)	O
,	O
&	O
is_recognized	int
)	O
;	O
}	O
if	O
(	O
escaped_value	int
<	O
0	int
)	O
{	O
dst	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
SWLIB_ASSERT	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
is_recognized	int
==	O
0	int
)	O
{	O
dst	pointer
[	O
len	int
]	O
=	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
;	O
len	int
++	O
;	O
k	int
++	O
;	O
}	O
else	O
{	O
dst	pointer
[	O
len	int
]	O
=	O
escaped_value	int
;	O
len	int
++	O
;	O
k	int
+=	O
2	int
;	O
}	O
}	O
else	O
{	O
dst	pointer
[	O
len	int
]	O
=	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
;	O
len	int
++	O
;	O
k	int
++	O
;	O
}	O
}	O
dst	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
return	O
retval	int
;	O
}	O
int	O
swlib_unexpand_escapes2	function
(	O
char	O
*	O
src	pointer
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
dst	pointer
;	O
dst	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
ret	int
=	O
swlib_unexpand_escapes	function
(	O
dst	pointer
,	O
src	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
return	O
ret	int
;	O
if	O
(	O
strob_strlen	function
(	O
dst	pointer
)	O
>	O
strlen	function
(	O
src	pointer
)	O
)	O
return	O
-	O
1	int
;	O
strcpy	function
(	O
src	pointer
,	O
strob_str	function
(	O
dst	pointer
)	O
)	O
;	O
strob_close	function
(	O
dst	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swlib_tee_to_file	function
(	O
char	O
*	O
filename	pointer
,	O
int	O
ifd	int
,	O
char	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
int	O
do_append	int
)	O
{	O
int	O
ret	int
;	O
int	O
fd	int
;	O
int	O
res	int
;	O
int	O
flags	int
;	O
flags	int
=	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
;	O
if	O
(	O
do_append	int
)	O
flags	int
=	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_APPEND	int
;	O
if	O
(	O
isdigit	function
(	O
(	O
int	O
)	O
(	O
*	O
filename	pointer
)	O
)	O
)	O
{	O
fd	int
=	O
swlib_atoi	function
(	O
filename	pointer
,	O
&	O
res	int
)	O
;	O
if	O
(	O
res	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
fd	int
=	O
open	function
(	O
filename	pointer
,	O
flags	int
,	O
0644	int
)	O
;	O
}	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
fd	int
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
{	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
ret	int
=	O
uxfio_unix_safe_write	function
(	O
fd	int
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strlen	function
(	O
buf	pointer
)	O
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
ret	int
=	O
uxfio_unix_safe_write	function
(	O
fd	int
,	O
buf	pointer
,	O
len	int
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
len	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
ret	int
=	O
swlib_pipe_pump	function
(	O
fd	int
,	O
ifd	int
)	O
;	O
}	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swlib_expand_escapes	function
(	O
char	O
*	O
*	O
pa	pointer
,	O
int	O
*	O
newlen	pointer
,	O
char	O
*	O
src	pointer
,	O
STROB	struct
*	O
ustore	pointer
)	O
{	O
int	O
n	long
=	O
strlen	function
(	O
src	pointer
)	O
;	O
int	O
count	long
=	O
0	int
;	O
int	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
,	O
k	int
=	O
0	int
;	O
char	O
*	O
lp	pointer
=	O
src	pointer
;	O
STROB	struct
*	O
store	pointer
;	O
if	O
(	O
ustore	pointer
)	O
{	O
store	pointer
=	O
ustore	pointer
;	O
strob_strcpy	function
(	O
store	pointer
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
store	pointer
=	O
strob_open	function
(	O
20	int
)	O
;	O
}	O
if	O
(	O
!	O
store	pointer
)	O
return	O
-	O
1	int
;	O
while	O
(	O
k	int
<	O
n	long
)	O
{	O
if	O
(	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
==	O
'\\'	O
)	O
{	O
count	long
++	O
;	O
if	O
(	O
count	long
%	O
2	int
&&	O
(	O
*	O
(	O
lp	pointer
+	O
k	int
+	O
1	int
)	O
==	O
'n'	O
)	O
)	O
{	O
count	long
=	O
0	int
;	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
'\n'	O
)	O
;	O
k	int
++	O
;	O
}	O
else	O
{	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
)	O
;	O
if	O
(	O
count	long
%	O
2	int
)	O
{	O
if	O
(	O
!	O
swlib_is_ansi_escape	function
(	O
*	O
(	O
lp	pointer
+	O
k	int
+	O
1	int
)	O
)	O
&&	O
!	O
swlib_is_c701_escape	function
(	O
*	O
(	O
lp	pointer
+	O
k	int
+	O
1	int
)	O
)	O
)	O
{	O
j	int
++	O
;	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
)	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
<	O
(	O
int	O
)	O
7	int
&&	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
>	O
0	int
)	O
||	O
*	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
lp	pointer
+	O
k	int
)	O
)	O
>=	O
127	int
)	O
{	O
strob_sprintf	function
(	O
store	pointer
,	O
1	int
,	O
"\\x%02X"	pointer
,	O
*	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
lp	pointer
+	O
k	int
)	O
)	O
)	O
;	O
j	int
+=	O
3	int
;	O
}	O
else	O
{	O
count	long
=	O
0	int
;	O
if	O
(	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
==	O
'#'	O
)	O
{	O
if	O
(	O
strob_get_char	function
(	O
store	pointer
,	O
i	int
+	O
j	int
-	O
1	int
)	O
!=	O
'\\'	O
)	O
{	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
'\\'	O
)	O
;	O
j	int
++	O
;	O
}	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
'#'	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
==	O
'\"'	O
)	O
{	O
if	O
(	O
strob_get_char	function
(	O
store	pointer
,	O
i	int
+	O
j	int
-	O
1	int
)	O
!=	O
'\\'	O
)	O
{	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
'\\'	O
)	O
;	O
j	int
++	O
;	O
}	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
'\"'	O
)	O
;	O
}	O
else	O
{	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
*	O
(	O
lp	pointer
+	O
k	int
)	O
)	O
;	O
}	O
}	O
i	int
++	O
;	O
k	int
++	O
;	O
}	O
strob_chr_index	function
(	O
store	pointer
,	O
i	int
+	O
j	int
,	O
'\0'	O
)	O
;	O
if	O
(	O
!	O
ustore	pointer
)	O
{	O
if	O
(	O
pa	pointer
)	O
*	O
pa	pointer
=	O
strob_release	function
(	O
store	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pa	pointer
)	O
*	O
pa	pointer
=	O
strob_str	function
(	O
store	pointer
)	O
;	O
}	O
if	O
(	O
newlen	pointer
)	O
*	O
newlen	pointer
=	O
i	int
+	O
j	int
;	O
return	O
0	int
;	O
}	O
char	O
*	O
swlib_imaxtostr	function
(	O
intmax_t	long
i	int
,	O
STROB	struct
*	O
pbuf	pointer
)	O
{	O
static	O
STROB	struct
*	O
sbuf	pointer
;	O
STROB	struct
*	O
buf	pointer
;	O
char	O
*	O
ret	int
;	O
if	O
(	O
pbuf	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
sbuf	pointer
==	O
NULL	O
)	O
sbuf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
buf	pointer
=	O
sbuf	pointer
;	O
}	O
else	O
{	O
buf	pointer
=	O
pbuf	pointer
;	O
}	O
strob_setlen	function
(	O
buf	pointer
,	O
UINTMAX_STRSIZE_BOUND	O
+	O
1	int
)	O
;	O
ret	int
=	O
imaxtostr	function
(	O
i	int
,	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
char	O
*	O
swlib_umaxtostr	function
(	O
uintmax_t	long
i	int
,	O
STROB	struct
*	O
pbuf	pointer
)	O
{	O
static	O
STROB	struct
*	O
buf	pointer
;	O
char	O
*	O
ret	int
;	O
if	O
(	O
pbuf	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
buf	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
}	O
else	O
{	O
buf	pointer
=	O
pbuf	pointer
;	O
}	O
strob_setlen	function
(	O
buf	pointer
,	O
UINTMAX_STRSIZE_BOUND	O
+	O
1	int
)	O
;	O
ret	int
=	O
umaxtostr	function
(	O
i	int
,	O
strob_str	function
(	O
buf	pointer
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
mode_t	int
swlib_get_umask	function
(	O
void	O
)	O
{	O
mode_t	int
mode	array
=	O
0777	int
;	O
mode	array
=	O
umask	function
(	O
mode	array
)	O
;	O
umask	function
(	O
mode	array
)	O
;	O
return	O
mode	array
;	O
}	O
int	O
swlib_ascii_text_fd_to_buf	function
(	O
STROB	struct
*	O
pbuf	pointer
,	O
int	O
ifd	int
)	O
{	O
intmax_t	long
amount	long
;	O
int	O
ret	int
;	O
amount	long
=	O
-	O
1	int
;	O
ret	int
=	O
swlib_i_pipe_pump	function
(	O
ifd	int
,	O
-	O
1	int
,	O
(	O
intmax_t	long
*	O
)	O
&	O
amount	long
,	O
-	O
1	int
,	O
pbuf	pointer
,	O
uxfio_read	function
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
||	O
(	O
int	O
)	O
amount	long
!=	O
(	O
int	O
)	O
strob_strlen	function
(	O
pbuf	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swlib_ascii_text_fd_to_buf: warning, size not equal to strlen\n"	pointer
)	O
;	O
ret	int
=	O
-	O
1	int
;	O
}	O
return	O
ret	int
;	O
}	O
void	O
swlib_apply_location	function
(	O
STROB	struct
*	O
relocated_path	pointer
,	O
char	O
*	O
path	pointer
,	O
char	O
*	O
location	pointer
,	O
char	O
*	O
directory	pointer
)	O
{	O
char	O
*	O
prefix	array
;	O
char	O
*	O
clean_directory	pointer
;	O
char	O
*	O
clean_location	pointer
;	O
char	O
*	O
clean_path	pointer
;	O
strob_strcpy	function
(	O
relocated_path	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
path	pointer
)	O
==	O
0	int
)	O
return	O
;	O
clean_path	pointer
=	O
swlib_return_no_leading	function
(	O
path	pointer
)	O
;	O
clean_location	pointer
=	O
swlib_return_no_leading	function
(	O
location	pointer
)	O
;	O
clean_directory	pointer
=	O
swlib_return_no_leading	function
(	O
directory	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
clean_directory	pointer
)	O
>	O
0	int
&&	O
strlen	function
(	O
clean_path	pointer
)	O
>	O
0	int
)	O
{	O
prefix	array
=	O
strstr	function
(	O
clean_path	pointer
,	O
clean_directory	pointer
)	O
;	O
if	O
(	O
prefix	array
!=	O
NULL	O
&&	O
prefix	array
==	O
clean_path	pointer
)	O
{	O
clean_path	pointer
+=	O
strlen	function
(	O
clean_directory	pointer
)	O
;	O
}	O
}	O
else	O
{	O
;	O
}	O
strob_strcpy	function
(	O
relocated_path	pointer
,	O
location	pointer
)	O
;	O
swlib_unix_dircat	function
(	O
relocated_path	pointer
,	O
clean_path	pointer
)	O
;	O
return	O
;	O
}	O
char	O
*	O
swlib_attribute_check_default	function
(	O
char	O
*	O
object	pointer
,	O
char	O
*	O
keyword	pointer
,	O
char	O
*	O
value	long
)	O
{	O
char	O
*	O
d	pointer
;	O
if	O
(	O
value	long
)	O
return	O
value	long
;	O
d	pointer
=	O
swsdflt_get_default_value	function
(	O
object	pointer
,	O
keyword	pointer
)	O
;	O
if	O
(	O
d	pointer
==	O
NULL	O
)	O
{	O
SWLIB_ERROR3	O
(	O
"no default value found for attribute: %s %s"	pointer
,	O
object	pointer
,	O
keyword	pointer
)	O
;	O
return	O
""	pointer
;	O
}	O
return	O
d	pointer
;	O
}	O
int	O
swlib_is_option_true	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
s	pointer
)	O
return	O
0	int
;	O
return	O
swextopt_is_value_true	function
(	O
s	pointer
)	O
;	O
}	O
void	O
swlib_squash_illegal_tag_chars	function
(	O
char	O
*	O
s	pointer
)	O
{	O
while	O
(	O
*	O
s	pointer
!=	O
(	O
int	O
)	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'.'	O
)	O
*	O
s	pointer
=	O
'_'	O
;	O
if	O
(	O
*	O
s	pointer
==	O
','	O
)	O
*	O
s	pointer
=	O
'_'	O
;	O
if	O
(	O
*	O
s	pointer
==	O
':'	O
)	O
*	O
s	pointer
=	O
'_'	O
;	O
s	pointer
++	O
;	O
}	O
}	O
void	O
swlib_append_synct_eof	function
(	O
STROB	struct
*	O
buf	pointer
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_sprintf	function
(	O
buf	pointer
,	O
1	int
,	O
") | dd ibs=%d obs=%d 2>/dev/null | dd ibs=%d obs=%d conv=sync 2>/dev/null |\n"	pointer
"	(\n"	pointer
"		dd bs=%d 2>/dev/null\n"	pointer
"		( printf \""	pointer
CPIO_INBAND_EOA_FILENAME	pointer
"\\r\\n\\r\\n\"\n"	pointer
"		) | dd ibs=%d obs=%d conv=sync 2>/dev/null\n"	pointer
"	)\n"	pointer
") | dd ibs=%d obs=%d conv=sync 2>/dev/null\n"	pointer
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
3	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
3	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
,	O
SWLIB_SYNCT_BLOCKSIZE	int
*	O
2	int
)	O
;	O
return	O
;	O
}	O
