enum	O
insert_order	enum
{	O
INS_RANDOM	int
,	O
INS_ASCENDING	int
,	O
INS_DESCENDING	int
,	O
INS_BALANCED	int
,	O
INS_ZIGZAG	int
,	O
INS_ASCENDING_SHIFTED	int
,	O
INS_CUSTOM	int
,	O
INS_CNT	int
}	O
;	O
enum	O
delete_order	enum
{	O
DEL_RANDOM	int
,	O
DEL_REVERSE	int
,	O
DEL_SAME	int
,	O
DEL_CUSTOM	int
,	O
DEL_CNT	int
}	O
;	O
enum	O
mt_policy	enum
{	O
MT_TRACK	int
,	O
MT_NO_TRACK	int
,	O
MT_FAIL_COUNT	int
,	O
MT_FAIL_PERCENT	int
,	O
MT_SUBALLOC	int
}	O
;	O
struct	O
option	struct
{	O
const	O
char	O
*	O
long_name	pointer
;	O
int	O
short_name	int
;	O
int	O
has_arg	int
;	O
}	O
;	O
enum	O
test	enum
{	O
TST_CORRECTNESS	int
,	O
TST_OVERFLOW	int
,	O
TST_NULL	int
}	O
;	O
struct	O
test_options	struct
{	O
enum	O
test	enum
test	enum
;	O
enum	O
insert_order	enum
insert_order	enum
;	O
enum	O
delete_order	enum
delete_order	enum
;	O
enum	O
mt_policy	enum
alloc_policy	enum
;	O
int	O
alloc_arg	array
[	O
2	int
]	O
;	O
int	O
alloc_incr	int
;	O
int	O
node_cnt	int
;	O
int	O
iter_cnt	int
;	O
int	O
seed_given	int
;	O
unsigned	O
seed	int
;	O
int	O
verbosity	int
;	O
int	O
nonstop	int
;	O
}	O
;	O
char	O
*	O
pgm_name	pointer
;	O
int	O
compare_ints	function
(	O
const	O
void	O
*	O
pa	pointer
,	O
const	O
void	O
*	O
pb	pointer
,	O
void	O
*	O
param	pointer
)	O
{	O
const	O
int	O
*	O
a	pointer
=	O
pa	pointer
;	O
const	O
int	O
*	O
b	pointer
=	O
pb	pointer
;	O
if	O
(	O
*	O
a	pointer
<	O
*	O
b	pointer
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
*	O
a	pointer
>	O
*	O
b	pointer
)	O
return	O
+	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
void	O
fail	function
(	O
const	O
char	O
*	O
message	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
pgm_name	pointer
)	O
;	O
va_start	O
(	O
args	array
,	O
message	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
message	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
block	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
block	pointer
==	O
NULL	O
&&	O
size	long
!=	O
0	int
)	O
fail	function
(	O
"out of memory"	pointer
)	O
;	O
return	O
block	pointer
;	O
}	O
struct	O
block	pointer
{	O
struct	O
block	pointer
*	O
next	pointer
;	O
int	O
idx	int
;	O
size_t	long
size	long
;	O
size_t	long
used	long
;	O
void	O
*	O
content	pointer
;	O
}	O
;	O
enum	O
mt_arg_index	enum
{	O
MT_COUNT	int
=	O
0	int
,	O
MT_PERCENT	int
=	O
0	int
,	O
MT_BLOCK_SIZE	int
=	O
0	int
,	O
MT_ALIGN	int
=	O
1	int
}	O
;	O
struct	O
mt_allocator	struct
{	O
struct	O
libavl_allocator	struct
allocator	pointer
;	O
enum	O
mt_policy	enum
policy	enum
;	O
int	O
arg	array
[	O
2	int
]	O
;	O
int	O
verbosity	int
;	O
struct	O
block	pointer
*	O
head	pointer
,	O
*	O
tail	pointer
;	O
int	O
alloc_idx	int
;	O
int	O
block_cnt	int
;	O
}	O
;	O
static	O
void	O
*	O
mt_allocate	function
(	O
struct	O
libavl_allocator	struct
*	O
,	O
size_t	long
)	O
;	O
static	O
void	O
mt_free	function
(	O
struct	O
libavl_allocator	struct
*	O
,	O
void	O
*	O
)	O
;	O
struct	O
mt_allocator	struct
*	O
mt_create	function
(	O
enum	O
mt_policy	enum
policy	enum
,	O
int	O
arg	array
[	O
2	int
]	O
,	O
int	O
verbosity	int
)	O
{	O
struct	O
mt_allocator	struct
*	O
mt	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
mt	pointer
)	O
;	O
mt	pointer
->	O
allocator	pointer
.	O
libavl_malloc	pointer
=	O
mt_allocate	function
;	O
mt	pointer
->	O
allocator	pointer
.	O
libavl_free	pointer
=	O
mt_free	function
;	O
mt	pointer
->	O
policy	enum
=	O
policy	enum
;	O
mt	pointer
->	O
arg	array
[	O
0	int
]	O
=	O
arg	array
[	O
0	int
]	O
;	O
mt	pointer
->	O
arg	array
[	O
1	int
]	O
=	O
arg	array
[	O
1	int
]	O
;	O
mt	pointer
->	O
verbosity	int
=	O
verbosity	int
;	O
mt	pointer
->	O
head	pointer
=	O
mt	pointer
->	O
tail	pointer
=	O
NULL	O
;	O
mt	pointer
->	O
alloc_idx	int
=	O
0	int
;	O
mt	pointer
->	O
block_cnt	int
=	O
0	int
;	O
return	O
mt	pointer
;	O
}	O
void	O
mt_destroy	function
(	O
struct	O
mt_allocator	struct
*	O
mt	pointer
)	O
{	O
assert	O
(	O
mt	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
mt	pointer
->	O
block_cnt	int
==	O
0	int
)	O
{	O
if	O
(	O
mt	pointer
->	O
policy	enum
!=	O
MT_NO_TRACK	int
&&	O
mt	pointer
->	O
verbosity	int
>=	O
1	int
)	O
printf	function
(	O
"  No memory leaks.\n"	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
block	pointer
*	O
iter	pointer
,	O
*	O
next	pointer
;	O
if	O
(	O
mt	pointer
->	O
policy	enum
!=	O
MT_SUBALLOC	int
)	O
printf	function
(	O
"  Memory leaks detected:\n"	pointer
)	O
;	O
for	O
(	O
iter	pointer
=	O
mt	pointer
->	O
head	pointer
;	O
iter	pointer
!=	O
NULL	O
;	O
iter	pointer
=	O
next	pointer
)	O
{	O
if	O
(	O
mt	pointer
->	O
policy	enum
!=	O
MT_SUBALLOC	int
)	O
printf	function
(	O
"    block #%d: %lu bytes\n"	pointer
,	O
iter	pointer
->	O
idx	int
,	O
(	O
unsigned	O
long	O
)	O
iter	pointer
->	O
size	long
)	O
;	O
next	pointer
=	O
iter	pointer
->	O
next	pointer
;	O
free	function
(	O
iter	pointer
->	O
content	pointer
)	O
;	O
free	function
(	O
iter	pointer
)	O
;	O
}	O
}	O
free	function
(	O
mt	pointer
)	O
;	O
}	O
void	O
*	O
mt_allocator	struct
(	O
struct	O
mt_allocator	struct
*	O
mt	pointer
)	O
{	O
return	O
&	O
mt	pointer
->	O
allocator	pointer
;	O
}	O
static	O
void	O
*	O
new_block	function
(	O
struct	O
mt_allocator	struct
*	O
mt	pointer
,	O
size_t	long
size	long
)	O
{	O
struct	O
block	pointer
*	O
new	pointer
;	O
new	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
new	pointer
)	O
;	O
new	pointer
->	O
next	pointer
=	O
NULL	O
;	O
new	pointer
->	O
idx	int
=	O
mt	pointer
->	O
alloc_idx	int
++	O
;	O
new	pointer
->	O
size	long
=	O
size	long
;	O
new	pointer
->	O
used	long
=	O
0	int
;	O
new	pointer
->	O
content	pointer
=	O
xmalloc	function
(	O
size	long
)	O
;	O
if	O
(	O
mt	pointer
->	O
head	pointer
==	O
NULL	O
)	O
mt	pointer
->	O
head	pointer
=	O
new	pointer
;	O
else	O
mt	pointer
->	O
tail	pointer
->	O
next	pointer
=	O
new	pointer
;	O
mt	pointer
->	O
tail	pointer
=	O
new	pointer
;	O
if	O
(	O
mt	pointer
->	O
verbosity	int
>=	O
3	int
)	O
printf	function
(	O
"    block #%d: allocated %lu bytes\n"	pointer
,	O
new	pointer
->	O
idx	int
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
mt	pointer
->	O
block_cnt	int
++	O
;	O
return	O
new	pointer
->	O
content	pointer
;	O
}	O
static	O
void	O
reject_request	function
(	O
struct	O
mt_allocator	struct
*	O
mt	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
mt	pointer
->	O
verbosity	int
>=	O
2	int
)	O
printf	function
(	O
"    block #%d: rejected request for %lu bytes\n"	pointer
,	O
mt	pointer
->	O
alloc_idx	int
++	O
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
}	O
static	O
void	O
*	O
mt_allocate	function
(	O
struct	O
libavl_allocator	struct
*	O
allocator	pointer
,	O
size_t	long
size	long
)	O
{	O
struct	O
mt_allocator	struct
*	O
mt	pointer
=	O
(	O
struct	O
mt_allocator	struct
*	O
)	O
allocator	pointer
;	O
if	O
(	O
size	long
==	O
0	int
)	O
return	O
NULL	O
;	O
switch	O
(	O
mt	pointer
->	O
policy	enum
)	O
{	O
case	O
MT_TRACK	int
:	O
return	O
new_block	function
(	O
mt	pointer
,	O
size	long
)	O
;	O
case	O
MT_NO_TRACK	int
:	O
return	O
xmalloc	function
(	O
size	long
)	O
;	O
case	O
MT_FAIL_COUNT	int
:	O
if	O
(	O
mt	pointer
->	O
arg	array
[	O
MT_COUNT	int
]	O
==	O
0	int
)	O
{	O
reject_request	function
(	O
mt	pointer
,	O
size	long
)	O
;	O
return	O
NULL	O
;	O
}	O
mt	pointer
->	O
arg	array
[	O
MT_COUNT	int
]	O
--	O
;	O
return	O
new_block	function
(	O
mt	pointer
,	O
size	long
)	O
;	O
case	O
MT_FAIL_PERCENT	int
:	O
if	O
(	O
rand	function
(	O
)	O
/	O
(	O
RAND_MAX	int
/	O
100	int
+	O
1	int
)	O
<	O
mt	pointer
->	O
arg	array
[	O
MT_PERCENT	int
]	O
)	O
{	O
reject_request	function
(	O
mt	pointer
,	O
size	long
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
return	O
new_block	function
(	O
mt	pointer
,	O
size	long
)	O
;	O
case	O
MT_SUBALLOC	int
:	O
if	O
(	O
mt	pointer
->	O
tail	pointer
==	O
NULL	O
||	O
mt	pointer
->	O
tail	pointer
->	O
used	long
+	O
size	long
>	O
(	O
size_t	long
)	O
mt	pointer
->	O
arg	array
[	O
MT_BLOCK_SIZE	int
]	O
)	O
new_block	function
(	O
mt	pointer
,	O
mt	pointer
->	O
arg	array
[	O
MT_BLOCK_SIZE	int
]	O
)	O
;	O
if	O
(	O
mt	pointer
->	O
tail	pointer
->	O
used	long
+	O
size	long
<=	O
(	O
size_t	long
)	O
mt	pointer
->	O
arg	array
[	O
MT_BLOCK_SIZE	int
]	O
)	O
{	O
void	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
mt	pointer
->	O
tail	pointer
->	O
content	pointer
+	O
mt	pointer
->	O
tail	pointer
->	O
used	long
;	O
size	long
=	O
(	O
(	O
size	long
+	O
mt	pointer
->	O
arg	array
[	O
MT_ALIGN	int
]	O
-	O
1	int
)	O
/	O
mt	pointer
->	O
arg	array
[	O
MT_ALIGN	int
]	O
*	O
mt	pointer
->	O
arg	array
[	O
MT_ALIGN	int
]	O
)	O
;	O
mt	pointer
->	O
tail	pointer
->	O
used	long
+=	O
size	long
;	O
if	O
(	O
mt	pointer
->	O
verbosity	int
>=	O
3	int
)	O
printf	function
(	O
"    block #%d: suballocated %lu bytes\n"	pointer
,	O
mt	pointer
->	O
tail	pointer
->	O
idx	int
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
return	O
p	pointer
;	O
}	O
else	O
fail	function
(	O
"blocksize %lu too small for %lu-byte allocation"	pointer
,	O
(	O
unsigned	O
long	O
)	O
mt	pointer
->	O
tail	pointer
->	O
size	long
,	O
(	O
unsigned	O
long	O
)	O
size	long
)	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
mt_free	function
(	O
struct	O
libavl_allocator	struct
*	O
allocator	pointer
,	O
void	O
*	O
block	pointer
)	O
{	O
struct	O
mt_allocator	struct
*	O
mt	pointer
=	O
(	O
struct	O
mt_allocator	struct
*	O
)	O
allocator	pointer
;	O
struct	O
block	pointer
*	O
iter	pointer
,	O
*	O
prev	pointer
;	O
if	O
(	O
block	pointer
==	O
NULL	O
||	O
mt	pointer
->	O
policy	enum
==	O
MT_NO_TRACK	int
)	O
{	O
free	function
(	O
block	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
mt	pointer
->	O
policy	enum
==	O
MT_SUBALLOC	int
)	O
return	O
;	O
for	O
(	O
prev	pointer
=	O
NULL	O
,	O
iter	pointer
=	O
mt	pointer
->	O
head	pointer
;	O
iter	pointer
;	O
prev	pointer
=	O
iter	pointer
,	O
iter	pointer
=	O
iter	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
iter	pointer
->	O
content	pointer
==	O
block	pointer
)	O
{	O
struct	O
block	pointer
*	O
next	pointer
=	O
iter	pointer
->	O
next	pointer
;	O
if	O
(	O
prev	pointer
==	O
NULL	O
)	O
mt	pointer
->	O
head	pointer
=	O
next	pointer
;	O
else	O
prev	pointer
->	O
next	pointer
=	O
next	pointer
;	O
if	O
(	O
next	pointer
==	O
NULL	O
)	O
mt	pointer
->	O
tail	pointer
=	O
prev	pointer
;	O
if	O
(	O
mt	pointer
->	O
verbosity	int
>=	O
4	int
)	O
printf	function
(	O
"    block #%d: freed %lu bytes\n"	pointer
,	O
iter	pointer
->	O
idx	int
,	O
(	O
unsigned	O
long	O
)	O
iter	pointer
->	O
size	long
)	O
;	O
free	function
(	O
iter	pointer
->	O
content	pointer
)	O
;	O
free	function
(	O
iter	pointer
)	O
;	O
mt	pointer
->	O
block_cnt	int
--	O
;	O
return	O
;	O
}	O
}	O
printf	function
(	O
"    attempt to free unknown block %p (already freed?)\n"	pointer
,	O
block	pointer
)	O
;	O
}	O
struct	O
option_state	struct
{	O
const	O
struct	O
option	struct
*	O
options	pointer
;	O
char	O
*	O
*	O
arg_next	pointer
;	O
char	O
*	O
short_next	pointer
;	O
}	O
;	O
static	O
struct	O
option_state	struct
*	O
option_init	function
(	O
const	O
struct	O
option	struct
*	O
options	pointer
,	O
char	O
*	O
*	O
args	array
)	O
{	O
struct	O
option_state	struct
*	O
state	pointer
;	O
assert	O
(	O
options	pointer
!=	O
NULL	O
&&	O
args	array
!=	O
NULL	O
)	O
;	O
state	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
state	pointer
)	O
;	O
state	pointer
->	O
options	pointer
=	O
options	pointer
;	O
state	pointer
->	O
arg_next	pointer
=	O
args	array
;	O
state	pointer
->	O
short_next	pointer
=	O
NULL	O
;	O
return	O
state	pointer
;	O
}	O
static	O
int	O
handle_short_option	function
(	O
struct	O
option_state	struct
*	O
state	pointer
,	O
char	O
*	O
*	O
argp	pointer
)	O
{	O
const	O
struct	O
option	struct
*	O
o	pointer
;	O
assert	O
(	O
state	pointer
!=	O
NULL	O
&&	O
state	pointer
->	O
short_next	pointer
!=	O
NULL	O
&&	O
*	O
state	pointer
->	O
short_next	pointer
!=	O
'\0'	O
&&	O
state	pointer
->	O
options	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
o	pointer
=	O
state	pointer
->	O
options	pointer
;	O
;	O
o	pointer
++	O
)	O
if	O
(	O
o	pointer
->	O
long_name	pointer
==	O
NULL	O
)	O
fail	function
(	O
"unknown option `-%c'; use --help for help"	pointer
,	O
*	O
state	pointer
->	O
short_next	pointer
)	O
;	O
else	O
if	O
(	O
o	pointer
->	O
short_name	int
==	O
*	O
state	pointer
->	O
short_next	pointer
)	O
break	O
;	O
state	pointer
->	O
short_next	pointer
++	O
;	O
if	O
(	O
o	pointer
->	O
has_arg	int
)	O
{	O
if	O
(	O
*	O
state	pointer
->	O
arg_next	pointer
==	O
NULL	O
||	O
*	O
*	O
state	pointer
->	O
arg_next	pointer
==	O
'-'	O
)	O
fail	function
(	O
"`-%c' requires an argument; use --help for help"	pointer
)	O
;	O
*	O
argp	pointer
=	O
*	O
state	pointer
->	O
arg_next	pointer
++	O
;	O
}	O
return	O
o	pointer
->	O
short_name	int
;	O
}	O
static	O
int	O
handle_long_option	function
(	O
struct	O
option_state	struct
*	O
state	pointer
,	O
char	O
*	O
*	O
argp	pointer
)	O
{	O
const	O
struct	O
option	struct
*	O
o	pointer
;	O
char	O
name	array
[	O
16	int
]	O
;	O
const	O
char	O
*	O
arg	array
;	O
assert	O
(	O
state	pointer
!=	O
NULL	O
&&	O
state	pointer
->	O
arg_next	pointer
!=	O
NULL	O
&&	O
*	O
state	pointer
->	O
arg_next	pointer
!=	O
NULL	O
&&	O
state	pointer
->	O
options	pointer
!=	O
NULL	O
&&	O
argp	pointer
!=	O
NULL	O
)	O
;	O
{	O
const	O
char	O
*	O
p	pointer
=	O
*	O
state	pointer
->	O
arg_next	pointer
+	O
2	int
;	O
const	O
char	O
*	O
q	pointer
=	O
p	pointer
+	O
strcspn	function
(	O
p	pointer
,	O
"="	pointer
)	O
;	O
size_t	long
name_len	long
=	O
q	pointer
-	O
p	pointer
;	O
if	O
(	O
name_len	long
>	O
(	O
sizeof	O
name	array
)	O
-	O
1	int
)	O
name_len	long
=	O
(	O
sizeof	O
name	array
)	O
-	O
1	int
;	O
memcpy	function
(	O
name	array
,	O
p	pointer
,	O
name_len	long
)	O
;	O
name	array
[	O
name_len	long
]	O
=	O
'\0'	O
;	O
arg	array
=	O
(	O
*	O
q	pointer
==	O
'='	O
)	O
?	O
q	pointer
+	O
1	int
:	O
NULL	O
;	O
}	O
for	O
(	O
o	pointer
=	O
state	pointer
->	O
options	pointer
;	O
;	O
o	pointer
++	O
)	O
if	O
(	O
o	pointer
->	O
long_name	pointer
==	O
NULL	O
)	O
fail	function
(	O
"unknown option --%s; use --help for help"	pointer
,	O
name	array
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
name	array
,	O
o	pointer
->	O
long_name	pointer
)	O
)	O
break	O
;	O
if	O
(	O
(	O
arg	array
!=	O
NULL	O
)	O
!=	O
(	O
o	pointer
->	O
has_arg	int
!=	O
0	int
)	O
)	O
{	O
if	O
(	O
arg	array
!=	O
NULL	O
)	O
fail	function
(	O
"--%s can't take an argument; use --help for help"	pointer
,	O
name	array
)	O
;	O
else	O
fail	function
(	O
"--%s requires an argument; use --help for help"	pointer
,	O
name	array
)	O
;	O
}	O
state	pointer
->	O
arg_next	pointer
++	O
;	O
*	O
argp	pointer
=	O
(	O
char	O
*	O
)	O
arg	array
;	O
return	O
o	pointer
->	O
short_name	int
;	O
}	O
static	O
int	O
option_get	function
(	O
struct	O
option_state	struct
*	O
state	pointer
,	O
char	O
*	O
*	O
argp	pointer
)	O
{	O
assert	O
(	O
state	pointer
!=	O
NULL	O
&&	O
argp	pointer
!=	O
NULL	O
)	O
;	O
*	O
argp	pointer
=	O
NULL	O
;	O
if	O
(	O
state	pointer
->	O
short_next	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
state	pointer
->	O
short_next	pointer
!=	O
'\0'	O
)	O
return	O
handle_short_option	function
(	O
state	pointer
,	O
argp	pointer
)	O
;	O
else	O
state	pointer
->	O
short_next	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
*	O
state	pointer
->	O
arg_next	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
state	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
*	O
state	pointer
->	O
arg_next	pointer
)	O
[	O
0	int
]	O
!=	O
'-'	O
)	O
fail	function
(	O
"non-option arguments encountered; use --help for help"	pointer
)	O
;	O
if	O
(	O
(	O
*	O
state	pointer
->	O
arg_next	pointer
)	O
[	O
1	int
]	O
==	O
'\0'	O
)	O
fail	function
(	O
"unknown option `-'; use --help for help"	pointer
)	O
;	O
if	O
(	O
(	O
*	O
state	pointer
->	O
arg_next	pointer
)	O
[	O
1	int
]	O
==	O
'-'	O
)	O
return	O
handle_long_option	function
(	O
state	pointer
,	O
argp	pointer
)	O
;	O
else	O
{	O
state	pointer
->	O
short_next	pointer
=	O
*	O
state	pointer
->	O
arg_next	pointer
+	O
1	int
;	O
state	pointer
->	O
arg_next	pointer
++	O
;	O
return	O
handle_short_option	function
(	O
state	pointer
,	O
argp	pointer
)	O
;	O
}	O
}	O
size_t	long
match_len	function
(	O
const	O
char	O
*	O
a	pointer
,	O
const	O
char	O
*	O
b	pointer
)	O
{	O
size_t	long
cnt	long
;	O
for	O
(	O
cnt	long
=	O
0	int
;	O
*	O
a	pointer
==	O
*	O
b	pointer
&&	O
*	O
a	pointer
!=	O
'\0'	O
;	O
a	pointer
++	O
,	O
b	pointer
++	O
)	O
cnt	long
++	O
;	O
return	O
(	O
*	O
a	pointer
!=	O
*	O
b	pointer
&&	O
*	O
a	pointer
!=	O
'\0'	O
&&	O
*	O
b	pointer
!=	O
'\0'	O
)	O
?	O
0	int
:	O
cnt	long
;	O
}	O
static	O
int	O
stoi	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
long	O
x	long
=	O
strtol	function
(	O
s	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
return	O
x	long
>=	O
INT_MIN	O
&&	O
x	long
<=	O
INT_MAX	O
?	O
x	long
:	O
0	int
;	O
}	O
static	O
void	O
usage	function
(	O
void	O
)	O
{	O
static	O
const	O
char	O
*	O
help	array
[	O
]	O
=	O
{	O
"bst-test, unit test for GNU libavl.\n\n"	pointer
,	O
"Usage: %s [OPTION]...\n\n"	pointer
,	O
"In the option descriptions below, CAPITAL denote arguments.\n"	pointer
,	O
"If a long option shows an argument as mandatory, then it is\n"	pointer
,	O
"mandatory for the equivalent short option also.  See the GNU\n"	pointer
,	O
"libavl manual for more information.\n\n"	pointer
,	O
"-t, --test=TEST     Sets test to perform.  TEST is one of:\n"	pointer
,	O
"                      correctness insert/delete/... (default)\n"	pointer
,	O
"                      overflow    stack overflow test\n"	pointer
,	O
"                      benchmark   benchmark test\n"	pointer
,	O
"                      null        no test\n"	pointer
,	O
"-s, --size=TREE-SIZE  Sets tree size in nodes (default 16).\n"	pointer
,	O
"-r, --repeat=COUNT  Repeats operation COUNT times (default 16).\n"	pointer
,	O
"-i, --insert=ORDER  Sets the insertion order.  ORDER is one of:\n"	pointer
,	O
"                      random      random permutation (default)\n"	pointer
,	O
"                      ascending   ascending order 0...n-1\n"	pointer
,	O
"                      descending  descending order n-1...0\n"	pointer
,	O
"                      balanced    balanced tree order\n"	pointer
,	O
"                      zigzag      zig-zag tree\n"	pointer
,	O
"                      asc-shifted n/2...n-1, 0...n/2-1\n"	pointer
,	O
"                      custom      custom, read from stdin\n"	pointer
,	O
"-d, --delete=ORDER  Sets the deletion order.  ORDER is one of:\n"	pointer
,	O
"                      random   random permutation (default)\n"	pointer
,	O
"                      reverse  reverse order of insertion\n"	pointer
,	O
"                      same     same as insertion order\n"	pointer
,	O
"                      custom   custom, read from stdin\n"	pointer
,	O
"-a, --alloc=POLICY  Sets allocation policy.  POLICY is one of:\n"	pointer
,	O
"                      track     track memory leaks (default)\n"	pointer
,	O
"                      no-track  turn off leak detection\n"	pointer
,	O
"                      fail-CNT  fail after CNT allocations\n"	pointer
,	O
"                      fail%%PCT  fail random PCT%% of allocations\n"	pointer
,	O
"                      sub-B,A   divide B-byte blocks in A-byte units\n"	pointer
,	O
"                    (Ignored for `benchmark' test.)\n"	pointer
,	O
"-A, --incr=INC      Fail policies: arg increment per repetition.\n"	pointer
,	O
"-S, --seed=SEED     Sets initial number seed to SEED.\n"	pointer
,	O
"                    (default based on system time)\n"	pointer
,	O
"-n, --nonstop       Don't stop after a single error.\n"	pointer
,	O
"-q, --quiet         Turns down verbosity level.\n"	pointer
,	O
"-v, --verbose       Turns up verbosity level.\n"	pointer
,	O
"-h, --help          Displays this help screen.\n"	pointer
,	O
"-V, --version       Reports version and copyright information.\n"	pointer
,	O
NULL	O
,	O
}	O
;	O
const	O
char	O
*	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
help	array
;	O
*	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
printf	function
(	O
*	O
p	pointer
,	O
pgm_name	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
parse_command_line	function
(	O
char	O
*	O
*	O
args	array
,	O
struct	O
test_options	struct
*	O
options	pointer
)	O
{	O
static	O
const	O
struct	O
option	struct
option_tab	array
[	O
]	O
=	O
{	O
{	O
"test"	pointer
,	O
't'	O
,	O
1	int
}	O
,	O
{	O
"insert"	pointer
,	O
'i'	O
,	O
1	int
}	O
,	O
{	O
"delete"	pointer
,	O
'd'	O
,	O
1	int
}	O
,	O
{	O
"alloc"	pointer
,	O
'a'	O
,	O
1	int
}	O
,	O
{	O
"incr"	pointer
,	O
'A'	O
,	O
1	int
}	O
,	O
{	O
"size"	pointer
,	O
's'	O
,	O
1	int
}	O
,	O
{	O
"repeat"	pointer
,	O
'r'	O
,	O
1	int
}	O
,	O
{	O
"operation"	pointer
,	O
'o'	O
,	O
1	int
}	O
,	O
{	O
"seed"	pointer
,	O
'S'	O
,	O
1	int
}	O
,	O
{	O
"nonstop"	pointer
,	O
'n'	O
,	O
0	int
}	O
,	O
{	O
"quiet"	pointer
,	O
'q'	O
,	O
0	int
}	O
,	O
{	O
"verbose"	pointer
,	O
'v'	O
,	O
0	int
}	O
,	O
{	O
"help"	pointer
,	O
'h'	O
,	O
0	int
}	O
,	O
{	O
"version"	pointer
,	O
'V'	O
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
struct	O
option_state	struct
*	O
state	pointer
;	O
options	pointer
->	O
test	enum
=	O
TST_CORRECTNESS	int
;	O
options	pointer
->	O
insert_order	enum
=	O
INS_RANDOM	int
;	O
options	pointer
->	O
delete_order	enum
=	O
DEL_RANDOM	int
;	O
options	pointer
->	O
alloc_policy	enum
=	O
MT_TRACK	int
;	O
options	pointer
->	O
alloc_arg	array
[	O
0	int
]	O
=	O
0	int
;	O
options	pointer
->	O
alloc_arg	array
[	O
1	int
]	O
=	O
0	int
;	O
options	pointer
->	O
alloc_incr	int
=	O
0	int
;	O
options	pointer
->	O
node_cnt	int
=	O
15	int
;	O
options	pointer
->	O
iter_cnt	int
=	O
15	int
;	O
options	pointer
->	O
seed_given	int
=	O
0	int
;	O
options	pointer
->	O
verbosity	int
=	O
0	int
;	O
options	pointer
->	O
nonstop	int
=	O
0	int
;	O
if	O
(	O
*	O
args	array
==	O
NULL	O
)	O
return	O
;	O
state	pointer
=	O
option_init	function
(	O
option_tab	array
,	O
args	array
+	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
arg	array
;	O
int	O
id	int
=	O
option_get	function
(	O
state	pointer
,	O
&	O
arg	array
)	O
;	O
if	O
(	O
id	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
id	int
)	O
{	O
case	O
't'	O
:	O
if	O
(	O
match_len	function
(	O
arg	array
,	O
"correctness"	pointer
)	O
>=	O
3	int
)	O
options	pointer
->	O
test	enum
=	O
TST_CORRECTNESS	int
;	O
else	O
if	O
(	O
match_len	function
(	O
arg	array
,	O
"overflow"	pointer
)	O
>=	O
3	int
)	O
options	pointer
->	O
test	enum
=	O
TST_OVERFLOW	int
;	O
else	O
if	O
(	O
match_len	function
(	O
arg	array
,	O
"null"	pointer
)	O
>=	O
3	int
)	O
options	pointer
->	O
test	enum
=	O
TST_NULL	int
;	O
else	O
fail	function
(	O
"unknown test \"%s\""	pointer
,	O
arg	array
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
{	O
static	O
const	O
char	O
*	O
orders	array
[	O
INS_CNT	int
]	O
=	O
{	O
"random"	pointer
,	O
"ascending"	pointer
,	O
"descending"	pointer
,	O
"balanced"	pointer
,	O
"zigzag"	pointer
,	O
"asc-shifted"	pointer
,	O
"custom"	pointer
,	O
}	O
;	O
const	O
char	O
*	O
*	O
iter	pointer
;	O
assert	O
(	O
sizeof	O
orders	array
/	O
sizeof	O
*	O
orders	array
==	O
INS_CNT	int
)	O
;	O
for	O
(	O
iter	pointer
=	O
orders	array
;	O
;	O
iter	pointer
++	O
)	O
if	O
(	O
iter	pointer
>=	O
orders	array
+	O
INS_CNT	int
)	O
fail	function
(	O
"unknown order \"%s\""	pointer
,	O
arg	array
)	O
;	O
else	O
if	O
(	O
match_len	function
(	O
*	O
iter	pointer
,	O
arg	array
)	O
>=	O
3	int
)	O
{	O
options	pointer
->	O
insert_order	enum
=	O
iter	pointer
-	O
orders	array
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
'd'	O
:	O
{	O
static	O
const	O
char	O
*	O
orders	array
[	O
DEL_CNT	int
]	O
=	O
{	O
"random"	pointer
,	O
"reverse"	pointer
,	O
"same"	pointer
,	O
"custom"	pointer
,	O
}	O
;	O
const	O
char	O
*	O
*	O
iter	pointer
;	O
assert	O
(	O
sizeof	O
orders	array
/	O
sizeof	O
*	O
orders	array
==	O
DEL_CNT	int
)	O
;	O
for	O
(	O
iter	pointer
=	O
orders	array
;	O
;	O
iter	pointer
++	O
)	O
if	O
(	O
iter	pointer
>=	O
orders	array
+	O
DEL_CNT	int
)	O
fail	function
(	O
"unknown order \"%s\""	pointer
,	O
arg	array
)	O
;	O
else	O
if	O
(	O
match_len	function
(	O
*	O
iter	pointer
,	O
arg	array
)	O
>=	O
3	int
)	O
{	O
options	pointer
->	O
delete_order	enum
=	O
iter	pointer
-	O
orders	array
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
match_len	function
(	O
arg	array
,	O
"track"	pointer
)	O
>=	O
3	int
)	O
options	pointer
->	O
alloc_policy	enum
=	O
MT_TRACK	int
;	O
else	O
if	O
(	O
match_len	function
(	O
arg	array
,	O
"no-track"	pointer
)	O
>=	O
3	int
)	O
options	pointer
->	O
alloc_policy	enum
=	O
MT_NO_TRACK	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	array
,	O
"fail"	pointer
,	O
3	int
)	O
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
arg	array
+	O
strcspn	function
(	O
arg	array
,	O
"-%"	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'-'	O
)	O
options	pointer
->	O
alloc_policy	enum
=	O
MT_FAIL_COUNT	int
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'%'	O
)	O
options	pointer
->	O
alloc_policy	enum
=	O
MT_FAIL_PERCENT	int
;	O
else	O
fail	function
(	O
"invalid allocation policy \"%s\""	pointer
,	O
arg	array
)	O
;	O
options	pointer
->	O
alloc_arg	array
[	O
0	int
]	O
=	O
stoi	function
(	O
p	pointer
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
arg	array
,	O
"suballoc"	pointer
,	O
3	int
)	O
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
arg	array
,	O
'-'	O
)	O
;	O
const	O
char	O
*	O
q	pointer
=	O
strchr	function
(	O
arg	array
,	O
','	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
q	pointer
==	O
NULL	O
)	O
fail	function
(	O
"invalid allocation policy \"%s\""	pointer
,	O
arg	array
)	O
;	O
options	pointer
->	O
alloc_policy	enum
=	O
MT_SUBALLOC	int
;	O
options	pointer
->	O
alloc_arg	array
[	O
0	int
]	O
=	O
stoi	function
(	O
p	pointer
+	O
1	int
)	O
;	O
options	pointer
->	O
alloc_arg	array
[	O
1	int
]	O
=	O
stoi	function
(	O
q	pointer
+	O
1	int
)	O
;	O
if	O
(	O
options	pointer
->	O
alloc_arg	array
[	O
MT_BLOCK_SIZE	int
]	O
<	O
32	int
)	O
fail	function
(	O
"block size too small"	pointer
)	O
;	O
else	O
if	O
(	O
options	pointer
->	O
alloc_arg	array
[	O
MT_ALIGN	int
]	O
>	O
options	pointer
->	O
alloc_arg	array
[	O
MT_BLOCK_SIZE	int
]	O
)	O
fail	function
(	O
"alignment cannot be greater than block size"	pointer
)	O
;	O
else	O
if	O
(	O
options	pointer
->	O
alloc_arg	array
[	O
MT_ALIGN	int
]	O
<	O
1	int
)	O
fail	function
(	O
"alignment must be at least 1"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'A'	O
:	O
options	pointer
->	O
alloc_incr	int
=	O
stoi	function
(	O
arg	array
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
options	pointer
->	O
node_cnt	int
=	O
stoi	function
(	O
arg	array
)	O
;	O
if	O
(	O
options	pointer
->	O
node_cnt	int
<	O
1	int
)	O
fail	function
(	O
"bad tree size \"%s\""	pointer
,	O
arg	array
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
options	pointer
->	O
iter_cnt	int
=	O
stoi	function
(	O
arg	array
)	O
;	O
if	O
(	O
options	pointer
->	O
iter_cnt	int
<	O
1	int
)	O
fail	function
(	O
"bad repeat count \"%s\""	pointer
,	O
arg	array
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
options	pointer
->	O
seed_given	int
=	O
1	int
;	O
options	pointer
->	O
seed	int
=	O
strtoul	function
(	O
arg	array
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
options	pointer
->	O
nonstop	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
options	pointer
->	O
verbosity	int
--	O
;	O
break	O
;	O
case	O
'v'	O
:	O
options	pointer
->	O
verbosity	int
++	O
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
fputs	function
(	O
"GNU libavl 2.0\n"	pointer
"Copyright (C) 1998-2002 Free Software Foundation, Inc.\n"	pointer
"This program comes with NO WARRANTY, not even for\n"	pointer
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"	pointer
"You may redistribute copies under the terms of the\n"	pointer
"GNU General Public License.  For more information on\n"	pointer
"these matters, see the file named COPYING.\n"	pointer
,	O
stdout	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
permuted_integers	function
(	O
int	O
array	array
[	O
]	O
,	O
size_t	long
n	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
array	array
[	O
i	long
]	O
=	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
size_t	long
j	long
=	O
i	long
+	O
(	O
unsigned	O
)	O
rand	function
(	O
)	O
/	O
(	O
RAND_MAX	int
/	O
(	O
n	int
-	O
i	long
)	O
+	O
1	int
)	O
;	O
int	O
t	int
=	O
array	array
[	O
j	long
]	O
;	O
array	array
[	O
j	long
]	O
=	O
array	array
[	O
i	long
]	O
;	O
array	array
[	O
i	long
]	O
=	O
t	int
;	O
}	O
}	O
static	O
void	O
gen_balanced_tree	function
(	O
int	O
min	int
,	O
int	O
max	int
,	O
int	O
*	O
*	O
array	array
)	O
{	O
int	O
i	long
;	O
if	O
(	O
min	int
>	O
max	int
)	O
return	O
;	O
i	long
=	O
(	O
min	int
+	O
max	int
+	O
1	int
)	O
/	O
2	int
;	O
*	O
(	O
*	O
array	array
)	O
++	O
=	O
i	long
;	O
gen_balanced_tree	function
(	O
min	int
,	O
i	long
-	O
1	int
,	O
array	array
)	O
;	O
gen_balanced_tree	function
(	O
i	long
+	O
1	int
,	O
max	int
,	O
array	array
)	O
;	O
}	O
static	O
void	O
gen_insertions	function
(	O
size_t	long
n	int
,	O
enum	O
insert_order	enum
insert_order	enum
,	O
int	O
insert	array
[	O
]	O
)	O
{	O
size_t	long
i	long
;	O
switch	O
(	O
insert_order	enum
)	O
{	O
case	O
INS_RANDOM	int
:	O
permuted_integers	function
(	O
insert	array
,	O
n	int
)	O
;	O
break	O
;	O
case	O
INS_ASCENDING	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
insert	array
[	O
i	long
]	O
=	O
i	long
;	O
break	O
;	O
case	O
INS_DESCENDING	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
insert	array
[	O
i	long
]	O
=	O
n	int
-	O
i	long
-	O
1	int
;	O
break	O
;	O
case	O
INS_BALANCED	int
:	O
gen_balanced_tree	function
(	O
0	int
,	O
n	int
-	O
1	int
,	O
&	O
insert	array
)	O
;	O
break	O
;	O
case	O
INS_ZIGZAG	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
if	O
(	O
i	long
%	O
2	int
==	O
0	int
)	O
insert	array
[	O
i	long
]	O
=	O
i	long
/	O
2	int
;	O
else	O
insert	array
[	O
i	long
]	O
=	O
n	int
-	O
i	long
/	O
2	int
-	O
1	int
;	O
break	O
;	O
case	O
INS_ASCENDING_SHIFTED	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
insert	array
[	O
i	long
]	O
=	O
i	long
+	O
n	int
/	O
2	int
;	O
if	O
(	O
(	O
size_t	long
)	O
insert	array
[	O
i	long
]	O
>=	O
n	int
)	O
insert	array
[	O
i	long
]	O
-=	O
n	int
;	O
}	O
break	O
;	O
case	O
INS_CUSTOM	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
if	O
(	O
scanf	function
(	O
"%d"	pointer
,	O
&	O
insert	array
[	O
i	long
]	O
)	O
==	O
0	int
)	O
fail	function
(	O
"error reading insertion order from stdin"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
gen_deletions	function
(	O
size_t	long
n	int
,	O
enum	O
delete_order	enum
delete_order	enum
,	O
const	O
int	O
*	O
insert	array
,	O
int	O
*	O
delete	array
)	O
{	O
size_t	long
i	long
;	O
switch	O
(	O
delete_order	enum
)	O
{	O
case	O
DEL_RANDOM	int
:	O
permuted_integers	function
(	O
delete	array
,	O
n	int
)	O
;	O
break	O
;	O
case	O
DEL_REVERSE	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
delete	array
[	O
i	long
]	O
=	O
insert	array
[	O
n	int
-	O
i	long
-	O
1	int
]	O
;	O
break	O
;	O
case	O
DEL_SAME	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
delete	array
[	O
i	long
]	O
=	O
insert	array
[	O
i	long
]	O
;	O
break	O
;	O
case	O
DEL_CUSTOM	int
:	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
if	O
(	O
scanf	function
(	O
"%d"	pointer
,	O
&	O
delete	array
[	O
i	long
]	O
)	O
==	O
0	int
)	O
fail	function
(	O
"error reading deletion order from stdin"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
unsigned	O
time_seed	function
(	O
void	O
)	O
{	O
time_t	long
timeval	long
;	O
unsigned	O
char	O
*	O
ptr	pointer
;	O
unsigned	O
seed	int
;	O
size_t	long
i	long
;	O
timeval	long
=	O
time	function
(	O
NULL	O
)	O
;	O
ptr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
timeval	long
;	O
seed	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
sizeof	O
timeval	long
;	O
i	long
++	O
)	O
seed	int
=	O
seed	int
*	O
(	O
UCHAR_MAX	O
+	O
2u	int
)	O
+	O
ptr	pointer
[	O
i	long
]	O
;	O
return	O
seed	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
struct	O
test_options	struct
opts	struct
;	O
int	O
*	O
insert	array
,	O
*	O
delete	array
;	O
int	O
success	int
;	O
pgm_name	pointer
=	O
argv	array
[	O
0	int
]	O
!=	O
NULL	O
&&	O
argv	array
[	O
0	int
]	O
[	O
0	int
]	O
!=	O
'\0'	O
?	O
argv	array
[	O
0	int
]	O
:	O
"bst-test"	pointer
;	O
parse_command_line	function
(	O
argv	array
,	O
&	O
opts	struct
)	O
;	O
if	O
(	O
opts	struct
.	O
verbosity	int
>=	O
0	int
)	O
fputs	function
(	O
"bst-test for GNU libavl 2.0; use --help to get help.\n"	pointer
,	O
stdout	pointer
)	O
;	O
if	O
(	O
!	O
opts	struct
.	O
seed_given	int
)	O
opts	struct
.	O
seed	int
=	O
time_seed	function
(	O
)	O
%	O
32768u	int
;	O
insert	array
=	O
xmalloc	function
(	O
sizeof	O
*	O
insert	array
*	O
opts	struct
.	O
node_cnt	int
)	O
;	O
delete	array
=	O
xmalloc	function
(	O
sizeof	O
*	O
delete	array
*	O
opts	struct
.	O
node_cnt	int
)	O
;	O
success	int
=	O
1	int
;	O
while	O
(	O
opts	struct
.	O
iter_cnt	int
--	O
)	O
{	O
struct	O
mt_allocator	struct
*	O
alloc	pointer
;	O
if	O
(	O
opts	struct
.	O
verbosity	int
>=	O
0	int
)	O
{	O
printf	function
(	O
"Testing seed=%u"	pointer
,	O
opts	struct
.	O
seed	int
)	O
;	O
if	O
(	O
opts	struct
.	O
alloc_incr	int
)	O
printf	function
(	O
", alloc arg=%d"	pointer
,	O
opts	struct
.	O
alloc_arg	array
[	O
0	int
]	O
)	O
;	O
printf	function
(	O
"...\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
srand	function
(	O
opts	struct
.	O
seed	int
)	O
;	O
gen_insertions	function
(	O
opts	struct
.	O
node_cnt	int
,	O
opts	struct
.	O
insert_order	enum
,	O
insert	array
)	O
;	O
srand	function
(	O
++	O
opts	struct
.	O
seed	int
)	O
;	O
gen_deletions	function
(	O
opts	struct
.	O
node_cnt	int
,	O
opts	struct
.	O
delete_order	enum
,	O
insert	array
,	O
delete	array
)	O
;	O
if	O
(	O
opts	struct
.	O
verbosity	int
>=	O
1	int
)	O
{	O
int	O
i	long
;	O
printf	function
(	O
"  Insertion order:"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
opts	struct
.	O
node_cnt	int
;	O
i	long
++	O
)	O
printf	function
(	O
" %d"	pointer
,	O
insert	array
[	O
i	long
]	O
)	O
;	O
printf	function
(	O
".\n"	pointer
)	O
;	O
if	O
(	O
opts	struct
.	O
test	enum
==	O
TST_CORRECTNESS	int
)	O
{	O
printf	function
(	O
"Deletion order:"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
opts	struct
.	O
node_cnt	int
;	O
i	long
++	O
)	O
printf	function
(	O
" %d"	pointer
,	O
delete	array
[	O
i	long
]	O
)	O
;	O
printf	function
(	O
".\n"	pointer
)	O
;	O
}	O
}	O
alloc	pointer
=	O
mt_create	function
(	O
opts	struct
.	O
alloc_policy	enum
,	O
opts	struct
.	O
alloc_arg	array
,	O
opts	struct
.	O
verbosity	int
)	O
;	O
{	O
int	O
okay	int
;	O
struct	O
libavl_allocator	struct
*	O
a	pointer
=	O
mt_allocator	struct
(	O
alloc	pointer
)	O
;	O
switch	O
(	O
opts	struct
.	O
test	enum
)	O
{	O
case	O
TST_CORRECTNESS	int
:	O
okay	int
=	O
test_correctness	function
(	O
a	pointer
,	O
insert	array
,	O
delete	array
,	O
opts	struct
.	O
node_cnt	int
,	O
opts	struct
.	O
verbosity	int
)	O
;	O
break	O
;	O
case	O
TST_OVERFLOW	int
:	O
okay	int
=	O
test_overflow	function
(	O
a	pointer
,	O
insert	array
,	O
opts	struct
.	O
node_cnt	int
,	O
opts	struct
.	O
verbosity	int
)	O
;	O
break	O
;	O
case	O
TST_NULL	int
:	O
okay	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
okay	int
)	O
{	O
if	O
(	O
opts	struct
.	O
verbosity	int
>=	O
1	int
)	O
printf	function
(	O
"  No errors.\n"	pointer
)	O
;	O
}	O
else	O
{	O
success	int
=	O
0	int
;	O
printf	function
(	O
"  Error!\n"	pointer
)	O
;	O
}	O
}	O
mt_destroy	function
(	O
alloc	pointer
)	O
;	O
opts	struct
.	O
alloc_arg	array
[	O
0	int
]	O
+=	O
opts	struct
.	O
alloc_incr	int
;	O
if	O
(	O
!	O
success	int
&&	O
!	O
opts	struct
.	O
nonstop	int
)	O
break	O
;	O
}	O
free	function
(	O
delete	array
)	O
;	O
free	function
(	O
insert	array
)	O
;	O
return	O
success	int
?	O
EXIT_SUCCESS	int
:	O
EXIT_FAILURE	int
;	O
}	O
