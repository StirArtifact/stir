static	O
const	O
char	O
app_text	array
[	O
]	O
=	O
"Midnight-Commander"	pointer
;	O
int	O
easy_patterns	int
=	O
1	int
;	O
extern	O
void	O
str_replace	function
(	O
char	O
*	O
s	pointer
,	O
char	O
from	char
,	O
char	O
to	char
)	O
{	O
for	O
(	O
;	O
*	O
s	pointer
!=	O
'\0'	O
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
from	char
)	O
*	O
s	pointer
=	O
to	char
;	O
}	O
}	O
static	O
inline	O
int	O
is_7bit_printable	function
(	O
unsigned	O
char	O
c	int
)	O
{	O
return	O
(	O
c	int
>	O
31	int
&&	O
c	int
<	O
127	int
)	O
;	O
}	O
static	O
inline	O
int	O
is_iso_printable	function
(	O
unsigned	O
char	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>	O
31	int
&&	O
c	int
<	O
127	int
)	O
||	O
c	int
>=	O
160	int
)	O
;	O
}	O
static	O
inline	O
int	O
is_8bit_printable	function
(	O
unsigned	O
char	O
c	int
)	O
{	O
if	O
(	O
xterm_flag	int
)	O
return	O
is_iso_printable	function
(	O
c	int
)	O
;	O
return	O
(	O
c	int
>	O
31	int
&&	O
c	int
!=	O
127	int
&&	O
c	int
!=	O
155	int
)	O
;	O
}	O
int	O
is_printable	function
(	O
int	O
c	int
)	O
{	O
c	int
&=	O
0xff	int
;	O
if	O
(	O
!	O
eight_bit_clean	int
)	O
return	O
is_7bit_printable	function
(	O
c	int
)	O
;	O
if	O
(	O
full_eight_bits	int
)	O
{	O
return	O
is_8bit_printable	function
(	O
c	int
)	O
;	O
}	O
else	O
return	O
is_iso_printable	function
(	O
c	int
)	O
;	O
}	O
void	O
msglen	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
*	O
lines	pointer
,	O
int	O
*	O
columns	pointer
)	O
{	O
int	O
nlines	int
=	O
1	int
;	O
int	O
ncolumns	int
=	O
0	int
;	O
int	O
colindex	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
text	pointer
!=	O
'\0'	O
;	O
text	pointer
++	O
)	O
{	O
if	O
(	O
*	O
text	pointer
==	O
'\n'	O
)	O
{	O
nlines	int
++	O
;	O
colindex	int
=	O
0	int
;	O
}	O
else	O
{	O
colindex	int
++	O
;	O
if	O
(	O
colindex	int
>	O
ncolumns	int
)	O
ncolumns	int
=	O
colindex	int
;	O
}	O
}	O
*	O
lines	pointer
=	O
nlines	int
;	O
*	O
columns	pointer
=	O
ncolumns	int
;	O
}	O
char	O
*	O
trim	function
(	O
const	O
char	O
*	O
s	pointer
,	O
char	O
*	O
d	double
,	O
int	O
len	int
)	O
{	O
int	O
source_len	int
;	O
len	int
=	O
max	long
(	O
len	int
,	O
0	int
)	O
;	O
source_len	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
source_len	int
>	O
len	int
)	O
{	O
if	O
(	O
len	int
<=	O
3	int
)	O
{	O
memset	function
(	O
d	double
,	O
'.'	O
,	O
len	int
)	O
;	O
d	double
[	O
len	int
]	O
=	O
0	int
;	O
return	O
d	double
;	O
}	O
else	O
{	O
memset	function
(	O
d	double
,	O
'.'	O
,	O
3	int
)	O
;	O
strcpy	function
(	O
d	double
+	O
3	int
,	O
s	pointer
+	O
3	int
+	O
source_len	int
-	O
len	int
)	O
;	O
}	O
}	O
else	O
strcpy	function
(	O
d	double
,	O
s	pointer
)	O
;	O
return	O
d	double
;	O
}	O
char	O
*	O
name_quote	function
(	O
const	O
char	O
*	O
s	pointer
,	O
int	O
quote_percent	int
)	O
{	O
char	O
*	O
ret	pointer
,	O
*	O
d	double
;	O
d	double
=	O
ret	pointer
=	O
g_malloc	function
(	O
strlen	function
(	O
s	pointer
)	O
*	O
2	int
+	O
2	int
+	O
1	int
)	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'-'	O
)	O
{	O
*	O
d	double
++	O
=	O
'.'	O
;	O
*	O
d	double
++	O
=	O
'/'	O
;	O
}	O
for	O
(	O
;	O
*	O
s	pointer
;	O
s	pointer
++	O
,	O
d	double
++	O
)	O
{	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'%'	O
:	O
if	O
(	O
quote_percent	int
)	O
*	O
d	double
++	O
=	O
'%'	O
;	O
break	O
;	O
case	O
'\''	O
:	O
case	O
'\\'	O
:	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
case	O
'\t'	O
:	O
case	O
'"'	O
:	O
case	O
';'	O
:	O
case	O
' '	O
:	O
case	O
'?'	O
:	O
case	O
'|'	O
:	O
case	O
'['	O
:	O
case	O
']'	O
:	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
case	O
'<'	O
:	O
case	O
'>'	O
:	O
case	O
'`'	O
:	O
case	O
'!'	O
:	O
case	O
'$'	O
:	O
case	O
'&'	O
:	O
case	O
'*'	O
:	O
case	O
'('	O
:	O
case	O
')'	O
:	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
break	O
;	O
case	O
'~'	O
:	O
case	O
'#'	O
:	O
if	O
(	O
d	double
==	O
ret	pointer
)	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
break	O
;	O
}	O
*	O
d	double
=	O
*	O
s	pointer
;	O
}	O
*	O
d	double
=	O
'\0'	O
;	O
return	O
ret	pointer
;	O
}	O
char	O
*	O
fake_name_quote	function
(	O
const	O
char	O
*	O
s	pointer
,	O
int	O
quote_percent	int
)	O
{	O
(	O
void	O
)	O
quote_percent	int
;	O
return	O
g_strdup	function
(	O
s	pointer
)	O
;	O
}	O
const	O
char	O
*	O
name_trunc	function
(	O
const	O
char	O
*	O
txt	pointer
,	O
int	O
trunc_len	int
)	O
{	O
static	O
char	O
x	array
[	O
MC_MAXPATHLEN	O
+	O
MC_MAXPATHLEN	O
]	O
;	O
int	O
txt_len	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
(	O
size_t	long
)	O
trunc_len	int
>	O
sizeof	O
(	O
x	array
)	O
-	O
1	int
)	O
{	O
trunc_len	int
=	O
sizeof	O
(	O
x	array
)	O
-	O
1	int
;	O
}	O
txt_len	int
=	O
strlen	function
(	O
txt	pointer
)	O
;	O
if	O
(	O
txt_len	int
<=	O
trunc_len	int
)	O
{	O
strcpy	function
(	O
x	array
,	O
txt	pointer
)	O
;	O
}	O
else	O
{	O
int	O
y	short
=	O
(	O
trunc_len	int
/	O
2	int
)	O
+	O
(	O
trunc_len	int
%	O
2	int
)	O
;	O
strncpy	function
(	O
x	array
,	O
txt	pointer
,	O
y	short
)	O
;	O
strncpy	function
(	O
x	array
+	O
y	short
,	O
txt	pointer
+	O
txt_len	int
-	O
(	O
trunc_len	int
/	O
2	int
)	O
,	O
trunc_len	int
/	O
2	int
)	O
;	O
x	array
[	O
y	short
]	O
=	O
'~'	O
;	O
}	O
x	array
[	O
trunc_len	int
]	O
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
x	array
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
!	O
is_printable	function
(	O
*	O
p	pointer
)	O
)	O
*	O
p	pointer
=	O
'?'	O
;	O
return	O
x	array
;	O
}	O
const	O
char	O
*	O
path_trunc	function
(	O
const	O
char	O
*	O
path	pointer
,	O
int	O
trunc_len	int
)	O
{	O
const	O
char	O
*	O
ret	pointer
;	O
char	O
*	O
secure_path	pointer
=	O
strip_password	function
(	O
g_strdup	function
(	O
path	pointer
)	O
,	O
1	int
)	O
;	O
ret	pointer
=	O
name_trunc	function
(	O
secure_path	pointer
,	O
trunc_len	int
)	O
;	O
g_free	function
(	O
secure_path	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
const	O
char	O
*	O
size_trunc	function
(	O
double	O
size	long
)	O
{	O
static	O
char	O
x	array
[	O
BUF_TINY	int
]	O
;	O
long	O
int	O
divisor	long
=	O
1	int
;	O
const	O
char	O
*	O
xtra	pointer
=	O
""	pointer
;	O
if	O
(	O
size	long
>	O
999999999L	int
)	O
{	O
divisor	long
=	O
1024	int
;	O
xtra	pointer
=	O
"K"	pointer
;	O
if	O
(	O
size	long
/	O
divisor	long
>	O
999999999L	int
)	O
{	O
divisor	long
=	O
1024	int
*	O
1024	int
;	O
xtra	pointer
=	O
"M"	pointer
;	O
}	O
}	O
g_snprintf	function
(	O
x	array
,	O
sizeof	O
(	O
x	array
)	O
,	O
"%.0f%s"	pointer
,	O
(	O
size	long
/	O
divisor	long
)	O
,	O
xtra	pointer
)	O
;	O
return	O
x	array
;	O
}	O
const	O
char	O
*	O
size_trunc_sep	function
(	O
double	O
size	long
)	O
{	O
static	O
char	O
x	array
[	O
60	int
]	O
;	O
int	O
count	int
;	O
const	O
char	O
*	O
p	pointer
,	O
*	O
y	short
;	O
char	O
*	O
d	double
;	O
p	pointer
=	O
y	short
=	O
size_trunc	function
(	O
size	long
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
d	double
=	O
x	array
+	O
sizeof	O
(	O
x	array
)	O
-	O
1	int
;	O
*	O
d	double
--	O
=	O
0	int
;	O
while	O
(	O
p	pointer
>=	O
y	short
&&	O
isalpha	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
*	O
d	double
--	O
=	O
*	O
p	pointer
--	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
p	pointer
>=	O
y	short
;	O
count	int
++	O
)	O
{	O
if	O
(	O
count	int
==	O
3	int
)	O
{	O
*	O
d	double
--	O
=	O
','	O
;	O
count	int
=	O
0	int
;	O
}	O
*	O
d	double
--	O
=	O
*	O
p	pointer
--	O
;	O
}	O
d	double
++	O
;	O
if	O
(	O
*	O
d	double
==	O
','	O
)	O
d	double
++	O
;	O
return	O
d	double
;	O
}	O
void	O
size_trunc_len	function
(	O
char	O
*	O
buffer	pointer
,	O
int	O
len	int
,	O
off_t	long
size	long
,	O
int	O
units	int
)	O
{	O
static	O
const	O
off_t	long
power10	array
[	O
]	O
=	O
{	O
1	int
,	O
10	int
,	O
100	int
,	O
1000	int
,	O
10000	int
,	O
100000	int
,	O
1000000	int
,	O
10000000	int
,	O
100000000	int
,	O
1000000000	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
suffix	pointer
[	O
]	O
=	O
{	O
""	pointer
,	O
"K"	pointer
,	O
"M"	pointer
,	O
"G"	pointer
,	O
"T"	pointer
,	O
"P"	pointer
,	O
"E"	pointer
,	O
"Z"	pointer
,	O
"Y"	pointer
,	O
NULL	O
}	O
;	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
len	int
==	O
0	int
||	O
len	int
>	O
9	int
)	O
len	int
=	O
9	int
;	O
for	O
(	O
j	int
=	O
units	int
;	O
suffix	pointer
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
if	O
(	O
j	int
==	O
units	int
)	O
{	O
g_snprintf	function
(	O
buffer	pointer
,	O
len	int
+	O
1	int
,	O
"0"	pointer
)	O
;	O
break	O
;	O
}	O
g_snprintf	function
(	O
buffer	pointer
,	O
len	int
+	O
1	int
,	O
(	O
len	int
>	O
1	int
)	O
?	O
"~%s"	pointer
:	O
"%s"	pointer
,	O
(	O
j	int
>	O
1	int
)	O
?	O
suffix	pointer
[	O
j	int
-	O
1	int
]	O
:	O
"B"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
size	long
<	O
power10	array
[	O
len	int
-	O
(	O
j	int
>	O
0	int
)	O
]	O
)	O
{	O
g_snprintf	function
(	O
buffer	pointer
,	O
len	int
+	O
1	int
,	O
"%lu%s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
size	long
,	O
suffix	pointer
[	O
j	int
]	O
)	O
;	O
break	O
;	O
}	O
size	long
=	O
(	O
size	long
+	O
512	int
)	O
>>	O
10	int
;	O
}	O
}	O
int	O
is_exe	function
(	O
mode_t	int
mode	int
)	O
{	O
if	O
(	O
(	O
S_IXUSR	O
&	O
mode	int
)	O
||	O
(	O
S_IXGRP	O
&	O
mode	int
)	O
||	O
(	O
S_IXOTH	O
&	O
mode	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
string_perm	function
(	O
mode_t	int
mode_bits	int
)	O
{	O
static	O
char	O
mode	int
[	O
11	int
]	O
;	O
strcpy	function
(	O
mode	int
,	O
"----------"	pointer
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'd'	O
;	O
if	O
(	O
S_ISCHR	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'c'	O
;	O
if	O
(	O
S_ISBLK	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'b'	O
;	O
if	O
(	O
S_ISLNK	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'l'	O
;	O
if	O
(	O
S_ISFIFO	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'p'	O
;	O
if	O
(	O
S_ISNAM	int
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'n'	O
;	O
if	O
(	O
S_ISSOCK	O
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
's'	O
;	O
if	O
(	O
S_ISDOOR	int
(	O
mode_bits	int
)	O
)	O
mode	int
[	O
0	int
]	O
=	O
'D'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IXOTH	O
)	O
)	O
mode	int
[	O
9	int
]	O
=	O
'x'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IWOTH	O
)	O
)	O
mode	int
[	O
8	int
]	O
=	O
'w'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IROTH	O
)	O
)	O
mode	int
[	O
7	int
]	O
=	O
'r'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IXGRP	O
)	O
)	O
mode	int
[	O
6	int
]	O
=	O
'x'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IWGRP	O
)	O
)	O
mode	int
[	O
5	int
]	O
=	O
'w'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IRGRP	O
)	O
)	O
mode	int
[	O
4	int
]	O
=	O
'r'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IXUSR	O
)	O
)	O
mode	int
[	O
3	int
]	O
=	O
'x'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IWUSR	O
)	O
)	O
mode	int
[	O
2	int
]	O
=	O
'w'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_IRUSR	O
)	O
)	O
mode	int
[	O
1	int
]	O
=	O
'r'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_ISUID	O
)	O
)	O
mode	int
[	O
3	int
]	O
=	O
(	O
mode	int
[	O
3	int
]	O
==	O
'x'	O
)	O
?	O
's'	O
:	O
'S'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_ISGID	O
)	O
)	O
mode	int
[	O
6	int
]	O
=	O
(	O
mode	int
[	O
6	int
]	O
==	O
'x'	O
)	O
?	O
's'	O
:	O
'S'	O
;	O
if	O
(	O
ismode	O
(	O
mode_bits	int
,	O
S_ISVTX	O
)	O
)	O
mode	int
[	O
9	int
]	O
=	O
(	O
mode	int
[	O
9	int
]	O
==	O
'x'	O
)	O
?	O
't'	O
:	O
'T'	O
;	O
return	O
mode	int
;	O
}	O
char	O
*	O
strip_password	function
(	O
char	O
*	O
p	pointer
,	O
int	O
has_prefix	int
)	O
{	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
size_t	long
len	int
;	O
}	O
prefixes	array
[	O
]	O
=	O
{	O
{	O
"/#ftp:"	pointer
,	O
6	int
}	O
,	O
{	O
"ftp://"	pointer
,	O
6	int
}	O
,	O
{	O
"/#mc:"	pointer
,	O
5	int
}	O
,	O
{	O
"mc://"	pointer
,	O
5	int
}	O
,	O
{	O
"/#smb:"	pointer
,	O
6	int
}	O
,	O
{	O
"smb://"	pointer
,	O
6	int
}	O
,	O
{	O
"/#sh:"	pointer
,	O
5	int
}	O
,	O
{	O
"sh://"	pointer
,	O
5	int
}	O
,	O
{	O
"ssh://"	pointer
,	O
6	int
}	O
}	O
;	O
char	O
*	O
at	pointer
,	O
*	O
inner_colon	pointer
,	O
*	O
dir	pointer
;	O
size_t	long
i	array
;	O
char	O
*	O
result	long
=	O
p	pointer
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
sizeof	O
(	O
prefixes	array
)	O
/	O
sizeof	O
(	O
prefixes	array
[	O
0	int
]	O
)	O
;	O
i	array
++	O
)	O
{	O
char	O
*	O
q	pointer
;	O
if	O
(	O
has_prefix	int
)	O
{	O
if	O
(	O
(	O
q	pointer
=	O
strstr	function
(	O
p	pointer
,	O
prefixes	array
[	O
i	array
]	O
.	O
name	pointer
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
else	O
p	pointer
=	O
q	pointer
+	O
prefixes	array
[	O
i	array
]	O
.	O
len	int
;	O
}	O
if	O
(	O
(	O
dir	pointer
=	O
strchr	function
(	O
p	pointer
,	O
PATH_SEP	char
)	O
)	O
!=	O
NULL	O
)	O
*	O
dir	pointer
=	O
'\0'	O
;	O
at	pointer
=	O
strrchr	function
(	O
p	pointer
,	O
'@'	O
)	O
;	O
if	O
(	O
dir	pointer
)	O
*	O
dir	pointer
=	O
PATH_SEP	char
;	O
if	O
(	O
at	pointer
)	O
{	O
inner_colon	pointer
=	O
memchr	function
(	O
p	pointer
,	O
':'	O
,	O
at	pointer
-	O
p	pointer
)	O
;	O
if	O
(	O
inner_colon	pointer
)	O
memmove	function
(	O
inner_colon	pointer
,	O
at	pointer
,	O
strlen	function
(	O
at	pointer
)	O
+	O
1	int
)	O
;	O
}	O
break	O
;	O
}	O
return	O
(	O
result	long
)	O
;	O
}	O
const	O
char	O
*	O
strip_home_and_password	function
(	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
size_t	long
len	int
;	O
static	O
char	O
newdir	array
[	O
MC_MAXPATHLEN	O
]	O
;	O
if	O
(	O
home_dir	pointer
&&	O
!	O
strncmp	function
(	O
dir	pointer
,	O
home_dir	pointer
,	O
len	int
=	O
strlen	function
(	O
home_dir	pointer
)	O
)	O
&&	O
(	O
dir	pointer
[	O
len	int
]	O
==	O
PATH_SEP	char
||	O
dir	pointer
[	O
len	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
newdir	array
[	O
0	int
]	O
=	O
'~'	O
;	O
g_strlcpy	function
(	O
&	O
newdir	array
[	O
1	int
]	O
,	O
&	O
dir	pointer
[	O
len	int
]	O
,	O
sizeof	O
(	O
newdir	array
)	O
-	O
1	int
)	O
;	O
return	O
newdir	array
;	O
}	O
g_strlcpy	function
(	O
newdir	array
,	O
dir	pointer
,	O
sizeof	O
(	O
newdir	array
)	O
)	O
;	O
strip_password	function
(	O
newdir	array
,	O
1	int
)	O
;	O
return	O
newdir	array
;	O
}	O
static	O
char	O
*	O
maybe_start_group	function
(	O
char	O
*	O
d	double
,	O
int	O
do_group	int
,	O
int	O
*	O
was_wildcard	pointer
)	O
{	O
if	O
(	O
!	O
do_group	int
)	O
return	O
d	double
;	O
if	O
(	O
*	O
was_wildcard	pointer
)	O
return	O
d	double
;	O
*	O
was_wildcard	pointer
=	O
1	int
;	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
*	O
d	double
++	O
=	O
'('	O
;	O
return	O
d	double
;	O
}	O
static	O
char	O
*	O
maybe_end_group	function
(	O
char	O
*	O
d	double
,	O
int	O
do_group	int
,	O
int	O
*	O
was_wildcard	pointer
)	O
{	O
if	O
(	O
!	O
do_group	int
)	O
return	O
d	double
;	O
if	O
(	O
!	O
*	O
was_wildcard	pointer
)	O
return	O
d	double
;	O
*	O
was_wildcard	pointer
=	O
0	int
;	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
*	O
d	double
++	O
=	O
')'	O
;	O
return	O
d	double
;	O
}	O
char	O
*	O
convert_pattern	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
int	O
match_type	int
,	O
int	O
do_group	int
)	O
{	O
char	O
*	O
d	double
;	O
char	O
*	O
new_pattern	pointer
;	O
int	O
was_wildcard	pointer
=	O
0	int
;	O
const	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
match_type	int
!=	O
match_regex	int
)	O
&&	O
easy_patterns	int
)	O
{	O
new_pattern	pointer
=	O
g_malloc	function
(	O
MC_MAXPATHLEN	O
)	O
;	O
d	double
=	O
new_pattern	pointer
;	O
if	O
(	O
match_type	int
==	O
match_file	int
)	O
*	O
d	double
++	O
=	O
'^'	O
;	O
for	O
(	O
s	pointer
=	O
pattern	pointer
;	O
*	O
s	pointer
;	O
s	pointer
++	O
,	O
d	double
++	O
)	O
{	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'*'	O
:	O
d	double
=	O
maybe_start_group	function
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	pointer
)	O
;	O
*	O
d	double
++	O
=	O
'.'	O
;	O
*	O
d	double
=	O
'*'	O
;	O
break	O
;	O
case	O
'?'	O
:	O
d	double
=	O
maybe_start_group	function
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	pointer
)	O
;	O
*	O
d	double
=	O
'.'	O
;	O
break	O
;	O
case	O
'.'	O
:	O
d	double
=	O
maybe_end_group	function
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	pointer
)	O
;	O
*	O
d	double
++	O
=	O
'\\'	O
;	O
*	O
d	double
=	O
'.'	O
;	O
break	O
;	O
default	O
:	O
d	double
=	O
maybe_end_group	function
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	pointer
)	O
;	O
*	O
d	double
=	O
*	O
s	pointer
;	O
break	O
;	O
}	O
}	O
d	double
=	O
maybe_end_group	function
(	O
d	double
,	O
do_group	int
,	O
&	O
was_wildcard	pointer
)	O
;	O
if	O
(	O
match_type	int
==	O
match_file	int
)	O
*	O
d	double
++	O
=	O
'$'	O
;	O
*	O
d	double
=	O
0	int
;	O
return	O
new_pattern	pointer
;	O
}	O
else	O
return	O
g_strdup	function
(	O
pattern	pointer
)	O
;	O
}	O
int	O
regexp_match	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
const	O
char	O
*	O
string	pointer
,	O
int	O
match_type	int
)	O
{	O
static	O
regex_t	struct
r	struct
;	O
static	O
char	O
*	O
old_pattern	pointer
=	O
NULL	O
;	O
static	O
int	O
old_type	int
;	O
int	O
rval	pointer
;	O
char	O
*	O
my_pattern	pointer
;	O
if	O
(	O
!	O
old_pattern	pointer
||	O
STRCOMP	O
(	O
old_pattern	pointer
,	O
pattern	pointer
)	O
||	O
old_type	int
!=	O
match_type	int
)	O
{	O
if	O
(	O
old_pattern	pointer
)	O
{	O
regfree	function
(	O
&	O
r	struct
)	O
;	O
g_free	function
(	O
old_pattern	pointer
)	O
;	O
old_pattern	pointer
=	O
NULL	O
;	O
}	O
my_pattern	pointer
=	O
convert_pattern	function
(	O
pattern	pointer
,	O
match_type	int
,	O
0	int
)	O
;	O
if	O
(	O
regcomp	function
(	O
&	O
r	struct
,	O
my_pattern	pointer
,	O
REG_EXTENDED	int
|	O
REG_NOSUB	O
|	O
MC_ARCH_FLAGS	int
)	O
)	O
{	O
g_free	function
(	O
my_pattern	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
old_pattern	pointer
=	O
my_pattern	pointer
;	O
old_type	int
=	O
match_type	int
;	O
}	O
rval	pointer
=	O
!	O
regexec	function
(	O
&	O
r	struct
,	O
string	pointer
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
return	O
rval	pointer
;	O
}	O
const	O
char	O
*	O
extension	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
const	O
char	O
*	O
d	double
=	O
strrchr	function
(	O
filename	pointer
,	O
'.'	O
)	O
;	O
return	O
(	O
d	double
!=	O
NULL	O
)	O
?	O
d	double
+	O
1	int
:	O
""	pointer
;	O
}	O
int	O
get_int	function
(	O
const	O
char	O
*	O
file	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
int	O
def	int
)	O
{	O
return	O
GetPrivateProfileInt	function
(	O
app_text	array
,	O
key	pointer
,	O
def	int
,	O
file	pointer
)	O
;	O
}	O
int	O
set_int	function
(	O
const	O
char	O
*	O
file	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
int	O
value	pointer
)	O
{	O
char	O
buffer	pointer
[	O
BUF_TINY	int
]	O
;	O
g_snprintf	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
"%d"	pointer
,	O
value	pointer
)	O
;	O
return	O
WritePrivateProfileString	function
(	O
app_text	array
,	O
key	pointer
,	O
buffer	pointer
,	O
file	pointer
)	O
;	O
}	O
extern	O
char	O
*	O
get_config_string	function
(	O
const	O
char	O
*	O
file	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
defval	pointer
)	O
{	O
char	O
buffer	pointer
[	O
1024	int
]	O
;	O
(	O
void	O
)	O
GetPrivateProfileString	function
(	O
app_text	array
,	O
key	pointer
,	O
defval	pointer
,	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
file	pointer
)	O
;	O
return	O
g_strdup	function
(	O
buffer	pointer
)	O
;	O
}	O
extern	O
void	O
set_config_string	function
(	O
const	O
char	O
*	O
file	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
val	array
)	O
{	O
(	O
void	O
)	O
WritePrivateProfileString	function
(	O
app_text	array
,	O
key	pointer
,	O
val	array
,	O
file	pointer
)	O
;	O
}	O
int	O
exist_file	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
access	function
(	O
name	pointer
,	O
R_OK	int
)	O
==	O
0	int
;	O
}	O
char	O
*	O
load_file	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
data_file	pointer
;	O
struct	O
stat	struct
s	pointer
;	O
char	O
*	O
data	pointer
;	O
long	O
read_size	long
;	O
if	O
(	O
(	O
data_file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
data_file	pointer
)	O
,	O
&	O
s	pointer
)	O
!=	O
0	int
)	O
{	O
fclose	function
(	O
data_file	pointer
)	O
;	O
return	O
0	int
;	O
}	O
data	pointer
=	O
g_malloc	function
(	O
s	pointer
.	O
st_size	long
+	O
1	int
)	O
;	O
read_size	long
=	O
fread	function
(	O
data	pointer
,	O
1	int
,	O
s	pointer
.	O
st_size	long
,	O
data_file	pointer
)	O
;	O
data	pointer
[	O
read_size	long
]	O
=	O
0	int
;	O
fclose	function
(	O
data_file	pointer
)	O
;	O
if	O
(	O
read_size	long
>	O
0	int
)	O
return	O
data	pointer
;	O
else	O
{	O
g_free	function
(	O
data	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
char	O
*	O
load_mc_home_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
*	O
allocated_filename	pointer
)	O
{	O
char	O
*	O
hintfile_base	pointer
,	O
*	O
hintfile	pointer
;	O
char	O
*	O
lang	pointer
;	O
char	O
*	O
data	pointer
;	O
hintfile_base	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
filename	pointer
)	O
;	O
lang	pointer
=	O
guess_message_value	function
(	O
)	O
;	O
hintfile	pointer
=	O
g_strconcat	function
(	O
hintfile_base	pointer
,	O
"."	pointer
,	O
lang	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
data	pointer
=	O
load_file	function
(	O
hintfile	pointer
)	O
;	O
if	O
(	O
!	O
data	pointer
)	O
{	O
g_free	function
(	O
hintfile	pointer
)	O
;	O
if	O
(	O
lang	pointer
[	O
0	int
]	O
&&	O
lang	pointer
[	O
1	int
]	O
)	O
lang	pointer
[	O
2	int
]	O
=	O
0	int
;	O
hintfile	pointer
=	O
g_strconcat	function
(	O
hintfile_base	pointer
,	O
"."	pointer
,	O
lang	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
data	pointer
=	O
load_file	function
(	O
hintfile	pointer
)	O
;	O
if	O
(	O
!	O
data	pointer
)	O
{	O
g_free	function
(	O
hintfile	pointer
)	O
;	O
hintfile	pointer
=	O
hintfile_base	pointer
;	O
data	pointer
=	O
load_file	function
(	O
hintfile_base	pointer
)	O
;	O
}	O
}	O
g_free	function
(	O
lang	pointer
)	O
;	O
if	O
(	O
hintfile	pointer
!=	O
hintfile_base	pointer
)	O
g_free	function
(	O
hintfile_base	pointer
)	O
;	O
if	O
(	O
allocated_filename	pointer
)	O
*	O
allocated_filename	pointer
=	O
hintfile	pointer
;	O
else	O
g_free	function
(	O
hintfile	pointer
)	O
;	O
return	O
data	pointer
;	O
}	O
size_t	long
i18n_checktimelength	function
(	O
void	O
)	O
{	O
size_t	long
length	int
,	O
a	pointer
,	O
b	pointer
;	O
char	O
buf	pointer
[	O
MAX_I18NTIMELENGTH	int
+	O
1	int
]	O
;	O
time_t	long
testtime	long
=	O
time	long
(	O
NULL	O
)	O
;	O
a	pointer
=	O
strftime	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
,	O
_	O
(	O
"%b %e %H:%M"	pointer
)	O
,	O
localtime	function
(	O
&	O
testtime	long
)	O
)	O
;	O
b	pointer
=	O
strftime	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
,	O
_	O
(	O
"%b %e  %Y"	pointer
)	O
,	O
localtime	function
(	O
&	O
testtime	long
)	O
)	O
;	O
length	int
=	O
max	long
(	O
a	pointer
,	O
b	pointer
)	O
;	O
if	O
(	O
length	int
>	O
MAX_I18NTIMELENGTH	int
||	O
length	int
<	O
MIN_I18NTIMELENGTH	int
)	O
length	int
=	O
STD_I18NTIMELENGTH	int
;	O
return	O
length	int
;	O
}	O
const	O
char	O
*	O
file_date	function
(	O
time_t	long
when	long
)	O
{	O
static	O
char	O
timebuf	array
[	O
MAX_I18NTIMELENGTH	int
+	O
1	int
]	O
;	O
time_t	long
current_time	long
=	O
time	long
(	O
(	O
time_t	long
)	O
0	int
)	O
;	O
static	O
size_t	long
i18n_timelength	long
=	O
0	int
;	O
static	O
const	O
char	O
*	O
fmtyear	pointer
,	O
*	O
fmttime	pointer
;	O
const	O
char	O
*	O
fmt	pointer
;	O
if	O
(	O
i18n_timelength	long
==	O
0	int
)	O
{	O
i18n_timelength	long
=	O
i18n_checktimelength	function
(	O
)	O
+	O
1	int
;	O
fmtyear	pointer
=	O
_	O
(	O
"%b %e  %Y"	pointer
)	O
;	O
fmttime	pointer
=	O
_	O
(	O
"%b %e %H:%M"	pointer
)	O
;	O
}	O
if	O
(	O
current_time	long
>	O
when	long
+	O
6L	int
*	O
30L	int
*	O
24L	int
*	O
60L	int
*	O
60L	int
||	O
current_time	long
<	O
when	long
-	O
60L	int
*	O
60L	int
)	O
fmt	pointer
=	O
fmtyear	pointer
;	O
else	O
fmt	pointer
=	O
fmttime	pointer
;	O
strftime	function
(	O
timebuf	array
,	O
i18n_timelength	long
,	O
fmt	pointer
,	O
localtime	function
(	O
&	O
when	long
)	O
)	O
;	O
return	O
timebuf	array
;	O
}	O
const	O
char	O
*	O
extract_line	function
(	O
const	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
top	pointer
)	O
{	O
static	O
char	O
tmp_line	array
[	O
BUF_MEDIUM	int
]	O
;	O
char	O
*	O
t	long
=	O
tmp_line	array
;	O
while	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
'\n'	O
&&	O
(	O
size_t	long
)	O
(	O
t	long
-	O
tmp_line	array
)	O
<	O
sizeof	O
(	O
tmp_line	array
)	O
-	O
1	int
&&	O
s	pointer
<	O
top	pointer
)	O
*	O
t	long
++	O
=	O
*	O
s	pointer
++	O
;	O
*	O
t	long
=	O
0	int
;	O
return	O
tmp_line	array
;	O
}	O
const	O
char	O
*	O
_icase_search	function
(	O
const	O
char	O
*	O
text	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
int	O
*	O
lng	pointer
)	O
{	O
const	O
char	O
*	O
d	double
=	O
text	pointer
;	O
const	O
char	O
*	O
e	pointer
=	O
data	pointer
;	O
int	O
dlng	int
=	O
0	int
;	O
if	O
(	O
lng	pointer
)	O
*	O
lng	pointer
=	O
0	int
;	O
for	O
(	O
;	O
*	O
e	pointer
;	O
e	pointer
++	O
)	O
{	O
while	O
(	O
*	O
(	O
e	pointer
+	O
1	int
)	O
==	O
'\b'	O
&&	O
*	O
(	O
e	pointer
+	O
2	int
)	O
)	O
{	O
e	pointer
+=	O
2	int
;	O
dlng	int
+=	O
2	int
;	O
}	O
if	O
(	O
toupper	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
d	double
)	O
==	O
toupper	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
e	pointer
)	O
)	O
d	double
++	O
;	O
else	O
{	O
e	pointer
-=	O
d	double
-	O
text	pointer
;	O
d	double
=	O
text	pointer
;	O
dlng	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
*	O
d	double
)	O
{	O
if	O
(	O
lng	pointer
)	O
*	O
lng	pointer
=	O
strlen	function
(	O
text	pointer
)	O
+	O
dlng	int
;	O
return	O
e	pointer
+	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
x_basename	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
const	O
char	O
*	O
where	pointer
;	O
return	O
(	O
(	O
where	pointer
=	O
strrchr	function
(	O
s	pointer
,	O
PATH_SEP	char
)	O
)	O
)	O
?	O
where	pointer
+	O
1	int
:	O
s	pointer
;	O
}	O
const	O
char	O
*	O
unix_error_string	function
(	O
int	O
error_num	int
)	O
{	O
static	O
char	O
buffer	pointer
[	O
BUF_LARGE	O
]	O
;	O
gchar	char
*	O
strerror_currentlocale	pointer
;	O
strerror_currentlocale	pointer
=	O
g_locale_from_utf8	function
(	O
g_strerror	function
(	O
error_num	int
)	O
,	O
-	O
1	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
g_snprintf	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
"%s (%d)"	pointer
,	O
strerror_currentlocale	pointer
,	O
error_num	int
)	O
;	O
g_free	function
(	O
strerror_currentlocale	pointer
)	O
;	O
return	O
buffer	pointer
;	O
}	O
const	O
char	O
*	O
skip_separators	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
for	O
(	O
;	O
*	O
s	pointer
;	O
s	pointer
++	O
)	O
if	O
(	O
*	O
s	pointer
!=	O
' '	O
&&	O
*	O
s	pointer
!=	O
'\t'	O
&&	O
*	O
s	pointer
!=	O
','	O
)	O
break	O
;	O
return	O
s	pointer
;	O
}	O
const	O
char	O
*	O
skip_numbers	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
for	O
(	O
;	O
*	O
s	pointer
;	O
s	pointer
++	O
)	O
if	O
(	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
)	O
)	O
break	O
;	O
return	O
s	pointer
;	O
}	O
char	O
*	O
strip_ctrl_codes	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
w	pointer
;	O
char	O
*	O
r	struct
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
0	int
;	O
for	O
(	O
w	pointer
=	O
s	pointer
,	O
r	struct
=	O
s	pointer
;	O
*	O
r	struct
;	O
)	O
{	O
if	O
(	O
*	O
r	struct
==	O
ESC_CHAR	char
)	O
{	O
;	O
if	O
(	O
*	O
(	O
++	O
r	struct
)	O
==	O
'['	O
)	O
{	O
while	O
(	O
*	O
(	O
++	O
r	struct
)	O
&&	O
strchr	function
(	O
"0123456789;?"	pointer
,	O
*	O
r	struct
)	O
)	O
;	O
}	O
if	O
(	O
*	O
r	struct
)	O
r	struct
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
is_printable	function
(	O
*	O
r	struct
)	O
)	O
*	O
w	pointer
++	O
=	O
*	O
r	struct
;	O
++	O
r	struct
;	O
}	O
*	O
w	pointer
=	O
0	int
;	O
return	O
s	pointer
;	O
}	O
enum	O
compression_type	enum
get_compression_type	function
(	O
int	O
fd	int
)	O
{	O
unsigned	O
char	O
magic	array
[	O
4	int
]	O
;	O
if	O
(	O
mc_read	function
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
magic	array
,	O
4	int
)	O
!=	O
4	int
)	O
return	O
COMPRESSION_NONE	int
;	O
if	O
(	O
magic	array
[	O
0	int
]	O
==	O
037	int
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
0213	int
||	O
magic	array
[	O
1	int
]	O
==	O
0236	int
)	O
)	O
{	O
return	O
COMPRESSION_GZIP	int
;	O
}	O
if	O
(	O
magic	array
[	O
0	int
]	O
==	O
0120	int
&&	O
magic	array
[	O
1	int
]	O
==	O
0113	int
&&	O
magic	array
[	O
2	int
]	O
==	O
003	int
&&	O
magic	array
[	O
3	int
]	O
==	O
004	int
)	O
{	O
mc_lseek	function
(	O
fd	int
,	O
8	int
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
mc_read	function
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
magic	array
,	O
2	int
)	O
!=	O
2	int
)	O
return	O
COMPRESSION_NONE	int
;	O
if	O
(	O
(	O
magic	array
[	O
0	int
]	O
!=	O
8	int
&&	O
magic	array
[	O
0	int
]	O
!=	O
0	int
)	O
||	O
magic	array
[	O
1	int
]	O
!=	O
0	int
)	O
return	O
COMPRESSION_NONE	int
;	O
return	O
COMPRESSION_GZIP	int
;	O
}	O
if	O
(	O
magic	array
[	O
0	int
]	O
==	O
037	int
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
036	int
||	O
magic	array
[	O
1	int
]	O
==	O
0240	int
||	O
magic	array
[	O
1	int
]	O
==	O
0235	int
)	O
)	O
{	O
return	O
COMPRESSION_GZIP	int
;	O
}	O
if	O
(	O
(	O
magic	array
[	O
0	int
]	O
==	O
'B'	O
)	O
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
'Z'	O
)	O
&&	O
(	O
magic	array
[	O
3	int
]	O
>=	O
'1'	O
)	O
&&	O
(	O
magic	array
[	O
3	int
]	O
<=	O
'9'	O
)	O
)	O
{	O
switch	O
(	O
magic	array
[	O
2	int
]	O
)	O
{	O
case	O
'0'	O
:	O
return	O
COMPRESSION_BZIP	int
;	O
case	O
'h'	O
:	O
return	O
COMPRESSION_BZIP2	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
decompress_extension	function
(	O
int	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
COMPRESSION_GZIP	int
:	O
return	O
"#ugz"	pointer
;	O
case	O
COMPRESSION_BZIP	int
:	O
return	O
"#ubz"	pointer
;	O
case	O
COMPRESSION_BZIP2	int
:	O
return	O
"#ubz2"	pointer
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"Fatal: decompress_extension called with an unknown argument\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
add_hook	function
(	O
Hook	struct
*	O
*	O
hook_list	pointer
,	O
void	O
(	O
*	O
hook_fn	pointer
)	O
(	O
void	O
*	O
)	O
,	O
void	O
*	O
data	pointer
)	O
{	O
Hook	struct
*	O
new_hook	pointer
=	O
g_new	O
(	O
Hook	struct
,	O
1	int
)	O
;	O
new_hook	pointer
->	O
hook_fn	pointer
=	O
hook_fn	pointer
;	O
new_hook	pointer
->	O
next	pointer
=	O
*	O
hook_list	pointer
;	O
new_hook	pointer
->	O
hook_data	pointer
=	O
data	pointer
;	O
*	O
hook_list	pointer
=	O
new_hook	pointer
;	O
}	O
void	O
execute_hooks	function
(	O
Hook	struct
*	O
hook_list	pointer
)	O
{	O
Hook	struct
*	O
new_hook	pointer
=	O
0	int
;	O
Hook	struct
*	O
p	pointer
;	O
while	O
(	O
hook_list	pointer
)	O
{	O
add_hook	function
(	O
&	O
new_hook	pointer
,	O
hook_list	pointer
->	O
hook_fn	pointer
,	O
hook_list	pointer
->	O
hook_data	pointer
)	O
;	O
hook_list	pointer
=	O
hook_list	pointer
->	O
next	pointer
;	O
}	O
p	pointer
=	O
new_hook	pointer
;	O
while	O
(	O
new_hook	pointer
)	O
{	O
(	O
*	O
new_hook	pointer
->	O
hook_fn	pointer
)	O
(	O
new_hook	pointer
->	O
hook_data	pointer
)	O
;	O
new_hook	pointer
=	O
new_hook	pointer
->	O
next	pointer
;	O
}	O
for	O
(	O
hook_list	pointer
=	O
p	pointer
;	O
hook_list	pointer
;	O
)	O
{	O
p	pointer
=	O
hook_list	pointer
;	O
hook_list	pointer
=	O
hook_list	pointer
->	O
next	pointer
;	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
}	O
void	O
delete_hook	function
(	O
Hook	struct
*	O
*	O
hook_list	pointer
,	O
void	O
(	O
*	O
hook_fn	pointer
)	O
(	O
void	O
*	O
)	O
)	O
{	O
Hook	struct
*	O
current	pointer
,	O
*	O
new_list	pointer
,	O
*	O
next	pointer
;	O
new_list	pointer
=	O
0	int
;	O
for	O
(	O
current	pointer
=	O
*	O
hook_list	pointer
;	O
current	pointer
;	O
current	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
current	pointer
->	O
hook_fn	pointer
==	O
hook_fn	pointer
)	O
g_free	function
(	O
current	pointer
)	O
;	O
else	O
add_hook	function
(	O
&	O
new_list	pointer
,	O
current	pointer
->	O
hook_fn	pointer
,	O
current	pointer
->	O
hook_data	pointer
)	O
;	O
}	O
*	O
hook_list	pointer
=	O
new_list	pointer
;	O
}	O
int	O
hook_present	function
(	O
Hook	struct
*	O
hook_list	pointer
,	O
void	O
(	O
*	O
hook_fn	pointer
)	O
(	O
void	O
*	O
)	O
)	O
{	O
Hook	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
hook_list	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
hook_fn	pointer
==	O
hook_fn	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
wipe_password	function
(	O
char	O
*	O
passwd	struct
)	O
{	O
char	O
*	O
p	pointer
=	O
passwd	struct
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
;	O
for	O
(	O
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
*	O
p	pointer
=	O
0	int
;	O
g_free	function
(	O
passwd	struct
)	O
;	O
}	O
char	O
*	O
convert_controls	function
(	O
const	O
char	O
*	O
p	pointer
)	O
{	O
char	O
*	O
valcopy	pointer
=	O
g_strdup	function
(	O
p	pointer
)	O
;	O
char	O
*	O
q	pointer
;	O
for	O
(	O
q	pointer
=	O
valcopy	pointer
;	O
*	O
p	pointer
;	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
)	O
{	O
p	pointer
++	O
;	O
if	O
(	O
(	O
*	O
p	pointer
==	O
'e'	O
)	O
||	O
(	O
*	O
p	pointer
==	O
'E'	O
)	O
)	O
{	O
p	pointer
++	O
;	O
*	O
q	pointer
++	O
=	O
ESC_CHAR	char
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'^'	O
)	O
{	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'^'	O
)	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
else	O
{	O
char	O
c	int
=	O
(	O
*	O
p	pointer
|	O
0x20	int
)	O
;	O
if	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
)	O
{	O
*	O
q	pointer
++	O
=	O
c	int
-	O
'a'	O
+	O
1	int
;	O
p	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
)	O
p	pointer
++	O
;	O
}	O
}	O
else	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
}	O
}	O
*	O
q	pointer
=	O
0	int
;	O
return	O
valcopy	pointer
;	O
}	O
static	O
char	O
*	O
resolve_symlinks	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
buf	pointer
,	O
*	O
buf2	pointer
,	O
*	O
q	pointer
,	O
*	O
r	struct
,	O
c	int
;	O
int	O
len	int
;	O
struct	O
stat	struct
mybuf	struct
;	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
*	O
path	pointer
!=	O
PATH_SEP	char
)	O
return	O
NULL	O
;	O
r	struct
=	O
buf	pointer
=	O
g_malloc	function
(	O
MC_MAXPATHLEN	O
)	O
;	O
buf2	pointer
=	O
g_malloc	function
(	O
MC_MAXPATHLEN	O
)	O
;	O
*	O
r	struct
++	O
=	O
PATH_SEP	char
;	O
*	O
r	struct
=	O
0	int
;	O
p	pointer
=	O
path	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
q	pointer
=	O
strchr	function
(	O
p	pointer
+	O
1	int
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
!	O
q	pointer
)	O
{	O
q	pointer
=	O
strchr	function
(	O
p	pointer
+	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
q	pointer
==	O
p	pointer
+	O
1	int
)	O
break	O
;	O
}	O
c	int
=	O
*	O
q	pointer
;	O
*	O
q	pointer
=	O
0	int
;	O
if	O
(	O
mc_lstat	function
(	O
path	pointer
,	O
&	O
mybuf	struct
)	O
<	O
0	int
)	O
{	O
g_free	function
(	O
buf	pointer
)	O
;	O
g_free	function
(	O
buf2	pointer
)	O
;	O
*	O
q	pointer
=	O
c	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
S_ISLNK	O
(	O
mybuf	struct
.	O
st_mode	int
)	O
)	O
strcpy	function
(	O
r	struct
,	O
p	pointer
+	O
1	int
)	O
;	O
else	O
{	O
len	int
=	O
mc_readlink	function
(	O
path	pointer
,	O
buf2	pointer
,	O
MC_MAXPATHLEN	O
-	O
1	int
)	O
;	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
g_free	function
(	O
buf	pointer
)	O
;	O
g_free	function
(	O
buf2	pointer
)	O
;	O
*	O
q	pointer
=	O
c	int
;	O
return	O
NULL	O
;	O
}	O
buf2	pointer
[	O
len	int
]	O
=	O
0	int
;	O
if	O
(	O
*	O
buf2	pointer
==	O
PATH_SEP	char
)	O
strcpy	function
(	O
buf	pointer
,	O
buf2	pointer
)	O
;	O
else	O
strcpy	function
(	O
r	struct
,	O
buf2	pointer
)	O
;	O
}	O
canonicalize_pathname	function
(	O
buf	pointer
)	O
;	O
r	struct
=	O
strchr	function
(	O
buf	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
*	O
r	struct
||	O
*	O
(	O
r	struct
-	O
1	int
)	O
!=	O
PATH_SEP	char
)	O
{	O
*	O
r	struct
++	O
=	O
PATH_SEP	char
;	O
*	O
r	struct
=	O
0	int
;	O
}	O
*	O
q	pointer
=	O
c	int
;	O
p	pointer
=	O
q	pointer
;	O
if	O
(	O
!	O
c	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
*	O
buf	pointer
)	O
strcpy	function
(	O
buf	pointer
,	O
PATH_SEP_STR	pointer
)	O
;	O
else	O
if	O
(	O
*	O
(	O
r	struct
-	O
1	int
)	O
==	O
PATH_SEP	char
&&	O
r	struct
!=	O
buf	pointer
+	O
1	int
)	O
*	O
(	O
r	struct
-	O
1	int
)	O
=	O
0	int
;	O
g_free	function
(	O
buf2	pointer
)	O
;	O
return	O
buf	pointer
;	O
}	O
char	O
*	O
diff_two_paths	function
(	O
const	O
char	O
*	O
first	pointer
,	O
const	O
char	O
*	O
second	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
,	O
*	O
r	struct
,	O
*	O
s	pointer
,	O
*	O
buf	pointer
=	O
NULL	O
;	O
int	O
i	array
,	O
j	int
,	O
prevlen	int
=	O
-	O
1	int
,	O
currlen	int
;	O
char	O
*	O
my_first	pointer
=	O
NULL	O
,	O
*	O
my_second	pointer
=	O
NULL	O
;	O
my_first	pointer
=	O
resolve_symlinks	function
(	O
first	pointer
)	O
;	O
if	O
(	O
my_first	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
my_second	pointer
=	O
resolve_symlinks	function
(	O
second	pointer
)	O
;	O
if	O
(	O
my_second	pointer
==	O
NULL	O
)	O
{	O
g_free	function
(	O
my_first	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
2	int
;	O
j	int
++	O
)	O
{	O
p	pointer
=	O
my_first	pointer
;	O
q	pointer
=	O
my_second	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
r	struct
=	O
strchr	function
(	O
p	pointer
,	O
PATH_SEP	char
)	O
;	O
s	pointer
=	O
strchr	function
(	O
q	pointer
,	O
PATH_SEP	char
)	O
;	O
if	O
(	O
!	O
r	struct
||	O
!	O
s	pointer
)	O
break	O
;	O
*	O
r	struct
=	O
0	int
;	O
*	O
s	pointer
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
q	pointer
)	O
)	O
{	O
*	O
r	struct
=	O
PATH_SEP	char
;	O
*	O
s	pointer
=	O
PATH_SEP	char
;	O
break	O
;	O
}	O
else	O
{	O
*	O
r	struct
=	O
PATH_SEP	char
;	O
*	O
s	pointer
=	O
PATH_SEP	char
;	O
}	O
p	pointer
=	O
r	struct
+	O
1	int
;	O
q	pointer
=	O
s	pointer
+	O
1	int
;	O
}	O
p	pointer
--	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
(	O
p	pointer
=	O
strchr	function
(	O
p	pointer
+	O
1	int
,	O
PATH_SEP	char
)	O
)	O
!=	O
NULL	O
;	O
i	array
++	O
)	O
;	O
currlen	int
=	O
(	O
i	array
+	O
1	int
)	O
*	O
3	int
+	O
strlen	function
(	O
q	pointer
)	O
+	O
1	int
;	O
if	O
(	O
j	int
)	O
{	O
if	O
(	O
currlen	int
<	O
prevlen	int
)	O
g_free	function
(	O
buf	pointer
)	O
;	O
else	O
{	O
g_free	function
(	O
my_first	pointer
)	O
;	O
g_free	function
(	O
my_second	pointer
)	O
;	O
return	O
buf	pointer
;	O
}	O
}	O
p	pointer
=	O
buf	pointer
=	O
g_malloc	function
(	O
currlen	int
)	O
;	O
prevlen	int
=	O
currlen	int
;	O
for	O
(	O
;	O
i	array
>=	O
0	int
;	O
i	array
--	O
,	O
p	pointer
+=	O
3	int
)	O
strcpy	function
(	O
p	pointer
,	O
"../"	pointer
)	O
;	O
strcpy	function
(	O
p	pointer
,	O
q	pointer
)	O
;	O
}	O
g_free	function
(	O
my_first	pointer
)	O
;	O
g_free	function
(	O
my_second	pointer
)	O
;	O
return	O
buf	pointer
;	O
}	O
char	O
*	O
concat_dir_and_file	function
(	O
const	O
char	O
*	O
dir	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
int	O
i	array
=	O
strlen	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
dir	pointer
[	O
i	array
-	O
1	int
]	O
==	O
PATH_SEP	char
)	O
return	O
g_strconcat	function
(	O
dir	pointer
,	O
file	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
else	O
return	O
g_strconcat	function
(	O
dir	pointer
,	O
PATH_SEP_STR	pointer
,	O
file	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
GList	struct
*	O
list_append_unique	function
(	O
GList	struct
*	O
list	pointer
,	O
char	O
*	O
text	pointer
)	O
{	O
GList	struct
*	O
link	function
,	O
*	O
newlink	pointer
;	O
list	pointer
=	O
g_list_append	function
(	O
list	pointer
,	O
text	pointer
)	O
;	O
list	pointer
=	O
g_list_last	function
(	O
list	pointer
)	O
;	O
link	function
=	O
g_list_previous	O
(	O
list	pointer
)	O
;	O
while	O
(	O
link	function
)	O
{	O
newlink	pointer
=	O
g_list_previous	O
(	O
link	function
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
(	O
char	O
*	O
)	O
link	function
->	O
data	pointer
,	O
text	pointer
)	O
)	O
{	O
g_free	function
(	O
link	function
->	O
data	pointer
)	O
;	O
g_list_remove_link	function
(	O
list	pointer
,	O
link	function
)	O
;	O
g_list_free_1	function
(	O
link	function
)	O
;	O
}	O
link	function
=	O
newlink	pointer
;	O
}	O
return	O
list	pointer
;	O
}	O
int	O
mc_mkstemps	function
(	O
char	O
*	O
*	O
pname	pointer
,	O
const	O
char	O
*	O
prefix	pointer
,	O
const	O
char	O
*	O
suffix	pointer
)	O
{	O
static	O
const	O
char	O
letters	array
[	O
]	O
=	O
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"	pointer
;	O
static	O
unsigned	O
long	O
value	pointer
;	O
struct	O
timeval	struct
tv	pointer
;	O
char	O
*	O
tmpbase	pointer
;	O
char	O
*	O
tmpname	pointer
;	O
char	O
*	O
XXXXXX	pointer
;	O
int	O
count	int
;	O
if	O
(	O
strchr	function
(	O
prefix	pointer
,	O
PATH_SEP	char
)	O
==	O
NULL	O
)	O
{	O
tmpbase	pointer
=	O
concat_dir_and_file	function
(	O
mc_tmpdir	function
(	O
)	O
,	O
prefix	pointer
)	O
;	O
}	O
else	O
{	O
tmpbase	pointer
=	O
g_strdup	function
(	O
prefix	pointer
)	O
;	O
}	O
tmpname	pointer
=	O
g_strconcat	function
(	O
tmpbase	pointer
,	O
"XXXXXX"	pointer
,	O
suffix	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
*	O
pname	pointer
=	O
tmpname	pointer
;	O
XXXXXX	pointer
=	O
&	O
tmpname	pointer
[	O
strlen	function
(	O
tmpbase	pointer
)	O
]	O
;	O
g_free	function
(	O
tmpbase	pointer
)	O
;	O
gettimeofday	function
(	O
&	O
tv	pointer
,	O
NULL	O
)	O
;	O
value	pointer
+=	O
(	O
tv	pointer
.	O
tv_usec	long
<<	O
16	int
)	O
^	O
tv	pointer
.	O
tv_sec	long
^	O
getpid	function
(	O
)	O
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
TMP_MAX	int
;	O
++	O
count	int
)	O
{	O
unsigned	O
long	O
v	pointer
=	O
value	pointer
;	O
int	O
fd	int
;	O
XXXXXX	pointer
[	O
0	int
]	O
=	O
letters	array
[	O
v	pointer
%	O
62	int
]	O
;	O
v	pointer
/=	O
62	int
;	O
XXXXXX	pointer
[	O
1	int
]	O
=	O
letters	array
[	O
v	pointer
%	O
62	int
]	O
;	O
v	pointer
/=	O
62	int
;	O
XXXXXX	pointer
[	O
2	int
]	O
=	O
letters	array
[	O
v	pointer
%	O
62	int
]	O
;	O
v	pointer
/=	O
62	int
;	O
XXXXXX	pointer
[	O
3	int
]	O
=	O
letters	array
[	O
v	pointer
%	O
62	int
]	O
;	O
v	pointer
/=	O
62	int
;	O
XXXXXX	pointer
[	O
4	int
]	O
=	O
letters	array
[	O
v	pointer
%	O
62	int
]	O
;	O
v	pointer
/=	O
62	int
;	O
XXXXXX	pointer
[	O
5	int
]	O
=	O
letters	array
[	O
v	pointer
%	O
62	int
]	O
;	O
fd	int
=	O
open	function
(	O
tmpname	pointer
,	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
|	O
O_EXCL	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
return	O
fd	int
;	O
}	O
value	pointer
+=	O
7777	int
;	O
}	O
g_free	function
(	O
tmpname	pointer
)	O
;	O
*	O
pname	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
load_file_position	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
long	O
*	O
line	int
,	O
long	O
*	O
column	pointer
)	O
{	O
char	O
*	O
fn	pointer
;	O
FILE	struct
*	O
f	struct
;	O
char	O
buf	pointer
[	O
MC_MAXPATHLEN	O
+	O
20	int
]	O
;	O
int	O
len	int
;	O
*	O
line	int
=	O
1	int
;	O
*	O
column	pointer
=	O
0	int
;	O
fn	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
MC_FILEPOS	pointer
)	O
;	O
f	struct
=	O
fopen	function
(	O
fn	pointer
,	O
"r"	pointer
)	O
;	O
g_free	function
(	O
fn	pointer
)	O
;	O
if	O
(	O
!	O
f	struct
)	O
return	O
;	O
len	int
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
f	struct
)	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
filename	pointer
,	O
len	int
)	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
buf	pointer
[	O
len	int
]	O
!=	O
' '	O
)	O
continue	O
;	O
p	pointer
=	O
&	O
buf	pointer
[	O
len	int
+	O
1	int
]	O
;	O
if	O
(	O
strchr	function
(	O
p	pointer
,	O
' '	O
)	O
)	O
continue	O
;	O
*	O
line	int
=	O
strtol	function
(	O
p	pointer
,	O
const_cast	O
(	O
char	O
*	O
*	O
,	O
&	O
p	pointer
)	O
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
';'	O
)	O
{	O
*	O
column	pointer
=	O
strtol	function
(	O
p	pointer
+	O
1	int
,	O
const_cast	O
(	O
char	O
*	O
*	O
,	O
&	O
p	pointer
)	O
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
'\n'	O
)	O
*	O
column	pointer
=	O
0	int
;	O
}	O
else	O
*	O
line	int
=	O
1	int
;	O
}	O
fclose	function
(	O
f	struct
)	O
;	O
}	O
void	O
save_file_position	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
long	O
line	int
,	O
long	O
column	pointer
)	O
{	O
char	O
*	O
tmp	pointer
,	O
*	O
fn	pointer
;	O
FILE	struct
*	O
f	struct
,	O
*	O
t	long
;	O
char	O
buf	pointer
[	O
MC_MAXPATHLEN	O
+	O
20	int
]	O
;	O
int	O
i	array
=	O
1	int
;	O
int	O
len	int
;	O
len	int
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
tmp	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
MC_FILEPOS_TMP	pointer
)	O
;	O
fn	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
MC_FILEPOS	pointer
)	O
;	O
t	long
=	O
fopen	function
(	O
tmp	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
t	long
)	O
{	O
g_free	function
(	O
tmp	pointer
)	O
;	O
g_free	function
(	O
fn	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
line	int
!=	O
1	int
||	O
column	pointer
!=	O
0	int
)	O
{	O
fprintf	function
(	O
t	long
,	O
"%s %ld;%ld\n"	pointer
,	O
filename	pointer
,	O
line	int
,	O
column	pointer
)	O
;	O
}	O
f	struct
=	O
fopen	function
(	O
fn	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
f	struct
)	O
{	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
f	struct
)	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
filename	pointer
,	O
len	int
)	O
==	O
0	int
&&	O
buf	pointer
[	O
len	int
]	O
==	O
' '	O
&&	O
!	O
strchr	function
(	O
&	O
buf	pointer
[	O
len	int
+	O
1	int
]	O
,	O
' '	O
)	O
)	O
continue	O
;	O
fprintf	function
(	O
t	long
,	O
"%s"	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
++	O
i	array
>	O
MC_FILEPOS_ENTRIES	int
)	O
break	O
;	O
}	O
fclose	function
(	O
f	struct
)	O
;	O
}	O
fclose	function
(	O
t	long
)	O
;	O
rename	function
(	O
tmp	pointer
,	O
fn	pointer
)	O
;	O
g_free	function
(	O
tmp	pointer
)	O
;	O
g_free	function
(	O
fn	pointer
)	O
;	O
}	O
extern	O
const	O
char	O
*	O
cstrcasestr	function
(	O
const	O
char	O
*	O
haystack	pointer
,	O
const	O
char	O
*	O
needle	pointer
)	O
{	O
const	O
char	O
*	O
hptr	pointer
;	O
size_t	long
i	array
,	O
needle_len	long
;	O
needle_len	long
=	O
strlen	function
(	O
needle	pointer
)	O
;	O
for	O
(	O
hptr	pointer
=	O
haystack	pointer
;	O
*	O
hptr	pointer
!=	O
'\0'	O
;	O
hptr	pointer
++	O
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
needle_len	long
;	O
i	array
++	O
)	O
{	O
if	O
(	O
toupper	function
(	O
(	O
unsigned	O
char	O
)	O
hptr	pointer
[	O
i	array
]	O
)	O
!=	O
toupper	function
(	O
(	O
unsigned	O
char	O
)	O
needle	pointer
[	O
i	array
]	O
)	O
)	O
goto	O
next_try	O
;	O
}	O
return	O
hptr	pointer
;	O
next_try	O
:	O
(	O
void	O
)	O
0	int
;	O
}	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
cstrstr	function
(	O
const	O
char	O
*	O
haystack	pointer
,	O
const	O
char	O
*	O
needle	pointer
)	O
{	O
return	O
strstr	function
(	O
haystack	pointer
,	O
needle	pointer
)	O
;	O
}	O
extern	O
char	O
*	O
str_unconst	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
return	O
(	O
char	O
*	O
)	O
s	pointer
;	O
}	O
extern	O
int	O
ascii_alpha_to_cntrl	function
(	O
int	O
ch	int
)	O
{	O
if	O
(	O
(	O
ch	int
>=	O
ASCII_A	O
&&	O
ch	int
<=	O
ASCII_Z	O
)	O
||	O
(	O
ch	int
>=	O
ASCII_a	O
&&	O
ch	int
<=	O
ASCII_z	O
)	O
)	O
{	O
ch	int
&=	O
0x1f	int
;	O
}	O
return	O
ch	int
;	O
}	O
const	O
char	O
*	O
Q_	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
const	O
char	O
*	O
result	long
,	O
*	O
sep	pointer
;	O
result	long
=	O
_	O
(	O
s	pointer
)	O
;	O
sep	pointer
=	O
strchr	function
(	O
result	long
,	O
'|'	O
)	O
;	O
return	O
(	O
sep	pointer
!=	O
NULL	O
)	O
?	O
sep	pointer
+	O
1	int
:	O
result	long
;	O
}	O
