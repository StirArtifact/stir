size_t	long
alignment	long
;	O
bool	bool
byteswap	bool
;	O
bool	bool
no_hash_table	bool
;	O
enum	O
{	O
M_ID	int
=	O
0	int
,	O
M_STR	int
=	O
1	int
}	O
;	O
struct	O
pre_string	struct
{	O
size_t	long
length	int
;	O
const	O
char	O
*	O
pointer	pointer
;	O
}	O
;	O
struct	O
pre_message	struct
{	O
struct	O
pre_string	struct
str	array
[	O
2	int
]	O
;	O
const	O
char	O
*	O
id_plural	pointer
;	O
size_t	long
id_plural_len	long
;	O
}	O
;	O
static	O
int	O
compare_id	function
(	O
const	O
void	O
*	O
pval1	pointer
,	O
const	O
void	O
*	O
pval2	pointer
)	O
{	O
return	O
strcmp	function
(	O
(	O
(	O
struct	O
pre_message	struct
*	O
)	O
pval1	pointer
)	O
->	O
str	array
[	O
M_ID	int
]	O
.	O
pointer	pointer
,	O
(	O
(	O
struct	O
pre_message	struct
*	O
)	O
pval2	pointer
)	O
->	O
str	array
[	O
M_ID	int
]	O
.	O
pointer	pointer
)	O
;	O
}	O
struct	O
pre_sysdep_segment	struct
{	O
size_t	long
length	int
;	O
const	O
char	O
*	O
pointer	pointer
;	O
}	O
;	O
struct	O
pre_segment_pair	struct
{	O
size_t	long
segsize	int
;	O
const	O
char	O
*	O
segptr	pointer
;	O
size_t	long
sysdepref	int
;	O
}	O
;	O
struct	O
pre_sysdep_string	struct
{	O
unsigned	O
int	O
segmentcount	int
;	O
struct	O
pre_segment_pair	struct
segments	array
[	O
1	int
]	O
;	O
}	O
;	O
struct	O
pre_sysdep_message	struct
{	O
struct	O
pre_sysdep_string	struct
*	O
str	array
[	O
2	int
]	O
;	O
const	O
char	O
*	O
id_plural	pointer
;	O
size_t	long
id_plural_len	long
;	O
}	O
;	O
static	O
void	O
write_table	function
(	O
FILE	struct
*	O
output_file	pointer
,	O
message_list_ty	struct
*	O
mlp	pointer
)	O
{	O
char	O
*	O
*	O
msgctid_arr	pointer
;	O
size_t	long
nstrings	int
;	O
struct	O
pre_message	struct
*	O
msg_arr	pointer
;	O
size_t	long
n_sysdep_strings	int
;	O
struct	O
pre_sysdep_message	struct
*	O
sysdep_msg_arr	pointer
;	O
size_t	long
n_sysdep_segments	int
;	O
struct	O
pre_sysdep_segment	struct
*	O
sysdep_segments	pointer
;	O
bool	bool
have_outdigits	bool
;	O
int	O
major_revision	int
;	O
int	O
minor_revision	int
;	O
bool	bool
omit_hash_table	bool
;	O
nls_uint32	int
hash_tab_size	int
;	O
struct	O
mo_file_header	struct
header	struct
;	O
size_t	long
header_size	long
;	O
size_t	long
offset	int
;	O
struct	O
string_desc	struct
*	O
orig_tab	pointer
;	O
struct	O
string_desc	struct
*	O
trans_tab	pointer
;	O
size_t	long
sysdep_tab_offset	long
=	O
0	int
;	O
size_t	long
end_offset	long
;	O
char	O
*	O
null	pointer
;	O
size_t	long
j	long
,	O
m	long
;	O
msgctid_arr	pointer
=	O
XNMALLOC	O
(	O
mlp	pointer
->	O
nitems	long
,	O
char	O
*	O
)	O
;	O
nstrings	int
=	O
0	int
;	O
msg_arr	pointer
=	O
XNMALLOC	O
(	O
mlp	pointer
->	O
nitems	long
,	O
struct	O
pre_message	struct
)	O
;	O
n_sysdep_strings	int
=	O
0	int
;	O
sysdep_msg_arr	pointer
=	O
XNMALLOC	O
(	O
mlp	pointer
->	O
nitems	long
,	O
struct	O
pre_sysdep_message	struct
)	O
;	O
n_sysdep_segments	int
=	O
0	int
;	O
sysdep_segments	pointer
=	O
NULL	O
;	O
have_outdigits	bool
=	O
false	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
size_t	long
msgctlen	long
;	O
char	O
*	O
msgctid	pointer
;	O
struct	O
interval	struct
*	O
intervals	array
[	O
2	int
]	O
;	O
size_t	long
nintervals	array
[	O
2	int
]	O
;	O
msgctlen	long
=	O
(	O
mp	pointer
->	O
msgctxt	pointer
!=	O
NULL	O
?	O
strlen	function
(	O
mp	pointer
->	O
msgctxt	pointer
)	O
+	O
1	int
:	O
0	int
)	O
;	O
msgctid	pointer
=	O
XNMALLOC	O
(	O
msgctlen	long
+	O
strlen	function
(	O
mp	pointer
->	O
msgid	pointer
)	O
+	O
1	int
,	O
char	O
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgctxt	pointer
!=	O
NULL	O
)	O
{	O
memcpy	function
(	O
msgctid	pointer
,	O
mp	pointer
->	O
msgctxt	pointer
,	O
msgctlen	long
-	O
1	int
)	O
;	O
msgctid	pointer
[	O
msgctlen	long
-	O
1	int
]	O
=	O
MSGCTXT_SEPARATOR	char
;	O
}	O
strcpy	function
(	O
msgctid	pointer
+	O
msgctlen	long
,	O
mp	pointer
->	O
msgid	pointer
)	O
;	O
msgctid_arr	pointer
[	O
j	long
]	O
=	O
msgctid	pointer
;	O
intervals	array
[	O
M_ID	int
]	O
=	O
NULL	O
;	O
nintervals	array
[	O
M_ID	int
]	O
=	O
0	int
;	O
intervals	array
[	O
M_STR	int
]	O
=	O
NULL	O
;	O
nintervals	array
[	O
M_STR	int
]	O
=	O
0	int
;	O
if	O
(	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_c	int
]	O
)	O
||	O
possible_format_p	function
(	O
mp	pointer
->	O
is_format	enum
[	O
format_objc	int
]	O
)	O
)	O
{	O
const	O
char	O
*	O
p_end	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
get_sysdep_c_format_directives	function
(	O
mp	pointer
->	O
msgid	pointer
,	O
false	int
,	O
&	O
intervals	array
[	O
M_ID	int
]	O
,	O
&	O
nintervals	array
[	O
M_ID	int
]	O
)	O
;	O
if	O
(	O
msgctlen	long
>	O
0	int
)	O
{	O
struct	O
interval	struct
*	O
id_intervals	pointer
=	O
intervals	array
[	O
M_ID	int
]	O
;	O
size_t	long
id_nintervals	long
=	O
nintervals	array
[	O
M_ID	int
]	O
;	O
if	O
(	O
id_nintervals	long
>	O
0	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
id_nintervals	long
;	O
i	long
++	O
)	O
{	O
id_intervals	pointer
[	O
i	long
]	O
.	O
startpos	long
+=	O
msgctlen	long
;	O
id_intervals	pointer
[	O
i	long
]	O
.	O
endpos	long
+=	O
msgctlen	long
;	O
}	O
}	O
}	O
p_end	pointer
=	O
mp	pointer
->	O
msgstr	pointer
+	O
mp	pointer
->	O
msgstr_len	long
;	O
for	O
(	O
p	pointer
=	O
mp	pointer
->	O
msgstr	pointer
;	O
p	pointer
<	O
p_end	pointer
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
{	O
struct	O
interval	struct
*	O
part_intervals	pointer
;	O
size_t	long
part_nintervals	long
;	O
get_sysdep_c_format_directives	function
(	O
p	pointer
,	O
true	int
,	O
&	O
part_intervals	pointer
,	O
&	O
part_nintervals	long
)	O
;	O
if	O
(	O
part_nintervals	long
>	O
0	int
)	O
{	O
size_t	long
d	long
=	O
p	pointer
-	O
mp	pointer
->	O
msgstr	pointer
;	O
unsigned	O
int	O
i	long
;	O
intervals	array
[	O
M_STR	int
]	O
=	O
(	O
struct	O
interval	struct
*	O
)	O
xrealloc	function
(	O
intervals	array
[	O
M_STR	int
]	O
,	O
(	O
nintervals	array
[	O
M_STR	int
]	O
+	O
part_nintervals	long
)	O
*	O
sizeof	O
(	O
struct	O
interval	struct
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
part_nintervals	long
;	O
i	long
++	O
)	O
{	O
intervals	array
[	O
M_STR	int
]	O
[	O
nintervals	array
[	O
M_STR	int
]	O
+	O
i	long
]	O
.	O
startpos	long
=	O
d	long
+	O
part_intervals	pointer
[	O
i	long
]	O
.	O
startpos	long
;	O
intervals	array
[	O
M_STR	int
]	O
[	O
nintervals	array
[	O
M_STR	int
]	O
+	O
i	long
]	O
.	O
endpos	long
=	O
d	long
+	O
part_intervals	pointer
[	O
i	long
]	O
.	O
endpos	long
;	O
}	O
nintervals	array
[	O
M_STR	int
]	O
+=	O
part_nintervals	long
;	O
}	O
}	O
}	O
if	O
(	O
nintervals	array
[	O
M_ID	int
]	O
>	O
0	int
||	O
nintervals	array
[	O
M_STR	int
]	O
>	O
0	int
)	O
{	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
2	int
;	O
m	long
++	O
)	O
{	O
struct	O
pre_sysdep_string	struct
*	O
pre	pointer
=	O
(	O
struct	O
pre_sysdep_string	struct
*	O
)	O
xmalloc	function
(	O
xsum	function
(	O
sizeof	O
(	O
struct	O
pre_sysdep_string	struct
)	O
,	O
xtimes	O
(	O
nintervals	array
[	O
m	long
]	O
,	O
sizeof	O
(	O
struct	O
pre_segment_pair	struct
)	O
)	O
)	O
)	O
;	O
const	O
char	O
*	O
str	array
;	O
size_t	long
str_len	long
;	O
size_t	long
lastpos	long
;	O
unsigned	O
int	O
i	long
;	O
if	O
(	O
m	long
==	O
M_ID	int
)	O
{	O
str	array
=	O
msgctid	pointer
;	O
str_len	long
=	O
strlen	function
(	O
msgctid	pointer
)	O
+	O
1	int
;	O
}	O
else	O
{	O
str	array
=	O
mp	pointer
->	O
msgstr	pointer
;	O
str_len	long
=	O
mp	pointer
->	O
msgstr_len	long
;	O
}	O
lastpos	long
=	O
0	int
;	O
pre	pointer
->	O
segmentcount	int
=	O
nintervals	array
[	O
m	long
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nintervals	array
[	O
m	long
]	O
;	O
i	long
++	O
)	O
{	O
size_t	long
length	int
;	O
const	O
char	O
*	O
pointer	pointer
;	O
size_t	long
r	int
;	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
segptr	pointer
=	O
str	array
+	O
lastpos	long
;	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
segsize	int
=	O
intervals	array
[	O
m	long
]	O
[	O
i	long
]	O
.	O
startpos	long
-	O
lastpos	long
;	O
length	int
=	O
intervals	array
[	O
m	long
]	O
[	O
i	long
]	O
.	O
endpos	long
-	O
intervals	array
[	O
m	long
]	O
[	O
i	long
]	O
.	O
startpos	long
;	O
pointer	pointer
=	O
str	array
+	O
intervals	array
[	O
m	long
]	O
[	O
i	long
]	O
.	O
startpos	long
;	O
if	O
(	O
length	int
>=	O
2	int
&&	O
pointer	pointer
[	O
0	int
]	O
==	O
'<'	O
&&	O
pointer	pointer
[	O
length	int
-	O
1	int
]	O
==	O
'>'	O
)	O
{	O
length	int
-=	O
2	int
;	O
pointer	pointer
+=	O
1	int
;	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
n_sysdep_segments	int
;	O
r	int
++	O
)	O
if	O
(	O
sysdep_segments	pointer
[	O
r	int
]	O
.	O
length	int
==	O
length	int
&&	O
memcmp	function
(	O
sysdep_segments	pointer
[	O
r	int
]	O
.	O
pointer	pointer
,	O
pointer	pointer
,	O
length	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
r	int
==	O
n_sysdep_segments	int
)	O
{	O
n_sysdep_segments	int
++	O
;	O
sysdep_segments	pointer
=	O
(	O
struct	O
pre_sysdep_segment	struct
*	O
)	O
xrealloc	function
(	O
sysdep_segments	pointer
,	O
n_sysdep_segments	int
*	O
sizeof	O
(	O
struct	O
pre_sysdep_segment	struct
)	O
)	O
;	O
sysdep_segments	pointer
[	O
r	int
]	O
.	O
length	int
=	O
length	int
;	O
sysdep_segments	pointer
[	O
r	int
]	O
.	O
pointer	pointer
=	O
pointer	pointer
;	O
}	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
sysdepref	int
=	O
r	int
;	O
if	O
(	O
length	int
==	O
1	int
&&	O
*	O
pointer	pointer
==	O
'I'	O
)	O
have_outdigits	bool
=	O
true	int
;	O
lastpos	long
=	O
intervals	array
[	O
m	long
]	O
[	O
i	long
]	O
.	O
endpos	long
;	O
}	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
segptr	pointer
=	O
str	array
+	O
lastpos	long
;	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
segsize	int
=	O
str_len	long
-	O
lastpos	long
;	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
sysdepref	int
=	O
SEGMENTS_END	O
;	O
sysdep_msg_arr	pointer
[	O
n_sysdep_strings	int
]	O
.	O
str	array
[	O
m	long
]	O
=	O
pre	pointer
;	O
}	O
sysdep_msg_arr	pointer
[	O
n_sysdep_strings	int
]	O
.	O
id_plural	pointer
=	O
mp	pointer
->	O
msgid_plural	pointer
;	O
sysdep_msg_arr	pointer
[	O
n_sysdep_strings	int
]	O
.	O
id_plural_len	long
=	O
(	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
?	O
strlen	function
(	O
mp	pointer
->	O
msgid_plural	pointer
)	O
+	O
1	int
:	O
0	int
)	O
;	O
n_sysdep_strings	int
++	O
;	O
}	O
else	O
{	O
msg_arr	pointer
[	O
nstrings	int
]	O
.	O
str	array
[	O
M_ID	int
]	O
.	O
pointer	pointer
=	O
msgctid	pointer
;	O
msg_arr	pointer
[	O
nstrings	int
]	O
.	O
str	array
[	O
M_ID	int
]	O
.	O
length	int
=	O
strlen	function
(	O
msgctid	pointer
)	O
+	O
1	int
;	O
msg_arr	pointer
[	O
nstrings	int
]	O
.	O
str	array
[	O
M_STR	int
]	O
.	O
pointer	pointer
=	O
mp	pointer
->	O
msgstr	pointer
;	O
msg_arr	pointer
[	O
nstrings	int
]	O
.	O
str	array
[	O
M_STR	int
]	O
.	O
length	int
=	O
mp	pointer
->	O
msgstr_len	long
;	O
msg_arr	pointer
[	O
nstrings	int
]	O
.	O
id_plural	pointer
=	O
mp	pointer
->	O
msgid_plural	pointer
;	O
msg_arr	pointer
[	O
nstrings	int
]	O
.	O
id_plural_len	long
=	O
(	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
?	O
strlen	function
(	O
mp	pointer
->	O
msgid_plural	pointer
)	O
+	O
1	int
:	O
0	int
)	O
;	O
nstrings	int
++	O
;	O
}	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
2	int
;	O
m	long
++	O
)	O
if	O
(	O
intervals	array
[	O
m	long
]	O
!=	O
NULL	O
)	O
free	function
(	O
intervals	array
[	O
m	long
]	O
)	O
;	O
}	O
if	O
(	O
nstrings	int
>	O
0	int
)	O
qsort	function
(	O
msg_arr	pointer
,	O
nstrings	int
,	O
sizeof	O
(	O
struct	O
pre_message	struct
)	O
,	O
compare_id	function
)	O
;	O
major_revision	int
=	O
(	O
have_outdigits	bool
?	O
MO_REVISION_NUMBER_WITH_SYSDEP_I	int
:	O
MO_REVISION_NUMBER	int
)	O
;	O
minor_revision	int
=	O
(	O
n_sysdep_strings	int
>	O
0	int
?	O
1	int
:	O
0	int
)	O
;	O
omit_hash_table	bool
=	O
(	O
no_hash_table	bool
&&	O
minor_revision	int
==	O
0	int
)	O
;	O
if	O
(	O
!	O
omit_hash_table	bool
)	O
{	O
hash_tab_size	int
=	O
next_prime	function
(	O
(	O
mlp	pointer
->	O
nitems	long
*	O
4	int
)	O
/	O
3	int
)	O
;	O
if	O
(	O
hash_tab_size	int
<=	O
2	int
)	O
hash_tab_size	int
=	O
3	int
;	O
}	O
else	O
hash_tab_size	int
=	O
0	int
;	O
header	struct
.	O
magic	int
=	O
_MAGIC	int
;	O
header	struct
.	O
revision	int
=	O
(	O
major_revision	int
<<	O
16	int
)	O
+	O
minor_revision	int
;	O
header_size	long
=	O
(	O
minor_revision	int
==	O
0	int
?	O
offsetof	O
(	O
struct	O
mo_file_header	struct
,	O
n_sysdep_segments	int
)	O
:	O
sizeof	O
(	O
struct	O
mo_file_header	struct
)	O
)	O
;	O
offset	int
=	O
header_size	long
;	O
header	struct
.	O
nstrings	int
=	O
nstrings	int
;	O
header	struct
.	O
orig_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
nstrings	int
*	O
sizeof	O
(	O
struct	O
string_desc	struct
)	O
;	O
orig_tab	pointer
=	O
XNMALLOC	O
(	O
nstrings	int
,	O
struct	O
string_desc	struct
)	O
;	O
header	struct
.	O
trans_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
nstrings	int
*	O
sizeof	O
(	O
struct	O
string_desc	struct
)	O
;	O
trans_tab	pointer
=	O
XNMALLOC	O
(	O
nstrings	int
,	O
struct	O
string_desc	struct
)	O
;	O
header	struct
.	O
hash_tab_size	int
=	O
hash_tab_size	int
;	O
header	struct
.	O
hash_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
hash_tab_size	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
;	O
if	O
(	O
minor_revision	int
>=	O
1	int
)	O
{	O
header	struct
.	O
n_sysdep_segments	int
=	O
n_sysdep_segments	int
;	O
header	struct
.	O
sysdep_segments_offset	int
=	O
offset	int
;	O
offset	int
+=	O
n_sysdep_segments	int
*	O
sizeof	O
(	O
struct	O
sysdep_segment	struct
)	O
;	O
header	struct
.	O
n_sysdep_strings	int
=	O
n_sysdep_strings	int
;	O
header	struct
.	O
orig_sysdep_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
n_sysdep_strings	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
;	O
header	struct
.	O
trans_sysdep_tab_offset	int
=	O
offset	int
;	O
offset	int
+=	O
n_sysdep_strings	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
;	O
sysdep_tab_offset	long
=	O
offset	int
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
2	int
;	O
m	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_sysdep_strings	int
;	O
j	long
++	O
)	O
offset	int
+=	O
sizeof	O
(	O
struct	O
sysdep_string	struct
)	O
+	O
sysdep_msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
m	long
]	O
->	O
segmentcount	int
*	O
sizeof	O
(	O
struct	O
segment_pair	struct
)	O
;	O
}	O
end_offset	long
=	O
offset	int
;	O
if	O
(	O
byteswap	bool
)	O
{	O
BSWAP32	O
(	O
header	struct
.	O
magic	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
revision	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
nstrings	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
orig_tab_offset	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
trans_tab_offset	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
hash_tab_size	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
hash_tab_offset	int
)	O
;	O
if	O
(	O
minor_revision	int
>=	O
1	int
)	O
{	O
BSWAP32	O
(	O
header	struct
.	O
n_sysdep_segments	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
sysdep_segments_offset	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
n_sysdep_strings	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
orig_sysdep_tab_offset	int
)	O
;	O
BSWAP32	O
(	O
header	struct
.	O
trans_sysdep_tab_offset	int
)	O
;	O
}	O
}	O
fwrite	function
(	O
&	O
header	struct
,	O
header_size	long
,	O
1	int
,	O
output_file	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nstrings	int
;	O
j	long
++	O
)	O
{	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
orig_tab	pointer
[	O
j	long
]	O
.	O
length	int
=	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_ID	int
]	O
.	O
length	int
+	O
msg_arr	pointer
[	O
j	long
]	O
.	O
id_plural_len	long
;	O
orig_tab	pointer
[	O
j	long
]	O
.	O
offset	int
=	O
offset	int
;	O
offset	int
+=	O
orig_tab	pointer
[	O
j	long
]	O
.	O
length	int
;	O
orig_tab	pointer
[	O
j	long
]	O
.	O
length	int
--	O
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nstrings	int
;	O
j	long
++	O
)	O
{	O
BSWAP32	O
(	O
orig_tab	pointer
[	O
j	long
]	O
.	O
length	int
)	O
;	O
BSWAP32	O
(	O
orig_tab	pointer
[	O
j	long
]	O
.	O
offset	int
)	O
;	O
}	O
fwrite	function
(	O
orig_tab	pointer
,	O
nstrings	int
*	O
sizeof	O
(	O
struct	O
string_desc	struct
)	O
,	O
1	int
,	O
output_file	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nstrings	int
;	O
j	long
++	O
)	O
{	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
trans_tab	pointer
[	O
j	long
]	O
.	O
length	int
=	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_STR	int
]	O
.	O
length	int
;	O
trans_tab	pointer
[	O
j	long
]	O
.	O
offset	int
=	O
offset	int
;	O
offset	int
+=	O
trans_tab	pointer
[	O
j	long
]	O
.	O
length	int
;	O
trans_tab	pointer
[	O
j	long
]	O
.	O
length	int
--	O
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nstrings	int
;	O
j	long
++	O
)	O
{	O
BSWAP32	O
(	O
trans_tab	pointer
[	O
j	long
]	O
.	O
length	int
)	O
;	O
BSWAP32	O
(	O
trans_tab	pointer
[	O
j	long
]	O
.	O
offset	int
)	O
;	O
}	O
fwrite	function
(	O
trans_tab	pointer
,	O
nstrings	int
*	O
sizeof	O
(	O
struct	O
string_desc	struct
)	O
,	O
1	int
,	O
output_file	pointer
)	O
;	O
if	O
(	O
!	O
omit_hash_table	bool
)	O
{	O
nls_uint32	int
*	O
hash_tab	pointer
;	O
unsigned	O
int	O
j	long
;	O
hash_tab	pointer
=	O
XNMALLOC	O
(	O
hash_tab_size	int
,	O
nls_uint32	int
)	O
;	O
memset	function
(	O
hash_tab	pointer
,	O
'\0'	O
,	O
hash_tab_size	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nstrings	int
;	O
j	long
++	O
)	O
{	O
nls_uint32	int
hash_val	int
=	O
hash_string	function
(	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_ID	int
]	O
.	O
pointer	pointer
)	O
;	O
nls_uint32	int
idx	int
=	O
hash_val	int
%	O
hash_tab_size	int
;	O
if	O
(	O
hash_tab	pointer
[	O
idx	int
]	O
!=	O
0	int
)	O
{	O
nls_uint32	int
incr	int
=	O
1	int
+	O
(	O
hash_val	int
%	O
(	O
hash_tab_size	int
-	O
2	int
)	O
)	O
;	O
do	O
if	O
(	O
idx	int
>=	O
hash_tab_size	int
-	O
incr	int
)	O
idx	int
-=	O
hash_tab_size	int
-	O
incr	int
;	O
else	O
idx	int
+=	O
incr	int
;	O
while	O
(	O
hash_tab	pointer
[	O
idx	int
]	O
!=	O
0	int
)	O
;	O
}	O
hash_tab	pointer
[	O
idx	int
]	O
=	O
j	long
+	O
1	int
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
hash_tab_size	int
;	O
j	long
++	O
)	O
BSWAP32	O
(	O
hash_tab	pointer
[	O
j	long
]	O
)	O
;	O
fwrite	function
(	O
hash_tab	pointer
,	O
hash_tab_size	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
,	O
1	int
,	O
output_file	pointer
)	O
;	O
free	function
(	O
hash_tab	pointer
)	O
;	O
}	O
if	O
(	O
minor_revision	int
>=	O
1	int
)	O
{	O
struct	O
sysdep_segment	struct
*	O
sysdep_segments_tab	pointer
;	O
nls_uint32	int
*	O
sysdep_tab	pointer
;	O
size_t	long
stoffset	long
;	O
unsigned	O
int	O
i	long
;	O
sysdep_segments_tab	pointer
=	O
XNMALLOC	O
(	O
n_sysdep_segments	int
,	O
struct	O
sysdep_segment	struct
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n_sysdep_segments	int
;	O
i	long
++	O
)	O
{	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
sysdep_segments_tab	pointer
[	O
i	long
]	O
.	O
length	int
=	O
sysdep_segments	pointer
[	O
i	long
]	O
.	O
length	int
+	O
1	int
;	O
sysdep_segments_tab	pointer
[	O
i	long
]	O
.	O
offset	int
=	O
offset	int
;	O
offset	int
+=	O
sysdep_segments_tab	pointer
[	O
i	long
]	O
.	O
length	int
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n_sysdep_segments	int
;	O
i	long
++	O
)	O
{	O
BSWAP32	O
(	O
sysdep_segments_tab	pointer
[	O
i	long
]	O
.	O
length	int
)	O
;	O
BSWAP32	O
(	O
sysdep_segments_tab	pointer
[	O
i	long
]	O
.	O
offset	int
)	O
;	O
}	O
fwrite	function
(	O
sysdep_segments_tab	pointer
,	O
n_sysdep_segments	int
*	O
sizeof	O
(	O
struct	O
sysdep_segment	struct
)	O
,	O
1	int
,	O
output_file	pointer
)	O
;	O
free	function
(	O
sysdep_segments_tab	pointer
)	O
;	O
sysdep_tab	pointer
=	O
XNMALLOC	O
(	O
n_sysdep_strings	int
,	O
nls_uint32	int
)	O
;	O
stoffset	long
=	O
sysdep_tab_offset	long
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
2	int
;	O
m	long
++	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_sysdep_strings	int
;	O
j	long
++	O
)	O
{	O
sysdep_tab	pointer
[	O
j	long
]	O
=	O
stoffset	long
;	O
stoffset	long
+=	O
sizeof	O
(	O
struct	O
sysdep_string	struct
)	O
+	O
sysdep_msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
m	long
]	O
->	O
segmentcount	int
*	O
sizeof	O
(	O
struct	O
segment_pair	struct
)	O
;	O
}	O
if	O
(	O
byteswap	bool
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_sysdep_strings	int
;	O
j	long
++	O
)	O
BSWAP32	O
(	O
sysdep_tab	pointer
[	O
j	long
]	O
)	O
;	O
fwrite	function
(	O
sysdep_tab	pointer
,	O
n_sysdep_strings	int
*	O
sizeof	O
(	O
nls_uint32	int
)	O
,	O
1	int
,	O
output_file	pointer
)	O
;	O
}	O
free	function
(	O
sysdep_tab	pointer
)	O
;	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
2	int
;	O
m	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_sysdep_strings	int
;	O
j	long
++	O
)	O
{	O
struct	O
pre_sysdep_message	struct
*	O
msg	pointer
=	O
&	O
sysdep_msg_arr	pointer
[	O
j	long
]	O
;	O
struct	O
pre_sysdep_string	struct
*	O
pre	pointer
=	O
msg	pointer
->	O
str	array
[	O
m	long
]	O
;	O
struct	O
sysdep_string	struct
*	O
str	array
=	O
(	O
struct	O
sysdep_string	struct
*	O
)	O
xmalloca	O
(	O
sizeof	O
(	O
struct	O
sysdep_string	struct
)	O
+	O
pre	pointer
->	O
segmentcount	int
*	O
sizeof	O
(	O
struct	O
segment_pair	struct
)	O
)	O
;	O
unsigned	O
int	O
i	long
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
str	array
->	O
offset	int
=	O
offset	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
pre	pointer
->	O
segmentcount	int
;	O
i	long
++	O
)	O
{	O
str	array
->	O
segments	array
[	O
i	long
]	O
.	O
segsize	int
=	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
segsize	int
;	O
str	array
->	O
segments	array
[	O
i	long
]	O
.	O
sysdepref	int
=	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
sysdepref	int
;	O
offset	int
+=	O
str	array
->	O
segments	array
[	O
i	long
]	O
.	O
segsize	int
;	O
}	O
if	O
(	O
m	long
==	O
M_ID	int
&&	O
msg	pointer
->	O
id_plural_len	long
>	O
0	int
)	O
{	O
str	array
->	O
segments	array
[	O
pre	pointer
->	O
segmentcount	int
]	O
.	O
segsize	int
+=	O
msg	pointer
->	O
id_plural_len	long
;	O
offset	int
+=	O
msg	pointer
->	O
id_plural_len	long
;	O
}	O
if	O
(	O
byteswap	bool
)	O
{	O
BSWAP32	O
(	O
str	array
->	O
offset	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
pre	pointer
->	O
segmentcount	int
;	O
i	long
++	O
)	O
{	O
BSWAP32	O
(	O
str	array
->	O
segments	array
[	O
i	long
]	O
.	O
segsize	int
)	O
;	O
BSWAP32	O
(	O
str	array
->	O
segments	array
[	O
i	long
]	O
.	O
sysdepref	int
)	O
;	O
}	O
}	O
fwrite	function
(	O
str	array
,	O
sizeof	O
(	O
struct	O
sysdep_string	struct
)	O
+	O
pre	pointer
->	O
segmentcount	int
*	O
sizeof	O
(	O
struct	O
segment_pair	struct
)	O
,	O
1	int
,	O
output_file	pointer
)	O
;	O
freea	function
(	O
str	array
)	O
;	O
}	O
}	O
free	function
(	O
trans_tab	pointer
)	O
;	O
free	function
(	O
orig_tab	pointer
)	O
;	O
offset	int
=	O
end_offset	long
;	O
null	pointer
=	O
(	O
char	O
*	O
)	O
alloca	O
(	O
alignment	long
)	O
;	O
memset	function
(	O
null	pointer
,	O
'\0'	O
,	O
alignment	long
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nstrings	int
;	O
j	long
++	O
)	O
{	O
fwrite	function
(	O
null	pointer
,	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
-	O
offset	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
fwrite	function
(	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_ID	int
]	O
.	O
pointer	pointer
,	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_ID	int
]	O
.	O
length	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
if	O
(	O
msg_arr	pointer
[	O
j	long
]	O
.	O
id_plural_len	long
>	O
0	int
)	O
fwrite	function
(	O
msg_arr	pointer
[	O
j	long
]	O
.	O
id_plural	pointer
,	O
msg_arr	pointer
[	O
j	long
]	O
.	O
id_plural_len	long
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
+=	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_ID	int
]	O
.	O
length	int
+	O
msg_arr	pointer
[	O
j	long
]	O
.	O
id_plural_len	long
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
nstrings	int
;	O
j	long
++	O
)	O
{	O
fwrite	function
(	O
null	pointer
,	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
-	O
offset	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
fwrite	function
(	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_STR	int
]	O
.	O
pointer	pointer
,	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_STR	int
]	O
.	O
length	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
+=	O
msg_arr	pointer
[	O
j	long
]	O
.	O
str	array
[	O
M_STR	int
]	O
.	O
length	int
;	O
}	O
if	O
(	O
minor_revision	int
>=	O
1	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n_sysdep_segments	int
;	O
i	long
++	O
)	O
{	O
fwrite	function
(	O
null	pointer
,	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
-	O
offset	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
fwrite	function
(	O
sysdep_segments	pointer
[	O
i	long
]	O
.	O
pointer	pointer
,	O
sysdep_segments	pointer
[	O
i	long
]	O
.	O
length	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
fwrite	function
(	O
null	pointer
,	O
1	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
+=	O
sysdep_segments	pointer
[	O
i	long
]	O
.	O
length	int
+	O
1	int
;	O
}	O
for	O
(	O
m	long
=	O
0	int
;	O
m	long
<	O
2	int
;	O
m	long
++	O
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n_sysdep_strings	int
;	O
j	long
++	O
)	O
{	O
struct	O
pre_sysdep_message	struct
*	O
msg	pointer
=	O
&	O
sysdep_msg_arr	pointer
[	O
j	long
]	O
;	O
struct	O
pre_sysdep_string	struct
*	O
pre	pointer
=	O
msg	pointer
->	O
str	array
[	O
m	long
]	O
;	O
fwrite	function
(	O
null	pointer
,	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
-	O
offset	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
=	O
roundup	O
(	O
offset	int
,	O
alignment	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
pre	pointer
->	O
segmentcount	int
;	O
i	long
++	O
)	O
{	O
fwrite	function
(	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
segptr	pointer
,	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
segsize	int
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
+=	O
pre	pointer
->	O
segments	array
[	O
i	long
]	O
.	O
segsize	int
;	O
}	O
if	O
(	O
m	long
==	O
M_ID	int
&&	O
msg	pointer
->	O
id_plural_len	long
>	O
0	int
)	O
{	O
fwrite	function
(	O
msg	pointer
->	O
id_plural	pointer
,	O
msg	pointer
->	O
id_plural_len	long
,	O
1	int
,	O
output_file	pointer
)	O
;	O
offset	int
+=	O
msg	pointer
->	O
id_plural_len	long
;	O
}	O
free	function
(	O
pre	pointer
)	O
;	O
}	O
}	O
freea	function
(	O
null	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
free	function
(	O
msgctid_arr	pointer
[	O
j	long
]	O
)	O
;	O
free	function
(	O
sysdep_msg_arr	pointer
)	O
;	O
free	function
(	O
msg_arr	pointer
)	O
;	O
free	function
(	O
msgctid_arr	pointer
)	O
;	O
}	O
int	O
msgdomain_write_mo	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
const	O
char	O
*	O
domain_name	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
FILE	struct
*	O
output_file	pointer
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
!=	O
0	int
)	O
{	O
message_list_delete_header_field	function
(	O
mlp	pointer
,	O
"POT-Creation-Date:"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
domain_name	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
output_file	pointer
=	O
stdout	pointer
;	O
SET_BINARY	O
(	O
fileno	function
(	O
output_file	pointer
)	O
)	O
;	O
}	O
else	O
{	O
output_file	pointer
=	O
fopen	function
(	O
file_name	pointer
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
output_file	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"error while opening \"%s\" for writing"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
output_file	pointer
!=	O
NULL	O
)	O
{	O
write_table	function
(	O
output_file	pointer
,	O
mlp	pointer
)	O
;	O
if	O
(	O
fwriteerror	function
(	O
output_file	pointer
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error while writing \"%s\" file"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
