int	O
tout	int
,	O
tin	int
,	O
net	int
;	O
struct	O
termio	struct
old_tc	struct
=	O
{	O
0	int
}	O
;	O
extern	O
struct	O
termio	struct
new_tc	struct
;	O
static	O
fd_set	struct
ibits	struct
,	O
obits	struct
,	O
xbits	struct
;	O
void	O
init_sys	function
(	O
void	O
)	O
{	O
tout	int
=	O
fileno	function
(	O
stdout	pointer
)	O
;	O
tin	int
=	O
fileno	function
(	O
stdin	pointer
)	O
;	O
FD_ZERO	O
(	O
&	O
ibits	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
obits	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
xbits	struct
)	O
;	O
errno	O
=	O
0	int
;	O
}	O
int	O
TerminalWrite	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
n	int
)	O
{	O
return	O
write	function
(	O
tout	int
,	O
buf	pointer
,	O
n	int
)	O
;	O
}	O
int	O
TerminalRead	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
n	int
)	O
{	O
return	O
read	function
(	O
tin	int
,	O
buf	pointer
,	O
n	int
)	O
;	O
}	O
int	O
TerminalAutoFlush	function
(	O
void	O
)	O
{	O
return	O
1	int
;	O
}	O
extern	O
int	O
kludgelinemode	int
;	O
extern	O
void	O
xmitAO	function
(	O
void	O
)	O
,	O
xmitEL	function
(	O
void	O
)	O
,	O
xmitEC	function
(	O
void	O
)	O
,	O
intp	function
(	O
void	O
)	O
,	O
sendbrk	function
(	O
void	O
)	O
;	O
int	O
TerminalSpecialChars	function
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
termIntChar	O
)	O
{	O
intp	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
termQuitChar	O
)	O
{	O
if	O
(	O
kludgelinemode	int
)	O
sendbrk	function
(	O
)	O
;	O
else	O
sendabort	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
termEofChar	O
)	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
sendeof	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
termSuspChar	O
)	O
{	O
sendsusp	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
termFlushChar	O
)	O
{	O
xmitAO	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
MODE_LOCAL_CHARS	O
(	O
globalmode	int
)	O
)	O
{	O
if	O
(	O
c	int
==	O
termKillChar	O
)	O
{	O
xmitEL	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
termEraseChar	O
)	O
{	O
xmitEC	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
void	O
TerminalFlushOutput	function
(	O
void	O
)	O
{	O
int	O
flags	int
=	O
0	int
;	O
ioctl	function
(	O
fileno	function
(	O
stdout	pointer
)	O
,	O
TCFLSH	int
,	O
&	O
flags	int
)	O
;	O
}	O
void	O
TerminalSaveState	function
(	O
void	O
)	O
{	O
tcgetattr	function
(	O
0	int
,	O
&	O
old_tc	struct
)	O
;	O
new_tc	struct
=	O
old_tc	struct
;	O
termAytChar	char
=	O
CONTROL	O
(	O
'T'	O
)	O
;	O
}	O
cc_t	char
*	O
tcval	function
(	O
register	O
int	O
func	int
)	O
{	O
switch	O
(	O
func	int
)	O
{	O
case	O
SLC_IP	int
:	O
return	O
(	O
&	O
termIntChar	O
)	O
;	O
case	O
SLC_ABORT	int
:	O
return	O
(	O
&	O
termQuitChar	O
)	O
;	O
case	O
SLC_EOF	int
:	O
return	O
(	O
&	O
termEofChar	O
)	O
;	O
case	O
SLC_EC	int
:	O
return	O
(	O
&	O
termEraseChar	O
)	O
;	O
case	O
SLC_EL	int
:	O
return	O
(	O
&	O
termKillChar	O
)	O
;	O
case	O
SLC_XON	int
:	O
return	O
(	O
&	O
termStartChar	O
)	O
;	O
case	O
SLC_XOFF	int
:	O
return	O
(	O
&	O
termStopChar	O
)	O
;	O
case	O
SLC_FORW1	int
:	O
return	O
(	O
&	O
termForw1Char	O
)	O
;	O
case	O
SLC_FORW2	int
:	O
return	O
(	O
&	O
termForw2Char	O
)	O
;	O
case	O
SLC_AO	int
:	O
return	O
(	O
&	O
termFlushChar	O
)	O
;	O
case	O
SLC_SUSP	int
:	O
return	O
(	O
&	O
termSuspChar	O
)	O
;	O
case	O
SLC_EW	int
:	O
return	O
(	O
&	O
termWerasChar	O
)	O
;	O
case	O
SLC_RP	int
:	O
return	O
(	O
&	O
termRprntChar	O
)	O
;	O
case	O
SLC_LNEXT	int
:	O
return	O
(	O
&	O
termLiteralNextChar	O
)	O
;	O
case	O
SLC_SYNCH	int
:	O
case	O
SLC_BRK	int
:	O
case	O
SLC_EOR	int
:	O
default	O
:	O
return	O
(	O
(	O
cc_t	char
*	O
)	O
0	int
)	O
;	O
}	O
}	O
void	O
TerminalDefaultChars	function
(	O
void	O
)	O
{	O
memmove	function
(	O
new_tc	struct
.	O
c_cc	array
,	O
old_tc	struct
.	O
c_cc	array
,	O
sizeof	O
(	O
old_tc	struct
.	O
c_cc	array
)	O
)	O
;	O
termAytChar	char
=	O
CONTROL	O
(	O
'T'	O
)	O
;	O
}	O
void	O
TerminalNewMode	function
(	O
register	O
int	O
f	int
)	O
{	O
static	O
int	O
prevmode	int
=	O
0	int
;	O
struct	O
termio	struct
tmp_tc	struct
;	O
int	O
onoff	int
;	O
int	O
old	int
;	O
cc_t	char
esc	char
;	O
globalmode	int
=	O
f	int
&	O
~	O
MODE_FORCE	int
;	O
if	O
(	O
prevmode	int
==	O
f	int
)	O
return	O
;	O
old	int
=	O
ttyflush	function
(	O
SYNCHing	int
|	O
flushout	int
)	O
;	O
if	O
(	O
old	int
<	O
0	int
||	O
old	int
>	O
1	int
)	O
{	O
tcgetattr	function
(	O
tin	int
,	O
&	O
tmp_tc	struct
)	O
;	O
do	O
{	O
tcsetattr	function
(	O
tin	int
,	O
TCSADRAIN	int
,	O
&	O
tmp_tc	struct
)	O
;	O
old	int
=	O
ttyflush	function
(	O
SYNCHing	int
|	O
flushout	int
)	O
;	O
}	O
while	O
(	O
old	int
<	O
0	int
||	O
old	int
>	O
1	int
)	O
;	O
}	O
old	int
=	O
prevmode	int
;	O
prevmode	int
=	O
f	int
&	O
~	O
MODE_FORCE	int
;	O
tmp_tc	struct
=	O
new_tc	struct
;	O
if	O
(	O
f	int
&	O
MODE_ECHO	int
)	O
{	O
tmp_tc	struct
.	O
c_lflag	short
|=	O
ECHO	int
;	O
tmp_tc	struct
.	O
c_oflag	short
|=	O
ONLCR	int
;	O
if	O
(	O
crlf	int
)	O
tmp_tc	struct
.	O
c_iflag	short
|=	O
ICRNL	int
;	O
}	O
else	O
{	O
tmp_tc	struct
.	O
c_lflag	short
&=	O
~	O
ECHO	int
;	O
tmp_tc	struct
.	O
c_oflag	short
&=	O
~	O
ONLCR	int
;	O
}	O
if	O
(	O
(	O
f	int
&	O
MODE_FLOW	int
)	O
==	O
0	int
)	O
{	O
tmp_tc	struct
.	O
c_iflag	short
&=	O
~	O
(	O
IXOFF	int
|	O
IXON	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
restartany	int
<	O
0	int
)	O
{	O
tmp_tc	struct
.	O
c_iflag	short
|=	O
IXOFF	int
|	O
IXON	int
;	O
}	O
else	O
if	O
(	O
restartany	int
>	O
0	int
)	O
{	O
tmp_tc	struct
.	O
c_iflag	short
|=	O
IXOFF	int
|	O
IXON	int
|	O
IXANY	int
;	O
}	O
else	O
{	O
tmp_tc	struct
.	O
c_iflag	short
|=	O
IXOFF	int
|	O
IXON	int
;	O
tmp_tc	struct
.	O
c_iflag	short
&=	O
~	O
IXANY	int
;	O
}	O
}	O
if	O
(	O
(	O
f	int
&	O
MODE_TRAPSIG	int
)	O
==	O
0	int
)	O
{	O
tmp_tc	struct
.	O
c_lflag	short
&=	O
~	O
ISIG	int
;	O
localchars	int
=	O
0	int
;	O
}	O
else	O
{	O
tmp_tc	struct
.	O
c_lflag	short
|=	O
ISIG	int
;	O
localchars	int
=	O
1	int
;	O
}	O
if	O
(	O
f	int
&	O
MODE_EDIT	int
)	O
{	O
tmp_tc	struct
.	O
c_lflag	short
|=	O
ICANON	int
;	O
}	O
else	O
{	O
tmp_tc	struct
.	O
c_lflag	short
&=	O
~	O
ICANON	int
;	O
tmp_tc	struct
.	O
c_iflag	short
&=	O
~	O
ICRNL	int
;	O
tmp_tc	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
tmp_tc	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
(	O
f	int
&	O
(	O
MODE_EDIT	int
|	O
MODE_TRAPSIG	int
)	O
)	O
==	O
0	int
)	O
{	O
tmp_tc	struct
.	O
c_cc	array
[	O
VLNEXT	int
]	O
=	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
;	O
}	O
if	O
(	O
f	int
&	O
MODE_SOFT_TAB	int
)	O
{	O
tmp_tc	struct
.	O
c_oflag	short
&=	O
~	O
TABDLY	int
;	O
tmp_tc	struct
.	O
c_oflag	short
|=	O
TAB3	int
;	O
}	O
else	O
{	O
tmp_tc	struct
.	O
c_oflag	short
&=	O
~	O
TABDLY	int
;	O
}	O
if	O
(	O
f	int
&	O
MODE_LIT_ECHO	int
)	O
{	O
tmp_tc	struct
.	O
c_lflag	short
&=	O
~	O
ECHOCTL	int
;	O
}	O
else	O
{	O
tmp_tc	struct
.	O
c_lflag	short
|=	O
ECHOCTL	int
;	O
}	O
if	O
(	O
f	int
==	O
-	O
1	int
)	O
{	O
onoff	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
f	int
&	O
MODE_INBIN	int
)	O
tmp_tc	struct
.	O
c_iflag	short
&=	O
~	O
ISTRIP	int
;	O
if	O
(	O
f	int
&	O
MODE_OUTBIN	int
)	O
{	O
tmp_tc	struct
.	O
c_cflag	short
&=	O
~	O
(	O
CSIZE	int
|	O
PARENB	int
)	O
;	O
tmp_tc	struct
.	O
c_cflag	short
|=	O
CS8	int
;	O
tmp_tc	struct
.	O
c_oflag	short
&=	O
~	O
OPOST	int
;	O
}	O
else	O
{	O
tmp_tc	struct
.	O
c_cflag	short
&=	O
~	O
(	O
CSIZE	int
|	O
PARENB	int
)	O
;	O
tmp_tc	struct
.	O
c_cflag	short
|=	O
old_tc	struct
.	O
c_cflag	short
&	O
(	O
CSIZE	int
|	O
PARENB	int
)	O
;	O
tmp_tc	struct
.	O
c_oflag	short
|=	O
OPOST	int
;	O
}	O
onoff	int
=	O
1	int
;	O
}	O
if	O
(	O
f	int
!=	O
-	O
1	int
)	O
{	O
void	O
susp	function
(	O
int	O
sig	int
)	O
;	O
signal	function
(	O
SIGTSTP	int
,	O
susp	function
)	O
;	O
esc	char
=	O
(	O
rlogin	char
!=	O
_POSIX_VDISABLE	char
)	O
?	O
rlogin	char
:	O
escape	char
;	O
if	O
(	O
(	O
tmp_tc	struct
.	O
c_cc	array
[	O
VEOL	int
]	O
!=	O
esc	char
)	O
&&	O
(	O
tmp_tc	struct
.	O
c_cc	array
[	O
VEOL2	int
]	O
!=	O
esc	char
)	O
)	O
{	O
if	O
(	O
tmp_tc	struct
.	O
c_cc	array
[	O
VEOL	int
]	O
==	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
tmp_tc	struct
.	O
c_cc	array
[	O
VEOL	int
]	O
=	O
esc	char
;	O
else	O
if	O
(	O
tmp_tc	struct
.	O
c_cc	array
[	O
VEOL2	int
]	O
==	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
tmp_tc	struct
.	O
c_cc	array
[	O
VEOL2	int
]	O
=	O
esc	char
;	O
}	O
}	O
else	O
{	O
signal	function
(	O
SIGTSTP	int
,	O
SIG_DFL	O
)	O
;	O
{	O
sigset_t	struct
sigs	struct
;	O
sigemptyset	function
(	O
&	O
sigs	struct
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGTSTP	int
)	O
;	O
sigprocmask	function
(	O
SIG_UNBLOCK	int
,	O
&	O
sigs	struct
,	O
0	int
)	O
;	O
}	O
tmp_tc	struct
=	O
old_tc	struct
;	O
}	O
if	O
(	O
tcsetattr	function
(	O
tin	int
,	O
TCSADRAIN	int
,	O
&	O
tmp_tc	struct
)	O
<	O
0	int
)	O
tcsetattr	function
(	O
tin	int
,	O
TCSANOW	int
,	O
&	O
tmp_tc	struct
)	O
;	O
ioctl	function
(	O
tin	int
,	O
FIONBIO	int
,	O
(	O
char	O
*	O
)	O
&	O
onoff	int
)	O
;	O
ioctl	function
(	O
tout	int
,	O
FIONBIO	int
,	O
(	O
char	O
*	O
)	O
&	O
onoff	int
)	O
;	O
}	O
struct	O
termspeeds	struct
{	O
long	O
speed	long
;	O
long	O
value	long
;	O
}	O
termspeeds	struct
[	O
]	O
=	O
{	O
{	O
0	int
,	O
B0	int
}	O
,	O
{	O
50	int
,	O
B50	int
}	O
,	O
{	O
75	int
,	O
B75	int
}	O
,	O
{	O
110	int
,	O
B110	int
}	O
,	O
{	O
134	int
,	O
B134	int
}	O
,	O
{	O
150	int
,	O
B150	int
}	O
,	O
{	O
200	int
,	O
B200	int
}	O
,	O
{	O
300	int
,	O
B300	int
}	O
,	O
{	O
600	int
,	O
B600	int
}	O
,	O
{	O
1200	int
,	O
B1200	int
}	O
,	O
{	O
1800	int
,	O
B1800	int
}	O
,	O
{	O
2400	int
,	O
B2400	int
}	O
,	O
{	O
4800	int
,	O
B4800	int
}	O
,	O
{	O
7200	int
,	O
B7200	O
}	O
,	O
{	O
9600	int
,	O
B9600	int
}	O
,	O
{	O
14400	int
,	O
B14400	O
}	O
,	O
{	O
19200	int
,	O
B19200	int
}	O
,	O
{	O
28800	int
,	O
B28800	O
}	O
,	O
{	O
38400	int
,	O
B38400	int
}	O
,	O
{	O
57600	int
,	O
B57600	int
}	O
,	O
{	O
115200	int
,	O
B115200	int
}	O
,	O
{	O
230400	int
,	O
B230400	int
}	O
,	O
{	O
-	O
1	int
,	O
B230400	int
}	O
}	O
;	O
void	O
TerminalSpeeds	function
(	O
long	O
*	O
ispeed	pointer
,	O
long	O
*	O
ospeed	pointer
)	O
{	O
register	O
struct	O
termspeeds	struct
*	O
tp	pointer
;	O
register	O
long	O
in	long
,	O
out	long
;	O
out	long
=	O
cfgetospeed	function
(	O
&	O
old_tc	struct
)	O
;	O
in	long
=	O
cfgetispeed	function
(	O
&	O
old_tc	struct
)	O
;	O
if	O
(	O
in	long
==	O
0	int
)	O
in	long
=	O
out	long
;	O
tp	pointer
=	O
termspeeds	struct
;	O
while	O
(	O
(	O
tp	pointer
->	O
speed	long
!=	O
-	O
1	int
)	O
&&	O
(	O
tp	pointer
->	O
value	long
<	O
in	long
)	O
)	O
tp	pointer
++	O
;	O
*	O
ispeed	pointer
=	O
tp	pointer
->	O
speed	long
;	O
tp	pointer
=	O
termspeeds	struct
;	O
while	O
(	O
(	O
tp	pointer
->	O
speed	long
!=	O
-	O
1	int
)	O
&&	O
(	O
tp	pointer
->	O
value	long
<	O
out	long
)	O
)	O
tp	pointer
++	O
;	O
*	O
ospeed	pointer
=	O
tp	pointer
->	O
speed	long
;	O
}	O
int	O
TerminalWindowSize	function
(	O
long	O
*	O
rows	pointer
,	O
long	O
*	O
cols	pointer
)	O
{	O
struct	O
winsize	struct
ws	struct
;	O
if	O
(	O
ioctl	function
(	O
fileno	function
(	O
stdin	pointer
)	O
,	O
TIOCGWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
ws	struct
)	O
>=	O
0	int
)	O
{	O
*	O
rows	pointer
=	O
ws	struct
.	O
ws_row	short
;	O
*	O
cols	pointer
=	O
ws	struct
.	O
ws_col	short
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
NetClose	function
(	O
int	O
fd	int
)	O
{	O
return	O
close	function
(	O
fd	int
)	O
;	O
}	O
void	O
NetNonblockingIO	function
(	O
int	O
fd	int
,	O
int	O
onoff	int
)	O
{	O
ioctl	function
(	O
fd	int
,	O
FIONBIO	int
,	O
(	O
char	O
*	O
)	O
&	O
onoff	int
)	O
;	O
}	O
void	O
deadpeer	function
(	O
int	O
sig	int
)	O
{	O
setcommandmode	function
(	O
)	O
;	O
longjmp	function
(	O
peerdied	array
,	O
-	O
1	int
)	O
;	O
}	O
void	O
intr	function
(	O
int	O
sig	int
)	O
{	O
if	O
(	O
localchars	int
)	O
{	O
intp	function
(	O
)	O
;	O
return	O
;	O
}	O
setcommandmode	function
(	O
)	O
;	O
longjmp	function
(	O
toplevel	array
,	O
-	O
1	int
)	O
;	O
}	O
void	O
intr2	function
(	O
int	O
sig	int
)	O
{	O
if	O
(	O
localchars	int
)	O
{	O
if	O
(	O
kludgelinemode	int
)	O
sendbrk	function
(	O
)	O
;	O
else	O
sendabort	function
(	O
)	O
;	O
return	O
;	O
}	O
}	O
void	O
susp	function
(	O
int	O
sig	int
)	O
{	O
if	O
(	O
(	O
rlogin	char
!=	O
_POSIX_VDISABLE	char
)	O
&&	O
rlogin_susp	function
(	O
)	O
)	O
return	O
;	O
if	O
(	O
localchars	int
)	O
sendsusp	function
(	O
)	O
;	O
}	O
void	O
sendwin	function
(	O
int	O
sig	int
)	O
{	O
if	O
(	O
connected	int
)	O
{	O
sendnaws	function
(	O
)	O
;	O
}	O
}	O
void	O
sys_telnet_init	function
(	O
void	O
)	O
{	O
signal	function
(	O
SIGINT	int
,	O
intr	function
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
intr2	function
)	O
;	O
signal	function
(	O
SIGPIPE	int
,	O
deadpeer	function
)	O
;	O
signal	function
(	O
SIGWINCH	int
,	O
sendwin	function
)	O
;	O
signal	function
(	O
SIGTSTP	int
,	O
susp	function
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
NetNonblockingIO	function
(	O
net	int
,	O
1	int
)	O
;	O
if	O
(	O
SetSockOpt	function
(	O
net	int
,	O
SOL_SOCKET	int
,	O
SO_OOBINLINE	int
,	O
1	int
)	O
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"SetSockOpt"	pointer
)	O
;	O
}	O
}	O
int	O
process_rings	function
(	O
int	O
netin	int
,	O
int	O
netout	int
,	O
int	O
netex	int
,	O
int	O
ttyin	int
,	O
int	O
ttyout	int
,	O
int	O
poll	int
)	O
{	O
register	O
int	O
c	int
;	O
int	O
returnValue	int
=	O
0	int
;	O
static	O
struct	O
timeval	struct
TimeValue	struct
=	O
{	O
0	int
}	O
;	O
int	O
nfds	int
=	O
0	int
;	O
if	O
(	O
netout	int
)	O
{	O
FD_SET	O
(	O
net	int
,	O
&	O
obits	struct
)	O
;	O
if	O
(	O
net	int
>	O
nfds	int
)	O
nfds	int
=	O
net	int
;	O
}	O
if	O
(	O
ttyout	int
)	O
{	O
FD_SET	O
(	O
tout	int
,	O
&	O
obits	struct
)	O
;	O
if	O
(	O
tout	int
>	O
nfds	int
)	O
nfds	int
=	O
tout	int
;	O
}	O
if	O
(	O
ttyin	int
)	O
{	O
FD_SET	O
(	O
tin	int
,	O
&	O
ibits	struct
)	O
;	O
if	O
(	O
tin	int
>	O
nfds	int
)	O
nfds	int
=	O
tin	int
;	O
}	O
if	O
(	O
netin	int
)	O
{	O
FD_SET	O
(	O
net	int
,	O
&	O
ibits	struct
)	O
;	O
if	O
(	O
net	int
>	O
nfds	int
)	O
nfds	int
=	O
net	int
;	O
}	O
if	O
(	O
netex	int
)	O
{	O
FD_SET	O
(	O
net	int
,	O
&	O
xbits	struct
)	O
;	O
if	O
(	O
net	int
>	O
nfds	int
)	O
nfds	int
=	O
net	int
;	O
}	O
if	O
(	O
(	O
c	int
=	O
select	function
(	O
nfds	int
+	O
1	int
,	O
&	O
ibits	struct
,	O
&	O
obits	struct
,	O
&	O
xbits	struct
,	O
(	O
poll	int
==	O
0	int
)	O
?	O
(	O
struct	O
timeval	struct
*	O
)	O
0	int
:	O
&	O
TimeValue	struct
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
{	O
return	O
0	int
;	O
}	O
printf	function
(	O
"sleep(5) from telnet, after select\r\n"	pointer
)	O
;	O
sleep	function
(	O
5	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
xbits	struct
)	O
)	O
{	O
FD_CLR	O
(	O
net	int
,	O
&	O
xbits	struct
)	O
;	O
SYNCHing	int
=	O
1	int
;	O
ttyflush	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
ibits	struct
)	O
)	O
{	O
int	O
canread	int
;	O
FD_CLR	O
(	O
net	int
,	O
&	O
ibits	struct
)	O
;	O
canread	int
=	O
ring_empty_consecutive	function
(	O
&	O
netiring	struct
)	O
;	O
c	int
=	O
recv	function
(	O
net	int
,	O
(	O
char	O
*	O
)	O
netiring	struct
.	O
supply	pointer
,	O
canread	int
,	O
0	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
&&	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
c	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
<=	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
netdata	int
)	O
{	O
Dump	function
(	O
'<'	O
,	O
netiring	struct
.	O
supply	pointer
,	O
c	int
)	O
;	O
}	O
if	O
(	O
c	int
)	O
ring_supplied	function
(	O
&	O
netiring	struct
,	O
c	int
)	O
;	O
returnValue	int
=	O
1	int
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
tin	int
,	O
&	O
ibits	struct
)	O
)	O
{	O
FD_CLR	O
(	O
tin	int
,	O
&	O
ibits	struct
)	O
;	O
c	int
=	O
TerminalRead	function
(	O
(	O
char	O
*	O
)	O
ttyiring	struct
.	O
supply	pointer
,	O
ring_empty_consecutive	function
(	O
&	O
ttyiring	struct
)	O
)	O
;	O
if	O
(	O
c	int
<	O
0	int
&&	O
errno	O
==	O
EIO	int
)	O
c	int
=	O
0	int
;	O
if	O
(	O
c	int
<	O
0	int
&&	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
c	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
c	int
==	O
0	int
)	O
&&	O
MODE_LOCAL_CHARS	O
(	O
globalmode	int
)	O
&&	O
isatty	function
(	O
tin	int
)	O
)	O
{	O
*	O
ttyiring	struct
.	O
supply	pointer
=	O
termEofChar	O
;	O
c	int
=	O
1	int
;	O
}	O
if	O
(	O
c	int
<=	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
termdata	int
)	O
{	O
Dump	function
(	O
'<'	O
,	O
ttyiring	struct
.	O
supply	pointer
,	O
c	int
)	O
;	O
}	O
ring_supplied	function
(	O
&	O
ttyiring	struct
,	O
c	int
)	O
;	O
}	O
returnValue	int
=	O
1	int
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
net	int
,	O
&	O
obits	struct
)	O
)	O
{	O
FD_CLR	O
(	O
net	int
,	O
&	O
obits	struct
)	O
;	O
returnValue	int
|=	O
netflush	function
(	O
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
tout	int
,	O
&	O
obits	struct
)	O
)	O
{	O
FD_CLR	O
(	O
tout	int
,	O
&	O
obits	struct
)	O
;	O
returnValue	int
|=	O
(	O
ttyflush	function
(	O
SYNCHing	int
|	O
flushout	int
)	O
>	O
0	int
)	O
;	O
}	O
return	O
returnValue	int
;	O
}	O
