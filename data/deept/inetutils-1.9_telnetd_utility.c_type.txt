static	O
char	O
netobuf	array
[	O
BUFSIZ	int
+	O
NETSLOP	int
]	O
,	O
*	O
nfrontp	pointer
,	O
*	O
nbackp	pointer
;	O
static	O
char	O
*	O
neturg	pointer
;	O
static	O
char	O
ptyobuf	array
[	O
BUFSIZ	int
+	O
NETSLOP	int
]	O
,	O
*	O
pfrontp	pointer
,	O
*	O
pbackp	pointer
;	O
static	O
char	O
netibuf	array
[	O
BUFSIZ	int
]	O
,	O
*	O
netip	pointer
;	O
static	O
int	O
ncc	int
;	O
static	O
char	O
ptyibuf	array
[	O
BUFSIZ	int
]	O
,	O
*	O
ptyip	pointer
;	O
static	O
int	O
pcc	int
;	O
int	O
not42	int
;	O
static	O
int	O
readstream	function
(	O
int	O
p	pointer
,	O
char	O
*	O
ibuf	pointer
,	O
int	O
bufsize	int
)	O
{	O
return	O
read	pointer
(	O
p	pointer
,	O
ibuf	pointer
,	O
bufsize	int
)	O
;	O
}	O
void	O
io_setup	function
(	O
void	O
)	O
{	O
pfrontp	pointer
=	O
pbackp	pointer
=	O
ptyobuf	array
;	O
nfrontp	pointer
=	O
nbackp	pointer
=	O
netobuf	array
;	O
netip	pointer
=	O
netibuf	array
;	O
ptyip	pointer
=	O
ptyibuf	array
;	O
}	O
void	O
set_neturg	function
(	O
void	O
)	O
{	O
neturg	pointer
=	O
nfrontp	pointer
-	O
1	int
;	O
}	O
void	O
net_output_byte	function
(	O
int	O
c	int
)	O
{	O
*	O
nfrontp	pointer
++	O
=	O
c	int
;	O
}	O
int	O
net_output_data	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
size_t	long
remaining	long
,	O
ret	long
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
remaining	long
=	O
BUFSIZ	int
-	O
(	O
nfrontp	pointer
-	O
netobuf	array
)	O
;	O
if	O
(	O
strlen	function
(	O
format	pointer
)	O
>	O
remaining	long
||	O
BUFSIZ	int
/	O
4	int
>	O
remaining	long
)	O
{	O
netflush	function
(	O
)	O
;	O
remaining	long
=	O
BUFSIZ	int
-	O
(	O
nfrontp	pointer
-	O
netobuf	array
)	O
;	O
}	O
ret	long
=	O
vsnprintf	function
(	O
nfrontp	pointer
,	O
remaining	long
,	O
format	pointer
,	O
args	array
)	O
;	O
nfrontp	pointer
+=	O
(	O
(	O
ret	long
<	O
remaining	long
-	O
1	int
)	O
?	O
ret	long
:	O
remaining	long
-	O
1	int
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
ret	long
;	O
}	O
int	O
net_output_datalen	function
(	O
const	O
void	O
*	O
buf	pointer
,	O
size_t	long
l	long
)	O
{	O
size_t	long
remaining	long
;	O
remaining	long
=	O
BUFSIZ	int
-	O
(	O
nfrontp	pointer
-	O
netobuf	array
)	O
;	O
if	O
(	O
remaining	long
<	O
l	long
)	O
{	O
netflush	function
(	O
)	O
;	O
remaining	long
=	O
BUFSIZ	int
-	O
(	O
nfrontp	pointer
-	O
netobuf	array
)	O
;	O
}	O
if	O
(	O
remaining	long
<	O
l	long
)	O
return	O
-	O
1	int
;	O
memmove	function
(	O
nfrontp	pointer
,	O
buf	pointer
,	O
l	long
)	O
;	O
nfrontp	pointer
+=	O
l	long
;	O
return	O
(	O
int	O
)	O
l	long
;	O
}	O
int	O
net_input_level	function
(	O
void	O
)	O
{	O
return	O
ncc	int
;	O
}	O
int	O
net_output_level	function
(	O
void	O
)	O
{	O
return	O
nfrontp	pointer
-	O
nbackp	pointer
;	O
}	O
int	O
net_buffer_is_full	function
(	O
void	O
)	O
{	O
return	O
(	O
&	O
netobuf	array
[	O
BUFSIZ	int
]	O
-	O
nfrontp	pointer
)	O
<	O
2	int
;	O
}	O
int	O
net_get_char	function
(	O
int	O
peek	int
)	O
{	O
if	O
(	O
peek	int
)	O
return	O
*	O
netip	pointer
;	O
else	O
if	O
(	O
ncc	int
>	O
0	int
)	O
{	O
ncc	int
--	O
;	O
return	O
*	O
netip	pointer
++	O
&	O
0377	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
net_read	function
(	O
void	O
)	O
{	O
ncc	int
=	O
read	pointer
(	O
net	int
,	O
netibuf	array
,	O
sizeof	O
(	O
netibuf	array
)	O
)	O
;	O
if	O
(	O
ncc	int
<	O
0	int
&&	O
errno	O
==	O
EWOULDBLOCK	O
)	O
ncc	int
=	O
0	int
;	O
else	O
if	O
(	O
ncc	int
==	O
0	int
)	O
{	O
syslog	function
(	O
LOG_INFO	int
,	O
"telnetd:  peer died"	pointer
)	O
;	O
cleanup	pointer
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
ncc	int
>	O
0	int
)	O
{	O
netip	pointer
=	O
netibuf	array
;	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	function
(	O
"td: netread %d chars\r\n"	pointer
,	O
ncc	int
)	O
)	O
;	O
DEBUG	O
(	O
debug_net_data	int
,	O
1	int
,	O
printdata	function
(	O
"nd"	pointer
,	O
netip	pointer
,	O
ncc	int
)	O
)	O
;	O
}	O
return	O
ncc	int
;	O
}	O
int	O
pty_buffer_is_full	function
(	O
void	O
)	O
{	O
return	O
(	O
&	O
ptyobuf	array
[	O
BUFSIZ	int
]	O
-	O
pfrontp	pointer
)	O
<	O
2	int
;	O
}	O
void	O
pty_output_byte	function
(	O
int	O
c	int
)	O
{	O
*	O
pfrontp	pointer
++	O
=	O
c	int
;	O
}	O
void	O
pty_output_datalen	function
(	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
(	O
&	O
ptyobuf	array
[	O
BUFSIZ	int
]	O
-	O
pfrontp	pointer
)	O
>	O
len	long
)	O
ptyflush	function
(	O
)	O
;	O
memcpy	function
(	O
pfrontp	pointer
,	O
data	pointer
,	O
len	long
)	O
;	O
pfrontp	pointer
+=	O
len	long
;	O
}	O
int	O
pty_input_level	function
(	O
void	O
)	O
{	O
return	O
pcc	int
;	O
}	O
int	O
pty_output_level	function
(	O
void	O
)	O
{	O
return	O
pfrontp	pointer
-	O
pbackp	pointer
;	O
}	O
void	O
ptyflush	function
(	O
void	O
)	O
{	O
int	O
n	long
;	O
if	O
(	O
(	O
n	long
=	O
pfrontp	pointer
-	O
pbackp	pointer
)	O
>	O
0	int
)	O
{	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	function
(	O
"td: ptyflush %d chars\r\n"	pointer
,	O
n	long
)	O
)	O
;	O
DEBUG	O
(	O
debug_pty_data	int
,	O
1	int
,	O
printdata	function
(	O
"pd"	pointer
,	O
pbackp	pointer
,	O
n	long
)	O
)	O
;	O
n	long
=	O
write	pointer
(	O
pty	int
,	O
pbackp	pointer
,	O
n	long
)	O
;	O
}	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
||	O
errno	O
==	O
EINTR	int
)	O
return	O
;	O
cleanup	pointer
(	O
0	int
)	O
;	O
}	O
pbackp	pointer
+=	O
n	long
;	O
if	O
(	O
pbackp	pointer
==	O
pfrontp	pointer
)	O
pbackp	pointer
=	O
pfrontp	pointer
=	O
ptyobuf	array
;	O
}	O
int	O
pty_get_char	function
(	O
int	O
peek	int
)	O
{	O
if	O
(	O
peek	int
)	O
return	O
*	O
ptyip	pointer
;	O
else	O
if	O
(	O
pcc	int
>	O
0	int
)	O
{	O
pcc	int
--	O
;	O
return	O
*	O
ptyip	pointer
++	O
&	O
0377	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
pty_input_putback	function
(	O
const	O
char	O
*	O
str	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
len	long
>	O
&	O
ptyibuf	array
[	O
BUFSIZ	int
]	O
-	O
ptyip	pointer
)	O
len	long
=	O
&	O
ptyibuf	array
[	O
BUFSIZ	int
]	O
-	O
ptyip	pointer
;	O
strncpy	function
(	O
ptyip	pointer
,	O
str	pointer
,	O
len	long
)	O
;	O
pcc	int
+=	O
len	long
;	O
return	O
0	int
;	O
}	O
int	O
pty_read	function
(	O
void	O
)	O
{	O
pcc	int
=	O
readstream	function
(	O
pty	int
,	O
ptyibuf	array
,	O
BUFSIZ	int
)	O
;	O
if	O
(	O
pcc	int
<	O
0	int
&&	O
(	O
errno	O
==	O
EWOULDBLOCK	O
||	O
errno	O
==	O
EAGAIN	int
||	O
errno	O
==	O
EIO	int
)	O
)	O
pcc	int
=	O
0	int
;	O
ptyip	pointer
=	O
ptyibuf	array
;	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	function
(	O
"ptyread %d chars\r\n"	pointer
,	O
pcc	int
)	O
)	O
;	O
DEBUG	O
(	O
debug_pty_data	int
,	O
1	int
,	O
printdata	function
(	O
"pty"	pointer
,	O
ptyip	pointer
,	O
pcc	int
)	O
)	O
;	O
return	O
pcc	int
;	O
}	O
void	O
io_drain	function
(	O
void	O
)	O
{	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	function
(	O
"td: ttloop\r\n"	pointer
)	O
)	O
;	O
if	O
(	O
nfrontp	pointer
-	O
nbackp	pointer
>	O
0	int
)	O
netflush	function
(	O
)	O
;	O
again	O
:	O
ncc	int
=	O
read	pointer
(	O
net	int
,	O
netibuf	array
,	O
sizeof	O
netibuf	array
)	O
;	O
if	O
(	O
ncc	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EAGAIN	int
)	O
{	O
syslog	function
(	O
LOG_INFO	int
,	O
"ttloop: retrying"	pointer
)	O
;	O
goto	O
again	O
;	O
}	O
syslog	function
(	O
LOG_INFO	int
,	O
"ttloop:  read: %m\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
if	O
(	O
ncc	int
==	O
0	int
)	O
{	O
syslog	function
(	O
LOG_INFO	int
,	O
"ttloop:  peer died: %m\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	function
(	O
"td: ttloop read %d chars\r\n"	pointer
,	O
ncc	int
)	O
)	O
;	O
netip	pointer
=	O
netibuf	array
;	O
telrcv	function
(	O
)	O
;	O
if	O
(	O
ncc	int
>	O
0	int
)	O
{	O
pfrontp	pointer
=	O
pbackp	pointer
=	O
ptyobuf	array
;	O
telrcv	function
(	O
)	O
;	O
}	O
}	O
int	O
stilloob	function
(	O
int	O
s	long
)	O
{	O
static	O
struct	O
timeval	struct
timeout	struct
=	O
{	O
0	int
}	O
;	O
fd_set	struct
excepts	struct
;	O
int	O
value	int
;	O
do	O
{	O
FD_ZERO	O
(	O
&	O
excepts	struct
)	O
;	O
FD_SET	O
(	O
s	long
,	O
&	O
excepts	struct
)	O
;	O
value	int
=	O
select	function
(	O
s	long
+	O
1	int
,	O
(	O
fd_set	struct
*	O
)	O
0	int
,	O
(	O
fd_set	struct
*	O
)	O
0	int
,	O
&	O
excepts	struct
,	O
&	O
timeout	struct
)	O
;	O
}	O
while	O
(	O
value	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
value	int
<	O
0	int
)	O
fatalperror	function
(	O
pty	int
,	O
"select"	pointer
)	O
;	O
return	O
FD_ISSET	O
(	O
s	long
,	O
&	O
excepts	struct
)	O
;	O
}	O
char	O
*	O
nextitem	function
(	O
char	O
*	O
current	struct
)	O
{	O
if	O
(	O
(	O
*	O
current	struct
&	O
0xff	int
)	O
!=	O
IAC	int
)	O
return	O
current	struct
+	O
1	int
;	O
switch	O
(	O
*	O
(	O
current	struct
+	O
1	int
)	O
&	O
0xff	int
)	O
{	O
case	O
DO	int
:	O
case	O
DONT	int
:	O
case	O
WILL	int
:	O
case	O
WONT	int
:	O
return	O
current	struct
+	O
3	int
;	O
case	O
SB	int
:	O
{	O
register	O
char	O
*	O
look	pointer
=	O
current	struct
+	O
2	int
;	O
for	O
(	O
;	O
;	O
)	O
if	O
(	O
(	O
*	O
look	pointer
++	O
&	O
0xff	int
)	O
==	O
IAC	int
&&	O
(	O
*	O
look	pointer
++	O
&	O
0xff	int
)	O
==	O
SE	int
)	O
return	O
look	pointer
;	O
default	O
:	O
return	O
current	struct
+	O
2	int
;	O
}	O
}	O
}	O
void	O
netclear	function
(	O
void	O
)	O
{	O
register	O
char	O
*	O
thisitem	pointer
,	O
*	O
next	pointer
;	O
char	O
*	O
good	pointer
;	O
thisitem	pointer
=	O
netobuf	array
;	O
while	O
(	O
(	O
next	pointer
=	O
nextitem	function
(	O
thisitem	pointer
)	O
)	O
<=	O
nbackp	pointer
)	O
thisitem	pointer
=	O
next	pointer
;	O
good	pointer
=	O
netobuf	array
;	O
while	O
(	O
nfrontp	pointer
>	O
thisitem	pointer
)	O
{	O
if	O
(	O
wewant	O
(	O
thisitem	pointer
)	O
)	O
{	O
int	O
length	int
;	O
for	O
(	O
next	pointer
=	O
thisitem	pointer
;	O
wewant	O
(	O
next	pointer
)	O
&&	O
nfrontp	pointer
>	O
next	pointer
;	O
next	pointer
=	O
nextitem	function
(	O
next	pointer
)	O
)	O
;	O
length	int
=	O
next	pointer
-	O
thisitem	pointer
;	O
memmove	function
(	O
good	pointer
,	O
thisitem	pointer
,	O
length	int
)	O
;	O
good	pointer
+=	O
length	int
;	O
thisitem	pointer
=	O
next	pointer
;	O
}	O
else	O
{	O
thisitem	pointer
=	O
nextitem	function
(	O
thisitem	pointer
)	O
;	O
}	O
}	O
nbackp	pointer
=	O
netobuf	array
;	O
nfrontp	pointer
=	O
good	pointer
;	O
neturg	pointer
=	O
0	int
;	O
}	O
void	O
netflush	function
(	O
void	O
)	O
{	O
int	O
n	long
;	O
if	O
(	O
(	O
n	long
=	O
nfrontp	pointer
-	O
nbackp	pointer
)	O
>	O
0	int
)	O
{	O
NET_ENCRYPT	O
(	O
)	O
;	O
if	O
(	O
!	O
neturg	pointer
||	O
!	O
not42	int
)	O
n	long
=	O
write	pointer
(	O
net	int
,	O
nbackp	pointer
,	O
n	long
)	O
;	O
else	O
{	O
n	long
=	O
neturg	pointer
-	O
nbackp	pointer
;	O
if	O
(	O
n	long
>	O
1	int
)	O
n	long
=	O
send	function
(	O
net	int
,	O
nbackp	pointer
,	O
n	long
-	O
1	int
,	O
0	int
)	O
;	O
else	O
n	long
=	O
send	function
(	O
net	int
,	O
nbackp	pointer
,	O
n	long
,	O
MSG_OOB	int
)	O
;	O
}	O
}	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
||	O
errno	O
==	O
EINTR	int
)	O
return	O
;	O
cleanup	pointer
(	O
0	int
)	O
;	O
}	O
nbackp	pointer
+=	O
n	long
;	O
if	O
(	O
nbackp	pointer
>=	O
neturg	pointer
)	O
neturg	pointer
=	O
0	int
;	O
if	O
(	O
nbackp	pointer
==	O
nfrontp	pointer
)	O
{	O
nbackp	pointer
=	O
nfrontp	pointer
=	O
netobuf	array
;	O
}	O
DEBUG	O
(	O
debug_report	int
,	O
1	int
,	O
debug_output_data	function
(	O
"td: netflush %d chars\r\n"	pointer
,	O
n	long
)	O
)	O
;	O
}	O
void	O
fatal	function
(	O
int	O
f	int
,	O
char	O
*	O
msg	pointer
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"telnetd: %s.\r\n"	pointer
,	O
msg	pointer
)	O
;	O
write	pointer
(	O
f	int
,	O
buf	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
void	O
fatalperror	function
(	O
int	O
f	int
,	O
char	O
*	O
msg	pointer
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"%s: %s"	pointer
,	O
msg	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fatal	function
(	O
f	int
,	O
buf	pointer
)	O
;	O
}	O
static	O
unsigned	O
char	O
ttytype_sbbuf	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_TTYPE	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
static	O
void	O
_gettermname	function
(	O
void	O
)	O
{	O
if	O
(	O
his_state_is_wont	O
(	O
TELOPT_TTYPE	int
)	O
)	O
return	O
;	O
settimer	O
(	O
baseline	int
)	O
;	O
net_output_datalen	function
(	O
ttytype_sbbuf	array
,	O
sizeof	O
ttytype_sbbuf	array
)	O
;	O
ttloop	O
(	O
sequenceIs	O
(	O
ttypesubopt	int
,	O
baseline	int
)	O
)	O
;	O
}	O
int	O
getterminaltype	function
(	O
char	O
*	O
user_name	pointer
)	O
{	O
int	O
retval	int
=	O
-	O
1	int
;	O
settimer	O
(	O
baseline	int
)	O
;	O
send_do	function
(	O
TELOPT_TTYPE	int
,	O
1	int
)	O
;	O
send_do	function
(	O
TELOPT_TSPEED	int
,	O
1	int
)	O
;	O
send_do	function
(	O
TELOPT_XDISPLOC	int
,	O
1	int
)	O
;	O
send_do	function
(	O
TELOPT_NEW_ENVIRON	int
,	O
1	int
)	O
;	O
send_do	function
(	O
TELOPT_OLD_ENVIRON	int
,	O
1	int
)	O
;	O
ttloop	O
(	O
his_will_wont_is_changing	O
(	O
TELOPT_TTYPE	int
)	O
||	O
his_will_wont_is_changing	O
(	O
TELOPT_TSPEED	int
)	O
||	O
his_will_wont_is_changing	O
(	O
TELOPT_XDISPLOC	int
)	O
||	O
his_will_wont_is_changing	O
(	O
TELOPT_NEW_ENVIRON	int
)	O
||	O
his_will_wont_is_changing	O
(	O
TELOPT_OLD_ENVIRON	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TSPEED	int
)	O
)	O
{	O
static	O
unsigned	O
char	O
sb	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_TSPEED	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
net_output_datalen	function
(	O
sb	array
,	O
sizeof	O
sb	array
)	O
;	O
}	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_XDISPLOC	int
)	O
)	O
{	O
static	O
unsigned	O
char	O
sb	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_XDISPLOC	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
net_output_datalen	function
(	O
sb	array
,	O
sizeof	O
sb	array
)	O
;	O
}	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_NEW_ENVIRON	int
)	O
)	O
{	O
static	O
unsigned	O
char	O
sb	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_NEW_ENVIRON	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
net_output_datalen	function
(	O
sb	array
,	O
sizeof	O
sb	array
)	O
;	O
}	O
else	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_OLD_ENVIRON	int
)	O
)	O
{	O
static	O
unsigned	O
char	O
sb	array
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_OLD_ENVIRON	int
,	O
TELQUAL_SEND	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
net_output_datalen	function
(	O
sb	array
,	O
sizeof	O
sb	array
)	O
;	O
}	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TTYPE	int
)	O
)	O
net_output_datalen	function
(	O
ttytype_sbbuf	array
,	O
sizeof	O
ttytype_sbbuf	array
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TSPEED	int
)	O
)	O
ttloop	O
(	O
sequenceIs	O
(	O
tspeedsubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_XDISPLOC	int
)	O
)	O
ttloop	O
(	O
sequenceIs	O
(	O
xdisplocsubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_NEW_ENVIRON	int
)	O
)	O
ttloop	O
(	O
sequenceIs	O
(	O
environsubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_OLD_ENVIRON	int
)	O
)	O
ttloop	O
(	O
sequenceIs	O
(	O
oenvironsubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TTYPE	int
)	O
)	O
{	O
char	O
*	O
first	pointer
=	O
NULL	O
,	O
*	O
last	pointer
=	O
NULL	O
;	O
ttloop	O
(	O
sequenceIs	O
(	O
ttypesubopt	int
,	O
baseline	int
)	O
)	O
;	O
if	O
(	O
his_state_is_will	O
(	O
TELOPT_TTYPE	int
)	O
&&	O
!	O
terminaltypeok	function
(	O
terminaltype	pointer
)	O
)	O
{	O
free	function
(	O
first	pointer
)	O
;	O
first	pointer
=	O
xstrdup	function
(	O
terminaltype	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
free	function
(	O
last	pointer
)	O
;	O
last	pointer
=	O
xstrdup	function
(	O
terminaltype	pointer
)	O
;	O
_gettermname	function
(	O
)	O
;	O
if	O
(	O
terminaltypeok	function
(	O
terminaltype	pointer
)	O
)	O
break	O
;	O
if	O
(	O
(	O
strcmp	function
(	O
last	pointer
,	O
terminaltype	pointer
)	O
==	O
0	int
)	O
||	O
his_state_is_wont	O
(	O
TELOPT_TTYPE	int
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
first	pointer
,	O
terminaltype	pointer
)	O
==	O
0	int
)	O
break	O
;	O
_gettermname	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
first	pointer
,	O
terminaltype	pointer
)	O
!=	O
0	int
)	O
{	O
free	function
(	O
terminaltype	pointer
)	O
;	O
terminaltype	pointer
=	O
xstrdup	function
(	O
first	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
free	function
(	O
first	pointer
)	O
;	O
free	function
(	O
last	pointer
)	O
;	O
}	O
return	O
retval	int
;	O
}	O
int	O
terminaltypeok	function
(	O
char	O
*	O
s	long
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
if	O
(	O
terminaltype	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
if	O
(	O
tgetent	function
(	O
buf	pointer
,	O
s	long
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
FILE	struct
*	O
debug_fp	pointer
=	O
NULL	O
;	O
static	O
int	O
debug_open	function
(	O
void	O
)	O
{	O
int	O
um	int
=	O
umask	function
(	O
077	int
)	O
;	O
if	O
(	O
!	O
debug_fp	pointer
)	O
debug_fp	pointer
=	O
fopen	function
(	O
"/tmp/telnet.debug"	pointer
,	O
"a"	pointer
)	O
;	O
umask	function
(	O
um	int
)	O
;	O
return	O
debug_fp	pointer
==	O
NULL	O
;	O
}	O
static	O
int	O
debug_close	function
(	O
void	O
)	O
{	O
if	O
(	O
debug_fp	pointer
)	O
fclose	function
(	O
debug_fp	pointer
)	O
;	O
debug_fp	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
void	O
debug_output_datalen	function
(	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
debug_open	function
(	O
)	O
)	O
return	O
;	O
fwrite	function
(	O
data	pointer
,	O
1	int
,	O
len	long
,	O
debug_fp	pointer
)	O
;	O
debug_close	function
(	O
)	O
;	O
}	O
void	O
debug_output_data	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
if	O
(	O
debug_open	function
(	O
)	O
)	O
return	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
debug_fp	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
debug_close	function
(	O
)	O
;	O
}	O
void	O
printoption	function
(	O
register	O
char	O
*	O
fmt	pointer
,	O
register	O
int	O
option	int
)	O
{	O
if	O
(	O
TELOPT_OK	O
(	O
option	int
)	O
)	O
debug_output_data	function
(	O
"%s %s\r\n"	pointer
,	O
fmt	pointer
,	O
TELOPT	O
(	O
option	int
)	O
)	O
;	O
else	O
if	O
(	O
TELCMD_OK	O
(	O
option	int
)	O
)	O
debug_output_data	function
(	O
"%s %s\r\n"	pointer
,	O
fmt	pointer
,	O
TELCMD	O
(	O
option	int
)	O
)	O
;	O
else	O
debug_output_data	function
(	O
"%s %d\r\n"	pointer
,	O
fmt	pointer
,	O
option	int
)	O
;	O
}	O
void	O
printsub	pointer
(	O
int	O
direction	int
,	O
unsigned	O
char	O
*	O
pointer	pointer
,	O
int	O
length	int
)	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
direction	int
)	O
{	O
debug_output_data	function
(	O
"td: %s suboption "	pointer
,	O
direction	int
==	O
'<'	O
?	O
"recv"	pointer
:	O
"send"	pointer
)	O
;	O
if	O
(	O
length	int
>=	O
3	int
)	O
{	O
register	O
int	O
j	int
;	O
i	int
=	O
pointer	pointer
[	O
length	int
-	O
2	int
]	O
;	O
j	int
=	O
pointer	pointer
[	O
length	int
-	O
1	int
]	O
;	O
if	O
(	O
i	int
!=	O
IAC	int
||	O
j	int
!=	O
SE	int
)	O
{	O
debug_output_data	function
(	O
"(terminated by "	pointer
)	O
;	O
if	O
(	O
TELOPT_OK	O
(	O
i	int
)	O
)	O
debug_output_data	function
(	O
"%s "	pointer
,	O
TELOPT	O
(	O
i	int
)	O
)	O
;	O
else	O
if	O
(	O
TELCMD_OK	O
(	O
i	int
)	O
)	O
debug_output_data	function
(	O
"%s "	pointer
,	O
TELCMD	O
(	O
i	int
)	O
)	O
;	O
else	O
debug_output_data	function
(	O
"%d "	pointer
,	O
i	int
)	O
;	O
if	O
(	O
TELOPT_OK	O
(	O
j	int
)	O
)	O
debug_output_data	function
(	O
"%s"	pointer
,	O
TELOPT	O
(	O
j	int
)	O
)	O
;	O
else	O
if	O
(	O
TELCMD_OK	O
(	O
j	int
)	O
)	O
debug_output_data	function
(	O
"%s"	pointer
,	O
TELCMD	O
(	O
j	int
)	O
)	O
;	O
else	O
debug_output_data	function
(	O
"%d"	pointer
,	O
j	int
)	O
;	O
debug_output_data	function
(	O
", not IAC SE!) "	pointer
)	O
;	O
}	O
}	O
length	int
-=	O
2	int
;	O
}	O
if	O
(	O
length	int
<	O
1	int
)	O
{	O
debug_output_data	function
(	O
"(Empty suboption??\?)"	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
pointer	pointer
[	O
0	int
]	O
)	O
{	O
case	O
TELOPT_TTYPE	int
:	O
debug_output_data	function
(	O
"TERMINAL-TYPE "	pointer
)	O
;	O
switch	O
(	O
pointer	pointer
[	O
1	int
]	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	function
(	O
"IS \"%.*s\""	pointer
,	O
length	int
-	O
2	int
,	O
(	O
char	O
*	O
)	O
pointer	pointer
+	O
2	int
)	O
;	O
break	O
;	O
case	O
TELQUAL_SEND	int
:	O
debug_output_data	function
(	O
"SEND"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	function
(	O
"- unknown qualifier %d (0x%x)."	pointer
,	O
pointer	pointer
[	O
1	int
]	O
,	O
pointer	pointer
[	O
1	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_TSPEED	int
:	O
debug_output_data	function
(	O
"TERMINAL-SPEED"	pointer
)	O
;	O
if	O
(	O
length	int
<	O
2	int
)	O
{	O
debug_output_data	function
(	O
" (empty suboption??\?)"	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
pointer	pointer
[	O
1	int
]	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	function
(	O
" IS %.*s"	pointer
,	O
length	int
-	O
2	int
,	O
(	O
char	O
*	O
)	O
pointer	pointer
+	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
pointer	pointer
[	O
1	int
]	O
==	O
1	int
)	O
debug_output_data	function
(	O
" SEND"	pointer
)	O
;	O
else	O
debug_output_data	function
(	O
" %d (unknown)"	pointer
,	O
pointer	pointer
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
{	O
debug_output_data	function
(	O
" ?%d?"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
case	O
TELOPT_LFLOW	int
:	O
debug_output_data	function
(	O
"TOGGLE-FLOW-CONTROL"	pointer
)	O
;	O
if	O
(	O
length	int
<	O
2	int
)	O
{	O
debug_output_data	function
(	O
" (empty suboption??\?)"	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
pointer	pointer
[	O
1	int
]	O
)	O
{	O
case	O
LFLOW_OFF	int
:	O
debug_output_data	function
(	O
" OFF"	pointer
)	O
;	O
break	O
;	O
case	O
LFLOW_ON	int
:	O
debug_output_data	function
(	O
" ON"	pointer
)	O
;	O
break	O
;	O
case	O
LFLOW_RESTART_ANY	int
:	O
debug_output_data	function
(	O
" RESTART-ANY"	pointer
)	O
;	O
break	O
;	O
case	O
LFLOW_RESTART_XON	int
:	O
debug_output_data	function
(	O
" RESTART-XON"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	function
(	O
" %d (unknown)"	pointer
,	O
pointer	pointer
[	O
1	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" ?%d?"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
TELOPT_NAWS	int
:	O
debug_output_data	function
(	O
"NAWS"	pointer
)	O
;	O
if	O
(	O
length	int
<	O
2	int
)	O
{	O
debug_output_data	function
(	O
" (empty suboption??\?)"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
length	int
==	O
2	int
)	O
{	O
debug_output_data	function
(	O
" ?%d?"	pointer
,	O
pointer	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
debug_output_data	function
(	O
" %d %d (%d)"	pointer
,	O
pointer	pointer
[	O
1	int
]	O
,	O
pointer	pointer
[	O
2	int
]	O
,	O
(	O
int	O
)	O
(	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
pointer	pointer
[	O
1	int
]	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
unsigned	O
int	O
)	O
pointer	pointer
[	O
2	int
]	O
)	O
)	O
)	O
;	O
if	O
(	O
length	int
==	O
4	int
)	O
{	O
debug_output_data	function
(	O
" ?%d?"	pointer
,	O
pointer	pointer
[	O
3	int
]	O
)	O
;	O
break	O
;	O
}	O
debug_output_data	function
(	O
" %d %d (%d)"	pointer
,	O
pointer	pointer
[	O
3	int
]	O
,	O
pointer	pointer
[	O
4	int
]	O
,	O
(	O
int	O
)	O
(	O
(	O
(	O
(	O
unsigned	O
int	O
)	O
pointer	pointer
[	O
3	int
]	O
)	O
<<	O
8	int
)	O
|	O
(	O
(	O
unsigned	O
int	O
)	O
pointer	pointer
[	O
4	int
]	O
)	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
5	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" ?%d?"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
debug_output_data	function
(	O
"LINEMODE "	pointer
)	O
;	O
if	O
(	O
length	int
<	O
2	int
)	O
{	O
debug_output_data	function
(	O
" (empty suboption??\?)"	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
pointer	pointer
[	O
1	int
]	O
)	O
{	O
case	O
WILL	int
:	O
debug_output_data	function
(	O
"WILL "	pointer
)	O
;	O
goto	O
common	O
;	O
case	O
WONT	int
:	O
debug_output_data	function
(	O
"WONT "	pointer
)	O
;	O
goto	O
common	O
;	O
case	O
DO	int
:	O
debug_output_data	function
(	O
"DO "	pointer
)	O
;	O
goto	O
common	O
;	O
case	O
DONT	int
:	O
debug_output_data	function
(	O
"DONT "	pointer
)	O
;	O
common	O
:	O
if	O
(	O
length	int
<	O
3	int
)	O
{	O
debug_output_data	function
(	O
"(no option??\?)"	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
pointer	pointer
[	O
2	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
debug_output_data	function
(	O
"Forward Mask"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" %x"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	function
(	O
"%d (unknown)"	pointer
,	O
pointer	pointer
[	O
2	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" %d"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
LM_SLC	int
:	O
debug_output_data	function
(	O
"SLC"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
-	O
2	int
;	O
i	int
+=	O
3	int
)	O
{	O
if	O
(	O
SLC_NAME_OK	O
(	O
pointer	pointer
[	O
i	int
+	O
SLC_FUNC	int
]	O
)	O
)	O
debug_output_data	function
(	O
" %s"	pointer
,	O
SLC_NAME	O
(	O
pointer	pointer
[	O
i	int
+	O
SLC_FUNC	int
]	O
)	O
)	O
;	O
else	O
debug_output_data	function
(	O
" %d"	pointer
,	O
pointer	pointer
[	O
i	int
+	O
SLC_FUNC	int
]	O
)	O
;	O
switch	O
(	O
pointer	pointer
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
SLC_LEVELBITS	int
)	O
{	O
case	O
SLC_NOSUPPORT	int
:	O
debug_output_data	function
(	O
" NOSUPPORT"	pointer
)	O
;	O
break	O
;	O
case	O
SLC_CANTCHANGE	int
:	O
debug_output_data	function
(	O
" CANTCHANGE"	pointer
)	O
;	O
break	O
;	O
case	O
SLC_VARIABLE	int
:	O
debug_output_data	function
(	O
" VARIABLE"	pointer
)	O
;	O
break	O
;	O
case	O
SLC_DEFAULT	int
:	O
debug_output_data	function
(	O
" DEFAULT"	pointer
)	O
;	O
break	O
;	O
}	O
debug_output_data	function
(	O
"%s%s%s"	pointer
,	O
pointer	pointer
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
SLC_ACK	int
?	O
"|ACK"	pointer
:	O
""	pointer
,	O
pointer	pointer
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
SLC_FLUSHIN	int
?	O
"|FLUSHIN"	pointer
:	O
""	pointer
,	O
pointer	pointer
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
SLC_FLUSHOUT	int
?	O
"|FLUSHOUT"	pointer
:	O
""	pointer
)	O
;	O
if	O
(	O
pointer	pointer
[	O
i	int
+	O
SLC_FLAGS	int
]	O
&	O
~	O
(	O
SLC_ACK	int
|	O
SLC_FLUSHIN	int
|	O
SLC_FLUSHOUT	int
|	O
SLC_LEVELBITS	int
)	O
)	O
debug_output_data	function
(	O
"(0x%x)"	pointer
,	O
pointer	pointer
[	O
i	int
+	O
SLC_FLAGS	int
]	O
)	O
;	O
debug_output_data	function
(	O
" %d;"	pointer
,	O
pointer	pointer
[	O
i	int
+	O
SLC_VALUE	int
]	O
)	O
;	O
if	O
(	O
(	O
pointer	pointer
[	O
i	int
+	O
SLC_VALUE	int
]	O
==	O
IAC	int
)	O
&&	O
(	O
pointer	pointer
[	O
i	int
+	O
SLC_VALUE	int
+	O
1	int
]	O
==	O
IAC	int
)	O
)	O
i	int
++	O
;	O
}	O
for	O
(	O
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" ?%d?"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
LM_MODE	int
:	O
debug_output_data	function
(	O
"MODE "	pointer
)	O
;	O
if	O
(	O
length	int
<	O
3	int
)	O
{	O
debug_output_data	function
(	O
"(no mode??\?)"	pointer
)	O
;	O
break	O
;	O
}	O
{	O
char	O
tbuf	array
[	O
32	int
]	O
;	O
snprintf	function
(	O
tbuf	array
,	O
sizeof	O
(	O
tbuf	array
)	O
,	O
"%s%s%s%s%s"	pointer
,	O
pointer	pointer
[	O
2	int
]	O
&	O
MODE_EDIT	int
?	O
"|EDIT"	pointer
:	O
""	pointer
,	O
pointer	pointer
[	O
2	int
]	O
&	O
MODE_TRAPSIG	int
?	O
"|TRAPSIG"	pointer
:	O
""	pointer
,	O
pointer	pointer
[	O
2	int
]	O
&	O
MODE_SOFT_TAB	int
?	O
"|SOFT_TAB"	pointer
:	O
""	pointer
,	O
pointer	pointer
[	O
2	int
]	O
&	O
MODE_LIT_ECHO	int
?	O
"|LIT_ECHO"	pointer
:	O
""	pointer
,	O
pointer	pointer
[	O
2	int
]	O
&	O
MODE_ACK	int
?	O
"|ACK"	pointer
:	O
""	pointer
)	O
;	O
debug_output_data	function
(	O
"%s"	pointer
,	O
tbuf	array
[	O
1	int
]	O
?	O
&	O
tbuf	array
[	O
1	int
]	O
:	O
"0"	pointer
)	O
;	O
}	O
if	O
(	O
pointer	pointer
[	O
2	int
]	O
&	O
~	O
(	O
MODE_EDIT	int
|	O
MODE_TRAPSIG	int
|	O
MODE_ACK	int
)	O
)	O
debug_output_data	function
(	O
" (0x%x)"	pointer
,	O
pointer	pointer
[	O
2	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" ?0x%x?"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	function
(	O
"%d (unknown)"	pointer
,	O
pointer	pointer
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" %d"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_STATUS	int
:	O
{	O
register	O
char	O
*	O
cp	pointer
;	O
register	O
int	O
j	int
,	O
k	int
;	O
debug_output_data	function
(	O
"STATUS"	pointer
)	O
;	O
switch	O
(	O
pointer	pointer
[	O
1	int
]	O
)	O
{	O
default	O
:	O
if	O
(	O
pointer	pointer
[	O
1	int
]	O
==	O
TELQUAL_SEND	int
)	O
debug_output_data	function
(	O
" SEND"	pointer
)	O
;	O
else	O
debug_output_data	function
(	O
" %d (unknown)"	pointer
,	O
pointer	pointer
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" ?%d?"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	function
(	O
" IS\r\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
pointer	pointer
[	O
i	int
]	O
)	O
{	O
case	O
DO	int
:	O
cp	pointer
=	O
"DO"	pointer
;	O
goto	O
common2	O
;	O
case	O
DONT	int
:	O
cp	pointer
=	O
"DONT"	pointer
;	O
goto	O
common2	O
;	O
case	O
WILL	int
:	O
cp	pointer
=	O
"WILL"	pointer
;	O
goto	O
common2	O
;	O
case	O
WONT	int
:	O
cp	pointer
=	O
"WONT"	pointer
;	O
goto	O
common2	O
;	O
common2	O
:	O
i	int
++	O
;	O
if	O
(	O
TELOPT_OK	O
(	O
pointer	pointer
[	O
i	int
]	O
)	O
)	O
debug_output_data	function
(	O
" %s %s\r\n"	pointer
,	O
cp	pointer
,	O
TELOPT	O
(	O
pointer	pointer
[	O
i	int
]	O
)	O
)	O
;	O
else	O
debug_output_data	function
(	O
" %s %d\r\n"	pointer
,	O
cp	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
case	O
SB	int
:	O
debug_output_data	function
(	O
" SB "	pointer
)	O
;	O
i	int
++	O
;	O
j	int
=	O
k	int
=	O
i	int
;	O
while	O
(	O
j	int
<	O
length	int
)	O
{	O
if	O
(	O
pointer	pointer
[	O
j	int
]	O
==	O
SE	int
)	O
{	O
if	O
(	O
j	int
+	O
1	int
==	O
length	int
)	O
break	O
;	O
if	O
(	O
pointer	pointer
[	O
j	int
+	O
1	int
]	O
==	O
SE	int
)	O
j	int
++	O
;	O
else	O
break	O
;	O
}	O
pointer	pointer
[	O
k	int
++	O
]	O
=	O
pointer	pointer
[	O
j	int
++	O
]	O
;	O
}	O
printsub	pointer
(	O
0	int
,	O
&	O
pointer	pointer
[	O
i	int
]	O
,	O
k	int
-	O
i	int
)	O
;	O
if	O
(	O
i	int
<	O
length	int
)	O
{	O
debug_output_data	function
(	O
" SE"	pointer
)	O
;	O
i	int
=	O
j	int
;	O
}	O
else	O
i	int
=	O
j	int
-	O
1	int
;	O
debug_output_data	function
(	O
"\r\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	function
(	O
" %d"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
TELOPT_XDISPLOC	int
:	O
debug_output_data	function
(	O
"X-DISPLAY-LOCATION "	pointer
)	O
;	O
switch	O
(	O
pointer	pointer
[	O
1	int
]	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	function
(	O
"IS \"%.*s\""	pointer
,	O
length	int
-	O
2	int
,	O
(	O
char	O
*	O
)	O
pointer	pointer
+	O
2	int
)	O
;	O
break	O
;	O
case	O
TELQUAL_SEND	int
:	O
debug_output_data	function
(	O
"SEND"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
debug_output_data	function
(	O
"- unknown qualifier %d (0x%x)."	pointer
,	O
pointer	pointer
[	O
1	int
]	O
,	O
pointer	pointer
[	O
1	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
debug_output_data	function
(	O
"NEW-ENVIRON "	pointer
)	O
;	O
goto	O
env_common1	O
;	O
case	O
TELOPT_OLD_ENVIRON	int
:	O
debug_output_data	function
(	O
"OLD-ENVIRON"	pointer
)	O
;	O
env_common1	O
:	O
switch	O
(	O
pointer	pointer
[	O
1	int
]	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
debug_output_data	function
(	O
"IS "	pointer
)	O
;	O
goto	O
env_common	O
;	O
case	O
TELQUAL_SEND	int
:	O
debug_output_data	function
(	O
"SEND "	pointer
)	O
;	O
goto	O
env_common	O
;	O
case	O
TELQUAL_INFO	int
:	O
debug_output_data	function
(	O
"INFO "	pointer
)	O
;	O
env_common	O
:	O
{	O
register	O
int	O
noquote	int
=	O
2	int
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
pointer	pointer
[	O
i	int
]	O
)	O
{	O
case	O
NEW_ENV_VAR	int
:	O
debug_output_data	function
(	O
"\" VAR "	pointer
+	O
noquote	int
)	O
;	O
noquote	int
=	O
2	int
;	O
break	O
;	O
case	O
NEW_ENV_VALUE	int
:	O
debug_output_data	function
(	O
"\" VALUE "	pointer
+	O
noquote	int
)	O
;	O
noquote	int
=	O
2	int
;	O
break	O
;	O
case	O
ENV_ESC	int
:	O
debug_output_data	function
(	O
"\" ESC "	pointer
+	O
noquote	int
)	O
;	O
noquote	int
=	O
2	int
;	O
break	O
;	O
case	O
ENV_USERVAR	int
:	O
debug_output_data	function
(	O
"\" USERVAR "	pointer
+	O
noquote	int
)	O
;	O
noquote	int
=	O
2	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
isprint	function
(	O
pointer	pointer
[	O
i	int
]	O
)	O
&&	O
pointer	pointer
[	O
i	int
]	O
!=	O
'"'	O
)	O
{	O
if	O
(	O
noquote	int
)	O
{	O
debug_output_data	function
(	O
"\""	pointer
)	O
;	O
noquote	int
=	O
0	int
;	O
}	O
debug_output_datalen	function
(	O
(	O
char	O
*	O
)	O
&	O
pointer	pointer
[	O
i	int
]	O
,	O
1	int
)	O
;	O
}	O
else	O
{	O
debug_output_data	function
(	O
"\" %03o "	pointer
+	O
noquote	int
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
noquote	int
=	O
2	int
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
noquote	int
)	O
debug_output_data	function
(	O
"\""	pointer
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
TELOPT_OK	O
(	O
pointer	pointer
[	O
0	int
]	O
)	O
)	O
debug_output_data	function
(	O
"%s (unknown)"	pointer
,	O
TELOPT	O
(	O
pointer	pointer
[	O
0	int
]	O
)	O
)	O
;	O
else	O
debug_output_data	function
(	O
"%d (unknown)"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
debug_output_data	function
(	O
" %d"	pointer
,	O
pointer	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
debug_output_data	function
(	O
"\r\n"	pointer
)	O
;	O
}	O
void	O
printdata	function
(	O
register	O
char	O
*	O
tag	pointer
,	O
register	O
char	O
*	O
ptr	pointer
,	O
register	O
int	O
cnt	int
)	O
{	O
register	O
int	O
i	int
;	O
char	O
xbuf	array
[	O
30	int
]	O
;	O
while	O
(	O
cnt	int
)	O
{	O
debug_output_data	function
(	O
"%s: "	pointer
,	O
tag	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
20	int
&&	O
cnt	int
;	O
i	int
++	O
)	O
{	O
debug_output_data	function
(	O
"%02x"	pointer
,	O
*	O
ptr	pointer
)	O
;	O
xbuf	array
[	O
i	int
]	O
=	O
isprint	function
(	O
*	O
ptr	pointer
)	O
?	O
*	O
ptr	pointer
:	O
'.'	O
;	O
if	O
(	O
i	int
%	O
2	int
)	O
debug_output_data	function
(	O
" "	pointer
)	O
;	O
cnt	int
--	O
;	O
ptr	pointer
++	O
;	O
}	O
xbuf	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
debug_output_data	function
(	O
" %s\r\n"	pointer
,	O
xbuf	array
)	O
;	O
}	O
}	O
struct	O
line_expander	struct
{	O
int	O
state	pointer
;	O
int	O
level	int
;	O
char	O
*	O
source	pointer
;	O
char	O
*	O
cp	pointer
;	O
struct	O
obstack	struct
stk	struct
;	O
}	O
;	O
static	O
char	O
*	O
_var_short_name	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
;	O
static	O
char	O
*	O
_var_long_name	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
,	O
char	O
*	O
start	pointer
,	O
int	O
length	int
)	O
;	O
static	O
char	O
*	O
_expand_var	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
;	O
static	O
void	O
_expand_cond	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
;	O
static	O
void	O
_skip_block	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
;	O
static	O
void	O
_expand_block	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
;	O
char	O
*	O
_var_short_name	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
{	O
char	O
*	O
q	pointer
;	O
char	O
timebuf	array
[	O
64	int
]	O
;	O
time_t	long
t	long
;	O
switch	O
(	O
*	O
exp	pointer
->	O
cp	pointer
++	O
)	O
{	O
case	O
'a'	O
:	O
return	O
NULL	O
;	O
case	O
'd'	O
:	O
time	struct
(	O
&	O
t	long
)	O
;	O
strftime	function
(	O
timebuf	array
,	O
sizeof	O
(	O
timebuf	array
)	O
,	O
"%l:%M%P on %A, %d %B %Y"	pointer
,	O
localtime	function
(	O
&	O
t	long
)	O
)	O
;	O
return	O
xstrdup	function
(	O
timebuf	array
)	O
;	O
case	O
'h'	O
:	O
return	O
xstrdup	function
(	O
remote_hostname	pointer
)	O
;	O
case	O
'l'	O
:	O
return	O
xstrdup	function
(	O
local_hostname	pointer
)	O
;	O
case	O
't'	O
:	O
q	pointer
=	O
strchr	function
(	O
line	array
+	O
1	int
,	O
'/'	O
)	O
;	O
if	O
(	O
q	pointer
)	O
q	pointer
++	O
;	O
else	O
q	pointer
=	O
line	array
;	O
return	O
xstrdup	function
(	O
q	pointer
)	O
;	O
case	O
'T'	O
:	O
return	O
terminaltype	pointer
?	O
xstrdup	function
(	O
terminaltype	pointer
)	O
:	O
NULL	O
;	O
case	O
'u'	O
:	O
return	O
user_name	pointer
?	O
xstrdup	function
(	O
user_name	pointer
)	O
:	O
NULL	O
;	O
default	O
:	O
exp	pointer
->	O
state	pointer
=	O
EXP_STATE_ERROR	int
;	O
return	O
NULL	O
;	O
}	O
}	O
char	O
*	O
_var_long_name	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
,	O
char	O
*	O
start	pointer
,	O
int	O
length	int
)	O
{	O
exp	pointer
->	O
state	pointer
=	O
EXP_STATE_ERROR	int
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
_expand_var	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
switch	O
(	O
*	O
exp	pointer
->	O
cp	pointer
)	O
{	O
case	O
'{'	O
:	O
for	O
(	O
p	pointer
=	O
++	O
exp	pointer
->	O
cp	pointer
;	O
*	O
exp	pointer
->	O
cp	pointer
&&	O
*	O
exp	pointer
->	O
cp	pointer
!=	O
'}'	O
;	O
exp	pointer
->	O
cp	pointer
++	O
)	O
;	O
if	O
(	O
*	O
exp	pointer
->	O
cp	pointer
==	O
0	int
)	O
{	O
exp	pointer
->	O
cp	pointer
=	O
p	pointer
;	O
exp	pointer
->	O
state	pointer
=	O
EXP_STATE_ERROR	int
;	O
break	O
;	O
}	O
p	pointer
=	O
_var_long_name	function
(	O
exp	pointer
,	O
p	pointer
,	O
exp	pointer
->	O
cp	pointer
-	O
p	pointer
)	O
;	O
exp	pointer
->	O
cp	pointer
++	O
;	O
break	O
;	O
default	O
:	O
p	pointer
=	O
_var_short_name	function
(	O
exp	pointer
)	O
;	O
break	O
;	O
}	O
return	O
p	pointer
;	O
}	O
void	O
_expand_cond	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
*	O
++	O
exp	pointer
->	O
cp	pointer
==	O
'?'	O
)	O
{	O
exp	pointer
->	O
cp	pointer
++	O
;	O
p	pointer
=	O
_expand_var	function
(	O
exp	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
_expand_block	function
(	O
exp	pointer
)	O
;	O
_skip_block	function
(	O
exp	pointer
)	O
;	O
}	O
else	O
{	O
_skip_block	function
(	O
exp	pointer
)	O
;	O
_expand_block	function
(	O
exp	pointer
)	O
;	O
}	O
free	function
(	O
p	pointer
)	O
;	O
}	O
else	O
{	O
p	pointer
=	O
_expand_var	function
(	O
exp	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
obstack_grow	O
(	O
&	O
exp	pointer
->	O
stk	struct
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
}	O
void	O
_skip_block	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
{	O
int	O
level	int
=	O
exp	pointer
->	O
level	int
;	O
if	O
(	O
*	O
exp	pointer
->	O
cp	pointer
!=	O
'{'	O
)	O
return	O
;	O
for	O
(	O
;	O
*	O
exp	pointer
->	O
cp	pointer
;	O
exp	pointer
->	O
cp	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
exp	pointer
->	O
cp	pointer
)	O
{	O
case	O
'{'	O
:	O
exp	pointer
->	O
level	int
++	O
;	O
break	O
;	O
case	O
'}'	O
:	O
exp	pointer
->	O
level	int
--	O
;	O
if	O
(	O
exp	pointer
->	O
level	int
==	O
level	int
)	O
{	O
exp	pointer
->	O
cp	pointer
++	O
;	O
return	O
;	O
}	O
}	O
}	O
}	O
void	O
_expand_block	function
(	O
struct	O
line_expander	struct
*	O
exp	pointer
)	O
{	O
int	O
level	int
=	O
exp	pointer
->	O
level	int
;	O
if	O
(	O
*	O
exp	pointer
->	O
cp	pointer
==	O
'{'	O
)	O
{	O
exp	pointer
->	O
level	int
++	O
;	O
exp	pointer
->	O
cp	pointer
++	O
;	O
}	O
while	O
(	O
exp	pointer
->	O
state	pointer
==	O
EXP_STATE_CONTINUE	int
)	O
{	O
for	O
(	O
;	O
*	O
exp	pointer
->	O
cp	pointer
&&	O
*	O
exp	pointer
->	O
cp	pointer
!=	O
'%'	O
;	O
exp	pointer
->	O
cp	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
exp	pointer
->	O
cp	pointer
)	O
{	O
case	O
'{'	O
:	O
exp	pointer
->	O
level	int
++	O
;	O
break	O
;	O
case	O
'}'	O
:	O
exp	pointer
->	O
level	int
--	O
;	O
if	O
(	O
exp	pointer
->	O
level	int
==	O
level	int
)	O
{	O
exp	pointer
->	O
cp	pointer
++	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
'\\'	O
:	O
exp	pointer
->	O
cp	pointer
++	O
;	O
break	O
;	O
}	O
obstack_1grow	O
(	O
&	O
exp	pointer
->	O
stk	struct
,	O
*	O
exp	pointer
->	O
cp	pointer
)	O
;	O
}	O
if	O
(	O
*	O
exp	pointer
->	O
cp	pointer
==	O
0	int
)	O
{	O
obstack_1grow	O
(	O
&	O
exp	pointer
->	O
stk	struct
,	O
0	int
)	O
;	O
exp	pointer
->	O
state	pointer
=	O
EXP_STATE_SUCCESS	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
exp	pointer
->	O
cp	pointer
==	O
'%'	O
&&	O
exp	pointer
->	O
cp	pointer
[	O
1	int
]	O
==	O
'%'	O
)	O
{	O
obstack_1grow	O
(	O
&	O
exp	pointer
->	O
stk	struct
,	O
*	O
exp	pointer
->	O
cp	pointer
)	O
;	O
exp	pointer
->	O
cp	pointer
+=	O
2	int
;	O
continue	O
;	O
}	O
_expand_cond	function
(	O
exp	pointer
)	O
;	O
}	O
}	O
char	O
*	O
expand_line	function
(	O
const	O
char	O
*	O
line	array
)	O
{	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
struct	O
line_expander	struct
exp	pointer
;	O
exp	pointer
.	O
state	pointer
=	O
EXP_STATE_CONTINUE	int
;	O
exp	pointer
.	O
level	int
=	O
0	int
;	O
exp	pointer
.	O
source	pointer
=	O
(	O
char	O
*	O
)	O
line	array
;	O
exp	pointer
.	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
line	array
;	O
obstack_init	O
(	O
&	O
exp	pointer
.	O
stk	struct
)	O
;	O
_expand_block	function
(	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
exp	pointer
.	O
state	pointer
==	O
EXP_STATE_SUCCESS	int
)	O
p	pointer
=	O
xstrdup	function
(	O
obstack_finish	O
(	O
&	O
exp	pointer
.	O
stk	struct
)	O
)	O
;	O
else	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"can't expand line: %s"	pointer
,	O
line	array
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"stopped near %s"	pointer
,	O
exp	pointer
.	O
cp	pointer
?	O
exp	pointer
.	O
cp	pointer
:	O
"(END)"	pointer
)	O
;	O
}	O
obstack_free	function
(	O
&	O
exp	pointer
.	O
stk	struct
,	O
NULL	O
)	O
;	O
return	O
p	pointer
;	O
}	O
