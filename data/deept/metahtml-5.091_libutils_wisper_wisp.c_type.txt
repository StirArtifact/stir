static	O
void	O
initialize_string_buffer	function
(	O
void	O
)	O
;	O
static	O
void	O
print_object_to_string_buffer	function
(	O
WispObject	struct
*	O
object	pointer
)	O
;	O
static	O
void	O
print_string_to_string_buffer	function
(	O
char	O
*	O
string	pointer
)	O
;	O
static	O
void	O
print_list_contents	function
(	O
WispObject	struct
*	O
list	pointer
)	O
;	O
static	O
char	O
*	O
get_string_buffer	function
(	O
void	O
)	O
;	O
static	O
char	O
*	O
read_string	function
(	O
void	O
)	O
;	O
static	O
WispObject	struct
*	O
read_symbol_or_number	function
(	O
void	O
)	O
;	O
static	O
WispObject	struct
*	O
read_list	function
(	O
void	O
)	O
;	O
static	O
int	O
read_character	function
(	O
void	O
)	O
;	O
static	O
void	O
unread_character	function
(	O
void	O
)	O
;	O
WispObject	struct
wisp_nil_value	struct
=	O
{	O
LT_nil	int
}	O
;	O
WispObject	struct
wisp_dot_value	struct
=	O
{	O
LT_string	int
,	O
{	O
"."	pointer
}	O
}	O
;	O
static	O
WispObject	struct
*	O
*	O
obarray	pointer
=	O
(	O
WispObject	struct
*	O
*	O
)	O
NULL	O
;	O
static	O
int	O
obarray_index	int
=	O
0	int
;	O
static	O
int	O
obarray_size	int
=	O
0	int
;	O
static	O
void	O
obarray_add	function
(	O
WispObject	struct
*	O
object	pointer
)	O
{	O
if	O
(	O
(	O
obarray_index	int
+	O
2	int
)	O
>	O
obarray_size	int
)	O
obarray	pointer
=	O
(	O
WispObject	struct
*	O
*	O
)	O
xrealloc	function
(	O
obarray	pointer
,	O
(	O
obarray_size	int
+=	O
1000	int
)	O
*	O
sizeof	O
(	O
WispObject	struct
*	O
)	O
)	O
;	O
obarray	pointer
[	O
obarray_index	int
++	O
]	O
=	O
object	pointer
;	O
obarray	pointer
[	O
obarray_index	int
]	O
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
obarray_del	function
(	O
WispObject	struct
*	O
object	pointer
)	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
obarray_index	int
;	O
i	int
++	O
)	O
if	O
(	O
obarray	pointer
[	O
i	int
]	O
==	O
object	pointer
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
(	O
obarray	pointer
[	O
i	int
]	O
=	O
obarray	pointer
[	O
j	int
]	O
)	O
!=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
j	int
++	O
,	O
i	int
++	O
)	O
;	O
if	O
(	O
obarray_index	int
==	O
j	int
)	O
obarray_index	int
--	O
;	O
break	O
;	O
}	O
}	O
void	O
gc_wisp_free	function
(	O
WispObject	struct
*	O
object	pointer
)	O
{	O
switch	O
(	O
object	pointer
->	O
type	enum
)	O
{	O
case	O
LT_string	int
:	O
free	function
(	O
object	pointer
->	O
val	union
.	O
string	pointer
)	O
;	O
free	function
(	O
object	pointer
)	O
;	O
break	O
;	O
case	O
LT_number	int
:	O
case	O
LT_cons	int
:	O
case	O
LT_symbol	int
:	O
free	function
(	O
object	pointer
)	O
;	O
break	O
;	O
case	O
LT_nil	int
:	O
break	O
;	O
}	O
}	O
void	O
gc_wisp_objects	function
(	O
)	O
{	O
register	O
int	O
i	int
;	O
register	O
WispObject	struct
*	O
object	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
obarray_index	int
;	O
i	int
++	O
)	O
{	O
object	pointer
=	O
obarray	pointer
[	O
i	int
]	O
;	O
gc_wisp_free	function
(	O
object	pointer
)	O
;	O
}	O
obarray_index	int
=	O
0	int
;	O
}	O
static	O
WispObject	struct
*	O
allocate_object	function
(	O
void	O
)	O
{	O
WispObject	struct
*	O
object	pointer
;	O
object	pointer
=	O
(	O
WispObject	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
WispObject	struct
)	O
)	O
;	O
memset	function
(	O
(	O
void	O
*	O
)	O
object	pointer
,	O
0	int
,	O
sizeof	O
(	O
WispObject	struct
)	O
)	O
;	O
obarray_add	function
(	O
object	pointer
)	O
;	O
return	O
(	O
object	pointer
)	O
;	O
}	O
void	O
gc_steal	function
(	O
WispObject	struct
*	O
object	pointer
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
obarray_index	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
obarray	pointer
[	O
i	int
]	O
==	O
object	pointer
)	O
{	O
for	O
(	O
;	O
i	int
<	O
obarray_index	int
;	O
i	int
++	O
)	O
obarray	pointer
[	O
i	int
]	O
=	O
obarray	pointer
[	O
i	int
+	O
1	int
]	O
;	O
obarray	pointer
[	O
i	int
]	O
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
obarray_index	int
--	O
;	O
break	O
;	O
}	O
}	O
}	O
WispObject	struct
*	O
make_string_object	function
(	O
char	O
*	O
string	pointer
)	O
{	O
WispObject	struct
*	O
object	pointer
;	O
object	pointer
=	O
allocate_object	function
(	O
)	O
;	O
object	pointer
->	O
type	enum
=	O
LT_string	int
;	O
object	pointer
->	O
val	union
.	O
string	pointer
=	O
strdup	function
(	O
string	pointer
)	O
;	O
return	O
(	O
object	pointer
)	O
;	O
}	O
WispObject	struct
*	O
make_number_object	function
(	O
double	O
number	double
)	O
{	O
WispObject	struct
*	O
object	pointer
;	O
object	pointer
=	O
allocate_object	function
(	O
)	O
;	O
object	pointer
->	O
type	enum
=	O
LT_number	int
;	O
object	pointer
->	O
val	union
.	O
number	double
=	O
number	double
;	O
return	O
(	O
object	pointer
)	O
;	O
}	O
WispObject	struct
*	O
make_cons	function
(	O
WispObject	struct
*	O
car	pointer
,	O
WispObject	struct
*	O
cdr	pointer
)	O
{	O
WispObject	struct
*	O
object	pointer
;	O
object	pointer
=	O
allocate_object	function
(	O
)	O
;	O
object	pointer
->	O
type	enum
=	O
LT_cons	int
;	O
CAR	O
(	O
object	pointer
)	O
=	O
car	pointer
;	O
CDR	O
(	O
object	pointer
)	O
=	O
cdr	pointer
;	O
return	O
(	O
object	pointer
)	O
;	O
}	O
WispObject	struct
*	O
make_list	function
(	O
WispObject	struct
*	O
car	pointer
,	O
WispObject	struct
*	O
cdr	pointer
)	O
{	O
WispObject	struct
*	O
list	pointer
;	O
list	pointer
=	O
make_cons	function
(	O
cdr	pointer
,	O
NIL	O
)	O
;	O
list	pointer
=	O
make_cons	function
(	O
car	pointer
,	O
list	pointer
)	O
;	O
return	O
(	O
list	pointer
)	O
;	O
}	O
char	O
*	O
string_from_wisp	function
(	O
WispObject	struct
*	O
object	pointer
)	O
{	O
initialize_string_buffer	function
(	O
)	O
;	O
print_object_to_string_buffer	function
(	O
object	pointer
)	O
;	O
return	O
(	O
get_string_buffer	function
(	O
)	O
)	O
;	O
}	O
WispObject	struct
*	O
wisp_from_string	function
(	O
char	O
*	O
string	pointer
)	O
{	O
WispObject	struct
*	O
object	pointer
;	O
if	O
(	O
(	O
string	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
||	O
(	O
*	O
string	pointer
==	O
'\0'	O
)	O
)	O
return	O
(	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
;	O
wisp_push_input_string	function
(	O
string	pointer
)	O
;	O
object	pointer
=	O
wisp_read	function
(	O
)	O
;	O
wisp_pop_input_string	function
(	O
)	O
;	O
return	O
(	O
object	pointer
)	O
;	O
}	O
WispObject	struct
*	O
wisp_read	function
(	O
)	O
{	O
WispObject	struct
*	O
object	pointer
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
int	O
reading_object	int
=	O
1	int
;	O
while	O
(	O
reading_object	int
)	O
{	O
int	O
character	int
;	O
character	int
=	O
read_character	function
(	O
)	O
;	O
switch	O
(	O
character	int
)	O
{	O
case	O
EOF	O
:	O
reading_object	int
=	O
0	int
;	O
break	O
;	O
case	O
'"'	O
:	O
{	O
char	O
*	O
string	pointer
;	O
string	pointer
=	O
read_string	function
(	O
)	O
;	O
object	pointer
=	O
make_string_object	function
(	O
string	pointer
)	O
;	O
free	function
(	O
string	pointer
)	O
;	O
reading_object	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'\''	O
:	O
object	pointer
=	O
wisp_read	function
(	O
)	O
;	O
reading_object	int
=	O
0	int
;	O
break	O
;	O
case	O
'('	O
:	O
{	O
WispObject	struct
*	O
list	pointer
;	O
list	pointer
=	O
read_list	function
(	O
)	O
;	O
if	O
(	O
list	pointer
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
object	pointer
=	O
NIL	O
;	O
else	O
object	pointer
=	O
list	pointer
;	O
reading_object	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
')'	O
:	O
reading_object	int
=	O
0	int
;	O
break	O
;	O
case	O
'\t'	O
:	O
case	O
' '	O
:	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
break	O
;	O
case	O
';'	O
:	O
while	O
(	O
(	O
(	O
character	int
=	O
read_character	function
(	O
)	O
)	O
!=	O
EOF	O
)	O
&&	O
(	O
character	int
!=	O
'\n'	O
)	O
)	O
;	O
break	O
;	O
default	O
:	O
{	O
unread_character	function
(	O
)	O
;	O
object	pointer
=	O
read_symbol_or_number	function
(	O
)	O
;	O
reading_object	int
=	O
0	int
;	O
if	O
(	O
(	O
(	O
STRING_P	O
(	O
object	pointer
)	O
)	O
&&	O
(	O
strcmp	function
(	O
STRING_VALUE	O
(	O
object	pointer
)	O
,	O
"."	pointer
)	O
==	O
0	int
)	O
)	O
||	O
(	O
(	O
SYMBOL_P	O
(	O
object	pointer
)	O
)	O
&&	O
(	O
strcmp	function
(	O
SYMBOL_PNAME	O
(	O
object	pointer
)	O
,	O
"."	pointer
)	O
==	O
0	int
)	O
)	O
)	O
{	O
obarray_del	function
(	O
object	pointer
)	O
;	O
free	function
(	O
object	pointer
->	O
val	union
.	O
string	pointer
)	O
;	O
free	function
(	O
object	pointer
)	O
;	O
object	pointer
=	O
&	O
wisp_dot_value	struct
;	O
}	O
}	O
break	O
;	O
}	O
}	O
return	O
(	O
object	pointer
)	O
;	O
}	O
static	O
char	O
*	O
read_string_1	function
(	O
int	O
delimited	int
)	O
{	O
char	O
*	O
string	pointer
;	O
int	O
string_index	int
,	O
string_size	int
;	O
int	O
chars_to_read	int
=	O
1	int
;	O
string	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
)	O
;	O
*	O
string	pointer
=	O
'\0'	O
;	O
string_index	int
=	O
0	int
;	O
string_size	int
=	O
1	int
;	O
while	O
(	O
chars_to_read	int
)	O
{	O
int	O
character	int
;	O
character	int
=	O
read_character	function
(	O
)	O
;	O
if	O
(	O
character	int
==	O
EOF	O
)	O
{	O
chars_to_read	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
delimited	int
)	O
{	O
if	O
(	O
self_delimiting	O
(	O
character	int
)	O
)	O
unread_character	function
(	O
)	O
;	O
if	O
(	O
whitespace_or_newline	O
(	O
character	int
)	O
||	O
self_delimiting	O
(	O
character	int
)	O
)	O
{	O
chars_to_read	int
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
switch	O
(	O
character	int
)	O
{	O
case	O
'\\'	O
:	O
character	int
=	O
read_character	function
(	O
)	O
;	O
switch	O
(	O
character	int
)	O
{	O
case	O
'n'	O
:	O
case	O
'r'	O
:	O
character	int
=	O
'\n'	O
;	O
break	O
;	O
case	O
't'	O
:	O
character	int
=	O
'\t'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
character	int
=	O
'\f'	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
continue	O
;	O
}	O
if	O
(	O
string_index	int
+	O
1	int
>=	O
string_size	int
)	O
string	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
string	pointer
,	O
(	O
string_size	int
+=	O
20	int
)	O
)	O
;	O
string	pointer
[	O
string_index	int
++	O
]	O
=	O
character	int
;	O
string	pointer
[	O
string_index	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'"'	O
:	O
chars_to_read	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
string_index	int
+	O
1	int
>=	O
string_size	int
)	O
string	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
string	pointer
,	O
(	O
string_size	int
+=	O
20	int
)	O
)	O
;	O
string	pointer
[	O
string_index	int
++	O
]	O
=	O
character	int
;	O
string	pointer
[	O
string_index	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
return	O
(	O
string	pointer
)	O
;	O
}	O
static	O
char	O
*	O
read_string	function
(	O
)	O
{	O
return	O
(	O
read_string_1	function
(	O
1	int
)	O
)	O
;	O
}	O
static	O
WispObject	struct
*	O
read_symbol_or_number	function
(	O
void	O
)	O
{	O
char	O
*	O
string	pointer
;	O
string	pointer
=	O
read_string_1	function
(	O
0	int
)	O
;	O
{	O
WispObject	struct
*	O
result	pointer
;	O
result	pointer
=	O
make_string_object	function
(	O
string	pointer
)	O
;	O
free	function
(	O
string	pointer
)	O
;	O
return	O
(	O
result	pointer
)	O
;	O
}	O
}	O
static	O
WispObject	struct
*	O
read_list	function
(	O
void	O
)	O
{	O
WispObject	struct
*	O
list	pointer
,	O
*	O
val_read	pointer
;	O
val_read	pointer
=	O
wisp_read	function
(	O
)	O
;	O
if	O
(	O
val_read	pointer
==	O
&	O
wisp_dot_value	struct
)	O
{	O
WispObject	struct
*	O
next_val	pointer
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
val_read	pointer
=	O
wisp_read	function
(	O
)	O
;	O
if	O
(	O
val_read	pointer
!=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
{	O
next_val	pointer
=	O
wisp_read	function
(	O
)	O
;	O
if	O
(	O
next_val	pointer
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
return	O
(	O
val_read	pointer
)	O
;	O
else	O
{	O
WispObject	struct
*	O
new_list	pointer
=	O
allocate_object	function
(	O
)	O
;	O
new_list	pointer
->	O
type	enum
=	O
LT_cons	int
;	O
CAR	O
(	O
new_list	pointer
)	O
=	O
val_read	pointer
;	O
CDR	O
(	O
new_list	pointer
)	O
=	O
make_cons	function
(	O
next_val	pointer
,	O
read_list	function
(	O
)	O
)	O
;	O
return	O
(	O
new_list	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
val_read	pointer
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
list	pointer
=	O
NIL	O
;	O
else	O
{	O
list	pointer
=	O
allocate_object	function
(	O
)	O
;	O
list	pointer
->	O
type	enum
=	O
LT_cons	int
;	O
CAR	O
(	O
list	pointer
)	O
=	O
val_read	pointer
;	O
CDR	O
(	O
list	pointer
)	O
=	O
read_list	function
(	O
)	O
;	O
}	O
return	O
(	O
list	pointer
)	O
;	O
}	O
static	O
void	O
print_object_to_string_buffer	function
(	O
WispObject	struct
*	O
object	pointer
)	O
{	O
if	O
(	O
object	pointer
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
switch	O
(	O
object	pointer
->	O
type	enum
)	O
{	O
case	O
LT_string	int
:	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
string	pointer
,	O
*	O
pr	pointer
;	O
string	pointer
=	O
STRING_VALUE	O
(	O
object	pointer
)	O
;	O
pr	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
(	O
2	int
*	O
STRING_LENGTH	O
(	O
object	pointer
)	O
)	O
+	O
1	int
)	O
;	O
j	int
=	O
0	int
;	O
pr	pointer
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
string	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
string	pointer
[	O
i	int
]	O
!=	O
'\0'	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
string	pointer
[	O
i	int
]	O
==	O
'"'	O
)	O
pr	pointer
[	O
j	int
++	O
]	O
=	O
'\\'	O
;	O
pr	pointer
[	O
j	int
++	O
]	O
=	O
string	pointer
[	O
i	int
]	O
;	O
}	O
pr	pointer
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
pr	pointer
[	O
j	int
++	O
]	O
=	O
'\0'	O
;	O
print_string_to_string_buffer	function
(	O
pr	pointer
)	O
;	O
free	function
(	O
pr	pointer
)	O
;	O
}	O
break	O
;	O
case	O
LT_number	int
:	O
{	O
char	O
float_rep	array
[	O
100	int
]	O
;	O
sprintf	function
(	O
float_rep	array
,	O
"\"%.2f\""	pointer
,	O
NUMBER_VALUE	O
(	O
object	pointer
)	O
)	O
;	O
print_string_to_string_buffer	function
(	O
float_rep	array
)	O
;	O
}	O
break	O
;	O
case	O
LT_cons	int
:	O
if	O
(	O
CAR	O
(	O
object	pointer
)	O
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
else	O
{	O
print_string_to_string_buffer	function
(	O
"("	pointer
)	O
;	O
print_list_contents	function
(	O
object	pointer
)	O
;	O
print_string_to_string_buffer	function
(	O
")"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
LT_symbol	int
:	O
print_string_to_string_buffer	function
(	O
SYMBOL_PNAME	O
(	O
object	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LT_nil	int
:	O
print_string_to_string_buffer	function
(	O
"()"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
print_list_contents	function
(	O
WispObject	struct
*	O
list	pointer
)	O
{	O
if	O
(	O
NIL_P	O
(	O
list	pointer
)	O
)	O
return	O
;	O
print_object_to_string_buffer	function
(	O
CAR	O
(	O
list	pointer
)	O
)	O
;	O
if	O
(	O
!	O
NIL_P	O
(	O
CDR	O
(	O
list	pointer
)	O
)	O
)	O
{	O
print_string_to_string_buffer	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
CONS_P	O
(	O
CDR	O
(	O
list	pointer
)	O
)	O
)	O
print_list_contents	function
(	O
CDR	O
(	O
list	pointer
)	O
)	O
;	O
else	O
{	O
print_string_to_string_buffer	function
(	O
". "	pointer
)	O
;	O
print_object_to_string_buffer	function
(	O
CDR	O
(	O
list	pointer
)	O
)	O
;	O
}	O
}	O
}	O
static	O
char	O
*	O
string_buffer	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
sb_index	int
=	O
0	int
;	O
static	O
int	O
sb_size	int
=	O
0	int
;	O
static	O
void	O
initialize_string_buffer	function
(	O
)	O
{	O
sb_index	int
=	O
0	int
;	O
if	O
(	O
string_buffer	pointer
)	O
string_buffer	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
char	O
*	O
get_string_buffer	function
(	O
)	O
{	O
return	O
(	O
string_buffer	pointer
)	O
;	O
}	O
static	O
void	O
print_string_to_string_buffer	function
(	O
char	O
*	O
string	pointer
)	O
{	O
int	O
len	int
=	O
0	int
;	O
if	O
(	O
string	pointer
)	O
len	int
+=	O
strlen	function
(	O
string	pointer
)	O
;	O
if	O
(	O
!	O
len	int
)	O
return	O
;	O
while	O
(	O
(	O
sb_index	int
+	O
len	int
)	O
>=	O
sb_size	int
)	O
string_buffer	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
string_buffer	pointer
,	O
(	O
sb_size	int
+=	O
EXPANSION	int
)	O
)	O
;	O
strcpy	function
(	O
string_buffer	pointer
+	O
sb_index	int
,	O
string	pointer
)	O
;	O
sb_index	int
+=	O
len	int
;	O
}	O
static	O
char	O
*	O
the_input_string	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
int	O
the_input_string_index	int
=	O
0	int
;	O
void	O
wisp_push_input_string	function
(	O
char	O
*	O
string	pointer
)	O
{	O
the_input_string	pointer
=	O
string	pointer
;	O
the_input_string_index	int
=	O
0	int
;	O
}	O
void	O
wisp_pop_input_string	function
(	O
)	O
{	O
the_input_string	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
the_input_string_index	int
=	O
0	int
;	O
}	O
static	O
int	O
read_character	function
(	O
)	O
{	O
int	O
character	int
=	O
EOF	O
;	O
if	O
(	O
(	O
the_input_string	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
the_input_string	pointer
[	O
the_input_string_index	int
]	O
!=	O
'\0'	O
)	O
)	O
character	int
=	O
the_input_string	pointer
[	O
the_input_string_index	int
++	O
]	O
&	O
0x00ff	int
;	O
return	O
(	O
character	int
)	O
;	O
}	O
static	O
void	O
unread_character	function
(	O
void	O
)	O
{	O
if	O
(	O
(	O
the_input_string	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
||	O
(	O
the_input_string_index	int
==	O
0	int
)	O
)	O
return	O
;	O
the_input_string_index	int
--	O
;	O
}	O
char	O
*	O
wisp_readable	function
(	O
char	O
*	O
string	pointer
)	O
{	O
int	O
len	int
=	O
(	O
string	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
?	O
1	int
:	O
(	O
3	int
+	O
(	O
2	int
*	O
strlen	function
(	O
string	pointer
)	O
)	O
)	O
;	O
static	O
char	O
*	O
result	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
result	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
result	pointer
,	O
len	int
)	O
;	O
if	O
(	O
string	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
j	int
=	O
0	int
;	O
result	pointer
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string	pointer
[	O
i	int
]	O
!=	O
'\0'	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
string	pointer
[	O
i	int
]	O
==	O
'"'	O
)	O
||	O
(	O
string	pointer
[	O
i	int
]	O
==	O
'\\'	O
)	O
)	O
result	pointer
[	O
j	int
++	O
]	O
=	O
'\\'	O
;	O
result	pointer
[	O
j	int
++	O
]	O
=	O
string	pointer
[	O
i	int
]	O
;	O
}	O
result	pointer
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
result	pointer
[	O
j	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
result	pointer
[	O
0	int
]	O
=	O
'0'	O
;	O
}	O
return	O
(	O
result	pointer
)	O
;	O
}	O
WispObject	struct
*	O
assoc	function
(	O
char	O
*	O
key	pointer
,	O
WispObject	struct
*	O
list	pointer
)	O
{	O
while	O
(	O
CONS_P	O
(	O
list	pointer
)	O
&&	O
CONS_P	O
(	O
CAR	O
(	O
list	pointer
)	O
)	O
)	O
{	O
WispObject	struct
*	O
pair	pointer
,	O
*	O
car	pointer
;	O
pair	pointer
=	O
CAR	O
(	O
list	pointer
)	O
;	O
car	pointer
=	O
CAR	O
(	O
pair	pointer
)	O
;	O
if	O
(	O
STRING_P	O
(	O
car	pointer
)	O
&&	O
(	O
strcasecmp	function
(	O
STRING_VALUE	O
(	O
car	pointer
)	O
,	O
key	pointer
)	O
==	O
0	int
)	O
)	O
return	O
(	O
pair	pointer
)	O
;	O
list	pointer
=	O
CDR	O
(	O
list	pointer
)	O
;	O
}	O
return	O
(	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
;	O
}	O
char	O
*	O
sassoc	function
(	O
char	O
*	O
key	pointer
,	O
WispObject	struct
*	O
list	pointer
)	O
{	O
WispObject	struct
*	O
result	pointer
;	O
result	pointer
=	O
assoc	function
(	O
key	pointer
,	O
list	pointer
)	O
;	O
if	O
(	O
(	O
result	pointer
!=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
&&	O
(	O
CONS_P	O
(	O
result	pointer
)	O
)	O
&&	O
(	O
STRING_P	O
(	O
CAR	O
(	O
CDR	O
(	O
result	pointer
)	O
)	O
)	O
)	O
)	O
return	O
(	O
STRING_VALUE	O
(	O
CAR	O
(	O
CDR	O
(	O
result	pointer
)	O
)	O
)	O
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
WispObject	struct
*	O
wisp_append	function
(	O
WispObject	struct
*	O
list	pointer
,	O
WispObject	struct
*	O
object	pointer
)	O
{	O
WispObject	struct
*	O
last_cons	pointer
=	O
list	pointer
;	O
if	O
(	O
NIL_P	O
(	O
list	pointer
)	O
)	O
return	O
(	O
object	pointer
)	O
;	O
while	O
(	O
CONS_P	O
(	O
last_cons	pointer
)	O
)	O
{	O
if	O
(	O
NIL_P	O
(	O
CDR	O
(	O
last_cons	pointer
)	O
)	O
)	O
{	O
CDR	O
(	O
last_cons	pointer
)	O
=	O
object	pointer
;	O
return	O
(	O
list	pointer
)	O
;	O
}	O
last_cons	pointer
=	O
CDR	O
(	O
last_cons	pointer
)	O
;	O
}	O
abort	function
(	O
)	O
;	O
}	O
WispObject	struct
*	O
copy_object	function
(	O
WispObject	struct
*	O
object	pointer
)	O
{	O
WispObject	struct
*	O
copy	pointer
=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
object	pointer
==	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
return	O
(	O
object	pointer
)	O
;	O
copy	pointer
=	O
allocate_object	function
(	O
)	O
;	O
copy	pointer
->	O
type	enum
=	O
object	pointer
->	O
type	enum
;	O
switch	O
(	O
object	pointer
->	O
type	enum
)	O
{	O
case	O
LT_string	int
:	O
copy	pointer
->	O
val	union
.	O
string	pointer
=	O
strdup	function
(	O
STRING_VALUE	O
(	O
object	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LT_number	int
:	O
copy	pointer
->	O
val	union
.	O
number	double
=	O
NUMBER_VALUE	O
(	O
object	pointer
)	O
;	O
break	O
;	O
case	O
LT_cons	int
:	O
CAR	O
(	O
copy	pointer
)	O
=	O
copy_object	function
(	O
CAR	O
(	O
object	pointer
)	O
)	O
;	O
CDR	O
(	O
copy	pointer
)	O
=	O
copy_object	function
(	O
CDR	O
(	O
object	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LT_symbol	int
:	O
copy	pointer
->	O
val	union
.	O
symbol	pointer
=	O
object	pointer
->	O
val	union
.	O
symbol	pointer
;	O
break	O
;	O
case	O
LT_nil	int
:	O
free	function
(	O
copy	pointer
)	O
;	O
copy	pointer
=	O
NIL	O
;	O
}	O
return	O
(	O
copy	pointer
)	O
;	O
}	O
WispObject	struct
*	O
wisp_nth	function
(	O
int	O
n	int
,	O
WispObject	struct
*	O
list	pointer
)	O
{	O
WispObject	struct
*	O
result	pointer
=	O
NIL	O
;	O
while	O
(	O
(	O
CONS_P	O
(	O
list	pointer
)	O
)	O
&&	O
(	O
n	int
>	O
0	int
)	O
)	O
{	O
--	O
n	int
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
result	pointer
=	O
CAR	O
(	O
list	pointer
)	O
;	O
break	O
;	O
}	O
else	O
list	pointer
=	O
CDR	O
(	O
list	pointer
)	O
;	O
}	O
return	O
(	O
result	pointer
)	O
;	O
}	O
int	O
wisp_length	function
(	O
WispObject	struct
*	O
object	pointer
)	O
{	O
int	O
result	pointer
=	O
0	int
;	O
if	O
(	O
object	pointer
!=	O
(	O
WispObject	struct
*	O
)	O
NULL	O
)	O
{	O
switch	O
(	O
object	pointer
->	O
type	enum
)	O
{	O
case	O
LT_nil	int
:	O
break	O
;	O
case	O
LT_string	int
:	O
result	pointer
=	O
strlen	function
(	O
STRING_VALUE	O
(	O
object	pointer
)	O
)	O
;	O
break	O
;	O
case	O
LT_cons	int
:	O
{	O
while	O
(	O
CONS_P	O
(	O
object	pointer
)	O
)	O
{	O
result	pointer
++	O
;	O
object	pointer
=	O
CDR	O
(	O
object	pointer
)	O
;	O
if	O
(	O
!	O
CONS_P	O
(	O
object	pointer
)	O
&&	O
!	O
NIL_P	O
(	O
object	pointer
)	O
)	O
result	pointer
++	O
;	O
}	O
break	O
;	O
case	O
LT_number	int
:	O
{	O
char	O
buffer	array
[	O
100	int
]	O
;	O
sprintf	function
(	O
buffer	array
,	O
"%f"	pointer
,	O
NUMBER_VALUE	O
(	O
object	pointer
)	O
)	O
;	O
result	pointer
=	O
strlen	function
(	O
buffer	array
)	O
;	O
}	O
break	O
;	O
case	O
LT_symbol	int
:	O
result	pointer
=	O
strlen	function
(	O
SYMBOL_PNAME	O
(	O
object	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
(	O
result	pointer
)	O
;	O
}	O
