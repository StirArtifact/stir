int	O
find_input_ranges	function
(	O
out_string	pointer
,	O
input_record	pointer
,	O
ranges	pointer
,	O
range_count	int
,	O
end_range_start	long
,	O
input_delimiter	pointer
,	O
input_delimiter_repeat	int
,	O
output_delimiter	pointer
)	O
STRINGTYPE	O
*	O
out_string	pointer
;	O
STRINGTYPE	O
*	O
input_record	pointer
;	O
field_range	struct
*	O
ranges	pointer
;	O
int	O
range_count	int
;	O
size_t	long
end_range_start	long
;	O
STRINGTYPE	O
*	O
input_delimiter	pointer
;	O
int	O
input_delimiter_repeat	int
;	O
STRINGTYPE	O
*	O
output_delimiter	pointer
;	O
{	O
int	O
i	int
;	O
int	O
j	int
;	O
STRINGTYPE	O
*	O
*	O
field_list	pointer
;	O
int	O
field_list_length	int
;	O
int	O
return_code	int
;	O
if	O
(	O
input_delimiter	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
dstrsplit	function
(	O
input_record	pointer
,	O
input_delimiter	pointer
,	O
&	O
field_list	pointer
,	O
&	O
field_list_length	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
return_code	int
==	O
DSTR_EMEMORY	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"internal error: invalid string descriptor"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
input_delimiter_repeat	int
)	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
field_list_length	int
)	O
{	O
if	O
(	O
field_list	pointer
[	O
i	int
]	O
->	O
length	long
==	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
field_list_length	int
;	O
j	int
++	O
)	O
field_list	pointer
[	O
j	int
-	O
1	int
]	O
=	O
field_list	pointer
[	O
j	int
]	O
;	O
field_list_length	int
--	O
;	O
}	O
else	O
i	int
++	O
;	O
}	O
field_list	pointer
=	O
realloc	function
(	O
field_list	pointer
,	O
field_list_length	int
*	O
sizeof	O
(	O
*	O
field_list	pointer
)	O
)	O
;	O
if	O
(	O
field_list	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
range_count	int
;	O
i	int
++	O
)	O
{	O
STRINGTYPE	O
*	O
temp_string	pointer
;	O
STRINGTYPE	O
*	O
other_string	pointer
;	O
if	O
(	O
out_string	pointer
->	O
length	long
>	O
0	int
&&	O
output_delimiter	pointer
!=	O
NULL	O
)	O
dstrcat	function
(	O
out_string	pointer
,	O
output_delimiter	pointer
)	O
;	O
if	O
(	O
input_delimiter	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
<	O
0	int
||	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
>	O
field_list_length	int
)	O
FATAL_ERROR2	O
(	O
_	O
(	O
"bad field substring -- wanted field %ld from %d fields"	pointer
)	O
,	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
,	O
field_list_length	int
)	O
;	O
temp_string	pointer
=	O
field_list	pointer
[	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
-	O
1	int
]	O
;	O
}	O
else	O
{	O
temp_string	pointer
=	O
dstrsubstr	function
(	O
input_record	pointer
,	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
,	O
ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
,	O
0	int
,	O
DStr_not_own	int
)	O
;	O
if	O
(	O
temp_string	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
>	O
0	int
||	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
>	O
ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
||	O
ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
>	O
input_record	pointer
->	O
length	long
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	pointer
)	O
,	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
,	O
ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
,	O
input_record	pointer
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
}	O
other_string	pointer
=	O
dstrcat	function
(	O
out_string	pointer
,	O
temp_string	pointer
)	O
;	O
if	O
(	O
other_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
if	O
(	O
input_delimiter	pointer
==	O
NULL	O
||	O
ranges	pointer
[	O
i	int
]	O
.	O
format	pointer
!=	O
NULL	O
)	O
dstrfree	function
(	O
temp_string	pointer
)	O
;	O
}	O
if	O
(	O
end_range_start	long
!=	O
0	int
)	O
{	O
STRINGTYPE	O
*	O
temp_string	pointer
;	O
STRINGTYPE	O
*	O
other_string	pointer
;	O
if	O
(	O
out_string	pointer
->	O
length	long
>	O
0	int
&&	O
output_delimiter	pointer
!=	O
NULL	O
)	O
dstrcat	function
(	O
out_string	pointer
,	O
output_delimiter	pointer
)	O
;	O
temp_string	pointer
=	O
dstrsubstr	function
(	O
input_record	pointer
,	O
end_range_start	long
,	O
input_record	pointer
->	O
length	long
,	O
0	int
,	O
DStr_not_own	int
)	O
;	O
if	O
(	O
temp_string	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
end_range_start	long
>	O
input_record	pointer
->	O
length	long
||	O
end_range_start	long
<	O
0	int
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	pointer
)	O
,	O
end_range_start	long
,	O
input_record	pointer
->	O
length	long
,	O
input_record	pointer
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
other_string	pointer
=	O
dstrcat	function
(	O
out_string	pointer
,	O
temp_string	pointer
)	O
;	O
if	O
(	O
other_string	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
dstrfree	function
(	O
temp_string	pointer
)	O
;	O
}	O
if	O
(	O
input_delimiter	pointer
!=	O
NULL	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_list_length	int
;	O
i	int
++	O
)	O
dstrfree	function
(	O
field_list	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
field_list	pointer
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
a_find_input_ranges	function
(	O
out_ranges	pointer
,	O
input_record	pointer
,	O
ranges	pointer
,	O
range_count	int
,	O
end_range_start	long
,	O
input_delimiter	pointer
,	O
input_delimiter_repeat	int
,	O
make_copy	enum
,	O
output_delimiter	pointer
,	O
empty_replacement	pointer
)	O
STRINGTYPE	O
*	O
*	O
*	O
out_ranges	pointer
;	O
STRINGTYPE	O
*	O
input_record	pointer
;	O
field_range	struct
*	O
ranges	pointer
;	O
int	O
range_count	int
;	O
size_t	long
end_range_start	long
;	O
STRINGTYPE	O
*	O
input_delimiter	pointer
;	O
int	O
input_delimiter_repeat	int
;	O
DStr_codes	enum
make_copy	enum
;	O
STRINGTYPE	O
*	O
output_delimiter	pointer
;	O
STRINGTYPE	O
*	O
empty_replacement	pointer
;	O
{	O
int	O
i	int
;	O
int	O
j	int
;	O
STRINGTYPE	O
*	O
*	O
field_list	pointer
;	O
int	O
field_list_length	int
;	O
int	O
return_code	int
;	O
if	O
(	O
input_delimiter	pointer
!=	O
NULL	O
)	O
{	O
return_code	int
=	O
dstrsplit	function
(	O
input_record	pointer
,	O
input_delimiter	pointer
,	O
&	O
field_list	pointer
,	O
&	O
field_list_length	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
return_code	int
==	O
DSTR_EMEMORY	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"internal error: invalid string descriptor"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
input_delimiter_repeat	int
)	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
field_list_length	int
)	O
{	O
if	O
(	O
field_list	pointer
[	O
i	int
]	O
->	O
length	long
==	O
0	int
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
field_list_length	int
;	O
j	int
++	O
)	O
field_list	pointer
[	O
j	int
-	O
1	int
]	O
=	O
field_list	pointer
[	O
j	int
]	O
;	O
if	O
(	O
i	int
<	O
field_list_length	int
-	O
1	int
)	O
field_list_length	int
--	O
;	O
else	O
i	int
++	O
;	O
}	O
else	O
i	int
++	O
;	O
}	O
field_list	pointer
=	O
realloc	function
(	O
field_list	pointer
,	O
field_list_length	int
*	O
sizeof	O
(	O
*	O
field_list	pointer
)	O
)	O
;	O
if	O
(	O
field_list	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
}	O
*	O
out_ranges	pointer
=	O
malloc	function
(	O
(	O
range_count	int
+	O
(	O
end_range_start	long
==	O
0	int
?	O
0	int
:	O
1	int
)	O
)	O
*	O
sizeof	O
(	O
STRINGTYPE	O
)	O
)	O
;	O
if	O
(	O
*	O
out_ranges	pointer
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
range_count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
input_delimiter	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
<=	O
field_list_length	int
)	O
{	O
if	O
(	O
empty_replacement	pointer
!=	O
NULL	O
&&	O
field_list	pointer
[	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
-	O
1	int
]	O
->	O
length	long
==	O
0	int
)	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
=	O
dstrdup	function
(	O
empty_replacement	pointer
)	O
;	O
else	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
=	O
dstrdup	function
(	O
field_list	pointer
[	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
-	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
empty_replacement	pointer
!=	O
NULL	O
)	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
=	O
dstrdup	function
(	O
empty_replacement	pointer
)	O
;	O
else	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
=	O
dstrdupstr	function
(	O
""	pointer
)	O
;	O
if	O
(	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
=	O
dstrsubstr	function
(	O
input_record	pointer
,	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
,	O
ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
,	O
0	int
,	O
make_copy	enum
)	O
;	O
if	O
(	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
==	O
NULL	O
)	O
{	O
if	O
(	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
<	O
1	int
||	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
>	O
ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
||	O
ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
>	O
input_record	pointer
->	O
length	long
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	pointer
)	O
,	O
ranges	pointer
[	O
i	int
]	O
.	O
lower_bound	long
,	O
ranges	pointer
[	O
i	int
]	O
.	O
upper_bound	long
,	O
input_record	pointer
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
end_range_start	long
!=	O
0	int
&&	O
input_delimiter	pointer
==	O
NULL	O
)	O
{	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
=	O
dstrsubstr	function
(	O
input_record	pointer
,	O
end_range_start	long
,	O
input_record	pointer
->	O
length	long
,	O
0	int
,	O
make_copy	enum
)	O
;	O
if	O
(	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
==	O
NULL	O
)	O
{	O
if	O
(	O
end_range_start	long
<	O
1	int
||	O
end_range_start	long
>	O
input_record	pointer
->	O
length	long
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	pointer
)	O
,	O
end_range_start	long
,	O
input_record	pointer
->	O
length	long
,	O
input_record	pointer
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
end_range_start	long
!=	O
0	int
&&	O
input_delimiter	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
end_range_start	long
<=	O
field_list_length	int
)	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
=	O
dstrdup	function
(	O
field_list	pointer
[	O
end_range_start	long
-	O
1	int
]	O
)	O
;	O
else	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
=	O
dstrdupstr	function
(	O
""	pointer
)	O
;	O
j	int
=	O
end_range_start	long
;	O
while	O
(	O
j	int
<	O
field_list_length	int
)	O
{	O
if	O
(	O
output_delimiter	pointer
!=	O
NULL	O
)	O
dstrcat	function
(	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
,	O
output_delimiter	pointer
)	O
;	O
if	O
(	O
empty_replacement	pointer
==	O
NULL	O
||	O
field_list	pointer
[	O
j	int
]	O
->	O
length	long
!=	O
0	int
)	O
dstrcat	function
(	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
,	O
field_list	pointer
[	O
j	int
]	O
)	O
;	O
else	O
dstrcat	function
(	O
(	O
*	O
out_ranges	pointer
)	O
[	O
i	int
]	O
,	O
empty_replacement	pointer
)	O
;	O
j	int
++	O
;	O
}	O
}	O
if	O
(	O
input_delimiter	pointer
!=	O
NULL	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_list_length	int
;	O
i	int
++	O
)	O
dstrfree	function
(	O
field_list	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
field_list	pointer
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
field_id	struct
*	O
parse_field_order_string	function
(	O
string	pointer
,	O
field_count	pointer
)	O
STRINGTYPE	O
*	O
string	pointer
;	O
int	O
*	O
field_count	pointer
;	O
{	O
field_id	struct
*	O
return_array	pointer
;	O
char	O
*	O
curr_pos	pointer
;	O
int	O
i	int
;	O
STRINGTYPE	O
*	O
*	O
field_list	pointer
;	O
int	O
field_list_length	int
;	O
int	O
field_list_extra	int
;	O
int	O
return_code	int
;	O
STRINGTYPE	O
delimiter	struct
;	O
delimiter	struct
.	O
length	long
=	O
1	int
;	O
delimiter	struct
.	O
string	pointer
=	O
","	pointer
;	O
field_list_extra	int
=	O
0	int
;	O
return_code	int
=	O
dstrsplit	function
(	O
string	pointer
,	O
&	O
delimiter	struct
,	O
&	O
field_list	pointer
,	O
&	O
field_list_length	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
return_code	int
==	O
DSTR_EMEMORY	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"internal error: invalid string descriptor"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
field_list_length	int
==	O
0	int
)	O
return	O
NULL	O
;	O
return_array	pointer
=	O
malloc	function
(	O
field_list_length	int
*	O
sizeof	O
(	O
field_id	struct
)	O
)	O
;	O
if	O
(	O
return_array	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_list_length	int
;	O
i	int
++	O
)	O
{	O
curr_pos	pointer
=	O
field_list	pointer
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
string	pointer
;	O
switch	O
(	O
*	O
curr_pos	pointer
)	O
{	O
case	O
'r'	O
:	O
case	O
'd'	O
:	O
case	O
'o'	O
:	O
case	O
's'	O
:	O
return_array	pointer
[	O
i	int
]	O
.	O
source	char
=	O
*	O
curr_pos	pointer
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR2	O
(	O
_	O
(	O
"field order specification starts with %c:  only %s are supported"	pointer
)	O
,	O
*	O
curr_pos	pointer
,	O
"r, d, o, s"	pointer
)	O
;	O
}	O
curr_pos	pointer
++	O
;	O
return_array	pointer
[	O
i	int
]	O
.	O
source_num	int
=	O
strtol	function
(	O
curr_pos	pointer
,	O
&	O
curr_pos	pointer
,	O
0	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
&&	O
(	O
return_array	pointer
[	O
i	int
]	O
.	O
source_num	int
==	O
LONG_MIN	O
||	O
return_array	pointer
[	O
i	int
]	O
.	O
source_num	int
==	O
LONG_MAX	O
)	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"number out of range in field order specification"	pointer
)	O
)	O
;	O
if	O
(	O
*	O
curr_pos	pointer
==	O
'.'	O
)	O
curr_pos	pointer
++	O
;	O
else	O
FATAL_ERROR2	O
(	O
_	O
(	O
"badly formed field order specification: %.*s"	pointer
)	O
,	O
field_list	pointer
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
length	long
,	O
field_list	pointer
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
string	pointer
)	O
;	O
switch	O
(	O
*	O
curr_pos	pointer
)	O
{	O
case	O
'o'	O
:	O
case	O
'k'	O
:	O
case	O
'f'	O
:	O
case	O
'n'	O
:	O
case	O
's'	O
:	O
case	O
'e'	O
:	O
return_array	pointer
[	O
i	int
]	O
.	O
type	char
=	O
*	O
curr_pos	pointer
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR3	O
(	O
_	O
(	O
"badly formed field order specification: type %c unknown: %.*s"	pointer
)	O
,	O
*	O
curr_pos	pointer
,	O
field_list	pointer
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
length	long
,	O
field_list	pointer
[	O
i	int
-	O
field_list_extra	int
]	O
->	O
string	pointer
)	O
;	O
}	O
curr_pos	pointer
++	O
;	O
if	O
(	O
*	O
curr_pos	pointer
==	O
'-'	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"field number started with -; use a positive number or range 1-n"	pointer
)	O
)	O
;	O
return_array	pointer
[	O
i	int
]	O
.	O
type_num	int
=	O
strtol	function
(	O
curr_pos	pointer
,	O
&	O
curr_pos	pointer
,	O
0	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
&&	O
(	O
return_array	pointer
[	O
i	int
]	O
.	O
type_num	int
==	O
LONG_MIN	O
||	O
return_array	pointer
[	O
i	int
]	O
.	O
type_num	int
==	O
LONG_MAX	O
)	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"number out of range in field order specification"	pointer
)	O
)	O
;	O
if	O
(	O
*	O
curr_pos	pointer
==	O
'-'	O
)	O
{	O
int	O
upper_bound	long
;	O
int	O
lower_bound	long
;	O
int	O
j	int
;	O
curr_pos	pointer
++	O
;	O
if	O
(	O
*	O
curr_pos	pointer
==	O
','	O
||	O
*	O
curr_pos	pointer
==	O
'\0'	O
)	O
{	O
return_array	pointer
[	O
i	int
]	O
.	O
type_num	int
*=	O
-	O
1	int
;	O
}	O
else	O
{	O
lower_bound	long
=	O
return_array	pointer
[	O
i	int
]	O
.	O
type_num	int
+	O
1	int
;	O
upper_bound	long
=	O
strtol	function
(	O
curr_pos	pointer
,	O
&	O
curr_pos	pointer
,	O
0	int
)	O
;	O
if	O
(	O
errno	O
==	O
ERANGE	int
&&	O
(	O
upper_bound	long
==	O
LONG_MIN	O
||	O
upper_bound	long
==	O
LONG_MAX	O
)	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"number out of range in field order specification"	pointer
)	O
)	O
;	O
field_list_length	int
+=	O
upper_bound	long
-	O
lower_bound	long
+	O
1	int
;	O
return_array	pointer
=	O
realloc	function
(	O
return_array	pointer
,	O
field_list_length	int
*	O
sizeof	O
(	O
field_id	struct
)	O
)	O
;	O
if	O
(	O
return_array	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
j	int
=	O
lower_bound	long
;	O
j	int
<=	O
upper_bound	long
;	O
j	int
++	O
)	O
{	O
i	int
++	O
;	O
field_list_extra	int
++	O
;	O
return_array	pointer
[	O
i	int
]	O
.	O
source	char
=	O
return_array	pointer
[	O
i	int
-	O
1	int
]	O
.	O
source	char
;	O
return_array	pointer
[	O
i	int
]	O
.	O
source_num	int
=	O
return_array	pointer
[	O
i	int
-	O
1	int
]	O
.	O
source_num	int
;	O
return_array	pointer
[	O
i	int
]	O
.	O
type	char
=	O
return_array	pointer
[	O
i	int
-	O
1	int
]	O
.	O
type	char
;	O
return_array	pointer
[	O
i	int
]	O
.	O
type_num	int
=	O
j	int
;	O
}	O
}	O
}	O
}	O
*	O
field_count	pointer
=	O
field_list_length	int
;	O
return	O
return_array	pointer
;	O
}	O
field_id	struct
*	O
parse_join_order_string	function
(	O
string	pointer
,	O
field_count	pointer
)	O
STRINGTYPE	O
*	O
string	pointer
;	O
int	O
*	O
field_count	pointer
;	O
{	O
field_id	struct
*	O
return_array	pointer
;	O
char	O
*	O
curr_pos	pointer
;	O
int	O
i	int
;	O
int	O
field_list_length	int
;	O
int	O
have_file	int
;	O
return_array	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
field_id	struct
)	O
)	O
;	O
if	O
(	O
return_array	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
curr_pos	pointer
=	O
string	pointer
->	O
string	pointer
;	O
i	int
=	O
0	int
;	O
field_list_length	int
=	O
0	int
;	O
have_file	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
string	pointer
->	O
length	long
)	O
{	O
if	O
(	O
*	O
curr_pos	pointer
==	O
','	O
||	O
*	O
curr_pos	pointer
==	O
' '	O
||	O
*	O
curr_pos	pointer
==	O
'\t'	O
)	O
{	O
i	int
++	O
;	O
curr_pos	pointer
++	O
;	O
have_file	int
=	O
0	int
;	O
field_list_length	int
++	O
;	O
return_array	pointer
=	O
realloc	function
(	O
return_array	pointer
,	O
(	O
field_list_length	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
field_id	struct
)	O
)	O
;	O
if	O
(	O
return_array	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
have_file	int
==	O
0	int
)	O
{	O
switch	O
(	O
*	O
curr_pos	pointer
)	O
{	O
case	O
'0'	O
:	O
i	int
++	O
;	O
curr_pos	pointer
++	O
;	O
if	O
(	O
i	int
<	O
string	pointer
->	O
length	long
&&	O
*	O
curr_pos	pointer
!=	O
','	O
&&	O
*	O
curr_pos	pointer
!=	O
' '	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"the join key (file 0) is misspecified"	pointer
)	O
)	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
source	char
=	O
'r'	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
source_num	int
=	O
1	int
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type	char
=	O
'o'	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type_num	int
=	O
1	int
;	O
field_list_length	int
++	O
;	O
return_array	pointer
=	O
realloc	function
(	O
return_array	pointer
,	O
(	O
field_list_length	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
field_id	struct
)	O
)	O
;	O
if	O
(	O
return_array	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
source	char
=	O
's'	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
source_num	int
=	O
0	int
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type	char
=	O
'o'	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type_num	int
=	O
1	int
;	O
break	O
;	O
case	O
'1'	O
:	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
source	char
=	O
'r'	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
source_num	int
=	O
1	int
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type	char
=	O
'o'	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type_num	int
=	O
0	int
;	O
have_file	int
=	O
-	O
1	int
;	O
i	int
++	O
;	O
curr_pos	pointer
++	O
;	O
if	O
(	O
i	int
>=	O
string	pointer
->	O
length	long
||	O
*	O
curr_pos	pointer
!=	O
'.'	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"did not find '.' where expected in order"	pointer
)	O
)	O
;	O
i	int
++	O
;	O
curr_pos	pointer
++	O
;	O
break	O
;	O
case	O
'2'	O
:	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
source	char
=	O
'd'	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
source_num	int
=	O
0	int
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type	char
=	O
'o'	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type_num	int
=	O
0	int
;	O
have_file	int
=	O
-	O
1	int
;	O
i	int
++	O
;	O
curr_pos	pointer
++	O
;	O
if	O
(	O
i	int
>=	O
string	pointer
->	O
length	long
||	O
*	O
curr_pos	pointer
!=	O
'.'	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"did not find '.' where expected in order"	pointer
)	O
)	O
;	O
i	int
++	O
;	O
curr_pos	pointer
++	O
;	O
break	O
;	O
default	O
:	O
FATAL_ERROR1	O
(	O
_	O
(	O
"file number must be 1 or 2 -- got %c"	pointer
)	O
,	O
*	O
curr_pos	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
curr_pos	pointer
<	O
'0'	O
||	O
*	O
curr_pos	pointer
>	O
'9'	O
)	O
FATAL_ERROR1	O
(	O
_	O
(	O
"non-digit in field number: '%c'"	pointer
)	O
,	O
*	O
curr_pos	pointer
)	O
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type_num	int
*=	O
10	int
;	O
return_array	pointer
[	O
field_list_length	int
]	O
.	O
type_num	int
+=	O
*	O
curr_pos	pointer
-	O
'0'	O
;	O
i	int
++	O
;	O
curr_pos	pointer
++	O
;	O
}	O
}	O
*	O
field_count	pointer
=	O
field_list_length	int
+	O
1	int
;	O
return	O
return_array	pointer
;	O
}	O
STRINGTYPE	O
*	O
find_field	function
(	O
ranges	pointer
,	O
range_count	int
,	O
which_range	int
,	O
input_record	pointer
,	O
input_delimiter	pointer
)	O
field_range	struct
*	O
ranges	pointer
;	O
int	O
range_count	int
;	O
int	O
which_range	int
;	O
STRINGTYPE	O
*	O
input_record	pointer
;	O
STRINGTYPE	O
*	O
input_delimiter	pointer
;	O
{	O
STRINGTYPE	O
*	O
return_string	pointer
;	O
STRINGTYPE	O
*	O
*	O
field_list	pointer
;	O
int	O
field_list_length	int
;	O
int	O
return_code	int
;	O
if	O
(	O
input_delimiter	pointer
!=	O
NULL	O
)	O
{	O
int	O
i	int
;	O
return_code	int
=	O
dstrsplit	function
(	O
input_record	pointer
,	O
input_delimiter	pointer
,	O
&	O
field_list	pointer
,	O
&	O
field_list_length	int
)	O
;	O
if	O
(	O
return_code	int
!=	O
EXIT_SUCCESS	int
)	O
{	O
if	O
(	O
return_code	int
==	O
DSTR_EMEMORY	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"internal error: invalid string descriptor"	pointer
)	O
)	O
;	O
}	O
return_string	pointer
=	O
dstrdup	function
(	O
field_list	pointer
[	O
ranges	pointer
[	O
which_range	int
]	O
.	O
lower_bound	long
-	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_list_length	int
;	O
i	int
++	O
)	O
dstrfree	function
(	O
field_list	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
field_list	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ranges	pointer
[	O
which_range	int
]	O
.	O
lower_bound	long
>	O
input_record	pointer
->	O
length	long
)	O
return	O
NULL	O
;	O
return_string	pointer
=	O
dstrsubstr	function
(	O
input_record	pointer
,	O
ranges	pointer
[	O
which_range	int
]	O
.	O
lower_bound	long
,	O
ranges	pointer
[	O
which_range	int
]	O
.	O
upper_bound	long
,	O
0	int
,	O
DStr_not_own	int
)	O
;	O
if	O
(	O
return_string	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
ranges	pointer
[	O
which_range	int
]	O
.	O
lower_bound	long
>	O
0	int
||	O
ranges	pointer
[	O
which_range	int
]	O
.	O
lower_bound	long
>	O
ranges	pointer
[	O
which_range	int
]	O
.	O
upper_bound	long
||	O
ranges	pointer
[	O
which_range	int
]	O
.	O
upper_bound	long
>	O
input_record	pointer
->	O
length	long
)	O
FATAL_ERROR3	O
(	O
_	O
(	O
"bad field substring -- wanted bytes %ld-%ld in %ld-byte string"	pointer
)	O
,	O
ranges	pointer
[	O
which_range	int
]	O
.	O
lower_bound	long
,	O
ranges	pointer
[	O
which_range	int
]	O
.	O
upper_bound	long
,	O
input_record	pointer
->	O
length	long
)	O
;	O
else	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
}	O
return	O
return_string	pointer
;	O
}	O
int	O
fill_empty_fields	function
(	O
fields	pointer
,	O
field_count	pointer
,	O
empty_replacement	pointer
)	O
STRINGTYPE	O
*	O
*	O
fields	pointer
;	O
size_t	long
field_count	pointer
;	O
STRINGTYPE	O
*	O
empty_replacement	pointer
;	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
field_count	pointer
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fields	pointer
[	O
i	int
]	O
->	O
length	long
==	O
0	int
)	O
{	O
dstrfree	function
(	O
fields	pointer
[	O
i	int
]	O
)	O
;	O
fields	pointer
[	O
i	int
]	O
=	O
dstrdup	function
(	O
empty_replacement	pointer
)	O
;	O
if	O
(	O
fields	pointer
[	O
i	int
]	O
==	O
NULL	O
)	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
