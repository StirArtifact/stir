void	O
_pl_b_paint_path	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
return	O
;	O
switch	O
(	O
(	O
int	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
type	enum
)	O
{	O
case	O
(	O
int	O
)	O
PATH_SEGMENT_LIST	int
:	O
{	O
int	O
i	int
,	O
polyline_len	int
;	O
bool	enum
identical_user_coordinates	enum
=	O
true	int
;	O
double	O
xu_last	double
,	O
yu_last	double
;	O
miGC	struct
*	O
pGC	pointer
;	O
miPoint	struct
*	O
miPoints	pointer
,	O
offset	array
;	O
miPixel	struct
fgPixel	struct
,	O
bgPixel	struct
;	O
miPixel	struct
pixels	pointer
[	O
2	int
]	O
;	O
unsigned	O
char	O
red	int
,	O
green	int
,	O
blue	int
;	O
plPoint	struct
p0	struct
,	O
p1	struct
,	O
pc	struct
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
1	int
)	O
break	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
2	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
type	enum
==	O
S_ARC	int
)	O
{	O
p0	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
;	O
p1	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
p	struct
;	O
pc	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
pc	struct
;	O
_pl_b_draw_elliptic_arc	function
(	O
R___	O
(	O
_plotter	pointer
)	O
p0	struct
,	O
p1	struct
,	O
pc	struct
)	O
;	O
break	O
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
2	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
type	enum
==	O
S_ELLARC	int
)	O
{	O
p0	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
;	O
p1	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
p	struct
;	O
pc	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
pc	struct
;	O
_pl_b_draw_elliptic_arc_2	function
(	O
R___	O
(	O
_plotter	pointer
)	O
p0	struct
,	O
p1	struct
,	O
pc	struct
)	O
;	O
break	O
;	O
}	O
miPoints	pointer
=	O
(	O
miPoint	struct
*	O
)	O
_pl_xmalloc	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
polyline_len	int
=	O
0	int
;	O
xu_last	double
=	O
0.0	int
;	O
yu_last	double
=	O
0.0	int
;	O
identical_user_coordinates	enum
=	O
true	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
double	O
xu	double
,	O
yu	double
;	O
int	O
device_x	int
,	O
device_y	int
;	O
xu	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
;	O
yu	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
;	O
if	O
(	O
i	int
>	O
0	int
&&	O
(	O
xu	double
!=	O
xu_last	double
||	O
yu	double
!=	O
yu_last	double
)	O
)	O
identical_user_coordinates	enum
=	O
false	int
;	O
device_x	int
=	O
IROUND	O
(	O
XD	O
(	O
xu	double
,	O
yu	double
)	O
)	O
;	O
device_y	int
=	O
IROUND	O
(	O
YD	O
(	O
xu	double
,	O
yu	double
)	O
)	O
;	O
if	O
(	O
(	O
polyline_len	int
==	O
0	int
)	O
||	O
(	O
device_x	int
!=	O
miPoints	pointer
[	O
polyline_len	int
-	O
1	int
]	O
.	O
x	double
)	O
||	O
(	O
device_y	int
!=	O
miPoints	pointer
[	O
polyline_len	int
-	O
1	int
]	O
.	O
y	double
)	O
)	O
{	O
miPoints	pointer
[	O
polyline_len	int
]	O
.	O
x	double
=	O
device_x	int
;	O
miPoints	pointer
[	O
polyline_len	int
]	O
.	O
y	double
=	O
device_y	int
;	O
polyline_len	int
++	O
;	O
}	O
xu_last	double
=	O
xu	double
;	O
yu_last	double
=	O
yu	double
;	O
}	O
bgPixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
bgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
0	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
red	int
&	O
0xff	int
;	O
bgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
1	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
green	int
&	O
0xff	int
;	O
bgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
2	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
blue	int
&	O
0xff	int
;	O
pixels	pointer
[	O
0	int
]	O
=	O
bgPixel	struct
;	O
pixels	pointer
[	O
1	int
]	O
=	O
bgPixel	struct
;	O
pGC	pointer
=	O
miNewGC	O
(	O
2	int
,	O
pixels	pointer
)	O
;	O
_set_common_mi_attributes	function
(	O
_plotter	pointer
->	O
drawstate	pointer
,	O
(	O
void	O
*	O
)	O
pGC	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
)	O
{	O
miPolygonShape	enum
polygon_shape	enum
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
primitive	enum
?	O
MI_SHAPE_CONVEX	int
:	O
MI_SHAPE_GENERAL	int
)	O
;	O
red	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
.	O
red	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
green	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
.	O
green	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
blue	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
.	O
blue	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
fgPixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
0	int
]	O
=	O
red	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
1	int
]	O
=	O
green	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
2	int
]	O
=	O
blue	int
;	O
pixels	pointer
[	O
0	int
]	O
=	O
bgPixel	struct
;	O
pixels	pointer
[	O
1	int
]	O
=	O
fgPixel	struct
;	O
miSetGCPixels	O
(	O
pGC	pointer
,	O
2	int
,	O
pixels	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
>	O
1	int
&&	O
polyline_len	int
==	O
1	int
)	O
miDrawPoints	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
MI_COORD_MODE_ORIGIN	int
,	O
1	int
,	O
miPoints	pointer
)	O
;	O
else	O
miFillPolygon	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
polygon_shape	enum
,	O
MI_COORD_MODE_ORIGIN	int
,	O
polyline_len	int
,	O
miPoints	pointer
)	O
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
)	O
{	O
red	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
red	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
green	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
green	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
blue	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
blue	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
fgPixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
0	int
]	O
=	O
red	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
1	int
]	O
=	O
green	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
2	int
]	O
=	O
blue	int
;	O
pixels	pointer
[	O
0	int
]	O
=	O
bgPixel	struct
;	O
pixels	pointer
[	O
1	int
]	O
=	O
fgPixel	struct
;	O
miSetGCPixels	O
(	O
pGC	pointer
,	O
2	int
,	O
pixels	pointer
)	O
;	O
if	O
(	O
polyline_len	int
==	O
1	int
)	O
{	O
if	O
(	O
identical_user_coordinates	enum
==	O
false	int
||	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
==	O
PL_CAP_ROUND	int
)	O
{	O
unsigned	O
int	O
sp_size	int
=	O
(	O
unsigned	O
int	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
quantized_device_line_width	int
;	O
if	O
(	O
sp_size	int
==	O
0	int
)	O
sp_size	int
=	O
1	int
;	O
if	O
(	O
sp_size	int
==	O
1	int
)	O
miDrawPoints	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
MI_COORD_MODE_ORIGIN	int
,	O
1	int
,	O
miPoints	pointer
)	O
;	O
else	O
{	O
int	O
sp_offset	int
;	O
miArc	struct
arc	struct
;	O
sp_offset	int
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
quantized_device_line_width	int
+	O
1	int
)	O
/	O
2	int
;	O
arc	struct
.	O
x	double
=	O
miPoints	pointer
[	O
0	int
]	O
.	O
x	double
-	O
sp_offset	int
;	O
arc	struct
.	O
y	double
=	O
miPoints	pointer
[	O
0	int
]	O
.	O
y	double
-	O
sp_offset	int
;	O
arc	struct
.	O
width	array
=	O
sp_size	int
;	O
arc	struct
.	O
height	int
=	O
sp_size	int
;	O
arc	struct
.	O
angle1	int
=	O
0	int
;	O
arc	struct
.	O
angle2	int
=	O
64	int
*	O
360	int
;	O
miFillArcs	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
1	int
,	O
&	O
arc	struct
)	O
;	O
}	O
}	O
}	O
else	O
miDrawLines	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
MI_COORD_MODE_ORIGIN	int
,	O
polyline_len	int
,	O
miPoints	pointer
)	O
;	O
}	O
miDeleteGC	O
(	O
pGC	pointer
)	O
;	O
free	function
(	O
miPoints	pointer
)	O
;	O
offset	array
.	O
x	double
=	O
0	int
;	O
offset	array
.	O
y	double
=	O
0	int
;	O
miCopyPaintedSetToCanvas	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
(	O
miCanvas	struct
*	O
)	O
_plotter	pointer
->	O
b_canvas	pointer
,	O
offset	array
)	O
;	O
miClearPaintedSet	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_ELLIPSE	int
:	O
{	O
int	O
ninetymult	int
;	O
int	O
x_orientation	int
,	O
y_orientation	int
;	O
int	O
xorigin	int
,	O
yorigin	int
;	O
unsigned	O
int	O
squaresize_x	int
,	O
squaresize_y	int
;	O
plPoint	struct
pc	struct
;	O
double	O
rx	double
,	O
ry	double
,	O
angle	double
;	O
pc	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
;	O
rx	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
rx	double
;	O
ry	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
ry	double
;	O
angle	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
angle	double
;	O
ninetymult	int
=	O
IROUND	O
(	O
angle	double
/	O
90.0	int
)	O
;	O
if	O
(	O
angle	double
==	O
(	O
double	O
)	O
(	O
90	int
*	O
ninetymult	int
)	O
)	O
{	O
angle	double
=	O
0.0	int
;	O
if	O
(	O
ninetymult	int
%	O
2	int
)	O
{	O
double	O
temp	double
;	O
temp	double
=	O
rx	double
;	O
rx	double
=	O
ry	double
;	O
ry	double
=	O
temp	double
;	O
}	O
}	O
rx	double
=	O
(	O
rx	double
<	O
0.0	int
?	O
-	O
rx	double
:	O
rx	double
)	O
;	O
ry	double
=	O
(	O
ry	double
<	O
0.0	int
?	O
-	O
ry	double
:	O
ry	double
)	O
;	O
x_orientation	int
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
0	int
]	O
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
y_orientation	int
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
3	int
]	O
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
xorigin	int
=	O
IROUND	O
(	O
XD	O
(	O
pc	struct
.	O
x	double
-	O
x_orientation	int
*	O
rx	double
,	O
pc	struct
.	O
y	double
-	O
y_orientation	int
*	O
ry	double
)	O
)	O
;	O
yorigin	int
=	O
IROUND	O
(	O
YD	O
(	O
pc	struct
.	O
x	double
-	O
x_orientation	int
*	O
rx	double
,	O
pc	struct
.	O
y	double
-	O
y_orientation	int
*	O
ry	double
)	O
)	O
;	O
squaresize_x	int
=	O
(	O
unsigned	O
int	O
)	O
IROUND	O
(	O
XDV	O
(	O
2	int
*	O
x_orientation	int
*	O
rx	double
,	O
0.0	int
)	O
)	O
;	O
squaresize_y	int
=	O
(	O
unsigned	O
int	O
)	O
IROUND	O
(	O
YDV	O
(	O
0.0	int
,	O
2	int
*	O
y_orientation	int
*	O
ry	double
)	O
)	O
;	O
_pl_b_draw_elliptic_arc_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
xorigin	int
,	O
yorigin	int
,	O
squaresize_x	int
,	O
squaresize_y	int
,	O
0	int
,	O
64	int
*	O
360	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
_pl_b_draw_elliptic_arc	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
plPoint	struct
p0	struct
,	O
plPoint	struct
p1	struct
,	O
plPoint	struct
pc	struct
)	O
{	O
double	O
radius	double
;	O
double	O
theta0	double
,	O
theta1	double
;	O
int	O
startangle	int
,	O
anglerange	int
;	O
int	O
x_orientation	int
,	O
y_orientation	int
;	O
int	O
xorigin	int
,	O
yorigin	int
;	O
unsigned	O
int	O
squaresize_x	int
,	O
squaresize_y	int
;	O
x_orientation	int
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
0	int
]	O
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
y_orientation	int
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
3	int
]	O
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
radius	double
=	O
DIST	O
(	O
pc	struct
,	O
p0	struct
)	O
;	O
xorigin	int
=	O
IROUND	O
(	O
XD	O
(	O
pc	struct
.	O
x	double
-	O
x_orientation	int
*	O
radius	double
,	O
pc	struct
.	O
y	double
-	O
y_orientation	int
*	O
radius	double
)	O
)	O
;	O
yorigin	int
=	O
IROUND	O
(	O
YD	O
(	O
pc	struct
.	O
x	double
-	O
x_orientation	int
*	O
radius	double
,	O
pc	struct
.	O
y	double
-	O
y_orientation	int
*	O
radius	double
)	O
)	O
;	O
squaresize_x	int
=	O
(	O
unsigned	O
int	O
)	O
IROUND	O
(	O
XDV	O
(	O
2	int
*	O
x_orientation	int
*	O
radius	double
,	O
0.0	int
)	O
)	O
;	O
squaresize_y	int
=	O
(	O
unsigned	O
int	O
)	O
IROUND	O
(	O
YDV	O
(	O
0.0	int
,	O
2	int
*	O
y_orientation	int
*	O
radius	double
)	O
)	O
;	O
theta0	double
=	O
_xatan2	function
(	O
-	O
y_orientation	int
*	O
(	O
p0	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
)	O
,	O
x_orientation	int
*	O
(	O
p0	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
)	O
)	O
/	O
M_PI	int
;	O
theta1	double
=	O
_xatan2	function
(	O
-	O
y_orientation	int
*	O
(	O
p1	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
)	O
,	O
x_orientation	int
*	O
(	O
p1	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
)	O
)	O
/	O
M_PI	int
;	O
if	O
(	O
theta1	double
<	O
theta0	double
)	O
theta1	double
+=	O
2.0	int
;	O
if	O
(	O
theta0	double
<	O
0.0	int
)	O
{	O
theta0	double
+=	O
2.0	int
;	O
theta1	double
+=	O
2.0	int
;	O
}	O
if	O
(	O
theta1	double
-	O
theta0	double
>	O
1.0	int
)	O
{	O
double	O
tmp	double
;	O
tmp	double
=	O
theta0	double
;	O
theta0	double
=	O
theta1	double
;	O
theta1	double
=	O
tmp	double
;	O
theta1	double
+=	O
2.0	int
;	O
}	O
if	O
(	O
theta0	double
>=	O
2.0	int
&&	O
theta1	double
>=	O
2.0	int
)	O
{	O
theta0	double
-=	O
2.0	int
;	O
theta1	double
-=	O
2.0	int
;	O
}	O
startangle	int
=	O
IROUND	O
(	O
64	int
*	O
theta0	double
*	O
180.0	int
)	O
;	O
anglerange	int
=	O
IROUND	O
(	O
64	int
*	O
(	O
theta1	double
-	O
theta0	double
)	O
*	O
180.0	int
)	O
;	O
_pl_b_draw_elliptic_arc_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
xorigin	int
,	O
yorigin	int
,	O
squaresize_x	int
,	O
squaresize_y	int
,	O
startangle	int
,	O
anglerange	int
)	O
;	O
}	O
void	O
_pl_b_draw_elliptic_arc_2	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
plPoint	struct
p0	struct
,	O
plPoint	struct
p1	struct
,	O
plPoint	struct
pc	struct
)	O
{	O
double	O
rx	double
,	O
ry	double
;	O
double	O
x0	double
,	O
y0	function
,	O
x1	double
,	O
y1	function
,	O
xc	int
,	O
yc	int
;	O
int	O
startangle	int
,	O
endangle	int
,	O
anglerange	int
;	O
int	O
x_orientation	int
,	O
y_orientation	int
;	O
int	O
xorigin	int
,	O
yorigin	int
;	O
unsigned	O
int	O
squaresize_x	int
,	O
squaresize_y	int
;	O
x_orientation	int
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
0	int
]	O
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
y_orientation	int
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
3	int
]	O
>=	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
xc	int
=	O
pc	struct
.	O
x	double
,	O
yc	int
=	O
pc	struct
.	O
y	double
;	O
x0	double
=	O
p0	struct
.	O
x	double
,	O
y0	function
=	O
p0	struct
.	O
y	double
;	O
x1	double
=	O
p1	struct
.	O
x	double
,	O
y1	function
=	O
p1	struct
.	O
y	double
;	O
if	O
(	O
y0	function
==	O
yc	int
&&	O
x1	double
==	O
xc	int
)	O
{	O
rx	double
=	O
(	O
x0	double
>	O
xc	int
)	O
?	O
x0	double
-	O
xc	int
:	O
xc	int
-	O
x0	double
;	O
ry	double
=	O
(	O
y1	function
>	O
yc	int
)	O
?	O
y1	function
-	O
yc	int
:	O
yc	int
-	O
y1	function
;	O
startangle	int
=	O
(	O
(	O
x0	double
>	O
xc	int
?	O
1	int
:	O
-	O
1	int
)	O
*	O
x_orientation	int
==	O
1	int
)	O
?	O
0	int
:	O
180	int
;	O
endangle	int
=	O
(	O
(	O
y1	function
>	O
yc	int
?	O
1	int
:	O
-	O
1	int
)	O
*	O
y_orientation	int
==	O
-	O
1	int
)	O
?	O
90	int
:	O
270	int
;	O
}	O
else	O
{	O
rx	double
=	O
(	O
x1	double
>	O
xc	int
)	O
?	O
x1	double
-	O
xc	int
:	O
xc	int
-	O
x1	double
;	O
ry	double
=	O
(	O
y0	function
>	O
yc	int
)	O
?	O
y0	function
-	O
yc	int
:	O
yc	int
-	O
y0	function
;	O
startangle	int
=	O
(	O
(	O
y0	function
>	O
yc	int
?	O
1	int
:	O
-	O
1	int
)	O
*	O
y_orientation	int
==	O
-	O
1	int
)	O
?	O
90	int
:	O
270	int
;	O
endangle	int
=	O
(	O
(	O
x1	double
>	O
xc	int
?	O
1	int
:	O
-	O
1	int
)	O
*	O
x_orientation	int
==	O
1	int
)	O
?	O
0	int
:	O
180	int
;	O
}	O
if	O
(	O
endangle	int
<	O
startangle	int
)	O
endangle	int
+=	O
360	int
;	O
anglerange	int
=	O
endangle	int
-	O
startangle	int
;	O
if	O
(	O
anglerange	int
==	O
270	int
)	O
{	O
int	O
tmp	double
;	O
tmp	double
=	O
startangle	int
;	O
startangle	int
=	O
endangle	int
;	O
endangle	int
=	O
tmp	double
;	O
anglerange	int
=	O
90	int
;	O
}	O
if	O
(	O
startangle	int
>=	O
360	int
)	O
startangle	int
-=	O
360	int
;	O
xorigin	int
=	O
IROUND	O
(	O
XD	O
(	O
xc	int
-	O
x_orientation	int
*	O
rx	double
,	O
yc	int
-	O
y_orientation	int
*	O
ry	double
)	O
)	O
;	O
yorigin	int
=	O
IROUND	O
(	O
YD	O
(	O
xc	int
-	O
x_orientation	int
*	O
rx	double
,	O
yc	int
-	O
y_orientation	int
*	O
ry	double
)	O
)	O
;	O
squaresize_x	int
=	O
(	O
unsigned	O
int	O
)	O
IROUND	O
(	O
XDV	O
(	O
2	int
*	O
x_orientation	int
*	O
rx	double
,	O
0.0	int
)	O
)	O
;	O
squaresize_y	int
=	O
(	O
unsigned	O
int	O
)	O
IROUND	O
(	O
YDV	O
(	O
0.0	int
,	O
2	int
*	O
y_orientation	int
*	O
ry	double
)	O
)	O
;	O
startangle	int
*=	O
64	int
;	O
anglerange	int
*=	O
64	int
;	O
_pl_b_draw_elliptic_arc_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
xorigin	int
,	O
yorigin	int
,	O
squaresize_x	int
,	O
squaresize_y	int
,	O
startangle	int
,	O
anglerange	int
)	O
;	O
}	O
void	O
_pl_b_draw_elliptic_arc_internal	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
xorigin	int
,	O
int	O
yorigin	int
,	O
unsigned	O
int	O
squaresize_x	int
,	O
unsigned	O
int	O
squaresize_y	int
,	O
int	O
startangle	int
,	O
int	O
anglerange	int
)	O
{	O
miGC	struct
*	O
pGC	pointer
;	O
miArc	struct
arc	struct
;	O
miPixel	struct
fgPixel	struct
,	O
bgPixel	struct
;	O
miPixel	struct
pixels	pointer
[	O
2	int
]	O
;	O
miPoint	struct
offset	array
;	O
unsigned	O
char	O
red	int
,	O
green	int
,	O
blue	int
;	O
bgPixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
bgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
0	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
red	int
&	O
0xff	int
;	O
bgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
1	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
green	int
&	O
0xff	int
;	O
bgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
2	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
blue	int
&	O
0xff	int
;	O
pixels	pointer
[	O
0	int
]	O
=	O
bgPixel	struct
;	O
pixels	pointer
[	O
1	int
]	O
=	O
bgPixel	struct
;	O
pGC	pointer
=	O
miNewGC	O
(	O
2	int
,	O
pixels	pointer
)	O
;	O
_set_common_mi_attributes	function
(	O
_plotter	pointer
->	O
drawstate	pointer
,	O
(	O
void	O
*	O
)	O
pGC	pointer
)	O
;	O
arc	struct
.	O
x	double
=	O
xorigin	int
;	O
arc	struct
.	O
y	double
=	O
yorigin	int
;	O
arc	struct
.	O
width	array
=	O
squaresize_x	int
;	O
arc	struct
.	O
height	int
=	O
squaresize_y	int
;	O
arc	struct
.	O
angle1	int
=	O
startangle	int
;	O
arc	struct
.	O
angle2	int
=	O
anglerange	int
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
)	O
{	O
double	O
red_d	double
,	O
green_d	double
,	O
blue_d	double
;	O
double	O
desaturate	double
;	O
red_d	double
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
)	O
.	O
red	int
)	O
)	O
/	O
0xFFFF	int
;	O
green_d	double
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
)	O
.	O
green	int
)	O
)	O
/	O
0xFFFF	int
;	O
blue_d	double
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
)	O
.	O
blue	int
)	O
)	O
/	O
0xFFFF	int
;	O
desaturate	double
=	O
(	O
(	O
double	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
-	O
1.	int
)	O
/	O
0xFFFE	int
;	O
red_d	double
=	O
red_d	double
+	O
desaturate	double
*	O
(	O
1.0	int
-	O
red_d	double
)	O
;	O
green_d	double
=	O
green_d	double
+	O
desaturate	double
*	O
(	O
1.0	int
-	O
green_d	double
)	O
;	O
blue_d	double
=	O
blue_d	double
+	O
desaturate	double
*	O
(	O
1.0	int
-	O
blue_d	double
)	O
;	O
red	int
=	O
IROUND	O
(	O
0xff	int
*	O
red_d	double
)	O
;	O
green	int
=	O
IROUND	O
(	O
0xff	int
*	O
green_d	double
)	O
;	O
blue	int
=	O
IROUND	O
(	O
0xff	int
*	O
blue_d	double
)	O
;	O
fgPixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
0	int
]	O
=	O
red	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
1	int
]	O
=	O
green	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
2	int
]	O
=	O
blue	int
;	O
pixels	pointer
[	O
0	int
]	O
=	O
bgPixel	struct
;	O
pixels	pointer
[	O
1	int
]	O
=	O
fgPixel	struct
;	O
miSetGCPixels	O
(	O
pGC	pointer
,	O
2	int
,	O
pixels	pointer
)	O
;	O
if	O
(	O
squaresize_x	int
<=	O
1	int
||	O
squaresize_y	int
<=	O
1	int
)	O
{	O
miPoint	struct
point	pointer
;	O
point	pointer
.	O
x	double
=	O
xorigin	int
;	O
point	pointer
.	O
y	double
=	O
yorigin	int
;	O
miDrawPoints	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
MI_COORD_MODE_ORIGIN	int
,	O
1	int
,	O
&	O
point	pointer
)	O
;	O
}	O
else	O
miFillArcs	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
1	int
,	O
&	O
arc	struct
)	O
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
)	O
{	O
unsigned	O
int	O
sp_size	int
=	O
0	int
;	O
red	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
red	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
green	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
green	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
blue	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
blue	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
fgPixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
0	int
]	O
=	O
red	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
1	int
]	O
=	O
green	int
;	O
fgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
2	int
]	O
=	O
blue	int
;	O
pixels	pointer
[	O
0	int
]	O
=	O
bgPixel	struct
;	O
pixels	pointer
[	O
1	int
]	O
=	O
fgPixel	struct
;	O
miSetGCPixels	O
(	O
pGC	pointer
,	O
2	int
,	O
pixels	pointer
)	O
;	O
if	O
(	O
squaresize_x	int
<=	O
1	int
||	O
squaresize_y	int
<=	O
1	int
)	O
{	O
int	O
sp_offset	int
;	O
sp_size	int
=	O
(	O
unsigned	O
int	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
quantized_device_line_width	int
;	O
sp_offset	int
=	O
(	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
quantized_device_line_width	int
+	O
1	int
)	O
/	O
2	int
;	O
if	O
(	O
sp_size	int
==	O
0	int
)	O
sp_size	int
=	O
1	int
;	O
arc	struct
.	O
x	double
-=	O
sp_offset	int
;	O
arc	struct
.	O
y	double
-=	O
sp_offset	int
;	O
arc	struct
.	O
width	array
=	O
sp_size	int
;	O
arc	struct
.	O
height	int
=	O
sp_size	int
;	O
arc	struct
.	O
angle1	int
=	O
0	int
;	O
arc	struct
.	O
angle2	int
=	O
64	int
*	O
360	int
;	O
}	O
if	O
(	O
squaresize_x	int
<=	O
1	int
||	O
squaresize_y	int
<=	O
1	int
)	O
{	O
if	O
(	O
sp_size	int
==	O
1	int
)	O
{	O
miPoint	struct
point	pointer
;	O
point	pointer
.	O
x	double
=	O
xorigin	int
;	O
point	pointer
.	O
y	double
=	O
yorigin	int
;	O
miDrawPoints	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
MI_COORD_MODE_ORIGIN	int
,	O
1	int
,	O
&	O
point	pointer
)	O
;	O
}	O
else	O
miFillArcs	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
1	int
,	O
&	O
arc	struct
)	O
;	O
}	O
else	O
miDrawArcs_r	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
1	int
,	O
&	O
arc	struct
,	O
(	O
miEllipseCache	struct
*	O
)	O
(	O
_plotter	pointer
->	O
b_arc_cache_data	pointer
)	O
)	O
;	O
}	O
miDeleteGC	O
(	O
pGC	pointer
)	O
;	O
offset	array
.	O
x	double
=	O
0	int
;	O
offset	array
.	O
y	double
=	O
0	int
;	O
miCopyPaintedSetToCanvas	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
(	O
miCanvas	struct
*	O
)	O
_plotter	pointer
->	O
b_canvas	pointer
,	O
offset	array
)	O
;	O
miClearPaintedSet	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
)	O
;	O
}	O
bool	enum
_pl_b_paint_paths	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
return	O
false	int
;	O
}	O
