static	O
Node	struct
*	O
eval_begin_rules	function
___P	O
(	O
(	O
State	struct
*	O
state	pointer
,	O
int	O
*	O
return_seen	pointer
)	O
)	O
;	O
static	O
Node	struct
*	O
eval_end_rules	function
___P	O
(	O
(	O
State	struct
*	O
state	pointer
,	O
int	O
*	O
found_return	pointer
)	O
)	O
;	O
void	O
process_file	function
(	O
fname	pointer
)	O
char	O
*	O
fname	pointer
;	O
{	O
Node	struct
*	O
result	pointer
;	O
int	O
return_seen	pointer
=	O
0	int
;	O
start_state	pointer
=	O
NULL	O
;	O
current_fname	pointer
=	O
fname	pointer
;	O
current_linenum	int
=	O
1	int
;	O
data_in_buffer	int
=	O
0	int
;	O
bufpos	int
=	O
0	int
;	O
eof_seen	int
=	O
0	int
;	O
enter_system_variable	function
(	O
"filename"	pointer
,	O
fname	pointer
)	O
;	O
data_in_buffer	int
=	O
fread	function
(	O
inbuf	pointer
,	O
1	int
,	O
INBUFSIZE	O
,	O
ifp	pointer
)	O
;	O
if	O
(	O
data_in_buffer	int
<	O
INBUFSIZE	O
)	O
eof_seen	int
=	O
1	int
;	O
if	O
(	O
start_state_arg	pointer
)	O
start_state	pointer
=	O
start_state_arg	pointer
;	O
result	pointer
=	O
eval_statement_list	function
(	O
start_stmts	pointer
,	O
NULL	O
,	O
&	O
return_seen	pointer
)	O
;	O
node_free	function
(	O
result	pointer
)	O
;	O
if	O
(	O
start_state	pointer
==	O
NULL	O
)	O
{	O
while	O
(	O
data_in_buffer	int
)	O
{	O
fwrite	function
(	O
inbuf	pointer
,	O
1	int
,	O
data_in_buffer	int
,	O
ofp	pointer
)	O
;	O
data_in_buffer	int
=	O
fread	function
(	O
inbuf	pointer
,	O
1	int
,	O
INBUFSIZE	O
,	O
ifp	pointer
)	O
;	O
}	O
}	O
else	O
{	O
result	pointer
=	O
execute_state	function
(	O
start_state	pointer
)	O
;	O
node_free	function
(	O
result	pointer
)	O
;	O
}	O
}	O
Node	struct
*	O
execute_state	function
(	O
name	pointer
)	O
char	O
*	O
name	pointer
;	O
{	O
State	struct
*	O
state	pointer
;	O
State	struct
*	O
s	pointer
;	O
int	O
to_read	int
,	O
got	int
;	O
ListItem	struct
*	O
rule	pointer
,	O
*	O
first_rule	pointer
;	O
unsigned	O
int	O
first_idx	int
;	O
unsigned	O
int	O
match_len	int
;	O
Node	struct
*	O
result	pointer
=	O
nvoid	pointer
;	O
Cons	struct
*	O
r	pointer
;	O
Node	struct
*	O
exp	pointer
;	O
int	O
return_seen	pointer
=	O
0	int
;	O
int	O
idx	int
;	O
state	pointer
=	O
lookup_state	function
(	O
name	pointer
)	O
;	O
if	O
(	O
state	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: undefined state `%s'\n"	pointer
)	O
,	O
program	pointer
,	O
name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
result	pointer
=	O
eval_begin_rules	function
(	O
state	pointer
,	O
&	O
return_seen	pointer
)	O
;	O
if	O
(	O
return_seen	pointer
)	O
goto	O
out	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
eol	int
;	O
if	O
(	O
bufpos	int
>=	O
data_in_buffer	int
)	O
{	O
if	O
(	O
eof_seen	int
)	O
break	O
;	O
data_in_buffer	int
=	O
fread	function
(	O
inbuf	pointer
,	O
1	int
,	O
INBUFSIZE	O
,	O
ifp	pointer
)	O
;	O
if	O
(	O
data_in_buffer	int
<	O
INBUFSIZE	O
)	O
eof_seen	int
=	O
1	int
;	O
bufpos	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
bufpos	int
>	O
0	int
&&	O
inbuf	pointer
[	O
bufpos	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
current_linenum	int
++	O
;	O
for	O
(	O
eol	int
=	O
bufpos	int
;	O
eol	int
<	O
data_in_buffer	int
&&	O
inbuf	pointer
[	O
eol	int
]	O
!=	O
'\n'	O
;	O
eol	int
++	O
)	O
;	O
if	O
(	O
eol	int
<	O
data_in_buffer	int
&&	O
inbuf	pointer
[	O
eol	int
]	O
==	O
'\n'	O
)	O
eol	int
++	O
;	O
if	O
(	O
eol	int
>=	O
data_in_buffer	int
&&	O
!	O
eof_seen	int
&&	O
bufpos	int
>	O
0	int
)	O
{	O
memmove	function
(	O
inbuf	pointer
,	O
inbuf	pointer
+	O
bufpos	int
,	O
eol	int
-	O
bufpos	int
)	O
;	O
data_in_buffer	int
=	O
eol	int
-	O
bufpos	int
;	O
bufpos	int
=	O
0	int
;	O
to_read	int
=	O
INBUFSIZE	O
-	O
data_in_buffer	int
;	O
got	int
=	O
fread	function
(	O
inbuf	pointer
+	O
data_in_buffer	int
,	O
1	int
,	O
to_read	int
,	O
ifp	pointer
)	O
;	O
if	O
(	O
got	int
<	O
to_read	int
)	O
eof_seen	int
=	O
1	int
;	O
data_in_buffer	int
+=	O
got	int
;	O
continue	O
;	O
}	O
first_idx	int
=	O
eol	int
;	O
match_len	int
=	O
0	int
;	O
first_rule	pointer
=	O
NULL	O
;	O
current_match	pointer
=	O
NULL	O
;	O
for	O
(	O
s	pointer
=	O
state	pointer
;	O
s	pointer
;	O
s	pointer
=	O
s	pointer
->	O
super	pointer
)	O
{	O
for	O
(	O
rule	pointer
=	O
s	pointer
->	O
rules	pointer
->	O
head	pointer
;	O
rule	pointer
;	O
rule	pointer
=	O
rule	pointer
->	O
next	pointer
)	O
{	O
int	O
err	int
;	O
r	pointer
=	O
(	O
Cons	struct
*	O
)	O
rule	pointer
->	O
data	pointer
;	O
exp	pointer
=	O
(	O
Node	struct
*	O
)	O
r	pointer
->	O
car	pointer
;	O
if	O
(	O
exp	pointer
==	O
RULE_BEGIN	O
||	O
exp	pointer
==	O
RULE_END	O
)	O
continue	O
;	O
if	O
(	O
exp	pointer
->	O
type	enum
==	O
nSYMBOL	int
)	O
{	O
Node	struct
*	O
n	long
;	O
if	O
(	O
!	O
strhash_get	function
(	O
ns_vars	pointer
,	O
exp	pointer
->	O
u	union
.	O
sym	pointer
,	O
strlen	function
(	O
exp	pointer
->	O
u	union
.	O
sym	pointer
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
n	long
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: error: undefined variable `%s'\n"	pointer
)	O
,	O
program	pointer
,	O
exp	pointer
->	O
u	union
.	O
sym	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
n	long
->	O
type	enum
!=	O
nREGEXP	int
)	O
continue	O
;	O
exp	pointer
=	O
n	long
;	O
}	O
err	int
=	O
re_search	function
(	O
REGEXP	O
(	O
exp	pointer
)	O
,	O
inbuf	pointer
,	O
eol	int
,	O
bufpos	int
,	O
eol	int
-	O
bufpos	int
,	O
&	O
exp	pointer
->	O
u	union
.	O
re	struct
.	O
matches	struct
)	O
;	O
if	O
(	O
err	int
<	O
0	int
)	O
continue	O
;	O
idx	int
=	O
exp	pointer
->	O
u	union
.	O
re	struct
.	O
matches	struct
.	O
start	pointer
[	O
0	int
]	O
;	O
if	O
(	O
idx	int
>=	O
0	int
&&	O
(	O
idx	int
<	O
first_idx	int
||	O
(	O
idx	int
==	O
first_idx	int
&&	O
(	O
exp	pointer
->	O
u	union
.	O
re	struct
.	O
matches	struct
.	O
end	pointer
[	O
0	int
]	O
-	O
exp	pointer
->	O
u	union
.	O
re	struct
.	O
matches	struct
.	O
start	pointer
[	O
0	int
]	O
>	O
match_len	int
)	O
)	O
)	O
)	O
{	O
first_idx	int
=	O
idx	int
;	O
first_rule	pointer
=	O
rule	pointer
;	O
match_len	int
=	O
(	O
exp	pointer
->	O
u	union
.	O
re	struct
.	O
matches	struct
.	O
end	pointer
[	O
0	int
]	O
-	O
exp	pointer
->	O
u	union
.	O
re	struct
.	O
matches	struct
.	O
start	pointer
[	O
0	int
]	O
)	O
;	O
current_match	pointer
=	O
&	O
exp	pointer
->	O
u	union
.	O
re	struct
.	O
matches	struct
;	O
current_match_buf	pointer
=	O
inbuf	pointer
;	O
}	O
}	O
}	O
fwrite	function
(	O
inbuf	pointer
+	O
bufpos	int
,	O
1	int
,	O
first_idx	int
-	O
bufpos	int
,	O
ofp	pointer
)	O
;	O
if	O
(	O
first_rule	pointer
)	O
{	O
bufpos	int
=	O
current_match	pointer
->	O
end	pointer
[	O
0	int
]	O
;	O
node_free	function
(	O
result	pointer
)	O
;	O
result	pointer
=	O
eval_statement_list	function
(	O
(	O
List	struct
*	O
)	O
(	O
(	O
Cons	struct
*	O
)	O
first_rule	pointer
->	O
data	pointer
)	O
->	O
cdr	pointer
,	O
NULL	O
,	O
&	O
return_seen	pointer
)	O
;	O
if	O
(	O
return_seen	pointer
)	O
goto	O
out	O
;	O
}	O
else	O
bufpos	int
=	O
first_idx	int
;	O
}	O
out	O
:	O
{	O
int	O
found	int
=	O
0	int
;	O
Node	struct
*	O
result2	pointer
;	O
result2	pointer
=	O
eval_end_rules	function
(	O
state	pointer
,	O
&	O
found	int
)	O
;	O
if	O
(	O
found	int
)	O
{	O
node_free	function
(	O
result	pointer
)	O
;	O
result	pointer
=	O
result2	pointer
;	O
}	O
}	O
return	O
result	pointer
;	O
}	O
static	O
Node	struct
*	O
eval_begin_rules	function
(	O
state	pointer
,	O
return_seen	pointer
)	O
State	struct
*	O
state	pointer
;	O
int	O
*	O
return_seen	pointer
;	O
{	O
Node	struct
*	O
result	pointer
=	O
nvoid	pointer
;	O
Cons	struct
*	O
r	pointer
;	O
ListItem	struct
*	O
rule	pointer
;	O
if	O
(	O
state	pointer
->	O
super_name	pointer
&&	O
state	pointer
->	O
super	pointer
==	O
NULL	O
)	O
{	O
state	pointer
->	O
super	pointer
=	O
lookup_state	function
(	O
state	pointer
->	O
super_name	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
super	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: undefined super state `%s'\n"	pointer
)	O
,	O
program	pointer
,	O
state	pointer
->	O
super_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
state	pointer
->	O
super	pointer
)	O
{	O
result	pointer
=	O
eval_begin_rules	function
(	O
state	pointer
->	O
super	pointer
,	O
return_seen	pointer
)	O
;	O
if	O
(	O
*	O
return_seen	pointer
)	O
return	O
result	pointer
;	O
}	O
for	O
(	O
rule	pointer
=	O
state	pointer
->	O
rules	pointer
->	O
head	pointer
;	O
rule	pointer
;	O
rule	pointer
=	O
rule	pointer
->	O
next	pointer
)	O
{	O
r	pointer
=	O
(	O
Cons	struct
*	O
)	O
rule	pointer
->	O
data	pointer
;	O
if	O
(	O
r	pointer
->	O
car	pointer
==	O
RULE_BEGIN	O
)	O
{	O
node_free	function
(	O
result	pointer
)	O
;	O
result	pointer
=	O
eval_statement_list	function
(	O
(	O
List	struct
*	O
)	O
r	pointer
->	O
cdr	pointer
,	O
NULL	O
,	O
return_seen	pointer
)	O
;	O
if	O
(	O
*	O
return_seen	pointer
)	O
break	O
;	O
}	O
}	O
return	O
result	pointer
;	O
}	O
static	O
Node	struct
*	O
eval_end_rules	function
(	O
state	pointer
,	O
found_return	pointer
)	O
State	struct
*	O
state	pointer
;	O
int	O
*	O
found_return	pointer
;	O
{	O
ListItem	struct
*	O
rule	pointer
;	O
Cons	struct
*	O
r	pointer
;	O
Node	struct
*	O
result	pointer
=	O
nvoid	pointer
;	O
int	O
return_seen	pointer
;	O
for	O
(	O
;	O
state	pointer
;	O
state	pointer
=	O
state	pointer
->	O
super	pointer
)	O
for	O
(	O
rule	pointer
=	O
state	pointer
->	O
rules	pointer
->	O
head	pointer
;	O
rule	pointer
;	O
rule	pointer
=	O
rule	pointer
->	O
next	pointer
)	O
{	O
r	pointer
=	O
(	O
Cons	struct
*	O
)	O
rule	pointer
->	O
data	pointer
;	O
if	O
(	O
r	pointer
->	O
car	pointer
==	O
RULE_END	O
)	O
{	O
*	O
found_return	pointer
=	O
1	int
;	O
node_free	function
(	O
result	pointer
)	O
;	O
result	pointer
=	O
eval_statement_list	function
(	O
(	O
List	struct
*	O
)	O
r	pointer
->	O
cdr	pointer
,	O
NULL	O
,	O
&	O
return_seen	pointer
)	O
;	O
}	O
}	O
return	O
result	pointer
;	O
}	O
