int	O
info_aborted_echo_area	int
=	O
0	int
;	O
int	O
echo_area_is_active	int
=	O
0	int
;	O
static	O
VFunction	function
*	O
ea_last_executed_command	pointer
=	O
NULL	O
;	O
int	O
echo_area_last_command_was_kill	int
=	O
0	int
;	O
static	O
char	O
input_line	array
[	O
1	int
+	O
EA_MAX_INPUT	int
]	O
;	O
static	O
int	O
input_line_point	int
;	O
static	O
int	O
input_line_beg	int
;	O
static	O
int	O
input_line_end	int
;	O
static	O
NODE	struct
input_line_node	struct
=	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
input_line	array
,	O
EA_MAX_INPUT	int
,	O
0	int
,	O
N_IsInternal	int
}	O
;	O
static	O
void	O
echo_area_initialize_node	function
(	O
void	O
)	O
;	O
static	O
void	O
push_echo_area	function
(	O
void	O
)	O
,	O
pop_echo_area	function
(	O
void	O
)	O
;	O
static	O
int	O
echo_area_stack_contains_completions_p	function
(	O
void	O
)	O
;	O
static	O
void	O
ea_kill_text	function
(	O
int	O
from	int
,	O
int	O
to	int
)	O
;	O
static	O
void	O
ea_remove_text	function
(	O
int	O
from	int
,	O
int	O
to	int
)	O
;	O
static	O
int	O
echo_area_must_complete_p	int
=	O
0	int
;	O
static	O
int	O
completions_window_p	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
;	O
static	O
WINDOW	struct
*	O
echo_area_completions_window	pointer
=	O
NULL	O
;	O
static	O
WINDOW	struct
*	O
calling_window	pointer
=	O
NULL	O
;	O
static	O
NODE	struct
*	O
calling_window_node	pointer
=	O
NULL	O
;	O
static	O
void	O
remember_calling_window	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
if	O
(	O
!	O
completions_window_p	function
(	O
window	pointer
)	O
||	O
(	O
(	O
window	pointer
==	O
windows	pointer
)	O
&&	O
!	O
(	O
window	pointer
->	O
next	pointer
)	O
)	O
)	O
{	O
calling_window	pointer
=	O
window	pointer
;	O
calling_window_node	pointer
=	O
window	pointer
->	O
node	pointer
;	O
}	O
}	O
static	O
void	O
restore_calling_window	function
(	O
void	O
)	O
{	O
register	O
WINDOW	struct
*	O
win	pointer
,	O
*	O
compwin	pointer
=	O
NULL	O
;	O
for	O
(	O
win	pointer
=	O
windows	pointer
;	O
win	pointer
;	O
win	pointer
=	O
win	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
completions_window_p	function
(	O
win	pointer
)	O
)	O
compwin	pointer
=	O
win	pointer
;	O
if	O
(	O
win	pointer
==	O
calling_window	pointer
&&	O
win	pointer
==	O
compwin	pointer
)	O
{	O
forget_node	function
(	O
win	pointer
)	O
;	O
compwin	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
compwin	pointer
)	O
{	O
if	O
(	O
(	O
compwin	pointer
!=	O
windows	pointer
||	O
windows	pointer
->	O
next	pointer
)	O
&&	O
!	O
echo_area_stack_contains_completions_p	function
(	O
)	O
)	O
{	O
info_delete_window_internal	function
(	O
compwin	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
initialize_input_line	function
(	O
const	O
char	O
*	O
prompt	pointer
)	O
{	O
strcpy	function
(	O
input_line	array
,	O
prompt	pointer
)	O
;	O
input_line_beg	int
=	O
input_line_end	int
=	O
input_line_point	int
=	O
strlen	function
(	O
prompt	pointer
)	O
;	O
}	O
static	O
char	O
*	O
echo_area_after_read	function
(	O
void	O
)	O
{	O
char	O
*	O
return_value	pointer
;	O
if	O
(	O
info_aborted_echo_area	int
)	O
{	O
info_aborted_echo_area	int
=	O
0	int
;	O
return_value	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
input_line_beg	int
==	O
input_line_end	int
)	O
return_value	pointer
=	O
xstrdup	function
(	O
""	pointer
)	O
;	O
else	O
{	O
int	O
line_len	int
=	O
input_line_end	int
-	O
input_line_beg	int
;	O
return_value	pointer
=	O
xmalloc	function
(	O
1	int
+	O
line_len	int
)	O
;	O
strncpy	function
(	O
return_value	pointer
,	O
&	O
input_line	array
[	O
input_line_beg	int
]	O
,	O
line_len	int
)	O
;	O
return_value	pointer
[	O
line_len	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
return	O
return_value	pointer
;	O
}	O
static	O
void	O
read_and_dispatch_in_echo_area	function
(	O
void	O
)	O
{	O
while	O
(	O
1	int
)	O
{	O
int	O
count	pointer
;	O
VFunction	function
*	O
cmd	pointer
;	O
int	O
lk	int
=	O
0	int
;	O
lk	int
=	O
echo_area_last_command_was_kill	int
;	O
echo_area_prep_read	function
(	O
)	O
;	O
if	O
(	O
!	O
info_any_buffered_input_p	function
(	O
)	O
)	O
display_update_display	function
(	O
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
cmd	pointer
=	O
read_key_sequence	function
(	O
echo_area_keymap	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
&	O
count	pointer
)	O
;	O
if	O
(	O
cmd	pointer
)	O
{	O
(	O
*	O
cmd	pointer
)	O
(	O
the_echo_area	pointer
,	O
count	pointer
)	O
;	O
ea_last_executed_command	pointer
=	O
cmd	pointer
;	O
}	O
else	O
ea_last_executed_command	pointer
=	O
0	int
;	O
if	O
(	O
lk	int
==	O
echo_area_last_command_was_kill	int
)	O
echo_area_last_command_was_kill	int
=	O
0	int
;	O
if	O
(	O
cmd	pointer
==	O
ea_newline	function
||	O
info_aborted_echo_area	int
)	O
{	O
ea_last_executed_command	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
}	O
char	O
*	O
info_read_in_echo_area	function
(	O
const	O
char	O
*	O
prompt	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
if	O
(	O
echo_area_is_active	int
)	O
push_echo_area	function
(	O
)	O
;	O
initialize_input_line	function
(	O
prompt	pointer
)	O
;	O
echo_area_initialize_node	function
(	O
)	O
;	O
remember_calling_window	function
(	O
active_window	pointer
)	O
;	O
echo_area_is_active	int
++	O
;	O
active_window	pointer
=	O
the_echo_area	pointer
;	O
read_and_dispatch_in_echo_area	function
(	O
)	O
;	O
window_clear_echo_area	function
(	O
)	O
;	O
echo_area_is_active	int
--	O
;	O
active_window	pointer
=	O
calling_window	pointer
;	O
restore_calling_window	function
(	O
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
line	pointer
=	O
echo_area_after_read	function
(	O
)	O
;	O
if	O
(	O
echo_area_is_active	int
)	O
pop_echo_area	function
(	O
)	O
;	O
return	O
line	pointer
;	O
}	O
static	O
void	O
echo_area_initialize_node	function
(	O
void	O
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
input_line_end	int
;	O
(	O
unsigned	O
int	O
)	O
i	int
<	O
sizeof	O
(	O
input_line	array
)	O
;	O
i	int
++	O
)	O
input_line	array
[	O
i	int
]	O
=	O
' '	O
;	O
input_line	array
[	O
i	int
-	O
1	int
]	O
=	O
'\n'	O
;	O
window_set_node_of_window	function
(	O
the_echo_area	pointer
,	O
&	O
input_line_node	struct
)	O
;	O
input_line	array
[	O
input_line_end	int
]	O
=	O
'\n'	O
;	O
}	O
void	O
echo_area_prep_read	function
(	O
void	O
)	O
{	O
if	O
(	O
the_echo_area	pointer
->	O
node	pointer
!=	O
&	O
input_line_node	struct
)	O
echo_area_initialize_node	function
(	O
)	O
;	O
the_echo_area	pointer
->	O
point	long
=	O
input_line_point	int
;	O
input_line	array
[	O
input_line_end	int
]	O
=	O
'\n'	O
;	O
the_echo_area	pointer
->	O
line_map	struct
.	O
used	long
=	O
0	int
;	O
display_update_one_window	function
(	O
the_echo_area	pointer
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_forward	function
,	O
_	O
(	O
"Move forward a character"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_backward	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
mbi_iterator_t	struct
iter	pointer
;	O
mbi_init	O
(	O
iter	pointer
,	O
input_line	array
+	O
input_line_point	int
,	O
input_line_end	int
-	O
input_line_point	int
)	O
;	O
while	O
(	O
mbi_avail	O
(	O
iter	pointer
)	O
&&	O
count	pointer
--	O
)	O
{	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
input_line_point	int
=	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
-	O
input_line	array
;	O
if	O
(	O
input_line_point	int
>	O
input_line_end	int
)	O
input_line_point	int
=	O
input_line_end	int
;	O
}	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_backward	function
,	O
_	O
(	O
"Move backward a character"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_forward	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
char	O
*	O
ptr	pointer
=	O
input_line	array
+	O
input_line_point	int
;	O
while	O
(	O
count	pointer
--	O
)	O
{	O
ptr	pointer
=	O
input_line	array
+	O
input_line_point	int
;	O
while	O
(	O
ptr	pointer
>	O
input_line	array
)	O
{	O
ptr	pointer
--	O
;	O
if	O
(	O
(	O
long	O
)	O
mbrlen	function
(	O
ptr	pointer
,	O
input_line	array
+	O
input_line_point	int
-	O
ptr	pointer
,	O
0	int
)	O
>	O
0	int
)	O
break	O
;	O
}	O
input_line_point	int
=	O
ptr	pointer
-	O
input_line	array
;	O
if	O
(	O
input_line_point	int
<	O
input_line_beg	int
)	O
input_line_point	int
=	O
input_line_beg	int
;	O
}	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_beg_of_line	function
,	O
_	O
(	O
"Move to the start of this line"	pointer
)	O
)	O
{	O
input_line_point	int
=	O
input_line_beg	int
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_end_of_line	function
,	O
_	O
(	O
"Move to the end of this line"	pointer
)	O
)	O
{	O
input_line_point	int
=	O
input_line_end	int
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_forward_word	function
,	O
_	O
(	O
"Move forward a word"	pointer
)	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_backward_word	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
while	O
(	O
count	pointer
--	O
)	O
{	O
if	O
(	O
input_line_point	int
==	O
input_line_end	int
)	O
return	O
;	O
c	int
=	O
input_line	array
[	O
input_line_point	int
]	O
;	O
if	O
(	O
!	O
alphabetic	O
(	O
c	int
)	O
)	O
{	O
while	O
(	O
++	O
input_line_point	int
<	O
input_line_end	int
)	O
{	O
c	int
=	O
input_line	array
[	O
input_line_point	int
]	O
;	O
if	O
(	O
alphabetic	O
(	O
c	int
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
input_line_point	int
==	O
input_line_end	int
)	O
return	O
;	O
while	O
(	O
++	O
input_line_point	int
<	O
input_line_end	int
)	O
{	O
c	int
=	O
input_line	array
[	O
input_line_point	int
]	O
;	O
if	O
(	O
!	O
alphabetic	O
(	O
c	int
)	O
)	O
break	O
;	O
}	O
}	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_backward_word	function
,	O
_	O
(	O
"Move backward a word"	pointer
)	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_forward_word	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
while	O
(	O
count	pointer
--	O
)	O
{	O
if	O
(	O
input_line_point	int
==	O
input_line_beg	int
)	O
return	O
;	O
c	int
=	O
input_line	array
[	O
input_line_point	int
-	O
1	int
]	O
;	O
if	O
(	O
!	O
alphabetic	O
(	O
c	int
)	O
)	O
{	O
while	O
(	O
(	O
--	O
input_line_point	int
)	O
!=	O
input_line_beg	int
)	O
{	O
c	int
=	O
input_line	array
[	O
input_line_point	int
-	O
1	int
]	O
;	O
if	O
(	O
alphabetic	O
(	O
c	int
)	O
)	O
break	O
;	O
}	O
}	O
while	O
(	O
input_line_point	int
!=	O
input_line_beg	int
)	O
{	O
c	int
=	O
input_line	array
[	O
input_line_point	int
-	O
1	int
]	O
;	O
if	O
(	O
!	O
alphabetic	O
(	O
c	int
)	O
)	O
break	O
;	O
else	O
--	O
input_line_point	int
;	O
}	O
}	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_delete	function
,	O
_	O
(	O
"Delete the character under the cursor"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_rubout	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
int	O
orig_point	int
;	O
if	O
(	O
input_line_point	int
==	O
input_line_end	int
)	O
return	O
;	O
orig_point	int
=	O
input_line_point	int
;	O
ea_forward	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
if	O
(	O
ea_explicit_arg	int
||	O
count	pointer
>	O
1	int
)	O
ea_kill_text	function
(	O
orig_point	int
,	O
input_line_point	int
)	O
;	O
else	O
ea_remove_text	function
(	O
orig_point	int
,	O
input_line_point	int
)	O
;	O
input_line_point	int
=	O
orig_point	int
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_rubout	function
,	O
_	O
(	O
"Delete the character behind the cursor"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_delete	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
int	O
start	int
;	O
if	O
(	O
input_line_point	int
==	O
input_line_beg	int
)	O
{	O
if	O
(	O
input_line_beg	int
==	O
input_line_end	int
)	O
info_aborted_echo_area	int
=	O
1	int
;	O
return	O
;	O
}	O
start	int
=	O
input_line_point	int
;	O
ea_backward	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
if	O
(	O
ea_explicit_arg	int
||	O
count	pointer
>	O
1	int
)	O
ea_kill_text	function
(	O
start	int
,	O
input_line_point	int
)	O
;	O
else	O
ea_delete	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_abort	function
,	O
_	O
(	O
"Cancel or quit operation"	pointer
)	O
)	O
{	O
if	O
(	O
input_line_end	int
!=	O
input_line_beg	int
)	O
{	O
terminal_ring_bell	function
(	O
)	O
;	O
input_line_end	int
=	O
input_line_point	int
=	O
input_line_beg	int
;	O
if	O
(	O
calling_window	pointer
->	O
node	pointer
!=	O
calling_window_node	pointer
)	O
restore_calling_window	function
(	O
)	O
;	O
}	O
else	O
info_aborted_echo_area	int
=	O
1	int
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_newline	function
,	O
_	O
(	O
"Accept (or force completion of) this line"	pointer
)	O
)	O
{	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_quoted_insert	function
,	O
_	O
(	O
"Insert next character verbatim"	pointer
)	O
)	O
{	O
int	O
character	int
;	O
character	int
=	O
get_another_input_key	function
(	O
)	O
;	O
if	O
(	O
character	int
>=	O
256	int
||	O
character	int
<	O
0	int
)	O
return	O
;	O
ea_insert	function
(	O
window	pointer
,	O
count	pointer
,	O
character	int
)	O
;	O
}	O
void	O
ea_insert	function
(	O
WINDOW	struct
*	O
window	pointer
,	O
int	O
count	pointer
,	O
int	O
key	int
)	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
(	O
input_line_end	int
+	O
1	int
)	O
==	O
EA_MAX_INPUT	int
)	O
{	O
terminal_ring_bell	function
(	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
input_line_end	int
+	O
1	int
;	O
i	int
!=	O
input_line_point	int
;	O
i	int
--	O
)	O
input_line	array
[	O
i	int
]	O
=	O
input_line	array
[	O
i	int
-	O
1	int
]	O
;	O
input_line	array
[	O
input_line_point	int
]	O
=	O
key	int
;	O
input_line_point	int
++	O
;	O
input_line_end	int
++	O
;	O
window_line_map_init	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_tab_insert	function
,	O
_	O
(	O
"Insert a TAB character"	pointer
)	O
)	O
{	O
ea_insert	function
(	O
window	pointer
,	O
count	pointer
,	O
'\t'	O
)	O
;	O
}	O
static	O
void	O
ea_swap_chars	function
(	O
int	O
c1	int
,	O
int	O
c1e	int
,	O
int	O
c2	int
,	O
int	O
c2e	int
)	O
{	O
int	O
len1	int
,	O
len2	int
;	O
char	O
*	O
tmp	pointer
;	O
len1	int
=	O
c1e	int
-	O
c1	int
;	O
len2	int
=	O
c2e	int
-	O
c2	int
;	O
if	O
(	O
len1	int
>=	O
len2	int
)	O
{	O
tmp	pointer
=	O
xmalloc	function
(	O
len1	int
)	O
;	O
memcpy	function
(	O
tmp	pointer
,	O
input_line	array
+	O
c1	int
,	O
len1	int
)	O
;	O
memcpy	function
(	O
input_line	array
+	O
c1	int
,	O
input_line	array
+	O
c2	int
,	O
len2	int
)	O
;	O
memmove	function
(	O
input_line	array
+	O
c1	int
+	O
len2	int
,	O
input_line	array
+	O
c1e	int
,	O
c2	int
-	O
c1e	int
)	O
;	O
memcpy	function
(	O
input_line	array
+	O
c2	int
-	O
(	O
len1	int
-	O
len2	int
)	O
,	O
tmp	pointer
,	O
len1	int
)	O
;	O
free	function
(	O
tmp	pointer
)	O
;	O
}	O
else	O
{	O
tmp	pointer
=	O
xmalloc	function
(	O
len2	int
)	O
;	O
memcpy	function
(	O
tmp	pointer
,	O
input_line	array
+	O
c2	int
,	O
len2	int
)	O
;	O
memcpy	function
(	O
input_line	array
+	O
c2e	int
-	O
len1	int
,	O
input_line	array
+	O
c1	int
,	O
len1	int
)	O
;	O
memmove	function
(	O
input_line	array
+	O
c1e	int
+	O
(	O
len2	int
-	O
len1	int
)	O
,	O
input_line	array
+	O
c1e	int
,	O
c2	int
-	O
c1e	int
)	O
;	O
memcpy	function
(	O
input_line	array
+	O
c1	int
,	O
tmp	pointer
,	O
len2	int
)	O
;	O
free	function
(	O
tmp	pointer
)	O
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_transpose_chars	function
,	O
_	O
(	O
"Transpose characters at point"	pointer
)	O
)	O
{	O
while	O
(	O
count	pointer
)	O
{	O
if	O
(	O
input_line_point	int
==	O
input_line_end	int
||	O
count	pointer
<	O
0	int
)	O
{	O
int	O
c1	int
,	O
c2	int
,	O
c2e	int
;	O
c2e	int
=	O
input_line_point	int
;	O
ea_backward	function
(	O
window	pointer
,	O
1	int
)	O
;	O
c2	int
=	O
input_line_point	int
;	O
ea_backward	function
(	O
window	pointer
,	O
1	int
)	O
;	O
c1	int
=	O
input_line_point	int
;	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
ea_swap_chars	function
(	O
c1	int
,	O
c2	int
,	O
c2	int
,	O
c2e	int
)	O
;	O
if	O
(	O
count	pointer
>	O
0	int
)	O
input_line_point	int
=	O
c2e	int
;	O
else	O
input_line_point	int
=	O
c1	int
+	O
c2e	int
-	O
c2	int
;	O
}	O
else	O
{	O
int	O
c1	int
,	O
c2	int
,	O
c2e	int
;	O
c2	int
=	O
input_line_point	int
;	O
ea_forward	function
(	O
window	pointer
,	O
1	int
)	O
;	O
c2e	int
=	O
input_line_point	int
;	O
if	O
(	O
c2e	int
==	O
c2	int
)	O
return	O
;	O
input_line_point	int
=	O
c2	int
;	O
ea_backward	function
(	O
window	pointer
,	O
1	int
)	O
;	O
c1	int
=	O
input_line_point	int
;	O
if	O
(	O
c1	int
==	O
c2e	int
)	O
return	O
;	O
ea_swap_chars	function
(	O
c1	int
,	O
c2	int
,	O
c2	int
,	O
c2e	int
)	O
;	O
input_line_point	int
=	O
c2e	int
;	O
}	O
if	O
(	O
count	pointer
<	O
0	int
)	O
count	pointer
++	O
;	O
else	O
count	pointer
--	O
;	O
}	O
}	O
static	O
char	O
*	O
*	O
kill_ring	pointer
=	O
NULL	O
;	O
static	O
int	O
kill_ring_index	int
=	O
0	int
;	O
static	O
int	O
kill_ring_slots	int
=	O
0	int
;	O
static	O
int	O
kill_ring_loc	int
=	O
0	int
;	O
static	O
int	O
max_retained_kills	int
=	O
15	int
;	O
DECLARE_INFO_COMMAND	O
(	O
ea_yank	function
,	O
_	O
(	O
"Yank back the contents of the last kill"	pointer
)	O
)	O
{	O
register	O
int	O
i	int
;	O
register	O
char	O
*	O
text	pointer
;	O
if	O
(	O
!	O
kill_ring_index	int
)	O
{	O
inform_in_echo_area	function
(	O
_	O
(	O
"Kill ring is empty"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
text	pointer
=	O
kill_ring	pointer
[	O
kill_ring_loc	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
ea_insert	function
(	O
window	pointer
,	O
1	int
,	O
text	pointer
[	O
i	int
]	O
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_yank_pop	function
,	O
_	O
(	O
"Yank back a previous kill"	pointer
)	O
)	O
{	O
register	O
int	O
len	long
;	O
if	O
(	O
(	O
(	O
ea_last_executed_command	pointer
!=	O
(	O
VFunction	function
*	O
)	O
ea_yank	function
)	O
&&	O
(	O
ea_last_executed_command	pointer
!=	O
(	O
VFunction	function
*	O
)	O
ea_yank_pop	function
)	O
)	O
||	O
(	O
kill_ring_index	int
==	O
0	int
)	O
)	O
return	O
;	O
len	long
=	O
strlen	function
(	O
kill_ring	pointer
[	O
kill_ring_loc	int
]	O
)	O
;	O
{	O
register	O
int	O
i	int
,	O
counter	int
;	O
counter	int
=	O
input_line_end	int
-	O
input_line_point	int
;	O
for	O
(	O
i	int
=	O
input_line_point	int
-	O
len	long
;	O
counter	int
;	O
i	int
++	O
,	O
counter	int
--	O
)	O
input_line	array
[	O
i	int
]	O
=	O
input_line	array
[	O
i	int
+	O
len	long
]	O
;	O
input_line_end	int
-=	O
len	long
;	O
input_line_point	int
-=	O
len	long
;	O
}	O
kill_ring_loc	int
--	O
;	O
if	O
(	O
kill_ring_loc	int
<	O
0	int
)	O
kill_ring_loc	int
=	O
kill_ring_index	int
-	O
1	int
;	O
ea_yank	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_kill_line	function
,	O
_	O
(	O
"Kill to the end of the line"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
{	O
ea_kill_text	function
(	O
input_line_point	int
,	O
input_line_beg	int
)	O
;	O
input_line_point	int
=	O
input_line_beg	int
;	O
}	O
else	O
ea_kill_text	function
(	O
input_line_point	int
,	O
input_line_end	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_backward_kill_line	function
,	O
_	O
(	O
"Kill to the beginning of the line"	pointer
)	O
)	O
{	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_kill_text	function
(	O
input_line_point	int
,	O
input_line_end	int
)	O
;	O
else	O
{	O
ea_kill_text	function
(	O
input_line_point	int
,	O
input_line_beg	int
)	O
;	O
input_line_point	int
=	O
input_line_beg	int
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_kill_word	function
,	O
_	O
(	O
"Kill the word following the cursor"	pointer
)	O
)	O
{	O
int	O
orig_point	int
=	O
input_line_point	int
;	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_backward_kill_word	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
ea_forward_word	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
if	O
(	O
input_line_point	int
!=	O
orig_point	int
)	O
ea_kill_text	function
(	O
orig_point	int
,	O
input_line_point	int
)	O
;	O
input_line_point	int
=	O
orig_point	int
;	O
}	O
window_line_map_init	function
(	O
window	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_backward_kill_word	function
,	O
_	O
(	O
"Kill the word preceding the cursor"	pointer
)	O
)	O
{	O
int	O
orig_point	int
=	O
input_line_point	int
;	O
if	O
(	O
count	pointer
<	O
0	int
)	O
ea_kill_word	function
(	O
window	pointer
,	O
-	O
count	pointer
)	O
;	O
else	O
{	O
ea_backward_word	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
if	O
(	O
input_line_point	int
!=	O
orig_point	int
)	O
ea_kill_text	function
(	O
orig_point	int
,	O
input_line_point	int
)	O
;	O
}	O
window_line_map_init	function
(	O
window	pointer
)	O
;	O
}	O
static	O
void	O
ea_remove_text	function
(	O
int	O
from	int
,	O
int	O
to	int
)	O
{	O
int	O
distance	int
,	O
i	int
,	O
counter	int
;	O
counter	int
=	O
input_line_end	int
-	O
to	int
;	O
distance	int
=	O
to	int
-	O
from	int
;	O
for	O
(	O
i	int
=	O
from	int
;	O
counter	int
;	O
i	int
++	O
,	O
counter	int
--	O
)	O
input_line	array
[	O
i	int
]	O
=	O
input_line	array
[	O
i	int
+	O
distance	int
]	O
;	O
input_line_end	int
-=	O
distance	int
;	O
}	O
static	O
void	O
ea_kill_text	function
(	O
int	O
from	int
,	O
int	O
to	int
)	O
{	O
register	O
int	O
distance	int
;	O
int	O
killing_backwards	int
,	O
slot	int
;	O
char	O
*	O
killed_text	pointer
;	O
killing_backwards	int
=	O
(	O
from	int
>	O
to	int
)	O
;	O
if	O
(	O
killing_backwards	int
)	O
{	O
int	O
temp	int
=	O
from	int
;	O
from	int
=	O
to	int
;	O
to	int
=	O
temp	int
;	O
}	O
distance	int
=	O
to	int
-	O
from	int
;	O
killed_text	pointer
=	O
xmalloc	function
(	O
1	int
+	O
distance	int
)	O
;	O
strncpy	function
(	O
killed_text	pointer
,	O
&	O
input_line	array
[	O
from	int
]	O
,	O
distance	int
)	O
;	O
killed_text	pointer
[	O
distance	int
]	O
=	O
'\0'	O
;	O
ea_remove_text	function
(	O
from	int
,	O
to	int
)	O
;	O
if	O
(	O
echo_area_last_command_was_kill	int
)	O
{	O
char	O
*	O
old	pointer
,	O
*	O
new	pointer
;	O
slot	int
=	O
kill_ring_loc	int
;	O
old	pointer
=	O
kill_ring	pointer
[	O
slot	int
]	O
;	O
new	pointer
=	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
old	pointer
)	O
+	O
strlen	function
(	O
killed_text	pointer
)	O
)	O
;	O
if	O
(	O
killing_backwards	int
)	O
{	O
strcpy	function
(	O
new	pointer
,	O
killed_text	pointer
)	O
;	O
strcat	function
(	O
new	pointer
,	O
old	pointer
)	O
;	O
}	O
else	O
{	O
strcpy	function
(	O
new	pointer
,	O
old	pointer
)	O
;	O
strcat	function
(	O
new	pointer
,	O
killed_text	pointer
)	O
;	O
}	O
free	function
(	O
old	pointer
)	O
;	O
free	function
(	O
killed_text	pointer
)	O
;	O
kill_ring	pointer
[	O
slot	int
]	O
=	O
new	pointer
;	O
}	O
else	O
{	O
slot	int
=	O
kill_ring_index	int
;	O
if	O
(	O
slot	int
==	O
max_retained_kills	int
)	O
slot	int
=	O
0	int
;	O
if	O
(	O
slot	int
+	O
1	int
>	O
kill_ring_slots	int
)	O
kill_ring	pointer
=	O
xrealloc	function
(	O
kill_ring	pointer
,	O
(	O
kill_ring_slots	int
+=	O
max_retained_kills	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
slot	int
!=	O
kill_ring_index	int
)	O
free	function
(	O
kill_ring	pointer
[	O
slot	int
]	O
)	O
;	O
else	O
kill_ring_index	int
++	O
;	O
kill_ring	pointer
[	O
slot	int
]	O
=	O
killed_text	pointer
;	O
kill_ring_loc	int
=	O
slot	int
;	O
}	O
echo_area_last_command_was_kill	int
++	O
;	O
}	O
REFERENCE	struct
*	O
*	O
echo_area_completion_items	pointer
=	O
NULL	O
;	O
static	O
REFERENCE	struct
*	O
*	O
completions_found	pointer
=	O
NULL	O
;	O
static	O
size_t	long
completions_found_index	long
=	O
0	int
;	O
static	O
size_t	long
completions_found_slots	long
=	O
0	int
;	O
static	O
REFERENCE	struct
*	O
LCD_completion	pointer
;	O
static	O
reference_bool_fn	pointer
completion_exclude_func	pointer
=	O
0	int
;	O
static	O
void	O
build_completions	function
(	O
void	O
)	O
;	O
static	O
void	O
completions_must_be_rebuilt	function
(	O
void	O
)	O
;	O
static	O
NODE	struct
*	O
possible_completions_output_node	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
compwin_name	pointer
=	O
"*Completions*"	pointer
;	O
static	O
int	O
completions_window_p	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
int	O
result	int
=	O
0	int
;	O
if	O
(	O
internal_info_node_p	function
(	O
window	pointer
->	O
node	pointer
)	O
&&	O
(	O
strcmp	function
(	O
window	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
compwin_name	pointer
)	O
==	O
0	int
)	O
)	O
result	int
=	O
1	int
;	O
return	O
result	int
;	O
}	O
char	O
*	O
info_read_completing_internal	function
(	O
const	O
char	O
*	O
prompt	pointer
,	O
REFERENCE	struct
*	O
*	O
completions	pointer
,	O
int	O
force	int
,	O
reference_bool_fn	pointer
exclude_func	pointer
)	O
{	O
char	O
*	O
line	pointer
;	O
if	O
(	O
echo_area_is_active	int
)	O
push_echo_area	function
(	O
)	O
;	O
echo_area_must_complete_p	int
=	O
force	int
;	O
initialize_input_line	function
(	O
prompt	pointer
)	O
;	O
echo_area_initialize_node	function
(	O
)	O
;	O
remember_calling_window	function
(	O
active_window	pointer
)	O
;	O
echo_area_completion_items	pointer
=	O
completions	pointer
;	O
completions_must_be_rebuilt	function
(	O
)	O
;	O
completion_exclude_func	pointer
=	O
exclude_func	pointer
;	O
active_window	pointer
=	O
the_echo_area	pointer
;	O
echo_area_is_active	int
++	O
;	O
window_line_map_init	function
(	O
active_window	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
read_and_dispatch_in_echo_area	function
(	O
)	O
;	O
line	pointer
=	O
echo_area_after_read	function
(	O
)	O
;	O
if	O
(	O
force	int
&&	O
line	pointer
&&	O
*	O
line	pointer
&&	O
completions	pointer
)	O
{	O
size_t	long
i	int
;	O
build_completions	function
(	O
)	O
;	O
if	O
(	O
completions_found_index	long
==	O
1	int
)	O
{	O
free	function
(	O
line	pointer
)	O
;	O
line	pointer
=	O
xstrdup	function
(	O
completions_found	pointer
[	O
0	int
]	O
->	O
label	pointer
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
completions_found_index	long
;	O
i	int
++	O
)	O
if	O
(	O
mbscasecmp	function
(	O
completions_found	pointer
[	O
i	int
]	O
->	O
label	pointer
,	O
line	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
line	pointer
)	O
;	O
line	pointer
=	O
xstrdup	function
(	O
completions_found	pointer
[	O
i	int
]	O
->	O
label	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
completions_found_index	long
)	O
{	O
if	O
(	O
!	O
completions_found_index	long
)	O
inform_in_echo_area	function
(	O
_	O
(	O
"No completions"	pointer
)	O
)	O
;	O
else	O
inform_in_echo_area	function
(	O
_	O
(	O
"Not complete"	pointer
)	O
)	O
;	O
free	function
(	O
line	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
break	O
;	O
}	O
echo_area_is_active	int
--	O
;	O
window_clear_echo_area	function
(	O
)	O
;	O
active_window	pointer
=	O
calling_window	pointer
;	O
restore_calling_window	function
(	O
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
echo_area_completion_items	pointer
=	O
NULL	O
;	O
completions_must_be_rebuilt	function
(	O
)	O
;	O
if	O
(	O
echo_area_is_active	int
)	O
pop_echo_area	function
(	O
)	O
;	O
return	O
line	pointer
;	O
}	O
char	O
*	O
info_read_completing_in_echo_area	function
(	O
const	O
char	O
*	O
prompt	pointer
,	O
REFERENCE	struct
*	O
*	O
completions	pointer
)	O
{	O
return	O
info_read_completing_internal	function
(	O
prompt	pointer
,	O
completions	pointer
,	O
1	int
,	O
0	int
)	O
;	O
}	O
char	O
*	O
info_read_maybe_completing	function
(	O
const	O
char	O
*	O
prompt	pointer
,	O
REFERENCE	struct
*	O
*	O
completions	pointer
)	O
{	O
return	O
info_read_completing_internal	function
(	O
prompt	pointer
,	O
completions	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
char	O
*	O
info_read_completing_in_echo_area_with_exclusions	function
(	O
const	O
char	O
*	O
prompt	pointer
,	O
REFERENCE	struct
*	O
*	O
completions	pointer
,	O
reference_bool_fn	pointer
exclude	pointer
)	O
{	O
return	O
info_read_completing_internal	function
(	O
prompt	pointer
,	O
completions	pointer
,	O
1	int
,	O
exclude	pointer
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_possible_completions	function
,	O
_	O
(	O
"List possible completions"	pointer
)	O
)	O
{	O
build_completions	function
(	O
)	O
;	O
if	O
(	O
!	O
completions_found_index	long
)	O
{	O
terminal_ring_bell	function
(	O
)	O
;	O
inform_in_echo_area	function
(	O
_	O
(	O
"No completions"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
completions_found_index	long
==	O
1	int
)	O
{	O
inform_in_echo_area	function
(	O
_	O
(	O
"Sole completion"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
size_t	long
i	int
,	O
l	long
;	O
size_t	long
limit	pointer
,	O
iterations	long
,	O
max_label	long
=	O
0	int
;	O
struct	O
text_buffer	struct
message	pointer
;	O
text_buffer_init	function
(	O
&	O
message	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
message	pointer
,	O
ngettext	function
(	O
"%d completion:\n"	pointer
,	O
"%d completions:\n"	pointer
,	O
completions_found_index	long
)	O
,	O
completions_found_index	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
completions_found_index	long
;	O
i	int
++	O
)	O
{	O
int	O
len	long
=	O
strlen	function
(	O
completions_found	pointer
[	O
i	int
]	O
->	O
label	pointer
)	O
;	O
if	O
(	O
len	long
>	O
max_label	long
)	O
max_label	long
=	O
len	long
;	O
}	O
max_label	long
+=	O
4	int
;	O
limit	pointer
=	O
calling_window	pointer
->	O
width	long
/	O
max_label	long
;	O
if	O
(	O
limit	pointer
!=	O
1	int
&&	O
(	O
limit	pointer
*	O
max_label	long
==	O
calling_window	pointer
->	O
width	long
)	O
)	O
limit	pointer
--	O
;	O
if	O
(	O
limit	pointer
==	O
0	int
)	O
limit	pointer
=	O
1	int
;	O
iterations	long
=	O
(	O
completions_found_index	long
+	O
(	O
limit	pointer
-	O
1	int
)	O
)	O
/	O
limit	pointer
;	O
if	O
(	O
completions_found_index	long
<	O
limit	pointer
)	O
iterations	long
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
iterations	long
;	O
i	int
++	O
)	O
{	O
register	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
,	O
l	long
=	O
i	int
;	O
j	int
<	O
limit	pointer
;	O
j	int
++	O
)	O
{	O
if	O
(	O
l	long
>=	O
completions_found_index	long
)	O
break	O
;	O
else	O
{	O
char	O
*	O
label	pointer
;	O
int	O
printed_length	int
,	O
k	int
;	O
label	pointer
=	O
completions_found	pointer
[	O
l	long
]	O
->	O
label	pointer
;	O
printed_length	int
=	O
strlen	function
(	O
label	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
message	pointer
,	O
"%s"	pointer
,	O
label	pointer
)	O
;	O
if	O
(	O
j	int
+	O
1	int
<	O
limit	pointer
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max_label	long
-	O
printed_length	int
;	O
k	int
++	O
)	O
text_buffer_printf	function
(	O
&	O
message	pointer
,	O
" "	pointer
)	O
;	O
}	O
}	O
l	long
+=	O
iterations	long
;	O
}	O
text_buffer_printf	function
(	O
&	O
message	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
{	O
NODE	struct
*	O
temp	int
;	O
temp	int
=	O
text_buffer_to_node	function
(	O
&	O
message	pointer
)	O
;	O
name_internal_node	function
(	O
temp	int
,	O
xstrdup	function
(	O
compwin_name	pointer
)	O
)	O
;	O
possible_completions_output_node	pointer
=	O
temp	int
;	O
possible_completions_output_node	pointer
->	O
flags	int
|=	O
N_WasRewritten	int
;	O
}	O
{	O
WINDOW	struct
*	O
compwin	pointer
;	O
compwin	pointer
=	O
get_internal_info_window	function
(	O
compwin_name	pointer
)	O
;	O
if	O
(	O
!	O
compwin	pointer
)	O
{	O
if	O
(	O
calling_window	pointer
->	O
height	long
>	O
(	O
iterations	long
*	O
2	int
)	O
&&	O
calling_window	pointer
->	O
height	long
/	O
2	int
>=	O
WINDOW_MIN_SIZE	O
)	O
{	O
remember_calling_window	function
(	O
calling_window	pointer
)	O
;	O
active_window	pointer
=	O
calling_window	pointer
;	O
compwin	pointer
=	O
window_make_window	function
(	O
)	O
;	O
window_change_window_height	function
(	O
compwin	pointer
,	O
-	O
(	O
compwin	pointer
->	O
height	long
-	O
(	O
iterations	long
+	O
2	int
)	O
)	O
)	O
;	O
echo_area_completions_window	pointer
=	O
compwin	pointer
;	O
active_window	pointer
=	O
the_echo_area	pointer
;	O
}	O
else	O
compwin	pointer
=	O
calling_window	pointer
;	O
}	O
while	O
(	O
compwin	pointer
->	O
node	pointer
&&	O
(	O
compwin	pointer
->	O
node	pointer
->	O
flags	int
&	O
N_IsInternal	int
)	O
&&	O
!	O
strcmp	function
(	O
compwin	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
compwin_name	pointer
)	O
)	O
forget_node	function
(	O
compwin	pointer
)	O
;	O
info_set_node_of_window	function
(	O
compwin	pointer
,	O
possible_completions_output_node	pointer
)	O
;	O
display_update_display	function
(	O
)	O
;	O
}	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_complete	function
,	O
_	O
(	O
"Insert completion"	pointer
)	O
)	O
{	O
if	O
(	O
ea_last_executed_command	pointer
==	O
(	O
VFunction	function
*	O
)	O
ea_complete	function
)	O
{	O
ea_possible_completions	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
return	O
;	O
}	O
input_line_point	int
=	O
input_line_end	int
;	O
build_completions	function
(	O
)	O
;	O
if	O
(	O
!	O
completions_found_index	long
)	O
terminal_ring_bell	function
(	O
)	O
;	O
else	O
if	O
(	O
LCD_completion	pointer
->	O
label	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
ea_possible_completions	function
(	O
window	pointer
,	O
count	pointer
)	O
;	O
else	O
{	O
register	O
int	O
i	int
;	O
input_line_point	int
=	O
input_line_end	int
=	O
input_line_beg	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
LCD_completion	pointer
->	O
label	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
ea_insert	function
(	O
window	pointer
,	O
1	int
,	O
LCD_completion	pointer
->	O
label	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
static	O
REFERENCE	struct
LCD_reference	struct
=	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
void	O
remove_completion_duplicates	function
(	O
void	O
)	O
;	O
static	O
char	O
*	O
last_completion_request	pointer
=	O
NULL	O
;	O
static	O
REFERENCE	struct
*	O
*	O
last_completion_items	pointer
=	O
NULL	O
;	O
static	O
void	O
completions_must_be_rebuilt	function
(	O
void	O
)	O
{	O
free	function
(	O
last_completion_request	pointer
)	O
;	O
last_completion_request	pointer
=	O
NULL	O
;	O
last_completion_items	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
build_completions	function
(	O
void	O
)	O
{	O
size_t	long
i	int
;	O
int	O
len	long
;	O
register	O
REFERENCE	struct
*	O
entry	pointer
;	O
char	O
*	O
request	pointer
;	O
int	O
informed_of_lengthy_job	int
=	O
0	int
;	O
if	O
(	O
!	O
echo_area_completion_items	pointer
)	O
{	O
completions_found_index	long
=	O
0	int
;	O
LCD_completion	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
len	long
=	O
input_line_end	int
-	O
input_line_beg	int
;	O
request	pointer
=	O
xmalloc	function
(	O
1	int
+	O
len	long
)	O
;	O
strncpy	function
(	O
request	pointer
,	O
&	O
input_line	array
[	O
input_line_beg	int
]	O
,	O
len	long
)	O
;	O
request	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
last_completion_request	pointer
&&	O
last_completion_items	pointer
&&	O
last_completion_items	pointer
==	O
echo_area_completion_items	pointer
&&	O
(	O
strcmp	function
(	O
last_completion_request	pointer
,	O
request	pointer
)	O
==	O
0	int
)	O
)	O
{	O
free	function
(	O
request	pointer
)	O
;	O
return	O
;	O
}	O
free	function
(	O
last_completion_request	pointer
)	O
;	O
last_completion_request	pointer
=	O
request	pointer
;	O
last_completion_items	pointer
=	O
echo_area_completion_items	pointer
;	O
completions_found_index	long
=	O
0	int
;	O
LCD_completion	pointer
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
entry	pointer
=	O
echo_area_completion_items	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
completion_exclude_func	pointer
&&	O
completion_exclude_func	pointer
(	O
entry	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
mbsncasecmp	function
(	O
request	pointer
,	O
entry	pointer
->	O
label	pointer
,	O
len	long
)	O
==	O
0	int
)	O
add_pointer_to_array	O
(	O
entry	pointer
,	O
completions_found_index	long
,	O
completions_found	pointer
,	O
completions_found_slots	long
,	O
20	int
)	O
;	O
if	O
(	O
!	O
informed_of_lengthy_job	int
&&	O
completions_found_index	long
>	O
100	int
)	O
{	O
informed_of_lengthy_job	int
=	O
1	int
;	O
window_message_in_echo_area	function
(	O
_	O
(	O
"Building completions..."	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
completions_found_index	long
)	O
return	O
;	O
remove_completion_duplicates	function
(	O
)	O
;	O
if	O
(	O
completions_found_index	long
==	O
1	int
)	O
{	O
LCD_completion	pointer
=	O
completions_found	pointer
[	O
0	int
]	O
;	O
return	O
;	O
}	O
{	O
long	O
shortest	long
=	O
100000	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
completions_found_index	long
;	O
i	int
++	O
)	O
{	O
register	O
int	O
j	int
;	O
int	O
c1	int
,	O
c2	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
(	O
c1	int
=	O
tolower	function
(	O
completions_found	pointer
[	O
i	int
-	O
1	int
]	O
->	O
label	pointer
[	O
j	int
]	O
)	O
)	O
&&	O
(	O
c2	int
=	O
tolower	function
(	O
completions_found	pointer
[	O
i	int
]	O
->	O
label	pointer
[	O
j	int
]	O
)	O
)	O
;	O
j	int
++	O
)	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
if	O
(	O
shortest	long
>	O
j	int
)	O
shortest	long
=	O
j	int
;	O
}	O
free	function
(	O
LCD_reference	struct
.	O
label	pointer
)	O
;	O
LCD_reference	struct
.	O
label	pointer
=	O
xmalloc	function
(	O
1	int
+	O
shortest	long
)	O
;	O
if	O
(	O
completions_found_index	long
>	O
1	int
)	O
{	O
int	O
req_len	int
=	O
strlen	function
(	O
request	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
completions_found_index	long
;	O
i	int
++	O
)	O
if	O
(	O
strncmp	function
(	O
request	pointer
,	O
completions_found	pointer
[	O
i	int
]	O
->	O
label	pointer
,	O
req_len	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	int
>=	O
completions_found_index	long
)	O
i	int
=	O
0	int
;	O
}	O
strncpy	function
(	O
LCD_reference	struct
.	O
label	pointer
,	O
completions_found	pointer
[	O
i	int
]	O
->	O
label	pointer
,	O
shortest	long
)	O
;	O
LCD_reference	struct
.	O
label	pointer
[	O
shortest	long
]	O
=	O
'\0'	O
;	O
LCD_completion	pointer
=	O
&	O
LCD_reference	struct
;	O
}	O
if	O
(	O
informed_of_lengthy_job	int
)	O
echo_area_initialize_node	function
(	O
)	O
;	O
}	O
static	O
int	O
compare_references	function
(	O
const	O
void	O
*	O
entry1	pointer
,	O
const	O
void	O
*	O
entry2	pointer
)	O
{	O
REFERENCE	struct
*	O
*	O
e1	pointer
=	O
(	O
REFERENCE	struct
*	O
*	O
)	O
entry1	pointer
;	O
REFERENCE	struct
*	O
*	O
e2	pointer
=	O
(	O
REFERENCE	struct
*	O
*	O
)	O
entry2	pointer
;	O
return	O
mbscasecmp	function
(	O
(	O
*	O
e1	pointer
)	O
->	O
label	pointer
,	O
(	O
*	O
e2	pointer
)	O
->	O
label	pointer
)	O
;	O
}	O
static	O
void	O
remove_completion_duplicates	function
(	O
void	O
)	O
{	O
size_t	long
i	int
,	O
j	int
;	O
REFERENCE	struct
*	O
*	O
temp	int
;	O
int	O
newlen	int
;	O
if	O
(	O
!	O
completions_found_index	long
)	O
return	O
;	O
qsort	function
(	O
completions_found	pointer
,	O
completions_found_index	long
,	O
sizeof	O
(	O
REFERENCE	struct
*	O
)	O
,	O
compare_references	function
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
newlen	int
=	O
1	int
;	O
i	int
<	O
completions_found_index	long
-	O
1	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
completions_found	pointer
[	O
i	int
]	O
->	O
label	pointer
,	O
completions_found	pointer
[	O
i	int
+	O
1	int
]	O
->	O
label	pointer
)	O
==	O
0	int
)	O
completions_found	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
else	O
newlen	int
++	O
;	O
}	O
temp	int
=	O
xmalloc	function
(	O
(	O
1	int
+	O
newlen	int
)	O
*	O
sizeof	O
(	O
REFERENCE	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
i	int
<	O
completions_found_index	long
;	O
i	int
++	O
)	O
if	O
(	O
completions_found	pointer
[	O
i	int
]	O
)	O
temp	int
[	O
j	int
++	O
]	O
=	O
completions_found	pointer
[	O
i	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
newlen	int
;	O
i	int
++	O
)	O
completions_found	pointer
[	O
i	int
]	O
=	O
temp	int
[	O
i	int
]	O
;	O
completions_found	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
completions_found_index	long
=	O
newlen	int
;	O
free	function
(	O
temp	int
)	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
ea_scroll_completions_window	function
,	O
_	O
(	O
"Scroll the completions window"	pointer
)	O
)	O
{	O
WINDOW	struct
*	O
compwin	pointer
;	O
compwin	pointer
=	O
get_internal_info_window	function
(	O
compwin_name	pointer
)	O
;	O
if	O
(	O
!	O
compwin	pointer
)	O
compwin	pointer
=	O
calling_window	pointer
;	O
info_scroll_forward	function
(	O
compwin	pointer
,	O
count	pointer
)	O
;	O
}	O
void	O
echo_area_inform_of_deleted_window	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
if	O
(	O
window	pointer
==	O
calling_window	pointer
)	O
{	O
if	O
(	O
active_window	pointer
!=	O
the_echo_area	pointer
)	O
remember_calling_window	function
(	O
active_window	pointer
)	O
;	O
else	O
remember_calling_window	function
(	O
windows	pointer
)	O
;	O
}	O
if	O
(	O
window	pointer
==	O
echo_area_completions_window	pointer
)	O
echo_area_completions_window	pointer
=	O
NULL	O
;	O
}	O
typedef	O
struct	O
{	O
char	O
*	O
line	pointer
;	O
REFERENCE	struct
*	O
*	O
comp_items	pointer
;	O
int	O
point	long
,	O
beg	int
,	O
end	int
;	O
int	O
must_complete	int
;	O
NODE	struct
node	pointer
;	O
WINDOW	struct
*	O
compwin	pointer
;	O
}	O
PUSHED_EA	struct
;	O
static	O
PUSHED_EA	struct
*	O
*	O
pushed_echo_areas	pointer
=	O
NULL	O
;	O
static	O
size_t	long
pushed_echo_areas_index	long
=	O
0	int
;	O
static	O
size_t	long
pushed_echo_areas_slots	long
=	O
0	int
;	O
static	O
void	O
push_echo_area	function
(	O
void	O
)	O
{	O
PUSHED_EA	struct
*	O
pushed	pointer
;	O
pushed	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
PUSHED_EA	struct
)	O
)	O
;	O
pushed	pointer
->	O
line	pointer
=	O
xstrdup	function
(	O
input_line	array
)	O
;	O
pushed	pointer
->	O
point	long
=	O
input_line_point	int
;	O
pushed	pointer
->	O
beg	int
=	O
input_line_beg	int
;	O
pushed	pointer
->	O
end	int
=	O
input_line_end	int
;	O
pushed	pointer
->	O
node	pointer
=	O
input_line_node	struct
;	O
pushed	pointer
->	O
comp_items	pointer
=	O
echo_area_completion_items	pointer
;	O
pushed	pointer
->	O
must_complete	int
=	O
echo_area_must_complete_p	int
;	O
pushed	pointer
->	O
compwin	pointer
=	O
echo_area_completions_window	pointer
;	O
add_pointer_to_array	O
(	O
pushed	pointer
,	O
pushed_echo_areas_index	long
,	O
pushed_echo_areas	pointer
,	O
pushed_echo_areas_slots	long
,	O
4	int
)	O
;	O
echo_area_completion_items	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
pop_echo_area	function
(	O
void	O
)	O
{	O
PUSHED_EA	struct
*	O
popped	pointer
;	O
popped	pointer
=	O
pushed_echo_areas	pointer
[	O
--	O
pushed_echo_areas_index	long
]	O
;	O
strcpy	function
(	O
input_line	array
,	O
popped	pointer
->	O
line	pointer
)	O
;	O
free	function
(	O
popped	pointer
->	O
line	pointer
)	O
;	O
input_line_point	int
=	O
popped	pointer
->	O
point	long
;	O
input_line_beg	int
=	O
popped	pointer
->	O
beg	int
;	O
input_line_end	int
=	O
popped	pointer
->	O
end	int
;	O
input_line_node	struct
=	O
popped	pointer
->	O
node	pointer
;	O
echo_area_completion_items	pointer
=	O
popped	pointer
->	O
comp_items	pointer
;	O
echo_area_must_complete_p	int
=	O
popped	pointer
->	O
must_complete	int
;	O
echo_area_completions_window	pointer
=	O
popped	pointer
->	O
compwin	pointer
;	O
completions_must_be_rebuilt	function
(	O
)	O
;	O
if	O
(	O
echo_area_completions_window	pointer
)	O
{	O
register	O
WINDOW	struct
*	O
win	pointer
;	O
for	O
(	O
win	pointer
=	O
windows	pointer
;	O
win	pointer
;	O
win	pointer
=	O
win	pointer
->	O
next	pointer
)	O
if	O
(	O
echo_area_completions_window	pointer
==	O
win	pointer
)	O
break	O
;	O
if	O
(	O
!	O
win	pointer
)	O
echo_area_completions_window	pointer
=	O
NULL	O
;	O
}	O
free	function
(	O
popped	pointer
)	O
;	O
}	O
static	O
int	O
echo_area_stack_contains_completions_p	function
(	O
void	O
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pushed_echo_areas_index	long
;	O
i	int
++	O
)	O
if	O
(	O
pushed_echo_areas	pointer
[	O
i	int
]	O
->	O
compwin	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
inform_in_echo_area	function
(	O
const	O
char	O
*	O
message	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
text	pointer
;	O
int	O
avail	int
=	O
EA_MAX_INPUT	int
+	O
1	int
-	O
input_line_end	int
;	O
text	pointer
=	O
xstrdup	function
(	O
message	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	pointer
[	O
i	int
]	O
&&	O
text	pointer
[	O
i	int
]	O
!=	O
'\n'	O
&&	O
i	int
<	O
avail	int
;	O
i	int
++	O
)	O
;	O
text	pointer
[	O
i	int
]	O
=	O
0	int
;	O
echo_area_initialize_node	function
(	O
)	O
;	O
sprintf	function
(	O
&	O
input_line	array
[	O
input_line_end	int
]	O
,	O
"%s[%s]\n"	pointer
,	O
echo_area_is_active	int
?	O
" "	pointer
:	O
""	pointer
,	O
text	pointer
)	O
;	O
free	function
(	O
text	pointer
)	O
;	O
the_echo_area	pointer
->	O
point	long
=	O
input_line_point	int
;	O
display_update_one_window	function
(	O
the_echo_area	pointer
)	O
;	O
display_cursor_at_point	function
(	O
active_window	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
pause_or_input	function
(	O
)	O
;	O
echo_area_initialize_node	function
(	O
)	O
;	O
}	O
