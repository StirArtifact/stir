extern	O
void	O
starting_body	function
(	O
)	O
;	O
extern	O
void	O
starting_text	function
(	O
)	O
;	O
extern	O
int	O
simulate_allcaps	int
;	O
extern	O
int	O
simulate_smallcaps	int
;	O
typedef	O
struct	O
_stack	struct
{	O
unsigned	O
char	O
attr_stack	array
[	O
MAX_ATTRS	O
]	O
;	O
char	O
*	O
attr_stack_params	array
[	O
MAX_ATTRS	O
]	O
;	O
int	O
tos	int
;	O
struct	O
_stack	struct
*	O
next	pointer
;	O
}	O
AttrStack	struct
;	O
static	O
AttrStack	struct
*	O
stack_of_stacks	pointer
=	O
NULL	O
;	O
static	O
AttrStack	struct
*	O
stack_of_stacks_top	pointer
=	O
NULL	O
;	O
void	O
attr_express_begin	function
(	O
int	O
attr	int
,	O
char	O
*	O
param	pointer
)	O
{	O
switch	O
(	O
attr	int
)	O
{	O
case	O
ATTR_BOLD	int
:	O
printf	function
(	O
op	pointer
->	O
bold_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_ITALIC	int
:	O
printf	function
(	O
op	pointer
->	O
italic_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_THICK_UL	int
:	O
case	O
ATTR_WAVE_UL	int
:	O
case	O
ATTR_DASH_UL	int
:	O
case	O
ATTR_DOT_UL	int
:	O
case	O
ATTR_DOT_DASH_UL	int
:	O
case	O
ATTR_2DOT_DASH_UL	int
:	O
case	O
ATTR_WORD_UL	int
:	O
case	O
ATTR_UNDERLINE	int
:	O
printf	function
(	O
op	pointer
->	O
underline_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_DOUBLE_UL	int
:	O
printf	function
(	O
op	pointer
->	O
dbl_underline_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_FONTSIZE	int
:	O
op_begin_std_fontsize	function
(	O
op	pointer
,	O
atoi	function
(	O
param	pointer
)	O
)	O
;	O
break	O
;	O
case	O
ATTR_FONTFACE	int
:	O
printf	function
(	O
op	pointer
->	O
font_begin	pointer
,	O
param	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_FOREGROUND	int
:	O
printf	function
(	O
op	pointer
->	O
foreground_begin	pointer
,	O
param	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_BACKGROUND	int
:	O
if	O
(	O
!	O
simple_mode	int
)	O
printf	function
(	O
op	pointer
->	O
foreground_begin	pointer
,	O
param	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_SUPER	int
:	O
printf	function
(	O
op	pointer
->	O
superscript_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_SUB	int
:	O
printf	function
(	O
op	pointer
->	O
subscript_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_STRIKE	int
:	O
printf	function
(	O
op	pointer
->	O
strikethru_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_DBL_STRIKE	int
:	O
printf	function
(	O
op	pointer
->	O
dbl_strikethru_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_EXPAND	int
:	O
printf	function
(	O
op	pointer
->	O
expand_begin	pointer
,	O
param	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_OUTLINE	int
:	O
printf	function
(	O
op	pointer
->	O
outline_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_SHADOW	int
:	O
printf	function
(	O
op	pointer
->	O
shadow_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_EMBOSS	int
:	O
printf	function
(	O
op	pointer
->	O
emboss_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_ENGRAVE	int
:	O
printf	function
(	O
op	pointer
->	O
engrave_begin	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_CAPS	int
:	O
if	O
(	O
op	pointer
->	O
simulate_all_caps	int
)	O
simulate_allcaps	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
ATTR_SMALLCAPS	int
:	O
if	O
(	O
op	pointer
->	O
simulate_small_caps	int
)	O
simulate_smallcaps	int
=	O
TRUE	O
;	O
else	O
{	O
if	O
(	O
op	pointer
->	O
small_caps_begin	pointer
)	O
printf	function
(	O
op	pointer
->	O
small_caps_begin	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
void	O
attr_express_end	function
(	O
int	O
attr	int
,	O
char	O
*	O
param	pointer
)	O
{	O
switch	O
(	O
attr	int
)	O
{	O
case	O
ATTR_BOLD	int
:	O
printf	function
(	O
op	pointer
->	O
bold_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_ITALIC	int
:	O
printf	function
(	O
op	pointer
->	O
italic_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_THICK_UL	int
:	O
case	O
ATTR_WAVE_UL	int
:	O
case	O
ATTR_DASH_UL	int
:	O
case	O
ATTR_DOT_UL	int
:	O
case	O
ATTR_DOT_DASH_UL	int
:	O
case	O
ATTR_2DOT_DASH_UL	int
:	O
case	O
ATTR_WORD_UL	int
:	O
case	O
ATTR_UNDERLINE	int
:	O
printf	function
(	O
op	pointer
->	O
underline_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_DOUBLE_UL	int
:	O
printf	function
(	O
op	pointer
->	O
dbl_underline_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_FONTSIZE	int
:	O
op_end_std_fontsize	function
(	O
op	pointer
,	O
atoi	function
(	O
param	pointer
)	O
)	O
;	O
break	O
;	O
case	O
ATTR_FONTFACE	int
:	O
printf	function
(	O
op	pointer
->	O
font_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_FOREGROUND	int
:	O
printf	function
(	O
op	pointer
->	O
foreground_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_BACKGROUND	int
:	O
if	O
(	O
!	O
simple_mode	int
)	O
printf	function
(	O
op	pointer
->	O
background_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_SUPER	int
:	O
printf	function
(	O
op	pointer
->	O
superscript_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_SUB	int
:	O
printf	function
(	O
op	pointer
->	O
subscript_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_STRIKE	int
:	O
printf	function
(	O
op	pointer
->	O
strikethru_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_DBL_STRIKE	int
:	O
printf	function
(	O
op	pointer
->	O
dbl_strikethru_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_OUTLINE	int
:	O
printf	function
(	O
op	pointer
->	O
outline_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_SHADOW	int
:	O
printf	function
(	O
op	pointer
->	O
shadow_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_EMBOSS	int
:	O
printf	function
(	O
op	pointer
->	O
emboss_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_ENGRAVE	int
:	O
printf	function
(	O
op	pointer
->	O
engrave_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_EXPAND	int
:	O
printf	function
(	O
op	pointer
->	O
expand_end	pointer
)	O
;	O
break	O
;	O
case	O
ATTR_CAPS	int
:	O
if	O
(	O
op	pointer
->	O
simulate_all_caps	int
)	O
simulate_allcaps	int
=	O
FALSE	O
;	O
break	O
;	O
case	O
ATTR_SMALLCAPS	int
:	O
if	O
(	O
op	pointer
->	O
simulate_small_caps	int
)	O
simulate_smallcaps	int
=	O
FALSE	O
;	O
else	O
{	O
if	O
(	O
op	pointer
->	O
small_caps_end	pointer
)	O
printf	function
(	O
op	pointer
->	O
small_caps_end	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
void	O
attr_push	function
(	O
int	O
attr	int
,	O
char	O
*	O
param	pointer
)	O
{	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
if	O
(	O
!	O
stack	pointer
)	O
{	O
warning_handler	function
(	O
"No stack to push attribute onto"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stack	pointer
->	O
tos	int
>=	O
MAX_ATTRS	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too many attributes!\n"	pointer
)	O
;	O
return	O
;	O
}	O
starting_body	function
(	O
)	O
;	O
starting_text	function
(	O
)	O
;	O
++	O
stack	pointer
->	O
tos	int
;	O
stack	pointer
->	O
attr_stack	array
[	O
stack	pointer
->	O
tos	int
]	O
=	O
attr	int
;	O
if	O
(	O
param	pointer
)	O
stack	pointer
->	O
attr_stack_params	array
[	O
stack	pointer
->	O
tos	int
]	O
=	O
my_strdup	function
(	O
param	pointer
)	O
;	O
else	O
stack	pointer
->	O
attr_stack_params	array
[	O
stack	pointer
->	O
tos	int
]	O
=	O
NULL	O
;	O
attr_express_begin	function
(	O
attr	int
,	O
param	pointer
)	O
;	O
}	O
char	O
*	O
attr_get_param	function
(	O
int	O
attr	int
)	O
{	O
int	O
i	int
;	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
if	O
(	O
!	O
stack	pointer
)	O
{	O
warning_handler	function
(	O
"No stack to get attribute from"	pointer
)	O
;	O
return	O
;	O
}	O
i	int
=	O
stack	pointer
->	O
tos	int
;	O
while	O
(	O
i	int
>=	O
0	int
)	O
{	O
if	O
(	O
stack	pointer
->	O
attr_stack	array
[	O
i	int
]	O
==	O
attr	int
)	O
{	O
if	O
(	O
stack	pointer
->	O
attr_stack_params	array
[	O
i	int
]	O
!=	O
NULL	O
)	O
return	O
stack	pointer
->	O
attr_stack_params	array
[	O
i	int
]	O
;	O
else	O
return	O
NULL	O
;	O
}	O
i	int
--	O
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
attrstack_copy_all	function
(	O
AttrStack	struct
*	O
src	pointer
,	O
AttrStack	struct
*	O
dest	pointer
)	O
{	O
int	O
i	int
;	O
int	O
total	int
;	O
CHECK_PARAM_NOT_NULL	O
(	O
src	pointer
)	O
;	O
CHECK_PARAM_NOT_NULL	O
(	O
dest	pointer
)	O
;	O
total	int
=	O
src	pointer
->	O
tos	int
+	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
total	int
;	O
i	int
++	O
)	O
{	O
int	O
attr	int
=	O
src	pointer
->	O
attr_stack	array
[	O
i	int
]	O
;	O
char	O
*	O
param	pointer
=	O
src	pointer
->	O
attr_stack_params	array
[	O
i	int
]	O
;	O
dest	pointer
->	O
attr_stack	array
[	O
i	int
]	O
=	O
attr	int
;	O
if	O
(	O
param	pointer
)	O
dest	pointer
->	O
attr_stack_params	array
[	O
i	int
]	O
=	O
my_strdup	function
(	O
param	pointer
)	O
;	O
else	O
dest	pointer
->	O
attr_stack_params	array
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
dest	pointer
->	O
tos	int
=	O
src	pointer
->	O
tos	int
;	O
}	O
void	O
attrstack_unexpress_all	function
(	O
AttrStack	struct
*	O
stack	pointer
)	O
{	O
int	O
i	int
;	O
CHECK_PARAM_NOT_NULL	O
(	O
stack	pointer
)	O
;	O
i	int
=	O
stack	pointer
->	O
tos	int
;	O
while	O
(	O
i	int
>=	O
0	int
)	O
{	O
int	O
attr	int
=	O
stack	pointer
->	O
attr_stack	array
[	O
i	int
]	O
;	O
char	O
*	O
param	pointer
=	O
stack	pointer
->	O
attr_stack_params	array
[	O
i	int
]	O
;	O
attr_express_end	function
(	O
attr	int
,	O
param	pointer
)	O
;	O
i	int
--	O
;	O
}	O
}	O
void	O
attrstack_push	function
(	O
)	O
{	O
AttrStack	struct
*	O
new_stack	pointer
;	O
AttrStack	struct
*	O
prev_stack	pointer
;	O
new_stack	pointer
=	O
(	O
AttrStack	struct
*	O
)	O
my_malloc	function
(	O
sizeof	O
(	O
AttrStack	struct
)	O
)	O
;	O
memset	function
(	O
(	O
void	O
*	O
)	O
new_stack	pointer
,	O
0	int
,	O
sizeof	O
(	O
AttrStack	struct
)	O
)	O
;	O
prev_stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
if	O
(	O
!	O
stack_of_stacks	pointer
)	O
{	O
stack_of_stacks	pointer
=	O
new_stack	pointer
;	O
}	O
else	O
{	O
stack_of_stacks_top	pointer
->	O
next	pointer
=	O
new_stack	pointer
;	O
}	O
stack_of_stacks_top	pointer
=	O
new_stack	pointer
;	O
new_stack	pointer
->	O
tos	int
=	O
-	O
1	int
;	O
if	O
(	O
prev_stack	pointer
)	O
{	O
attrstack_unexpress_all	function
(	O
prev_stack	pointer
)	O
;	O
attrstack_copy_all	function
(	O
prev_stack	pointer
,	O
new_stack	pointer
)	O
;	O
attrstack_express_all	function
(	O
)	O
;	O
}	O
}	O
int	O
attr_pop	function
(	O
int	O
attr	int
)	O
{	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
if	O
(	O
!	O
stack	pointer
)	O
{	O
warning_handler	function
(	O
"no stack to pop attribute from"	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
stack	pointer
->	O
tos	int
>=	O
0	int
&&	O
stack	pointer
->	O
attr_stack	array
[	O
stack	pointer
->	O
tos	int
]	O
==	O
attr	int
)	O
{	O
char	O
*	O
param	pointer
=	O
stack	pointer
->	O
attr_stack_params	array
[	O
stack	pointer
->	O
tos	int
]	O
;	O
attr_express_end	function
(	O
attr	int
,	O
param	pointer
)	O
;	O
if	O
(	O
param	pointer
)	O
my_free	function
(	O
param	pointer
)	O
;	O
stack	pointer
->	O
tos	int
--	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
int	O
attr_read	function
(	O
)	O
{	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
if	O
(	O
!	O
stack	pointer
)	O
{	O
warning_handler	function
(	O
"no stack to read attribute from"	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
stack	pointer
->	O
tos	int
>=	O
0	int
)	O
{	O
int	O
attr	int
=	O
stack	pointer
->	O
attr_stack	array
[	O
stack	pointer
->	O
tos	int
]	O
;	O
return	O
attr	int
;	O
}	O
else	O
return	O
ATTR_NONE	int
;	O
}	O
void	O
attr_drop_all	function
(	O
)	O
{	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
if	O
(	O
!	O
stack	pointer
)	O
{	O
warning_handler	function
(	O
"no stack to drop all attributes from"	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
stack	pointer
->	O
tos	int
>=	O
0	int
)	O
{	O
char	O
*	O
param	pointer
=	O
stack	pointer
->	O
attr_stack_params	array
[	O
stack	pointer
->	O
tos	int
]	O
;	O
if	O
(	O
param	pointer
)	O
my_free	function
(	O
param	pointer
)	O
;	O
stack	pointer
->	O
tos	int
--	O
;	O
}	O
}	O
void	O
attrstack_drop	function
(	O
)	O
{	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
AttrStack	struct
*	O
prev_stack	pointer
;	O
if	O
(	O
!	O
stack	pointer
)	O
{	O
warning_handler	function
(	O
"no attr-stack to drop"	pointer
)	O
;	O
return	O
;	O
}	O
attr_pop_all	function
(	O
)	O
;	O
prev_stack	pointer
=	O
stack_of_stacks	pointer
;	O
while	O
(	O
prev_stack	pointer
&&	O
prev_stack	pointer
->	O
next	pointer
&&	O
prev_stack	pointer
->	O
next	pointer
!=	O
stack	pointer
)	O
prev_stack	pointer
=	O
prev_stack	pointer
->	O
next	pointer
;	O
if	O
(	O
prev_stack	pointer
)	O
{	O
stack_of_stacks_top	pointer
=	O
prev_stack	pointer
;	O
prev_stack	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
stack_of_stacks_top	pointer
=	O
NULL	O
;	O
stack_of_stacks	pointer
=	O
NULL	O
;	O
}	O
my_free	function
(	O
(	O
void	O
*	O
)	O
stack	pointer
)	O
;	O
attrstack_express_all	function
(	O
)	O
;	O
}	O
void	O
attr_pop_all	function
(	O
)	O
{	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
if	O
(	O
!	O
stack	pointer
)	O
{	O
warning_handler	function
(	O
"no stack to pop from"	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
stack	pointer
->	O
tos	int
>=	O
0	int
)	O
{	O
int	O
attr	int
=	O
stack	pointer
->	O
attr_stack	array
[	O
stack	pointer
->	O
tos	int
]	O
;	O
char	O
*	O
param	pointer
=	O
stack	pointer
->	O
attr_stack_params	array
[	O
stack	pointer
->	O
tos	int
]	O
;	O
attr_express_end	function
(	O
attr	int
,	O
param	pointer
)	O
;	O
if	O
(	O
param	pointer
)	O
my_free	function
(	O
param	pointer
)	O
;	O
stack	pointer
->	O
tos	int
--	O
;	O
}	O
}	O
void	O
attrstack_express_all	function
(	O
)	O
{	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
int	O
i	int
;	O
if	O
(	O
!	O
stack	pointer
)	O
{	O
warning_handler	function
(	O
"no stack to pop from"	pointer
)	O
;	O
return	O
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<=	O
stack	pointer
->	O
tos	int
)	O
{	O
int	O
attr	int
=	O
stack	pointer
->	O
attr_stack	array
[	O
i	int
]	O
;	O
char	O
*	O
param	pointer
=	O
stack	pointer
->	O
attr_stack_params	array
[	O
i	int
]	O
;	O
attr_express_begin	function
(	O
attr	int
,	O
param	pointer
)	O
;	O
i	int
++	O
;	O
}	O
}	O
void	O
attr_pop_dump	function
(	O
)	O
{	O
AttrStack	struct
*	O
stack	pointer
=	O
stack_of_stacks_top	pointer
;	O
int	O
i	int
;	O
if	O
(	O
!	O
stack	pointer
)	O
return	O
;	O
i	int
=	O
stack	pointer
->	O
tos	int
;	O
while	O
(	O
i	int
>=	O
0	int
)	O
{	O
int	O
attr	int
=	O
stack	pointer
->	O
attr_stack	array
[	O
i	int
]	O
;	O
attr_pop	function
(	O
attr	int
)	O
;	O
i	int
--	O
;	O
}	O
}	O
