extern	O
FILE	struct
*	O
option_usage_fp	pointer
;	O
size_t	long
separator_str_len	long
=	O
6	int
;	O
extern	O
void	O
init_unshar	function
(	O
void	O
)	O
;	O
char	O
const	O
*	O
const	O
program_name	pointer
=	O
"unshar"	pointer
;	O
static	O
char	O
const	O
unshar_opt_strs	array
[	O
3901	int
]	O
=	O
"unshar (GNU sharutils) 4.15\n"	pointer
"Copyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\n"	pointer
"This is free software. It is licensed for use, modification and\n"	pointer
"redistribution under the terms of the GNU General Public License,\n"	pointer
"version 3 or later <http://gnu.org/licenses/gpl.html>\n\0"	pointer
"unshar is free software: you can redistribute it and/or modify it under the\n"	pointer
"terms of the GNU General Public License as published by the Free Software\n"	pointer
"Foundation, either version 3 of the License, or (at your option) any later\n"	pointer
"version.\n\n"	pointer
"unshar is distributed in the hope that it will be useful, but WITHOUT ANY\n"	pointer
"WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"	pointer
"FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n"	pointer
"details.\n\n"	pointer
"You should have received a copy of the GNU General Public License along\n"	pointer
"with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"	pointer
"unpack into the directory dir\0"	pointer
"DIRECTORY\0"	pointer
"directory\0"	pointer
"overwrite any pre-existing files\0"	pointer
"OVERWRITE\0"	pointer
"overwrite\0"	pointer
"an alias for the 'overwrite' option\0"	pointer
"force\0"	pointer
"split input on split-mark lines\0"	pointer
"SPLIT_AT\0"	pointer
"split-at\0"	pointer
"exit 0\0"	pointer
"split input on \"exit 0\" lines\0"	pointer
"EXIT_0\0"	pointer
"exit-0\0"	pointer
"debug the shell code\0"	pointer
"DEBUG\0"	pointer
"debug\0"	pointer
"display extended usage information and exit\0"	pointer
"help\0"	pointer
"extended usage information passed thru pager\0"	pointer
"more-help\0"	pointer
"output version information and exit\0"	pointer
"version\0"	pointer
"save the option state to a config file\0"	pointer
"save-opts\0"	pointer
"load options from a config file\0"	pointer
"LOAD_OPTS\0"	pointer
"no-load-opts\0"	pointer
"no\0"	pointer
"UNSHAR\0"	pointer
"unshar (GNU sharutils) - unpack a shar archive\n"	pointer
"Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\0"	pointer
"$HOME\0"	pointer
".sharrc\0"	pointer
"bug-gnu-utils@gnu.org\0"	pointer
"\n"	pointer
"If no arguments are provided, input arguments are read from stdin,\n"	pointer
"one per line; blank and '#'-prefixed lines are comments.\n"	pointer
"'stdin' may not be a terminal (tty).\n\0"	pointer
"Unshar scans the input files (typically email messages) looking for the\n"	pointer
"start of a shell archive.  If no files are given, then standard input is\n"	pointer
"processed instead.  It then passes each archive discovered through an\n"	pointer
"invocation of the shell program to unpack it.\n\0"	pointer
"unshar (GNU sharutils) 4.15\0"	pointer
"unshar (GNU sharutils) - unpack a shar archive\n"	pointer
"Usage:  unshar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\n"	pointer
"   -d, --directory=DIR        unpack into the directory DIR\n"	pointer
"   -c, --overwrite            overwrite any pre-existing files\n"	pointer
"   -f, --force                an alias for the 'overwrite' option\n"	pointer
"   -E, --split-at=SPLIT-PAT   split input on SPLIT-PAT lines\n"	pointer
"   -e, --exit-0               split input on \"exit 0\" lines\n"	pointer
"                                - prohibits the option 'split-at'\n"	pointer
"   -D, --debug                debug the shell code\n"	pointer
"   -v, --version[=MODE]       output version information and exit\n"	pointer
"   -h, --help                 display extended usage information and exit\n"	pointer
"   -!, --more-help            extended usage information passed thru pager\n"	pointer
"   -R, --save-opts[=FILE]     save the option state to the config file FILE\n"	pointer
"   -r, --load-opts=FILE       load options from the config file FILE\n"	pointer
"                                - disabled as '--no-load-opts'\n"	pointer
"                                - may appear multiple times\n\n"	pointer
"Options are specified by doubled hyphens and their name or by a single\n"	pointer
"hyphen and the flag character.\n\n"	pointer
"If no arguments are provided, input arguments are read from stdin,\n"	pointer
"one per line; blank and '#'-prefixed lines are comments.\n"	pointer
"'stdin' may not be a terminal (tty).\n\n"	pointer
"The following option preset mechanisms are supported:\n"	pointer
" - reading file $HOME/.sharrc\n\n"	pointer
"'unshar' scans the input files (typically email messages) looking for the\n"	pointer
"start of a shell archive.  If no files are given, then standard input is\n"	pointer
"processed instead.  It then passes each archive discovered through an\n"	pointer
"invocation of the shell program to unpack it.\n\n"	pointer
"Please send bug reports to:  <bug-gnu-utils@gnu.org>\n\0"	pointer
"unshar (GNU sharutils) - unpack a shar archive\n"	pointer
"Usage:  unshar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n"	pointer
"Try 'unshar --help' for more information.\n"	pointer
;	O
static	O
int	O
const	O
aExit_0CantList	array
[	O
]	O
=	O
{	O
INDEX_OPT_SPLIT_AT	int
,	O
NO_EQUIVALENT	O
}	O
;	O
extern	O
tOptProc	function
optionBooleanVal	function
,	O
optionNestedVal	function
,	O
optionNumericVal	function
,	O
optionPagedUsage	function
,	O
optionPrintVersion	function
,	O
optionResetOpt	function
,	O
optionStackArg	function
,	O
optionTimeDate	function
,	O
optionTimeVal	function
,	O
optionUnstackArg	function
,	O
optionVendorOption	function
;	O
static	O
tOptProc	function
doOptExit_0	function
,	O
doOptForce	function
,	O
doOptSplit_At	function
,	O
doUsageOpt	function
;	O
static	O
tOptDesc	struct
optDesc	array
[	O
OPTION_CT	int
]	O
=	O
{	O
{	O
0	int
,	O
VALUE_OPT_DIRECTORY	char
,	O
0	int
,	O
VALUE_OPT_DIRECTORY	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
DIRECTORY_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
DIRECTORY_DESC	O
,	O
DIRECTORY_NAME	O
,	O
DIRECTORY_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
1	int
,	O
VALUE_OPT_OVERWRITE	char
,	O
1	int
,	O
VALUE_OPT_OVERWRITE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OVERWRITE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
OVERWRITE_DESC	O
,	O
OVERWRITE_NAME	O
,	O
OVERWRITE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
2	int
,	O
VALUE_OPT_FORCE	char
,	O
2	int
,	O
VALUE_OPT_FORCE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
FORCE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptForce	function
,	O
FORCE_DESC	O
,	O
FORCE_NAME	O
,	O
FORCE_name	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
3	int
,	O
VALUE_OPT_SPLIT_AT	char
,	O
3	int
,	O
VALUE_OPT_SPLIT_AT	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
SPLIT_AT_FLAGS	O
,	O
0	int
,	O
{	O
SPLIT_AT_DFT_ARG	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptSplit_At	function
,	O
SPLIT_AT_DESC	O
,	O
SPLIT_AT_NAME	O
,	O
SPLIT_AT_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
4	int
,	O
VALUE_OPT_EXIT_0	char
,	O
4	int
,	O
VALUE_OPT_EXIT_0	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
EXIT_0_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
aExit_0CantList	array
,	O
doOptExit_0	function
,	O
EXIT_0_DESC	O
,	O
EXIT_0_NAME	O
,	O
EXIT_0_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
5	int
,	O
VALUE_OPT_DEBUG	char
,	O
5	int
,	O
VALUE_OPT_DEBUG	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
DEBUG_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
DEBUG_DESC	O
,	O
DEBUG_NAME	O
,	O
DEBUG_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_VERSION	int
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
VER_FLAGS	O
,	O
AOUSE_VERSION	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
VER_PROC	O
,	O
VER_DESC	O
,	O
NULL	O
,	O
VER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_HELP	int
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_IMM	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doUsageOpt	function
,	O
HELP_DESC	O
,	O
NULL	O
,	O
HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
MORE_HELP_FLAGS	O
,	O
AOUSE_MORE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionPagedUsage	function
,	O
MORE_HELP_DESC	O
,	O
NULL	O
,	O
MORE_HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_SAVE_OPTS	int
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_ARG_OPTIONAL	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_SAVE_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SAVE_OPTS_DESC	O
,	O
NULL	O
,	O
SAVE_OPTS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_LOAD_OPTS	int
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_DISABLE_IMM	int
,	O
AOUSE_LOAD_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionLoadOpt	function
,	O
LOAD_OPTS_DESC	O
,	O
LOAD_OPTS_NAME	O
,	O
LOAD_OPTS_name	O
,	O
NO_LOAD_OPTS_name	O
,	O
LOAD_OPTS_pfx	O
}	O
}	O
;	O
static	O
char	O
const	O
*	O
const	O
apzHomeList	array
[	O
2	int
]	O
=	O
{	O
unshar_opt_strs	array
+	O
1549	int
,	O
NULL	O
}	O
;	O
static	O
tOptionXlateProc	function
translate_option_strings	function
;	O
static	O
void	O
doUsageOpt	function
(	O
tOptions	struct
*	O
opts	pointer
,	O
tOptDesc	struct
*	O
od	pointer
)	O
{	O
int	O
ex_code	int
;	O
ex_code	int
=	O
UNSHAR_EXIT_SUCCESS	int
;	O
optionUsage	function
(	O
&	O
unsharOptions	struct
,	O
ex_code	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
(	O
void	O
)	O
opts	pointer
;	O
(	O
void	O
)	O
od	pointer
;	O
}	O
static	O
void	O
doOptForce	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
int	O
res	int
=	O
optionAlias	function
(	O
pOptions	pointer
,	O
pOptDesc	pointer
,	O
INDEX_OPT_OVERWRITE	int
)	O
;	O
if	O
(	O
(	O
res	int
!=	O
0	int
)	O
&&	O
(	O
(	O
pOptions	pointer
->	O
fOptSet	int
&	O
OPTPROC_ERRSTOP	int
)	O
!=	O
0	int
)	O
)	O
USAGE	O
(	O
UNSHAR_EXIT_USAGE_ERROR	int
)	O
;	O
}	O
static	O
void	O
doOptSplit_At	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
separator_str_len	long
=	O
strlen	function
(	O
pOptDesc	pointer
->	O
optArg	union
.	O
argString	pointer
)	O
;	O
(	O
void	O
)	O
pOptions	pointer
;	O
}	O
static	O
void	O
doOptExit_0	function
(	O
tOptions	struct
*	O
pOptions	pointer
,	O
tOptDesc	struct
*	O
pOptDesc	pointer
)	O
{	O
SET_OPT_SPLIT_AT	O
(	O
"exit 0"	pointer
)	O
;	O
(	O
void	O
)	O
pOptDesc	pointer
;	O
(	O
void	O
)	O
pOptions	pointer
;	O
}	O
extern	O
int	O
unshar_file	function
(	O
char	O
const	O
*	O
pz_fname	pointer
,	O
FILE	struct
*	O
entry_fp	pointer
)	O
;	O
static	O
unshar_exit_code_t	enum
validate_fname	function
(	O
char	O
const	O
*	O
pz_fname	pointer
)	O
{	O
static	O
char	O
const	O
*	O
pz_fs_err	pointer
=	O
NULL	O
;	O
if	O
(	O
pz_fs_err	pointer
==	O
NULL	O
)	O
pz_fs_err	pointer
=	O
_	O
(	O
"fs error %d (%s) %s-ing %s\n"	pointer
)	O
;	O
if	O
(	O
(	O
pz_fname	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
&&	O
(	O
pz_fname	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
return	O
unshar_file	function
(	O
_	O
(	O
"standard input"	pointer
)	O
,	O
stdin	pointer
)	O
;	O
{	O
struct	O
stat	struct
sb	struct
;	O
if	O
(	O
stat	struct
(	O
pz_fname	pointer
,	O
&	O
sb	struct
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
pz_fs_err	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
"stat"	pointer
,	O
pz_fname	pointer
)	O
;	O
return	O
UNSHAR_EXIT_NO_CONFIG_INPUT	int
;	O
}	O
}	O
{	O
int	O
res	int
;	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
pz_fname	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
pz_fs_err	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
"fopen"	pointer
,	O
pz_fname	pointer
)	O
;	O
return	O
UNSHAR_EXIT_NO_CONFIG_INPUT	int
;	O
}	O
res	int
=	O
unshar_file	function
(	O
pz_fname	pointer
,	O
fp	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
res	int
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
res	int
=	O
0	int
;	O
int	O
proc_ct	int
=	O
0	int
;	O
int	O
arg_ix	int
=	O
optionProcess	function
(	O
&	O
unsharOptions	struct
,	O
argc	int
,	O
argv	pointer
)	O
;	O
init_unshar	function
(	O
)	O
;	O
if	O
(	O
arg_ix	int
<	O
argc	int
)	O
{	O
for	O
(	O
;	O
arg_ix	int
<	O
argc	int
;	O
arg_ix	int
++	O
)	O
{	O
char	O
*	O
arg	pointer
=	O
argv	pointer
[	O
arg_ix	int
]	O
;	O
res	int
|=	O
validate_fname	function
(	O
arg	pointer
)	O
;	O
proc_ct	int
++	O
;	O
}	O
}	O
else	O
res	int
=	O
unshar_file	function
(	O
_	O
(	O
"standard input"	pointer
)	O
,	O
stdin	pointer
)	O
;	O
return	O
res	int
;	O
}	O
void	O
vusage_message	function
(	O
char	O
const	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
char	O
const	O
*	O
er_leader	pointer
=	O
_	O
(	O
"unshar usage error:\n"	pointer
)	O
;	O
fputs	function
(	O
er_leader	pointer
,	O
stderr	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
optionUsage	function
(	O
&	O
unsharOptions	struct
,	O
UNSHAR_EXIT_USAGE_ERROR	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
void	O
usage_message	function
(	O
char	O
const	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vusage_message	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
vdie	function
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
char	O
const	O
*	O
die_leader	pointer
=	O
_	O
(	O
"unshar fatal error:\n"	pointer
)	O
;	O
fputs	function
(	O
die_leader	pointer
,	O
stderr	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
exit	function
(	O
exit_code	int
)	O
;	O
}	O
void	O
die	function
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vdie	function
(	O
exit_code	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
fserr	function
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
op	pointer
,	O
char	O
const	O
*	O
fname	pointer
)	O
{	O
char	O
const	O
*	O
fserr_fmt	pointer
=	O
_	O
(	O
"fserr %d (%s) performing '%s' on %s\n"	pointer
)	O
;	O
die	function
(	O
exit_code	int
,	O
fserr_fmt	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
op	pointer
,	O
fname	pointer
)	O
;	O
}	O
tOptions	struct
unsharOptions	struct
=	O
{	O
OPTIONS_STRUCT_VERSION	int
,	O
0	int
,	O
NULL	O
,	O
(	O
OPTPROC_BASE	O
+	O
OPTPROC_ERRSTOP	int
+	O
OPTPROC_SHORTOPT	int
+	O
OPTPROC_LONGOPT	int
+	O
OPTPROC_NO_REQ_OPT	int
+	O
OPTPROC_GNUUSAGE	int
+	O
OPTPROC_MISUSE	int
)	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
zPROGNAME	O
,	O
zRcName	O
,	O
zCopyright	O
,	O
zLicenseDescrip	O
,	O
zFullVersion	O
,	O
apzHomeList	array
,	O
zUsageTitle	O
,	O
zExplain	O
,	O
zDetail	O
,	O
optDesc	array
,	O
zBugsAddr	O
,	O
NULL	O
,	O
NULL	O
,	O
optionUsage	function
,	O
translate_option_strings	function
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
INDEX_OPT_SAVE_OPTS	int
,	O
NO_EQUIVALENT	O
,	O
NO_EQUIVALENT	O
}	O
,	O
11	int
,	O
6	int
,	O
unshar_full_usage	O
,	O
unshar_short_usage	O
,	O
NULL	O
,	O
NULL	O
,	O
PKGDATADIR	pointer
,	O
unshar_packager_info	O
}	O
;	O
static	O
char	O
*	O
AO_gettext	function
(	O
char	O
const	O
*	O
pz	pointer
)	O
;	O
static	O
void	O
coerce_it	function
(	O
void	O
*	O
*	O
s	enum
)	O
;	O
static	O
char	O
*	O
AO_gettext	function
(	O
char	O
const	O
*	O
pz	pointer
)	O
{	O
char	O
*	O
res	int
;	O
if	O
(	O
pz	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
option_xlateable_txt	struct
.	O
field_ct	int
!=	O
0	int
)	O
{	O
res	int
=	O
dgettext	function
(	O
"libopts"	pointer
,	O
pz	pointer
)	O
;	O
if	O
(	O
res	int
==	O
pz	pointer
)	O
res	int
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	pointer
)	O
)	O
;	O
}	O
else	O
res	int
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	pointer
)	O
)	O
;	O
if	O
(	O
res	int
==	O
pz	pointer
)	O
return	O
res	int
;	O
res	int
=	O
strdup	function
(	O
res	int
)	O
;	O
if	O
(	O
res	int
==	O
NULL	O
)	O
{	O
fputs	function
(	O
_	O
(	O
"No memory for duping translated strings\n"	pointer
)	O
,	O
stderr	pointer
)	O
;	O
exit	function
(	O
UNSHAR_EXIT_NOMEM	int
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
void	O
coerce_it	function
(	O
void	O
*	O
*	O
s	enum
)	O
{	O
*	O
s	enum
=	O
AO_gettext	function
(	O
*	O
s	enum
)	O
;	O
}	O
static	O
void	O
translate_option_strings	function
(	O
void	O
)	O
{	O
tOptions	struct
*	O
const	O
opts	pointer
=	O
&	O
unsharOptions	struct
;	O
if	O
(	O
option_xlateable_txt	struct
.	O
field_ct	int
!=	O
0	int
)	O
{	O
char	O
*	O
*	O
ppz	pointer
=	O
(	O
char	O
*	O
*	O
)	O
VOIDP	O
(	O
&	O
(	O
option_xlateable_txt	struct
)	O
)	O
;	O
int	O
ix	int
=	O
option_xlateable_txt	struct
.	O
field_ct	int
;	O
do	O
{	O
ppz	pointer
++	O
;	O
*	O
ppz	pointer
=	O
AO_gettext	function
(	O
*	O
ppz	pointer
)	O
;	O
}	O
while	O
(	O
--	O
ix	int
>	O
0	int
)	O
;	O
option_xlateable_txt	struct
.	O
field_ct	int
=	O
0	int
;	O
coerce_it	function
(	O
VOIDP	O
(	O
&	O
(	O
opts	pointer
->	O
pzCopyright	pointer
)	O
)	O
)	O
;	O
coerce_it	function
(	O
VOIDP	O
(	O
&	O
(	O
opts	pointer
->	O
pzCopyNotice	pointer
)	O
)	O
)	O
;	O
coerce_it	function
(	O
VOIDP	O
(	O
&	O
(	O
opts	pointer
->	O
pzFullVersion	pointer
)	O
)	O
)	O
;	O
}	O
}	O
