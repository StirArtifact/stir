static	O
int	O
is_initialized	int
;	O
static	O
byte	char
*	O
rndpool	pointer
;	O
static	O
byte	char
*	O
keypool	pointer
;	O
static	O
size_t	long
pool_readpos	long
;	O
static	O
size_t	long
pool_writepos	long
;	O
static	O
int	O
pool_filled	int
;	O
static	O
int	O
pool_balance	int
;	O
static	O
int	O
just_mixed	int
;	O
static	O
int	O
did_initial_extra_seeding	int
;	O
static	O
char	O
*	O
seed_file_name	pointer
;	O
static	O
int	O
allow_seed_file_update	int
;	O
static	O
int	O
secure_alloc	int
;	O
static	O
int	O
quick_test	int
;	O
static	O
int	O
faked_rng	int
;	O
int	O
read_pool	function
(	O
byte	char
*	O
buffer	pointer
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
;	O
static	O
void	O
add_randomness	function
(	O
const	O
void	O
*	O
buffer	pointer
,	O
size_t	long
length	long
,	O
int	O
source	int
)	O
;	O
static	O
void	O
random_poll	function
(	O
void	O
)	O
;	O
static	O
int	O
read_random_source	function
(	O
int	O
requester	int
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
;	O
static	O
int	O
gather_faked	function
(	O
void	O
(	O
*	O
add	pointer
)	O
(	O
const	O
void	O
*	O
,	O
size_t	long
,	O
int	O
)	O
,	O
int	O
requester	int
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
;	O
static	O
struct	O
{	O
ulong	long
mixrnd	long
;	O
ulong	long
mixkey	long
;	O
ulong	long
slowpolls	long
;	O
ulong	long
fastpolls	long
;	O
ulong	long
getbytes1	long
;	O
ulong	long
ngetbytes1	long
;	O
ulong	long
getbytes2	long
;	O
ulong	long
ngetbytes2	long
;	O
ulong	long
addbytes	long
;	O
ulong	long
naddbytes	long
;	O
}	O
rndstats	struct
;	O
static	O
void	O
initialize	function
(	O
void	O
)	O
{	O
rndpool	pointer
=	O
secure_alloc	int
?	O
m_alloc_secure_clear	O
(	O
POOLSIZE	O
+	O
BLOCKLEN	int
)	O
:	O
m_alloc_clear	O
(	O
POOLSIZE	O
+	O
BLOCKLEN	int
)	O
;	O
keypool	pointer
=	O
secure_alloc	int
?	O
m_alloc_secure_clear	O
(	O
POOLSIZE	O
+	O
BLOCKLEN	int
)	O
:	O
m_alloc_clear	O
(	O
POOLSIZE	O
+	O
BLOCKLEN	int
)	O
;	O
is_initialized	int
=	O
1	int
;	O
}	O
static	O
void	O
burn_stack	function
(	O
int	O
bytes	int
)	O
{	O
char	O
buf	array
[	O
128	int
]	O
;	O
memset	function
(	O
buf	array
,	O
0	int
,	O
sizeof	O
buf	array
)	O
;	O
bytes	int
-=	O
sizeof	O
buf	array
;	O
if	O
(	O
bytes	int
>	O
0	int
)	O
burn_stack	function
(	O
bytes	int
)	O
;	O
}	O
void	O
random_dump_stats	function
(	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"random usage: poolsize=%d mixed=%lu polls=%lu/%lu added=%lu/%lu\n"	pointer
"              outmix=%lu getlvl1=%lu/%lu getlvl2=%lu/%lu\n"	pointer
,	O
POOLSIZE	O
,	O
rndstats	struct
.	O
mixrnd	long
,	O
rndstats	struct
.	O
slowpolls	long
,	O
rndstats	struct
.	O
fastpolls	long
,	O
rndstats	struct
.	O
naddbytes	long
,	O
rndstats	struct
.	O
addbytes	long
,	O
rndstats	struct
.	O
mixkey	long
,	O
rndstats	struct
.	O
ngetbytes1	long
,	O
rndstats	struct
.	O
getbytes1	long
,	O
rndstats	struct
.	O
ngetbytes2	long
,	O
rndstats	struct
.	O
getbytes2	long
)	O
;	O
}	O
void	O
secure_random_alloc	function
(	O
)	O
{	O
secure_alloc	int
=	O
1	int
;	O
}	O
int	O
quick_random_gen	function
(	O
int	O
onoff	int
)	O
{	O
int	O
last	int
;	O
read_random_source	function
(	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
last	int
=	O
quick_test	int
;	O
if	O
(	O
onoff	int
!=	O
-	O
1	int
)	O
quick_test	int
=	O
onoff	int
;	O
return	O
faked_rng	int
?	O
1	int
:	O
last	int
;	O
}	O
void	O
randomize_buffer	function
(	O
byte	char
*	O
buffer	pointer
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
byte	char
*	O
p	pointer
=	O
get_random_bits	function
(	O
length	long
*	O
8	int
,	O
level	int
,	O
1	int
)	O
;	O
memcpy	function
(	O
buffer	pointer
,	O
p	pointer
,	O
length	long
)	O
;	O
m_free	O
(	O
p	pointer
)	O
;	O
}	O
int	O
random_is_faked	function
(	O
)	O
{	O
if	O
(	O
!	O
is_initialized	int
)	O
initialize	function
(	O
)	O
;	O
return	O
faked_rng	int
||	O
quick_test	int
;	O
}	O
byte	char
*	O
get_random_bits	function
(	O
size_t	long
nbits	long
,	O
int	O
level	int
,	O
int	O
secure	int
)	O
{	O
byte	char
*	O
buf	array
,	O
*	O
p	pointer
;	O
size_t	long
nbytes	long
=	O
(	O
nbits	long
+	O
7	int
)	O
/	O
8	int
;	O
if	O
(	O
quick_test	int
&&	O
level	int
>	O
1	int
)	O
level	int
=	O
1	int
;	O
MASK_LEVEL	O
(	O
level	int
)	O
;	O
if	O
(	O
level	int
==	O
1	int
)	O
{	O
rndstats	struct
.	O
getbytes1	long
+=	O
nbytes	long
;	O
rndstats	struct
.	O
ngetbytes1	long
++	O
;	O
}	O
else	O
if	O
(	O
level	int
>=	O
2	int
)	O
{	O
rndstats	struct
.	O
getbytes2	long
+=	O
nbytes	long
;	O
rndstats	struct
.	O
ngetbytes2	long
++	O
;	O
}	O
buf	array
=	O
secure	int
&&	O
secure_alloc	int
?	O
m_alloc_secure	O
(	O
nbytes	long
)	O
:	O
m_alloc	O
(	O
nbytes	long
)	O
;	O
for	O
(	O
p	pointer
=	O
buf	array
;	O
nbytes	long
>	O
0	int
;	O
)	O
{	O
size_t	long
n	long
=	O
nbytes	long
>	O
POOLSIZE	O
?	O
POOLSIZE	O
:	O
nbytes	long
;	O
n	long
=	O
read_pool	function
(	O
p	pointer
,	O
n	long
,	O
level	int
)	O
;	O
nbytes	long
-=	O
n	long
;	O
p	pointer
+=	O
n	long
;	O
}	O
return	O
buf	array
;	O
}	O
static	O
void	O
mix_pool	function
(	O
byte	char
*	O
pool	pointer
)	O
{	O
byte	char
*	O
hashbuf	pointer
=	O
pool	pointer
+	O
POOLSIZE	O
;	O
byte	char
*	O
p	pointer
,	O
*	O
pend	pointer
;	O
int	O
i	int
,	O
n	long
;	O
RMD160_CONTEXT	struct
md	struct
;	O
rmd160_init	function
(	O
&	O
md	struct
)	O
;	O
pend	pointer
=	O
pool	pointer
+	O
POOLSIZE	O
;	O
memcpy	function
(	O
hashbuf	pointer
,	O
pend	pointer
-	O
DIGESTLEN	int
,	O
DIGESTLEN	int
)	O
;	O
memcpy	function
(	O
hashbuf	pointer
+	O
DIGESTLEN	int
,	O
pool	pointer
,	O
BLOCKLEN	int
-	O
DIGESTLEN	int
)	O
;	O
rmd160_mixblock	function
(	O
&	O
md	struct
,	O
hashbuf	pointer
)	O
;	O
memcpy	function
(	O
pool	pointer
,	O
hashbuf	pointer
,	O
DIGESTLEN	int
)	O
;	O
p	pointer
=	O
pool	pointer
;	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
POOLBLOCKS	int
;	O
n	long
++	O
)	O
{	O
if	O
(	O
p	pointer
+	O
BLOCKLEN	int
<	O
pend	pointer
)	O
memcpy	function
(	O
hashbuf	pointer
,	O
p	pointer
,	O
BLOCKLEN	int
)	O
;	O
else	O
{	O
byte	char
*	O
pp	pointer
=	O
p	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
BLOCKLEN	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pp	pointer
>=	O
pend	pointer
)	O
pp	pointer
=	O
pool	pointer
;	O
hashbuf	pointer
[	O
i	int
]	O
=	O
*	O
pp	pointer
++	O
;	O
}	O
}	O
rmd160_mixblock	function
(	O
&	O
md	struct
,	O
hashbuf	pointer
)	O
;	O
p	pointer
+=	O
DIGESTLEN	int
;	O
memcpy	function
(	O
p	pointer
,	O
hashbuf	pointer
,	O
DIGESTLEN	int
)	O
;	O
}	O
burn_stack	function
(	O
200	int
)	O
;	O
}	O
void	O
set_random_seed_file	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
seed_file_name	pointer
)	O
BUG	O
(	O
)	O
;	O
seed_file_name	pointer
=	O
m_strdup	O
(	O
name	pointer
)	O
;	O
}	O
static	O
int	O
read_seed_file	function
(	O
)	O
{	O
int	O
fd	int
;	O
struct	O
stat	struct
sb	struct
;	O
byte	char
buffer	pointer
[	O
POOLSIZE	O
]	O
;	O
int	O
n	long
;	O
if	O
(	O
!	O
seed_file_name	pointer
)	O
return	O
0	int
;	O
fd	int
=	O
open	function
(	O
seed_file_name	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
&&	O
errno	O
==	O
ENOENT	int
)	O
{	O
allow_seed_file_update	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
log_info	O
(	O
_	O
(	O
"can't open `%s': %s\n"	pointer
)	O
,	O
seed_file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
fstat	function
(	O
fd	int
,	O
&	O
sb	struct
)	O
)	O
{	O
log_info	O
(	O
_	O
(	O
"can't stat `%s': %s\n"	pointer
)	O
,	O
seed_file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
sb	struct
.	O
st_mode	int
)	O
)	O
{	O
log_info	O
(	O
_	O
(	O
"`%s' is not a regular file - ignored\n"	pointer
)	O
,	O
seed_file_name	pointer
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
sb	struct
.	O
st_size	long
)	O
{	O
log_info	O
(	O
_	O
(	O
"note: random_seed file is empty\n"	pointer
)	O
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
allow_seed_file_update	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
sb	struct
.	O
st_size	long
!=	O
POOLSIZE	O
)	O
{	O
log_info	O
(	O
_	O
(	O
"warning: invalid size of random_seed file - not used\n"	pointer
)	O
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
do	O
{	O
n	long
=	O
read	pointer
(	O
fd	int
,	O
buffer	pointer
,	O
POOLSIZE	O
)	O
;	O
}	O
while	O
(	O
n	long
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
n	long
!=	O
POOLSIZE	O
)	O
{	O
log_fatal	O
(	O
_	O
(	O
"can't read `%s': %s\n"	pointer
)	O
,	O
seed_file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
close	pointer
(	O
fd	int
)	O
;	O
add_randomness	function
(	O
buffer	pointer
,	O
POOLSIZE	O
,	O
0	int
)	O
;	O
{	O
pid_t	int
x	int
=	O
getpid	function
(	O
)	O
;	O
add_randomness	function
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
0	int
)	O
;	O
}	O
{	O
time_t	long
x	int
=	O
time	struct
(	O
NULL	O
)	O
;	O
add_randomness	function
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
0	int
)	O
;	O
}	O
{	O
clock_t	long
x	int
=	O
clock	function
(	O
)	O
;	O
add_randomness	function
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
0	int
)	O
;	O
}	O
read_random_source	function
(	O
0	int
,	O
16	int
,	O
0	int
)	O
;	O
allow_seed_file_update	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
void	O
update_random_seed_file	function
(	O
)	O
{	O
ulong	long
*	O
sp	pointer
,	O
*	O
dp	pointer
;	O
int	O
fd	int
,	O
i	int
;	O
if	O
(	O
!	O
seed_file_name	pointer
||	O
!	O
is_initialized	int
||	O
!	O
pool_filled	int
)	O
return	O
;	O
if	O
(	O
!	O
allow_seed_file_update	int
)	O
{	O
log_info	O
(	O
_	O
(	O
"note: random_seed file not updated\n"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
dp	pointer
=	O
(	O
ulong	long
*	O
)	O
keypool	pointer
,	O
sp	pointer
=	O
(	O
ulong	long
*	O
)	O
rndpool	pointer
;	O
i	int
<	O
POOLWORDS	O
;	O
i	int
++	O
,	O
dp	pointer
++	O
,	O
sp	pointer
++	O
)	O
{	O
*	O
dp	pointer
=	O
*	O
sp	pointer
+	O
ADD_VALUE	int
;	O
}	O
mix_pool	function
(	O
rndpool	pointer
)	O
;	O
rndstats	struct
.	O
mixrnd	long
++	O
;	O
mix_pool	function
(	O
keypool	pointer
)	O
;	O
rndstats	struct
.	O
mixkey	long
++	O
;	O
fd	int
=	O
open	function
(	O
seed_file_name	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
log_info	O
(	O
_	O
(	O
"can't create `%s': %s\n"	pointer
)	O
,	O
seed_file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
do	O
{	O
i	int
=	O
write	pointer
(	O
fd	int
,	O
keypool	pointer
,	O
POOLSIZE	O
)	O
;	O
}	O
while	O
(	O
i	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
i	int
!=	O
POOLSIZE	O
)	O
{	O
log_info	O
(	O
_	O
(	O
"can't write `%s': %s\n"	pointer
)	O
,	O
seed_file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
close	pointer
(	O
fd	int
)	O
)	O
log_info	O
(	O
_	O
(	O
"can't close `%s': %s\n"	pointer
)	O
,	O
seed_file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
int	O
readable_pool	function
(	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
size_t	long
needed	long
=	O
0	int
;	O
size_t	long
my_balance	long
=	O
pool_balance	int
;	O
size_t	long
available	long
=	O
(	O
gatherwpos	int
-	O
gatherrpos	int
+	O
GATHERBUFSIZE	int
)	O
%	O
GATHERBUFSIZE	int
;	O
if	O
(	O
length	long
>	O
POOLSIZE	O
)	O
length	long
=	O
POOLSIZE	O
;	O
if	O
(	O
level	int
<	O
2	int
)	O
return	O
length	long
;	O
if	O
(	O
!	O
pool_filled	int
)	O
{	O
if	O
(	O
read_seed_file	function
(	O
)	O
)	O
pool_filled	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
did_initial_extra_seeding	int
)	O
{	O
needed	long
=	O
length	long
;	O
if	O
(	O
needed	long
<	O
POOLSIZE	O
/	O
2	int
)	O
needed	long
=	O
POOLSIZE	O
/	O
2	int
;	O
my_balance	long
=	O
needed	long
;	O
if	O
(	O
!	O
pool_filled	int
&&	O
pool_writepos	long
+	O
needed	long
<	O
POOLSIZE	O
)	O
{	O
needed	long
+=	O
(	O
POOLSIZE	O
-	O
pool_writepos	long
+	O
needed	long
+	O
POOLSIZE	O
/	O
5	int
-	O
1	int
)	O
/	O
(	O
POOLSIZE	O
/	O
5	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
pool_filled	int
)	O
needed	long
+=	O
(	O
POOLSIZE	O
-	O
pool_writepos	long
+	O
needed	long
+	O
POOLSIZE	O
/	O
5	int
-	O
1	int
)	O
/	O
(	O
POOLSIZE	O
/	O
5	int
)	O
;	O
}	O
if	O
(	O
available	long
<	O
needed	long
)	O
return	O
0	int
;	O
return	O
available	long
+	O
my_balance	long
-	O
needed	long
;	O
}	O
int	O
read_pool	function
(	O
byte	char
*	O
buffer	pointer
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
int	O
i	int
;	O
ulong	long
*	O
sp	pointer
,	O
*	O
dp	pointer
;	O
if	O
(	O
length	long
>	O
POOLSIZE	O
)	O
{	O
length	long
=	O
POOLSIZE	O
;	O
}	O
if	O
(	O
!	O
pool_filled	int
)	O
{	O
if	O
(	O
read_seed_file	function
(	O
)	O
)	O
pool_filled	int
=	O
1	int
;	O
}	O
if	O
(	O
level	int
==	O
2	int
&&	O
!	O
did_initial_extra_seeding	int
)	O
{	O
size_t	long
needed	long
;	O
pool_balance	int
=	O
0	int
;	O
needed	long
=	O
length	long
-	O
pool_balance	int
;	O
if	O
(	O
needed	long
<	O
POOLSIZE	O
/	O
2	int
)	O
needed	long
=	O
POOLSIZE	O
/	O
2	int
;	O
else	O
if	O
(	O
needed	long
>	O
POOLSIZE	O
)	O
BUG	O
(	O
)	O
;	O
needed	long
=	O
read_random_source	function
(	O
3	int
,	O
needed	long
,	O
2	int
)	O
;	O
if	O
(	O
!	O
needed	long
)	O
return	O
0	int
;	O
pool_balance	int
+=	O
needed	long
;	O
did_initial_extra_seeding	int
=	O
1	int
;	O
}	O
if	O
(	O
level	int
==	O
2	int
&&	O
pool_balance	int
<	O
length	long
)	O
{	O
size_t	long
needed	long
;	O
if	O
(	O
pool_balance	int
<	O
0	int
)	O
pool_balance	int
=	O
0	int
;	O
needed	long
=	O
length	long
-	O
pool_balance	int
;	O
if	O
(	O
needed	long
>	O
POOLSIZE	O
)	O
BUG	O
(	O
)	O
;	O
needed	long
=	O
read_random_source	function
(	O
3	int
,	O
needed	long
,	O
2	int
)	O
;	O
pool_balance	int
+=	O
needed	long
;	O
}	O
if	O
(	O
level	int
==	O
2	int
)	O
while	O
(	O
!	O
pool_filled	int
)	O
random_poll	function
(	O
)	O
;	O
fast_random_poll	function
(	O
)	O
;	O
if	O
(	O
!	O
level	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
dp	pointer
=	O
(	O
ulong	long
*	O
)	O
keypool	pointer
,	O
sp	pointer
=	O
(	O
ulong	long
*	O
)	O
rndpool	pointer
;	O
i	int
<	O
POOLWORDS	O
;	O
i	int
++	O
,	O
dp	pointer
++	O
,	O
sp	pointer
++	O
)	O
*	O
dp	pointer
=	O
*	O
sp	pointer
+	O
ADD_VALUE	int
;	O
mix_pool	function
(	O
rndpool	pointer
)	O
;	O
rndstats	struct
.	O
mixrnd	long
++	O
;	O
mix_pool	function
(	O
keypool	pointer
)	O
;	O
rndstats	struct
.	O
mixkey	long
++	O
;	O
memcpy	function
(	O
buffer	pointer
,	O
keypool	pointer
,	O
length	long
)	O
;	O
return	O
length	long
;	O
}	O
else	O
{	O
int	O
amount	int
;	O
if	O
(	O
!	O
just_mixed	int
)	O
{	O
mix_pool	function
(	O
rndpool	pointer
)	O
;	O
rndstats	struct
.	O
mixrnd	long
++	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
dp	pointer
=	O
(	O
ulong	long
*	O
)	O
keypool	pointer
,	O
sp	pointer
=	O
(	O
ulong	long
*	O
)	O
rndpool	pointer
;	O
i	int
<	O
POOLWORDS	O
;	O
i	int
++	O
,	O
dp	pointer
++	O
,	O
sp	pointer
++	O
)	O
*	O
dp	pointer
=	O
*	O
sp	pointer
+	O
ADD_VALUE	int
;	O
mix_pool	function
(	O
rndpool	pointer
)	O
;	O
rndstats	struct
.	O
mixrnd	long
++	O
;	O
mix_pool	function
(	O
keypool	pointer
)	O
;	O
rndstats	struct
.	O
mixkey	long
++	O
;	O
if	O
(	O
level	int
==	O
2	int
&&	O
length	long
>	O
pool_balance	int
)	O
length	long
=	O
pool_balance	int
;	O
amount	int
=	O
length	long
;	O
while	O
(	O
length	long
--	O
)	O
{	O
*	O
buffer	pointer
++	O
=	O
keypool	pointer
[	O
pool_readpos	long
++	O
]	O
;	O
if	O
(	O
pool_readpos	long
>=	O
POOLSIZE	O
)	O
pool_readpos	long
=	O
0	int
;	O
pool_balance	int
--	O
;	O
}	O
if	O
(	O
pool_balance	int
<	O
0	int
)	O
pool_balance	int
=	O
0	int
;	O
memset	function
(	O
keypool	pointer
,	O
0	int
,	O
POOLSIZE	O
)	O
;	O
return	O
amount	int
;	O
}	O
}	O
static	O
void	O
add_randomness	function
(	O
const	O
void	O
*	O
buffer	pointer
,	O
size_t	long
length	long
,	O
int	O
source	int
)	O
{	O
const	O
byte	char
*	O
p	pointer
=	O
buffer	pointer
;	O
if	O
(	O
!	O
is_initialized	int
)	O
initialize	function
(	O
)	O
;	O
rndstats	struct
.	O
addbytes	long
+=	O
length	long
;	O
rndstats	struct
.	O
naddbytes	long
++	O
;	O
while	O
(	O
length	long
--	O
)	O
{	O
rndpool	pointer
[	O
pool_writepos	long
++	O
]	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
pool_writepos	long
>=	O
POOLSIZE	O
)	O
{	O
if	O
(	O
source	int
>	O
1	int
)	O
pool_filled	int
=	O
1	int
;	O
pool_writepos	long
=	O
0	int
;	O
mix_pool	function
(	O
rndpool	pointer
)	O
;	O
rndstats	struct
.	O
mixrnd	long
++	O
;	O
just_mixed	int
=	O
!	O
length	long
;	O
}	O
}	O
}	O
static	O
void	O
random_poll	function
(	O
)	O
{	O
rndstats	struct
.	O
slowpolls	long
++	O
;	O
read_random_source	function
(	O
2	int
,	O
POOLSIZE	O
/	O
5	int
,	O
1	int
)	O
;	O
}	O
void	O
fast_random_poll	function
(	O
)	O
{	O
static	O
void	O
(	O
*	O
fnc	pointer
)	O
(	O
void	O
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
size_t	long
,	O
int	O
)	O
,	O
int	O
)	O
=	O
NULL	O
;	O
static	O
int	O
initialized	int
=	O
0	int
;	O
rndstats	struct
.	O
fastpolls	long
++	O
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
if	O
(	O
!	O
is_initialized	int
)	O
initialize	function
(	O
)	O
;	O
initialized	int
=	O
1	int
;	O
fnc	pointer
=	O
dynload_getfnc_fast_random_poll	O
(	O
)	O
;	O
}	O
if	O
(	O
fnc	pointer
)	O
{	O
(	O
*	O
fnc	pointer
)	O
(	O
add_randomness	function
,	O
1	int
)	O
;	O
return	O
;	O
}	O
{	O
struct	O
timeval	struct
tv	struct
;	O
if	O
(	O
gettimeofday	function
(	O
&	O
tv	struct
,	O
NULL	O
)	O
)	O
BUG	O
(	O
)	O
;	O
add_randomness	function
(	O
&	O
tv	struct
.	O
tv_sec	long
,	O
sizeof	O
(	O
tv	struct
.	O
tv_sec	long
)	O
,	O
1	int
)	O
;	O
add_randomness	function
(	O
&	O
tv	struct
.	O
tv_usec	long
,	O
sizeof	O
(	O
tv	struct
.	O
tv_usec	long
)	O
,	O
1	int
)	O
;	O
}	O
{	O
struct	O
rusage	struct
buf	array
;	O
getrusage	function
(	O
RUSAGE_SELF	int
,	O
&	O
buf	array
)	O
;	O
add_randomness	function
(	O
&	O
buf	array
,	O
sizeof	O
buf	array
,	O
1	int
)	O
;	O
memset	function
(	O
&	O
buf	array
,	O
0	int
,	O
sizeof	O
buf	array
)	O
;	O
}	O
{	O
time_t	long
x	int
=	O
time	struct
(	O
NULL	O
)	O
;	O
add_randomness	function
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
1	int
)	O
;	O
}	O
{	O
clock_t	long
x	int
=	O
clock	function
(	O
)	O
;	O
add_randomness	function
(	O
&	O
x	int
,	O
sizeof	O
(	O
x	int
)	O
,	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
read_random_source	function
(	O
int	O
requester	int
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
static	O
int	O
(	O
*	O
fnc	pointer
)	O
(	O
void	O
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
size_t	long
,	O
int	O
)	O
,	O
int	O
,	O
size_t	long
,	O
int	O
)	O
=	O
NULL	O
;	O
int	O
got	int
;	O
if	O
(	O
!	O
fnc	pointer
)	O
{	O
if	O
(	O
!	O
is_initialized	int
)	O
initialize	function
(	O
)	O
;	O
fnc	pointer
=	O
dynload_getfnc_gather_random	O
(	O
)	O
;	O
if	O
(	O
!	O
fnc	pointer
)	O
{	O
faked_rng	int
=	O
1	int
;	O
fnc	pointer
=	O
gather_faked	function
;	O
}	O
if	O
(	O
!	O
requester	int
&&	O
!	O
length	long
&&	O
!	O
level	int
)	O
return	O
0	int
;	O
}	O
got	int
=	O
(	O
*	O
fnc	pointer
)	O
(	O
add_randomness	function
,	O
requester	int
,	O
length	long
,	O
level	int
)	O
;	O
if	O
(	O
got	int
<	O
0	int
)	O
log_fatal	O
(	O
"No way to gather entropy for the RNG\n"	pointer
)	O
;	O
return	O
got	int
;	O
}	O
static	O
int	O
gather_faked	function
(	O
void	O
(	O
*	O
add	pointer
)	O
(	O
const	O
void	O
*	O
,	O
size_t	long
,	O
int	O
)	O
,	O
int	O
requester	int
,	O
size_t	long
length	long
,	O
int	O
level	int
)	O
{	O
static	O
int	O
initialized	int
=	O
0	int
;	O
size_t	long
n	long
;	O
char	O
*	O
buffer	pointer
,	O
*	O
p	pointer
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
log_info	O
(	O
_	O
(	O
"WARNING: using insecure random number generator!!\n"	pointer
)	O
)	O
;	O
tty_printf	O
(	O
_	O
(	O
"The random number generator is only a kludge to let\n"	pointer
"it run - it is in no way a strong RNG!\n\n"	pointer
"DON'T USE ANY DATA GENERATED BY THIS PROGRAM!!\n\n"	pointer
)	O
)	O
;	O
initialized	int
=	O
1	int
;	O
srand	function
(	O
make_timestamp	O
(	O
)	O
*	O
getpid	function
(	O
)	O
)	O
;	O
}	O
printf	function
(	O
"WAITING FOR %i bytes.\n"	pointer
,	O
length	long
)	O
;	O
p	pointer
=	O
buffer	pointer
=	O
m_alloc	O
(	O
length	long
)	O
;	O
n	long
=	O
length	long
;	O
while	O
(	O
n	long
--	O
)	O
*	O
p	pointer
++	O
=	O
(	O
(	O
unsigned	O
)	O
(	O
1	int
+	O
(	O
int	O
)	O
(	O
256.0	int
*	O
rand	function
(	O
)	O
/	O
(	O
RAND_MAX	int
+	O
1.0	int
)	O
)	O
)	O
-	O
1	int
)	O
;	O
add_randomness	function
(	O
buffer	pointer
,	O
length	long
,	O
requester	int
)	O
;	O
m_free	O
(	O
buffer	pointer
)	O
;	O
return	O
0	int
;	O
}	O
