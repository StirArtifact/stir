static	O
int	O
copy_regular_file	function
(	O
const	O
char	O
*	O
srcpath	pointer
,	O
const	O
char	O
*	O
dstpath	pointer
,	O
int	O
flags	int
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
;	O
static	O
int	O
copy_symlink	function
(	O
const	O
char	O
*	O
srcpath	pointer
,	O
const	O
char	O
*	O
dstpath	pointer
)	O
;	O
static	O
int	O
copy_dir	function
(	O
const	O
char	O
*	O
srcpath	pointer
,	O
const	O
char	O
*	O
dstpath	pointer
,	O
int	O
flags	int
)	O
;	O
int	O
mu_copy_file	function
(	O
const	O
char	O
*	O
srcpath	pointer
,	O
const	O
char	O
*	O
dstpath	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
(	O
(	O
flags	int
&	O
MU_COPY_DEREF	int
)	O
?	O
stat	struct
:	O
lstat	function
)	O
(	O
srcpath	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't stat file %s: %s"	pointer
)	O
,	O
srcpath	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
if	O
(	O
access	function
(	O
dstpath	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
flags	int
&	O
MU_COPY_OVERWRITE	int
)	O
{	O
rc	int
=	O
mu_remove_file	function
(	O
dstpath	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't remove destination %s: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
else	O
return	O
EEXIST	int
;	O
}	O
switch	O
(	O
st	pointer
.	O
st_mode	int
&	O
S_IFMT	O
)	O
{	O
case	O
S_IFREG	O
:	O
return	O
copy_regular_file	function
(	O
srcpath	pointer
,	O
dstpath	pointer
,	O
flags	int
,	O
&	O
st	pointer
)	O
;	O
case	O
S_IFLNK	O
:	O
return	O
copy_symlink	function
(	O
srcpath	pointer
,	O
dstpath	pointer
)	O
;	O
case	O
S_IFDIR	O
:	O
return	O
copy_dir	function
(	O
srcpath	pointer
,	O
dstpath	pointer
,	O
flags	int
)	O
;	O
case	O
S_IFBLK	O
:	O
case	O
S_IFCHR	O
:	O
if	O
(	O
mknod	function
(	O
dstpath	pointer
,	O
st	pointer
.	O
st_mode	int
&	O
0777	int
,	O
st	pointer
.	O
st_dev	long
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot create node: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
S_IFIFO	O
:	O
if	O
(	O
mkfifo	function
(	O
dstpath	pointer
,	O
st	pointer
.	O
st_mode	int
&	O
0777	int
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot create node: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: don't know how to copy file of that type"	pointer
)	O
,	O
srcpath	pointer
)	O
)	O
;	O
return	O
ENOTSUP	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
copy_regular_file	function
(	O
const	O
char	O
*	O
srcpath	pointer
,	O
const	O
char	O
*	O
dstpath	pointer
,	O
int	O
flags	int
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	pointer
src	pointer
,	O
dst	pointer
;	O
mode_t	int
mask	int
,	O
mode	int
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
src	pointer
,	O
srcpath	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"cannot open source file %s: %s"	pointer
)	O
,	O
srcpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
mask	int
=	O
umask	function
(	O
077	int
)	O
;	O
mode	int
=	O
(	O
(	O
flags	int
&	O
MU_COPY_MODE	int
)	O
?	O
st	pointer
->	O
st_mode	int
:	O
(	O
0666	int
&	O
~	O
mask	int
)	O
)	O
&	O
0777	int
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
dst	pointer
,	O
dstpath	pointer
,	O
MU_STREAM_CREAT	int
|	O
MU_STREAM_WRITE	int
)	O
;	O
umask	function
(	O
mask	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"cannot open destination file %s: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
src	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_stream_copy	function
(	O
dst	pointer
,	O
src	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"failed to copy %s to %s: %s"	pointer
)	O
,	O
srcpath	pointer
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
else	O
{	O
mu_transport_t	pointer
trans	array
[	O
2	int
]	O
;	O
rc	int
=	O
mu_stream_ioctl	function
(	O
dst	pointer
,	O
MU_IOCTL_TRANSPORT	int
,	O
MU_IOCTL_OP_GET	int
,	O
trans	array
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
fchmod	function
(	O
(	O
int	O
)	O
(	O
intptr_t	long
)	O
trans	array
[	O
0	int
]	O
,	O
mode	int
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot chmod: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
rc	int
=	O
MU_ERR_RESTORE_META	O
;	O
}	O
else	O
if	O
(	O
flags	int
&	O
MU_COPY_OWNER	int
)	O
{	O
uid_t	int
uid	int
;	O
gid_t	int
gid	int
;	O
if	O
(	O
getuid	function
(	O
)	O
==	O
0	int
)	O
{	O
uid	int
=	O
st	pointer
->	O
st_uid	int
;	O
gid	int
=	O
st	pointer
->	O
st_gid	int
;	O
}	O
else	O
if	O
(	O
getuid	function
(	O
)	O
==	O
st	pointer
->	O
st_uid	int
)	O
{	O
uid	int
=	O
-	O
1	int
;	O
gid	int
=	O
st	pointer
->	O
st_gid	int
;	O
}	O
else	O
{	O
uid	int
=	O
-	O
1	int
;	O
gid	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
gid	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
fchown	function
(	O
(	O
int	O
)	O
(	O
intptr_t	long
)	O
trans	array
[	O
0	int
]	O
,	O
uid	int
,	O
gid	int
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot chown to %lu.%lu: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
(	O
unsigned	O
long	O
)	O
uid	int
,	O
(	O
unsigned	O
long	O
)	O
gid	int
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
rc	int
=	O
MU_ERR_RESTORE_META	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't change file mode and ownership after copying %s to %s;"	pointer
" cannot get file handle: %s"	pointer
)	O
,	O
srcpath	pointer
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
}	O
mu_stream_destroy	function
(	O
&	O
src	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
dst	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
copy_symlink	function
(	O
const	O
char	O
*	O
srcpath	pointer
,	O
const	O
char	O
*	O
dstpath	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
rc	int
=	O
mu_readlink	function
(	O
srcpath	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot read link: %s"	pointer
)	O
,	O
srcpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
symlink	function
(	O
buf	pointer
,	O
dstpath	pointer
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: can't link %s to %s: %s"	pointer
)	O
,	O
srcpath	pointer
,	O
buf	pointer
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
copy_dir	function
(	O
const	O
char	O
*	O
srcpath	pointer
,	O
const	O
char	O
*	O
dstpath	pointer
,	O
int	O
flags	int
)	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
rc	int
;	O
mode_t	int
mode	int
,	O
mask	int
;	O
if	O
(	O
stat	struct
(	O
srcpath	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't stat file %s: %s"	pointer
)	O
,	O
srcpath	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
mask	int
=	O
umask	function
(	O
077	int
)	O
;	O
mode	int
=	O
(	O
(	O
flags	int
&	O
MU_COPY_MODE	int
)	O
?	O
st	pointer
.	O
st_mode	int
:	O
(	O
0777	int
&	O
~	O
mask	int
)	O
)	O
&	O
0777	int
;	O
rc	int
=	O
mkdir	function
(	O
dstpath	pointer
,	O
0700	int
)	O
;	O
umask	function
(	O
mask	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"can't create directory %s: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
dirp	pointer
=	O
opendir	function
(	O
srcpath	pointer
)	O
;	O
if	O
(	O
dirp	pointer
==	O
NULL	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"cannot open directory %s: %s"	pointer
,	O
srcpath	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
while	O
(	O
(	O
dp	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
)	O
)	O
{	O
char	O
const	O
*	O
ename	pointer
=	O
dp	pointer
->	O
d_name	array
;	O
char	O
*	O
src	pointer
,	O
*	O
dst	pointer
;	O
if	O
(	O
ename	pointer
[	O
ename	pointer
[	O
0	int
]	O
!=	O
'.'	O
?	O
0	int
:	O
ename	pointer
[	O
1	int
]	O
!=	O
'.'	O
?	O
1	int
:	O
2	int
]	O
==	O
0	int
)	O
continue	O
;	O
src	pointer
=	O
mu_make_file_name	O
(	O
srcpath	pointer
,	O
ename	pointer
)	O
;	O
dst	pointer
=	O
mu_make_file_name	O
(	O
dstpath	pointer
,	O
ename	pointer
)	O
;	O
rc	int
=	O
mu_copy_file	function
(	O
src	pointer
,	O
dst	pointer
,	O
flags	int
)	O
;	O
free	function
(	O
dst	pointer
)	O
;	O
free	function
(	O
src	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
closedir	function
(	O
dirp	pointer
)	O
;	O
if	O
(	O
chmod	function
(	O
dstpath	pointer
,	O
mode	int
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot chmod: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
flags	int
&	O
MU_COPY_OWNER	int
)	O
{	O
uid_t	int
uid	int
;	O
gid_t	int
gid	int
;	O
if	O
(	O
getuid	function
(	O
)	O
==	O
0	int
)	O
{	O
uid	int
=	O
st	pointer
.	O
st_uid	int
;	O
gid	int
=	O
st	pointer
.	O
st_gid	int
;	O
}	O
else	O
if	O
(	O
getuid	function
(	O
)	O
==	O
st	pointer
.	O
st_uid	int
)	O
{	O
uid	int
=	O
-	O
1	int
;	O
gid	int
=	O
st	pointer
.	O
st_gid	int
;	O
}	O
else	O
{	O
uid	int
=	O
-	O
1	int
;	O
gid	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
gid	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
chown	function
(	O
dstpath	pointer
,	O
uid	int
,	O
gid	int
)	O
)	O
{	O
rc	int
=	O
errno	O
;	O
mu_debug	O
(	O
MU_DEBCAT_STREAM	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"%s: cannot chown to %lu.%lu: %s"	pointer
)	O
,	O
dstpath	pointer
,	O
(	O
unsigned	O
long	O
)	O
uid	int
,	O
(	O
unsigned	O
long	O
)	O
gid	int
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
}	O
}	O
return	O
rc	int
;	O
}	O
