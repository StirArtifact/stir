MAV_timer	O
Atimer	int
;	O
extern	O
int	O
wire	int
;	O
char	O
files	array
[	O
NUM_PARTS	int
]	O
[	O
100	int
]	O
=	O
{	O
"./models/hips.ac"	pointer
,	O
"./models/neck.ac"	pointer
,	O
"./models/head.ac"	pointer
,	O
"./models/left_clavicle.ac"	pointer
,	O
"./models/right_clavicle.ac"	pointer
,	O
"./models/right_hand.ac"	pointer
,	O
"./models/right_lower_arm.ac"	pointer
,	O
"./models/right_upper_arm.ac"	pointer
,	O
"./models/left_hand.ac"	pointer
,	O
"./models/left_lower_arm.ac"	pointer
,	O
"./models/left_upper_arm.ac"	pointer
,	O
"./models/lower_torso.ac"	pointer
,	O
"./models/upper_torso.ac"	pointer
,	O
"./models/left_upper_leg.ac"	pointer
,	O
"./models/left_lower_leg.ac"	pointer
,	O
"./models/left_foot.ac"	pointer
,	O
"./models/right_upper_leg.ac"	pointer
,	O
"./models/right_lower_leg.ac"	pointer
,	O
"./models/right_foot.ac"	pointer
,	O
}	O
;	O
int	O
part_colours	array
[	O
NUM_PARTS	int
]	O
=	O
{	O
COLOUR_BLUE	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_HAIR	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_BLUE	int
,	O
COLOUR_BLUE	int
,	O
COLOUR_BLACK	int
,	O
COLOUR_BLUE	int
,	O
COLOUR_BLUE	int
,	O
COLOUR_BLACK	int
}	O
;	O
MAV_vector	O
offsets	array
[	O
NUM_PARTS	int
]	O
=	O
{	O
{	O
-	O
0.072	int
,	O
7.21202	int
,	O
-	O
1.703075	int
}	O
,	O
{	O
-	O
0.00084	int
,	O
2.90589	int
,	O
1.347075	int
}	O
,	O
{	O
-	O
0.00367	int
,	O
10.65	int
,	O
1.9961	int
}	O
,	O
{	O
-	O
8.31702	int
,	O
-	O
5.29735	int
,	O
0.037970	int
}	O
,	O
{	O
8.31702	int
,	O
-	O
5.29735	int
,	O
0.037970	int
}	O
,	O
{	O
0.970001	int
,	O
-	O
7.85	int
,	O
-	O
4.4	int
}	O
,	O
{	O
0.0	int
,	O
-	O
12.649045	int
,	O
0.0	int
}	O
,	O
{	O
0.488288	int
,	O
-	O
17.43445	int
,	O
0.0	int
}	O
,	O
{	O
-	O
0.97	int
,	O
-	O
7.85	int
,	O
-	O
4.4	int
}	O
,	O
{	O
0.0	int
,	O
-	O
12.649045	int
,	O
0.0	int
}	O
,	O
{	O
-	O
1.063061	int
,	O
-	O
17.43445	int
,	O
0.0	int
}	O
,	O
{	O
0.0	int
,	O
8.124279	int
,	O
5.2517	int
}	O
,	O
{	O
0.483099	int
,	O
-	O
13.877290	int
,	O
2.426865	int
}	O
,	O
{	O
-	O
1.068495	int
,	O
-	O
17.356901	int
,	O
-	O
1.86941	int
}	O
,	O
{	O
0.0	int
,	O
-	O
16.551956	int
,	O
0.0	int
}	O
,	O
{	O
-	O
0.164850	int
,	O
-	O
6.564404	int
,	O
6.861835	int
}	O
,	O
{	O
0.90647	int
,	O
-	O
17.356901	int
,	O
-	O
1.84463	int
}	O
,	O
{	O
0.0	int
,	O
-	O
16.551956	int
,	O
0.0	int
}	O
,	O
{	O
-	O
0.164850	int
,	O
-	O
6.564404	int
,	O
6.861835	int
}	O
,	O
}	O
;	O
int	O
relationship	array
[	O
NUM_PARTS	int
]	O
[	O
2	int
]	O
=	O
{	O
{	O
HIPS	int
,	O
-	O
1	int
}	O
,	O
{	O
LEFT_UPPER_LEG	int
,	O
HIPS	int
}	O
,	O
{	O
LEFT_LOWER_LEG	int
,	O
LEFT_UPPER_LEG	int
}	O
,	O
{	O
LEFT_FOOT	int
,	O
LEFT_LOWER_LEG	int
}	O
,	O
{	O
RIGHT_UPPER_LEG	int
,	O
HIPS	int
}	O
,	O
{	O
RIGHT_LOWER_LEG	int
,	O
RIGHT_UPPER_LEG	int
}	O
,	O
{	O
RIGHT_FOOT	int
,	O
RIGHT_LOWER_LEG	int
}	O
,	O
{	O
LOWER_TORSO	int
,	O
HIPS	int
}	O
,	O
{	O
UPPER_TORSO	int
,	O
LOWER_TORSO	int
}	O
,	O
{	O
NECK	int
,	O
UPPER_TORSO	int
}	O
,	O
{	O
HEAD	int
,	O
NECK	int
}	O
,	O
{	O
LEFT_CLAVICLE	int
,	O
UPPER_TORSO	int
}	O
,	O
{	O
RIGHT_CLAVICLE	int
,	O
UPPER_TORSO	int
}	O
,	O
{	O
LEFT_UPPER_ARM	int
,	O
LEFT_CLAVICLE	int
}	O
,	O
{	O
LEFT_LOWER_ARM	int
,	O
LEFT_UPPER_ARM	int
}	O
,	O
{	O
LEFT_HAND	int
,	O
LEFT_LOWER_ARM	int
}	O
,	O
{	O
RIGHT_UPPER_ARM	int
,	O
RIGHT_CLAVICLE	int
}	O
,	O
{	O
RIGHT_LOWER_ARM	int
,	O
RIGHT_UPPER_ARM	int
}	O
,	O
{	O
RIGHT_HAND	int
,	O
RIGHT_LOWER_ARM	int
}	O
}	O
;	O
MAV_vector	O
relative_positions	array
[	O
NUM_PARTS	int
]	O
=	O
{	O
{	O
0.000000	int
,	O
0.000000	int
,	O
0.000000	int
}	O
,	O
{	O
-	O
8.400009	int
,	O
0.000000	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
-	O
40.720001	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
-	O
34.529999	int
,	O
0.000000	int
}	O
,	O
{	O
8.399997	int
,	O
0.000000	int
,	O
0.000000	int
}	O
,	O
{	O
0.000004	int
,	O
-	O
40.720001	int
,	O
0.000000	int
}	O
,	O
{	O
0.000003	int
,	O
-	O
34.529999	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
13.099998	int
,	O
-	O
5.500000	int
}	O
,	O
{	O
0.000000	int
,	O
47.055008	int
,	O
1.463499	int
}	O
,	O
{	O
0.000000	int
,	O
2.174988	int
,	O
0.807901	int
}	O
,	O
{	O
0.000000	int
,	O
4.340012	int
,	O
0.000000	int
}	O
,	O
{	O
-	O
3.680010	int
,	O
-	O
3.215012	int
,	O
0.807901	int
}	O
,	O
{	O
3.680000	int
,	O
-	O
3.215012	int
,	O
0.807901	int
}	O
,	O
{	O
-	O
16.14008	int
,	O
1.029999	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
-	O
31.339996	int
,	O
0.000000	int
}	O
,	O
{	O
0.969999	int
,	O
-	O
27.020401	int
,	O
4.650000	int
}	O
,	O
{	O
16.14008	int
,	O
1.029999	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
-	O
31.339996	int
,	O
0.000000	int
}	O
,	O
{	O
-	O
0.970000	int
,	O
-	O
27.020401	int
,	O
4.650000	int
}	O
}	O
;	O
double	O
mav_getTimer	function
(	O
void	O
)	O
{	O
mav_timerStop	function
(	O
&	O
Atimer	int
)	O
;	O
return	O
Atimer	int
.	O
wall	O
;	O
}	O
int	O
mav_avatarGetMatrix	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_matrix	O
*	O
*	O
mat	pointer
)	O
{	O
*	O
mat	pointer
=	O
&	O
(	O
(	O
(	O
MAV_avatar	struct
*	O
)	O
obj	pointer
->	O
the_data	O
)	O
->	O
matrix	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_avatarGetUserdef	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
void	O
*	O
*	O
*	O
ud	pointer
)	O
{	O
*	O
ud	pointer
=	O
&	O
(	O
(	O
(	O
MAV_avatar	struct
*	O
)	O
obj	pointer
->	O
the_data	O
)	O
->	O
userdef	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
mav_partBBox	function
(	O
MAV_part	struct
*	O
part	pointer
,	O
MAV_matrix	O
mat	pointer
,	O
MAV_BB	O
*	O
bb	int
)	O
{	O
MAV_partptr	struct
*	O
p	pointer
;	O
MAV_object	O
*	O
obj	pointer
;	O
MAV_BB	O
objbb	O
;	O
MAV_BB	O
bbox	O
;	O
mat	pointer
=	O
mav_matrixMult	function
(	O
mat	pointer
,	O
part	pointer
->	O
position	int
)	O
;	O
mat	pointer
=	O
mav_matrixMult	function
(	O
mat	pointer
,	O
part	pointer
->	O
rotation	int
)	O
;	O
p	pointer
=	O
part	pointer
->	O
children	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
mav_partBBox	function
(	O
p	pointer
->	O
part	pointer
,	O
mat	pointer
,	O
bb	int
)	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
mav_listPointerReset	function
(	O
part	pointer
->	O
objects	pointer
)	O
;	O
while	O
(	O
mav_listItemNext	function
(	O
part	pointer
->	O
objects	pointer
,	O
(	O
void	O
*	O
)	O
&	O
obj	pointer
)	O
)	O
{	O
mav_callbackBBExec	function
(	O
mav_win_current	O
,	O
obj	pointer
,	O
&	O
objbb	O
)	O
;	O
mav_BBAlign	function
(	O
objbb	O
,	O
mat	pointer
,	O
&	O
bbox	O
)	O
;	O
if	O
(	O
bbox	O
.	O
min	O
.	O
x	O
<	O
bb	int
->	O
min	O
.	O
x	O
)	O
bb	int
->	O
min	O
.	O
x	O
=	O
bbox	O
.	O
min	O
.	O
x	O
;	O
if	O
(	O
bbox	O
.	O
min	O
.	O
y	O
<	O
bb	int
->	O
min	O
.	O
y	O
)	O
bb	int
->	O
min	O
.	O
y	O
=	O
bbox	O
.	O
min	O
.	O
y	O
;	O
if	O
(	O
bbox	O
.	O
min	O
.	O
z	O
<	O
bb	int
->	O
min	O
.	O
z	O
)	O
bb	int
->	O
min	O
.	O
z	O
=	O
bbox	O
.	O
min	O
.	O
z	O
;	O
if	O
(	O
bbox	O
.	O
max	O
.	O
x	O
>	O
bb	int
->	O
max	O
.	O
x	O
)	O
bb	int
->	O
max	O
.	O
x	O
=	O
bbox	O
.	O
max	O
.	O
x	O
;	O
if	O
(	O
bbox	O
.	O
max	O
.	O
y	O
>	O
bb	int
->	O
max	O
.	O
y	O
)	O
bb	int
->	O
max	O
.	O
y	O
=	O
bbox	O
.	O
max	O
.	O
y	O
;	O
if	O
(	O
bbox	O
.	O
max	O
.	O
z	O
>	O
bb	int
->	O
max	O
.	O
z	O
)	O
bb	int
->	O
max	O
.	O
z	O
=	O
bbox	O
.	O
max	O
.	O
z	O
;	O
}	O
}	O
int	O
mav_avatarBBox	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_BB	O
*	O
bb	int
)	O
{	O
MAV_avatar	struct
*	O
a	pointer
=	O
(	O
MAV_avatar	struct
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
MAV_matrix	O
mat	pointer
;	O
MAV_BB	O
bbox	O
;	O
mat	pointer
=	O
MAV_ID_MATRIX	O
;	O
bbox	O
.	O
min	O
.	O
x	O
=	O
bbox	O
.	O
min	O
.	O
y	O
=	O
bbox	O
.	O
min	O
.	O
z	O
=	O
10000000.0	int
;	O
bbox	O
.	O
max	O
.	O
x	O
=	O
bbox	O
.	O
max	O
.	O
y	O
=	O
bbox	O
.	O
max	O
.	O
z	O
=	O
-	O
10000000.0	int
;	O
mav_partBBox	function
(	O
a	pointer
->	O
root	pointer
,	O
mat	pointer
,	O
&	O
bbox	O
)	O
;	O
mav_BBAlign	function
(	O
bbox	O
,	O
a	pointer
->	O
vertical	int
,	O
&	O
bbox	O
)	O
;	O
mav_BBAlign	function
(	O
bbox	O
,	O
a	pointer
->	O
matrix	int
,	O
bb	int
)	O
;	O
a	pointer
->	O
bb	int
=	O
*	O
bb	int
;	O
return	O
1	int
;	O
}	O
void	O
mav_BBDisplayWireWithSurfaceParams	function
(	O
MAV_window	O
*	O
w	pointer
,	O
MAV_BB	O
bb	int
,	O
MAV_surfaceParams	O
sp	int
)	O
{	O
MAV_vector	O
vert	O
[	O
8	int
]	O
;	O
MAV_vector	O
norm	O
;	O
vert	O
[	O
0	int
]	O
.	O
x	O
=	O
bb	int
.	O
min	O
.	O
x	O
;	O
vert	O
[	O
0	int
]	O
.	O
y	O
=	O
bb	int
.	O
min	O
.	O
y	O
;	O
vert	O
[	O
0	int
]	O
.	O
z	O
=	O
bb	int
.	O
min	O
.	O
z	O
;	O
vert	O
[	O
1	int
]	O
.	O
x	O
=	O
bb	int
.	O
min	O
.	O
x	O
;	O
vert	O
[	O
1	int
]	O
.	O
y	O
=	O
bb	int
.	O
max	O
.	O
y	O
;	O
vert	O
[	O
1	int
]	O
.	O
z	O
=	O
bb	int
.	O
min	O
.	O
z	O
;	O
vert	O
[	O
2	int
]	O
.	O
x	O
=	O
bb	int
.	O
max	O
.	O
x	O
;	O
vert	O
[	O
2	int
]	O
.	O
y	O
=	O
bb	int
.	O
min	O
.	O
y	O
;	O
vert	O
[	O
2	int
]	O
.	O
z	O
=	O
bb	int
.	O
min	O
.	O
z	O
;	O
vert	O
[	O
3	int
]	O
.	O
x	O
=	O
bb	int
.	O
max	O
.	O
x	O
;	O
vert	O
[	O
3	int
]	O
.	O
y	O
=	O
bb	int
.	O
max	O
.	O
y	O
;	O
vert	O
[	O
3	int
]	O
.	O
z	O
=	O
bb	int
.	O
min	O
.	O
z	O
;	O
vert	O
[	O
4	int
]	O
.	O
x	O
=	O
bb	int
.	O
min	O
.	O
x	O
;	O
vert	O
[	O
4	int
]	O
.	O
y	O
=	O
bb	int
.	O
min	O
.	O
y	O
;	O
vert	O
[	O
4	int
]	O
.	O
z	O
=	O
bb	int
.	O
max	O
.	O
z	O
;	O
vert	O
[	O
5	int
]	O
.	O
x	O
=	O
bb	int
.	O
min	O
.	O
x	O
;	O
vert	O
[	O
5	int
]	O
.	O
y	O
=	O
bb	int
.	O
max	O
.	O
y	O
;	O
vert	O
[	O
5	int
]	O
.	O
z	O
=	O
bb	int
.	O
max	O
.	O
z	O
;	O
vert	O
[	O
6	int
]	O
.	O
x	O
=	O
bb	int
.	O
max	O
.	O
x	O
;	O
vert	O
[	O
6	int
]	O
.	O
y	O
=	O
bb	int
.	O
min	O
.	O
y	O
;	O
vert	O
[	O
6	int
]	O
.	O
z	O
=	O
bb	int
.	O
max	O
.	O
z	O
;	O
vert	O
[	O
7	int
]	O
.	O
x	O
=	O
bb	int
.	O
max	O
.	O
x	O
;	O
vert	O
[	O
7	int
]	O
.	O
y	O
=	O
bb	int
.	O
max	O
.	O
y	O
;	O
vert	O
[	O
7	int
]	O
.	O
z	O
=	O
bb	int
.	O
max	O
.	O
z	O
;	O
sp	int
.	O
mode	O
=	O
MAV_MATERIAL	O
;	O
mav_surfaceParamsUse	function
(	O
&	O
sp	int
)	O
;	O
norm	O
.	O
x	O
=	O
0.0	int
;	O
norm	O
.	O
y	O
=	O
0.0	int
;	O
norm	O
.	O
z	O
=	O
-	O
1.0	int
;	O
mav_gfxNormal	function
(	O
norm	O
)	O
;	O
mav_gfxLineClosedBegin	function
(	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
0	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
1	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
3	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
2	int
]	O
)	O
;	O
mav_gfxLineClosedEnd	function
(	O
)	O
;	O
norm	O
.	O
z	O
=	O
1.0	int
;	O
mav_gfxNormal	function
(	O
norm	O
)	O
;	O
mav_gfxLineClosedBegin	function
(	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
4	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
5	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
7	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
6	int
]	O
)	O
;	O
mav_gfxLineClosedEnd	function
(	O
)	O
;	O
norm	O
.	O
x	O
=	O
-	O
1.0	int
;	O
norm	O
.	O
z	O
=	O
0.0	int
;	O
mav_gfxNormal	function
(	O
norm	O
)	O
;	O
mav_gfxLineBegin	function
(	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
0	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
4	int
]	O
)	O
;	O
mav_gfxLineEnd	function
(	O
)	O
;	O
norm	O
.	O
x	O
=	O
0.0	int
;	O
norm	O
.	O
y	O
=	O
1.0	int
;	O
mav_gfxNormal	function
(	O
norm	O
)	O
;	O
mav_gfxLineBegin	function
(	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
1	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
5	int
]	O
)	O
;	O
mav_gfxLineEnd	function
(	O
)	O
;	O
mav_gfxLineBegin	function
(	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
3	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
7	int
]	O
)	O
;	O
mav_gfxLineEnd	function
(	O
)	O
;	O
norm	O
.	O
y	O
=	O
-	O
1.0	int
;	O
mav_gfxNormal	function
(	O
norm	O
)	O
;	O
mav_gfxLineBegin	function
(	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
2	int
]	O
)	O
;	O
mav_gfxVertex	function
(	O
vert	O
[	O
6	int
]	O
)	O
;	O
mav_gfxLineEnd	function
(	O
)	O
;	O
}	O
void	O
mav_partDraw	function
(	O
MAV_part	struct
*	O
part	pointer
,	O
float	O
dist	float
)	O
{	O
MAV_partptr	struct
*	O
p	pointer
;	O
MAV_object	O
*	O
obj	pointer
;	O
MAV_composite	O
*	O
comp	O
;	O
MAV_surfaceParams	O
*	O
*	O
sp	int
;	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
part	pointer
->	O
position	int
)	O
;	O
mav_gfxMatrixMult	function
(	O
part	pointer
->	O
rotation	int
)	O
;	O
mav_listPointerReset	function
(	O
part	pointer
->	O
objects	pointer
)	O
;	O
while	O
(	O
mav_listItemNext	function
(	O
part	pointer
->	O
objects	pointer
,	O
(	O
void	O
*	O
)	O
&	O
obj	pointer
)	O
)	O
{	O
if	O
(	O
!	O
wire	int
&&	O
dist	float
>	O
1000.0	int
)	O
{	O
comp	O
=	O
(	O
MAV_composite	O
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
if	O
(	O
comp	O
->	O
numobj	O
>	O
0	int
)	O
{	O
mav_callbackGetSurfaceParamsExec	function
(	O
mav_win_current	O
,	O
comp	O
->	O
obj	pointer
[	O
0	int
]	O
,	O
&	O
sp	int
)	O
;	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
comp	O
->	O
matrix	int
)	O
;	O
mav_BBDisplayWireWithSurfaceParams	function
(	O
mav_win_current	O
,	O
comp	O
->	O
bb	int
,	O
*	O
*	O
sp	int
)	O
;	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
wire	int
&&	O
dist	float
>	O
500.0	int
)	O
{	O
comp	O
=	O
(	O
MAV_composite	O
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
if	O
(	O
comp	O
->	O
numobj	O
>	O
0	int
)	O
{	O
mav_callbackGetSurfaceParamsExec	function
(	O
mav_win_current	O
,	O
comp	O
->	O
obj	pointer
[	O
0	int
]	O
,	O
&	O
sp	int
)	O
;	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
comp	O
->	O
matrix	int
)	O
;	O
mav_BBDisplayWithSurfaceParams	function
(	O
mav_win_current	O
,	O
comp	O
->	O
bb	int
,	O
*	O
sp	int
)	O
;	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
}	O
}	O
else	O
mav_callbackDrawExec	function
(	O
mav_win_current	O
,	O
obj	pointer
,	O
NULL	O
)	O
;	O
}	O
p	pointer
=	O
part	pointer
->	O
children	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
mav_partDraw	function
(	O
p	pointer
->	O
part	pointer
,	O
dist	float
)	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
}	O
int	O
mav_avatarDraw	function
(	O
MAV_object	O
*	O
obj	pointer
,	O
MAV_drawInfo	O
*	O
di	pointer
)	O
{	O
MAV_avatar	struct
*	O
a	pointer
=	O
(	O
MAV_avatar	struct
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
MAV_vector	O
dr	O
;	O
float	O
dd	float
;	O
dr	O
.	O
x	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	O
-	O
a	pointer
->	O
matrix	int
.	O
mat	pointer
[	O
MAV_MATRIX_XCOMP	O
]	O
;	O
dr	O
.	O
y	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	O
-	O
a	pointer
->	O
matrix	int
.	O
mat	pointer
[	O
MAV_MATRIX_YCOMP	O
]	O
;	O
dr	O
.	O
z	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	O
-	O
a	pointer
->	O
matrix	int
.	O
mat	pointer
[	O
MAV_MATRIX_ZCOMP	O
]	O
;	O
dd	float
=	O
dr	O
.	O
x	O
*	O
dr	O
.	O
x	O
+	O
dr	O
.	O
y	O
*	O
dr	O
.	O
y	O
+	O
dr	O
.	O
z	O
*	O
dr	O
.	O
z	O
;	O
a	pointer
->	O
drawn	int
=	O
1	int
;	O
if	O
(	O
mav_win_current	O
==	O
mav_win_left	O
)	O
mav_avatarAnimate	function
(	O
a	pointer
)	O
;	O
mav_gfxMatrixPush	function
(	O
)	O
;	O
mav_gfxMatrixMult	function
(	O
a	pointer
->	O
matrix	int
)	O
;	O
mav_gfxMatrixMult	function
(	O
a	pointer
->	O
vertical	int
)	O
;	O
mav_gfxMatrixMult	function
(	O
a	pointer
->	O
rotation	int
)	O
;	O
mav_partDraw	function
(	O
a	pointer
->	O
root	pointer
,	O
dd	float
)	O
;	O
mav_gfxMatrixPop	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
mav_avatarInitialise	function
(	O
void	O
)	O
{	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
COLOUR_WHITE	int
,	O
0.627	int
,	O
0.743	int
,	O
0.878	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
COLOUR_BLACK	int
,	O
0.267	int
,	O
0.267	int
,	O
0.267	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
COLOUR_SKIN	int
,	O
0.800	int
,	O
0.544	int
,	O
0.455	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
COLOUR_HAIR	int
,	O
0.267	int
,	O
0.145	int
,	O
0.020	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
COLOUR_BLUE	int
,	O
0.043	int
,	O
0.282	int
,	O
0.529	int
,	O
0.0	int
)	O
;	O
mav_timerStart	function
(	O
&	O
Atimer	int
)	O
;	O
}	O
MAV_avatar	struct
*	O
mav_avatarBuild	function
(	O
MAV_avatarCurves	struct
*	O
curves	pointer
,	O
MAV_surfaceParams	O
*	O
jumper	pointer
,	O
MAV_surfaceParams	O
*	O
trousers	pointer
)	O
{	O
int	O
i	int
,	O
j	int
,	O
n	int
;	O
MAV_matrix	O
matrix	int
;	O
MAV_facet	O
*	O
fc	O
;	O
MAV_avatar	struct
*	O
avatar	pointer
;	O
MAV_BB	O
bb	int
;	O
MAV_composite	O
*	O
avatarComps	O
[	O
NUM_PARTS	int
]	O
;	O
MAV_partptr	struct
*	O
pptr	pointer
;	O
avatar	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_avatar	struct
)	O
)	O
;	O
avatar	pointer
->	O
last_time	float
=	O
-	O
1.0	int
;	O
avatar	pointer
->	O
curves	pointer
=	O
curves	pointer
;	O
avatar	pointer
->	O
offset	float
=	O
0.0	int
;	O
avatar	pointer
->	O
speed	float
=	O
0.0	int
;	O
avatar	pointer
->	O
drawn	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_PARTS	int
;	O
i	int
++	O
)	O
{	O
avatar	pointer
->	O
part_list	array
[	O
i	int
]	O
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_part	struct
)	O
)	O
;	O
avatar	pointer
->	O
part_list	array
[	O
i	int
]	O
->	O
part_num	int
=	O
i	int
;	O
avatar	pointer
->	O
part_list	array
[	O
i	int
]	O
->	O
colour	int
=	O
part_colours	array
[	O
i	int
]	O
;	O
avatar	pointer
->	O
part_list	array
[	O
i	int
]	O
->	O
objects	pointer
=	O
mav_listNew	function
(	O
)	O
;	O
avatar	pointer
->	O
part_list	array
[	O
i	int
]	O
->	O
position	int
=	O
MAV_ID_MATRIX	O
;	O
avatar	pointer
->	O
part_list	array
[	O
i	int
]	O
->	O
rotation	int
=	O
MAV_ID_MATRIX	O
;	O
avatar	pointer
->	O
part_list	array
[	O
i	int
]	O
->	O
children	pointer
=	O
NULL	O
;	O
avatarComps	O
[	O
i	int
]	O
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_composite	O
)	O
)	O
;	O
matrix	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
offsets	array
[	O
i	int
]	O
.	O
x	O
,	O
offsets	array
[	O
i	int
]	O
.	O
y	O
,	O
offsets	array
[	O
i	int
]	O
.	O
z	O
)	O
;	O
mav_compositeReadAC3D	function
(	O
files	array
[	O
i	int
]	O
,	O
avatarComps	O
[	O
i	int
]	O
,	O
matrix	int
)	O
;	O
avatarComps	O
[	O
i	int
]	O
->	O
matrix	int
=	O
MAV_ID_MATRIX	O
;	O
avatarComps	O
[	O
i	int
]	O
->	O
matrix	int
=	O
mav_matrixScaleSet	function
(	O
avatarComps	O
[	O
i	int
]	O
->	O
matrix	int
,	O
0.010211582	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
avatarComps	O
[	O
i	int
]	O
->	O
numobj	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
UPPER_TORSO	int
||	O
i	int
==	O
LOWER_TORSO	int
||	O
i	int
==	O
LEFT_CLAVICLE	int
||	O
i	int
==	O
RIGHT_CLAVICLE	int
||	O
i	int
==	O
LEFT_UPPER_ARM	int
||	O
i	int
==	O
RIGHT_UPPER_ARM	int
||	O
i	int
==	O
LEFT_LOWER_ARM	int
||	O
i	int
==	O
RIGHT_LOWER_ARM	int
)	O
{	O
if	O
(	O
avatarComps	O
[	O
i	int
]	O
->	O
obj	pointer
[	O
j	int
]	O
->	O
the_class	O
==	O
mav_class_facet	O
)	O
{	O
fc	O
=	O
(	O
MAV_facet	O
*	O
)	O
avatarComps	O
[	O
i	int
]	O
->	O
obj	pointer
[	O
j	int
]	O
->	O
the_data	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
fc	O
->	O
npolys	O
;	O
n	int
++	O
)	O
fc	O
->	O
sp	int
[	O
n	int
]	O
=	O
jumper	pointer
;	O
}	O
}	O
else	O
if	O
(	O
i	int
==	O
HIPS	int
||	O
i	int
==	O
LEFT_UPPER_LEG	int
||	O
i	int
==	O
RIGHT_UPPER_LEG	int
||	O
i	int
==	O
LEFT_LOWER_LEG	int
||	O
i	int
==	O
RIGHT_LOWER_LEG	int
)	O
{	O
if	O
(	O
avatarComps	O
[	O
i	int
]	O
->	O
obj	pointer
[	O
j	int
]	O
->	O
the_class	O
==	O
mav_class_facet	O
)	O
{	O
fc	O
=	O
(	O
MAV_facet	O
*	O
)	O
avatarComps	O
[	O
i	int
]	O
->	O
obj	pointer
[	O
j	int
]	O
->	O
the_data	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
fc	O
->	O
npolys	O
;	O
n	int
++	O
)	O
fc	O
->	O
sp	int
[	O
n	int
]	O
=	O
trousers	pointer
;	O
}	O
}	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_PARTS	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
relationship	array
[	O
i	int
]	O
[	O
1	int
]	O
==	O
-	O
1	int
)	O
{	O
avatar	pointer
->	O
root	pointer
=	O
avatar	pointer
->	O
part_list	array
[	O
relationship	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
;	O
mav_listItemAdd	function
(	O
avatar	pointer
->	O
root	pointer
->	O
objects	pointer
,	O
(	O
void	O
*	O
)	O
mav_objectNew	function
(	O
mav_class_composite	O
,	O
avatarComps	O
[	O
relationship	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
)	O
)	O
;	O
avatar	pointer
->	O
part_list	array
[	O
relationship	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
->	O
position	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0058695	int
,	O
0.901687	int
,	O
-	O
0.0323005	int
)	O
;	O
}	O
else	O
{	O
pptr	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_partptr	struct
)	O
)	O
;	O
pptr	pointer
->	O
part	pointer
=	O
avatar	pointer
->	O
part_list	array
[	O
relationship	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
;	O
pptr	pointer
->	O
next	pointer
=	O
avatar	pointer
->	O
part_list	array
[	O
relationship	array
[	O
i	int
]	O
[	O
1	int
]	O
]	O
->	O
children	pointer
;	O
avatar	pointer
->	O
part_list	array
[	O
relationship	array
[	O
i	int
]	O
[	O
1	int
]	O
]	O
->	O
children	pointer
=	O
pptr	pointer
;	O
mav_listItemAdd	function
(	O
avatar	pointer
->	O
part_list	array
[	O
relationship	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
->	O
objects	pointer
,	O
(	O
void	O
*	O
)	O
mav_objectNew	function
(	O
mav_class_composite	O
,	O
avatarComps	O
[	O
relationship	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
)	O
)	O
;	O
avatar	pointer
->	O
part_list	array
[	O
relationship	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
->	O
position	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.010211582	int
*	O
relative_positions	array
[	O
i	int
]	O
.	O
x	O
,	O
0.010211582	int
*	O
relative_positions	array
[	O
i	int
]	O
.	O
y	O
,	O
0.010211582	int
*	O
relative_positions	array
[	O
i	int
]	O
.	O
z	O
)	O
;	O
}	O
}	O
mav_partBBox	function
(	O
avatar	pointer
->	O
root	pointer
,	O
MAV_ID_MATRIX	O
,	O
&	O
bb	int
)	O
;	O
avatar	pointer
->	O
matrix	int
=	O
MAV_ID_MATRIX	O
;	O
avatar	pointer
->	O
rotation	int
=	O
MAV_ID_MATRIX	O
;	O
avatar	pointer
->	O
vertical	int
=	O
MAV_ID_MATRIX	O
;	O
return	O
avatar	pointer
;	O
}	O
static	O
int	O
Find_PartNum	function
(	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"HIPS"	pointer
)	O
==	O
0	int
)	O
return	O
HIPS	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"NECK"	pointer
)	O
==	O
0	int
)	O
return	O
NECK	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"HEAD"	pointer
)	O
==	O
0	int
)	O
return	O
HEAD	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"LEFT_CLAVICLE"	pointer
)	O
==	O
0	int
)	O
return	O
LEFT_CLAVICLE	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"RIGHT_CLAVICLE"	pointer
)	O
==	O
0	int
)	O
return	O
RIGHT_CLAVICLE	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"RIGHT_HAND"	pointer
)	O
==	O
0	int
)	O
return	O
NECK	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"RIGHT_LOWER_ARM"	pointer
)	O
==	O
0	int
)	O
return	O
RIGHT_LOWER_ARM	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"RIGHT_UPPER_ARM"	pointer
)	O
==	O
0	int
)	O
return	O
RIGHT_UPPER_ARM	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"LEFT_HAND"	pointer
)	O
==	O
0	int
)	O
return	O
LEFT_HAND	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"LEFT_LOWER_ARM"	pointer
)	O
==	O
0	int
)	O
return	O
LEFT_LOWER_ARM	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"LEFT_UPPER_ARM"	pointer
)	O
==	O
0	int
)	O
return	O
LEFT_UPPER_ARM	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"LOWER_TORSO"	pointer
)	O
==	O
0	int
)	O
return	O
LOWER_TORSO	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"UPPER_TORSO"	pointer
)	O
==	O
0	int
)	O
return	O
UPPER_TORSO	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"LEFT_UPPER_LEG"	pointer
)	O
==	O
0	int
)	O
return	O
LEFT_UPPER_LEG	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"LEFT_LOWER_LEG"	pointer
)	O
==	O
0	int
)	O
return	O
LEFT_LOWER_LEG	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"LEFT_FOOT"	pointer
)	O
==	O
0	int
)	O
return	O
LEFT_FOOT	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"RIGHT_UPPER_LEG"	pointer
)	O
==	O
0	int
)	O
return	O
RIGHT_UPPER_LEG	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"RIGHT_LOWER_LEG"	pointer
)	O
==	O
0	int
)	O
return	O
RIGHT_LOWER_LEG	int
;	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
"RIGHT_FOOT"	pointer
)	O
==	O
0	int
)	O
return	O
RIGHT_FOOT	int
;	O
return	O
-	O
1	int
;	O
}	O
MAV_avatarCurves	struct
*	O
mav_avatarReadCurves	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
MAV_avatarCurves	struct
*	O
curves	pointer
;	O
FILE	struct
*	O
in	pointer
;	O
int	O
i	int
,	O
j	int
;	O
int	O
num_points	int
;	O
float	O
xcoord	float
,	O
angle	array
;	O
int	O
b	int
,	O
v	int
;	O
char	O
part_name	array
[	O
100	int
]	O
;	O
char	O
axis	int
[	O
100	int
]	O
;	O
in	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
in	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"mav_readAvatarCurves(): can't open file %s\n"	pointer
,	O
filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
curves	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_avatarCurves	struct
)	O
)	O
;	O
fscanf	function
(	O
in	pointer
,	O
"%d"	pointer
,	O
&	O
curves	pointer
->	O
num_joints	int
)	O
;	O
curves	pointer
->	O
joints	pointer
=	O
mav_malloc	function
(	O
curves	pointer
->	O
num_joints	int
*	O
sizeof	O
(	O
MAV_joint	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
curves	pointer
->	O
num_joints	int
;	O
i	int
++	O
)	O
{	O
fscanf	function
(	O
in	pointer
,	O
"%s"	pointer
,	O
part_name	array
)	O
;	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
part_num	int
=	O
Find_PartNum	function
(	O
part_name	array
)	O
;	O
if	O
(	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
part_num	int
!=	O
-	O
1	int
)	O
{	O
fscanf	function
(	O
in	pointer
,	O
"%f"	pointer
,	O
&	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
offset	float
)	O
;	O
fscanf	function
(	O
in	pointer
,	O
"%s"	pointer
,	O
axis	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
axis	int
,	O
"ROLL"	pointer
)	O
==	O
0	int
)	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
axis	int
=	O
ROLL	int
;	O
if	O
(	O
strcmp	function
(	O
axis	int
,	O
"PITCH"	pointer
)	O
==	O
0	int
)	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
axis	int
=	O
PITCH	int
;	O
if	O
(	O
strcmp	function
(	O
axis	int
,	O
"YAW"	pointer
)	O
==	O
0	int
)	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
axis	int
=	O
YAW	int
;	O
}	O
else	O
{	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
offset	float
=	O
0.0	int
;	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
axis	int
=	O
-	O
1	int
;	O
}	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
start	float
=	O
0.0	int
;	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
end	float
=	O
1.0	int
;	O
fscanf	function
(	O
in	pointer
,	O
"%d"	pointer
,	O
&	O
num_points	int
)	O
;	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
num_beziers	int
=	O
1	int
+	O
(	O
num_points	int
-	O
4	int
)	O
/	O
3	int
;	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
=	O
mav_malloc	function
(	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
num_beziers	int
*	O
sizeof	O
(	O
MAV_bezier	struct
)	O
)	O
;	O
v	int
=	O
0	int
;	O
b	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_points	int
;	O
j	int
++	O
)	O
{	O
fscanf	function
(	O
in	pointer
,	O
"%f"	pointer
,	O
&	O
xcoord	float
)	O
;	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
b	int
]	O
.	O
value	array
[	O
v	int
]	O
=	O
xcoord	float
;	O
v	int
++	O
;	O
if	O
(	O
v	int
==	O
4	int
)	O
{	O
if	O
(	O
j	int
<	O
num_points	int
-	O
1	int
)	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
b	int
+	O
1	int
]	O
.	O
value	array
[	O
0	int
]	O
=	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
b	int
]	O
.	O
value	array
[	O
3	int
]	O
;	O
b	int
++	O
;	O
v	int
=	O
1	int
;	O
}	O
}	O
v	int
=	O
0	int
;	O
b	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_points	int
;	O
j	int
++	O
)	O
{	O
fscanf	function
(	O
in	pointer
,	O
"%f"	pointer
,	O
&	O
angle	array
)	O
;	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
b	int
]	O
.	O
angle	array
[	O
v	int
]	O
=	O
angle	array
/	O
90.0	int
;	O
v	int
++	O
;	O
if	O
(	O
v	int
==	O
4	int
)	O
{	O
if	O
(	O
j	int
<	O
num_points	int
-	O
1	int
)	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
b	int
+	O
1	int
]	O
.	O
angle	array
[	O
0	int
]	O
=	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
b	int
]	O
.	O
angle	array
[	O
3	int
]	O
;	O
b	int
++	O
;	O
v	int
=	O
1	int
;	O
}	O
}	O
}	O
fclose	function
(	O
in	pointer
)	O
;	O
return	O
curves	pointer
;	O
}	O
void	O
mav_avatarUpdatePosition	function
(	O
MAV_avatar	struct
*	O
avatar	pointer
)	O
{	O
MAV_vector	O
position	int
;	O
float	O
time	float
;	O
MAV_vector	O
new_position	O
;	O
position	int
.	O
x	O
=	O
avatar	pointer
->	O
matrix	int
.	O
mat	pointer
[	O
MAV_MATRIX_XCOMP	O
]	O
;	O
position	int
.	O
y	O
=	O
avatar	pointer
->	O
matrix	int
.	O
mat	pointer
[	O
MAV_MATRIX_YCOMP	O
]	O
;	O
position	int
.	O
z	O
=	O
avatar	pointer
->	O
matrix	int
.	O
mat	pointer
[	O
MAV_MATRIX_ZCOMP	O
]	O
;	O
time	float
=	O
mav_getTimer	function
(	O
)	O
;	O
if	O
(	O
avatar	pointer
->	O
last_time	float
<	O
0.0	int
)	O
avatar	pointer
->	O
last_time	float
=	O
time	float
;	O
new_position	O
.	O
x	O
=	O
position	int
.	O
x	O
+	O
(	O
time	float
-	O
avatar	pointer
->	O
last_time	float
)	O
*	O
avatar	pointer
->	O
velocity	int
.	O
x	O
*	O
avatar	pointer
->	O
speed	float
;	O
new_position	O
.	O
y	O
=	O
position	int
.	O
y	O
+	O
(	O
time	float
-	O
avatar	pointer
->	O
last_time	float
)	O
*	O
avatar	pointer
->	O
velocity	int
.	O
y	O
*	O
avatar	pointer
->	O
speed	float
;	O
new_position	O
.	O
z	O
=	O
position	int
.	O
z	O
+	O
(	O
time	float
-	O
avatar	pointer
->	O
last_time	float
)	O
*	O
avatar	pointer
->	O
velocity	int
.	O
z	O
*	O
avatar	pointer
->	O
speed	float
;	O
avatar	pointer
->	O
last_time	float
=	O
time	float
;	O
avatar	pointer
->	O
matrix	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
new_position	O
.	O
x	O
,	O
new_position	O
.	O
y	O
,	O
new_position	O
.	O
z	O
)	O
;	O
}	O
void	O
mav_avatarAnimate	function
(	O
MAV_avatar	struct
*	O
avatar	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
float	O
t	float
;	O
float	O
value	array
;	O
float	O
v	int
,	O
val	float
;	O
MAV_vector	O
direction	int
;	O
float	O
s	float
;	O
float	O
angle	array
;	O
float	O
scl	float
;	O
float	O
time	float
;	O
scl	float
=	O
0.85	int
*	O
avatar	pointer
->	O
speed	float
*	O
sqrt	function
(	O
avatar	pointer
->	O
velocity	int
.	O
x	O
*	O
avatar	pointer
->	O
velocity	int
.	O
x	O
+	O
avatar	pointer
->	O
velocity	int
.	O
y	O
*	O
avatar	pointer
->	O
velocity	int
.	O
y	O
+	O
avatar	pointer
->	O
velocity	int
.	O
z	O
*	O
avatar	pointer
->	O
velocity	int
.	O
z	O
)	O
;	O
direction	int
=	O
avatar	pointer
->	O
velocity	int
;	O
s	float
=	O
sqrt	function
(	O
direction	int
.	O
x	O
*	O
direction	int
.	O
x	O
+	O
direction	int
.	O
y	O
*	O
direction	int
.	O
y	O
+	O
direction	int
.	O
z	O
*	O
direction	int
.	O
z	O
)	O
;	O
if	O
(	O
s	float
>	O
0.0	int
)	O
{	O
direction	int
.	O
x	O
/=	O
s	float
;	O
direction	int
.	O
y	O
/=	O
s	float
;	O
direction	int
.	O
z	O
/=	O
s	float
;	O
angle	array
=	O
57.29577951	int
*	O
acos	function
(	O
direction	int
.	O
z	O
)	O
;	O
if	O
(	O
direction	int
.	O
x	O
<	O
0.0	int
)	O
angle	array
=	O
-	O
angle	array
;	O
}	O
else	O
angle	array
=	O
0.0	int
;	O
avatar	pointer
->	O
rotation	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
angle	array
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
time	float
=	O
mav_getTimer	function
(	O
)	O
;	O
value	array
=	O
fmod	function
(	O
time	float
,	O
1.0	int
)	O
;	O
value	array
-=	O
avatar	pointer
->	O
offset	float
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
avatar	pointer
->	O
curves	pointer
->	O
num_joints	int
;	O
i	int
++	O
)	O
{	O
v	int
=	O
value	array
-	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
offset	float
;	O
while	O
(	O
v	int
<	O
0.0	int
)	O
v	int
+=	O
1.0	int
;	O
while	O
(	O
v	int
>	O
1.0	int
)	O
v	int
-=	O
1.0	int
;	O
t	float
=	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
start	float
+	O
v	int
*	O
(	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
end	float
-	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
start	float
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
num_beziers	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
t	float
>=	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
value	array
[	O
0	int
]	O
&&	O
t	float
<=	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
value	array
[	O
3	int
]	O
)	O
{	O
val	float
=	O
(	O
t	float
-	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
value	array
[	O
0	int
]	O
)	O
/	O
(	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
value	array
[	O
3	int
]	O
-	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
value	array
[	O
0	int
]	O
)	O
;	O
angle	array
=	O
scl	float
*	O
90.0	int
*	O
(	O
(	O
1.0	int
-	O
val	float
)	O
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
angle	array
[	O
0	int
]	O
+	O
3.0	int
*	O
val	float
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
angle	array
[	O
1	int
]	O
+	O
3.0	int
*	O
val	float
*	O
val	float
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
angle	array
[	O
2	int
]	O
+	O
val	float
*	O
val	float
*	O
val	float
*	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
beziers	pointer
[	O
j	int
]	O
.	O
angle	array
[	O
3	int
]	O
)	O
;	O
if	O
(	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
part_num	int
==	O
-	O
1	int
)	O
{	O
avatar	pointer
->	O
vertical	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
-	O
0.055	int
*	O
angle	array
/	O
105.0	int
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
axis	int
)	O
{	O
case	O
ROLL	int
:	O
avatar	pointer
->	O
part_list	array
[	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
part_num	int
]	O
->	O
rotation	int
=	O
mav_matrixSet	function
(	O
-	O
angle	array
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
case	O
PITCH	int
:	O
avatar	pointer
->	O
part_list	array
[	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
part_num	int
]	O
->	O
rotation	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
-	O
angle	array
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
case	O
YAW	int
:	O
avatar	pointer
->	O
part_list	array
[	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
part_num	int
]	O
->	O
rotation	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
-	O
angle	array
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
}	O
}	O
j	int
=	O
avatar	pointer
->	O
curves	pointer
->	O
joints	pointer
[	O
i	int
]	O
.	O
num_beziers	int
;	O
}	O
}	O
}	O
}	O
void	O
mav_avatarSetVelocity	function
(	O
MAV_avatar	struct
*	O
avatar	pointer
,	O
MAV_vector	O
direction	int
,	O
float	O
velocity	int
)	O
{	O
avatar	pointer
->	O
speed	float
=	O
velocity	int
;	O
avatar	pointer
->	O
velocity	int
=	O
direction	int
;	O
}	O
