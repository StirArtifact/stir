Dlg_head	struct
*	O
current_dlg	pointer
=	O
0	int
;	O
Hook	struct
*	O
idle_hook	pointer
=	O
0	int
;	O
static	O
void	O
dlg_broadcast_msg_to	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
widget_msg_t	enum
message	pointer
,	O
int	O
reverse	int
,	O
int	O
flags	enum
)	O
;	O
static	O
void	O
slow_box	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
ys	int
,	O
int	O
xs	int
)	O
{	O
move	O
(	O
h	pointer
->	O
y	short
+	O
y	short
,	O
h	pointer
->	O
x	array
+	O
x	array
)	O
;	O
hline	function
(	O
' '	O
,	O
xs	int
)	O
;	O
vline	function
(	O
' '	O
,	O
ys	int
)	O
;	O
move	O
(	O
h	pointer
->	O
y	short
+	O
y	short
,	O
h	pointer
->	O
x	array
+	O
x	array
+	O
xs	int
-	O
1	int
)	O
;	O
vline	function
(	O
' '	O
,	O
ys	int
)	O
;	O
move	O
(	O
h	pointer
->	O
y	short
+	O
y	short
+	O
ys	int
-	O
1	int
,	O
h	pointer
->	O
x	array
+	O
x	array
)	O
;	O
hline	function
(	O
' '	O
,	O
xs	int
)	O
;	O
}	O
void	O
draw_box	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
ys	int
,	O
int	O
xs	int
)	O
{	O
if	O
(	O
slow_terminal	int
)	O
{	O
slow_box	function
(	O
h	pointer
,	O
y	short
,	O
x	array
,	O
ys	int
,	O
xs	int
)	O
;	O
return	O
;	O
}	O
SLsmg_draw_box	function
(	O
h	pointer
->	O
y	short
+	O
y	short
,	O
h	pointer
->	O
x	array
+	O
x	array
,	O
ys	int
,	O
xs	int
)	O
;	O
}	O
void	O
draw_double_box	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
ys	int
,	O
int	O
xs	int
)	O
{	O
SLsmg_draw_double_box	O
(	O
h	pointer
->	O
y	short
+	O
y	short
,	O
h	pointer
->	O
x	array
+	O
x	array
,	O
ys	int
,	O
xs	int
)	O
;	O
}	O
void	O
widget_erase	function
(	O
Widget	struct
*	O
w	pointer
)	O
{	O
int	O
x	array
,	O
y	short
;	O
for	O
(	O
y	short
=	O
0	int
;	O
y	short
<	O
w	pointer
->	O
lines	pointer
;	O
y	short
++	O
)	O
{	O
widget_move	O
(	O
w	pointer
,	O
y	short
,	O
0	int
)	O
;	O
for	O
(	O
x	array
=	O
0	int
;	O
x	array
<	O
w	pointer
->	O
cols	int
;	O
x	array
++	O
)	O
addch	O
(	O
' '	O
)	O
;	O
}	O
}	O
void	O
dlg_erase	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
int	O
x	array
,	O
y	short
;	O
for	O
(	O
y	short
=	O
0	int
;	O
y	short
<	O
h	pointer
->	O
lines	pointer
;	O
y	short
++	O
)	O
{	O
move	O
(	O
y	short
+	O
h	pointer
->	O
y	short
,	O
h	pointer
->	O
x	array
)	O
;	O
for	O
(	O
x	array
=	O
0	int
;	O
x	array
<	O
h	pointer
->	O
cols	int
;	O
x	array
++	O
)	O
{	O
addch	O
(	O
' '	O
)	O
;	O
}	O
}	O
}	O
void	O
init_widget	function
(	O
Widget	struct
*	O
w	pointer
,	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
lines	pointer
,	O
int	O
cols	int
,	O
callback_fn	pointer
callback	pointer
,	O
mouse_h	pointer
mouse_handler	pointer
)	O
{	O
w	pointer
->	O
x	array
=	O
x	array
;	O
w	pointer
->	O
y	short
=	O
y	short
;	O
w	pointer
->	O
cols	int
=	O
cols	int
;	O
w	pointer
->	O
lines	pointer
=	O
lines	pointer
;	O
w	pointer
->	O
callback	pointer
=	O
callback	pointer
;	O
w	pointer
->	O
mouse	pointer
=	O
mouse_handler	pointer
;	O
w	pointer
->	O
parent	pointer
=	O
0	int
;	O
w	pointer
->	O
options	int
=	O
W_WANT_CURSOR	O
;	O
}	O
cb_ret_t	enum
default_proc	function
(	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
(	O
void	O
)	O
parm	int
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_INIT	int
:	O
case	O
WIDGET_FOCUS	int
:	O
case	O
WIDGET_UNFOCUS	int
:	O
case	O
WIDGET_DRAW	int
:	O
case	O
WIDGET_DESTROY	int
:	O
case	O
WIDGET_CURSOR	int
:	O
case	O
WIDGET_IDLE	int
:	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
}	O
void	O
common_dialog_repaint	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
int	O
space	int
;	O
space	int
=	O
(	O
h	pointer
->	O
flags	enum
&	O
DLG_COMPACT	O
)	O
?	O
0	int
:	O
1	int
;	O
attrset	function
(	O
DLG_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
dlg_erase	function
(	O
h	pointer
)	O
;	O
draw_box	function
(	O
h	pointer
,	O
space	int
,	O
space	int
,	O
h	pointer
->	O
lines	pointer
-	O
2	int
*	O
space	int
,	O
h	pointer
->	O
cols	int
-	O
2	int
*	O
space	int
)	O
;	O
if	O
(	O
h	pointer
->	O
title	pointer
)	O
{	O
attrset	function
(	O
DLG_HOT_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
space	int
,	O
(	O
h	pointer
->	O
cols	int
-	O
strlen	function
(	O
h	pointer
->	O
title	pointer
)	O
)	O
/	O
2	int
)	O
;	O
addstr	O
(	O
h	pointer
->	O
title	pointer
)	O
;	O
}	O
}	O
cb_ret_t	enum
default_dlg_callback	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
(	O
void	O
)	O
parm	int
;	O
if	O
(	O
msg	pointer
==	O
DLG_DRAW	int
&&	O
h	pointer
->	O
color	short
)	O
{	O
common_dialog_repaint	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
msg	pointer
==	O
DLG_IDLE	int
)	O
{	O
dlg_broadcast_msg_to	function
(	O
h	pointer
,	O
WIDGET_IDLE	int
,	O
0	int
,	O
W_WANT_IDLE	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
Dlg_head	struct
*	O
create_dlg	function
(	O
int	O
y1	int
,	O
int	O
x1	int
,	O
int	O
lines	pointer
,	O
int	O
cols	int
,	O
const	O
int	O
*	O
color_set	pointer
,	O
dlg_cb_fn	pointer
callback	pointer
,	O
const	O
char	O
*	O
help_ctx	pointer
,	O
const	O
char	O
*	O
title	pointer
,	O
int	O
flags	enum
)	O
{	O
Dlg_head	struct
*	O
new_d	pointer
;	O
if	O
(	O
flags	enum
&	O
DLG_CENTER	O
)	O
{	O
y1	int
=	O
(	O
LINES	O
-	O
lines	pointer
)	O
/	O
2	int
;	O
x1	int
=	O
(	O
COLS	O
-	O
cols	int
)	O
/	O
2	int
;	O
}	O
if	O
(	O
(	O
flags	enum
&	O
DLG_TRYUP	O
)	O
&&	O
(	O
y1	int
>	O
3	int
)	O
)	O
y1	int
-=	O
2	int
;	O
new_d	pointer
=	O
g_new0	O
(	O
Dlg_head	struct
,	O
1	int
)	O
;	O
new_d	pointer
->	O
color	short
=	O
color_set	pointer
;	O
new_d	pointer
->	O
help_ctx	pointer
=	O
help_ctx	pointer
;	O
new_d	pointer
->	O
callback	pointer
=	O
callback	pointer
?	O
callback	pointer
:	O
default_dlg_callback	function
;	O
new_d	pointer
->	O
x	array
=	O
x1	int
;	O
new_d	pointer
->	O
y	short
=	O
y1	int
;	O
new_d	pointer
->	O
cols	int
=	O
cols	int
;	O
new_d	pointer
->	O
lines	pointer
=	O
lines	pointer
;	O
new_d	pointer
->	O
flags	enum
=	O
flags	enum
;	O
if	O
(	O
title	pointer
)	O
{	O
char	O
*	O
t	long
;	O
t	long
=	O
g_strstrip	O
(	O
g_strdup	function
(	O
title	pointer
)	O
)	O
;	O
new_d	pointer
->	O
title	pointer
=	O
g_strconcat	function
(	O
" "	pointer
,	O
t	long
,	O
" "	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
t	long
)	O
;	O
}	O
return	O
(	O
new_d	pointer
)	O
;	O
}	O
void	O
set_idle_proc	function
(	O
Dlg_head	struct
*	O
d	double
,	O
int	O
enable	int
)	O
{	O
if	O
(	O
enable	int
)	O
d	double
->	O
flags	enum
|=	O
DLG_WANT_IDLE	O
;	O
else	O
d	double
->	O
flags	enum
&=	O
~	O
DLG_WANT_IDLE	O
;	O
}	O
int	O
add_widget	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
void	O
*	O
w	pointer
)	O
{	O
Widget	struct
*	O
widget	pointer
=	O
(	O
Widget	struct
*	O
)	O
w	pointer
;	O
if	O
(	O
!	O
widget	pointer
||	O
h	pointer
->	O
running	int
)	O
abort	function
(	O
)	O
;	O
widget	pointer
->	O
x	array
+=	O
h	pointer
->	O
x	array
;	O
widget	pointer
->	O
y	short
+=	O
h	pointer
->	O
y	short
;	O
widget	pointer
->	O
parent	pointer
=	O
h	pointer
;	O
widget	pointer
->	O
dlg_id	int
=	O
h	pointer
->	O
count	int
++	O
;	O
if	O
(	O
h	pointer
->	O
current	pointer
)	O
{	O
widget	pointer
->	O
next	pointer
=	O
h	pointer
->	O
current	pointer
;	O
widget	pointer
->	O
prev	pointer
=	O
h	pointer
->	O
current	pointer
->	O
prev	pointer
;	O
h	pointer
->	O
current	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
widget	pointer
;	O
h	pointer
->	O
current	pointer
->	O
prev	pointer
=	O
widget	pointer
;	O
}	O
else	O
{	O
widget	pointer
->	O
prev	pointer
=	O
widget	pointer
;	O
widget	pointer
->	O
next	pointer
=	O
widget	pointer
;	O
}	O
if	O
(	O
(	O
h	pointer
->	O
flags	enum
&	O
DLG_REVERSE	O
)	O
||	O
!	O
h	pointer
->	O
current	pointer
)	O
h	pointer
->	O
current	pointer
=	O
widget	pointer
;	O
return	O
widget	pointer
->	O
dlg_id	int
;	O
}	O
enum	O
{	O
REFRESH_COVERS_PART	int
,	O
REFRESH_COVERS_ALL	int
}	O
;	O
static	O
void	O
do_complete_refresh	function
(	O
Dlg_head	struct
*	O
dlg	pointer
)	O
{	O
if	O
(	O
!	O
dlg	pointer
->	O
fullscreen	int
&&	O
dlg	pointer
->	O
parent	pointer
)	O
do_complete_refresh	function
(	O
dlg	pointer
->	O
parent	pointer
)	O
;	O
dlg_redraw	function
(	O
dlg	pointer
)	O
;	O
}	O
void	O
do_refresh	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
current_dlg	pointer
)	O
return	O
;	O
if	O
(	O
fast_refresh	int
)	O
dlg_redraw	function
(	O
current_dlg	pointer
)	O
;	O
else	O
{	O
do_complete_refresh	function
(	O
current_dlg	pointer
)	O
;	O
}	O
}	O
static	O
void	O
dlg_broadcast_msg_to	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
widget_msg_t	enum
message	pointer
,	O
int	O
reverse	int
,	O
int	O
flags	enum
)	O
{	O
Widget	struct
*	O
p	pointer
,	O
*	O
first	pointer
,	O
*	O
wi	pointer
;	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
;	O
if	O
(	O
reverse	int
)	O
first	pointer
=	O
p	pointer
=	O
h	pointer
->	O
current	pointer
->	O
prev	pointer
;	O
else	O
first	pointer
=	O
p	pointer
=	O
h	pointer
->	O
current	pointer
->	O
next	pointer
;	O
do	O
{	O
wi	pointer
=	O
p	pointer
;	O
if	O
(	O
reverse	int
)	O
p	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
else	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
if	O
(	O
flags	enum
==	O
0	int
||	O
(	O
flags	enum
&	O
wi	pointer
->	O
options	int
)	O
)	O
send_message	function
(	O
wi	pointer
,	O
message	pointer
,	O
0	int
)	O
;	O
}	O
while	O
(	O
first	pointer
!=	O
p	pointer
)	O
;	O
}	O
void	O
dlg_broadcast_msg	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
widget_msg_t	enum
message	pointer
,	O
int	O
reverse	int
)	O
{	O
dlg_broadcast_msg_to	function
(	O
h	pointer
,	O
message	pointer
,	O
reverse	int
,	O
0	int
)	O
;	O
}	O
int	O
dlg_focus	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
0	int
;	O
if	O
(	O
send_message	function
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_FOCUS	int
,	O
0	int
)	O
)	O
{	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_FOCUS	int
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
dlg_unfocus	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
0	int
;	O
if	O
(	O
send_message	function
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_UNFOCUS	int
,	O
0	int
)	O
)	O
{	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_UNFOCUS	int
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
dlg_overlap	function
(	O
Widget	struct
*	O
a	pointer
,	O
Widget	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
(	O
b	pointer
->	O
x	array
>=	O
a	pointer
->	O
x	array
+	O
a	pointer
->	O
cols	int
)	O
||	O
(	O
a	pointer
->	O
x	array
>=	O
b	pointer
->	O
x	array
+	O
b	pointer
->	O
cols	int
)	O
||	O
(	O
b	pointer
->	O
y	short
>=	O
a	pointer
->	O
y	short
+	O
a	pointer
->	O
lines	pointer
)	O
||	O
(	O
a	pointer
->	O
y	short
>=	O
b	pointer
->	O
y	short
+	O
b	pointer
->	O
lines	pointer
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
Widget	struct
*	O
find_widget_type	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
callback_fn	pointer
callback	pointer
)	O
{	O
Widget	struct
*	O
w	pointer
;	O
Widget	struct
*	O
item	pointer
;	O
int	O
i	array
;	O
if	O
(	O
!	O
h	pointer
)	O
return	O
0	int
;	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
0	int
;	O
w	pointer
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
,	O
item	pointer
=	O
h	pointer
->	O
current	pointer
;	O
i	array
<	O
h	pointer
->	O
count	int
;	O
i	array
++	O
,	O
item	pointer
=	O
item	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
item	pointer
->	O
callback	pointer
==	O
callback	pointer
)	O
{	O
w	pointer
=	O
item	pointer
;	O
break	O
;	O
}	O
}	O
return	O
w	pointer
;	O
}	O
void	O
dlg_select_by_id	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
id	int
)	O
{	O
Widget	struct
*	O
w	pointer
,	O
*	O
w_found	pointer
;	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
;	O
w	pointer
=	O
h	pointer
->	O
current	pointer
;	O
w_found	pointer
=	O
NULL	O
;	O
do	O
{	O
if	O
(	O
w	pointer
->	O
dlg_id	int
==	O
id	int
)	O
{	O
w_found	pointer
=	O
w	pointer
;	O
break	O
;	O
}	O
w	pointer
=	O
w	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
w	pointer
!=	O
h	pointer
->	O
current	pointer
)	O
;	O
if	O
(	O
w_found	pointer
)	O
dlg_select_widget	function
(	O
w_found	pointer
)	O
;	O
}	O
typedef	O
enum	O
{	O
SELECT_NEXT	int
,	O
SELECT_PREV	int
,	O
SELECT_EXACT	int
}	O
select_dir_t	enum
;	O
static	O
void	O
do_select_widget	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
Widget	struct
*	O
w	pointer
,	O
select_dir_t	enum
dir	pointer
)	O
{	O
Widget	struct
*	O
w0	pointer
=	O
h	pointer
->	O
current	pointer
;	O
if	O
(	O
!	O
dlg_unfocus	function
(	O
h	pointer
)	O
)	O
return	O
;	O
h	pointer
->	O
current	pointer
=	O
w	pointer
;	O
do	O
{	O
if	O
(	O
dlg_focus	function
(	O
h	pointer
)	O
)	O
break	O
;	O
switch	O
(	O
dir	pointer
)	O
{	O
case	O
SELECT_NEXT	int
:	O
h	pointer
->	O
current	pointer
=	O
h	pointer
->	O
current	pointer
->	O
next	pointer
;	O
break	O
;	O
case	O
SELECT_PREV	int
:	O
h	pointer
->	O
current	pointer
=	O
h	pointer
->	O
current	pointer
->	O
prev	pointer
;	O
break	O
;	O
case	O
SELECT_EXACT	int
:	O
h	pointer
->	O
current	pointer
=	O
w0	pointer
;	O
dlg_focus	function
(	O
h	pointer
)	O
;	O
return	O
;	O
}	O
}	O
while	O
(	O
h	pointer
->	O
current	pointer
!=	O
w	pointer
)	O
;	O
if	O
(	O
dlg_overlap	function
(	O
w0	pointer
,	O
h	pointer
->	O
current	pointer
)	O
)	O
{	O
send_message	function
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
send_message	function
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_FOCUS	int
,	O
0	int
)	O
;	O
}	O
}	O
void	O
dlg_select_widget	function
(	O
void	O
*	O
w	pointer
)	O
{	O
do_select_widget	function
(	O
(	O
(	O
Widget	struct
*	O
)	O
w	pointer
)	O
->	O
parent	pointer
,	O
w	pointer
,	O
SELECT_NEXT	int
)	O
;	O
}	O
void	O
dlg_one_up	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
current	pointer
)	O
do_select_widget	function
(	O
h	pointer
,	O
h	pointer
->	O
current	pointer
->	O
prev	pointer
,	O
SELECT_PREV	int
)	O
;	O
}	O
void	O
dlg_one_down	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
current	pointer
)	O
do_select_widget	function
(	O
h	pointer
,	O
h	pointer
->	O
current	pointer
->	O
next	pointer
,	O
SELECT_NEXT	int
)	O
;	O
}	O
void	O
update_cursor	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
;	O
if	O
(	O
h	pointer
->	O
current	pointer
->	O
options	int
&	O
W_WANT_CURSOR	O
)	O
send_message	function
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_CURSOR	int
,	O
0	int
)	O
;	O
else	O
{	O
Widget	struct
*	O
p	pointer
=	O
h	pointer
->	O
current	pointer
;	O
do	O
{	O
if	O
(	O
p	pointer
->	O
options	int
&	O
W_WANT_CURSOR	O
)	O
if	O
(	O
(	O
*	O
p	pointer
->	O
callback	pointer
)	O
(	O
p	pointer
,	O
WIDGET_CURSOR	int
,	O
0	int
)	O
)	O
{	O
break	O
;	O
}	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
h	pointer
->	O
current	pointer
!=	O
p	pointer
)	O
;	O
}	O
}	O
void	O
dlg_redraw	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
(	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_DRAW	int
,	O
0	int
)	O
;	O
dlg_broadcast_msg	function
(	O
h	pointer
,	O
WIDGET_DRAW	int
,	O
1	int
)	O
;	O
update_cursor	function
(	O
h	pointer
)	O
;	O
}	O
void	O
dlg_stop	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
h	pointer
->	O
running	int
=	O
0	int
;	O
}	O
static	O
inline	O
void	O
dialog_handle_key	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
d_key	int
)	O
{	O
switch	O
(	O
d_key	int
)	O
{	O
case	O
KEY_LEFT	int
:	O
case	O
KEY_UP	int
:	O
dlg_one_up	function
(	O
h	pointer
)	O
;	O
break	O
;	O
case	O
KEY_RIGHT	int
:	O
case	O
KEY_DOWN	int
:	O
dlg_one_down	function
(	O
h	pointer
)	O
;	O
break	O
;	O
case	O
KEY_F	O
(	O
1	int
)	O
:	O
interactive_display	function
(	O
NULL	O
,	O
h	pointer
->	O
help_ctx	pointer
)	O
;	O
do_refresh	function
(	O
)	O
;	O
break	O
;	O
case	O
XCTRL	O
(	O
'z'	O
)	O
:	O
suspend_cmd	function
(	O
)	O
;	O
case	O
XCTRL	O
(	O
'l'	O
)	O
:	O
touchwin	O
(	O
stdscr	O
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
doupdate	O
(	O
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
KEY_ENTER	int
:	O
h	pointer
->	O
ret_value	int
=	O
B_ENTER	int
;	O
h	pointer
->	O
running	int
=	O
0	int
;	O
break	O
;	O
case	O
ESC_CHAR	char
:	O
case	O
KEY_F	O
(	O
10	int
)	O
:	O
case	O
XCTRL	O
(	O
'c'	O
)	O
:	O
case	O
XCTRL	O
(	O
'g'	O
)	O
:	O
h	pointer
->	O
ret_value	int
=	O
B_CANCEL	int
;	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
int	O
dlg_try_hotkey	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
d_key	int
)	O
{	O
Widget	struct
*	O
hot_cur	pointer
;	O
int	O
handled	int
,	O
c	int
;	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
0	int
;	O
if	O
(	O
h	pointer
->	O
current	pointer
->	O
options	int
&	O
W_IS_INPUT	O
)	O
{	O
if	O
(	O
d_key	int
<	O
255	int
&&	O
isalpha	function
(	O
d_key	int
)	O
)	O
return	O
0	int
;	O
}	O
c	int
=	O
d_key	int
&	O
~	O
ALT	O
(	O
0	int
)	O
;	O
if	O
(	O
d_key	int
&	O
ALT	O
(	O
0	int
)	O
&&	O
c	int
<	O
255	int
&&	O
isalpha	function
(	O
c	int
)	O
)	O
d_key	int
=	O
tolower	function
(	O
c	int
)	O
;	O
handled	int
=	O
0	int
;	O
if	O
(	O
h	pointer
->	O
current	pointer
->	O
options	int
&	O
W_WANT_HOTKEY	O
)	O
handled	int
=	O
h	pointer
->	O
current	pointer
->	O
callback	pointer
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_HOTKEY	int
,	O
d_key	int
)	O
;	O
if	O
(	O
handled	int
)	O
return	O
handled	int
;	O
hot_cur	pointer
=	O
h	pointer
->	O
current	pointer
;	O
do	O
{	O
if	O
(	O
hot_cur	pointer
->	O
options	int
&	O
W_WANT_HOTKEY	O
)	O
handled	int
|=	O
(	O
*	O
hot_cur	pointer
->	O
callback	pointer
)	O
(	O
hot_cur	pointer
,	O
WIDGET_HOTKEY	int
,	O
d_key	int
)	O
;	O
if	O
(	O
!	O
handled	int
)	O
hot_cur	pointer
=	O
hot_cur	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
h	pointer
->	O
current	pointer
!=	O
hot_cur	pointer
&&	O
!	O
handled	int
)	O
;	O
if	O
(	O
!	O
handled	int
)	O
return	O
0	int
;	O
do_select_widget	function
(	O
h	pointer
,	O
hot_cur	pointer
,	O
SELECT_EXACT	int
)	O
;	O
return	O
handled	int
;	O
}	O
static	O
void	O
dlg_key_event	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
d_key	int
)	O
{	O
int	O
handled	int
;	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
;	O
if	O
(	O
!	O
(	O
h	pointer
->	O
flags	enum
&	O
DLG_WANT_TAB	O
)	O
)	O
{	O
if	O
(	O
d_key	int
==	O
'\t'	O
)	O
{	O
dlg_one_down	function
(	O
h	pointer
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
d_key	int
==	O
KEY_BTAB	int
)	O
{	O
dlg_one_up	function
(	O
h	pointer
)	O
;	O
return	O
;	O
}	O
}	O
handled	int
=	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_KEY	int
,	O
d_key	int
)	O
;	O
if	O
(	O
!	O
handled	int
)	O
handled	int
=	O
dlg_try_hotkey	function
(	O
h	pointer
,	O
d_key	int
)	O
;	O
if	O
(	O
handled	int
)	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_HOTKEY_HANDLED	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
handled	int
)	O
handled	int
=	O
h	pointer
->	O
current	pointer
->	O
callback	pointer
(	O
h	pointer
->	O
current	pointer
,	O
WIDGET_KEY	int
,	O
d_key	int
)	O
;	O
if	O
(	O
!	O
handled	int
)	O
handled	int
=	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_UNHANDLED_KEY	int
,	O
d_key	int
)	O
;	O
if	O
(	O
!	O
handled	int
)	O
dialog_handle_key	function
(	O
h	pointer
,	O
d_key	int
)	O
;	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_POST_KEY	int
,	O
d_key	int
)	O
;	O
}	O
static	O
inline	O
int	O
dlg_mouse_event	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
Gpm_Event	struct
*	O
event	pointer
)	O
{	O
Widget	struct
*	O
item	pointer
;	O
Widget	struct
*	O
starting_widget	pointer
=	O
h	pointer
->	O
current	pointer
;	O
Gpm_Event	struct
new_event	struct
;	O
int	O
x	array
=	O
event	pointer
->	O
x	array
;	O
int	O
y	short
=	O
event	pointer
->	O
y	short
;	O
item	pointer
=	O
starting_widget	pointer
;	O
do	O
{	O
Widget	struct
*	O
widget	pointer
=	O
item	pointer
;	O
item	pointer
=	O
item	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
(	O
(	O
x	array
>	O
widget	pointer
->	O
x	array
)	O
&&	O
(	O
x	array
<=	O
widget	pointer
->	O
x	array
+	O
widget	pointer
->	O
cols	int
)	O
&&	O
(	O
y	short
>	O
widget	pointer
->	O
y	short
)	O
&&	O
(	O
y	short
<=	O
widget	pointer
->	O
y	short
+	O
widget	pointer
->	O
lines	pointer
)	O
)	O
)	O
continue	O
;	O
new_event	struct
=	O
*	O
event	pointer
;	O
new_event	struct
.	O
x	array
-=	O
widget	pointer
->	O
x	array
;	O
new_event	struct
.	O
y	short
-=	O
widget	pointer
->	O
y	short
;	O
if	O
(	O
!	O
widget	pointer
->	O
mouse	pointer
)	O
return	O
MOU_NORMAL	int
;	O
return	O
(	O
*	O
widget	pointer
->	O
mouse	pointer
)	O
(	O
&	O
new_event	struct
,	O
widget	pointer
)	O
;	O
}	O
while	O
(	O
item	pointer
!=	O
starting_widget	pointer
)	O
;	O
return	O
MOU_NORMAL	int
;	O
}	O
void	O
init_dlg	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_INIT	int
,	O
0	int
)	O
;	O
dlg_broadcast_msg	function
(	O
h	pointer
,	O
WIDGET_INIT	int
,	O
0	int
)	O
;	O
if	O
(	O
h	pointer
->	O
x	array
==	O
0	int
&&	O
h	pointer
->	O
y	short
==	O
0	int
&&	O
h	pointer
->	O
cols	int
==	O
COLS	O
&&	O
h	pointer
->	O
lines	pointer
==	O
LINES	O
)	O
h	pointer
->	O
fullscreen	int
=	O
1	int
;	O
h	pointer
->	O
parent	pointer
=	O
current_dlg	pointer
;	O
current_dlg	pointer
=	O
h	pointer
;	O
h	pointer
->	O
mouse_status	int
=	O
MOU_NORMAL	int
;	O
while	O
(	O
!	O
dlg_focus	function
(	O
h	pointer
)	O
&&	O
h	pointer
->	O
current	pointer
)	O
h	pointer
->	O
current	pointer
=	O
h	pointer
->	O
current	pointer
->	O
next	pointer
;	O
dlg_redraw	function
(	O
h	pointer
)	O
;	O
h	pointer
->	O
ret_value	int
=	O
0	int
;	O
h	pointer
->	O
running	int
=	O
1	int
;	O
}	O
void	O
dlg_run_done	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
->	O
current	pointer
)	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_END	int
,	O
0	int
)	O
;	O
current_dlg	pointer
=	O
h	pointer
->	O
parent	pointer
;	O
}	O
void	O
dlg_process_event	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
key	pointer
,	O
Gpm_Event	struct
*	O
event	pointer
)	O
{	O
if	O
(	O
key	pointer
==	O
EV_NONE	O
)	O
{	O
if	O
(	O
got_interrupt	O
(	O
)	O
)	O
key	pointer
=	O
XCTRL	O
(	O
'g'	O
)	O
;	O
else	O
return	O
;	O
}	O
if	O
(	O
key	pointer
==	O
EV_MOUSE	O
)	O
h	pointer
->	O
mouse_status	int
=	O
dlg_mouse_event	function
(	O
h	pointer
,	O
event	pointer
)	O
;	O
else	O
dlg_key_event	function
(	O
h	pointer
,	O
key	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
frontend_run_dlg	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
int	O
d_key	int
;	O
Gpm_Event	struct
event	pointer
;	O
event	pointer
.	O
x	array
=	O
-	O
1	int
;	O
while	O
(	O
h	pointer
->	O
running	int
)	O
{	O
if	O
(	O
winch_flag	int
)	O
change_screen_size	function
(	O
)	O
;	O
if	O
(	O
is_idle	function
(	O
)	O
)	O
{	O
if	O
(	O
idle_hook	pointer
)	O
execute_hooks	function
(	O
idle_hook	pointer
)	O
;	O
while	O
(	O
(	O
h	pointer
->	O
flags	enum
&	O
DLG_WANT_IDLE	O
)	O
&&	O
is_idle	function
(	O
)	O
)	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_IDLE	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
h	pointer
->	O
running	int
)	O
break	O
;	O
}	O
update_cursor	function
(	O
h	pointer
)	O
;	O
got_interrupt	O
(	O
)	O
;	O
d_key	int
=	O
get_event	function
(	O
&	O
event	pointer
,	O
h	pointer
->	O
mouse_status	int
==	O
MOU_REPEAT	int
,	O
1	int
)	O
;	O
dlg_process_event	function
(	O
h	pointer
,	O
d_key	int
,	O
&	O
event	pointer
)	O
;	O
if	O
(	O
!	O
h	pointer
->	O
running	int
)	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_VALIDATE	int
,	O
0	int
)	O
;	O
}	O
}	O
int	O
run_dlg	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
init_dlg	function
(	O
h	pointer
)	O
;	O
frontend_run_dlg	function
(	O
h	pointer
)	O
;	O
dlg_run_done	function
(	O
h	pointer
)	O
;	O
return	O
h	pointer
->	O
ret_value	int
;	O
}	O
void	O
destroy_dlg	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
int	O
i	array
;	O
Widget	struct
*	O
c	int
;	O
dlg_broadcast_msg	function
(	O
h	pointer
,	O
WIDGET_DESTROY	int
,	O
0	int
)	O
;	O
c	int
=	O
h	pointer
->	O
current	pointer
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
h	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
c	int
=	O
c	int
->	O
next	pointer
;	O
g_free	function
(	O
h	pointer
->	O
current	pointer
)	O
;	O
h	pointer
->	O
current	pointer
=	O
c	int
;	O
}	O
g_free	function
(	O
h	pointer
->	O
title	pointer
)	O
;	O
g_free	function
(	O
h	pointer
)	O
;	O
do_refresh	function
(	O
)	O
;	O
}	O
void	O
widget_set_size	function
(	O
Widget	struct
*	O
widget	pointer
,	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
lines	pointer
,	O
int	O
cols	int
)	O
{	O
widget	pointer
->	O
x	array
=	O
x	array
;	O
widget	pointer
->	O
y	short
=	O
y	short
;	O
widget	pointer
->	O
cols	int
=	O
cols	int
;	O
widget	pointer
->	O
lines	pointer
=	O
lines	pointer
;	O
send_message	function
(	O
widget	pointer
,	O
WIDGET_RESIZED	int
,	O
0	int
)	O
;	O
}	O
void	O
dlg_replace_widget	function
(	O
Widget	struct
*	O
old_w	pointer
,	O
Widget	struct
*	O
new_w	pointer
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
old_w	pointer
->	O
parent	pointer
;	O
int	O
should_focus	int
=	O
0	int
;	O
if	O
(	O
!	O
h	pointer
->	O
current	pointer
)	O
return	O
;	O
if	O
(	O
old_w	pointer
==	O
h	pointer
->	O
current	pointer
)	O
should_focus	int
=	O
1	int
;	O
new_w	pointer
->	O
parent	pointer
=	O
h	pointer
;	O
new_w	pointer
->	O
dlg_id	int
=	O
old_w	pointer
->	O
dlg_id	int
;	O
if	O
(	O
old_w	pointer
==	O
old_w	pointer
->	O
next	pointer
)	O
{	O
new_w	pointer
->	O
prev	pointer
=	O
new_w	pointer
;	O
new_w	pointer
->	O
next	pointer
=	O
new_w	pointer
;	O
}	O
else	O
{	O
new_w	pointer
->	O
prev	pointer
=	O
old_w	pointer
->	O
prev	pointer
;	O
new_w	pointer
->	O
next	pointer
=	O
old_w	pointer
->	O
next	pointer
;	O
old_w	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
new_w	pointer
;	O
old_w	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
new_w	pointer
;	O
}	O
if	O
(	O
should_focus	int
)	O
h	pointer
->	O
current	pointer
=	O
new_w	pointer
;	O
send_message	function
(	O
old_w	pointer
,	O
WIDGET_DESTROY	int
,	O
0	int
)	O
;	O
send_message	function
(	O
new_w	pointer
,	O
WIDGET_INIT	int
,	O
0	int
)	O
;	O
if	O
(	O
should_focus	int
)	O
dlg_select_widget	function
(	O
new_w	pointer
)	O
;	O
send_message	function
(	O
new_w	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
}	O
