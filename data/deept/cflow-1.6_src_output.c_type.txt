unsigned	O
char	O
*	O
level_mark	pointer
;	O
int	O
level_mark_size	int
=	O
0	int
;	O
int	O
level_mark_incr	int
=	O
128	int
;	O
int	O
out_line	int
=	O
1	int
;	O
FILE	struct
*	O
outfile	pointer
;	O
static	O
void	O
set_level_mark	function
(	O
int	O
lev	int
,	O
int	O
mark	int
)	O
{	O
if	O
(	O
lev	int
>=	O
level_mark_size	int
)	O
{	O
level_mark_size	int
+=	O
level_mark_incr	int
;	O
level_mark	pointer
=	O
xrealloc	function
(	O
level_mark	pointer
,	O
level_mark_size	int
)	O
;	O
}	O
level_mark	pointer
[	O
lev	int
]	O
=	O
mark	int
;	O
}	O
void	O
print_level	function
(	O
int	O
lev	int
,	O
int	O
last	int
)	O
{	O
int	O
i	long
;	O
if	O
(	O
print_line_numbers	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"%5d "	pointer
,	O
out_line	int
)	O
;	O
if	O
(	O
print_levels	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"{%4d} "	pointer
,	O
lev	int
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"%s"	pointer
,	O
level_begin	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
lev	int
;	O
i	long
++	O
)	O
fprintf	function
(	O
outfile	pointer
,	O
"%s"	pointer
,	O
level_indent	array
[	O
level_mark	pointer
[	O
i	long
]	O
]	O
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"%s"	pointer
,	O
level_end	array
[	O
last	int
]	O
)	O
;	O
}	O
struct	O
output_driver	struct
{	O
char	O
*	O
name	pointer
;	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
cflow_output_command	enum
cmd	enum
,	O
FILE	struct
*	O
outfile	pointer
,	O
int	O
line	int
,	O
void	O
*	O
data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
;	O
void	O
*	O
handler_data	pointer
;	O
}	O
;	O
static	O
int	O
driver_index	int
;	O
static	O
int	O
driver_max	int
=	O
0	int
;	O
struct	O
output_driver	struct
output_driver	struct
[	O
MAX_OUTPUT_DRIVERS	int
]	O
;	O
int	O
register_output	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
cflow_output_command	enum
cmd	enum
,	O
FILE	struct
*	O
outfile	pointer
,	O
int	O
line	int
,	O
void	O
*	O
data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
if	O
(	O
driver_max	int
==	O
MAX_OUTPUT_DRIVERS	int
-	O
1	int
)	O
abort	function
(	O
)	O
;	O
output_driver	struct
[	O
driver_max	int
]	O
.	O
name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
output_driver	struct
[	O
driver_max	int
]	O
.	O
handler	pointer
=	O
handler	pointer
;	O
output_driver	struct
[	O
driver_max	int
]	O
.	O
handler_data	pointer
=	O
handler_data	pointer
;	O
return	O
driver_max	int
++	O
;	O
}	O
int	O
select_output_driver	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
driver_max	int
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
output_driver	struct
[	O
i	long
]	O
.	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
driver_index	int
=	O
i	long
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
void	O
output_init	function
(	O
)	O
{	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler	pointer
(	O
cflow_output_init	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler_data	pointer
)	O
;	O
}	O
void	O
newline	function
(	O
)	O
{	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler	pointer
(	O
cflow_output_newline	int
,	O
outfile	pointer
,	O
out_line	int
,	O
NULL	O
,	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler_data	pointer
)	O
;	O
out_line	int
++	O
;	O
}	O
static	O
void	O
begin	function
(	O
)	O
{	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler	pointer
(	O
cflow_output_begin	int
,	O
outfile	pointer
,	O
out_line	int
,	O
NULL	O
,	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler_data	pointer
)	O
;	O
}	O
static	O
void	O
end	function
(	O
)	O
{	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler	pointer
(	O
cflow_output_end	int
,	O
outfile	pointer
,	O
out_line	int
,	O
NULL	O
,	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler_data	pointer
)	O
;	O
}	O
static	O
void	O
separator	function
(	O
)	O
{	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler	pointer
(	O
cflow_output_separator	int
,	O
outfile	pointer
,	O
out_line	int
,	O
NULL	O
,	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler_data	pointer
)	O
;	O
}	O
static	O
int	O
print_symbol	function
(	O
int	O
direct	int
,	O
int	O
level	int
,	O
int	O
last	int
,	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
struct	O
output_symbol	struct
output_symbol	struct
;	O
output_symbol	struct
.	O
direct	int
=	O
direct	int
;	O
output_symbol	struct
.	O
level	int
=	O
level	int
;	O
output_symbol	struct
.	O
last	int
=	O
last	int
;	O
output_symbol	struct
.	O
sym	pointer
=	O
sym	pointer
;	O
return	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler	pointer
(	O
cflow_output_symbol	int
,	O
outfile	pointer
,	O
out_line	int
,	O
&	O
output_symbol	struct
,	O
output_driver	struct
[	O
driver_index	int
]	O
.	O
handler_data	pointer
)	O
;	O
}	O
static	O
int	O
compare	function
(	O
const	O
void	O
*	O
ap	pointer
,	O
const	O
void	O
*	O
bp	pointer
)	O
{	O
Symbol	struct
*	O
const	O
*	O
a	pointer
=	O
ap	pointer
;	O
Symbol	struct
*	O
const	O
*	O
b	pointer
=	O
bp	pointer
;	O
return	O
strcmp	function
(	O
(	O
*	O
a	pointer
)	O
->	O
name	pointer
,	O
(	O
*	O
b	pointer
)	O
->	O
name	pointer
)	O
;	O
}	O
static	O
int	O
is_var	function
(	O
Symbol	struct
*	O
symp	pointer
)	O
{	O
if	O
(	O
include_symbol	function
(	O
symp	pointer
)	O
)	O
{	O
if	O
(	O
symp	pointer
->	O
type	enum
==	O
SymIdentifier	int
)	O
return	O
symp	pointer
->	O
storage	enum
==	O
ExternStorage	int
||	O
symp	pointer
->	O
storage	enum
==	O
StaticStorage	int
;	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
symbol_is_function	function
(	O
Symbol	struct
*	O
symp	pointer
)	O
{	O
return	O
symp	pointer
->	O
type	enum
==	O
SymIdentifier	int
&&	O
symp	pointer
->	O
arity	int
>=	O
0	int
;	O
}	O
static	O
void	O
clear_active	function
(	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
sym	pointer
->	O
active	int
=	O
0	int
;	O
}	O
void	O
print_refs	function
(	O
char	O
*	O
name	pointer
,	O
struct	O
linked_list	struct
*	O
reflist	pointer
)	O
{	O
Ref	struct
*	O
refptr	pointer
;	O
struct	O
linked_list_entry	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
linked_list_head	O
(	O
reflist	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
refptr	pointer
=	O
(	O
Ref	struct
*	O
)	O
p	pointer
->	O
data	pointer
;	O
fprintf	function
(	O
outfile	pointer
,	O
"%s   %s:%d\n"	pointer
,	O
name	pointer
,	O
refptr	pointer
->	O
source	pointer
,	O
refptr	pointer
->	O
line	int
)	O
;	O
}	O
}	O
static	O
void	O
print_function	function
(	O
Symbol	struct
*	O
symp	pointer
)	O
{	O
if	O
(	O
symp	pointer
->	O
source	pointer
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"%s * %s:%d %s\n"	pointer
,	O
symp	pointer
->	O
name	pointer
,	O
symp	pointer
->	O
source	pointer
,	O
symp	pointer
->	O
def_line	int
,	O
symp	pointer
->	O
decl	pointer
)	O
;	O
}	O
print_refs	function
(	O
symp	pointer
->	O
name	pointer
,	O
symp	pointer
->	O
ref_line	pointer
)	O
;	O
}	O
static	O
void	O
print_type	function
(	O
Symbol	struct
*	O
symp	pointer
)	O
{	O
if	O
(	O
symp	pointer
->	O
source	pointer
)	O
fprintf	function
(	O
outfile	pointer
,	O
"%s t %s:%d\n"	pointer
,	O
symp	pointer
->	O
name	pointer
,	O
symp	pointer
->	O
source	pointer
,	O
symp	pointer
->	O
def_line	int
)	O
;	O
}	O
void	O
xref_output	function
(	O
)	O
{	O
Symbol	struct
*	O
*	O
symbols	pointer
,	O
*	O
symp	pointer
;	O
size_t	long
i	long
,	O
num	long
;	O
num	long
=	O
collect_symbols	function
(	O
&	O
symbols	pointer
,	O
is_var	function
,	O
0	int
)	O
;	O
qsort	function
(	O
symbols	pointer
,	O
num	long
,	O
sizeof	O
(	O
*	O
symbols	pointer
)	O
,	O
compare	function
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num	long
;	O
i	long
++	O
)	O
{	O
symp	pointer
=	O
symbols	pointer
[	O
i	long
]	O
;	O
switch	O
(	O
symp	pointer
->	O
type	enum
)	O
{	O
case	O
SymIdentifier	int
:	O
print_function	function
(	O
symp	pointer
)	O
;	O
break	O
;	O
case	O
SymToken	int
:	O
print_type	function
(	O
symp	pointer
)	O
;	O
break	O
;	O
case	O
SymUndefined	int
:	O
break	O
;	O
}	O
}	O
free	function
(	O
symbols	pointer
)	O
;	O
}	O
static	O
void	O
set_active	function
(	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
sym	pointer
->	O
active	int
=	O
out_line	int
;	O
}	O
static	O
int	O
is_printable	function
(	O
struct	O
linked_list_entry	struct
*	O
p	pointer
)	O
{	O
return	O
p	pointer
!=	O
NULL	O
&&	O
include_symbol	function
(	O
(	O
Symbol	struct
*	O
)	O
p	pointer
->	O
data	pointer
)	O
;	O
}	O
static	O
int	O
is_last	function
(	O
struct	O
linked_list_entry	struct
*	O
p	pointer
)	O
{	O
while	O
(	O
(	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
)	O
if	O
(	O
is_printable	function
(	O
p	pointer
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
direct_tree	function
(	O
int	O
lev	int
,	O
int	O
last	int
,	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
struct	O
linked_list_entry	struct
*	O
p	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
sym	pointer
->	O
type	enum
==	O
SymUndefined	int
||	O
(	O
max_depth	int
&&	O
lev	int
>=	O
max_depth	int
)	O
||	O
!	O
include_symbol	function
(	O
sym	pointer
)	O
)	O
return	O
;	O
rc	int
=	O
print_symbol	function
(	O
1	int
,	O
lev	int
,	O
last	int
,	O
sym	pointer
)	O
;	O
newline	function
(	O
)	O
;	O
if	O
(	O
rc	int
||	O
sym	pointer
->	O
active	int
)	O
return	O
;	O
set_active	function
(	O
sym	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
linked_list_head	O
(	O
sym	pointer
->	O
callee	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
set_level_mark	function
(	O
lev	int
+	O
1	int
,	O
!	O
is_last	function
(	O
p	pointer
)	O
)	O
;	O
direct_tree	function
(	O
lev	int
+	O
1	int
,	O
is_last	function
(	O
p	pointer
)	O
,	O
(	O
Symbol	struct
*	O
)	O
p	pointer
->	O
data	pointer
)	O
;	O
}	O
clear_active	function
(	O
sym	pointer
)	O
;	O
}	O
static	O
void	O
inverted_tree	function
(	O
int	O
lev	int
,	O
int	O
last	int
,	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
struct	O
linked_list_entry	struct
*	O
p	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
sym	pointer
->	O
type	enum
==	O
SymUndefined	int
||	O
(	O
max_depth	int
&&	O
lev	int
>=	O
max_depth	int
)	O
||	O
!	O
include_symbol	function
(	O
sym	pointer
)	O
)	O
return	O
;	O
rc	int
=	O
print_symbol	function
(	O
0	int
,	O
lev	int
,	O
last	int
,	O
sym	pointer
)	O
;	O
newline	function
(	O
)	O
;	O
if	O
(	O
rc	int
||	O
sym	pointer
->	O
active	int
)	O
return	O
;	O
set_active	function
(	O
sym	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
linked_list_head	O
(	O
sym	pointer
->	O
caller	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
set_level_mark	function
(	O
lev	int
+	O
1	int
,	O
!	O
is_last	function
(	O
p	pointer
)	O
)	O
;	O
inverted_tree	function
(	O
lev	int
+	O
1	int
,	O
is_last	function
(	O
p	pointer
)	O
,	O
(	O
Symbol	struct
*	O
)	O
p	pointer
->	O
data	pointer
)	O
;	O
}	O
clear_active	function
(	O
sym	pointer
)	O
;	O
}	O
static	O
void	O
tree_output	function
(	O
)	O
{	O
Symbol	struct
*	O
*	O
symbols	pointer
,	O
*	O
main_sym	pointer
;	O
size_t	long
i	long
,	O
num	long
;	O
cflow_depmap_t	pointer
depmap	pointer
;	O
num	long
=	O
collect_functions	function
(	O
&	O
symbols	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num	long
;	O
i	long
++	O
)	O
symbols	pointer
[	O
i	long
]	O
->	O
ord	long
=	O
i	long
;	O
depmap	pointer
=	O
depmap_alloc	function
(	O
num	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
symbols	pointer
[	O
i	long
]	O
->	O
callee	pointer
)	O
{	O
struct	O
linked_list_entry	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
linked_list_head	O
(	O
symbols	pointer
[	O
i	long
]	O
->	O
callee	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
Symbol	struct
*	O
s	long
=	O
(	O
Symbol	struct
*	O
)	O
p	pointer
->	O
data	pointer
;	O
if	O
(	O
symbol_is_function	function
(	O
s	long
)	O
)	O
depmap_set	function
(	O
depmap	pointer
,	O
i	long
,	O
(	O
(	O
Symbol	struct
*	O
)	O
p	pointer
->	O
data	pointer
)	O
->	O
ord	long
)	O
;	O
}	O
}	O
}	O
depmap_tc	function
(	O
depmap	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num	long
;	O
i	long
++	O
)	O
if	O
(	O
depmap_isset	function
(	O
depmap	pointer
,	O
i	long
,	O
i	long
)	O
)	O
symbols	pointer
[	O
i	long
]	O
->	O
recursive	int
=	O
1	int
;	O
free	function
(	O
depmap	pointer
)	O
;	O
free	function
(	O
symbols	pointer
)	O
;	O
num	long
=	O
collect_symbols	function
(	O
&	O
symbols	pointer
,	O
is_var	function
,	O
0	int
)	O
;	O
qsort	function
(	O
symbols	pointer
,	O
num	long
,	O
sizeof	O
(	O
*	O
symbols	pointer
)	O
,	O
compare	function
)	O
;	O
begin	function
(	O
)	O
;	O
if	O
(	O
reverse_tree	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num	long
;	O
i	long
++	O
)	O
{	O
inverted_tree	function
(	O
0	int
,	O
0	int
,	O
symbols	pointer
[	O
i	long
]	O
)	O
;	O
separator	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
main_sym	pointer
=	O
start_name	pointer
?	O
lookup	function
(	O
start_name	pointer
)	O
:	O
NULL	O
)	O
!=	O
NULL	O
)	O
{	O
direct_tree	function
(	O
0	int
,	O
0	int
,	O
main_sym	pointer
)	O
;	O
separator	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
all_functions	int
)	O
{	O
all_functions	int
=	O
1	int
;	O
}	O
if	O
(	O
all_functions	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
main_sym	pointer
!=	O
symbols	pointer
[	O
i	long
]	O
&&	O
symbols	pointer
[	O
i	long
]	O
->	O
source	pointer
&&	O
(	O
all_functions	int
>	O
1	int
||	O
symbols	pointer
[	O
i	long
]	O
->	O
caller	pointer
==	O
NULL	O
)	O
)	O
{	O
direct_tree	function
(	O
0	int
,	O
0	int
,	O
symbols	pointer
[	O
i	long
]	O
)	O
;	O
separator	function
(	O
)	O
;	O
}	O
}	O
}	O
}	O
end	function
(	O
)	O
;	O
free	function
(	O
symbols	pointer
)	O
;	O
}	O
void	O
output	function
(	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
outname	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
outfile	pointer
=	O
stdout	pointer
;	O
}	O
else	O
{	O
outfile	pointer
=	O
fopen	function
(	O
outname	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
outfile	pointer
)	O
error	function
(	O
EX_FATAL	int
,	O
errno	O
,	O
_	O
(	O
"cannot open file `%s'"	pointer
)	O
,	O
outname	pointer
)	O
;	O
}	O
set_level_mark	function
(	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
print_option	int
&	O
PRINT_XREF	int
)	O
{	O
xref_output	function
(	O
)	O
;	O
}	O
if	O
(	O
print_option	int
&	O
PRINT_TREE	int
)	O
{	O
tree_output	function
(	O
)	O
;	O
}	O
fclose	function
(	O
outfile	pointer
)	O
;	O
}	O
