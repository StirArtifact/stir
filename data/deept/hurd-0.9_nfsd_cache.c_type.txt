static	O
struct	O
idspec	O
*	O
idhashtable	array
[	O
IDHASH_TABLE_SIZE	int
]	O
;	O
pthread_spinlock_t	int
idhashlock	int
=	O
PTHREAD_SPINLOCK_INITIALIZER	O
;	O
static	O
int	O
nfreeids	int
;	O
static	O
int	O
leastidlastuse	int
;	O
static	O
int	O
idspec_compare	function
(	O
struct	O
idspec	O
*	O
i	pointer
,	O
int	O
nuids	int
,	O
int	O
ngids	int
,	O
int	O
*	O
uids	pointer
,	O
int	O
*	O
gids	pointer
)	O
{	O
if	O
(	O
i	pointer
->	O
nuids	int
!=	O
nuids	int
||	O
i	pointer
->	O
ngids	int
!=	O
ngids	int
)	O
return	O
0	int
;	O
assert	O
(	O
sizeof	O
(	O
int	O
)	O
==	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
if	O
(	O
bcmp	function
(	O
i	pointer
->	O
uids	pointer
,	O
uids	pointer
,	O
nuids	int
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
||	O
bcmp	function
(	O
i	pointer
->	O
gids	pointer
,	O
gids	pointer
,	O
ngids	int
*	O
sizeof	O
(	O
gid_t	O
)	O
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
idspec_hash	function
(	O
int	O
nuids	int
,	O
int	O
ngids	int
,	O
int	O
*	O
uids	pointer
,	O
int	O
*	O
gids	pointer
)	O
{	O
int	O
hash	int
,	O
n	int
;	O
hash	int
=	O
nuids	int
+	O
ngids	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
ngids	int
;	O
n	int
++	O
)	O
hash	int
+=	O
gids	pointer
[	O
n	int
]	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nuids	int
;	O
n	int
++	O
)	O
hash	int
+=	O
uids	pointer
[	O
n	int
]	O
;	O
hash	int
%=	O
IDHASH_TABLE_SIZE	int
;	O
return	O
hash	int
;	O
}	O
static	O
struct	O
idspec	O
*	O
idspec_lookup	function
(	O
int	O
nuids	int
,	O
int	O
ngids	int
,	O
int	O
*	O
uids	pointer
,	O
int	O
*	O
gids	pointer
)	O
{	O
int	O
hash	int
;	O
struct	O
idspec	O
*	O
i	pointer
;	O
hash	int
=	O
idspec_hash	function
(	O
nuids	int
,	O
ngids	int
,	O
uids	pointer
,	O
gids	pointer
)	O
;	O
pthread_spin_lock	function
(	O
&	O
idhashlock	int
)	O
;	O
for	O
(	O
i	pointer
=	O
idhashtable	array
[	O
hash	int
]	O
;	O
i	pointer
;	O
i	pointer
=	O
i	pointer
->	O
next	O
)	O
if	O
(	O
idspec_compare	function
(	O
i	pointer
,	O
nuids	int
,	O
ngids	int
,	O
uids	pointer
,	O
gids	pointer
)	O
)	O
{	O
i	pointer
->	O
references	O
++	O
;	O
if	O
(	O
i	pointer
->	O
references	O
==	O
1	int
)	O
nfreeids	int
--	O
;	O
pthread_spin_unlock	function
(	O
&	O
idhashlock	int
)	O
;	O
return	O
i	pointer
;	O
}	O
assert	O
(	O
sizeof	O
(	O
uid_t	O
)	O
==	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
i	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
idspec	O
)	O
)	O
;	O
i	pointer
->	O
nuids	int
=	O
nuids	int
;	O
i	pointer
->	O
ngids	int
=	O
ngids	int
;	O
i	pointer
->	O
uids	pointer
=	O
malloc	O
(	O
nuids	int
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
i	pointer
->	O
gids	pointer
=	O
malloc	O
(	O
ngids	int
*	O
sizeof	O
(	O
gid_t	O
)	O
)	O
;	O
memcpy	function
(	O
i	pointer
->	O
uids	pointer
,	O
uids	pointer
,	O
nuids	int
*	O
sizeof	O
(	O
uid_t	O
)	O
)	O
;	O
memcpy	function
(	O
i	pointer
->	O
gids	pointer
,	O
gids	pointer
,	O
ngids	int
*	O
sizeof	O
(	O
gid_t	O
)	O
)	O
;	O
i	pointer
->	O
references	O
=	O
1	int
;	O
i	pointer
->	O
next	O
=	O
idhashtable	array
[	O
hash	int
]	O
;	O
if	O
(	O
idhashtable	array
[	O
hash	int
]	O
)	O
idhashtable	array
[	O
hash	int
]	O
->	O
prevp	O
=	O
&	O
i	pointer
->	O
next	O
;	O
i	pointer
->	O
prevp	O
=	O
&	O
idhashtable	array
[	O
hash	int
]	O
;	O
idhashtable	array
[	O
hash	int
]	O
=	O
i	pointer
;	O
pthread_spin_unlock	function
(	O
&	O
idhashlock	int
)	O
;	O
return	O
i	pointer
;	O
}	O
int	O
*	O
process_cred	function
(	O
int	O
*	O
p	pointer
,	O
struct	O
idspec	O
*	O
*	O
credp	pointer
)	O
{	O
int	O
type	int
;	O
int	O
len	int
;	O
int	O
*	O
uid	pointer
;	O
int	O
*	O
gids	pointer
;	O
int	O
ngids	int
;	O
int	O
firstgid	int
;	O
int	O
i	pointer
;	O
type	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
if	O
(	O
type	int
!=	O
AUTH_UNIX	O
)	O
{	O
int	O
size	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
*	O
credp	pointer
=	O
idspec_lookup	function
(	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
p	pointer
+=	O
INTSIZE	function
(	O
size	int
)	O
;	O
}	O
else	O
{	O
p	pointer
++	O
;	O
p	pointer
++	O
;	O
len	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
p	pointer
+=	O
INTSIZE	function
(	O
len	int
)	O
;	O
uid	pointer
=	O
p	pointer
++	O
;	O
*	O
uid	pointer
=	O
ntohl	function
(	O
*	O
uid	pointer
)	O
;	O
firstgid	int
=	O
*	O
(	O
p	pointer
++	O
)	O
;	O
gids	pointer
=	O
p	pointer
;	O
ngids	int
=	O
ntohl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
*	O
gids	pointer
=	O
firstgid	int
;	O
ngids	int
++	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
ngids	int
;	O
i	pointer
++	O
)	O
gids	pointer
[	O
i	pointer
]	O
=	O
ntohl	function
(	O
gids	pointer
[	O
i	pointer
]	O
)	O
;	O
p	pointer
+=	O
ngids	int
-	O
1	int
;	O
*	O
credp	pointer
=	O
idspec_lookup	function
(	O
1	int
,	O
ngids	int
,	O
uid	pointer
,	O
gids	pointer
)	O
;	O
}	O
p	pointer
++	O
;	O
len	int
=	O
htonl	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
p	pointer
+=	O
INTSIZE	function
(	O
len	int
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
cred_rele	function
(	O
struct	O
idspec	O
*	O
i	pointer
)	O
{	O
pthread_spin_lock	function
(	O
&	O
idhashlock	int
)	O
;	O
i	pointer
->	O
references	O
--	O
;	O
if	O
(	O
i	pointer
->	O
references	O
==	O
0	int
)	O
{	O
i	pointer
->	O
lastuse	O
=	O
mapped_time	O
->	O
seconds	O
;	O
if	O
(	O
i	pointer
->	O
lastuse	O
<	O
leastidlastuse	int
||	O
nfreeids	int
==	O
0	int
)	O
leastidlastuse	int
=	O
i	pointer
->	O
lastuse	O
;	O
nfreeids	int
++	O
;	O
}	O
pthread_spin_unlock	function
(	O
&	O
idhashlock	int
)	O
;	O
}	O
void	O
cred_ref	function
(	O
struct	O
idspec	O
*	O
i	pointer
)	O
{	O
pthread_spin_lock	function
(	O
&	O
idhashlock	int
)	O
;	O
assert	O
(	O
i	pointer
->	O
references	O
)	O
;	O
i	pointer
->	O
references	O
++	O
;	O
pthread_spin_unlock	function
(	O
&	O
idhashlock	int
)	O
;	O
}	O
void	O
scan_creds	function
(	O
)	O
{	O
int	O
n	int
;	O
int	O
newleast	int
=	O
mapped_time	O
->	O
seconds	O
;	O
pthread_spin_lock	function
(	O
&	O
idhashlock	int
)	O
;	O
if	O
(	O
mapped_time	O
->	O
seconds	O
-	O
leastidlastuse	int
>	O
ID_KEEP_TIMEOUT	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
IDHASH_TABLE_SIZE	int
&&	O
nfreeids	int
;	O
n	int
++	O
)	O
{	O
struct	O
idspec	O
*	O
i	pointer
=	O
idhashtable	array
[	O
n	int
]	O
;	O
while	O
(	O
i	pointer
&&	O
nfreeids	int
)	O
{	O
struct	O
idspec	O
*	O
next_i	pointer
=	O
i	pointer
->	O
next	O
;	O
if	O
(	O
!	O
i	pointer
->	O
references	O
&&	O
mapped_time	O
->	O
seconds	O
-	O
i	pointer
->	O
lastuse	O
>	O
ID_KEEP_TIMEOUT	O
)	O
{	O
nfreeids	int
--	O
;	O
*	O
i	pointer
->	O
prevp	O
=	O
i	pointer
->	O
next	O
;	O
if	O
(	O
i	pointer
->	O
next	O
)	O
i	pointer
->	O
next	O
->	O
prevp	O
=	O
i	pointer
->	O
prevp	O
;	O
free	function
(	O
i	pointer
->	O
uids	pointer
)	O
;	O
free	function
(	O
i	pointer
->	O
gids	pointer
)	O
;	O
free	function
(	O
i	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
i	pointer
->	O
references	O
&&	O
newleast	int
>	O
i	pointer
->	O
lastuse	O
)	O
newleast	int
=	O
i	pointer
->	O
lastuse	O
;	O
i	pointer
=	O
next_i	pointer
;	O
}	O
}	O
if	O
(	O
nfreeids	int
)	O
leastidlastuse	int
=	O
newleast	int
;	O
}	O
pthread_spin_unlock	function
(	O
&	O
idhashlock	int
)	O
;	O
}	O
static	O
struct	O
cache_handle	O
*	O
fhhashtable	array
[	O
FHHASH_TABLE_SIZE	int
]	O
;	O
pthread_mutex_t	union
fhhashlock	union
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
static	O
int	O
nfreefh	int
;	O
static	O
int	O
leastfhlastuse	int
;	O
static	O
int	O
fh_hash	function
(	O
char	O
*	O
fhandle	pointer
,	O
struct	O
idspec	O
*	O
i	pointer
)	O
{	O
int	O
hash	int
=	O
0	int
,	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
NFS2_FHSIZE	O
;	O
n	int
++	O
)	O
hash	int
+=	O
fhandle	pointer
[	O
n	int
]	O
;	O
hash	int
+=	O
(	O
intptr_t	O
)	O
i	pointer
>>	O
6	int
;	O
return	O
hash	int
%	O
FHHASH_TABLE_SIZE	int
;	O
}	O
int	O
*	O
lookup_cache_handle	function
(	O
int	O
*	O
p	pointer
,	O
struct	O
cache_handle	O
*	O
*	O
cp	pointer
,	O
struct	O
idspec	O
*	O
i	pointer
)	O
{	O
int	O
hash	int
;	O
struct	O
cache_handle	O
*	O
c	pointer
;	O
fsys_t	O
fsys	O
;	O
file_t	O
port	O
;	O
hash	int
=	O
fh_hash	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
i	pointer
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
fhhashlock	union
)	O
;	O
for	O
(	O
c	pointer
=	O
fhhashtable	array
[	O
hash	int
]	O
;	O
c	pointer
;	O
c	pointer
=	O
c	pointer
->	O
next	O
)	O
if	O
(	O
c	pointer
->	O
ids	O
==	O
i	pointer
&&	O
!	O
bcmp	function
(	O
c	pointer
->	O
handle	O
.	O
array	O
,	O
p	pointer
,	O
NFS2_FHSIZE	O
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
references	O
==	O
0	int
)	O
nfreefh	int
--	O
;	O
c	pointer
->	O
references	O
++	O
;	O
pthread_mutex_unlock	function
(	O
&	O
fhhashlock	union
)	O
;	O
*	O
cp	pointer
=	O
c	pointer
;	O
return	O
p	pointer
+	O
NFS2_FHSIZE	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
fsys	O
=	O
lookup_filesystem	function
(	O
*	O
p	pointer
)	O
;	O
if	O
(	O
fsys	O
==	O
MACH_PORT_NULL	O
||	O
fsys_getfile	function
(	O
fsys	O
,	O
i	pointer
->	O
uids	pointer
,	O
i	pointer
->	O
nuids	int
,	O
i	pointer
->	O
gids	pointer
,	O
i	pointer
->	O
ngids	int
,	O
(	O
char	O
*	O
)	O
(	O
p	pointer
+	O
1	int
)	O
,	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
,	O
&	O
port	O
)	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
fhhashlock	union
)	O
;	O
*	O
cp	pointer
=	O
0	int
;	O
return	O
p	pointer
+	O
NFS2_FHSIZE	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
c	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
cache_handle	O
)	O
)	O
;	O
memcpy	function
(	O
c	pointer
->	O
handle	O
.	O
array	O
,	O
p	pointer
,	O
NFS2_FHSIZE	O
)	O
;	O
cred_ref	function
(	O
i	pointer
)	O
;	O
c	pointer
->	O
ids	O
=	O
i	pointer
;	O
c	pointer
->	O
port	O
=	O
port	O
;	O
c	pointer
->	O
references	O
=	O
1	int
;	O
c	pointer
->	O
next	O
=	O
fhhashtable	array
[	O
hash	int
]	O
;	O
if	O
(	O
c	pointer
->	O
next	O
)	O
c	pointer
->	O
next	O
->	O
prevp	O
=	O
&	O
c	pointer
->	O
next	O
;	O
c	pointer
->	O
prevp	O
=	O
&	O
fhhashtable	array
[	O
hash	int
]	O
;	O
fhhashtable	array
[	O
hash	int
]	O
=	O
c	pointer
;	O
pthread_mutex_unlock	function
(	O
&	O
fhhashlock	union
)	O
;	O
*	O
cp	pointer
=	O
c	pointer
;	O
return	O
p	pointer
+	O
NFS2_FHSIZE	O
/	O
sizeof	O
(	O
int	O
)	O
;	O
}	O
void	O
cache_handle_rele	function
(	O
struct	O
cache_handle	O
*	O
c	pointer
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
fhhashlock	union
)	O
;	O
c	pointer
->	O
references	O
--	O
;	O
if	O
(	O
c	pointer
->	O
references	O
==	O
0	int
)	O
{	O
c	pointer
->	O
lastuse	O
=	O
mapped_time	O
->	O
seconds	O
;	O
if	O
(	O
c	pointer
->	O
lastuse	O
<	O
leastfhlastuse	int
||	O
nfreefh	int
==	O
0	int
)	O
leastfhlastuse	int
=	O
c	pointer
->	O
lastuse	O
;	O
nfreefh	int
++	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
fhhashlock	union
)	O
;	O
}	O
void	O
scan_fhs	function
(	O
)	O
{	O
int	O
n	int
;	O
int	O
newleast	int
=	O
mapped_time	O
->	O
seconds	O
;	O
pthread_mutex_lock	function
(	O
&	O
fhhashlock	union
)	O
;	O
if	O
(	O
mapped_time	O
->	O
seconds	O
-	O
leastfhlastuse	int
>	O
FH_KEEP_TIMEOUT	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
FHHASH_TABLE_SIZE	int
&&	O
nfreefh	int
;	O
n	int
++	O
)	O
{	O
struct	O
cache_handle	O
*	O
c	pointer
=	O
fhhashtable	array
[	O
n	int
]	O
;	O
while	O
(	O
c	pointer
&&	O
nfreefh	int
)	O
{	O
struct	O
cache_handle	O
*	O
next_c	pointer
=	O
c	pointer
->	O
next	O
;	O
if	O
(	O
!	O
c	pointer
->	O
references	O
&&	O
mapped_time	O
->	O
seconds	O
-	O
c	pointer
->	O
lastuse	O
>	O
FH_KEEP_TIMEOUT	O
)	O
{	O
nfreefh	int
--	O
;	O
*	O
c	pointer
->	O
prevp	O
=	O
c	pointer
->	O
next	O
;	O
if	O
(	O
c	pointer
->	O
next	O
)	O
c	pointer
->	O
next	O
->	O
prevp	O
=	O
c	pointer
->	O
prevp	O
;	O
cred_rele	function
(	O
c	pointer
->	O
ids	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
c	pointer
->	O
port	O
)	O
;	O
free	function
(	O
c	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
c	pointer
->	O
references	O
&&	O
newleast	int
>	O
c	pointer
->	O
lastuse	O
)	O
newleast	int
=	O
c	pointer
->	O
lastuse	O
;	O
c	pointer
=	O
next_c	pointer
;	O
}	O
}	O
if	O
(	O
nfreefh	int
)	O
leastfhlastuse	int
=	O
newleast	int
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
fhhashlock	union
)	O
;	O
}	O
struct	O
cache_handle	O
*	O
create_cached_handle	function
(	O
int	O
fs	int
,	O
struct	O
cache_handle	O
*	O
credc	pointer
,	O
file_t	O
userport	int
)	O
{	O
union	O
cache_handle_array	O
fhandle	pointer
;	O
error_t	O
err	O
;	O
struct	O
cache_handle	O
*	O
c	pointer
;	O
int	O
hash	int
;	O
char	O
*	O
bp	pointer
=	O
fhandle	pointer
.	O
array	O
+	O
sizeof	O
(	O
int	O
)	O
;	O
size_t	long
handlelen	long
=	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
;	O
mach_port_t	O
newport	O
,	O
ref	O
;	O
ref	O
=	O
mach_reply_port	function
(	O
)	O
;	O
if	O
(	O
io_reauthenticate	function
(	O
userport	int
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
||	O
auth_user_authenticate	function
(	O
authserver	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
,	O
&	O
newport	O
)	O
)	O
{	O
newport	O
=	O
userport	int
;	O
}	O
else	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
userport	int
)	O
;	O
mach_port_destroy	function
(	O
mach_task_self	function
(	O
)	O
,	O
ref	O
)	O
;	O
fhandle	pointer
.	O
fs	int
=	O
fs	int
;	O
err	O
=	O
file_getfh	function
(	O
newport	O
,	O
&	O
bp	pointer
,	O
&	O
handlelen	long
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
newport	O
)	O
;	O
if	O
(	O
err	O
||	O
handlelen	long
!=	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
bp	pointer
!=	O
fhandle	pointer
.	O
array	O
+	O
sizeof	O
(	O
int	O
)	O
)	O
{	O
memcpy	function
(	O
fhandle	pointer
.	O
array	O
+	O
sizeof	O
(	O
int	O
)	O
,	O
bp	pointer
,	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
munmap	function
(	O
bp	pointer
,	O
handlelen	long
)	O
;	O
}	O
hash	int
=	O
fh_hash	function
(	O
fhandle	pointer
.	O
array	O
,	O
credc	pointer
->	O
ids	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
fhhashlock	union
)	O
;	O
for	O
(	O
c	pointer
=	O
fhhashtable	array
[	O
hash	int
]	O
;	O
c	pointer
;	O
c	pointer
=	O
c	pointer
->	O
next	O
)	O
if	O
(	O
c	pointer
->	O
ids	O
==	O
credc	pointer
->	O
ids	O
&&	O
!	O
bcmp	function
(	O
fhandle	pointer
.	O
array	O
,	O
c	pointer
->	O
handle	O
.	O
array	O
,	O
NFS2_FHSIZE	O
)	O
)	O
{	O
if	O
(	O
c	pointer
->	O
references	O
==	O
0	int
)	O
nfreefh	int
--	O
;	O
c	pointer
->	O
references	O
++	O
;	O
pthread_mutex_unlock	function
(	O
&	O
fhhashlock	union
)	O
;	O
return	O
c	pointer
;	O
}	O
err	O
=	O
fsys_getfile	function
(	O
lookup_filesystem	function
(	O
fs	int
)	O
,	O
credc	pointer
->	O
ids	O
->	O
uids	pointer
,	O
credc	pointer
->	O
ids	O
->	O
nuids	int
,	O
credc	pointer
->	O
ids	O
->	O
gids	pointer
,	O
credc	pointer
->	O
ids	O
->	O
ngids	int
,	O
fhandle	pointer
.	O
array	O
+	O
sizeof	O
(	O
int	O
)	O
,	O
NFS2_FHSIZE	O
-	O
sizeof	O
(	O
int	O
)	O
,	O
&	O
newport	O
)	O
;	O
if	O
(	O
err	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
fhhashlock	union
)	O
;	O
return	O
0	int
;	O
}	O
c	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
cache_handle	O
)	O
)	O
;	O
memcpy	function
(	O
c	pointer
->	O
handle	O
.	O
array	O
,	O
fhandle	pointer
.	O
array	O
,	O
NFS2_FHSIZE	O
)	O
;	O
cred_ref	function
(	O
credc	pointer
->	O
ids	O
)	O
;	O
c	pointer
->	O
ids	O
=	O
credc	pointer
->	O
ids	O
;	O
c	pointer
->	O
port	O
=	O
newport	O
;	O
c	pointer
->	O
references	O
=	O
1	int
;	O
c	pointer
->	O
next	O
=	O
fhhashtable	array
[	O
hash	int
]	O
;	O
if	O
(	O
c	pointer
->	O
next	O
)	O
c	pointer
->	O
next	O
->	O
prevp	O
=	O
&	O
c	pointer
->	O
next	O
;	O
c	pointer
->	O
prevp	O
=	O
&	O
fhhashtable	array
[	O
hash	int
]	O
;	O
fhhashtable	array
[	O
hash	int
]	O
=	O
c	pointer
;	O
pthread_mutex_unlock	function
(	O
&	O
fhhashlock	union
)	O
;	O
return	O
c	pointer
;	O
}	O
static	O
struct	O
cached_reply	O
*	O
replyhashtable	array
[	O
REPLYHASH_TABLE_SIZE	int
]	O
;	O
static	O
pthread_spinlock_t	int
replycachelock	int
=	O
PTHREAD_SPINLOCK_INITIALIZER	O
;	O
static	O
int	O
nfreereplies	int
;	O
static	O
int	O
leastreplylastuse	int
;	O
struct	O
cached_reply	O
*	O
check_cached_replies	function
(	O
int	O
xid	int
,	O
struct	O
sockaddr_in	O
*	O
sender	pointer
)	O
{	O
struct	O
cached_reply	O
*	O
cr	pointer
;	O
int	O
hash	int
;	O
hash	int
=	O
abs	O
(	O
xid	int
%	O
REPLYHASH_TABLE_SIZE	int
)	O
;	O
pthread_spin_lock	function
(	O
&	O
replycachelock	int
)	O
;	O
for	O
(	O
cr	pointer
=	O
replyhashtable	array
[	O
hash	int
]	O
;	O
cr	pointer
;	O
cr	pointer
=	O
cr	pointer
->	O
next	O
)	O
if	O
(	O
cr	pointer
->	O
xid	int
==	O
xid	int
&&	O
!	O
bcmp	function
(	O
sender	pointer
,	O
&	O
cr	pointer
->	O
source	O
,	O
sizeof	O
(	O
struct	O
sockaddr_in	O
)	O
)	O
)	O
{	O
cr	pointer
->	O
references	O
++	O
;	O
if	O
(	O
cr	pointer
->	O
references	O
==	O
1	int
)	O
nfreereplies	int
--	O
;	O
pthread_spin_unlock	function
(	O
&	O
replycachelock	int
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
cr	pointer
->	O
lock	O
)	O
;	O
return	O
cr	pointer
;	O
}	O
cr	pointer
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
cached_reply	O
)	O
)	O
;	O
pthread_mutex_init	function
(	O
&	O
cr	pointer
->	O
lock	O
,	O
NULL	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
cr	pointer
->	O
lock	O
)	O
;	O
memcpy	function
(	O
&	O
cr	pointer
->	O
source	O
,	O
sender	pointer
,	O
sizeof	O
(	O
struct	O
sockaddr_in	O
)	O
)	O
;	O
cr	pointer
->	O
xid	int
=	O
xid	int
;	O
cr	pointer
->	O
data	O
=	O
0	int
;	O
cr	pointer
->	O
references	O
=	O
1	int
;	O
cr	pointer
->	O
next	O
=	O
replyhashtable	array
[	O
hash	int
]	O
;	O
if	O
(	O
replyhashtable	array
[	O
hash	int
]	O
)	O
replyhashtable	array
[	O
hash	int
]	O
->	O
prevp	O
=	O
&	O
cr	pointer
->	O
next	O
;	O
cr	pointer
->	O
prevp	O
=	O
&	O
replyhashtable	array
[	O
hash	int
]	O
;	O
replyhashtable	array
[	O
hash	int
]	O
=	O
cr	pointer
;	O
pthread_spin_unlock	function
(	O
&	O
replycachelock	int
)	O
;	O
return	O
cr	pointer
;	O
}	O
void	O
release_cached_reply	function
(	O
struct	O
cached_reply	O
*	O
cr	pointer
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
cr	pointer
->	O
lock	O
)	O
;	O
pthread_spin_lock	function
(	O
&	O
replycachelock	int
)	O
;	O
cr	pointer
->	O
references	O
--	O
;	O
if	O
(	O
cr	pointer
->	O
references	O
==	O
0	int
)	O
{	O
cr	pointer
->	O
lastuse	O
=	O
mapped_time	O
->	O
seconds	O
;	O
if	O
(	O
cr	pointer
->	O
lastuse	O
<	O
leastreplylastuse	int
||	O
nfreereplies	int
==	O
0	int
)	O
leastreplylastuse	int
=	O
cr	pointer
->	O
lastuse	O
;	O
nfreereplies	int
++	O
;	O
}	O
pthread_spin_unlock	function
(	O
&	O
replycachelock	int
)	O
;	O
}	O
void	O
scan_replies	function
(	O
)	O
{	O
int	O
n	int
;	O
int	O
newleast	int
=	O
mapped_time	O
->	O
seconds	O
;	O
pthread_spin_lock	function
(	O
&	O
replycachelock	int
)	O
;	O
if	O
(	O
mapped_time	O
->	O
seconds	O
-	O
leastreplylastuse	int
>	O
REPLY_KEEP_TIMEOUT	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
REPLYHASH_TABLE_SIZE	int
&&	O
nfreereplies	int
;	O
n	int
++	O
)	O
{	O
struct	O
cached_reply	O
*	O
cr	pointer
=	O
replyhashtable	array
[	O
n	int
]	O
;	O
while	O
(	O
cr	pointer
&&	O
nfreereplies	int
)	O
{	O
struct	O
cached_reply	O
*	O
next_cr	pointer
=	O
cr	pointer
->	O
next	O
;	O
if	O
(	O
!	O
cr	pointer
->	O
references	O
&&	O
mapped_time	O
->	O
seconds	O
-	O
cr	pointer
->	O
lastuse	O
>	O
REPLY_KEEP_TIMEOUT	O
)	O
{	O
nfreereplies	int
--	O
;	O
*	O
cr	pointer
->	O
prevp	O
=	O
cr	pointer
->	O
next	O
;	O
if	O
(	O
cr	pointer
->	O
next	O
)	O
cr	pointer
->	O
next	O
->	O
prevp	O
=	O
cr	pointer
->	O
prevp	O
;	O
if	O
(	O
cr	pointer
->	O
data	O
)	O
free	function
(	O
cr	pointer
->	O
data	O
)	O
;	O
free	function
(	O
cr	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
cr	pointer
->	O
references	O
&&	O
newleast	int
>	O
cr	pointer
->	O
lastuse	O
)	O
newleast	int
=	O
cr	pointer
->	O
lastuse	O
;	O
cr	pointer
=	O
next_cr	pointer
;	O
}	O
}	O
if	O
(	O
nfreereplies	int
)	O
leastreplylastuse	int
=	O
newleast	int
;	O
}	O
pthread_spin_unlock	function
(	O
&	O
replycachelock	int
)	O
;	O
}	O
