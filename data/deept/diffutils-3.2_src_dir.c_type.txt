struct	O
dirdata	struct
{	O
size_t	long
nnames	long
;	O
char	O
const	O
*	O
*	O
names	pointer
;	O
char	O
*	O
data	pointer
;	O
}	O
;	O
static	O
bool	bool
locale_specific_sorting	bool
;	O
static	O
jmp_buf	array
failed_locale_specific_sorting	array
;	O
static	O
bool	bool
dir_loop	function
(	O
struct	O
comparison	struct
const	O
*	O
,	O
int	O
)	O
;	O
static	O
int	O
compare_names_for_qsort	function
(	O
void	O
const	O
*	O
,	O
void	O
const	O
*	O
)	O
;	O
static	O
bool	bool
dir_read	function
(	O
struct	O
file_data	struct
const	O
*	O
dir	pointer
,	O
struct	O
dirdata	struct
*	O
dirdata	struct
)	O
{	O
register	O
struct	O
dirent	struct
*	O
next	pointer
;	O
register	O
size_t	long
i	long
;	O
char	O
const	O
*	O
*	O
names	pointer
;	O
size_t	long
nnames	long
;	O
char	O
*	O
data	pointer
;	O
size_t	long
data_alloc	long
,	O
data_used	long
;	O
dirdata	struct
->	O
names	pointer
=	O
0	int
;	O
dirdata	struct
->	O
data	pointer
=	O
0	int
;	O
nnames	long
=	O
0	int
;	O
data	pointer
=	O
0	int
;	O
if	O
(	O
dir	pointer
->	O
desc	int
!=	O
-	O
1	int
)	O
{	O
register	O
DIR	struct
*	O
reading	pointer
=	O
opendir	function
(	O
dir	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
!	O
reading	pointer
)	O
return	O
false	int
;	O
data_alloc	long
=	O
512	int
;	O
data_used	long
=	O
0	int
;	O
dirdata	struct
->	O
data	pointer
=	O
data	pointer
=	O
xmalloc	function
(	O
data_alloc	long
)	O
;	O
while	O
(	O
(	O
errno	O
=	O
0	int
,	O
(	O
next	pointer
=	O
readdir	function
(	O
reading	pointer
)	O
)	O
!=	O
0	int
)	O
)	O
{	O
char	O
*	O
d_name	array
=	O
next	pointer
->	O
d_name	array
;	O
size_t	long
d_size	long
=	O
_D_EXACT_NAMLEN	O
(	O
next	pointer
)	O
+	O
1	int
;	O
if	O
(	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
d_name	array
[	O
1	int
]	O
==	O
0	int
||	O
(	O
d_name	array
[	O
1	int
]	O
==	O
'.'	O
&&	O
d_name	array
[	O
2	int
]	O
==	O
0	int
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
excluded_file_name	function
(	O
excluded	pointer
,	O
d_name	array
)	O
)	O
continue	O
;	O
while	O
(	O
data_alloc	long
<	O
data_used	long
+	O
d_size	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
2	int
<=	O
data_alloc	long
)	O
xalloc_die	function
(	O
)	O
;	O
dirdata	struct
->	O
data	pointer
=	O
data	pointer
=	O
xrealloc	function
(	O
data	pointer
,	O
data_alloc	long
*=	O
2	int
)	O
;	O
}	O
memcpy	function
(	O
data	pointer
+	O
data_used	long
,	O
d_name	array
,	O
d_size	long
)	O
;	O
data_used	long
+=	O
d_size	long
;	O
nnames	long
++	O
;	O
}	O
if	O
(	O
errno	O
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
closedir	function
(	O
reading	pointer
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
false	int
;	O
}	O
if	O
(	O
closedir	function
(	O
reading	pointer
)	O
!=	O
0	int
)	O
return	O
false	int
;	O
}	O
if	O
(	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
names	pointer
-	O
1	int
<=	O
nnames	long
)	O
xalloc_die	function
(	O
)	O
;	O
dirdata	struct
->	O
names	pointer
=	O
names	pointer
=	O
xmalloc	function
(	O
(	O
nnames	long
+	O
1	int
)	O
*	O
sizeof	O
*	O
names	pointer
)	O
;	O
dirdata	struct
->	O
nnames	long
=	O
nnames	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nnames	long
;	O
i	long
++	O
)	O
{	O
names	pointer
[	O
i	long
]	O
=	O
data	pointer
;	O
data	pointer
+=	O
strlen	function
(	O
data	pointer
)	O
+	O
1	int
;	O
}	O
names	pointer
[	O
nnames	long
]	O
=	O
0	int
;	O
return	O
true	int
;	O
}	O
static	O
int	O
compare_names	function
(	O
char	O
const	O
*	O
name1	pointer
,	O
char	O
const	O
*	O
name2	pointer
)	O
{	O
if	O
(	O
locale_specific_sorting	bool
)	O
{	O
int	O
r	int
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
ignore_file_name_case	bool
)	O
r	int
=	O
strcasecoll	O
(	O
name1	pointer
,	O
name2	pointer
)	O
;	O
else	O
r	int
=	O
strcoll	function
(	O
name1	pointer
,	O
name2	pointer
)	O
;	O
if	O
(	O
errno	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot compare file names `%s' and `%s'"	pointer
)	O
,	O
name1	pointer
,	O
name2	pointer
)	O
;	O
longjmp	function
(	O
failed_locale_specific_sorting	array
,	O
1	int
)	O
;	O
}	O
return	O
r	int
;	O
}	O
return	O
file_name_cmp	O
(	O
name1	pointer
,	O
name2	pointer
)	O
;	O
}	O
static	O
int	O
compare_names_for_qsort	function
(	O
void	O
const	O
*	O
file1	pointer
,	O
void	O
const	O
*	O
file2	pointer
)	O
{	O
char	O
const	O
*	O
const	O
*	O
f1	pointer
=	O
file1	pointer
;	O
char	O
const	O
*	O
const	O
*	O
f2	pointer
=	O
file2	pointer
;	O
int	O
diff	int
=	O
compare_names	function
(	O
*	O
f1	pointer
,	O
*	O
f2	pointer
)	O
;	O
return	O
diff	int
?	O
diff	int
:	O
file_name_cmp	O
(	O
*	O
f1	pointer
,	O
*	O
f2	pointer
)	O
;	O
}	O
int	O
diff_dirs	function
(	O
struct	O
comparison	struct
const	O
*	O
cmp	pointer
,	O
int	O
(	O
*	O
handle_file	pointer
)	O
(	O
struct	O
comparison	struct
const	O
*	O
,	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
)	O
{	O
struct	O
dirdata	struct
dirdata	struct
[	O
2	int
]	O
;	O
int	O
volatile	O
val	array
=	O
EXIT_SUCCESS	int
;	O
int	O
i	long
;	O
if	O
(	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
desc	int
==	O
-	O
1	int
||	O
dir_loop	function
(	O
cmp	pointer
,	O
0	int
)	O
)	O
&&	O
(	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
desc	int
==	O
-	O
1	int
||	O
dir_loop	function
(	O
cmp	pointer
,	O
1	int
)	O
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: recursive directory loop"	pointer
)	O
,	O
cmp	pointer
->	O
file	array
[	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
desc	int
==	O
-	O
1	int
]	O
.	O
name	pointer
)	O
;	O
return	O
EXIT_TROUBLE	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
2	int
;	O
i	long
++	O
)	O
if	O
(	O
!	O
dir_read	function
(	O
&	O
cmp	pointer
->	O
file	array
[	O
i	long
]	O
,	O
&	O
dirdata	struct
[	O
i	long
]	O
)	O
)	O
{	O
perror_with_name	function
(	O
cmp	pointer
->	O
file	array
[	O
i	long
]	O
.	O
name	pointer
)	O
;	O
val	array
=	O
EXIT_TROUBLE	int
;	O
}	O
if	O
(	O
val	array
==	O
EXIT_SUCCESS	int
)	O
{	O
char	O
const	O
*	O
*	O
volatile	O
names	pointer
[	O
2	int
]	O
;	O
names	pointer
[	O
0	int
]	O
=	O
dirdata	struct
[	O
0	int
]	O
.	O
names	pointer
;	O
names	pointer
[	O
1	int
]	O
=	O
dirdata	struct
[	O
1	int
]	O
.	O
names	pointer
;	O
locale_specific_sorting	bool
=	O
true	int
;	O
if	O
(	O
setjmp	function
(	O
failed_locale_specific_sorting	array
)	O
)	O
locale_specific_sorting	bool
=	O
false	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
2	int
;	O
i	long
++	O
)	O
qsort	function
(	O
names	pointer
[	O
i	long
]	O
,	O
dirdata	struct
[	O
i	long
]	O
.	O
nnames	long
,	O
sizeof	O
*	O
dirdata	struct
[	O
i	long
]	O
.	O
names	pointer
,	O
compare_names_for_qsort	function
)	O
;	O
if	O
(	O
starting_file	pointer
&&	O
!	O
cmp	pointer
->	O
parent	pointer
)	O
{	O
while	O
(	O
*	O
names	pointer
[	O
0	int
]	O
&&	O
compare_names	function
(	O
*	O
names	pointer
[	O
0	int
]	O
,	O
starting_file	pointer
)	O
<	O
0	int
)	O
names	pointer
[	O
0	int
]	O
++	O
;	O
while	O
(	O
*	O
names	pointer
[	O
1	int
]	O
&&	O
compare_names	function
(	O
*	O
names	pointer
[	O
1	int
]	O
,	O
starting_file	pointer
)	O
<	O
0	int
)	O
names	pointer
[	O
1	int
]	O
++	O
;	O
}	O
while	O
(	O
*	O
names	pointer
[	O
0	int
]	O
||	O
*	O
names	pointer
[	O
1	int
]	O
)	O
{	O
int	O
nameorder	int
=	O
(	O
!	O
*	O
names	pointer
[	O
0	int
]	O
?	O
1	int
:	O
!	O
*	O
names	pointer
[	O
1	int
]	O
?	O
-	O
1	int
:	O
compare_names	function
(	O
*	O
names	pointer
[	O
0	int
]	O
,	O
*	O
names	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
nameorder	int
==	O
0	int
)	O
{	O
int	O
raw_order	int
=	O
file_name_cmp	O
(	O
*	O
names	pointer
[	O
0	int
]	O
,	O
*	O
names	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
raw_order	int
!=	O
0	int
)	O
{	O
int	O
greater_side	int
=	O
raw_order	int
<	O
0	int
;	O
int	O
lesser_side	int
=	O
1	int
-	O
greater_side	int
;	O
char	O
const	O
*	O
*	O
lesser	pointer
=	O
names	pointer
[	O
lesser_side	int
]	O
;	O
char	O
const	O
*	O
greater_name	pointer
=	O
*	O
names	pointer
[	O
greater_side	int
]	O
;	O
char	O
const	O
*	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
lesser	pointer
+	O
1	int
;	O
*	O
p	pointer
&&	O
compare_names	function
(	O
*	O
p	pointer
,	O
greater_name	pointer
)	O
==	O
0	int
;	O
p	pointer
++	O
)	O
{	O
int	O
c	int
=	O
file_name_cmp	O
(	O
*	O
p	pointer
,	O
greater_name	pointer
)	O
;	O
if	O
(	O
0	int
<=	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
memmove	function
(	O
lesser	pointer
+	O
1	int
,	O
lesser	pointer
,	O
(	O
char	O
*	O
)	O
p	pointer
-	O
(	O
char	O
*	O
)	O
lesser	pointer
)	O
;	O
*	O
lesser	pointer
=	O
greater_name	pointer
;	O
}	O
break	O
;	O
}	O
}	O
}	O
}	O
int	O
v1	int
=	O
(	O
*	O
handle_file	pointer
)	O
(	O
cmp	pointer
,	O
0	int
<	O
nameorder	int
?	O
0	int
:	O
*	O
names	pointer
[	O
0	int
]	O
++	O
,	O
nameorder	int
<	O
0	int
?	O
0	int
:	O
*	O
names	pointer
[	O
1	int
]	O
++	O
)	O
;	O
if	O
(	O
val	array
<	O
v1	int
)	O
val	array
=	O
v1	int
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
2	int
;	O
i	long
++	O
)	O
{	O
free	function
(	O
dirdata	struct
[	O
i	long
]	O
.	O
names	pointer
)	O
;	O
free	function
(	O
dirdata	struct
[	O
i	long
]	O
.	O
data	pointer
)	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
bool	bool
dir_loop	function
(	O
struct	O
comparison	struct
const	O
*	O
cmp	pointer
,	O
int	O
i	long
)	O
{	O
struct	O
comparison	struct
const	O
*	O
p	pointer
=	O
cmp	pointer
;	O
while	O
(	O
(	O
p	pointer
=	O
p	pointer
->	O
parent	pointer
)	O
)	O
if	O
(	O
0	int
<	O
same_file	O
(	O
&	O
p	pointer
->	O
file	array
[	O
i	long
]	O
.	O
stat	struct
,	O
&	O
cmp	pointer
->	O
file	array
[	O
i	long
]	O
.	O
stat	struct
)	O
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
char	O
*	O
find_dir_file_pathname	function
(	O
char	O
const	O
*	O
dir	pointer
,	O
char	O
const	O
*	O
file	array
)	O
{	O
char	O
*	O
val	array
;	O
char	O
const	O
*	O
match	pointer
=	O
file	array
;	O
struct	O
dirdata	struct
dirdata	struct
;	O
dirdata	struct
.	O
names	pointer
=	O
NULL	O
;	O
dirdata	struct
.	O
data	pointer
=	O
NULL	O
;	O
if	O
(	O
ignore_file_name_case	bool
)	O
{	O
struct	O
file_data	struct
filedata	struct
;	O
filedata	struct
.	O
name	pointer
=	O
dir	pointer
;	O
filedata	struct
.	O
desc	int
=	O
0	int
;	O
if	O
(	O
dir_read	function
(	O
&	O
filedata	struct
,	O
&	O
dirdata	struct
)	O
)	O
{	O
locale_specific_sorting	bool
=	O
true	int
;	O
if	O
(	O
setjmp	function
(	O
failed_locale_specific_sorting	array
)	O
)	O
match	pointer
=	O
file	array
;	O
else	O
{	O
for	O
(	O
char	O
const	O
*	O
*	O
p	pointer
=	O
dirdata	struct
.	O
names	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
compare_names	function
(	O
*	O
p	pointer
,	O
file	array
)	O
==	O
0	int
)	O
{	O
if	O
(	O
file_name_cmp	O
(	O
*	O
p	pointer
,	O
file	array
)	O
==	O
0	int
)	O
{	O
match	pointer
=	O
*	O
p	pointer
;	O
break	O
;	O
}	O
if	O
(	O
match	pointer
==	O
file	array
)	O
match	pointer
=	O
*	O
p	pointer
;	O
}	O
}	O
}	O
}	O
val	array
=	O
file_name_concat	function
(	O
dir	pointer
,	O
match	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
dirdata	struct
.	O
names	pointer
)	O
;	O
free	function
(	O
dirdata	struct
.	O
data	pointer
)	O
;	O
return	O
val	array
;	O
}	O
