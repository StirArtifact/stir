extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
int	O
iflag	int
;	O
extern	O
struct	O
win	struct
*	O
console_window	pointer
;	O
static	O
void	O
consredir_readev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
int	O
separate_sids	int
=	O
1	int
;	O
static	O
void	O
DoSendBreak	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
sigret_t	void
SigAlrmDummy	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
sigret_t	void
SigAlrmDummy	function
SIGDEFARG	O
{	O
debug	O
(	O
"SigAlrmDummy()\n"	pointer
)	O
;	O
SIGRETURN	O
;	O
}	O
int	O
OpenTTY	function
(	O
char	O
*	O
line	array
,	O
char	O
*	O
opt	pointer
)	O
{	O
int	O
f	int
;	O
struct	O
mode	struct
Mode	struct
;	O
sigret_t	void
(	O
*	O
sigalrm	pointer
)	O
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
sigalrm	pointer
=	O
signal	function
(	O
SIGALRM	int
,	O
SigAlrmDummy	function
)	O
;	O
alarm	function
(	O
2	int
)	O
;	O
if	O
(	O
(	O
f	int
=	O
secopen	function
(	O
line	array
,	O
O_RDWR	int
|	O
O_NONBLOCK	int
|	O
O_NOCTTY	int
,	O
0	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
Msg	function
(	O
0	int
,	O
"Cannot open line '%s' for R/W: open() blocked, aborted."	pointer
,	O
line	array
)	O
;	O
else	O
Msg	function
(	O
errno	O
,	O
"Cannot open line '%s' for R/W"	pointer
,	O
line	array
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
sigalrm	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
isatty	function
(	O
f	int
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"'%s' is not a tty"	pointer
,	O
line	array
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
sigalrm	pointer
)	O
;	O
close	pointer
(	O
f	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
errno	O
=	O
0	int
;	O
if	O
(	O
ioctl	function
(	O
f	int
,	O
TIOCEXCL	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
<	O
0	int
)	O
Msg	function
(	O
errno	O
,	O
"%s: ioctl TIOCEXCL failed"	pointer
,	O
line	array
)	O
;	O
debug3	O
(	O
"%d %d %d\n"	pointer
,	O
getuid	function
(	O
)	O
,	O
geteuid	function
(	O
)	O
,	O
getpid	function
(	O
)	O
)	O
;	O
debug2	O
(	O
"%s TIOCEXCL errno %d\n"	pointer
,	O
line	array
,	O
errno	O
)	O
;	O
InitTTY	function
(	O
&	O
Mode	struct
,	O
W_TYPE_PLAIN	int
)	O
;	O
SttyMode	function
(	O
&	O
Mode	struct
,	O
opt	pointer
)	O
;	O
SetTTY	function
(	O
f	int
,	O
&	O
Mode	struct
)	O
;	O
{	O
int	O
mcs	int
=	O
0	int
;	O
ioctl	function
(	O
f	int
,	O
TIOCMGET	int
,	O
&	O
mcs	int
)	O
;	O
mcs	int
|=	O
TIOCM_RTS	int
;	O
ioctl	function
(	O
f	int
,	O
TIOCMSET	int
,	O
&	O
mcs	int
)	O
;	O
}	O
brktty	function
(	O
f	int
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
sigalrm	pointer
)	O
;	O
debug2	O
(	O
"'%s' CONNECT fd=%d.\n"	pointer
,	O
line	array
,	O
f	int
)	O
;	O
return	O
f	int
;	O
}	O
void	O
InitTTY	function
(	O
struct	O
mode	struct
*	O
m	union
,	O
int	O
ttyflag	int
)	O
{	O
bzero	function
(	O
(	O
char	O
*	O
)	O
m	union
,	O
sizeof	O
(	O
*	O
m	union
)	O
)	O
;	O
debug1	O
(	O
"InitTTY: POSIX: termios defaults based on SunOS 4.1.3, but better (%d)\n"	pointer
,	O
ttyflag	int
)	O
;	O
m	union
->	O
tio	struct
.	O
c_iflag	short
|=	O
BRKINT	int
;	O
m	union
->	O
tio	struct
.	O
c_iflag	short
|=	O
IGNPAR	int
;	O
m	union
->	O
tio	struct
.	O
c_iflag	short
|=	O
IXON	int
;	O
if	O
(	O
!	O
ttyflag	int
)	O
{	O
m	union
->	O
tio	struct
.	O
c_iflag	short
|=	O
ICRNL	int
;	O
m	union
->	O
tio	struct
.	O
c_oflag	short
|=	O
ONLCR	int
;	O
m	union
->	O
tio	struct
.	O
c_oflag	short
|=	O
TAB3	int
;	O
m	union
->	O
tio	struct
.	O
c_oflag	short
|=	O
OPOST	int
;	O
}	O
cfsetospeed	function
(	O
&	O
m	union
->	O
tio	struct
,	O
B9600	int
)	O
;	O
cfsetispeed	function
(	O
&	O
m	union
->	O
tio	struct
,	O
B9600	int
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cflag	short
|=	O
CS8	int
;	O
m	union
->	O
tio	struct
.	O
c_cflag	short
|=	O
CREAD	int
;	O
m	union
->	O
tio	struct
.	O
c_cflag	short
|=	O
CLOCAL	int
;	O
m	union
->	O
tio	struct
.	O
c_lflag	short
|=	O
ECHOCTL	int
;	O
m	union
->	O
tio	struct
.	O
c_lflag	short
|=	O
ECHOKE	int
;	O
if	O
(	O
!	O
ttyflag	int
)	O
{	O
m	union
->	O
tio	struct
.	O
c_lflag	short
|=	O
ISIG	int
;	O
m	union
->	O
tio	struct
.	O
c_lflag	short
|=	O
ICANON	int
;	O
m	union
->	O
tio	struct
.	O
c_lflag	short
|=	O
ECHO	int
;	O
}	O
m	union
->	O
tio	struct
.	O
c_lflag	short
|=	O
ECHOE	int
;	O
m	union
->	O
tio	struct
.	O
c_lflag	short
|=	O
ECHOK	int
;	O
m	union
->	O
tio	struct
.	O
c_lflag	short
|=	O
IEXTEN	int
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
Ctrl	O
(	O
'C'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VQUIT	int
]	O
=	O
Ctrl	O
(	O
'\\'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VERASE	int
]	O
=	O
0x7f	int
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VKILL	int
]	O
=	O
Ctrl	O
(	O
'U'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VEOF	int
]	O
=	O
Ctrl	O
(	O
'D'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VEOL	int
]	O
=	O
VDISABLE	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VEOL2	int
]	O
=	O
VDISABLE	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VSTART	int
]	O
=	O
Ctrl	O
(	O
'Q'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VSTOP	int
]	O
=	O
Ctrl	O
(	O
'S'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VSUSP	int
]	O
=	O
Ctrl	O
(	O
'Z'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VREPRINT	int
]	O
=	O
Ctrl	O
(	O
'R'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VDISCARD	int
]	O
=	O
Ctrl	O
(	O
'O'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VWERASE	int
]	O
=	O
Ctrl	O
(	O
'W'	O
)	O
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VLNEXT	int
]	O
=	O
Ctrl	O
(	O
'V'	O
)	O
;	O
if	O
(	O
ttyflag	int
)	O
{	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
TTYVMIN	int
;	O
m	union
->	O
tio	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
TTYVTIME	int
;	O
}	O
}	O
void	O
SetTTY	function
(	O
int	O
fd	int
,	O
struct	O
mode	struct
*	O
mp	pointer
)	O
{	O
errno	O
=	O
0	int
;	O
tcsetattr	function
(	O
fd	int
,	O
TCSADRAIN	int
,	O
&	O
mp	pointer
->	O
tio	struct
)	O
;	O
if	O
(	O
errno	O
)	O
Msg	function
(	O
errno	O
,	O
"SetTTY (fd %d): ioctl failed"	pointer
,	O
fd	int
)	O
;	O
}	O
void	O
GetTTY	function
(	O
int	O
fd	int
,	O
struct	O
mode	struct
*	O
mp	pointer
)	O
{	O
errno	O
=	O
0	int
;	O
tcgetattr	function
(	O
fd	int
,	O
&	O
mp	pointer
->	O
tio	struct
)	O
;	O
if	O
(	O
errno	O
)	O
Msg	function
(	O
errno	O
,	O
"GetTTY (fd %d): ioctl failed"	pointer
,	O
fd	int
)	O
;	O
}	O
void	O
SetMode	function
(	O
struct	O
mode	struct
*	O
op	pointer
,	O
struct	O
mode	struct
*	O
np	pointer
,	O
int	O
flow	int
,	O
int	O
interrupt	int
)	O
{	O
*	O
np	pointer
=	O
*	O
op	pointer
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
np	pointer
->	O
tio	struct
.	O
c_iflag	short
&=	O
~	O
ICRNL	int
;	O
np	pointer
->	O
tio	struct
.	O
c_iflag	short
&=	O
~	O
ISTRIP	int
;	O
np	pointer
->	O
tio	struct
.	O
c_oflag	short
&=	O
~	O
ONLCR	int
;	O
np	pointer
->	O
tio	struct
.	O
c_lflag	short
&=	O
~	O
(	O
ICANON	int
|	O
ECHO	int
)	O
;	O
np	pointer
->	O
tio	struct
.	O
c_lflag	short
&=	O
~	O
IEXTEN	int
;	O
if	O
(	O
interrupt	int
)	O
np	pointer
->	O
tio	struct
.	O
c_lflag	short
|=	O
ISIG	int
;	O
else	O
np	pointer
->	O
tio	struct
.	O
c_lflag	short
&=	O
~	O
ISIG	int
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
interrupt	int
||	O
!	O
flow	int
)	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
VDISABLE	O
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VQUIT	int
]	O
=	O
VDISABLE	O
;	O
if	O
(	O
flow	int
==	O
0	int
)	O
{	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VSTART	int
]	O
=	O
VDISABLE	O
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VSTOP	int
]	O
=	O
VDISABLE	O
;	O
np	pointer
->	O
tio	struct
.	O
c_iflag	short
&=	O
~	O
IXON	int
;	O
}	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VDISCARD	int
]	O
=	O
VDISABLE	O
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VLNEXT	int
]	O
=	O
VDISABLE	O
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VSUSP	int
]	O
=	O
VDISABLE	O
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VERASE	int
]	O
=	O
0x7f	int
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VKILL	int
]	O
=	O
VDISABLE	O
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VREPRINT	int
]	O
=	O
VDISABLE	O
;	O
np	pointer
->	O
tio	struct
.	O
c_cc	array
[	O
VWERASE	int
]	O
=	O
VDISABLE	O
;	O
}	O
void	O
SetFlow	function
(	O
int	O
on	int
)	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
D_flow	O
==	O
on	int
)	O
return	O
;	O
if	O
(	O
on	int
)	O
{	O
D_NewMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
iflag	int
?	O
D_OldMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
:	O
VDISABLE	O
;	O
D_NewMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VSTART	int
]	O
=	O
D_OldMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VSTART	int
]	O
;	O
D_NewMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VSTOP	int
]	O
=	O
D_OldMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VSTOP	int
]	O
;	O
D_NewMode	O
.	O
tio	struct
.	O
c_iflag	short
|=	O
D_OldMode	O
.	O
tio	struct
.	O
c_iflag	short
&	O
IXON	int
;	O
}	O
else	O
{	O
D_NewMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
VDISABLE	O
;	O
D_NewMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VSTART	int
]	O
=	O
VDISABLE	O
;	O
D_NewMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VSTOP	int
]	O
=	O
VDISABLE	O
;	O
D_NewMode	O
.	O
tio	struct
.	O
c_iflag	short
&=	O
~	O
IXON	int
;	O
}	O
if	O
(	O
!	O
on	int
)	O
tcflow	function
(	O
D_userfd	O
,	O
TCOON	int
)	O
;	O
if	O
(	O
tcsetattr	function
(	O
D_userfd	O
,	O
TCSANOW	int
,	O
&	O
D_NewMode	O
.	O
tio	struct
)	O
)	O
debug1	O
(	O
"SetFlow: ioctl errno %d\n"	pointer
,	O
errno	O
)	O
;	O
D_flow	O
=	O
on	int
;	O
}	O
int	O
SttyMode	function
(	O
struct	O
mode	struct
*	O
m	union
,	O
char	O
*	O
opt	pointer
)	O
{	O
static	O
const	O
char	O
sep	array
[	O
]	O
=	O
" \t:;,"	pointer
;	O
if	O
(	O
!	O
opt	pointer
)	O
return	O
0	int
;	O
while	O
(	O
*	O
opt	pointer
)	O
{	O
while	O
(	O
index	function
(	O
sep	array
,	O
*	O
opt	pointer
)	O
)	O
opt	pointer
++	O
;	O
if	O
(	O
*	O
opt	pointer
>=	O
'0'	O
&&	O
*	O
opt	pointer
<=	O
'9'	O
)	O
{	O
if	O
(	O
SetBaud	function
(	O
m	union
,	O
atoi	function
(	O
opt	pointer
)	O
,	O
atoi	function
(	O
opt	pointer
)	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"cs7"	pointer
,	O
opt	pointer
,	O
3	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_cflag	short
&=	O
~	O
CSIZE	int
;	O
m	union
->	O
tio	struct
.	O
c_cflag	short
|=	O
CS7	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"cs8"	pointer
,	O
opt	pointer
,	O
3	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_cflag	short
&=	O
~	O
CSIZE	int
;	O
m	union
->	O
tio	struct
.	O
c_cflag	short
|=	O
CS8	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"istrip"	pointer
,	O
opt	pointer
,	O
6	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_iflag	short
|=	O
ISTRIP	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"-istrip"	pointer
,	O
opt	pointer
,	O
7	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_iflag	short
&=	O
~	O
ISTRIP	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"ixon"	pointer
,	O
opt	pointer
,	O
4	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_iflag	short
|=	O
IXON	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"-ixon"	pointer
,	O
opt	pointer
,	O
5	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_iflag	short
&=	O
~	O
IXON	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"ixoff"	pointer
,	O
opt	pointer
,	O
5	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_iflag	short
|=	O
IXOFF	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"-ixoff"	pointer
,	O
opt	pointer
,	O
6	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_iflag	short
&=	O
~	O
IXOFF	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"crtscts"	pointer
,	O
opt	pointer
,	O
7	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_cflag	short
|=	O
CRTSCTS	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
"-crtscts"	pointer
,	O
opt	pointer
,	O
8	int
)	O
)	O
{	O
m	union
->	O
tio	struct
.	O
c_cflag	short
&=	O
~	O
CRTSCTS	int
;	O
}	O
else	O
return	O
-	O
1	int
;	O
while	O
(	O
*	O
opt	pointer
&&	O
!	O
index	function
(	O
sep	array
,	O
*	O
opt	pointer
)	O
)	O
opt	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
brktty	function
(	O
int	O
fd	int
)	O
{	O
if	O
(	O
separate_sids	int
)	O
setsid	function
(	O
)	O
;	O
}	O
int	O
fgtty	function
(	O
int	O
fd	int
)	O
{	O
int	O
mypid	int
;	O
mypid	int
=	O
getpid	function
(	O
)	O
;	O
if	O
(	O
separate_sids	int
)	O
if	O
(	O
tcsetpgrp	function
(	O
fd	int
,	O
mypid	int
)	O
)	O
{	O
debug1	O
(	O
"fgtty: tcsetpgrp: %d\n"	pointer
,	O
errno	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
breaktype	int
=	O
2	int
;	O
static	O
void	O
DoSendBreak	function
(	O
int	O
fd	int
,	O
int	O
n	int
,	O
int	O
type	enum
)	O
{	O
switch	O
(	O
type	enum
)	O
{	O
case	O
2	int
:	O
debug2	O
(	O
"%d * tcsendbreak(fd=%d, 0)\n"	pointer
,	O
n	int
,	O
fd	int
)	O
;	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
n	int
)	O
n	int
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
tcsendbreak	function
(	O
fd	int
,	O
0	int
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"cannot send BREAK (tcsendbreak SVR4)"	pointer
)	O
;	O
return	O
;	O
}	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
!	O
n	int
)	O
n	int
++	O
;	O
debug2	O
(	O
"%d * TCSBRK fd=%d\n"	pointer
,	O
n	int
,	O
fd	int
)	O
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
TCSBRK	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Cannot send BREAK (TCSBRK)"	pointer
)	O
;	O
return	O
;	O
}	O
}	O
break	O
;	O
case	O
0	int
:	O
debug	O
(	O
"TIOCSBRK TIOCCBRK\n"	pointer
)	O
;	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
TIOCSBRK	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Can't send BREAK (TIOCSBRK)"	pointer
)	O
;	O
return	O
;	O
}	O
sleep1000	function
(	O
n	int
?	O
n	int
*	O
250	int
:	O
250	int
)	O
;	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
TIOCCBRK	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"BREAK stuck!!! -- HELP! (TIOCCBRK)"	pointer
)	O
;	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
Msg	function
(	O
0	int
,	O
"Internal SendBreak error: method %d unknown"	pointer
,	O
type	enum
)	O
;	O
}	O
}	O
void	O
SendBreak	function
(	O
struct	O
win	struct
*	O
wp	pointer
,	O
int	O
n	int
,	O
int	O
closeopen	int
)	O
{	O
sigret_t	void
(	O
*	O
sigalrm	pointer
)	O
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_type	int
!=	O
W_TYPE_PLAIN	int
)	O
return	O
;	O
debug3	O
(	O
"break(%d, %d) fd %d\n"	pointer
,	O
n	int
,	O
closeopen	int
,	O
wp	pointer
->	O
w_ptyfd	int
)	O
;	O
(	O
void	O
)	O
tcflush	function
(	O
wp	pointer
->	O
w_ptyfd	int
,	O
TCIOFLUSH	int
)	O
;	O
if	O
(	O
closeopen	int
)	O
{	O
close	pointer
(	O
wp	pointer
->	O
w_ptyfd	int
)	O
;	O
sleep1000	function
(	O
n	int
?	O
n	int
*	O
250	int
:	O
250	int
)	O
;	O
if	O
(	O
(	O
wp	pointer
->	O
w_ptyfd	int
=	O
OpenTTY	function
(	O
wp	pointer
->	O
w_tty	array
,	O
wp	pointer
->	O
w_cmdargs	array
[	O
1	int
]	O
)	O
)	O
<	O
1	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Ouch, cannot reopen line %s, please try harder"	pointer
,	O
wp	pointer
->	O
w_tty	array
)	O
;	O
return	O
;	O
}	O
(	O
void	O
)	O
fcntl	function
(	O
wp	pointer
->	O
w_ptyfd	int
,	O
F_SETFL	int
,	O
FNBLOCK	O
)	O
;	O
}	O
else	O
{	O
sigalrm	pointer
=	O
signal	function
(	O
SIGALRM	int
,	O
SigAlrmDummy	function
)	O
;	O
alarm	function
(	O
15	int
)	O
;	O
DoSendBreak	function
(	O
wp	pointer
->	O
w_ptyfd	int
,	O
n	int
,	O
breaktype	int
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
sigalrm	pointer
)	O
;	O
}	O
debug	O
(	O
"            broken.\n"	pointer
)	O
;	O
}	O
static	O
struct	O
event	struct
consredir_ev	struct
;	O
static	O
int	O
consredirfd	array
[	O
2	int
]	O
=	O
{	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
static	O
void	O
consredir_readev_fn	function
(	O
struct	O
event	struct
*	O
ev	pointer
,	O
char	O
*	O
data	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
n	int
,	O
buf	pointer
[	O
256	int
]	O
;	O
int	O
l	int
;	O
if	O
(	O
!	O
console_window	pointer
||	O
(	O
l	int
=	O
read	pointer
(	O
consredirfd	array
[	O
0	int
]	O
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
<=	O
0	int
)	O
{	O
close	pointer
(	O
consredirfd	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
consredirfd	array
[	O
1	int
]	O
)	O
;	O
consredirfd	array
[	O
0	int
]	O
=	O
consredirfd	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
evdeq	function
(	O
ev	pointer
)	O
;	O
return	O
;	O
}	O
for	O
(	O
p	pointer
=	O
n	int
=	O
buf	pointer
;	O
l	int
>	O
0	int
;	O
n	int
++	O
,	O
l	int
--	O
)	O
if	O
(	O
*	O
n	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
n	int
>	O
p	pointer
)	O
WriteString	function
(	O
console_window	pointer
,	O
p	pointer
,	O
n	int
-	O
p	pointer
)	O
;	O
WriteString	function
(	O
console_window	pointer
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
p	pointer
=	O
n	int
+	O
1	int
;	O
}	O
if	O
(	O
n	int
>	O
p	pointer
)	O
WriteString	function
(	O
console_window	pointer
,	O
p	pointer
,	O
n	int
-	O
p	pointer
)	O
;	O
}	O
int	O
TtyGrabConsole	function
(	O
int	O
fd	int
,	O
int	O
on	int
,	O
char	O
*	O
rc_name	pointer
)	O
{	O
struct	O
display	struct
*	O
d	int
;	O
struct	O
mode	struct
new1	struct
,	O
new2	struct
;	O
char	O
*	O
slave	pointer
;	O
if	O
(	O
on	int
>	O
0	int
)	O
{	O
if	O
(	O
displays	pointer
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"I need a display"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
d	int
=	O
displays	pointer
;	O
d	int
;	O
d	int
=	O
d	int
->	O
d_next	pointer
)	O
if	O
(	O
strcmp	function
(	O
d	int
->	O
d_usertty	array
,	O
"/dev/console"	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
d	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"too dangerous - screen is running on /dev/console"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
consredirfd	array
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
evdeq	function
(	O
&	O
consredir_ev	struct
)	O
;	O
close	pointer
(	O
consredirfd	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
consredirfd	array
[	O
1	int
]	O
)	O
;	O
consredirfd	array
[	O
0	int
]	O
=	O
consredirfd	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
if	O
(	O
on	int
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
consredirfd	array
[	O
0	int
]	O
=	O
OpenPTY	function
(	O
&	O
slave	pointer
)	O
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"%s: could not open detach pty master"	pointer
,	O
rc_name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
consredirfd	array
[	O
1	int
]	O
=	O
open	function
(	O
slave	pointer
,	O
O_RDWR	int
|	O
O_NOCTTY	int
)	O
)	O
<	O
0	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"%s: could not open detach pty slave"	pointer
,	O
rc_name	pointer
)	O
;	O
close	pointer
(	O
consredirfd	array
[	O
0	int
]	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
InitTTY	function
(	O
&	O
new1	struct
,	O
0	int
)	O
;	O
SetMode	function
(	O
&	O
new1	struct
,	O
&	O
new2	struct
,	O
0	int
,	O
0	int
)	O
;	O
SetTTY	function
(	O
consredirfd	array
[	O
1	int
]	O
,	O
&	O
new2	struct
)	O
;	O
if	O
(	O
UserContext	function
(	O
)	O
==	O
1	int
)	O
UserReturn	function
(	O
ioctl	function
(	O
consredirfd	array
[	O
1	int
]	O
,	O
TIOCCONS	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
)	O
)	O
;	O
if	O
(	O
UserStatus	function
(	O
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"%s: ioctl TIOCCONS failed"	pointer
,	O
rc_name	pointer
)	O
;	O
close	pointer
(	O
consredirfd	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
consredirfd	array
[	O
1	int
]	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
consredir_ev	struct
.	O
fd	int
=	O
consredirfd	array
[	O
0	int
]	O
;	O
consredir_ev	struct
.	O
type	enum
=	O
EV_READ	int
;	O
consredir_ev	struct
.	O
handler	pointer
=	O
consredir_readev_fn	function
;	O
evenq	function
(	O
&	O
consredir_ev	struct
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
TtyGetModemStatus	function
(	O
int	O
fd	int
,	O
char	O
*	O
buf	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
buf	pointer
;	O
unsigned	O
int	O
softcar	int
;	O
unsigned	O
int	O
mflags	int
;	O
struct	O
mode	struct
mtio	struct
;	O
int	O
rtscts	int
;	O
int	O
clocal	int
;	O
GetTTY	function
(	O
fd	int
,	O
&	O
mtio	struct
)	O
;	O
clocal	int
=	O
0	int
;	O
if	O
(	O
mtio	struct
.	O
tio	struct
.	O
c_cflag	short
&	O
CLOCAL	int
)	O
{	O
clocal	int
=	O
1	int
;	O
*	O
p	pointer
++	O
=	O
'{'	O
;	O
}	O
if	O
(	O
!	O
(	O
mtio	struct
.	O
tio	struct
.	O
c_cflag	short
&	O
CRTSCTS	int
)	O
)	O
rtscts	int
=	O
0	int
;	O
else	O
rtscts	int
=	O
1	int
;	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
TIOCGSOFTCAR	int
,	O
(	O
char	O
*	O
)	O
&	O
softcar	int
)	O
<	O
0	int
)	O
softcar	int
=	O
0	int
;	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
TIOCMGET	int
,	O
(	O
char	O
*	O
)	O
&	O
mflags	int
)	O
<	O
0	int
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"NO-TTY? %s"	pointer
,	O
softcar	int
?	O
"(CD)"	pointer
:	O
"CD"	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
"!RTS "	pointer
;	O
if	O
(	O
mflags	int
&	O
TIOCM_RTS	int
)	O
s	pointer
++	O
;	O
while	O
(	O
*	O
s	pointer
)	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
s	pointer
=	O
"!CTS "	pointer
;	O
if	O
(	O
!	O
rtscts	int
)	O
{	O
*	O
p	pointer
++	O
=	O
'('	O
;	O
s	pointer
=	O
"!CTS) "	pointer
;	O
}	O
if	O
(	O
mflags	int
&	O
TIOCM_CTS	int
)	O
s	pointer
++	O
;	O
while	O
(	O
*	O
s	pointer
)	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
s	pointer
=	O
"!DTR "	pointer
;	O
if	O
(	O
mflags	int
&	O
TIOCM_DTR	int
)	O
s	pointer
++	O
;	O
while	O
(	O
*	O
s	pointer
)	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
s	pointer
=	O
"!DSR "	pointer
;	O
if	O
(	O
mflags	int
&	O
TIOCM_DSR	int
)	O
s	pointer
++	O
;	O
while	O
(	O
*	O
s	pointer
)	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
s	pointer
=	O
"!CD "	pointer
;	O
if	O
(	O
softcar	int
)	O
{	O
*	O
p	pointer
++	O
=	O
'('	O
;	O
s	pointer
=	O
"!CD) "	pointer
;	O
}	O
if	O
(	O
mflags	int
&	O
TIOCM_CD	O
)	O
s	pointer
++	O
;	O
while	O
(	O
*	O
s	pointer
)	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
if	O
(	O
mflags	int
&	O
TIOCM_RI	O
)	O
for	O
(	O
s	pointer
=	O
"RI "	pointer
;	O
*	O
s	pointer
;	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
++	O
)	O
;	O
if	O
(	O
p	pointer
>	O
buf	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
' '	O
)	O
p	pointer
--	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
clocal	int
)	O
*	O
p	pointer
++	O
=	O
'}'	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
buf	pointer
;	O
}	O
static	O
struct	O
baud_values	struct
btable	array
[	O
]	O
=	O
{	O
{	O
33	int
,	O
4000000	int
,	O
B4000000	int
}	O
,	O
{	O
32	int
,	O
3500000	int
,	O
B3500000	int
}	O
,	O
{	O
31	int
,	O
3000000	int
,	O
B3000000	int
}	O
,	O
{	O
30	int
,	O
2500000	int
,	O
B2500000	int
}	O
,	O
{	O
29	int
,	O
2000000	int
,	O
B2000000	int
}	O
,	O
{	O
28	int
,	O
1500000	int
,	O
B1500000	int
}	O
,	O
{	O
27	int
,	O
1152000	int
,	O
B1152000	int
}	O
,	O
{	O
26	int
,	O
1000000	int
,	O
B1000000	int
}	O
,	O
{	O
25	int
,	O
921600	int
,	O
B921600	int
}	O
,	O
{	O
24	int
,	O
576000	int
,	O
B576000	int
}	O
,	O
{	O
23	int
,	O
500000	int
,	O
B500000	int
}	O
,	O
{	O
22	int
,	O
460800	int
,	O
B460800	int
}	O
,	O
{	O
21	int
,	O
230400	int
,	O
B230400	int
}	O
,	O
{	O
20	int
,	O
115200	int
,	O
B115200	int
}	O
,	O
{	O
19	int
,	O
57600	int
,	O
B57600	int
}	O
,	O
{	O
18	int
,	O
38400	int
,	O
EXTB	O
}	O
,	O
{	O
18	int
,	O
38400	int
,	O
B38400	int
}	O
,	O
{	O
17	int
,	O
19200	int
,	O
EXTA	O
}	O
,	O
{	O
17	int
,	O
19200	int
,	O
B19200	int
}	O
,	O
{	O
16	int
,	O
9600	int
,	O
B9600	int
}	O
,	O
{	O
14	int
,	O
4800	int
,	O
B4800	int
}	O
,	O
{	O
12	int
,	O
2400	int
,	O
B2400	int
}	O
,	O
{	O
11	int
,	O
1800	int
,	O
B1800	int
}	O
,	O
{	O
10	int
,	O
1200	int
,	O
B1200	int
}	O
,	O
{	O
8	int
,	O
600	int
,	O
B600	int
}	O
,	O
{	O
7	int
,	O
300	int
,	O
B300	int
}	O
,	O
{	O
6	int
,	O
200	int
,	O
B200	int
}	O
,	O
{	O
5	int
,	O
150	int
,	O
B150	int
}	O
,	O
{	O
4	int
,	O
134	int
,	O
B134	int
}	O
,	O
{	O
3	int
,	O
110	int
,	O
B110	int
}	O
,	O
{	O
2	int
,	O
75	int
,	O
B75	int
}	O
,	O
{	O
1	int
,	O
50	int
,	O
B50	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
B0	int
}	O
,	O
{	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
}	O
}	O
;	O
struct	O
baud_values	struct
*	O
lookup_baud	function
(	O
int	O
baud	int
)	O
{	O
struct	O
baud_values	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
btable	array
;	O
p	pointer
->	O
idx	int
>=	O
0	int
;	O
p	pointer
++	O
)	O
if	O
(	O
baud	int
==	O
p	pointer
->	O
bps	int
||	O
baud	int
==	O
p	pointer
->	O
sym	int
)	O
return	O
p	pointer
;	O
return	O
NULL	O
;	O
}	O
int	O
SetBaud	function
(	O
struct	O
mode	struct
*	O
m	union
,	O
int	O
ibaud	int
,	O
int	O
obaud	int
)	O
{	O
struct	O
baud_values	struct
*	O
ip	pointer
,	O
*	O
op	pointer
;	O
if	O
(	O
(	O
!	O
(	O
ip	pointer
=	O
lookup_baud	function
(	O
ibaud	int
)	O
)	O
&&	O
ibaud	int
!=	O
-	O
1	int
)	O
||	O
(	O
!	O
(	O
op	pointer
=	O
lookup_baud	function
(	O
obaud	int
)	O
)	O
&&	O
obaud	int
!=	O
-	O
1	int
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ip	pointer
)	O
cfsetispeed	function
(	O
&	O
m	union
->	O
tio	struct
,	O
ip	pointer
->	O
sym	int
)	O
;	O
if	O
(	O
op	pointer
)	O
cfsetospeed	function
(	O
&	O
m	union
->	O
tio	struct
,	O
op	pointer
->	O
sym	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
CheckTtyname	function
(	O
char	O
*	O
tty	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
char	O
realbuf	array
[	O
PATH_MAX	int
]	O
;	O
const	O
char	O
*	O
real	pointer
;	O
int	O
rc	int
;	O
real	pointer
=	O
realpath	function
(	O
tty	pointer
,	O
realbuf	array
)	O
;	O
if	O
(	O
!	O
real	pointer
)	O
return	O
-	O
1	int
;	O
realbuf	array
[	O
sizeof	O
(	O
realbuf	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
lstat	function
(	O
real	pointer
,	O
&	O
st	struct
)	O
||	O
!	O
S_ISCHR	O
(	O
st	struct
.	O
st_mode	int
)	O
||	O
(	O
st	struct
.	O
st_nlink	long
>	O
1	int
&&	O
strncmp	function
(	O
real	pointer
,	O
"/dev"	pointer
,	O
4	int
)	O
)	O
)	O
rc	int
=	O
-	O
1	int
;	O
else	O
rc	int
=	O
0	int
;	O
return	O
rc	int
;	O
}	O
