static	O
__inline__	O
void	O
print_hsc	function
(	O
hsc	struct
*	O
h	pointer
)	O
{	O
printf	function
(	O
" h=%d s=%d c=%d\n"	pointer
,	O
head	int
(	O
*	O
h	pointer
)	O
,	O
sector	int
(	O
*	O
h	pointer
)	O
,	O
cyl	char
(	O
*	O
h	pointer
)	O
)	O
;	O
}	O
static	O
void	O
set_offset	function
(	O
hsc	struct
*	O
h	pointer
,	O
int	O
offset	long
,	O
int	O
heads	short
,	O
int	O
sectors	short
)	O
{	O
int	O
head	int
,	O
sector	int
,	O
cyl	char
;	O
if	O
(	O
!	O
heads	short
||	O
!	O
sectors	short
)	O
head	int
=	O
sector	int
=	O
cyl	char
=	O
0	int
;	O
else	O
{	O
sector	int
=	O
offset	long
%	O
sectors	short
;	O
offset	long
=	O
offset	long
/	O
sectors	short
;	O
head	int
=	O
offset	long
%	O
heads	short
;	O
cyl	char
=	O
offset	long
/	O
heads	short
;	O
if	O
(	O
cyl	char
>	O
1023	int
)	O
cyl	char
=	O
1023	int
;	O
}	O
h	pointer
->	O
head	int
=	O
head	int
;	O
h	pointer
->	O
sector	int
=	O
(	O
(	O
sector	int
+	O
1	int
)	O
&	O
0x3f	int
)	O
|	O
(	O
(	O
cyl	char
&	O
0x300	int
)	O
>>	O
2	int
)	O
;	O
h	pointer
->	O
cyl	char
=	O
cyl	char
&	O
0xff	int
;	O
}	O
void	O
setBeginEnd	function
(	O
struct	O
partition	int
*	O
partTable	pointer
,	O
unsigned	O
int	O
begin	int
,	O
unsigned	O
int	O
end	pointer
,	O
unsigned	O
int	O
heads	short
,	O
unsigned	O
int	O
sectors	short
,	O
int	O
activate	int
,	O
int	O
type	enum
,	O
int	O
fat_bits	int
)	O
{	O
set_offset	function
(	O
&	O
partTable	pointer
->	O
start	array
,	O
begin	int
,	O
heads	short
,	O
sectors	short
)	O
;	O
set_offset	function
(	O
&	O
partTable	pointer
->	O
end	pointer
,	O
end	pointer
-	O
1	int
,	O
heads	short
,	O
sectors	short
)	O
;	O
set_dword	function
(	O
partTable	pointer
->	O
start_sect	array
,	O
begin	int
)	O
;	O
set_dword	function
(	O
partTable	pointer
->	O
nr_sects	array
,	O
end	pointer
-	O
begin	int
)	O
;	O
if	O
(	O
activate	int
)	O
partTable	pointer
->	O
boot_ind	O
=	O
0x80	int
;	O
else	O
partTable	pointer
->	O
boot_ind	O
=	O
0	int
;	O
if	O
(	O
!	O
type	enum
)	O
{	O
if	O
(	O
fat_bits	int
==	O
0	int
)	O
{	O
if	O
(	O
end	pointer
-	O
begin	int
<	O
4096	int
)	O
fat_bits	int
=	O
12	int
;	O
else	O
fat_bits	int
=	O
16	int
;	O
}	O
if	O
(	O
fat_bits	int
==	O
32	int
)	O
type	enum
=	O
0x0C	int
;	O
else	O
if	O
(	O
end	pointer
<	O
65536	int
)	O
{	O
if	O
(	O
fat_bits	int
==	O
12	int
)	O
type	enum
=	O
0x01	int
;	O
else	O
if	O
(	O
fat_bits	int
==	O
16	int
)	O
type	enum
=	O
0x04	int
;	O
}	O
else	O
if	O
(	O
end	pointer
<	O
sectors	short
*	O
heads	short
*	O
1024	int
)	O
type	enum
=	O
0x06	int
;	O
else	O
type	enum
=	O
0x0E	int
;	O
}	O
partTable	pointer
->	O
sys_ind	O
=	O
type	enum
;	O
}	O
int	O
consistencyCheck	function
(	O
struct	O
partition	int
*	O
partTable	pointer
,	O
int	O
doprint	int
,	O
int	O
verbose	int
,	O
int	O
*	O
has_activated	pointer
,	O
unsigned	O
int	O
*	O
last_end	pointer
,	O
unsigned	O
int	O
*	O
j	pointer
,	O
struct	O
device	struct
*	O
used_dev	pointer
,	O
int	O
target_partition	int
)	O
{	O
int	O
i	int
;	O
unsigned	O
int	O
inconsistency	int
;	O
*	O
j	pointer
=	O
0	int
;	O
*	O
last_end	pointer
=	O
1	int
;	O
inconsistency	int
=	O
0	int
;	O
*	O
has_activated	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
partTable	pointer
[	O
i	int
]	O
.	O
sys_ind	O
)	O
continue	O
;	O
if	O
(	O
partTable	pointer
[	O
i	int
]	O
.	O
boot_ind	O
)	O
(	O
*	O
has_activated	pointer
)	O
++	O
;	O
if	O
(	O
(	O
used_dev	pointer
&&	O
(	O
used_dev	pointer
->	O
heads	short
!=	O
head	int
(	O
partTable	pointer
[	O
i	int
]	O
.	O
end	pointer
)	O
+	O
1	int
||	O
used_dev	pointer
->	O
sectors	short
!=	O
sector	int
(	O
partTable	pointer
[	O
i	int
]	O
.	O
end	pointer
)	O
)	O
)	O
||	O
sector	int
(	O
partTable	pointer
[	O
i	int
]	O
.	O
start	array
)	O
!=	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Partition %d is not aligned\n"	pointer
,	O
i	int
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
if	O
(	O
*	O
j	pointer
&&	O
*	O
last_end	pointer
>	O
BEGIN	O
(	O
partTable	pointer
[	O
i	int
]	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Partitions %d and %d badly ordered or overlapping\n"	pointer
,	O
*	O
j	pointer
,	O
i	int
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
*	O
last_end	pointer
=	O
END	O
(	O
partTable	pointer
[	O
i	int
]	O
)	O
;	O
*	O
j	pointer
=	O
i	int
;	O
if	O
(	O
used_dev	pointer
&&	O
cyl	char
(	O
partTable	pointer
[	O
i	int
]	O
.	O
start	array
)	O
!=	O
1023	int
&&	O
tolinear	O
(	O
partTable	pointer
[	O
i	int
]	O
.	O
start	array
)	O
!=	O
BEGIN	O
(	O
partTable	pointer
[	O
i	int
]	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Start position mismatch for partition %d\n"	pointer
,	O
i	int
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
if	O
(	O
used_dev	pointer
&&	O
cyl	char
(	O
partTable	pointer
[	O
i	int
]	O
.	O
end	pointer
)	O
!=	O
1023	int
&&	O
tolinear	O
(	O
partTable	pointer
[	O
i	int
]	O
.	O
end	pointer
)	O
+	O
1	int
!=	O
END	O
(	O
partTable	pointer
[	O
i	int
]	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"End position mismatch for partition %d\n"	pointer
,	O
i	int
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
if	O
(	O
doprint	int
&&	O
verbose	int
)	O
{	O
if	O
(	O
i	int
==	O
target_partition	int
)	O
putchar	function
(	O
'*'	O
)	O
;	O
else	O
putchar	function
(	O
' '	O
)	O
;	O
printf	function
(	O
"Partition %d\n"	pointer
,	O
i	int
)	O
;	O
printf	function
(	O
"  active=%x\n"	pointer
,	O
partTable	pointer
[	O
i	int
]	O
.	O
boot_ind	O
)	O
;	O
printf	function
(	O
"  start:"	pointer
)	O
;	O
print_hsc	function
(	O
&	O
partTable	pointer
[	O
i	int
]	O
.	O
start	array
)	O
;	O
printf	function
(	O
"  type=0x%x\n"	pointer
,	O
partTable	pointer
[	O
i	int
]	O
.	O
sys_ind	O
)	O
;	O
printf	function
(	O
"  end:"	pointer
)	O
;	O
print_hsc	function
(	O
&	O
partTable	pointer
[	O
i	int
]	O
.	O
end	pointer
)	O
;	O
printf	function
(	O
"  start=%d\n"	pointer
,	O
BEGIN	O
(	O
partTable	pointer
[	O
i	int
]	O
)	O
)	O
;	O
printf	function
(	O
"  nr=%d\n"	pointer
,	O
_DWORD	O
(	O
partTable	pointer
[	O
i	int
]	O
.	O
nr_sects	array
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
return	O
inconsistency	int
;	O
}	O
static	O
int	O
setsize	function
(	O
unsigned	O
long	O
capacity	long
,	O
unsigned	O
int	O
*	O
cyls	short
,	O
uint16_t	short
*	O
hds	pointer
,	O
uint16_t	short
*	O
secs	pointer
)	O
{	O
unsigned	O
int	O
rv	int
=	O
0	int
;	O
unsigned	O
long	O
heads	short
,	O
sectors	short
,	O
cylinders	short
,	O
temp	long
;	O
cylinders	short
=	O
1024L	int
;	O
sectors	short
=	O
62L	int
;	O
temp	long
=	O
cylinders	short
*	O
sectors	short
;	O
heads	short
=	O
capacity	long
/	O
temp	long
;	O
if	O
(	O
capacity	long
%	O
temp	long
)	O
{	O
heads	short
++	O
;	O
temp	long
=	O
cylinders	short
*	O
heads	short
;	O
sectors	short
=	O
capacity	long
/	O
temp	long
;	O
if	O
(	O
capacity	long
%	O
temp	long
)	O
{	O
sectors	short
++	O
;	O
temp	long
=	O
heads	short
*	O
sectors	short
;	O
cylinders	short
=	O
capacity	long
/	O
temp	long
;	O
}	O
}	O
if	O
(	O
cylinders	short
==	O
0	int
)	O
rv	int
=	O
(	O
unsigned	O
)	O
-	O
1	int
;	O
*	O
cyls	short
=	O
(	O
unsigned	O
int	O
)	O
cylinders	short
;	O
*	O
secs	pointer
=	O
(	O
unsigned	O
int	O
)	O
sectors	short
;	O
*	O
hds	pointer
=	O
(	O
unsigned	O
int	O
)	O
heads	short
;	O
return	O
(	O
rv	int
)	O
;	O
}	O
static	O
void	O
setsize0	function
(	O
unsigned	O
long	O
capacity	long
,	O
unsigned	O
int	O
*	O
cyls	short
,	O
uint16_t	short
*	O
hds	pointer
,	O
uint16_t	short
*	O
secs	pointer
)	O
{	O
int	O
r	int
;	O
if	O
(	O
capacity	long
<	O
1024	int
*	O
2048	int
&&	O
!	O
(	O
capacity	long
%	O
1024	int
)	O
)	O
{	O
*	O
cyls	short
=	O
capacity	long
>>	O
11	int
;	O
*	O
hds	pointer
=	O
64	int
;	O
*	O
secs	pointer
=	O
32	int
;	O
return	O
;	O
}	O
r	int
=	O
setsize	function
(	O
capacity	long
,	O
cyls	short
,	O
hds	pointer
,	O
secs	pointer
)	O
;	O
if	O
(	O
r	int
||	O
*	O
hds	pointer
>	O
255	int
||	O
*	O
secs	pointer
>	O
63	int
)	O
{	O
*	O
cyls	short
=	O
capacity	long
>>	O
11	int
;	O
*	O
hds	pointer
=	O
64	int
;	O
*	O
secs	pointer
=	O
32	int
;	O
return	O
;	O
}	O
}	O
static	O
void	O
usage	function
(	O
int	O
ret	int
)	O
NORETURN	O
;	O
static	O
void	O
usage	function
(	O
int	O
ret	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Mtools version %s, dated %s\n"	pointer
,	O
mversion	pointer
,	O
mdate	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s [-pradcv] [-I] [-B bootsect-template] [-s sectors] "	pointer
"[-t cylinders] "	pointer
"[-h heads] [-T type] [-b begin] [-l length] "	pointer
"drive\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	function
(	O
ret	int
)	O
;	O
}	O
void	O
mpartition	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
dummy	array
UNUSEDP	O
)	O
NORETURN	O
;	O
void	O
mpartition	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
dummy	array
UNUSEDP	O
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
;	O
unsigned	O
int	O
dummy2	int
;	O
unsigned	O
int	O
i	int
,	O
j	pointer
;	O
int	O
sec_per_cyl	int
;	O
int	O
doprint	int
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
int	O
create	int
=	O
0	int
;	O
int	O
force	int
=	O
0	int
;	O
unsigned	O
int	O
length	int
=	O
0	int
;	O
int	O
do_remove	int
=	O
0	int
;	O
int	O
initialize	int
=	O
0	int
;	O
unsigned	O
int	O
tot_sectors	long
=	O
0	int
;	O
int	O
type	enum
=	O
0	int
;	O
int	O
begin_set	int
=	O
0	int
;	O
int	O
size_set	int
=	O
0	int
;	O
int	O
end_set	int
=	O
0	int
;	O
unsigned	O
int	O
last_end	pointer
=	O
0	int
;	O
int	O
activate	int
=	O
0	int
;	O
int	O
has_activated	pointer
=	O
0	int
;	O
int	O
inconsistency	int
=	O
0	int
;	O
unsigned	O
int	O
begin	int
=	O
0	int
;	O
unsigned	O
int	O
end	pointer
=	O
0	int
;	O
int	O
sizetest	int
=	O
0	int
;	O
int	O
dirty	int
=	O
0	int
;	O
int	O
open2flags	int
=	O
NO_OFFSET	int
;	O
int	O
c	char
;	O
struct	O
device	struct
used_dev	pointer
;	O
int	O
argtracks	int
,	O
argheads	int
,	O
argsectors	int
;	O
char	O
drive	char
,	O
name	pointer
[	O
EXPAND_BUF	int
]	O
;	O
unsigned	O
char	O
buf	pointer
[	O
512	int
]	O
;	O
struct	O
partition	int
*	O
partTable	pointer
=	O
(	O
struct	O
partition	int
*	O
)	O
(	O
buf	pointer
+	O
0x1ae	int
)	O
;	O
struct	O
device	struct
*	O
dev	pointer
;	O
char	O
errmsg	pointer
[	O
2100	int
]	O
;	O
char	O
*	O
bootSector	pointer
=	O
0	int
;	O
argtracks	int
=	O
0	int
;	O
argheads	int
=	O
0	int
;	O
argsectors	int
=	O
0	int
;	O
if	O
(	O
helpFlag	function
(	O
argc	int
,	O
argv	pointer
)	O
)	O
usage	function
(	O
0	int
)	O
;	O
while	O
(	O
(	O
c	char
=	O
getopt	function
(	O
argc	int
,	O
argv	pointer
,	O
"i:adprcIT:t:h:s:fvpb:l:S:B:"	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	char
)	O
{	O
case	O
'i'	O
:	O
set_cmd_line_image	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
bootSector	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'a'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
activate	int
=	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
activate	int
=	O
-	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
doprint	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
do_remove	int
=	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'I'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
initialize	int
=	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
create	int
=	O
1	int
;	O
dirty	int
=	O
1	int
;	O
break	O
;	O
case	O
'T'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
type	enum
=	O
strtoi	function
(	O
optarg	pointer
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
argtracks	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
argheads	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
argsectors	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
force	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'S'	O
:	O
open2flags	int
|=	O
NO_PRIV	int
;	O
tot_sectors	long
=	O
strtoui	function
(	O
optarg	pointer
,	O
0	int
,	O
0	int
)	O
;	O
sizetest	int
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
begin_set	int
=	O
1	int
;	O
begin	int
=	O
strtoui	function
(	O
optarg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
size_set	int
=	O
1	int
;	O
length	int
=	O
strtoui	function
(	O
optarg	pointer
,	O
NULL	O
,	O
10	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
argc	int
-	O
optind	int
!=	O
1	int
||	O
!	O
argv	pointer
[	O
optind	int
]	O
[	O
0	int
]	O
||	O
argv	pointer
[	O
optind	int
]	O
[	O
1	int
]	O
!=	O
':'	O
)	O
usage	function
(	O
1	int
)	O
;	O
drive	char
=	O
ch_toupper	function
(	O
argv	pointer
[	O
optind	int
]	O
[	O
0	int
]	O
)	O
;	O
sprintf	function
(	O
errmsg	pointer
,	O
"Drive '%c:' not supported"	pointer
,	O
drive	char
)	O
;	O
Stream	pointer
=	O
0	int
;	O
for	O
(	O
dev	pointer
=	O
devices	pointer
;	O
dev	pointer
->	O
drive	char
;	O
dev	pointer
++	O
)	O
{	O
int	O
mode	int
;	O
FREE	O
(	O
&	O
(	O
Stream	pointer
)	O
)	O
;	O
if	O
(	O
dev	pointer
->	O
drive	char
!=	O
drive	char
)	O
continue	O
;	O
if	O
(	O
dev	pointer
->	O
partition	int
<	O
1	int
||	O
dev	pointer
->	O
partition	int
>	O
4	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Drive '%c:' is not a partition"	pointer
,	O
drive	char
)	O
;	O
continue	O
;	O
}	O
used_dev	pointer
=	O
*	O
dev	pointer
;	O
SET_INT	O
(	O
used_dev	pointer
.	O
tracks	int
,	O
argtracks	int
)	O
;	O
SET_INT	O
(	O
used_dev	pointer
.	O
heads	short
,	O
argheads	int
)	O
;	O
SET_INT	O
(	O
used_dev	pointer
.	O
sectors	short
,	O
argsectors	int
)	O
;	O
expand	function
(	O
dev	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
mode	int
=	O
dirty	int
?	O
O_RDWR	int
:	O
O_RDONLY	int
;	O
if	O
(	O
initialize	int
)	O
mode	int
|=	O
O_CREAT	int
;	O
Stream	pointer
=	O
SimpleFileOpen	function
(	O
&	O
used_dev	pointer
,	O
dev	pointer
,	O
name	pointer
,	O
mode	int
,	O
errmsg	pointer
,	O
open2flags	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
Stream	pointer
)	O
{	O
snprintf	function
(	O
errmsg	pointer
,	O
sizeof	O
(	O
errmsg	pointer
)	O
-	O
1	int
,	O
"init: open: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
sizetest	int
)	O
tot_sectors	long
=	O
0	int
;	O
if	O
(	O
IS_SCSI	O
(	O
dev	pointer
)	O
)	O
{	O
unsigned	O
char	O
cmd	array
[	O
10	int
]	O
;	O
unsigned	O
char	O
data	pointer
[	O
10	int
]	O
;	O
cmd	array
[	O
0	int
]	O
=	O
SCSI_READ_CAPACITY	int
;	O
memset	function
(	O
(	O
void	O
*	O
)	O
&	O
cmd	array
[	O
2	int
]	O
,	O
0	int
,	O
8	int
)	O
;	O
memset	function
(	O
(	O
void	O
*	O
)	O
&	O
data	pointer
[	O
0	int
]	O
,	O
137	int
,	O
10	int
)	O
;	O
scsi_cmd	function
(	O
get_fd	function
(	O
Stream	pointer
)	O
,	O
cmd	array
,	O
10	int
,	O
SCSI_IO_READ	int
,	O
data	pointer
,	O
10	int
,	O
get_extra_data	function
(	O
Stream	pointer
)	O
)	O
;	O
tot_sectors	long
=	O
1	int
+	O
(	O
data	pointer
[	O
0	int
]	O
<<	O
24	int
)	O
+	O
(	O
data	pointer
[	O
1	int
]	O
<<	O
16	int
)	O
+	O
(	O
data	pointer
[	O
2	int
]	O
<<	O
8	int
)	O
+	O
(	O
data	pointer
[	O
3	int
]	O
)	O
;	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"%d sectors in total\n"	pointer
,	O
tot_sectors	long
)	O
;	O
}	O
if	O
(	O
tot_sectors	long
==	O
0	int
)	O
{	O
ioctl	function
(	O
get_fd	function
(	O
Stream	pointer
)	O
,	O
BLKGETSIZE	O
,	O
&	O
tot_sectors	long
)	O
;	O
}	O
if	O
(	O
READS	O
(	O
Stream	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
0	int
,	O
512	int
)	O
!=	O
512	int
&&	O
!	O
initialize	int
)	O
{	O
snprintf	function
(	O
errmsg	pointer
,	O
sizeof	O
(	O
errmsg	pointer
)	O
-	O
1	int
,	O
"Error reading from '%s', wrong parameters?"	pointer
,	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
verbose	int
>=	O
2	int
)	O
print_sector	function
(	O
"Read sector"	pointer
,	O
buf	pointer
,	O
512	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
dev	pointer
->	O
drive	char
==	O
0	int
)	O
{	O
FREE	O
(	O
&	O
Stream	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
errmsg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
used_dev	pointer
.	O
sectors	short
||	O
used_dev	pointer
.	O
heads	short
)	O
&&	O
(	O
!	O
used_dev	pointer
.	O
sectors	short
||	O
!	O
used_dev	pointer
.	O
heads	short
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"You should either indicate both the number of sectors and the number of heads,\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" or none of them\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
initialize	int
)	O
{	O
if	O
(	O
bootSector	pointer
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
open	function
(	O
bootSector	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
|	O
O_LARGEFILE	O
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
perror	function
(	O
"open MBR"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
read	pointer
(	O
fd	int
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
512	int
)	O
<	O
512	int
)	O
{	O
perror	function
(	O
"read MBR"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
memset	function
(	O
(	O
char	O
*	O
)	O
(	O
partTable	pointer
+	O
1	int
)	O
,	O
0	int
,	O
4	int
*	O
sizeof	O
(	O
*	O
partTable	pointer
)	O
)	O
;	O
set_word	function
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
)	O
+	O
510	int
,	O
0xaa55	int
)	O
;	O
}	O
if	O
(	O
(	O
buf	pointer
[	O
510	int
]	O
!=	O
0x55	int
)	O
||	O
(	O
buf	pointer
[	O
511	int
]	O
!=	O
0xaa	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Boot signature not set\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Use the -I flag to initialize the partition table, and set the boot signature\n"	pointer
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
if	O
(	O
do_remove	int
)	O
{	O
if	O
(	O
!	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
.	O
sys_ind	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Partition for drive %c: does not exist\n"	pointer
,	O
drive	char
)	O
;	O
if	O
(	O
(	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
.	O
sys_ind	O
&	O
0x3f	int
)	O
==	O
5	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Partition for drive %c: may be an extended partition\n"	pointer
,	O
drive	char
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Use the -f flag to remove it anyways\n"	pointer
)	O
;	O
inconsistency	int
=	O
1	int
;	O
}	O
memset	function
(	O
&	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
*	O
partTable	pointer
)	O
)	O
;	O
}	O
if	O
(	O
create	int
&&	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
.	O
sys_ind	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Partition for drive %c: already exists\n"	pointer
,	O
drive	char
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Use the -r flag to remove it before attempting to recreate it\n"	pointer
)	O
;	O
}	O
has_activated	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
partTable	pointer
[	O
i	int
]	O
.	O
sys_ind	O
)	O
continue	O
;	O
if	O
(	O
partTable	pointer
[	O
i	int
]	O
.	O
boot_ind	O
)	O
has_activated	pointer
++	O
;	O
if	O
(	O
!	O
used_dev	pointer
.	O
heads	short
)	O
used_dev	pointer
.	O
heads	short
=	O
head	int
(	O
partTable	pointer
[	O
i	int
]	O
.	O
end	pointer
)	O
+	O
1	int
;	O
if	O
(	O
!	O
used_dev	pointer
.	O
sectors	short
)	O
used_dev	pointer
.	O
sectors	short
=	O
sector	int
(	O
partTable	pointer
[	O
i	int
]	O
.	O
end	pointer
)	O
;	O
if	O
(	O
i	int
<	O
dev	pointer
->	O
partition	int
&&	O
!	O
begin_set	int
)	O
begin	int
=	O
END	O
(	O
partTable	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
i	int
>	O
dev	pointer
->	O
partition	int
&&	O
!	O
end_set	int
&&	O
!	O
size_set	int
)	O
{	O
end	pointer
=	O
BEGIN	O
(	O
partTable	pointer
[	O
i	int
]	O
)	O
;	O
end_set	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
used_dev	pointer
.	O
sectors	short
&&	O
!	O
used_dev	pointer
.	O
heads	short
)	O
{	O
if	O
(	O
!	O
IS_SCSI	O
(	O
dev	pointer
)	O
)	O
{	O
struct	O
hd_geometry	struct
geom	struct
;	O
if	O
(	O
ioctl	function
(	O
get_fd	function
(	O
Stream	pointer
)	O
,	O
HDIO_GETGEO	int
,	O
&	O
geom	struct
)	O
==	O
0	int
)	O
{	O
used_dev	pointer
.	O
heads	short
=	O
geom	struct
.	O
heads	short
;	O
used_dev	pointer
.	O
sectors	short
=	O
geom	struct
.	O
sectors	short
;	O
}	O
}	O
}	O
if	O
(	O
!	O
used_dev	pointer
.	O
sectors	short
&&	O
!	O
used_dev	pointer
.	O
heads	short
)	O
{	O
if	O
(	O
tot_sectors	long
)	O
setsize0	function
(	O
tot_sectors	long
,	O
&	O
dummy2	int
,	O
&	O
used_dev	pointer
.	O
heads	short
,	O
&	O
used_dev	pointer
.	O
sectors	short
)	O
;	O
else	O
{	O
used_dev	pointer
.	O
heads	short
=	O
64	int
;	O
used_dev	pointer
.	O
sectors	short
=	O
32	int
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"sectors: %d heads: %d %d\n"	pointer
,	O
used_dev	pointer
.	O
sectors	short
,	O
used_dev	pointer
.	O
heads	short
,	O
tot_sectors	long
)	O
;	O
sec_per_cyl	int
=	O
used_dev	pointer
.	O
sectors	short
*	O
used_dev	pointer
.	O
heads	short
;	O
if	O
(	O
create	int
)	O
{	O
if	O
(	O
!	O
end_set	int
&&	O
tot_sectors	long
)	O
{	O
end	pointer
=	O
tot_sectors	long
-	O
tot_sectors	long
%	O
sec_per_cyl	int
;	O
end_set	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
begin	int
&&	O
!	O
begin_set	int
)	O
begin	int
=	O
used_dev	pointer
.	O
sectors	short
;	O
if	O
(	O
!	O
size_set	int
&&	O
used_dev	pointer
.	O
tracks	int
)	O
{	O
size_set	int
=	O
2	int
;	O
length	int
=	O
sec_per_cyl	int
*	O
used_dev	pointer
.	O
tracks	int
;	O
if	O
(	O
begin_set	int
||	O
dev	pointer
->	O
partition	int
<=	O
2	int
||	O
!	O
end_set	int
)	O
length	int
-=	O
begin	int
%	O
sec_per_cyl	int
;	O
else	O
if	O
(	O
end	pointer
-	O
length	int
<	O
begin	int
)	O
length	int
=	O
end	pointer
-	O
begin	int
;	O
}	O
if	O
(	O
size_set	int
)	O
{	O
if	O
(	O
!	O
begin_set	int
&&	O
dev	pointer
->	O
partition	int
>	O
2	int
&&	O
end_set	int
)	O
begin	int
=	O
end	pointer
-	O
length	int
;	O
else	O
end	pointer
=	O
begin	int
+	O
length	int
;	O
}	O
else	O
if	O
(	O
!	O
end_set	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unknown size\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
setBeginEnd	function
(	O
&	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
,	O
begin	int
,	O
end	pointer
,	O
used_dev	pointer
.	O
heads	short
,	O
used_dev	pointer
.	O
sectors	short
,	O
!	O
has_activated	pointer
,	O
type	enum
,	O
dev	pointer
->	O
fat_bits	int
)	O
;	O
}	O
if	O
(	O
activate	int
)	O
{	O
if	O
(	O
!	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
.	O
sys_ind	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Partition for drive %c: does not exist\n"	pointer
,	O
drive	char
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
activate	int
)	O
{	O
case	O
1	int
:	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
.	O
boot_ind	O
=	O
0x80	int
;	O
break	O
;	O
case	O
-	O
1	int
:	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
.	O
boot_ind	O
=	O
0x00	int
;	O
break	O
;	O
}	O
}	O
}	O
inconsistency	int
|=	O
consistencyCheck	function
(	O
partTable	pointer
,	O
doprint	int
,	O
verbose	int
,	O
&	O
has_activated	pointer
,	O
&	O
last_end	pointer
,	O
&	O
j	pointer
,	O
&	O
used_dev	pointer
,	O
dev	pointer
->	O
partition	int
)	O
;	O
if	O
(	O
doprint	int
&&	O
!	O
inconsistency	int
&&	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
.	O
sys_ind	O
)	O
{	O
printf	function
(	O
"The following command will recreate the partition for drive %c:\n"	pointer
,	O
drive	char
)	O
;	O
used_dev	pointer
.	O
tracks	int
=	O
(	O
_DWORD	O
(	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
.	O
nr_sects	array
)	O
+	O
(	O
BEGIN	O
(	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
)	O
%	O
sec_per_cyl	int
)	O
)	O
/	O
sec_per_cyl	int
;	O
printf	function
(	O
"mpartition -c -t %d -h %d -s %d -b %u %c:\n"	pointer
,	O
used_dev	pointer
.	O
tracks	int
,	O
used_dev	pointer
.	O
heads	short
,	O
used_dev	pointer
.	O
sectors	short
,	O
BEGIN	O
(	O
partTable	pointer
[	O
dev	pointer
->	O
partition	int
]	O
)	O
,	O
drive	char
)	O
;	O
}	O
if	O
(	O
tot_sectors	long
&&	O
last_end	pointer
>	O
tot_sectors	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Partition %d exceeds beyond end of disk\n"	pointer
,	O
j	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
switch	O
(	O
has_activated	pointer
)	O
{	O
case	O
0	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: no active (bootable) partition present\n"	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: %d active (bootable) partitions present\n"	pointer
,	O
has_activated	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Usually, a disk should have exactly one active partition\n"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
inconsistency	int
&&	O
!	O
force	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"inconsistency detected!\n"	pointer
)	O
;	O
if	O
(	O
dirty	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Retry with the -f switch to go ahead anyways\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dirty	int
)	O
{	O
if	O
(	O
verbose	int
>=	O
2	int
)	O
print_sector	function
(	O
"Writing sector"	pointer
,	O
buf	pointer
,	O
512	int
)	O
;	O
if	O
(	O
WRITES	O
(	O
Stream	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
0	int
,	O
512	int
)	O
!=	O
512	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error writing partition table"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
verbose	int
>=	O
3	int
)	O
print_sector	function
(	O
"Sector written"	pointer
,	O
buf	pointer
,	O
512	int
)	O
;	O
}	O
FREE	O
(	O
&	O
Stream	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
