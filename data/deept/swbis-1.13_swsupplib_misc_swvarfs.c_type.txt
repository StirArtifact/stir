static	O
int	O
show_nopen	function
(	O
void	O
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"fcntl error: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	pointer
(	O
ret	int
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
ud_init	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
u_fd_array_len	O
(	O
swvarfs	pointer
)	O
;	O
i	int
++	O
)	O
{	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
i	int
]	O
.	O
u_fdM	int
=	O
-	O
1	int
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
i	int
]	O
.	O
u_current_name_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
i	int
]	O
.	O
u_linkname_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
}	O
static	O
int	O
ud_set_fd	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
u_fd_array_len	O
(	O
swvarfs	pointer
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
i	int
]	O
.	O
u_fdM	int
<	O
0	int
)	O
{	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
i	int
]	O
.	O
u_fdM	int
=	O
fd	int
;	O
return	O
fd	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
ud_unset_fd	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
u_fd_array_len	O
(	O
swvarfs	pointer
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
i	int
]	O
.	O
u_fdM	int
==	O
fd	int
)	O
{	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
i	int
]	O
.	O
u_fdM	int
=	O
-	O
1	int
;	O
return	O
fd	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
ud_find_fd	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
u_fd_array_len	O
(	O
swvarfs	pointer
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
i	int
]	O
.	O
u_fdM	int
==	O
fd	int
)	O
{	O
return	O
i	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
u_reject	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
swvarfs	pointer
->	O
current_filechainM	pointer
=	O
NULL	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
}	O
static	O
int	O
is_name_a_path_prefix	function
(	O
char	O
*	O
npath	pointer
,	O
char	O
*	O
nprefix	pointer
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
trl	pointer
=	O
NULL	O
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
path	pointer
;	O
char	O
*	O
prefix	pointer
;	O
if	O
(	O
strcmp	function
(	O
nprefix	pointer
,	O
"."	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
nprefix	pointer
,	O
"./"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
nprefix	pointer
||	O
*	O
nprefix	pointer
==	O
'\0'	O
)	O
return	O
0	int
;	O
if	O
(	O
nprefix	pointer
[	O
strlen	function
(	O
nprefix	pointer
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
{	O
trl	pointer
=	O
nprefix	pointer
+	O
(	O
strlen	function
(	O
nprefix	pointer
)	O
-	O
1	int
)	O
;	O
*	O
trl	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
strncmp	function
(	O
npath	pointer
,	O
"./"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
path	pointer
=	O
npath	pointer
+	O
2	int
;	O
}	O
else	O
{	O
path	pointer
=	O
npath	pointer
;	O
}	O
if	O
(	O
strncmp	function
(	O
nprefix	pointer
,	O
"./"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
prefix	pointer
=	O
nprefix	pointer
+	O
2	int
;	O
}	O
else	O
{	O
prefix	pointer
=	O
nprefix	pointer
;	O
}	O
if	O
(	O
strlen	function
(	O
prefix	pointer
)	O
==	O
0	int
||	O
strlen	function
(	O
path	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
path	pointer
,	O
prefix	pointer
)	O
==	O
0	int
)	O
{	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
s	pointer
=	O
strstr	function
(	O
path	pointer
,	O
prefix	pointer
)	O
)	O
&&	O
s	pointer
==	O
path	pointer
&&	O
(	O
strlen	function
(	O
path	pointer
)	O
==	O
strlen	function
(	O
prefix	pointer
)	O
||	O
path	pointer
[	O
strlen	function
(	O
prefix	pointer
)	O
]	O
==	O
'/'	O
)	O
)	O
{	O
ret	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
trl	pointer
)	O
*	O
trl	pointer
=	O
'/'	O
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
handle_leading_slash	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
mode	int
,	O
char	O
*	O
name	pointer
,	O
int	O
*	O
pflag	pointer
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
!=	O
UINFILE_FILESYSTEM	int
&&	O
swvarfs	pointer
->	O
has_leading_slashM	int
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
mode	int
,	O
"drop"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
name	pointer
==	O
'/'	O
)	O
{	O
memmove	function
(	O
name	pointer
,	O
name	pointer
+	O
1	int
,	O
strlen	function
(	O
name	pointer
)	O
)	O
;	O
*	O
pflag	pointer
=	O
1	int
;	O
}	O
else	O
{	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
mode	int
,	O
"restore"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
pflag	pointer
)	O
{	O
memmove	function
(	O
name	pointer
+	O
1	int
,	O
name	pointer
,	O
strlen	function
(	O
name	pointer
)	O
)	O
;	O
*	O
name	pointer
=	O
'/'	O
;	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
static	O
void	O
handle_trailing_slash	function
(	O
char	O
*	O
mode	int
,	O
char	O
*	O
name	pointer
,	O
int	O
*	O
pflag	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
mode	int
,	O
"drop"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
name	pointer
[	O
strlen	function
(	O
name	pointer
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
{	O
name	pointer
[	O
strlen	function
(	O
name	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
*	O
pflag	pointer
=	O
1	int
;	O
}	O
else	O
{	O
*	O
pflag	pointer
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
pflag	pointer
)	O
{	O
name	pointer
[	O
strlen	function
(	O
name	pointer
)	O
]	O
=	O
'/'	O
;	O
}	O
}	O
}	O
static	O
int	O
filename_does_match	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
candidate	pointer
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
swlib_compare_8859	function
(	O
name	pointer
,	O
candidate	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
is_name_in_scope	function
(	O
char	O
*	O
dirscope	pointer
,	O
char	O
*	O
name	pointer
,	O
struct	O
stat	struct
*	O
namest	pointer
)	O
{	O
int	O
ret	int
;	O
char	O
*	O
s	pointer
,	O
*	O
name1	pointer
;	O
if	O
(	O
strlen	function
(	O
dirscope	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
dirscope	pointer
,	O
"/"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
s	pointer
=	O
strstr	function
(	O
name	pointer
,	O
"./"	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
s	pointer
==	O
name	pointer
&&	O
strlen	function
(	O
name	pointer
)	O
>	O
2	int
)	O
{	O
name1	pointer
=	O
name	pointer
+	O
2	int
;	O
}	O
else	O
{	O
name1	pointer
=	O
name	pointer
;	O
}	O
if	O
(	O
strlen	function
(	O
name1	pointer
)	O
+	O
4	int
<	O
strlen	function
(	O
dirscope	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
s	pointer
=	O
strstr	function
(	O
dirscope	pointer
,	O
name1	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
strlen	function
(	O
name1	pointer
)	O
>=	O
strlen	function
(	O
dirscope	pointer
)	O
-	O
2	int
)	O
{	O
if	O
(	O
namest	pointer
!=	O
NULL	O
&&	O
S_ISDIR	O
(	O
namest	pointer
->	O
st_mode	int
)	O
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
{	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
STROB	struct
*	O
tmp1	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
dirscope	pointer
)	O
;	O
strob_strcpy	function
(	O
tmp1	pointer
,	O
name1	pointer
)	O
;	O
if	O
(	O
!	O
strstr	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
"/*"	pointer
)	O
)	O
{	O
strob_strcat	function
(	O
tmp	pointer
,	O
"/*"	pointer
)	O
;	O
}	O
strob_strcpy	function
(	O
tmp1	pointer
,	O
name1	pointer
)	O
;	O
if	O
(	O
strstr	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
"./"	pointer
)	O
==	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
{	O
strob_strcpy	function
(	O
tmp1	pointer
,	O
"./"	pointer
)	O
;	O
strob_strcat	function
(	O
tmp1	pointer
,	O
name1	pointer
)	O
;	O
}	O
ret	int
=	O
fnmatch	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
strob_str	function
(	O
tmp1	pointer
)	O
,	O
0	int
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
tmp1	pointer
)	O
;	O
}	O
return	O
!	O
ret	int
;	O
}	O
static	O
void	O
process_vcwd	function
(	O
STRAR	struct
*	O
pathcomps	pointer
,	O
char	O
*	O
source	pointer
)	O
{	O
char	O
*	O
s	pointer
,	O
*	O
pc	pointer
;	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
strstr	function
(	O
source	pointer
,	O
"//"	pointer
)	O
==	O
source	pointer
)	O
{	O
strar_add	function
(	O
pathcomps	pointer
,	O
source	pointer
)	O
;	O
*	O
(	O
source	pointer
+	O
1	int
)	O
=	O
'\0'	O
;	O
s	pointer
=	O
source	pointer
+	O
2	int
;	O
}	O
else	O
{	O
s	pointer
=	O
source	pointer
;	O
}	O
pc	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
s	pointer
,	O
"/"	pointer
)	O
;	O
while	O
(	O
pc	pointer
)	O
{	O
strar_add	function
(	O
pathcomps	pointer
,	O
pc	pointer
)	O
;	O
pc	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
"/"	pointer
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
;	O
}	O
static	O
int	O
construct_new_path_from_pathspec	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
STROB	struct
*	O
newvcwd	pointer
,	O
char	O
*	O
pathspec	pointer
)	O
{	O
STRAR	struct
*	O
pathcomps	pointer
;	O
STRAR	struct
*	O
cmdcomps	pointer
;	O
char	O
*	O
sx	pointer
;	O
char	O
*	O
cx	pointer
;	O
int	O
ncomp	int
;	O
int	O
i	int
=	O
0	int
;	O
int	O
j	int
=	O
0	int
;	O
int	O
ret	int
=	O
0	int
;	O
strob_strcpy	function
(	O
newvcwd	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
*	O
pathspec	pointer
==	O
'/'	O
)	O
{	O
if	O
(	O
strstr	function
(	O
pathspec	pointer
,	O
".."	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strstr	function
(	O
pathspec	pointer
,	O
"./"	pointer
)	O
)	O
return	O
-	O
1	int
;	O
strob_strcpy	function
(	O
newvcwd	pointer
,	O
pathspec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
pathcomps	pointer
=	O
strar_open	function
(	O
)	O
;	O
cmdcomps	pointer
=	O
strar_open	function
(	O
)	O
;	O
sx	pointer
=	O
malloc	function
(	O
strob_strlen	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
)	O
+	O
2	int
)	O
;	O
if	O
(	O
sx	pointer
==	O
NULL	O
)	O
exit	function
(	O
31	int
)	O
;	O
if	O
(	O
*	O
strob_str	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
)	O
==	O
'/'	O
)	O
{	O
strcpy	function
(	O
sx	pointer
,	O
"/"	pointer
)	O
;	O
}	O
else	O
{	O
strcpy	function
(	O
sx	pointer
,	O
""	pointer
)	O
;	O
}	O
strcat	function
(	O
sx	pointer
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
)	O
)	O
;	O
process_vcwd	function
(	O
pathcomps	pointer
,	O
sx	pointer
)	O
;	O
swlib_squash_all_dot_slash	function
(	O
pathspec	pointer
)	O
;	O
process_vcwd	function
(	O
cmdcomps	pointer
,	O
pathspec	pointer
)	O
;	O
ncomp	int
=	O
strar_num_elements	function
(	O
pathcomps	pointer
)	O
;	O
j	int
=	O
0	int
;	O
cx	pointer
=	O
strar_get	function
(	O
cmdcomps	pointer
,	O
i	int
++	O
)	O
;	O
while	O
(	O
cx	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
cx	pointer
,	O
".."	pointer
)	O
==	O
0	int
)	O
j	int
++	O
;	O
cx	pointer
=	O
strar_get	function
(	O
cmdcomps	pointer
,	O
i	int
++	O
)	O
;	O
}	O
ncomp	int
-=	O
j	int
;	O
if	O
(	O
ncomp	int
<=	O
0	int
)	O
{	O
ret	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
newvcwd	pointer
,	O
""	pointer
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
ncomp	int
)	O
{	O
if	O
(	O
i	int
>	O
0	int
)	O
strob_strcat	function
(	O
newvcwd	pointer
,	O
"/"	pointer
)	O
;	O
strob_strcat	function
(	O
newvcwd	pointer
,	O
strar_get	function
(	O
pathcomps	pointer
,	O
i	int
++	O
)	O
)	O
;	O
}	O
strob_strcat	function
(	O
newvcwd	pointer
,	O
"/"	pointer
)	O
;	O
i	int
=	O
j	int
;	O
while	O
(	O
i	int
<	O
strar_num_elements	function
(	O
cmdcomps	pointer
)	O
)	O
{	O
if	O
(	O
i	int
>	O
j	int
)	O
strob_strcat	function
(	O
newvcwd	pointer
,	O
"/"	pointer
)	O
;	O
strob_strcat	function
(	O
newvcwd	pointer
,	O
strar_get	function
(	O
cmdcomps	pointer
,	O
i	int
++	O
)	O
)	O
;	O
}	O
ret	int
=	O
0	int
;	O
}	O
strar_close	function
(	O
pathcomps	pointer
)	O
;	O
strar_close	function
(	O
cmdcomps	pointer
)	O
;	O
free	function
(	O
sx	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
dump_filechain_link	function
(	O
struct	O
fileChain	struct
*	O
link	function
)	O
{	O
STROB	struct
*	O
ubuf	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s header_offset=%d data_offset=%s\n"	pointer
,	O
link	function
->	O
nameFC	pointer
,	O
link	function
->	O
header_offsetFC	int
,	O
swlib_imaxtostr	function
(	O
link	function
->	O
data_offsetFC	long
,	O
ubuf	pointer
)	O
)	O
;	O
strob_close	function
(	O
ubuf	pointer
)	O
;	O
}	O
static	O
int	O
check_seek_violation	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
int	O
uxfio_buffer_type	int
=	O
swvarfs_uxfio_fcntl	function
(	O
swvarfs	pointer
,	O
UXFIO_F_GET_BUFTYPE	O
,	O
0	int
)	O
;	O
if	O
(	O
(	O
swvarfs	pointer
->	O
is_unix_pipeM	int
&&	O
swvarfs	pointer
->	O
fdM	int
<	O
UXFIO_FD_MIN	int
)	O
||	O
(	O
swvarfs	pointer
->	O
is_unix_pipeM	int
&&	O
swvarfs	pointer
->	O
fdM	int
>=	O
UXFIO_FD_MIN	int
&&	O
(	O
uxfio_buffer_type	int
!=	O
UXFIO_BUFTYPE_FILE	int
&&	O
uxfio_buffer_type	int
!=	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\nThe pending operation is invalid for use with a pipe.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Re-try with a disk file or stdin redirected from a disk file\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"or, file/dynamic-mem buffering, or, in-order traversal only.\n"	pointer
)	O
;	O
return	O
10	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
set_vcwd	function
(	O
STROB	struct
*	O
cw	pointer
,	O
char	O
*	O
newvcwd	pointer
)	O
{	O
strob_strcpy	function
(	O
cw	pointer
,	O
newvcwd	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
strob_str	function
(	O
cw	pointer
)	O
,	O
"./"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
(	O
strob_str	function
(	O
cw	pointer
)	O
+	O
1	int
)	O
=	O
'\0'	O
;	O
}	O
}	O
static	O
int	O
set_linkname	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
ufd	int
,	O
char	O
*	O
path	pointer
)	O
{	O
int	O
c	int
;	O
int	O
retval	int
=	O
0	int
;	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
vlinkp	pointer
;	O
int	O
vlen	int
=	O
1024	int
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%s]"	pointer
,	O
path	pointer
)	O
;	O
if	O
(	O
ufd	int
<	O
0	int
)	O
{	O
vlinkp	pointer
=	O
swvarfs	pointer
->	O
g_linkname_	pointer
;	O
}	O
else	O
{	O
int	O
u_index	int
=	O
ud_find_fd	function
(	O
swvarfs	pointer
,	O
ufd	int
)	O
;	O
if	O
(	O
u_index	int
>=	O
0	int
)	O
{	O
vlinkp	pointer
=	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_linkname_	pointer
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"internal error,"	pointer
" %d desc not found in swvarfs:set_linkname()\n"	pointer
,	O
ufd	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
file_hdr	pointer
=	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
;	O
ahsStaticSetTarLinknameLength	function
(	O
file_hdr	pointer
,	O
vlen	int
)	O
;	O
s	pointer
=	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
;	O
s	pointer
[	O
vlen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
c	int
=	O
readlink	function
(	O
path	pointer
,	O
s	pointer
,	O
vlen	int
-	O
1	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
SWBIS_E_FAIL3	O
(	O
"error: readlink on [%s] returned %d.\n"	pointer
,	O
path	pointer
,	O
c	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
c	int
>=	O
vlen	int
-	O
1	int
)	O
{	O
c	int
=	O
vlen	int
-	O
1	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning, linkname [%s] truncated.\n"	pointer
,	O
s	pointer
)	O
;	O
}	O
s	pointer
[	O
c	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
>	O
TARNAMESIZE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning, linkname [%s] is too long for tar archives\n"	pointer
,	O
s	pointer
)	O
;	O
}	O
if	O
(	O
vlinkp	pointer
)	O
{	O
swbis_free	O
(	O
vlinkp	pointer
)	O
;	O
vlinkp	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
vlinkp	pointer
=	O
strdup	function
(	O
s	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
static	O
void	O
swvarfs_i_delete_link	function
(	O
struct	O
fileChain	struct
*	O
link	function
)	O
{	O
swbis_free	O
(	O
link	function
->	O
nameFC	pointer
)	O
;	O
swbis_free	O
(	O
link	function
)	O
;	O
}	O
static	O
void	O
swvarfs_i_delete_filechain	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
struct	O
fileChain	struct
*	O
last	pointer
=	O
swvarfs	pointer
->	O
tailM	pointer
;	O
struct	O
fileChain	struct
*	O
newlast	pointer
;	O
while	O
(	O
last	pointer
)	O
{	O
newlast	pointer
=	O
last	pointer
->	O
prevFC	pointer
;	O
swvarfs_i_delete_link	function
(	O
last	pointer
)	O
;	O
last	pointer
=	O
newlast	pointer
;	O
}	O
}	O
static	O
void	O
swvarfs_i_clear_filechain	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
swvarfs_i_delete_filechain	function
(	O
swvarfs	pointer
)	O
;	O
swvarfs	pointer
->	O
headM	pointer
=	O
NULL	O
;	O
swvarfs	pointer
->	O
tailM	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
swvarfs_i_attach_filechain	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
fileChain	struct
*	O
new	pointer
)	O
{	O
new	pointer
->	O
prevFC	pointer
=	O
swvarfs	pointer
->	O
tailM	pointer
;	O
new	pointer
->	O
nextFC	pointer
=	O
NULL	O
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
tailM	pointer
)	O
{	O
swvarfs	pointer
->	O
tailM	pointer
->	O
nextFC	pointer
=	O
new	pointer
;	O
}	O
swvarfs	pointer
->	O
tailM	pointer
=	O
new	pointer
;	O
if	O
(	O
!	O
swvarfs	pointer
->	O
headM	pointer
)	O
{	O
swvarfs	pointer
->	O
headM	pointer
=	O
swvarfs	pointer
->	O
tailM	pointer
;	O
}	O
}	O
static	O
int	O
stat_node	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
fp_path	pointer
,	O
struct	O
stat	struct
*	O
statbuf	pointer
)	O
{	O
char	O
*	O
path	pointer
;	O
int	O
i	int
;	O
STROB	struct
*	O
linkbuf	pointer
;	O
int	O
bufsize	int
;	O
STROB	struct
*	O
totallinkbuf	pointer
;	O
int	O
ret	int
;	O
SWVARFS_E_DEBUG	O
(	O
"BEGIN"	pointer
)	O
;	O
bufsize	int
=	O
300	int
;	O
linkbuf	pointer
=	O
NULL	O
;	O
totallinkbuf	pointer
=	O
NULL	O
;	O
path	pointer
=	O
fp_path	pointer
;	O
i	int
=	O
0	int
;	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
i	int
++	O
<	O
swvarfs	pointer
->	O
n_loop_symlinksM	int
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"in sumlink loop, i=%d"	pointer
,	O
i	int
)	O
;	O
if	O
(	O
(	O
*	O
(	O
swvarfs	pointer
->	O
f_statM	pointer
)	O
)	O
(	O
path	pointer
,	O
statbuf	pointer
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: getnext_dirent: %s() failed: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
swvarfs_get_stat_syscall	function
(	O
swvarfs	pointer
)	O
,	O
path	pointer
)	O
;	O
swvarfs	pointer
->	O
derrM	int
=	O
-	O
2	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
*	O
swvarfs_get_stat_syscall	function
(	O
swvarfs	pointer
)	O
==	O
'l'	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
;	O
}	O
if	O
(	O
S_ISLNK	O
(	O
statbuf	pointer
->	O
st_mode	int
)	O
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"Never gets here"	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"ISLNK is true"	pointer
)	O
;	O
if	O
(	O
linkbuf	pointer
==	O
NULL	O
)	O
{	O
linkbuf	pointer
=	O
strob_open	function
(	O
bufsize	int
+	O
2	int
)	O
;	O
}	O
if	O
(	O
totallinkbuf	pointer
==	O
NULL	O
)	O
{	O
totallinkbuf	pointer
=	O
strob_open	function
(	O
bufsize	int
)	O
;	O
strob_strcpy	function
(	O
totallinkbuf	pointer
,	O
path	pointer
)	O
;	O
}	O
strob_memset	function
(	O
linkbuf	pointer
,	O
(	O
int	O
)	O
(	O
'\0'	O
)	O
,	O
bufsize	int
+	O
2	int
)	O
;	O
ret	int
=	O
readlink	function
(	O
strob_str	function
(	O
totallinkbuf	pointer
)	O
,	O
strob_str	function
(	O
linkbuf	pointer
)	O
,	O
bufsize	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
ret	int
>=	O
bufsize	int
-	O
1	int
)	O
{	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: readlink failed: %s on %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strob_str	function
(	O
totallinkbuf	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: readlink failed: program buffer: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strob_str	function
(	O
totallinkbuf	pointer
)	O
)	O
;	O
}	O
return	O
-	O
1	int
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
*	O
strob_str	function
(	O
linkbuf	pointer
)	O
==	O
'/'	O
)	O
{	O
strob_strcpy	function
(	O
totallinkbuf	pointer
,	O
strob_str	function
(	O
linkbuf	pointer
)	O
)	O
;	O
}	O
else	O
{	O
strob_strcat	function
(	O
totallinkbuf	pointer
,	O
"/"	pointer
)	O
;	O
strob_strcat	function
(	O
totallinkbuf	pointer
,	O
strob_str	function
(	O
linkbuf	pointer
)	O
)	O
;	O
}	O
path	pointer
=	O
strob_str	function
(	O
totallinkbuf	pointer
)	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
linkbuf	pointer
)	O
strob_close	function
(	O
linkbuf	pointer
)	O
;	O
if	O
(	O
totallinkbuf	pointer
)	O
strob_close	function
(	O
totallinkbuf	pointer
)	O
;	O
if	O
(	O
i	int
>=	O
swvarfs	pointer
->	O
n_loop_symlinksM	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: getnext_dirent: recursive %s failed on %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
swvarfs_get_stat_syscall	function
(	O
swvarfs	pointer
)	O
,	O
fp_path	pointer
)	O
;	O
swvarfs	pointer
->	O
derrM	int
=	O
-	O
2	int
;	O
return	O
-	O
2	int
;	O
}	O
taru_statbuf2filehdr	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
statbuf	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
ahsStaticSetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
fp_path	pointer
)	O
;	O
if	O
(	O
S_ISLNK	O
(	O
statbuf	pointer
->	O
st_mode	int
)	O
)	O
{	O
set_linkname	function
(	O
swvarfs	pointer
,	O
-	O
1	int
,	O
fp_path	pointer
)	O
;	O
}	O
else	O
{	O
ahsStaticSetPaxLinkname	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
"END"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
delete_last_component	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
path	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
index_of_slash	int
=	O
strob_strlen	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
-	O
2	int
;	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
[	O
index_of_slash	int
]	O
=	O
'\0'	O
;	O
s	pointer
=	O
strstr	function
(	O
path	pointer
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
)	O
;	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
[	O
index_of_slash	int
]	O
=	O
'/'	O
;	O
if	O
(	O
s	pointer
==	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
)	O
{	O
SWBIS_E_FAIL3	O
(	O
"delete_last_component path=[%s] dirscope=[%s]"	pointer
,	O
path	pointer
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
)	O
;	O
return	O
;	O
}	O
s	pointer
+=	O
(	O
strob_strlen	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
-	O
2	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"/"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
;	O
}	O
s	pointer
=	O
strrchr	function
(	O
s	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
*	O
(	O
s	pointer
)	O
=	O
'\0'	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
get_dir_context	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
dirContext	struct
*	O
dirx	pointer
)	O
{	O
int	O
i	int
=	O
swvarfs	pointer
->	O
stackixM	int
;	O
unsigned	O
char	O
*	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
strob_str	function
(	O
swvarfs	pointer
->	O
stackM	pointer
)	O
;	O
struct	O
dirContext	struct
*	O
ds	pointer
=	O
(	O
struct	O
dirContext	struct
*	O
)	O
(	O
s	pointer
+	O
(	O
i	int
*	O
sizeof	O
(	O
struct	O
dirContext	struct
)	O
)	O
)	O
;	O
*	O
dirx	pointer
=	O
*	O
ds	pointer
;	O
}	O
static	O
void	O
add_dir_context	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
dirContext	struct
*	O
dirx	pointer
)	O
{	O
int	O
i	int
=	O
++	O
(	O
swvarfs	pointer
->	O
stackixM	int
)	O
;	O
unsigned	O
char	O
*	O
s	pointer
;	O
struct	O
dirContext	struct
*	O
ds	pointer
;	O
strob_set_memlength	function
(	O
swvarfs	pointer
->	O
stackM	pointer
,	O
(	O
(	O
i	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
dirContext	struct
)	O
)	O
)	O
;	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
strob_str	function
(	O
swvarfs	pointer
->	O
stackM	pointer
)	O
;	O
ds	pointer
=	O
(	O
struct	O
dirContext	struct
*	O
)	O
(	O
s	pointer
+	O
(	O
i	int
*	O
sizeof	O
(	O
struct	O
dirContext	struct
)	O
)	O
)	O
;	O
*	O
ds	pointer
=	O
*	O
dirx	pointer
;	O
}	O
static	O
void	O
raise_dir_context	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
dirContext	struct
*	O
dirx	pointer
)	O
{	O
struct	O
dirContext	struct
ds	pointer
;	O
get_dir_context	function
(	O
swvarfs	pointer
,	O
&	O
ds	pointer
)	O
;	O
if	O
(	O
ds	pointer
.	O
dp	pointer
!=	O
NULL	O
)	O
closedir	function
(	O
ds	pointer
.	O
dp	pointer
)	O
;	O
swvarfs	pointer
->	O
stackixM	int
--	O
;	O
if	O
(	O
!	O
swvarfs	pointer
->	O
stackixM	int
)	O
{	O
dirx	pointer
->	O
dp	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
get_dir_context	function
(	O
swvarfs	pointer
,	O
dirx	pointer
)	O
;	O
}	O
}	O
static	O
char	O
*	O
swvarfs_get_next_dirent_fs	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
struct	O
stat	struct
sto	struct
;	O
struct	O
stat	struct
*	O
statbuf	pointer
;	O
struct	O
dirent	struct
*	O
dirp	pointer
;	O
DIR	struct
*	O
dp	pointer
=	O
NULL	O
,	O
*	O
olddp	pointer
;	O
char	O
*	O
fullpath	pointer
=	O
strob_str	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
)	O
;	O
struct	O
dirContext	struct
dirx	pointer
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
st	pointer
==	O
NULL	O
)	O
{	O
statbuf	pointer
=	O
&	O
sto	struct
;	O
}	O
else	O
{	O
statbuf	pointer
=	O
st	pointer
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
stackixM	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
get_dir_context	function
(	O
swvarfs	pointer
,	O
&	O
dirx	pointer
)	O
;	O
dirp	pointer
=	O
dirx	pointer
.	O
dirp	pointer
;	O
dp	pointer
=	O
dirx	pointer
.	O
dp	pointer
;	O
while	O
(	O
dp	pointer
==	O
NULL	O
)	O
{	O
delete_last_component	function
(	O
swvarfs	pointer
,	O
fullpath	pointer
)	O
;	O
raise_dir_context	function
(	O
swvarfs	pointer
,	O
&	O
dirx	pointer
)	O
;	O
dirp	pointer
=	O
dirx	pointer
.	O
dirp	pointer
;	O
dp	pointer
=	O
dirx	pointer
.	O
dp	pointer
;	O
}	O
delete_last_component	function
(	O
swvarfs	pointer
,	O
fullpath	pointer
)	O
;	O
}	O
else	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
swvarfs_setdir	function
(	O
swvarfs	pointer
,	O
fullpath	pointer
)	O
;	O
get_dir_context	function
(	O
swvarfs	pointer
,	O
&	O
dirx	pointer
)	O
;	O
dp	pointer
=	O
dirx	pointer
.	O
dp	pointer
;	O
stat_node	function
(	O
swvarfs	pointer
,	O
fullpath	pointer
,	O
statbuf	pointer
)	O
;	O
return	O
fullpath	pointer
;	O
}	O
do	O
{	O
while	O
(	O
(	O
dirp	pointer
=	O
readdir	function
(	O
dp	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
dirp	pointer
->	O
d_name	array
,	O
"."	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
dirp	pointer
->	O
d_name	array
,	O
".."	pointer
)	O
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_strcat	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
,	O
"/"	pointer
)	O
;	O
strob_strcat	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
,	O
dirp	pointer
->	O
d_name	array
)	O
;	O
fullpath	pointer
=	O
strob_str	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
)	O
;	O
stat_node	function
(	O
swvarfs	pointer
,	O
fullpath	pointer
,	O
statbuf	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
statbuf	pointer
->	O
st_mode	int
)	O
)	O
{	O
olddp	pointer
=	O
dp	pointer
;	O
if	O
(	O
(	O
dp	pointer
=	O
opendir	function
(	O
fullpath	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
==	O
EACCES	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Permission denied: %s\n"	pointer
,	O
fullpath	pointer
)	O
;	O
}	O
else	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"internal error -3: [%s]"	pointer
,	O
fullpath	pointer
)	O
;	O
swvarfs	pointer
->	O
derrM	int
=	O
-	O
3	int
;	O
return	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
;	O
}	O
}	O
dirx	pointer
.	O
dp	pointer
=	O
dp	pointer
;	O
add_dir_context	function
(	O
swvarfs	pointer
,	O
&	O
dirx	pointer
)	O
;	O
strob_strcat	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
,	O
"/"	pointer
)	O
;	O
fullpath	pointer
=	O
strob_str	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
)	O
;	O
}	O
swvarfs	pointer
->	O
derrM	int
=	O
0	int
;	O
return	O
fullpath	pointer
;	O
break	O
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
dirp	pointer
==	O
NULL	O
)	O
{	O
raise_dir_context	function
(	O
swvarfs	pointer
,	O
&	O
dirx	pointer
)	O
;	O
delete_last_component	function
(	O
swvarfs	pointer
,	O
fullpath	pointer
)	O
;	O
dp	pointer
=	O
dirx	pointer
.	O
dp	pointer
;	O
}	O
}	O
while	O
(	O
dp	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
swvarfs	pointer
->	O
derrM	int
=	O
0	int
;	O
return	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
;	O
}	O
static	O
int	O
do_stop_reading	function
(	O
void	O
*	O
xx	pointer
,	O
char	O
*	O
member_name	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
did_squash	int
=	O
0	int
;	O
int	O
did_squash1	int
=	O
0	int
;	O
int	O
did_squash2	int
=	O
0	int
;	O
SWVARFS	struct
*	O
swvarfs	pointer
=	O
(	O
SWVARFS	struct
*	O
)	O
xx	pointer
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%s]"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
member_name	pointer
,	O
"./"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
member_name	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
!	O
name	pointer
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
"./"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
name	pointer
+=	O
2	int
;	O
}	O
handle_trailing_slash	function
(	O
"drop"	pointer
,	O
name	pointer
,	O
&	O
did_squash	int
)	O
;	O
handle_trailing_slash	function
(	O
"drop"	pointer
,	O
member_name	pointer
,	O
&	O
did_squash1	int
)	O
;	O
handle_leading_slash	function
(	O
swvarfs	pointer
,	O
"drop"	pointer
,	O
name	pointer
,	O
&	O
did_squash2	int
)	O
;	O
SWVARFS_E_DEBUG3	O
(	O
"strcmp/fnmatch pattern=[%s] name=[%s]"	pointer
,	O
name	pointer
,	O
member_name	pointer
)	O
;	O
ret	int
=	O
strcmp	function
(	O
name	pointer
,	O
member_name	pointer
)	O
?	O
1	int
:	O
0	int
;	O
SWVARFS_E_DEBUG2	O
(	O
"strcmp/fnmatch returned [%d]"	pointer
,	O
ret	int
)	O
;	O
handle_leading_slash	function
(	O
swvarfs	pointer
,	O
"restore"	pointer
,	O
name	pointer
,	O
&	O
did_squash2	int
)	O
;	O
handle_trailing_slash	function
(	O
"restore"	pointer
,	O
name	pointer
,	O
&	O
did_squash	int
)	O
;	O
handle_trailing_slash	function
(	O
"restore"	pointer
,	O
member_name	pointer
,	O
&	O
did_squash1	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
!	O
ret	int
;	O
}	O
static	O
void	O
swvarfs_i_init	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swvarfs	pointer
->	O
uinformat_close_on_deleteM	int
=	O
1	int
;	O
swvarfs	pointer
->	O
opencwdpathM	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
swvarfs	pointer
->	O
openpathM	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
swvarfs	pointer
->	O
dirscopeM	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
swvarfs	pointer
->	O
tmpM	pointer
=	O
strob_open	function
(	O
128	int
)	O
;	O
swvarfs	pointer
->	O
vcwdM	pointer
=	O
strob_open	function
(	O
128	int
)	O
;	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
opencwdpathM	pointer
,	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
openpathM	pointer
,	O
""	pointer
)	O
;	O
swvarfs	pointer
->	O
u_nameM	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
swvarfs	pointer
->	O
ahsM	pointer
=	O
ahs_open	function
(	O
)	O
;	O
swvarfs	pointer
->	O
do_close_ahsM	int
=	O
1	int
;	O
swvarfs	pointer
->	O
headM	pointer
=	O
NULL	O
;	O
swvarfs	pointer
->	O
tailM	pointer
=	O
NULL	O
;	O
swvarfs	pointer
->	O
g_linkname_	pointer
=	O
NULL	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
NULL	O
;	O
swvarfs	pointer
->	O
u_fdM	int
=	O
-	O
1	int
;	O
swvarfs	pointer
->	O
formatM	int
=	O
0	int
;	O
swvarfs	pointer
->	O
f_do_stop_	pointer
=	O
do_stop_reading	function
;	O
swvarfs	pointer
->	O
stackM	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
swvarfs	pointer
->	O
direntpathM	pointer
=	O
strob_open	function
(	O
16	int
)	O
;	O
swvarfs	pointer
->	O
stackixM	int
=	O
0	int
;	O
swvarfs	pointer
->	O
derrM	int
=	O
0	int
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swvarfs	pointer
->	O
have_read_filesM	int
=	O
0	int
;	O
swvarfs	pointer
->	O
current_filechainM	pointer
=	O
NULL	O
;	O
swvarfs	pointer
->	O
uxfio_buftype	int
=	O
UXFIO_BUFTYPE_FILE	int
;	O
swvarfs	pointer
->	O
current_data_offsetM	long
=	O
0	int
;	O
swvarfs	pointer
->	O
is_unix_pipeM	int
=	O
0	int
;	O
swvarfs	pointer
->	O
current_data_offsetM	long
=	O
-	O
1	int
;	O
swvarfs	pointer
->	O
current_header_offsetM	long
=	O
-	O
1	int
;	O
swvarfs	pointer
->	O
makefilechainM	int
=	O
0	int
;	O
swvarfs	pointer
->	O
eoaM	int
=	O
0	int
;	O
swvarfs	pointer
->	O
has_leading_slashM	int
=	O
0	int
;	O
swvarfs	pointer
->	O
did_u_openM	int
=	O
-	O
1	int
;	O
ud_init	function
(	O
swvarfs	pointer
)	O
;	O
swvarfs	pointer
->	O
f_statM	pointer
=	O
(	O
int	O
(	O
*	O
)	O
(	O
char	O
*	O
,	O
struct	O
stat	struct
*	O
)	O
)	O
(	O
lstat	function
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swvarfs	pointer
->	O
link_recordM	pointer
=	O
hllist_open	function
(	O
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swvarfs	pointer
->	O
taruM	pointer
=	O
taru_create	function
(	O
)	O
;	O
swvarfs	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
=	O
0	int
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swvarfs	pointer
->	O
n_loop_symlinksM	int
=	O
20	int
;	O
}	O
static	O
int	O
swvarfs_i_u_open_fs	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
fd	int
;	O
int	O
ret	int
=	O
0	int
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
u_index	int
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%s]"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
swvarfs_dirent_err	function
(	O
swvarfs	pointer
)	O
)	O
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"Internal error status returned from swvarfs_get_next_dirent"	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
name	pointer
=	O
swvarfs_get_next_dirent	function
(	O
swvarfs	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
name	pointer
&&	O
!	O
swvarfs_dirent_err	function
(	O
swvarfs	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
swvarfs_dirent_err	function
(	O
swvarfs	pointer
)	O
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"Internal error status returned from swvarfs_get_next_dirent"	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
if	O
(	O
*	O
name	pointer
!=	O
'/'	O
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
stackixM	int
==	O
0	int
&&	O
is_name_a_path_prefix	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
)	O
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
openpathM	pointer
)	O
)	O
==	O
0	int
)	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
openpathM	pointer
)	O
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
,	O
""	pointer
)	O
;	O
}	O
swlib_unix_dircat	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
,	O
name	pointer
)	O
;	O
}	O
fd	int
=	O
uxfio_open	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
,	O
O_RDONLY	int
,	O
(	O
mode_t	int
)	O
(	O
0	int
)	O
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
swlib_strdup	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
ahsStaticSetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
SWLIB_ASSERT	O
(	O
ud_set_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
>=	O
0	int
)	O
;	O
u_index	int
=	O
ud_find_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
SWLIB_ASSERT	O
(	O
u_index	int
>=	O
0	int
)	O
;	O
swvarfs_uxfio_fcntl	function
(	O
swvarfs	pointer
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_NOBUF	int
)	O
;	O
if	O
(	O
(	O
*	O
(	O
swvarfs	pointer
->	O
f_statM	pointer
)	O
)	O
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
,	O
&	O
st	pointer
)	O
)	O
return	O
-	O
2	int
;	O
ahsStaticSetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
=	O
swlib_strdup	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
)	O
;	O
if	O
(	O
S_ISLNK	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
set_linkname	function
(	O
swvarfs	pointer
,	O
fd	int
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
)	O
;	O
}	O
taru_statbuf2filehdr	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
&	O
st	pointer
,	O
NULL	O
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
,	O
NULL	O
)	O
;	O
uxfio_ioctl	function
(	O
fd	int
,	O
UXFIO_IOCTL_SET_STATBUF	O
,	O
(	O
void	O
*	O
)	O
&	O
st	pointer
)	O
;	O
swvarfs	pointer
->	O
u_fdM	int
=	O
fd	int
;	O
return	O
fd	int
;	O
}	O
static	O
int	O
swvarfs_i_u_lstat_fs	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
ret	int
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
*	O
path	pointer
!=	O
'/'	O
)	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
,	O
""	pointer
)	O
;	O
strob_strcat	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
,	O
path	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
,	O
path	pointer
)	O
;	O
}	O
ret	int
=	O
(	O
*	O
(	O
swvarfs	pointer
->	O
f_statM	pointer
)	O
)	O
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
,	O
st	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
swvarfs_i_u_lstat_archive	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
fd	int
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
fd	int
=	O
swvarfs_u_open	function
(	O
swvarfs	pointer
,	O
path	pointer
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
return	O
-	O
3	int
;	O
}	O
if	O
(	O
swvarfs_file_has_data	function
(	O
swvarfs	pointer
)	O
)	O
{	O
taru_pump_amount2	function
(	O
-	O
1	int
,	O
fd	int
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
st	pointer
)	O
if	O
(	O
swvarfs_u_fstat	function
(	O
swvarfs	pointer
,	O
fd	int
,	O
st	pointer
)	O
)	O
return	O
-	O
2	int
;	O
swvarfs_u_close	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
swvarfs_get_next_dirent_archive_NEW	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
,	O
int	O
*	O
peoa	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
intmax_t	long
old_pos	long
;	O
intmax_t	long
new_pos	long
;	O
*	O
peoa	pointer
=	O
0	int
;	O
if	O
(	O
swvarfs	pointer
->	O
did_u_openM	int
==	O
0	int
&&	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
{	O
swvarfs_i_u_lstat_archive	function
(	O
swvarfs	pointer
,	O
swvarfs	pointer
->	O
u_current_name_	pointer
,	O
NULL	O
)	O
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"OFFSET = %d"	pointer
,	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
)	O
;	O
old_pos	long
=	O
(	O
intmax_t	long
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
swvarfs	pointer
->	O
current_header_offsetM	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
taru_read_header	function
(	O
swvarfs	pointer
->	O
taruM	pointer
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
swvarfs	pointer
->	O
fdM	int
,	O
swvarfs	pointer
->	O
formatM	int
,	O
peoa	pointer
,	O
swvarfs	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL	O
(	O
"header read error"	pointer
)	O
;	O
swvarfs	pointer
->	O
derrM	int
=	O
-	O
3	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
*	O
peoa	pointer
)	O
{	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
swvarfs	pointer
->	O
current_data_offsetM	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
new_pos	long
=	O
swvarfs	pointer
->	O
current_data_offsetM	long
;	O
SWVARFS_E_DEBUG3	O
(	O
"swvarfs->fdM = [%d] old_pos = %d "	pointer
,	O
swvarfs	pointer
->	O
fdM	int
,	O
old_pos	long
)	O
;	O
SWVARFS_E_DEBUG3	O
(	O
"swvarfs->fdM = [%d] new_pos = %d "	pointer
,	O
swvarfs	pointer
->	O
fdM	int
,	O
new_pos	long
)	O
;	O
SWVARFS_E_DEBUG3	O
(	O
"swvarfs->fdM = [%d] old_pos - new_pos = %d "	pointer
,	O
swvarfs	pointer
->	O
fdM	int
,	O
old_pos	long
-	O
new_pos	long
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
off_t	long
)	O
(	O
old_pos	long
-	O
new_pos	long
)	O
,	O
UXFIO_SEEK_VCUR	int
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL	O
(	O
"swvarfs_get_next_dirent_archive: seek error"	pointer
)	O
;	O
exit	function
(	O
88	int
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
st	pointer
)	O
{	O
taru_filehdr2statbuf	function
(	O
st	pointer
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
;	O
}	O
name	pointer
=	O
ahsStaticGetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
is_name_in_scope	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
,	O
name	pointer
,	O
(	O
struct	O
stat	struct
*	O
)	O
NULL	O
)	O
==	O
0	int
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"SCOPE REJECT HERE name = %s"	pointer
,	O
name	pointer
)	O
;	O
u_reject	function
(	O
swvarfs	pointer
)	O
;	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
swlib_strdup	function
(	O
name	pointer
)	O
;	O
swvarfs	pointer
->	O
did_u_openM	int
=	O
0	int
;	O
return	O
name	pointer
;	O
}	O
static	O
struct	O
fileChain	struct
*	O
swvarfs_i_make_link	function
(	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
,	O
intmax_t	long
header_offset	long
,	O
intmax_t	long
data_offset	long
)	O
{	O
struct	O
fileChain	struct
*	O
link	function
=	O
(	O
struct	O
fileChain	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
fileChain	struct
)	O
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
link	function
==	O
NULL	O
)	O
return	O
NULL	O
;	O
link	function
->	O
nameFC	pointer
=	O
swlib_strdup	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
;	O
swlib_slashclean	function
(	O
link	function
->	O
nameFC	pointer
)	O
;	O
swlib_process_hex_escapes	function
(	O
link	function
->	O
nameFC	pointer
)	O
;	O
SWVARFS_E_DEBUG3	O
(	O
"link made name=[%s] header_offset = [%s]"	pointer
,	O
link	function
->	O
nameFC	pointer
,	O
swlib_imaxtostr	function
(	O
header_offset	long
,	O
NULL	O
)	O
)	O
;	O
SWVARFS_E_DEBUG3	O
(	O
"link made name=[%s]   data_offset = [%s]"	pointer
,	O
link	function
->	O
nameFC	pointer
,	O
swlib_imaxtostr	function
(	O
data_offset	long
,	O
NULL	O
)	O
)	O
;	O
link	function
->	O
header_offsetFC	int
=	O
header_offset	long
;	O
link	function
->	O
data_offsetFC	long
=	O
data_offset	long
;	O
link	function
->	O
prevFC	pointer
=	O
link	function
->	O
nextFC	pointer
=	O
NULL	O
;	O
link	function
->	O
uxfio_u_fdFC	int
=	O
-	O
1	int
;	O
return	O
link	function
;	O
}	O
static	O
struct	O
fileChain	struct
*	O
swvarfs_i_readin_filechain	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
fileChain	struct
*	O
last	pointer
=	O
swvarfs	pointer
->	O
tailM	pointer
,	O
*	O
new_link	pointer
;	O
intmax_t	long
header_offset	long
;	O
intmax_t	long
data_offset	long
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%s]"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
last	pointer
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"OFFSET BEFORE= %d"	pointer
,	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
)	O
;	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
off_t	long
)	O
(	O
last	pointer
->	O
header_offsetFC	int
)	O
,	O
SEEK_SET	int
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"OFFSET AFTER= %d"	pointer
,	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
)	O
;	O
header_offset	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
if	O
(	O
taru_read_header	function
(	O
swvarfs	pointer
->	O
taruM	pointer
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
swvarfs	pointer
->	O
fdM	int
,	O
swvarfs	pointer
->	O
formatM	int
,	O
NULL	O
,	O
swvarfs	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL	O
(	O
"header read error"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
SWVARFS_E_DEBUG2	O
(	O
"I-section AFTER taru_read_header name=[%s]"	pointer
,	O
ahsStaticGetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
)	O
;	O
swvarfs	pointer
->	O
current_data_offsetM	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
data_offset	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
if	O
(	O
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFREG	int
)	O
{	O
if	O
(	O
taru_write_archive_member_data	function
(	O
swvarfs	pointer
->	O
taruM	pointer
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
-	O
1	int
,	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
int	O
(	O
*	O
)	O
(	O
int	O
)	O
)	O
NULL	O
,	O
uinfile_get_type	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
,	O
-	O
1	int
,	O
NULL	O
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL2	O
(	O
"data error %s\n"	pointer
,	O
ahsStaticGetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
taru_tape_skip_padding	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
->	O
c_filesize	long
,	O
uinfile_get_type	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
)	O
;	O
}	O
else	O
{	O
data_offset	long
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
}	O
do	O
{	O
header_offset	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
SWVARFS_E_DEBUG3	O
(	O
"readin name = [%s]  header offset = %d"	pointer
,	O
name	pointer
,	O
(	O
int	O
)	O
header_offset	long
)	O
;	O
if	O
(	O
taru_read_header	function
(	O
swvarfs	pointer
->	O
taruM	pointer
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
swvarfs	pointer
->	O
fdM	int
,	O
swvarfs	pointer
->	O
formatM	int
,	O
NULL	O
,	O
swvarfs	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
)	O
<	O
0	int
)	O
{	O
new_link	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
swvarfs	pointer
->	O
current_data_offsetM	long
=	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"Loop-section AFTER taru_read_header name=[%s]"	pointer
,	O
ahsStaticGetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
ahsStaticGetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
,	O
"TRAILER!!!"	pointer
)	O
)	O
{	O
new_link	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
data_offset	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
if	O
(	O
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFREG	int
)	O
{	O
if	O
(	O
taru_write_archive_member_data	function
(	O
swvarfs	pointer
->	O
taruM	pointer
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
-	O
1	int
,	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
int	O
(	O
*	O
)	O
(	O
int	O
)	O
)	O
NULL	O
,	O
uinfile_get_type	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
,	O
-	O
1	int
,	O
NULL	O
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL2	O
(	O
"data error %s\n"	pointer
,	O
ahsStaticGetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
taru_tape_skip_padding	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
->	O
c_filesize	long
,	O
uinfile_get_type	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
)	O
;	O
}	O
else	O
{	O
data_offset	long
=	O
-	O
1	int
;	O
}	O
new_link	pointer
=	O
swvarfs_i_make_link	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
header_offset	long
,	O
data_offset	long
)	O
;	O
swvarfs_i_attach_filechain	function
(	O
swvarfs	pointer
,	O
new_link	pointer
)	O
;	O
}	O
while	O
(	O
do_stop_reading	function
(	O
(	O
void	O
*	O
)	O
swvarfs	pointer
,	O
ahsStaticGetTarFilename	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
,	O
name	pointer
)	O
==	O
0	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
new_link	pointer
;	O
}	O
static	O
struct	O
fileChain	struct
*	O
swvarfs_i_search_filechain	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
name_p	pointer
,	O
int	O
*	O
scope_rejection	pointer
)	O
{	O
int	O
did_drop	int
=	O
0	int
;	O
int	O
did_omit_lslash	int
=	O
0	int
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
p	pointer
;	O
struct	O
fileChain	struct
*	O
last	pointer
=	O
swvarfs	pointer
->	O
headM	pointer
;	O
name	pointer
=	O
name_p	pointer
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
NULL	O
;	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
tmpM	pointer
,	O
name	pointer
)	O
;	O
name	pointer
=	O
strob_str	function
(	O
swvarfs	pointer
->	O
tmpM	pointer
)	O
;	O
swlib_process_hex_escapes	function
(	O
name	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%s]"	pointer
,	O
name	pointer
)	O
;	O
*	O
scope_rejection	pointer
=	O
0	int
;	O
while	O
(	O
last	pointer
)	O
{	O
p	pointer
=	O
last	pointer
->	O
nameFC	pointer
;	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"./"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
p	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
"./"	pointer
)	O
==	O
0	int
)	O
{	O
name	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
"./"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
name	pointer
+=	O
2	int
;	O
}	O
handle_trailing_slash	function
(	O
"drop"	pointer
,	O
name	pointer
,	O
&	O
did_drop	int
)	O
;	O
handle_leading_slash	function
(	O
swvarfs	pointer
,	O
"drop"	pointer
,	O
name	pointer
,	O
&	O
did_omit_lslash	int
)	O
;	O
SWVARFS_E_DEBUG3	O
(	O
"strcmp/fnmatch pattern=[%s] name=[%s]"	pointer
,	O
name	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
p	pointer
)	O
==	O
0	int
)	O
{	O
SWVARFS_E_DEBUG3	O
(	O
"Got match strcmp/fnmatch pattern=[%s] name=[%s]"	pointer
,	O
name	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
is_name_in_scope	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
,	O
name	pointer
,	O
(	O
struct	O
stat	struct
*	O
)	O
NULL	O
)	O
)	O
{	O
handle_trailing_slash	function
(	O
"restore"	pointer
,	O
name	pointer
,	O
&	O
did_drop	int
)	O
;	O
handle_leading_slash	function
(	O
swvarfs	pointer
,	O
"restore"	pointer
,	O
name	pointer
,	O
&	O
did_omit_lslash	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING Found in scope OK"	pointer
)	O
;	O
return	O
last	pointer
;	O
}	O
else	O
{	O
*	O
scope_rejection	pointer
=	O
1	int
;	O
handle_trailing_slash	function
(	O
"restore"	pointer
,	O
name	pointer
,	O
&	O
did_drop	int
)	O
;	O
handle_leading_slash	function
(	O
swvarfs	pointer
,	O
"restore"	pointer
,	O
name	pointer
,	O
&	O
did_omit_lslash	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING returning null, out of scope"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
handle_trailing_slash	function
(	O
"restore"	pointer
,	O
name	pointer
,	O
&	O
did_drop	int
)	O
;	O
handle_leading_slash	function
(	O
swvarfs	pointer
,	O
"restore"	pointer
,	O
name	pointer
,	O
&	O
did_omit_lslash	int
)	O
;	O
last	pointer
=	O
last	pointer
->	O
nextFC	pointer
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
swvarfs_i_u_open_archive_seek_to_name	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
tret	int
;	O
intmax_t	long
header_offset	long
=	O
0	int
;	O
intmax_t	long
data_offset	long
;	O
int	O
*	O
peoa	pointer
=	O
&	O
(	O
swvarfs	pointer
->	O
eoaM	int
)	O
;	O
struct	O
fileChain	struct
*	O
new_link	pointer
;	O
struct	O
fileChain	struct
*	O
existing	pointer
=	O
NULL	O
;	O
char	O
*	O
current_name	pointer
=	O
swvarfs	pointer
->	O
u_current_name_	pointer
;	O
int	O
scope_rejection	pointer
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%s]"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
current_name	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"current name is NULL"	pointer
)	O
;	O
scope_rejection	pointer
=	O
0	int
;	O
if	O
(	O
(	O
existing	pointer
=	O
swvarfs_i_search_filechain	function
(	O
swvarfs	pointer
,	O
name	pointer
,	O
&	O
scope_rejection	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
scope_rejection	pointer
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"SCOPE REJECT HERE name = %s"	pointer
,	O
name	pointer
)	O
;	O
u_reject	function
(	O
swvarfs	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
current_name	pointer
=	O
swvarfs_get_next_dirent_archive_NEW	function
(	O
swvarfs	pointer
,	O
(	O
struct	O
stat	struct
*	O
)	O
(	O
NULL	O
)	O
,	O
peoa	pointer
)	O
;	O
}	O
else	O
{	O
SWVARFS_E_DEBUG	O
(	O
"HERE"	pointer
)	O
;	O
swvarfs	pointer
->	O
current_filechainM	pointer
=	O
existing	pointer
;	O
current_name	pointer
=	O
existing	pointer
->	O
nameFC	pointer
;	O
}	O
}	O
SWVARFS_E_DEBUG3	O
(	O
"name = [%s] peoa=%d"	pointer
,	O
current_name	pointer
,	O
*	O
peoa	pointer
)	O
;	O
if	O
(	O
current_name	pointer
&&	O
!	O
filename_does_match	function
(	O
name	pointer
,	O
current_name	pointer
)	O
&&	O
existing	pointer
==	O
NULL	O
)	O
{	O
SWVARFS_E_DEBUG3	O
(	O
"NAME MATCH [%s] offset = %d"	pointer
,	O
name	pointer
,	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
)	O
;	O
if	O
(	O
is_name_in_scope	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
,	O
current_name	pointer
,	O
(	O
struct	O
stat	struct
*	O
)	O
NULL	O
)	O
==	O
0	int
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"SCOPE REJECT HERE name = %s"	pointer
,	O
current_name	pointer
)	O
;	O
u_reject	function
(	O
swvarfs	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
swvarfs	pointer
->	O
current_filechainM	pointer
=	O
existing	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
check_seek_violation	function
(	O
swvarfs	pointer
)	O
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
-	O
3	int
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
"NOT a match"	pointer
)	O
;	O
if	O
(	O
(	O
existing	pointer
=	O
swvarfs_i_search_filechain	function
(	O
swvarfs	pointer
,	O
name	pointer
,	O
&	O
scope_rejection	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
scope_rejection	pointer
=	O
0	int
;	O
if	O
(	O
scope_rejection	pointer
||	O
(	O
(	O
existing	pointer
=	O
swvarfs_i_readin_filechain	function
(	O
swvarfs	pointer
,	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"REJECT HERE name = %s"	pointer
,	O
name	pointer
)	O
;	O
u_reject	function
(	O
swvarfs	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
is_name_in_scope	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
,	O
name	pointer
,	O
(	O
struct	O
stat	struct
*	O
)	O
NULL	O
)	O
==	O
0	int
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"SCOPE REJECT HERE name = %s"	pointer
,	O
name	pointer
)	O
;	O
u_reject	function
(	O
swvarfs	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
swvarfs	pointer
->	O
current_filechainM	pointer
=	O
existing	pointer
;	O
SWVARFS_E_DEBUG2	O
(	O
"OFFSET BEFORE = %d"	pointer
,	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"header_offsetFC is = %d"	pointer
,	O
(	O
int	O
)	O
(	O
existing	pointer
->	O
header_offsetFC	int
)	O
)	O
;	O
tret	int
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
off_t	long
)	O
(	O
existing	pointer
->	O
header_offsetFC	int
)	O
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
tret	int
!=	O
existing	pointer
->	O
header_offsetFC	int
)	O
{	O
SWBIS_E_FAIL3	O
(	O
"seek error tret = %d header_offsetM = %d"	pointer
,	O
tret	int
,	O
existing	pointer
->	O
header_offsetFC	int
)	O
;	O
u_reject	function
(	O
swvarfs	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
SWVARFS_E_DEBUG2	O
(	O
"OFFSET AFTER = %d"	pointer
,	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
)	O
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
makefilechainM	int
&&	O
swvarfs	pointer
->	O
current_filechainM	pointer
==	O
NULL	O
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
header_offset	long
=	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
"about to read the archive header"	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"offset in swvarfs->fdM is %d"	pointer
,	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
)	O
;	O
if	O
(	O
taru_read_header	function
(	O
swvarfs	pointer
->	O
taruM	pointer
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
swvarfs	pointer
->	O
fdM	int
,	O
swvarfs	pointer
->	O
formatM	int
,	O
peoa	pointer
,	O
swvarfs	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL	O
(	O
"header read error"	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
-	O
3	int
;	O
}	O
swvarfs	pointer
->	O
current_data_offsetM	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"swvarfs->current_data_offsetM = [%s]"	pointer
,	O
swlib_imaxtostr	function
(	O
swvarfs	pointer
->	O
current_data_offsetM	long
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
makefilechainM	int
&&	O
swvarfs	pointer
->	O
current_filechainM	pointer
==	O
NULL	O
)	O
{	O
data_offset	long
=	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
new_link	pointer
=	O
swvarfs_i_make_link	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
,	O
header_offset	long
,	O
data_offset	long
)	O
;	O
swvarfs_i_attach_filechain	function
(	O
swvarfs	pointer
,	O
new_link	pointer
)	O
;	O
swvarfs	pointer
->	O
current_filechainM	pointer
=	O
new_link	pointer
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
swvarfs_i_u_open_archive_bh	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
new_cpio_header	struct
*	O
file_hdr	pointer
)	O
{	O
int	O
fd	int
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
u_index	int
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%p]"	pointer
,	O
file_hdr	pointer
)	O
;	O
if	O
(	O
ud_find_fd	function
(	O
swvarfs	pointer
,	O
-	O
1	int
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"too many open swvarfs:u_fd descriptors.\n"	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"return -4"	pointer
)	O
;	O
return	O
-	O
4	int
;	O
}	O
fd	int
=	O
uxfio_opendup	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
UXFIO_BUFTYPE_NOBUF	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"return -5"	pointer
)	O
;	O
return	O
-	O
5	int
;	O
}	O
SWLIB_ASSERT	O
(	O
ud_set_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
>=	O
0	int
)	O
;	O
u_index	int
=	O
ud_find_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
SWLIB_ASSERT	O
(	O
u_index	int
>=	O
0	int
)	O
;	O
taru_filehdr2statbuf	function
(	O
&	O
st	pointer
,	O
file_hdr	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
swlib_strdup	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
=	O
swlib_strdup	function
(	O
ahsStaticGetTarFilename	function
(	O
file_hdr	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
NULL	O
;	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
g_linkname_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
g_linkname_	pointer
)	O
;	O
swvarfs	pointer
->	O
g_linkname_	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
strlen	function
(	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
)	O
)	O
{	O
swvarfs	pointer
->	O
g_linkname_	pointer
=	O
swlib_strdup	function
(	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
)	O
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_linkname_	pointer
=	O
swlib_strdup	function
(	O
ahsStaticGetTarLinkname	function
(	O
file_hdr	pointer
)	O
)	O
;	O
}	O
uxfio_ioctl	function
(	O
fd	int
,	O
UXFIO_IOCTL_SET_STATBUF	O
,	O
(	O
void	O
*	O
)	O
&	O
st	pointer
)	O
;	O
swvarfs	pointer
->	O
u_fdM	int
=	O
fd	int
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_fdM	int
=	O
fd	int
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"return at last with fd=%d"	pointer
,	O
fd	int
)	O
;	O
return	O
fd	int
;	O
}	O
static	O
int	O
swvarfs_i_u_open_archive	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
fd	int
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%s]"	pointer
,	O
name	pointer
)	O
;	O
swvarfs	pointer
->	O
did_u_openM	int
=	O
1	int
;	O
ret	int
=	O
swvarfs_i_u_open_archive_seek_to_name	function
(	O
swvarfs	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"error ret=%d"	pointer
,	O
ret	int
)	O
;	O
return	O
ret	int
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
eoaM	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"End of archive"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
fd	int
=	O
swvarfs_i_u_open_archive_bh	function
(	O
swvarfs	pointer
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
fd	int
;	O
}	O
static	O
int	O
swvarfs_i_iopen	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
oflags	int
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING oflags=[%d]"	pointer
,	O
oflags	int
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING swvarfs->fdM = [%d]"	pointer
,	O
swvarfs	pointer
->	O
fdM	int
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
fdM	int
>=	O
UXFIO_FD_MIN	int
)	O
{	O
if	O
(	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
{	O
SWBIS_E_FAIL	O
(	O
"error in initial uxfio_lseek"	pointer
)	O
;	O
swvarfs	pointer
->	O
fdM	int
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
uxfio_espipe	function
(	O
swvarfs	pointer
->	O
fdM	int
)	O
)	O
{	O
int	O
current_buftype	int
;	O
current_buftype	int
=	O
uxfio_fcntl	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
UXFIO_F_GET_BUFTYPE	O
,	O
0	int
)	O
;	O
if	O
(	O
current_buftype	int
!=	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
&&	O
current_buftype	int
!=	O
UXFIO_BUFTYPE_MEM	int
&&	O
current_buftype	int
!=	O
UXFIO_BUFTYPE_FILE	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"set buftype DYNAMIC_MEM"	pointer
)	O
;	O
swvarfs	pointer
->	O
is_unix_pipeM	int
=	O
1	int
;	O
swvarfs_uxfio_fcntl	function
(	O
swvarfs	pointer
,	O
UXFIO_F_SET_BUFTYPE	O
,	O
UXFIO_BUFTYPE_DYNAMIC_MEM	int
)	O
;	O
swvarfs_uxfio_fcntl	function
(	O
swvarfs	pointer
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_ON	int
)	O
;	O
}	O
}	O
else	O
{	O
swvarfs	pointer
->	O
is_unix_pipeM	int
=	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
swvarfs_i_u_close_archive	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
ret	int
;	O
int	O
u_index	int
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING [%d]"	pointer
,	O
fd	int
)	O
;	O
SWVARFS_E_DEBUG3	O
(	O
"u_fdM=%d  fdM=%d"	pointer
,	O
swvarfs	pointer
->	O
u_fdM	int
,	O
swvarfs	pointer
->	O
fdM	int
)	O
;	O
if	O
(	O
(	O
u_index	int
=	O
ud_find_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"close error, desc %d not found.\n"	pointer
,	O
fd	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fd	int
!=	O
swvarfs	pointer
->	O
u_fdM	int
&&	O
fd	int
!=	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_fdM	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"close error, desc %d not found.\n"	pointer
,	O
fd	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
!=	O
CP_IFLNK	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"(ahs_vfile_hdr(swvarfs->ahsM)->c_mode & CP_IFMT) != CP_IFLNK is true."	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
uxfio_buftype	int
!=	O
UXFIO_BUFTYPE_NOBUF	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"swvarfs->uxfio_buftype != UXFIO_BUFTYPE_NOBUF"	pointer
)	O
;	O
ret	int
=	O
uxfio_lseek	function
(	O
fd	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: swvarfs_i_u_close_archive: uxfio_lseek error\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
->	O
c_mode	short
&	O
CP_IFMT	int
)	O
==	O
CP_IFREG	int
)	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"SKIP running taru_tape_skip_padding name=%s."	pointer
,	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
taru_tape_skip_padding	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
->	O
c_filesize	long
,	O
swvarfs	pointer
->	O
formatM	int
)	O
;	O
}	O
else	O
{	O
int	O
current_pos	int
;	O
current_pos	int
=	O
(	O
int	O
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
if	O
(	O
current_pos	int
<	O
0	int
)	O
{	O
SWBIS_E_FAIL	O
(	O
"uxfio_lseek failed-1"	pointer
)	O
;	O
}	O
SWVARFS_E_DEBUG3	O
(	O
"XXX running uxfio_lseek fd=%d offset=%d"	pointer
,	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
int	O
)	O
(	O
swvarfs	pointer
->	O
current_data_offsetM	long
-	O
current_pos	int
)	O
)	O
;	O
if	O
(	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
off_t	long
)	O
(	O
swvarfs	pointer
->	O
current_data_offsetM	long
-	O
current_pos	int
)	O
,	O
SEEK_CUR	int
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL	O
(	O
"uxfio_lseek failed-2"	pointer
)	O
;	O
}	O
}	O
swvarfs	pointer
->	O
u_fdM	int
=	O
-	O
1	int
;	O
if	O
(	O
swvarfs	pointer
->	O
g_linkname_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
g_linkname_	pointer
)	O
;	O
swvarfs	pointer
->	O
g_linkname_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
=	O
NULL	O
;	O
}	O
ud_unset_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
uxfio_free	function
(	O
fd	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
clear_all_dir_context	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
struct	O
dirContext	struct
dirx	pointer
;	O
while	O
(	O
swvarfs	pointer
->	O
stackixM	int
>	O
0	int
)	O
raise_dir_context	function
(	O
swvarfs	pointer
,	O
&	O
dirx	pointer
)	O
;	O
}	O
static	O
void	O
set_dirscope	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
path	pointer
)	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
,	O
path	pointer
)	O
;	O
swlib_squash_trailing_slash	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
)	O
;	O
swlib_squash_leading_dot_slash	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
)	O
;	O
{	O
char	O
*	O
s	pointer
,	O
*	O
p	pointer
;	O
s	pointer
=	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
;	O
p	pointer
=	O
strstr	function
(	O
s	pointer
,	O
"/*"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"/"	pointer
)	O
&&	O
(	O
p	pointer
==	O
NULL	O
||	O
p	pointer
!=	O
s	pointer
)	O
)	O
{	O
strob_strcat	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
,	O
"/*"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"/"	pointer
)	O
==	O
0	int
)	O
{	O
strob_strcat	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
,	O
"*"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
SWVARFS	struct
*	O
swvarfs_open_serial_access_file_internal	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
oflags	int
)	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
opencwdpathM	pointer
,	O
""	pointer
)	O
;	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
,	O
""	pointer
)	O
;	O
swvarfs	pointer
->	O
fdM	int
=	O
uinfile_open	function
(	O
name	pointer
,	O
(	O
mode_t	int
)	O
(	O
0	int
)	O
,	O
&	O
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
,	O
oflags	int
)	O
;	O
swvarfs	pointer
->	O
did_dupM	int
=	O
1	int
;	O
if	O
(	O
swvarfs	pointer
->	O
fdM	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error (swvarfs_open_serial_access_file_internal) loc=1\n"	pointer
)	O
;	O
swbis_free	O
(	O
swvarfs	pointer
)	O
;	O
return	O
(	O
SWVARFS	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
}	O
if	O
(	O
swvarfs_i_iopen	function
(	O
swvarfs	pointer
,	O
oflags	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error (swvarfs_open_serial_access_file_internal) loc=2\n"	pointer
)	O
;	O
swbis_free	O
(	O
swvarfs	pointer
)	O
;	O
return	O
(	O
SWVARFS	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
}	O
swvarfs	pointer
->	O
formatM	int
=	O
uinfile_get_type	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
;	O
swvarfs	pointer
->	O
has_leading_slashM	int
=	O
uinfile_get_has_leading_slash	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
;	O
return	O
swvarfs	pointer
;	O
}	O
static	O
SWVARFS	struct
*	O
swvarfs_open_directory_internal	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
swvarfs	pointer
->	O
formatM	int
=	O
UINFILE_FILESYSTEM	int
;	O
strob_set_length	function
(	O
swvarfs	pointer
->	O
opencwdpathM	pointer
,	O
256	int
)	O
;	O
strob_str	function
(	O
swvarfs	pointer
->	O
opencwdpathM	pointer
)	O
[	O
255	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
getcwd	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
opencwdpathM	pointer
)	O
,	O
255	int
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swvarfs_open: cwd name too long.\n"	pointer
)	O
;	O
swbis_free	O
(	O
swvarfs	pointer
)	O
;	O
return	O
(	O
SWVARFS	struct
*	O
)	O
NULL	O
;	O
}	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
,	O
name	pointer
)	O
;	O
set_dirscope	function
(	O
swvarfs	pointer
,	O
name	pointer
)	O
;	O
swlib_slashclean	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
)	O
)	O
;	O
swlib_slashclean	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
opencwdpathM	pointer
)	O
)	O
;	O
swvarfs	pointer
->	O
did_dupM	int
=	O
0	int
;	O
swvarfs	pointer
->	O
fdM	int
=	O
-	O
1	int
;	O
return	O
swvarfs	pointer
;	O
}	O
UINFORMAT	struct
*	O
swvarfs_get_uinformat	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
return	O
swvarfs	pointer
->	O
format_descM	pointer
;	O
}	O
void	O
swvarfs_debug_dump_filechain	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
struct	O
fileChain	struct
*	O
last	pointer
=	O
swvarfs	pointer
->	O
headM	pointer
;	O
while	O
(	O
last	pointer
)	O
{	O
dump_filechain_link	function
(	O
last	pointer
)	O
;	O
last	pointer
=	O
last	pointer
->	O
nextFC	pointer
;	O
}	O
}	O
SWVARFS	struct
*	O
swvarfs_open_archive_file	function
(	O
char	O
*	O
name	pointer
,	O
int	O
oflags	int
)	O
{	O
SWVARFS	struct
*	O
swvarfs	pointer
=	O
(	O
SWVARFS	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWVARFS	struct
)	O
)	O
;	O
SWVARFS	struct
*	O
ret	int
;	O
if	O
(	O
swvarfs	pointer
==	O
NULL	O
)	O
return	O
(	O
SWVARFS	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
swvarfs_i_init	function
(	O
swvarfs	pointer
)	O
;	O
ret	int
=	O
swvarfs_open_serial_access_file_internal	function
(	O
swvarfs	pointer
,	O
name	pointer
,	O
oflags	int
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
openpathM	pointer
,	O
name	pointer
)	O
;	O
set_vcwd	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
,	O
name	pointer
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
SWVARFS	struct
*	O
swvarfs_open_directory	function
(	O
char	O
*	O
name	pointer
)	O
{	O
SWVARFS	struct
*	O
swvarfs	pointer
=	O
(	O
SWVARFS	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWVARFS	struct
)	O
)	O
;	O
SWVARFS	struct
*	O
ret	int
;	O
if	O
(	O
swvarfs	pointer
==	O
NULL	O
)	O
return	O
(	O
SWVARFS	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
swvarfs_i_init	function
(	O
swvarfs	pointer
)	O
;	O
ret	int
=	O
swvarfs_open_directory_internal	function
(	O
swvarfs	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
openpathM	pointer
,	O
name	pointer
)	O
;	O
set_vcwd	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
,	O
name	pointer
)	O
;	O
}	O
swvarfs	pointer
->	O
format_descM	pointer
=	O
(	O
UINFORMAT	struct
*	O
)	O
NULL	O
;	O
return	O
ret	int
;	O
}	O
SWVARFS	struct
*	O
swvarfs_open	function
(	O
char	O
*	O
name	pointer
,	O
int	O
oflags	int
,	O
mode_t	int
p_mode	int
)	O
{	O
SWVARFS	struct
*	O
rval	pointer
;	O
int	O
statrc	int
=	O
0	int
;	O
mode_t	int
mode	int
=	O
0	int
;	O
struct	O
stat	struct
stbuf	struct
;	O
SWVARFS_E_DEBUG3	O
(	O
"ENTERING name=[%s] mode=%d"	pointer
,	O
name	pointer
?	O
name	pointer
:	O
""	pointer
,	O
oflags	int
)	O
;	O
if	O
(	O
p_mode	int
==	O
0	int
)	O
{	O
if	O
(	O
name	pointer
&&	O
strcmp	function
(	O
name	pointer
,	O
"-"	pointer
)	O
!=	O
0	int
)	O
statrc	int
=	O
stat	struct
(	O
name	pointer
,	O
&	O
stbuf	struct
)	O
;	O
if	O
(	O
statrc	int
==	O
0	int
)	O
mode	int
=	O
stbuf	struct
.	O
st_mode	int
;	O
}	O
else	O
{	O
mode	int
=	O
p_mode	int
;	O
}	O
if	O
(	O
name	pointer
&&	O
strcmp	function
(	O
name	pointer
,	O
"-"	pointer
)	O
&&	O
statrc	int
==	O
0	int
&&	O
(	O
S_ISDIR	O
(	O
mode	int
)	O
||	O
mode	int
==	O
SWVARFS_S_IFDIR	int
)	O
)	O
{	O
rval	pointer
=	O
swvarfs_open_directory	function
(	O
name	pointer
)	O
;	O
}	O
else	O
{	O
rval	pointer
=	O
swvarfs_open_archive_file	function
(	O
name	pointer
,	O
oflags	int
)	O
;	O
}	O
return	O
rval	pointer
;	O
}	O
SWVARFS	struct
*	O
swvarfs_opendup_with_name	function
(	O
int	O
ifd	int
,	O
int	O
oflags	int
,	O
mode_t	int
mode	int
,	O
char	O
*	O
name	pointer
)	O
{	O
SWVARFS	struct
*	O
swvarfs	pointer
=	O
(	O
SWVARFS	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWVARFS	struct
)	O
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING mode=%d"	pointer
,	O
oflags	int
)	O
;	O
if	O
(	O
swvarfs	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
swvarfs_opendup	function
(	O
ifd	int
,	O
oflags	int
,	O
mode	int
)	O
;	O
swvarfs	pointer
->	O
fdM	int
=	O
uinfile_opendup_with_name	function
(	O
ifd	int
,	O
(	O
mode_t	int
)	O
(	O
0	int
)	O
,	O
&	O
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
,	O
oflags	int
,	O
name	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
fdM	int
<	O
0	int
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
)	O
;	O
return	O
(	O
SWVARFS	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
swvarfs	pointer
->	O
fdM	int
==	O
ifd	int
)	O
{	O
swvarfs	pointer
->	O
did_dupM	int
=	O
0	int
;	O
}	O
else	O
{	O
swvarfs	pointer
->	O
did_dupM	int
=	O
1	int
;	O
}	O
swvarfs_i_init	function
(	O
swvarfs	pointer
)	O
;	O
if	O
(	O
swvarfs_i_iopen	function
(	O
swvarfs	pointer
,	O
oflags	int
)	O
)	O
return	O
NULL	O
;	O
swvarfs	pointer
->	O
formatM	int
=	O
uinfile_get_type	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
;	O
return	O
swvarfs	pointer
;	O
}	O
SWVARFS	struct
*	O
swvarfs_opendup	function
(	O
int	O
ifd	int
,	O
int	O
oflags	int
,	O
mode_t	int
mode	int
)	O
{	O
SWVARFS	struct
*	O
swvarfs	pointer
=	O
(	O
SWVARFS	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWVARFS	struct
)	O
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"ENTERING mode=%d"	pointer
,	O
oflags	int
)	O
;	O
if	O
(	O
swvarfs	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swvarfs	pointer
->	O
fdM	int
=	O
uinfile_opendup	function
(	O
ifd	int
,	O
(	O
mode_t	int
)	O
(	O
0	int
)	O
,	O
&	O
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
,	O
oflags	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
fdM	int
<	O
0	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
swbis_free	O
(	O
swvarfs	pointer
)	O
;	O
return	O
(	O
SWVARFS	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
swvarfs	pointer
->	O
fdM	int
==	O
ifd	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"did_dup = 0"	pointer
)	O
;	O
swvarfs	pointer
->	O
did_dupM	int
=	O
0	int
;	O
}	O
else	O
{	O
SWVARFS_E_DEBUG	O
(	O
"did_dup = 1"	pointer
)	O
;	O
swvarfs	pointer
->	O
did_dupM	int
=	O
1	int
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swvarfs_i_init	function
(	O
swvarfs	pointer
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
if	O
(	O
swvarfs_i_iopen	function
(	O
swvarfs	pointer
,	O
oflags	int
)	O
)	O
return	O
NULL	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
swvarfs	pointer
->	O
formatM	int
=	O
uinfile_get_type	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
;	O
return	O
swvarfs	pointer
;	O
}	O
int	O
swvarfs_u_readlink	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
path	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
bufsize	int
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
int	O
fd	int
;	O
char	O
*	O
s	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
swvarfs	pointer
&&	O
swvarfs	pointer
->	O
formatM	int
!=	O
UINFILE_FILESYSTEM	int
)	O
{	O
fd	int
=	O
swvarfs_u_open	function
(	O
swvarfs	pointer
,	O
path	pointer
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
-	O
4	int
;	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
!=	O
UINFILE_FILESYSTEM	int
)	O
{	O
if	O
(	O
swvarfs_file_has_data	function
(	O
swvarfs	pointer
)	O
)	O
{	O
taru_pump_amount2	function
(	O
-	O
1	int
,	O
fd	int
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
swvarfs_u_fstat	function
(	O
swvarfs	pointer
,	O
fd	int
,	O
&	O
st	pointer
)	O
)	O
{	O
swvarfs_u_close	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
return	O
-	O
3	int
;	O
}	O
if	O
(	O
S_ISLNK	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
s	pointer
=	O
ahsStaticGetTarLinkname	function
(	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
)	O
;	O
}	O
else	O
{	O
swvarfs_u_close	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
return	O
-	O
2	int
;	O
}	O
strncpy	function
(	O
buf	pointer
,	O
s	pointer
,	O
bufsize	int
)	O
;	O
buf	pointer
[	O
bufsize	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
>=	O
bufsize	int
-	O
1	int
)	O
{	O
ret	int
=	O
-	O
strlen	function
(	O
s	pointer
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
}	O
swvarfs_u_close	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
readlink	function
(	O
path	pointer
,	O
buf	pointer
,	O
bufsize	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"readlink (%s) : %s\n"	pointer
,	O
path	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
int	O
)	O
ret	int
>=	O
(	O
int	O
)	O
bufsize	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"readlink (%s) : linkname to long\n"	pointer
,	O
path	pointer
)	O
;	O
buf	pointer
[	O
bufsize	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
ret	int
=	O
-	O
ret	int
;	O
}	O
else	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"readlink (%s) : has empty linkname\n"	pointer
,	O
path	pointer
)	O
;	O
ret	int
=	O
-	O
1	int
;	O
*	O
buf	pointer
=	O
'\0'	O
;	O
}	O
else	O
{	O
buf	pointer
[	O
ret	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
swvarfs_vchdir	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
path	pointer
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
newvcwd	pointer
;	O
newvcwd	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
ret	int
=	O
construct_new_path_from_pathspec	function
(	O
swvarfs	pointer
,	O
newvcwd	pointer
,	O
path	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
set_vcwd	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
,	O
strob_str	function
(	O
newvcwd	pointer
)	O
)	O
;	O
ret	int
=	O
swvarfs_setdir	function
(	O
swvarfs	pointer
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
)	O
)	O
;	O
}	O
strob_close	function
(	O
newvcwd	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swvarfs_setdir	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
path	pointer
)	O
{	O
DIR	struct
*	O
dp	pointer
=	O
NULL	O
;	O
int	O
ret	int
=	O
0	int
;	O
if	O
(	O
(	O
path	pointer
==	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
||	O
strlen	function
(	O
path	pointer
)	O
==	O
0	int
)	O
&&	O
swvarfs	pointer
->	O
formatM	int
!=	O
UINFILE_FILESYSTEM	int
)	O
{	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
,	O
""	pointer
)	O
;	O
return	O
0	int
;	O
}	O
{	O
int	O
depth	pointer
=	O
0	int
;	O
swlib_resolve_path	function
(	O
path	pointer
,	O
&	O
depth	pointer
,	O
(	O
STROB	struct
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
depth	pointer
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
==	O
UINFILE_FILESYSTEM	int
)	O
{	O
if	O
(	O
is_name_in_scope	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
openpathM	pointer
)	O
,	O
path	pointer
,	O
(	O
struct	O
stat	struct
*	O
)	O
NULL	O
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"directory [%s] not in current scope of %s openpath=%s\n"	pointer
,	O
path	pointer
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
,	O
strob_str	function
(	O
swvarfs	pointer
->	O
openpathM	pointer
)	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
==	O
UINFILE_FILESYSTEM	int
)	O
{	O
struct	O
dirContext	struct
dirx	pointer
;	O
int	O
statrc	int
;	O
struct	O
stat	struct
stbuf	struct
;	O
dirx	pointer
.	O
statbuf	pointer
=	O
NULL	O
;	O
dirx	pointer
.	O
dirp	pointer
=	O
NULL	O
;	O
dirx	pointer
.	O
dp	pointer
=	O
NULL	O
;	O
dirx	pointer
.	O
ptr	pointer
=	O
NULL	O
;	O
clear_all_dir_context	function
(	O
swvarfs	pointer
)	O
;	O
statrc	int
=	O
stat	struct
(	O
path	pointer
,	O
&	O
stbuf	struct
)	O
;	O
if	O
(	O
statrc	int
||	O
S_ISDIR	O
(	O
stbuf	struct
.	O
st_mode	int
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swvarfs_setdir : %s : %s\n"	pointer
,	O
path	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
ret	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
swvarfs	pointer
->	O
stackixM	int
=	O
0	int
;	O
strob_strcpy	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
,	O
path	pointer
)	O
;	O
ret	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
dp	pointer
=	O
opendir	function
(	O
path	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : %s\n"	pointer
,	O
path	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
swvarfs	pointer
->	O
derrM	int
=	O
-	O
1	int
;	O
return	O
-	O
3	int
;	O
}	O
dirx	pointer
.	O
dp	pointer
=	O
dp	pointer
;	O
add_dir_context	function
(	O
swvarfs	pointer
,	O
&	O
dirx	pointer
)	O
;	O
ret	int
=	O
0	int
;	O
}	O
else	O
{	O
int	O
header_offset	long
;	O
intmax_t	long
old_pos	long
;	O
struct	O
fileChain	struct
*	O
existing	pointer
=	O
NULL	O
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
espipe	int
=	O
0	int
;	O
swvarfs	pointer
->	O
makefilechainM	int
=	O
1	int
;	O
swvarfs	pointer
->	O
current_filechainM	pointer
=	O
(	O
struct	O
fileChain	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
(	O
espipe	int
=	O
uxfio_espipe	function
(	O
swvarfs	pointer
->	O
fdM	int
)	O
)	O
)	O
{	O
;	O
}	O
else	O
{	O
if	O
(	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
)	O
{	O
SWBIS_E_FAIL	O
(	O
"uxfio_lseek error"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
strcmp	function
(	O
path	pointer
,	O
"."	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
path	pointer
,	O
"./"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
espipe	int
)	O
{	O
return	O
-	O
4	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
swvarfs_u_lstat	function
(	O
swvarfs	pointer
,	O
path	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
return	O
-	O
5	int
;	O
}	O
existing	pointer
=	O
swvarfs	pointer
->	O
current_filechainM	pointer
;	O
if	O
(	O
existing	pointer
==	O
(	O
struct	O
fileChain	struct
*	O
)	O
NULL	O
)	O
{	O
SWBIS_E_FAIL	O
(	O
"(struct fileChain*)existing is null. fatal."	pointer
)	O
;	O
return	O
-	O
6	int
;	O
}	O
old_pos	long
=	O
(	O
intmax_t	long
)	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
0	int
,	O
UXFIO_SEEK_VCUR	int
)	O
;	O
if	O
(	O
old_pos	long
<	O
0	int
)	O
{	O
SWBIS_E_FAIL2	O
(	O
"uxfio_lseek error ret = %d"	pointer
,	O
(	O
int	O
)	O
old_pos	long
)	O
;	O
return	O
-	O
7	int
;	O
}	O
header_offset	long
=	O
existing	pointer
->	O
header_offsetFC	int
;	O
if	O
(	O
header_offset	long
-	O
old_pos	long
>=	O
0	int
)	O
{	O
SWBIS_E_FAIL3	O
(	O
"internal error old_pos=%s  header_offset=%s"	pointer
,	O
swlib_imaxtostr	function
(	O
old_pos	long
,	O
NULL	O
)	O
,	O
swlib_imaxtostr	function
(	O
header_offset	long
,	O
NULL	O
)	O
)	O
;	O
return	O
-	O
8	int
;	O
}	O
if	O
(	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
header_offset	long
-	O
old_pos	long
,	O
UXFIO_SEEK_VCUR	int
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL	O
(	O
"uxfio_lseek error"	pointer
)	O
;	O
return	O
-	O
9	int
;	O
}	O
swvarfs_i_clear_filechain	function
(	O
swvarfs	pointer
)	O
;	O
ret	int
=	O
0	int
;	O
}	O
set_vcwd	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
,	O
path	pointer
)	O
;	O
set_dirscope	function
(	O
swvarfs	pointer
,	O
path	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swvarfs_u_lstat	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
==	O
UINFILE_FILESYSTEM	int
)	O
{	O
return	O
swvarfs_i_u_lstat_fs	function
(	O
swvarfs	pointer
,	O
path	pointer
,	O
st	pointer
)	O
;	O
}	O
else	O
{	O
return	O
swvarfs_i_u_lstat_archive	function
(	O
swvarfs	pointer
,	O
path	pointer
,	O
st	pointer
)	O
;	O
}	O
}	O
int	O
swvarfs_close	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
did_dupM	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"did_dupM: CLOSING swvarfs->fdM"	pointer
)	O
;	O
uxfio_close	function
(	O
swvarfs	pointer
->	O
fdM	int
)	O
;	O
}	O
else	O
{	O
SWVARFS_E_DEBUG	O
(	O
"did_dupM: NOT CLOSING swvarfs->fdM"	pointer
)	O
;	O
;	O
}	O
strob_close	function
(	O
swvarfs	pointer
->	O
opencwdpathM	pointer
)	O
;	O
strob_close	function
(	O
swvarfs	pointer
->	O
openpathM	pointer
)	O
;	O
strob_close	function
(	O
swvarfs	pointer
->	O
u_nameM	pointer
)	O
;	O
strob_close	function
(	O
swvarfs	pointer
->	O
tmpM	pointer
)	O
;	O
strob_close	function
(	O
swvarfs	pointer
->	O
dirscopeM	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
stackM	pointer
!=	O
(	O
STROB	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
strob_close	function
(	O
swvarfs	pointer
->	O
stackM	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
direntpathM	pointer
!=	O
(	O
STROB	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
strob_close	function
(	O
swvarfs	pointer
->	O
direntpathM	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
do_close_ahsM	int
)	O
ahs_close	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
uinformat_close_on_deleteM	int
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
ret	int
=	O
uinfile_close	function
(	O
swvarfs	pointer
->	O
format_descM	pointer
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
0	int
;	O
}	O
swvarfs_i_delete_filechain	function
(	O
swvarfs	pointer
)	O
;	O
hllist_close	function
(	O
swvarfs	pointer
->	O
link_recordM	pointer
)	O
;	O
taru_delete	function
(	O
swvarfs	pointer
->	O
taruM	pointer
)	O
;	O
swbis_free	O
(	O
swvarfs	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"LOWEST FD=%d"	pointer
,	O
show_nopen	function
(	O
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swvarfs_uxfio_fcntl	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
cmd	int
,	O
int	O
value	pointer
)	O
{	O
int	O
ret	int
;	O
if	O
(	O
swvarfs	pointer
->	O
fdM	int
>=	O
UXFIO_FD_MIN	int
)	O
{	O
ret	int
=	O
uxfio_fcntl	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
cmd	int
,	O
value	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
switch	O
(	O
cmd	int
)	O
{	O
case	O
UXFIO_F_SET_BUFTYPE	O
:	O
uxfio_fcntl	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
UXFIO_F_SET_BUFACTIVE	O
,	O
UXFIO_ON	int
)	O
;	O
swvarfs	pointer
->	O
uxfio_buftype	int
=	O
value	pointer
;	O
break	O
;	O
case	O
UXFIO_F_ARM_AUTO_DISABLE	O
:	O
if	O
(	O
value	pointer
)	O
{	O
swvarfs	pointer
->	O
uxfio_buftype	int
=	O
UXFIO_BUFTYPE_NOBUF	int
;	O
}	O
break	O
;	O
}	O
}	O
return	O
ret	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
struct	O
new_cpio_header	struct
*	O
swvarfs_header	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
return	O
ahs_vfile_hdr	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
;	O
}	O
AHS	struct
*	O
swvarfs_get_ahs	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
return	O
swvarfs	pointer
->	O
ahsM	pointer
;	O
}	O
void	O
swvarfs_set_ahs	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
AHS	struct
*	O
ahs	pointer
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
do_close_ahsM	int
)	O
ahs_close	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
;	O
swvarfs	pointer
->	O
ahsM	pointer
=	O
ahs	pointer
;	O
swvarfs	pointer
->	O
do_close_ahsM	int
=	O
0	int
;	O
}	O
int	O
swvarfs_fd	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
return	O
swvarfs	pointer
->	O
fdM	int
;	O
}	O
int	O
swvarfs_u_open	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
int	O
ret	int
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
SWVARFS_E_DEBUG2	O
(	O
"name = %s"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
ud_find_fd	function
(	O
swvarfs	pointer
,	O
-	O
1	int
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"too many open swvarfs:u_fd descriptors.\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
==	O
UINFILE_FILESYSTEM	int
)	O
{	O
ret	int
=	O
swvarfs_i_u_open_fs	function
(	O
swvarfs	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
swvarfs_i_u_open_archive	function
(	O
swvarfs	pointer
,	O
name	pointer
)	O
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swvarfs_u_close	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
ret	int
;	O
int	O
u_index	int
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
==	O
UINFILE_FILESYSTEM	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
"file system"	pointer
)	O
;	O
if	O
(	O
(	O
u_index	int
=	O
ud_find_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
)	O
<	O
0	int
)	O
{	O
SWBIS_E_FAIL3	O
(	O
"close error, expecting desc=%d. given=%d\n"	pointer
,	O
swvarfs	pointer
->	O
u_fdM	int
,	O
fd	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fd	int
!=	O
swvarfs	pointer
->	O
u_fdM	int
&&	O
fd	int
!=	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_fdM	int
)	O
{	O
SWBIS_E_FAIL3	O
(	O
"close error, expecting desc=%d. given=%d\n"	pointer
,	O
swvarfs	pointer
->	O
u_fdM	int
,	O
fd	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_linkname_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_linkname_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_linkname_	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
g_linkname_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
g_linkname_	pointer
)	O
;	O
swvarfs	pointer
->	O
g_linkname_	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_current_name_	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
{	O
swbis_free	O
(	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
)	O
;	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
=	O
NULL	O
;	O
}	O
ud_unset_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
swvarfs	pointer
->	O
u_fdM	int
=	O
-	O
1	int
;	O
ret	int
=	O
uxfio_close	function
(	O
fd	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
else	O
{	O
SWVARFS_E_DEBUG	O
(	O
"archive"	pointer
)	O
;	O
ret	int
=	O
swvarfs_i_u_close_archive	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"LEAVING"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
}	O
int	O
swvarfs_u_usr_stat	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
,	O
int	O
ofd	int
)	O
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
linkname	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
swvarfs_u_fstat	function
(	O
swvarfs	pointer
,	O
fd	int
,	O
&	O
st	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
name	pointer
=	O
swvarfs_u_get_name	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
linkname	pointer
=	O
swvarfs_u_get_linkname	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
;	O
swlib_write_stats	function
(	O
name	pointer
,	O
linkname	pointer
,	O
&	O
st	pointer
,	O
0	int
,	O
""	pointer
,	O
ofd	int
,	O
(	O
STROB	struct
*	O
)	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
swvarfs_u_get_name	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
)	O
{	O
int	O
u_index	int
;	O
if	O
(	O
(	O
u_index	int
=	O
ud_find_fd	function
(	O
swvarfs	pointer
,	O
fd	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swvarfs invalid file descriptor %d.\n"	pointer
,	O
fd	int
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
swvarfs	pointer
->	O
u_fd_setM	array
[	O
u_index	int
]	O
.	O
u_current_name_	pointer
;	O
}	O
char	O
*	O
swvarfs_u_get_linkname	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
)	O
{	O
if	O
(	O
fd	int
!=	O
swvarfs	pointer
->	O
u_fdM	int
)	O
{	O
SWBIS_E_FAIL2	O
(	O
"error, expecting %d.\n"	pointer
,	O
swvarfs	pointer
->	O
u_fdM	int
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
swvarfs	pointer
->	O
g_linkname_	pointer
;	O
}	O
int	O
swvarfs_u_fstat	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
fd	int
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
uxfio_fstat	function
(	O
fd	int
,	O
st	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swvarfs_stop_function	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
(	O
*	O
fc	pointer
)	O
(	O
void	O
*	O
,	O
char	O
*	O
,	O
char	O
*	O
)	O
)	O
{	O
swvarfs	pointer
->	O
f_do_stop_	pointer
=	O
fc	pointer
;	O
}	O
int	O
swvarfs_dirent_reset	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
==	O
UINFILE_FILESYSTEM	int
)	O
{	O
;	O
}	O
else	O
{	O
uxfio_lseek	function
(	O
swvarfs	pointer
->	O
fdM	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
;	O
swvarfs	pointer
->	O
eoaM	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
swvarfs_get_next_dirent	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
tartype	int
;	O
int	O
is_at_end	int
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
s	pointer
;	O
SWVARFS_E_DEBUG	O
(	O
"ENTERING"	pointer
)	O
;	O
if	O
(	O
swvarfs	pointer
->	O
formatM	int
==	O
UINFILE_FILESYSTEM	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
name	pointer
=	O
swvarfs_get_next_dirent_fs	function
(	O
swvarfs	pointer
,	O
st	pointer
)	O
;	O
is_at_end	int
=	O
0	int
;	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
else	O
{	O
int	O
*	O
peoa	pointer
=	O
&	O
(	O
swvarfs	pointer
->	O
eoaM	int
)	O
;	O
SWVARFS_E_DEBUG	O
(	O
"entering swvarfs_get_next_dirent_archive_NEW"	pointer
)	O
;	O
name	pointer
=	O
swvarfs_get_next_dirent_archive_NEW	function
(	O
swvarfs	pointer
,	O
st	pointer
,	O
peoa	pointer
)	O
;	O
is_at_end	int
=	O
*	O
peoa	pointer
;	O
SWVARFS_E_DEBUG2	O
(	O
"SWVARFS (ARCHIVE) EOA=[%d]"	pointer
,	O
*	O
peoa	pointer
)	O
;	O
}	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
is_at_end	int
==	O
0	int
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
tartype	int
=	O
ahs_get_tar_typeflag	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
;	O
if	O
(	O
tartype	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unrecognized file type [%d] for file: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
tartype	int
,	O
name	pointer
?	O
name	pointer
:	O
"<null>"	pointer
)	O
;	O
set_vcwd	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
,	O
name	pointer
?	O
name	pointer
:	O
""	pointer
)	O
;	O
}	O
else	O
if	O
(	O
tartype	int
==	O
DIRTYPE	char
)	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
set_vcwd	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
,	O
name	pointer
?	O
name	pointer
:	O
""	pointer
)	O
;	O
}	O
else	O
{	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
set_vcwd	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
,	O
name	pointer
?	O
name	pointer
:	O
""	pointer
)	O
;	O
if	O
(	O
(	O
s	pointer
=	O
strrchr	function
(	O
strob_str	function
(	O
swvarfs	pointer
->	O
vcwdM	pointer
)	O
,	O
'/'	O
)	O
)	O
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
}	O
}	O
SWVARFS_E_DEBUG	O
(	O
""	pointer
)	O
;	O
}	O
else	O
{	O
SWVARFS_E_DEBUG2	O
(	O
"GOT EOA [%d]"	pointer
,	O
is_at_end	int
)	O
;	O
name	pointer
=	O
NULL	O
;	O
;	O
}	O
SWVARFS_E_DEBUG2	O
(	O
"LEAVING !!!!!!!!!!!!!!! [%s]"	pointer
,	O
name	pointer
?	O
name	pointer
:	O
"<nil>"	pointer
)	O
;	O
return	O
name	pointer
;	O
}	O
int	O
swvarfs_dirent_err	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
return	O
swvarfs	pointer
->	O
derrM	int
;	O
}	O
HLLIST	struct
*	O
swvarfs_get_hllist	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
return	O
swvarfs	pointer
->	O
link_recordM	pointer
;	O
}	O
int	O
swvarfs_get_format	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
return	O
swvarfs	pointer
->	O
formatM	int
;	O
}	O
int	O
swvarfs_file_has_data	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
int	O
type	enum
=	O
ahs_get_tar_typeflag	function
(	O
swvarfs	pointer
->	O
ahsM	pointer
)	O
;	O
return	O
(	O
type	enum
==	O
REGTYPE	char
)	O
;	O
}	O
void	O
swvarfs_set_stat_syscall	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'l'	O
)	O
{	O
swvarfs	pointer
->	O
f_statM	pointer
=	O
(	O
int	O
(	O
*	O
)	O
(	O
char	O
*	O
,	O
struct	O
stat	struct
*	O
)	O
)	O
lstat	function
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
's'	O
)	O
{	O
swvarfs	pointer
->	O
f_statM	pointer
=	O
(	O
int	O
(	O
*	O
)	O
(	O
char	O
*	O
,	O
struct	O
stat	struct
*	O
)	O
)	O
stat	struct
;	O
}	O
}	O
char	O
*	O
swvarfs_get_stat_syscall	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
if	O
(	O
swvarfs	pointer
->	O
f_statM	pointer
==	O
(	O
int	O
(	O
*	O
)	O
(	O
char	O
*	O
,	O
struct	O
stat	struct
*	O
)	O
)	O
lstat	function
)	O
{	O
return	O
SWVARFS_VSTAT_LSTAT	pointer
;	O
}	O
else	O
if	O
(	O
swvarfs	pointer
->	O
f_statM	pointer
==	O
(	O
int	O
(	O
*	O
)	O
(	O
char	O
*	O
,	O
struct	O
stat	struct
*	O
)	O
)	O
stat	struct
)	O
{	O
return	O
SWVARFS_VSTAT_STAT	pointer
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swvarfs: fatal error in swvarfs_get_stat_syscall\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
int	O
swvarfs_get_tarheader_flags	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
)	O
{	O
return	O
swvarfs	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
;	O
}	O
void	O
swvarfs_set_tarheader_flags	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
flags	int
)	O
{	O
swvarfs	pointer
->	O
taruM	pointer
->	O
taru_tarheaderflagsM	int
=	O
flags	int
;	O
}	O
void	O
swvarfs_set_tarheader_flag	function
(	O
SWVARFS	struct
*	O
swvarfs	pointer
,	O
int	O
flag	int
,	O
int	O
n	long
)	O
{	O
taru_set_tarheader_flag	function
(	O
swvarfs	pointer
->	O
taruM	pointer
,	O
flag	int
,	O
n	long
)	O
;	O
}	O
