extern	O
int	O
vnStates	int
;	O
extern	O
int	O
vnOutputs	int
;	O
extern	O
int	O
vnModelVars	int
;	O
extern	O
int	O
vnInputs	int
;	O
extern	O
int	O
vnParms	int
;	O
extern	O
double	O
vrgModelVars	array
[	O
]	O
;	O
extern	O
IFN	struct
vrgInputs	array
[	O
]	O
;	O
extern	O
VMMAPSTRCT	struct
vrgvmGlo	array
[	O
]	O
;	O
BOOL	int
vbModelReinitd	int
=	O
FALSE	int
;	O
void	O
FixupDependentInputs	function
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vnInputs	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hMag	long
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dMag	double
=	O
GetVarValue	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hMag	long
)	O
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hTper	long
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
=	O
GetVarValue	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hTper	long
)	O
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hT0	long
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dT0	double
=	O
GetVarValue	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hT0	long
)	O
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hTexp	long
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTexp	double
=	O
GetVarValue	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hTexp	long
)	O
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hDecay	long
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dDecay	double
=	O
GetVarValue	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hDecay	long
)	O
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hNcpt	long
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dNcpt	double
=	O
GetVarValue	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
hNcpt	long
)	O
;	O
if	O
(	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_NDOSES	int
)	O
||	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_SPIKES	int
)	O
||	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_EVENTS	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
vrgInputs	array
[	O
i	int
]	O
.	O
nDoses	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
rghMags	pointer
[	O
j	int
]	O
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgMags	pointer
[	O
j	int
]	O
=	O
GetVarValue	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
rghMags	pointer
[	O
j	int
]	O
)	O
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
rghT0s	pointer
[	O
j	int
]	O
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgT0s	pointer
[	O
j	int
]	O
=	O
GetVarValue	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
rghT0s	pointer
[	O
j	int
]	O
)	O
;	O
if	O
(	O
j	int
>	O
0	int
)	O
{	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgT0s	pointer
[	O
j	int
]	O
<=	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgT0s	pointer
[	O
j	int
-	O
1	int
]	O
)	O
{	O
printf	function
(	O
"\nError: unordered pair of times (%g, %g) in %s "	pointer
"statement - Exiting\n"	pointer
,	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgT0s	pointer
[	O
j	int
-	O
1	int
]	O
,	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgT0s	pointer
[	O
j	int
]	O
,	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_NDOSES	int
?	O
"NDoses"	pointer
:	O
"Spikes"	pointer
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_PEREXP	int
)	O
||	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_PERTRANS	int
)	O
)	O
{	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTexp	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
;	O
}	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_PERTRANS	int
)	O
{	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
dNcpt	double
<=	O
0	int
)	O
{	O
printf	function
(	O
"\nError: null or negative number of virtual compartment "	pointer
"in PerTransit input function - Exiting\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTexp	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
;	O
}	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTexp	double
>=	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTexp	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_NDOSES	int
||	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_SPIKES	int
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dMag	double
=	O
1.0	int
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_PERDOSE	int
||	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_PERTRANS	int
||	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_PEREXP	int
)	O
{	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTexp	double
==	O
0.0	int
||	O
vrgInputs	array
[	O
i	int
]	O
.	O
dT0	double
<	O
0.0	int
||	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
<	O
0.0	int
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dMag	double
=	O
0.0	int
;	O
}	O
}	O
}	O
void	O
GetStartPeriods	function
(	O
PDOUBLE	pointer
pdTime	pointer
)	O
{	O
int	O
i	int
;	O
double	O
dTmp	double
,	O
dDummy	double
;	O
if	O
(	O
*	O
pdTime	pointer
==	O
0.0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vnInputs	int
;	O
i	int
++	O
)	O
{	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTStartPeriod	double
=	O
0.0	int
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_NDOSES	int
||	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_SPIKES	int
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
=	O
0	int
;	O
}	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vnInputs	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_NDOSES	int
||	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
==	O
IFN_SPIKES	int
)	O
{	O
for	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
=	O
0	int
;	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
<	O
vrgInputs	array
[	O
i	int
]	O
.	O
nDoses	int
;	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
++	O
)	O
if	O
(	O
*	O
pdTime	pointer
<	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgT0s	pointer
[	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
]	O
)	O
break	O
;	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
--	O
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
<	O
0	int
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
==	O
0.0	int
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTStartPeriod	double
=	O
0.0	int
;	O
else	O
{	O
dTmp	double
=	O
(	O
*	O
pdTime	pointer
/	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
)	O
;	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTStartPeriod	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTper	double
*	O
modf	function
(	O
dTmp	double
,	O
&	O
dDummy	double
)	O
;	O
}	O
}	O
}	O
}	O
void	O
UpdateNDoses	function
(	O
PIFN	pointer
pifn	pointer
,	O
PDOUBLE	pointer
pdTnext	pointer
,	O
PDOUBLE	pointer
pdTime	pointer
)	O
{	O
int	O
j	int
;	O
j	int
=	O
pifn	pointer
->	O
iDoseCur	int
;	O
if	O
(	O
j	int
<	O
pifn	pointer
->	O
nDoses	int
)	O
{	O
*	O
pdTnext	pointer
=	O
pifn	pointer
->	O
rgT0s	pointer
[	O
j	int
]	O
;	O
pifn	pointer
->	O
bOn	int
=	O
(	O
*	O
pdTime	pointer
>=	O
*	O
pdTnext	pointer
)	O
;	O
if	O
(	O
pifn	pointer
->	O
bOn	int
)	O
{	O
*	O
pdTnext	pointer
=	O
pifn	pointer
->	O
rgT0s	pointer
[	O
j	int
+	O
1	int
]	O
;	O
pifn	pointer
->	O
bOn	int
=	O
(	O
*	O
pdTime	pointer
<	O
*	O
pdTnext	pointer
)	O
;	O
if	O
(	O
!	O
pifn	pointer
->	O
bOn	int
)	O
if	O
(	O
++	O
pifn	pointer
->	O
iDoseCur	int
<	O
pifn	pointer
->	O
nDoses	int
)	O
{	O
*	O
pdTnext	pointer
=	O
pifn	pointer
->	O
rgT0s	pointer
[	O
pifn	pointer
->	O
iDoseCur	int
+	O
1	int
]	O
;	O
pifn	pointer
->	O
bOn	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
else	O
*	O
pdTnext	pointer
=	O
DBL_MAX	O
;	O
if	O
(	O
!	O
pifn	pointer
->	O
bOn	int
)	O
pifn	pointer
->	O
dVal	double
=	O
0.0	int
;	O
}	O
BOOL	int
UpdateSpikes	function
(	O
PIFN	pointer
pifn	pointer
,	O
PDOUBLE	pointer
pdTnext	pointer
,	O
PDOUBLE	pointer
pdTime	pointer
)	O
{	O
register	O
double	O
*	O
rgT0s	pointer
=	O
pifn	pointer
->	O
rgT0s	pointer
;	O
register	O
int	O
j	int
=	O
pifn	pointer
->	O
iDoseCur	int
;	O
*	O
pdTnext	pointer
=	O
DBL_MAX	O
;	O
pifn	pointer
->	O
bOn	int
=	O
FALSE	int
;	O
if	O
(	O
j	int
<	O
pifn	pointer
->	O
nDoses	int
)	O
{	O
if	O
(	O
*	O
pdTime	pointer
<	O
rgT0s	pointer
[	O
j	int
]	O
)	O
*	O
pdTnext	pointer
=	O
rgT0s	pointer
[	O
j	int
]	O
;	O
else	O
if	O
(	O
*	O
pdTime	pointer
==	O
rgT0s	pointer
[	O
j	int
]	O
)	O
{	O
pifn	pointer
->	O
bOn	int
=	O
TRUE	int
;	O
if	O
(	O
j	int
+	O
1	int
<	O
pifn	pointer
->	O
nDoses	int
)	O
*	O
pdTnext	pointer
=	O
rgT0s	pointer
[	O
j	int
+	O
1	int
]	O
;	O
}	O
else	O
printf	function
(	O
"\nUpdateSpikes: Discontinuity was passed over\n"	pointer
)	O
;	O
}	O
return	O
(	O
pifn	pointer
->	O
bOn	int
)	O
;	O
}	O
void	O
UpdateDefaultInput	function
(	O
PIFN	pointer
pifn	pointer
,	O
PDOUBLE	pointer
pdTnext	pointer
,	O
PDOUBLE	pointer
pdTime	pointer
)	O
{	O
*	O
pdTnext	pointer
=	O
pifn	pointer
->	O
dTStartPeriod	double
+	O
pifn	pointer
->	O
dT0	double
;	O
pifn	pointer
->	O
bOn	int
=	O
(	O
*	O
pdTime	pointer
>=	O
*	O
pdTnext	pointer
)	O
;	O
if	O
(	O
pifn	pointer
->	O
bOn	int
)	O
{	O
*	O
pdTnext	pointer
+=	O
pifn	pointer
->	O
dTexp	double
;	O
pifn	pointer
->	O
bOn	int
=	O
(	O
*	O
pdTime	pointer
<	O
*	O
pdTnext	pointer
)	O
&&	O
(	O
(	O
*	O
pdTnext	pointer
-	O
*	O
pdTime	pointer
)	O
>	O
DBL_EPSILON	O
*	O
2.0	int
*	O
(	O
*	O
pdTnext	pointer
)	O
)	O
;	O
if	O
(	O
!	O
pifn	pointer
->	O
bOn	int
)	O
{	O
if	O
(	O
pifn	pointer
->	O
dTper	double
!=	O
0.0	int
)	O
*	O
pdTnext	pointer
=	O
(	O
pifn	pointer
->	O
dTStartPeriod	double
+=	O
pifn	pointer
->	O
dTper	double
)	O
;	O
else	O
*	O
pdTnext	pointer
=	O
pifn	pointer
->	O
dTStartPeriod	double
=	O
DBL_MAX	O
-	O
pifn	pointer
->	O
dTper	double
;	O
}	O
}	O
if	O
(	O
!	O
pifn	pointer
->	O
bOn	int
)	O
pifn	pointer
->	O
dVal	double
=	O
0.0	int
;	O
else	O
pifn	pointer
->	O
dVal	double
=	O
pifn	pointer
->	O
dMag	double
;	O
}	O
void	O
UpdateInputs	function
(	O
PDOUBLE	pointer
pdTime	pointer
,	O
PDOUBLE	pointer
pdNextTransTime	pointer
)	O
{	O
double	O
dT	double
;	O
int	O
i	int
,	O
j	int
,	O
stateID	int
;	O
if	O
(	O
vbModelReinitd	int
)	O
{	O
ScaleModel	function
(	O
pdTime	pointer
)	O
;	O
FixupDependentInputs	function
(	O
)	O
;	O
GetStartPeriods	function
(	O
pdTime	pointer
)	O
;	O
}	O
dT	double
=	O
*	O
pdNextTransTime	pointer
=	O
DBL_MAX	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vnInputs	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
)	O
{	O
case	O
IFN_CONSTANT	int
:	O
break	O
;	O
case	O
IFN_NDOSES	int
:	O
UpdateNDoses	function
(	O
&	O
vrgInputs	array
[	O
i	int
]	O
,	O
&	O
dT	double
,	O
pdTime	pointer
)	O
;	O
break	O
;	O
case	O
IFN_EVENTS	int
:	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
bOn	int
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
++	O
;	O
UpdateSpikes	function
(	O
&	O
vrgInputs	array
[	O
i	int
]	O
,	O
&	O
dT	double
,	O
pdTime	pointer
)	O
;	O
j	int
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
;	O
stateID	int
=	O
HINDEX	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
target_state	long
)	O
;	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
bOn	int
&&	O
(	O
j	int
<	O
vrgInputs	array
[	O
i	int
]	O
.	O
nDoses	int
)	O
)	O
vrgModelVars	array
[	O
stateID	int
]	O
=	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgOper	pointer
[	O
j	int
]	O
==	O
KM_REPLACE	int
?	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgMags	pointer
[	O
j	int
]	O
:	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgOper	pointer
[	O
j	int
]	O
==	O
KM_ADD	int
?	O
vrgModelVars	array
[	O
stateID	int
]	O
+	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgMags	pointer
[	O
j	int
]	O
:	O
vrgModelVars	array
[	O
stateID	int
]	O
*	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgMags	pointer
[	O
j	int
]	O
)	O
;	O
break	O
;	O
case	O
IFN_SPIKES	int
:	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
bOn	int
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
++	O
;	O
UpdateSpikes	function
(	O
&	O
vrgInputs	array
[	O
i	int
]	O
,	O
&	O
dT	double
,	O
pdTime	pointer
)	O
;	O
break	O
;	O
default	O
:	O
case	O
IFN_PERDOSE	int
:	O
case	O
IFN_PEREXP	int
:	O
case	O
IFN_PERTRANS	int
:	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
dMag	double
!=	O
0.0	int
)	O
UpdateDefaultInput	function
(	O
&	O
vrgInputs	array
[	O
i	int
]	O
,	O
&	O
dT	double
,	O
pdTime	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
dT	double
<	O
*	O
pdNextTransTime	pointer
)	O
*	O
pdNextTransTime	pointer
=	O
dT	double
;	O
}	O
if	O
(	O
vbModelReinitd	int
)	O
{	O
vbModelReinitd	int
=	O
FALSE	int
;	O
}	O
}	O
PVMMAPSTRCT	pointer
GetVarPtr	function
(	O
PVMMAPSTRCT	pointer
pvm	pointer
,	O
PSTR	pointer
szName	pointer
)	O
{	O
while	O
(	O
*	O
pvm	pointer
->	O
szName	pointer
&&	O
MyStrcmp	function
(	O
szName	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
)	O
pvm	pointer
++	O
;	O
return	O
(	O
*	O
pvm	pointer
->	O
szName	pointer
?	O
pvm	pointer
:	O
NULL	O
)	O
;	O
}	O
HVAR	long
GetVarHandle	function
(	O
PSTR	pointer
szName	pointer
)	O
{	O
PVMMAPSTRCT	pointer
pvm	pointer
=	O
GetVarPtr	function
(	O
vrgvmGlo	array
,	O
szName	pointer
)	O
;	O
return	O
(	O
pvm	pointer
?	O
pvm	pointer
->	O
hvar	long
:	O
ID_NULL	int
)	O
;	O
}	O
int	O
GetVarType	function
(	O
HVAR	long
hvar	long
)	O
{	O
BOOL	int
bOK	int
=	O
FALSE	int
;	O
switch	O
(	O
HTYPE	O
(	O
hvar	long
)	O
)	O
{	O
case	O
ID_INPUT	int
:	O
bOK	int
=	O
HINDEX	O
(	O
hvar	long
)	O
<	O
vnInputs	int
;	O
break	O
;	O
case	O
ID_STATE	int
:	O
bOK	int
=	O
HINDEX	O
(	O
hvar	long
)	O
<	O
vnStates	int
;	O
break	O
;	O
case	O
ID_OUTPUT	int
:	O
bOK	int
=	O
HINDEX	O
(	O
hvar	long
)	O
>=	O
vnStates	int
&&	O
HINDEX	O
(	O
hvar	long
)	O
<	O
vnModelVars	int
;	O
break	O
;	O
case	O
ID_PARM	int
:	O
{	O
int	O
nSOI	int
=	O
vnStates	int
+	O
vnOutputs	int
+	O
vnInputs	int
;	O
bOK	int
=	O
(	O
HINDEX	O
(	O
hvar	long
)	O
>=	O
nSOI	int
)	O
&&	O
(	O
HINDEX	O
(	O
hvar	long
)	O
<	O
nSOI	int
+	O
vnParms	int
)	O
;	O
break	O
;	O
}	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
bOK	int
?	O
HTYPE	O
(	O
hvar	long
)	O
:	O
ID_NULL	int
)	O
;	O
}	O
char	O
*	O
GetVarName	function
(	O
HVAR	long
hvar	long
)	O
{	O
static	O
char	O
szInvalid	array
[	O
]	O
=	O
"InvalidVariable?"	pointer
;	O
PVMMAPSTRCT	pointer
pvm	pointer
=	O
vrgvmGlo	array
;	O
while	O
(	O
*	O
pvm	pointer
->	O
szName	pointer
&&	O
hvar	long
!=	O
pvm	pointer
->	O
hvar	long
)	O
pvm	pointer
++	O
;	O
return	O
(	O
*	O
pvm	pointer
->	O
szName	pointer
?	O
pvm	pointer
->	O
szName	pointer
:	O
szInvalid	array
)	O
;	O
}	O
double	O
GetVarValue	function
(	O
HVAR	long
hvar	long
)	O
{	O
double	O
dReturn	double
=	O
0.0	int
;	O
switch	O
(	O
GetVarType	function
(	O
hvar	long
)	O
)	O
{	O
case	O
ID_INPUT	int
:	O
dReturn	double
=	O
vrgInputs	array
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
.	O
dVal	double
;	O
break	O
;	O
case	O
ID_OUTPUT	int
:	O
case	O
ID_STATE	int
:	O
dReturn	double
=	O
vrgModelVars	array
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
;	O
break	O
;	O
case	O
ID_PARM	int
:	O
{	O
PVMMAPSTRCT	pointer
pvm	pointer
;	O
pvm	pointer
=	O
&	O
vrgvmGlo	array
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
;	O
dReturn	double
=	O
*	O
(	O
PDOUBLE	pointer
)	O
pvm	pointer
->	O
pVar	pointer
;	O
break	O
;	O
}	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
dReturn	double
)	O
;	O
}	O
BOOL	int
IsInput	function
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
GetVarType	function
(	O
hvar	long
)	O
==	O
ID_INPUT	int
)	O
;	O
}	O
BOOL	int
IsState	function
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
GetVarType	function
(	O
hvar	long
)	O
==	O
ID_STATE	int
)	O
;	O
}	O
BOOL	int
IsOutput	function
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
GetVarType	function
(	O
hvar	long
)	O
==	O
ID_OUTPUT	int
)	O
;	O
}	O
BOOL	int
IsModelVar	function
(	O
HVAR	long
hvar	long
)	O
{	O
int	O
iType	int
=	O
GetVarType	function
(	O
hvar	long
)	O
;	O
return	O
(	O
iType	int
==	O
ID_STATE	int
||	O
iType	int
==	O
ID_OUTPUT	int
)	O
;	O
}	O
BOOL	int
IsParm	function
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
GetVarType	function
(	O
hvar	long
)	O
==	O
ID_PARM	int
)	O
;	O
}	O
int	O
ModelIndex	function
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
IsModelVar	function
(	O
hvar	long
)	O
?	O
HINDEX	O
(	O
hvar	long
)	O
:	O
0	int
)	O
;	O
}	O
BOOL	int
SetVar	function
(	O
HVAR	long
hvar	long
,	O
double	O
dVal	double
)	O
{	O
BOOL	int
bReturn	int
=	O
TRUE	int
;	O
switch	O
(	O
GetVarType	function
(	O
hvar	long
)	O
)	O
{	O
default	O
:	O
case	O
ID_INPUT	int
:	O
bReturn	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
ID_OUTPUT	int
:	O
case	O
ID_STATE	int
:	O
vrgModelVars	array
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
=	O
dVal	double
;	O
break	O
;	O
case	O
ID_PARM	int
:	O
{	O
PVMMAPSTRCT	pointer
pvm	pointer
=	O
&	O
vrgvmGlo	array
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
;	O
*	O
(	O
PDOUBLE	pointer
)	O
pvm	pointer
->	O
pVar	pointer
=	O
dVal	double
;	O
break	O
;	O
}	O
}	O
return	O
(	O
bReturn	int
)	O
;	O
}	O
BOOL	int
SetInput	function
(	O
HVAR	long
hvar	long
,	O
PIFN	pointer
pifn	pointer
)	O
{	O
if	O
(	O
!	O
pifn	pointer
||	O
!	O
IsInput	function
(	O
hvar	long
)	O
)	O
return	O
(	O
FALSE	int
)	O
;	O
memcpy	function
(	O
&	O
vrgInputs	array
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
,	O
pifn	pointer
,	O
sizeof	O
(	O
IFN	struct
)	O
)	O
;	O
return	O
(	O
TRUE	int
)	O
;	O
}	O
PDOUBLE	pointer
GetModelVector	function
(	O
void	O
)	O
{	O
return	O
(	O
(	O
PDOUBLE	pointer
)	O
vrgModelVars	array
)	O
;	O
}	O
int	O
GetNModelVars	function
(	O
void	O
)	O
{	O
return	O
(	O
vnModelVars	int
)	O
;	O
}	O
int	O
GetNStates	function
(	O
void	O
)	O
{	O
return	O
(	O
vnStates	int
)	O
;	O
}	O
void	O
CalcInputs	function
(	O
PDOUBLE	pointer
pdTime	pointer
)	O
{	O
int	O
i	int
;	O
double	O
dTmp	double
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vnInputs	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
!=	O
IFN_CONSTANT	int
)	O
&&	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
bOn	int
||	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
!=	O
IFN_SPIKES	int
)	O
)	O
)	O
{	O
switch	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iType	int
)	O
{	O
case	O
IFN_CONSTANT	int
:	O
break	O
;	O
case	O
IFN_NDOSES	int
:	O
if	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
<	O
vrgInputs	array
[	O
i	int
]	O
.	O
nDoses	int
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dVal	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgMags	pointer
[	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
]	O
*	O
vrgInputs	array
[	O
i	int
]	O
.	O
dMag	double
;	O
break	O
;	O
case	O
IFN_PERDOSE	int
:	O
break	O
;	O
case	O
IFN_PEREXP	int
:	O
vrgInputs	array
[	O
i	int
]	O
.	O
dVal	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
dMag	double
*	O
(	O
(	O
int	O
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
bOn	int
)	O
*	O
exp	function
(	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTStartPeriod	double
+	O
vrgInputs	array
[	O
i	int
]	O
.	O
dT0	double
-	O
*	O
pdTime	pointer
)	O
*	O
vrgInputs	array
[	O
i	int
]	O
.	O
dDecay	double
)	O
;	O
break	O
;	O
case	O
IFN_PERTRANS	int
:	O
dTmp	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
dDecay	double
*	O
(	O
*	O
pdTime	pointer
-	O
vrgInputs	array
[	O
i	int
]	O
.	O
dTStartPeriod	double
-	O
vrgInputs	array
[	O
i	int
]	O
.	O
dT0	double
)	O
;	O
vrgInputs	array
[	O
i	int
]	O
.	O
dVal	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
dMag	double
*	O
(	O
(	O
int	O
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
bOn	int
)	O
*	O
pow	function
(	O
dTmp	double
,	O
vrgInputs	array
[	O
i	int
]	O
.	O
dNcpt	double
)	O
*	O
exp	function
(	O
-	O
dTmp	double
)	O
/	O
(	O
SQRT2PI	int
*	O
pow	function
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
dNcpt	double
,	O
vrgInputs	array
[	O
i	int
]	O
.	O
dNcpt	double
+	O
0.5	int
)	O
*	O
exp	function
(	O
-	O
vrgInputs	array
[	O
i	int
]	O
.	O
dNcpt	double
)	O
)	O
;	O
break	O
;	O
case	O
IFN_SPIKES	int
:	O
if	O
(	O
(	O
*	O
pdTime	pointer
==	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgT0s	pointer
[	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
]	O
)	O
&&	O
(	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
<	O
vrgInputs	array
[	O
i	int
]	O
.	O
nDoses	int
)	O
)	O
vrgInputs	array
[	O
i	int
]	O
.	O
dVal	double
=	O
vrgInputs	array
[	O
i	int
]	O
.	O
rgMags	pointer
[	O
vrgInputs	array
[	O
i	int
]	O
.	O
iDoseCur	int
]	O
*	O
vrgInputs	array
[	O
i	int
]	O
.	O
dMag	double
;	O
else	O
vrgInputs	array
[	O
i	int
]	O
.	O
dVal	double
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
void	O
DumpSymbolTable	function
(	O
char	O
*	O
szFilename	pointer
)	O
{	O
static	O
char	O
szStderr	array
[	O
]	O
=	O
"<stdout>"	pointer
;	O
FILE	struct
*	O
pfile	pointer
;	O
PVMMAPSTRCT	pointer
pvm	pointer
=	O
&	O
vrgvmGlo	array
[	O
0	int
]	O
;	O
if	O
(	O
szFilename	pointer
)	O
pfile	pointer
=	O
fopen	function
(	O
szFilename	pointer
,	O
"a"	pointer
)	O
;	O
else	O
{	O
pfile	pointer
=	O
stdout	pointer
;	O
szFilename	pointer
=	O
szStderr	array
;	O
}	O
if	O
(	O
!	O
pfile	pointer
)	O
{	O
printf	function
(	O
"Cannot dump symbol table to %s\n"	pointer
,	O
szFilename	pointer
)	O
;	O
return	O
;	O
}	O
fprintf	function
(	O
pfile	pointer
,	O
"\nSymbol Table:\n"	pointer
)	O
;	O
if	O
(	O
!	O
pvm	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"<null>\n"	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
*	O
pvm	pointer
->	O
szName	pointer
)	O
{	O
fprintf	function
(	O
pfile	pointer
,	O
"%s \t= "	pointer
,	O
pvm	pointer
->	O
szName	pointer
)	O
;	O
if	O
(	O
IsInput	function
(	O
pvm	pointer
->	O
hvar	long
)	O
)	O
{	O
PIFN	pointer
pifn	pointer
=	O
(	O
PIFN	pointer
)	O
pvm	pointer
->	O
pVar	pointer
;	O
fprintf	function
(	O
pfile	pointer
,	O
"Mag=%g [Val=%g]\n"	pointer
,	O
pifn	pointer
->	O
dMag	double
,	O
pifn	pointer
->	O
dVal	double
)	O
;	O
}	O
else	O
fprintf	function
(	O
pfile	pointer
,	O
"%g\n"	pointer
,	O
*	O
(	O
double	O
*	O
)	O
pvm	pointer
->	O
pVar	pointer
)	O
;	O
pvm	pointer
++	O
;	O
}	O
if	O
(	O
szFilename	pointer
!=	O
szStderr	array
)	O
fclose	function
(	O
pfile	pointer
)	O
;	O
}	O
void	O
GetStateHandles	function
(	O
HVAR	long
*	O
phvar	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
VMMAPSTRCT	struct
*	O
pvm	pointer
=	O
vrgvmGlo	array
;	O
while	O
(	O
pvm	pointer
->	O
pVar	pointer
)	O
{	O
if	O
(	O
IsState	function
(	O
pvm	pointer
->	O
hvar	long
)	O
)	O
phvar	pointer
[	O
i	int
++	O
]	O
=	O
pvm	pointer
->	O
hvar	long
;	O
++	O
pvm	pointer
;	O
}	O
;	O
}	O
