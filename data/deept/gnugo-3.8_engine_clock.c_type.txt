static	O
int	O
level	int
=	O
DEFAULT_LEVEL	int
;	O
static	O
int	O
level_offset	int
=	O
0	int
;	O
static	O
int	O
min_level	int
=	O
0	int
;	O
static	O
int	O
max_level	int
=	O
gg_max	O
(	O
DEFAULT_LEVEL	int
,	O
10	int
)	O
;	O
static	O
int	O
main_time	int
=	O
-	O
1	int
;	O
static	O
int	O
byoyomi_time	int
=	O
-	O
1	int
;	O
static	O
int	O
byoyomi_stones	int
=	O
-	O
1	int
;	O
struct	O
remaining_time_data	struct
{	O
double	O
time_left	int
;	O
double	O
time_for_last_move	double
;	O
int	O
stones	pointer
;	O
int	O
movenum	int
;	O
int	O
in_byoyomi	int
;	O
}	O
;	O
struct	O
timer_data	struct
{	O
struct	O
remaining_time_data	struct
official	struct
;	O
struct	O
remaining_time_data	struct
estimated	struct
;	O
int	O
time_out	int
;	O
}	O
;	O
static	O
struct	O
timer_data	struct
black_time_data	struct
;	O
static	O
struct	O
timer_data	struct
white_time_data	struct
;	O
static	O
void	O
timeval_print	function
(	O
FILE	struct
*	O
outfile	pointer
,	O
double	O
tv	double
)	O
{	O
int	O
min	int
;	O
double	O
sec	double
;	O
min	int
=	O
(	O
int	O
)	O
tv	double
/	O
60	int
;	O
sec	double
=	O
tv	double
-	O
min	int
*	O
60	int
;	O
fprintf	function
(	O
outfile	pointer
,	O
"%3dmin %.2fsec "	pointer
,	O
min	int
,	O
sec	double
)	O
;	O
}	O
void	O
clock_print	function
(	O
int	O
color	int
)	O
{	O
struct	O
timer_data	struct
*	O
const	O
td	pointer
=	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
&	O
black_time_data	struct
:	O
&	O
white_time_data	struct
;	O
fprintf	function
(	O
stderr	pointer
,	O
"clock: "	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s "	pointer
,	O
color_to_string	function
(	O
color	int
)	O
)	O
;	O
if	O
(	O
td	pointer
->	O
time_out	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"TIME OUT! "	pointer
)	O
;	O
else	O
{	O
if	O
(	O
td	pointer
->	O
estimated	struct
.	O
in_byoyomi	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"byoyomi"	pointer
)	O
;	O
timeval_print	function
(	O
stderr	pointer
,	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"for %d stones."	pointer
,	O
td	pointer
->	O
estimated	struct
.	O
stones	pointer
)	O
;	O
}	O
else	O
timeval_print	function
(	O
stderr	pointer
,	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
void	O
clock_settings	function
(	O
int	O
time	function
,	O
int	O
byo_time	int
,	O
int	O
byo_stones	int
)	O
{	O
if	O
(	O
time	function
>=	O
0	int
)	O
main_time	int
=	O
time	function
;	O
if	O
(	O
byo_time	int
>=	O
0	int
)	O
byoyomi_time	int
=	O
byo_time	int
;	O
if	O
(	O
byo_stones	int
>=	O
0	int
)	O
byoyomi_stones	int
=	O
byo_stones	int
;	O
init_timers	function
(	O
)	O
;	O
}	O
int	O
have_time_settings	function
(	O
void	O
)	O
{	O
if	O
(	O
byoyomi_time	int
>	O
0	int
&&	O
byoyomi_stones	int
==	O
0	int
)	O
return	O
0	int
;	O
else	O
return	O
(	O
main_time	int
>=	O
0	int
||	O
byoyomi_time	int
>=	O
0	int
)	O
;	O
}	O
void	O
init_timers	function
(	O
)	O
{	O
white_time_data	struct
.	O
official	struct
.	O
time_left	int
=	O
main_time	int
;	O
white_time_data	struct
.	O
official	struct
.	O
time_for_last_move	double
=	O
-	O
1.0	int
;	O
white_time_data	struct
.	O
official	struct
.	O
stones	pointer
=	O
0	int
;	O
white_time_data	struct
.	O
official	struct
.	O
movenum	int
=	O
0	int
;	O
white_time_data	struct
.	O
official	struct
.	O
in_byoyomi	int
=	O
0	int
;	O
white_time_data	struct
.	O
estimated	struct
=	O
white_time_data	struct
.	O
official	struct
;	O
white_time_data	struct
.	O
time_out	int
=	O
0	int
;	O
black_time_data	struct
=	O
white_time_data	struct
;	O
level_offset	int
=	O
0	int
;	O
}	O
void	O
update_time_left	function
(	O
int	O
color	int
,	O
int	O
time_left	int
,	O
int	O
stones	pointer
)	O
{	O
struct	O
timer_data	struct
*	O
const	O
td	pointer
=	O
(	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
&	O
black_time_data	struct
:	O
&	O
white_time_data	struct
)	O
;	O
int	O
time_used	int
=	O
td	pointer
->	O
official	struct
.	O
time_left	int
-	O
time_left	int
;	O
if	O
(	O
time_left	int
>	O
0	int
)	O
td	pointer
->	O
time_out	int
=	O
0	int
;	O
else	O
td	pointer
->	O
time_out	int
=	O
1	int
;	O
if	O
(	O
time_used	int
>	O
0	int
&&	O
gg_abs	O
(	O
time_used	int
-	O
td	pointer
->	O
estimated	struct
.	O
time_for_last_move	double
)	O
>=	O
1.0	int
)	O
td	pointer
->	O
estimated	struct
.	O
time_for_last_move	double
=	O
time_used	int
;	O
td	pointer
->	O
estimated	struct
.	O
stones	pointer
=	O
stones	pointer
;	O
td	pointer
->	O
estimated	struct
.	O
movenum	int
=	O
movenum	int
;	O
if	O
(	O
gg_abs	O
(	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
-	O
time_left	int
)	O
>=	O
1.0	int
)	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
=	O
time_left	int
;	O
if	O
(	O
stones	pointer
>	O
0	int
)	O
td	pointer
->	O
estimated	struct
.	O
in_byoyomi	int
=	O
1	int
;	O
else	O
td	pointer
->	O
estimated	struct
.	O
in_byoyomi	int
=	O
0	int
;	O
td	pointer
->	O
official	struct
.	O
stones	pointer
=	O
stones	pointer
;	O
td	pointer
->	O
official	struct
.	O
movenum	int
=	O
movenum	int
;	O
td	pointer
->	O
official	struct
.	O
time_for_last_move	double
=	O
td	pointer
->	O
official	struct
.	O
time_for_last_move	double
-	O
time_left	int
;	O
td	pointer
->	O
official	struct
.	O
time_left	int
=	O
time_left	int
;	O
td	pointer
->	O
official	struct
.	O
in_byoyomi	int
=	O
td	pointer
->	O
estimated	struct
.	O
in_byoyomi	int
;	O
}	O
void	O
clock_push_button	function
(	O
int	O
color	int
)	O
{	O
static	O
double	O
last_time	double
=	O
-	O
1.0	int
;	O
static	O
int	O
last_movenum	int
=	O
-	O
1	int
;	O
struct	O
timer_data	struct
*	O
const	O
td	pointer
=	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
&	O
black_time_data	struct
:	O
&	O
white_time_data	struct
;	O
double	O
now	double
=	O
gg_gettimeofday	function
(	O
)	O
;	O
if	O
(	O
!	O
have_time_settings	function
(	O
)	O
)	O
return	O
;	O
if	O
(	O
last_movenum	int
>=	O
0	int
&&	O
movenum	int
==	O
last_movenum	int
+	O
1	int
&&	O
movenum	int
>	O
td	pointer
->	O
estimated	struct
.	O
movenum	int
)	O
{	O
double	O
time_used	int
=	O
now	double
-	O
last_time	double
;	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
-=	O
time_used	int
;	O
td	pointer
->	O
estimated	struct
.	O
movenum	int
=	O
movenum	int
;	O
td	pointer
->	O
estimated	struct
.	O
time_for_last_move	double
=	O
time_used	int
;	O
if	O
(	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
<	O
0	int
)	O
{	O
if	O
(	O
td	pointer
->	O
estimated	struct
.	O
in_byoyomi	int
||	O
byoyomi_stones	int
==	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_TIME	int
,	O
"%s ran out of time.\n"	pointer
,	O
color_to_string	function
(	O
color	int
)	O
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_TIME	int
)	O
clock_print	function
(	O
color	int
)	O
;	O
td	pointer
->	O
time_out	int
=	O
1	int
;	O
}	O
else	O
{	O
gg_assert	O
(	O
!	O
(	O
td	pointer
->	O
estimated	struct
.	O
in_byoyomi	int
)	O
)	O
;	O
td	pointer
->	O
estimated	struct
.	O
in_byoyomi	int
=	O
1	int
;	O
td	pointer
->	O
estimated	struct
.	O
stones	pointer
=	O
byoyomi_stones	int
-	O
1	int
;	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
+=	O
byoyomi_time	int
;	O
if	O
(	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
<	O
0	int
)	O
td	pointer
->	O
time_out	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
td	pointer
->	O
estimated	struct
.	O
stones	pointer
>	O
0	int
)	O
{	O
gg_assert	O
(	O
td	pointer
->	O
estimated	struct
.	O
in_byoyomi	int
)	O
;	O
td	pointer
->	O
estimated	struct
.	O
stones	pointer
=	O
td	pointer
->	O
estimated	struct
.	O
stones	pointer
-	O
1	int
;	O
if	O
(	O
td	pointer
->	O
estimated	struct
.	O
stones	pointer
==	O
0	int
)	O
{	O
td	pointer
->	O
estimated	struct
.	O
time_left	int
=	O
byoyomi_time	int
;	O
td	pointer
->	O
estimated	struct
.	O
stones	pointer
=	O
byoyomi_stones	int
;	O
}	O
}	O
}	O
last_movenum	int
=	O
movenum	int
;	O
last_time	double
=	O
now	double
;	O
if	O
(	O
debug	int
&	O
DEBUG_TIME	int
)	O
clock_print	function
(	O
color	int
)	O
;	O
}	O
static	O
int	O
analyze_time_data	function
(	O
int	O
color	int
,	O
double	O
*	O
time_for_last_move	double
,	O
double	O
*	O
time_left	int
,	O
int	O
*	O
stones_left	pointer
)	O
{	O
struct	O
remaining_time_data	struct
*	O
const	O
timer	pointer
=	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
&	O
black_time_data	struct
.	O
estimated	struct
:	O
&	O
white_time_data	struct
.	O
estimated	struct
;	O
if	O
(	O
!	O
have_time_settings	function
(	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
timer	pointer
->	O
time_for_last_move	double
<	O
0.0	int
)	O
return	O
0	int
;	O
*	O
time_for_last_move	double
=	O
timer	pointer
->	O
time_for_last_move	double
;	O
if	O
(	O
timer	pointer
->	O
stones	pointer
==	O
0	int
)	O
{	O
*	O
time_left	int
=	O
timer	pointer
->	O
time_left	int
+	O
byoyomi_time	int
;	O
if	O
(	O
byoyomi_time	int
>	O
0	int
)	O
*	O
stones_left	pointer
=	O
byoyomi_stones	int
;	O
else	O
{	O
int	O
nominal_moves	int
=	O
board_size	int
*	O
board_size	int
/	O
3	int
;	O
*	O
stones_left	pointer
=	O
gg_max	O
(	O
nominal_moves	int
-	O
movenum	int
/	O
2	int
,	O
2	int
*	O
nominal_moves	int
/	O
5	int
)	O
;	O
}	O
}	O
else	O
{	O
*	O
time_left	int
=	O
timer	pointer
->	O
time_left	int
;	O
*	O
stones_left	pointer
=	O
timer	pointer
->	O
stones	pointer
;	O
}	O
return	O
1	int
;	O
}	O
void	O
adjust_level_offset	function
(	O
int	O
color	int
)	O
{	O
double	O
time_for_last_move	double
;	O
double	O
time_left	int
;	O
int	O
stones_left	pointer
;	O
if	O
(	O
!	O
analyze_time_data	function
(	O
color	int
,	O
&	O
time_for_last_move	double
,	O
&	O
time_left	int
,	O
&	O
stones_left	pointer
)	O
)	O
return	O
;	O
if	O
(	O
time_left	int
<	O
time_for_last_move	double
*	O
(	O
stones_left	pointer
+	O
3	int
)	O
)	O
level_offset	int
--	O
;	O
if	O
(	O
time_left	int
<	O
time_for_last_move	double
*	O
stones_left	pointer
)	O
level_offset	int
--	O
;	O
if	O
(	O
3	int
*	O
time_left	int
<	O
2	int
*	O
time_for_last_move	double
*	O
stones_left	pointer
)	O
level_offset	int
--	O
;	O
if	O
(	O
2	int
*	O
time_left	int
<	O
time_for_last_move	double
*	O
stones_left	pointer
)	O
level_offset	int
--	O
;	O
if	O
(	O
3	int
*	O
time_left	int
<	O
time_for_last_move	double
*	O
stones_left	pointer
)	O
level_offset	int
--	O
;	O
if	O
(	O
time_for_last_move	double
==	O
0	int
)	O
time_for_last_move	double
=	O
1	int
;	O
if	O
(	O
time_left	int
>	O
time_for_last_move	double
*	O
(	O
stones_left	pointer
+	O
6	int
)	O
)	O
level_offset	int
++	O
;	O
if	O
(	O
time_left	int
>	O
2	int
*	O
time_for_last_move	double
*	O
(	O
stones_left	pointer
+	O
6	int
)	O
)	O
level_offset	int
++	O
;	O
if	O
(	O
level	int
+	O
level_offset	int
<	O
min_level	int
)	O
level_offset	int
=	O
min_level	int
-	O
level	int
;	O
if	O
(	O
level	int
+	O
level_offset	int
>	O
max_level	int
)	O
level_offset	int
=	O
max_level	int
-	O
level	int
;	O
DEBUG	O
(	O
DEBUG_TIME	int
,	O
"New level %d (%d %C %f %f %d)\n"	pointer
,	O
level	int
+	O
level_offset	int
,	O
movenum	int
/	O
2	int
,	O
color	int
,	O
time_for_last_move	double
,	O
time_left	int
,	O
stones_left	pointer
)	O
;	O
}	O
int	O
get_level	function
(	O
)	O
{	O
return	O
level	int
+	O
level_offset	int
;	O
}	O
void	O
set_level	function
(	O
int	O
new_level	int
)	O
{	O
level	int
=	O
new_level	int
;	O
level_offset	int
=	O
0	int
;	O
if	O
(	O
level	int
>	O
max_level	int
)	O
max_level	int
=	O
level	int
;	O
if	O
(	O
level	int
<	O
min_level	int
)	O
min_level	int
=	O
level	int
;	O
}	O
void	O
set_max_level	function
(	O
int	O
new_max	int
)	O
{	O
max_level	int
=	O
new_max	int
;	O
}	O
void	O
set_min_level	function
(	O
int	O
new_min	int
)	O
{	O
min_level	int
=	O
new_min	int
;	O
}	O
