typedef	O
struct	O
sector_map	struct
{	O
unsigned	O
int	O
head	int
:	O
1	int
;	O
unsigned	O
int	O
size	array
:	O
7	int
;	O
}	O
sector_map_t	struct
;	O
static	O
struct	O
{	O
unsigned	O
char	O
track_size	char
;	O
unsigned	O
int	O
track0_size	int
:	O
7	int
;	O
unsigned	O
int	O
rootskip	int
:	O
1	int
;	O
unsigned	O
char	O
rate	int
;	O
sector_map_t	struct
map	array
[	O
9	int
]	O
;	O
}	O
xdf_table	array
[	O
]	O
=	O
{	O
{	O
19	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
{	O
{	O
0	int
,	O
3	int
}	O
,	O
{	O
0	int
,	O
6	int
}	O
,	O
{	O
1	int
,	O
2	int
}	O
,	O
{	O
0	int
,	O
2	int
}	O
,	O
{	O
1	int
,	O
6	int
}	O
,	O
{	O
1	int
,	O
3	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
}	O
,	O
{	O
23	int
,	O
19	int
,	O
0	int
,	O
0	int
,	O
{	O
{	O
0	int
,	O
3	int
}	O
,	O
{	O
0	int
,	O
4	int
}	O
,	O
{	O
1	int
,	O
6	int
}	O
,	O
{	O
0	int
,	O
2	int
}	O
,	O
{	O
1	int
,	O
2	int
}	O
,	O
{	O
0	int
,	O
6	int
}	O
,	O
{	O
1	int
,	O
4	int
}	O
,	O
{	O
1	int
,	O
3	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
}	O
,	O
{	O
46	int
,	O
37	int
,	O
1	int
,	O
0x43	int
,	O
{	O
{	O
0	int
,	O
3	int
}	O
,	O
{	O
0	int
,	O
4	int
}	O
,	O
{	O
0	int
,	O
5	int
}	O
,	O
{	O
0	int
,	O
7	int
}	O
,	O
{	O
1	int
,	O
3	int
}	O
,	O
{	O
1	int
,	O
4	int
}	O
,	O
{	O
1	int
,	O
5	int
}	O
,	O
{	O
1	int
,	O
7	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
}	O
,	O
{	O
24	int
,	O
20	int
,	O
1	int
,	O
0	int
,	O
{	O
{	O
0	int
,	O
5	int
}	O
,	O
{	O
1	int
,	O
6	int
}	O
,	O
{	O
0	int
,	O
6	int
}	O
,	O
{	O
1	int
,	O
5	int
}	O
}	O
}	O
,	O
{	O
48	int
,	O
41	int
,	O
1	int
,	O
0	int
,	O
{	O
{	O
0	int
,	O
6	int
}	O
,	O
{	O
1	int
,	O
7	int
}	O
,	O
{	O
0	int
,	O
7	int
}	O
,	O
{	O
1	int
,	O
6	int
}	O
}	O
}	O
}	O
;	O
typedef	O
struct	O
{	O
unsigned	O
char	O
begin	char
;	O
unsigned	O
char	O
end	char
;	O
unsigned	O
char	O
sector	int
;	O
unsigned	O
char	O
sizecode	char
;	O
unsigned	O
int	O
dirty	int
:	O
1	int
;	O
unsigned	O
int	O
phantom	int
:	O
2	int
;	O
unsigned	O
int	O
valid	int
:	O
1	int
;	O
unsigned	O
int	O
head	int
:	O
1	int
;	O
}	O
TrackMap_t	struct
;	O
typedef	O
struct	O
Xdf_t	struct
{	O
Class_t	struct
*	O
Class	pointer
;	O
int	O
refs	int
;	O
Stream_t	struct
*	O
Next	pointer
;	O
Stream_t	struct
*	O
Buffer	pointer
;	O
int	O
fd	int
;	O
char	O
*	O
buffer	pointer
;	O
int	O
current_track	int
;	O
sector_map_t	struct
*	O
map	array
;	O
int	O
track_size	char
;	O
int	O
track0_size	int
;	O
int	O
sector_size	int
;	O
unsigned	O
int	O
FatSize	int
;	O
unsigned	O
int	O
RootDirSize	int
;	O
TrackMap_t	struct
*	O
track_map	pointer
;	O
unsigned	O
char	O
last_sector	char
;	O
unsigned	O
char	O
rate	int
;	O
unsigned	O
int	O
stretch	int
:	O
1	int
;	O
unsigned	O
int	O
rootskip	int
:	O
1	int
;	O
signed	O
int	O
drive	char
:	O
4	int
;	O
}	O
Xdf_t	struct
;	O
typedef	O
struct	O
{	O
unsigned	O
char	O
head	int
;	O
unsigned	O
char	O
sector	int
;	O
unsigned	O
char	O
ptr	char
;	O
}	O
Compactify_t	struct
;	O
static	O
int	O
analyze_reply	function
(	O
RawRequest_t	struct
*	O
raw_cmd	pointer
,	O
int	O
do_print	int
)	O
{	O
int	O
ret	int
,	O
bytes	array
,	O
newbytes	int
;	O
bytes	array
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
ret	int
=	O
analyze_one_reply	function
(	O
raw_cmd	pointer
,	O
&	O
newbytes	int
,	O
do_print	int
)	O
;	O
bytes	array
+=	O
newbytes	int
;	O
switch	O
(	O
ret	int
)	O
{	O
case	O
0	int
:	O
return	O
bytes	array
;	O
case	O
1	int
:	O
raw_cmd	pointer
++	O
;	O
break	O
;	O
case	O
-	O
1	int
:	O
if	O
(	O
bytes	array
)	O
return	O
bytes	array
;	O
else	O
return	O
0	int
;	O
}	O
}	O
}	O
static	O
int	O
send_cmd	function
(	O
int	O
fd	int
,	O
RawRequest_t	struct
*	O
raw_cmd	pointer
,	O
int	O
nr	int
,	O
const	O
char	O
*	O
message	pointer
,	O
int	O
retries	int
)	O
{	O
int	O
j	int
;	O
int	O
ret	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
nr	int
)	O
return	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
retries	int
;	O
j	int
++	O
)	O
{	O
switch	O
(	O
send_one_cmd	function
(	O
fd	int
,	O
raw_cmd	pointer
,	O
message	pointer
)	O
)	O
{	O
case	O
-	O
1	int
:	O
return	O
-	O
1	int
;	O
case	O
1	int
:	O
j	int
++	O
;	O
continue	O
;	O
case	O
0	int
:	O
break	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
analyze_reply	function
(	O
raw_cmd	pointer
,	O
j	int
)	O
)	O
>	O
0	int
)	O
return	O
ret	int
;	O
}	O
if	O
(	O
j	int
>	O
1	int
&&	O
j	int
==	O
retries	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too many errors, giving up\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
add_to_request	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
int	O
ptr	char
,	O
RawRequest_t	struct
*	O
request	pointer
,	O
int	O
*	O
nr	int
,	O
int	O
direction	int
,	O
Compactify_t	struct
*	O
compactify	pointer
)	O
{	O
if	O
(	O
REC	O
.	O
phantom	int
)	O
{	O
if	O
(	O
direction	int
==	O
MT_READ	int
)	O
memset	function
(	O
This	pointer
->	O
buffer	pointer
+	O
ptr	char
*	O
This	pointer
->	O
sector_size	int
,	O
0	int
,	O
128	int
<<	O
REC	O
.	O
sizecode	char
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
nr	int
&&	O
RR_SIZECODE	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
-	O
1	int
)	O
==	O
REC	O
.	O
sizecode	char
&&	O
compactify	pointer
->	O
head	int
==	O
REC	O
.	O
head	int
&&	O
compactify	pointer
->	O
ptr	char
+	O
1	int
==	O
ptr	char
&&	O
compactify	pointer
->	O
sector	int
+	O
1	int
==	O
REC	O
.	O
sector	int
)	O
{	O
RR_SETSIZECODE	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
-	O
1	int
,	O
REC	O
.	O
sizecode	char
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
nr	int
)	O
RR_SETCONT	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
-	O
1	int
)	O
;	O
RR_INIT	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
)	O
;	O
RR_SETDRIVE	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
This	pointer
->	O
drive	char
)	O
;	O
RR_SETRATE	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
This	pointer
->	O
rate	int
)	O
;	O
RR_SETTRACK	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
This	pointer
->	O
current_track	int
)	O
;	O
RR_SETPTRACK	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
This	pointer
->	O
current_track	int
<<	O
This	pointer
->	O
stretch	int
)	O
;	O
RR_SETHEAD	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
REC	O
.	O
head	int
)	O
;	O
RR_SETSECTOR	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
REC	O
.	O
sector	int
)	O
;	O
RR_SETSIZECODE	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
REC	O
.	O
sizecode	char
)	O
;	O
RR_SETDIRECTION	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
direction	int
)	O
;	O
RR_SETDATA	function
(	O
request	pointer
+	O
(	O
*	O
nr	int
)	O
,	O
(	O
caddr_t	pointer
)	O
This	pointer
->	O
buffer	pointer
+	O
ptr	char
*	O
This	pointer
->	O
sector_size	int
)	O
;	O
(	O
*	O
nr	int
)	O
++	O
;	O
}	O
compactify	pointer
->	O
ptr	char
=	O
ptr	char
;	O
compactify	pointer
->	O
head	int
=	O
REC	O
.	O
head	int
;	O
compactify	pointer
->	O
sector	int
=	O
REC	O
.	O
sector	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
add_to_request_if_invalid	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
int	O
ptr	char
,	O
RawRequest_t	struct
*	O
request	pointer
,	O
int	O
*	O
nr	int
,	O
Compactify_t	struct
*	O
compactify	pointer
)	O
{	O
if	O
(	O
!	O
REC	O
.	O
valid	int
)	O
add_to_request	function
(	O
This	pointer
,	O
ptr	char
,	O
request	pointer
,	O
nr	int
,	O
MT_READ	int
,	O
compactify	pointer
)	O
;	O
}	O
static	O
void	O
adjust_bounds	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
off_t	long
*	O
begin	char
,	O
off_t	long
*	O
end	char
)	O
{	O
*	O
begin	char
=	O
*	O
begin	char
/	O
This	pointer
->	O
sector_size	int
;	O
*	O
end	char
=	O
(	O
*	O
end	char
+	O
This	pointer
->	O
sector_size	int
-	O
1	int
)	O
/	O
This	pointer
->	O
sector_size	int
;	O
}	O
static	O
__inline__	O
int	O
try_flush_dirty	function
(	O
Xdf_t	struct
*	O
This	pointer
)	O
{	O
int	O
ptr	char
,	O
nr	int
,	O
bytes	array
;	O
RawRequest_t	struct
requests	array
[	O
100	int
]	O
;	O
Compactify_t	struct
compactify	pointer
;	O
if	O
(	O
This	pointer
->	O
current_track	int
<	O
0	int
)	O
return	O
0	int
;	O
nr	int
=	O
0	int
;	O
for	O
(	O
ptr	char
=	O
0	int
;	O
ptr	char
<	O
This	pointer
->	O
last_sector	char
;	O
ptr	char
=	O
REC	O
.	O
end	char
)	O
if	O
(	O
REC	O
.	O
dirty	int
)	O
add_to_request	function
(	O
This	pointer
,	O
ptr	char
,	O
requests	array
,	O
&	O
nr	int
,	O
MT_WRITE	int
,	O
&	O
compactify	pointer
)	O
;	O
bytes	array
=	O
send_cmd	function
(	O
This	pointer
->	O
fd	int
,	O
requests	array
,	O
nr	int
,	O
"writing"	pointer
,	O
4	int
)	O
;	O
if	O
(	O
bytes	array
<	O
0	int
)	O
return	O
bytes	array
;	O
for	O
(	O
ptr	char
=	O
0	int
;	O
ptr	char
<	O
This	pointer
->	O
last_sector	char
;	O
ptr	char
=	O
REC	O
.	O
end	char
)	O
if	O
(	O
REC	O
.	O
dirty	int
)	O
{	O
if	O
(	O
bytes	array
>=	O
REC	O
.	O
end	char
-	O
REC	O
.	O
begin	char
)	O
{	O
bytes	array
-=	O
REC	O
.	O
end	char
-	O
REC	O
.	O
begin	char
;	O
REC	O
.	O
dirty	int
=	O
0	int
;	O
}	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
flush_dirty	function
(	O
Xdf_t	struct
*	O
This	pointer
)	O
{	O
int	O
ret	int
;	O
while	O
(	O
(	O
ret	int
=	O
try_flush_dirty	function
(	O
This	pointer
)	O
)	O
)	O
{	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
load_data	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
off_t	long
begin	char
,	O
off_t	long
end	char
,	O
int	O
retries	int
)	O
{	O
int	O
ptr	char
,	O
nr	int
,	O
bytes	array
;	O
RawRequest_t	struct
requests	array
[	O
100	int
]	O
;	O
Compactify_t	struct
compactify	pointer
;	O
adjust_bounds	function
(	O
This	pointer
,	O
&	O
begin	char
,	O
&	O
end	char
)	O
;	O
ptr	char
=	O
begin	char
;	O
nr	int
=	O
0	int
;	O
for	O
(	O
ptr	char
=	O
REC	O
.	O
begin	char
;	O
ptr	char
<	O
end	char
;	O
ptr	char
=	O
REC	O
.	O
end	char
)	O
add_to_request_if_invalid	function
(	O
This	pointer
,	O
ptr	char
,	O
requests	array
,	O
&	O
nr	int
,	O
&	O
compactify	pointer
)	O
;	O
bytes	array
=	O
send_cmd	function
(	O
This	pointer
->	O
fd	int
,	O
requests	array
,	O
nr	int
,	O
"reading"	pointer
,	O
retries	int
)	O
;	O
if	O
(	O
bytes	array
<	O
0	int
)	O
return	O
bytes	array
;	O
ptr	char
=	O
begin	char
;	O
for	O
(	O
ptr	char
=	O
REC	O
.	O
begin	char
;	O
ptr	char
<	O
end	char
;	O
ptr	char
=	O
REC	O
.	O
end	char
)	O
{	O
if	O
(	O
!	O
REC	O
.	O
valid	int
)	O
{	O
if	O
(	O
bytes	array
>=	O
REC	O
.	O
end	char
-	O
REC	O
.	O
begin	char
)	O
{	O
bytes	array
-=	O
REC	O
.	O
end	char
-	O
REC	O
.	O
begin	char
;	O
REC	O
.	O
valid	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
ptr	char
>	O
begin	char
)	O
return	O
ptr	char
*	O
This	pointer
->	O
sector_size	int
;	O
else	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
end	char
*	O
This	pointer
->	O
sector_size	int
;	O
}	O
static	O
void	O
mark_dirty	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
off_t	long
begin	char
,	O
off_t	long
end	char
)	O
{	O
int	O
ptr	char
;	O
adjust_bounds	function
(	O
This	pointer
,	O
&	O
begin	char
,	O
&	O
end	char
)	O
;	O
ptr	char
=	O
begin	char
;	O
for	O
(	O
ptr	char
=	O
REC	O
.	O
begin	char
;	O
ptr	char
<	O
end	char
;	O
ptr	char
=	O
REC	O
.	O
end	char
)	O
{	O
REC	O
.	O
valid	int
=	O
1	int
;	O
if	O
(	O
!	O
REC	O
.	O
phantom	int
)	O
REC	O
.	O
dirty	int
=	O
1	int
;	O
}	O
}	O
static	O
int	O
load_bounds	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
off_t	long
begin	char
,	O
off_t	long
end	char
)	O
{	O
off_t	long
lbegin	long
,	O
lend	long
;	O
int	O
endp1	int
,	O
endp2	int
;	O
lbegin	long
=	O
begin	char
;	O
lend	long
=	O
end	char
;	O
adjust_bounds	function
(	O
This	pointer
,	O
&	O
lbegin	long
,	O
&	O
lend	long
)	O
;	O
if	O
(	O
begin	char
!=	O
BEGIN	O
(	O
lbegin	long
)	O
*	O
This	pointer
->	O
sector_size	int
&&	O
end	char
!=	O
BEGIN	O
(	O
lend	long
)	O
*	O
This	pointer
->	O
sector_size	int
&&	O
lend	long
<	O
END	O
(	O
END	O
(	O
lbegin	long
)	O
)	O
)	O
return	O
load_data	function
(	O
This	pointer
,	O
begin	char
,	O
end	char
,	O
4	int
)	O
;	O
if	O
(	O
begin	char
!=	O
BEGIN	O
(	O
lbegin	long
)	O
*	O
This	pointer
->	O
sector_size	int
)	O
{	O
endp1	int
=	O
load_data	function
(	O
This	pointer
,	O
begin	char
,	O
begin	char
,	O
4	int
)	O
;	O
if	O
(	O
endp1	int
<	O
0	int
)	O
return	O
endp1	int
;	O
}	O
if	O
(	O
end	char
!=	O
BEGIN	O
(	O
lend	long
)	O
*	O
This	pointer
->	O
sector_size	int
)	O
{	O
endp2	int
=	O
load_data	function
(	O
This	pointer
,	O
end	char
,	O
end	char
,	O
4	int
)	O
;	O
if	O
(	O
endp2	int
<	O
0	int
)	O
return	O
BEGIN	O
(	O
lend	long
)	O
*	O
This	pointer
->	O
sector_size	int
;	O
}	O
return	O
lend	long
*	O
This	pointer
->	O
sector_size	int
;	O
}	O
static	O
int	O
fill_t0	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
int	O
ptr	char
,	O
unsigned	O
int	O
size	array
,	O
int	O
*	O
sector	int
,	O
int	O
*	O
head	int
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
size	array
;	O
ptr	char
++	O
,	O
n	int
++	O
)	O
{	O
REC	O
.	O
head	int
=	O
*	O
head	int
;	O
REC	O
.	O
sector	int
=	O
*	O
sector	int
+	O
129	int
;	O
REC	O
.	O
phantom	int
=	O
0	int
;	O
(	O
*	O
sector	int
)	O
++	O
;	O
if	O
(	O
!	O
*	O
head	int
&&	O
*	O
sector	int
>=	O
This	pointer
->	O
track0_size	int
-	O
8	int
)	O
{	O
*	O
sector	int
=	O
0	int
;	O
*	O
head	int
=	O
1	int
;	O
}	O
}	O
return	O
ptr	char
;	O
}	O
static	O
int	O
fill_phantoms	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
int	O
ptr	char
,	O
unsigned	O
int	O
size	array
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
size	array
;	O
ptr	char
++	O
,	O
n	int
++	O
)	O
REC	O
.	O
phantom	int
=	O
1	int
;	O
return	O
ptr	char
;	O
}	O
static	O
void	O
decompose	function
(	O
Xdf_t	struct
*	O
This	pointer
,	O
int	O
where	long
,	O
int	O
len	long
,	O
off_t	long
*	O
begin	char
,	O
off_t	long
*	O
end	char
,	O
int	O
boot	struct
)	O
{	O
int	O
ptr	char
,	O
track	int
;	O
sector_map_t	struct
*	O
map	array
;	O
int	O
lbegin	long
,	O
lend	long
;	O
track	int
=	O
where	long
/	O
This	pointer
->	O
track_size	char
/	O
1024	int
;	O
*	O
begin	char
=	O
where	long
-	O
track	int
*	O
This	pointer
->	O
track_size	char
*	O
1024	int
;	O
*	O
end	char
=	O
where	long
+	O
len	long
-	O
track	int
*	O
This	pointer
->	O
track_size	char
*	O
1024	int
;	O
maximize	O
(	O
*	O
end	char
,	O
This	pointer
->	O
track_size	char
*	O
1024	int
)	O
;	O
if	O
(	O
This	pointer
->	O
current_track	int
==	O
track	int
&&	O
!	O
boot	struct
)	O
return	O
;	O
if	O
(	O
!	O
boot	struct
)	O
flush_dirty	function
(	O
This	pointer
)	O
;	O
This	pointer
->	O
current_track	int
=	O
track	int
;	O
if	O
(	O
track	int
)	O
{	O
for	O
(	O
ptr	char
=	O
0	int
,	O
map	array
=	O
This	pointer
->	O
map	array
;	O
map	array
->	O
size	array
;	O
map	array
++	O
)	O
{	O
lbegin	long
=	O
ptr	char
;	O
lend	long
=	O
ptr	char
+	O
(	O
128	int
<<	O
map	array
->	O
size	array
)	O
/	O
This	pointer
->	O
sector_size	int
;	O
for	O
(	O
;	O
ptr	char
<	O
lend	long
;	O
ptr	char
++	O
)	O
{	O
REC	O
.	O
begin	char
=	O
lbegin	long
;	O
REC	O
.	O
end	char
=	O
lend	long
;	O
REC	O
.	O
head	int
=	O
map	array
->	O
head	int
;	O
REC	O
.	O
sector	int
=	O
map	array
->	O
size	array
+	O
128	int
;	O
REC	O
.	O
sizecode	char
=	O
map	array
->	O
size	array
;	O
REC	O
.	O
valid	int
=	O
0	int
;	O
REC	O
.	O
dirty	int
=	O
0	int
;	O
REC	O
.	O
phantom	int
=	O
0	int
;	O
}	O
}	O
REC	O
.	O
begin	char
=	O
REC	O
.	O
end	char
=	O
ptr	char
;	O
}	O
else	O
{	O
int	O
sector	int
,	O
head	int
;	O
head	int
=	O
0	int
;	O
sector	int
=	O
0	int
;	O
for	O
(	O
ptr	char
=	O
boot	struct
;	O
ptr	char
<	O
2	int
*	O
This	pointer
->	O
track_size	char
;	O
ptr	char
++	O
)	O
{	O
REC	O
.	O
begin	char
=	O
ptr	char
;	O
REC	O
.	O
end	char
=	O
ptr	char
+	O
1	int
;	O
REC	O
.	O
sizecode	char
=	O
2	int
;	O
REC	O
.	O
valid	int
=	O
0	int
;	O
REC	O
.	O
dirty	int
=	O
0	int
;	O
}	O
ptr	char
=	O
fill_t0	function
(	O
This	pointer
,	O
0	int
,	O
1	int
+	O
This	pointer
->	O
FatSize	int
,	O
&	O
sector	int
,	O
&	O
head	int
)	O
;	O
ptr	char
=	O
fill_phantoms	function
(	O
This	pointer
,	O
ptr	char
,	O
This	pointer
->	O
FatSize	int
)	O
;	O
ptr	char
=	O
fill_t0	function
(	O
This	pointer
,	O
ptr	char
,	O
This	pointer
->	O
RootDirSize	int
,	O
&	O
sector	int
,	O
&	O
head	int
)	O
;	O
ptr	char
=	O
fill_phantoms	function
(	O
This	pointer
,	O
ptr	char
,	O
5	int
)	O
;	O
if	O
(	O
This	pointer
->	O
rootskip	int
)	O
sector	int
++	O
;	O
ptr	char
=	O
fill_t0	function
(	O
This	pointer
,	O
ptr	char
,	O
(	O
This	pointer
->	O
track_size	char
-	O
This	pointer
->	O
FatSize	int
)	O
*	O
2	int
-	O
This	pointer
->	O
RootDirSize	int
-	O
6	int
,	O
&	O
sector	int
,	O
&	O
head	int
)	O
;	O
}	O
This	pointer
->	O
last_sector	char
=	O
ptr	char
;	O
}	O
static	O
int	O
xdf_read	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
char	O
*	O
buf	pointer
,	O
mt_off_t	long
where	long
,	O
size_t	long
len	long
)	O
{	O
off_t	long
begin	char
,	O
end	char
;	O
size_t	long
len2	long
;	O
DeclareThis	O
(	O
Xdf_t	struct
)	O
;	O
decompose	function
(	O
This	pointer
,	O
truncBytes32	function
(	O
where	long
)	O
,	O
len	long
,	O
&	O
begin	char
,	O
&	O
end	char
,	O
0	int
)	O
;	O
len2	long
=	O
load_data	function
(	O
This	pointer
,	O
begin	char
,	O
end	char
,	O
4	int
)	O
;	O
len2	long
-=	O
begin	char
;	O
maximize	O
(	O
len	long
,	O
len2	long
)	O
;	O
memcpy	function
(	O
buf	pointer
,	O
This	pointer
->	O
buffer	pointer
+	O
begin	char
,	O
len	long
)	O
;	O
return	O
end	char
-	O
begin	char
;	O
}	O
static	O
int	O
xdf_write	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
char	O
*	O
buf	pointer
,	O
mt_off_t	long
where	long
,	O
size_t	long
len	long
)	O
{	O
off_t	long
begin	char
,	O
end	char
;	O
size_t	long
len2	long
;	O
DeclareThis	O
(	O
Xdf_t	struct
)	O
;	O
decompose	function
(	O
This	pointer
,	O
truncBytes32	function
(	O
where	long
)	O
,	O
len	long
,	O
&	O
begin	char
,	O
&	O
end	char
,	O
0	int
)	O
;	O
len2	long
=	O
load_bounds	function
(	O
This	pointer
,	O
begin	char
,	O
end	char
)	O
;	O
smaximize	O
(	O
end	char
,	O
(	O
off_t	long
)	O
len2	long
)	O
;	O
len2	long
-=	O
begin	char
;	O
sizemaximize	O
(	O
len	long
,	O
(	O
off_t	long
)	O
len2	long
)	O
;	O
memcpy	function
(	O
This	pointer
->	O
buffer	pointer
+	O
begin	char
,	O
buf	pointer
,	O
len	long
)	O
;	O
mark_dirty	function
(	O
This	pointer
,	O
begin	char
,	O
end	char
)	O
;	O
return	O
end	char
-	O
begin	char
;	O
}	O
static	O
int	O
xdf_flush	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
Xdf_t	struct
)	O
;	O
return	O
flush_dirty	function
(	O
This	pointer
)	O
;	O
}	O
static	O
int	O
xdf_free	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
Xdf_t	struct
)	O
;	O
Free	O
(	O
This	pointer
->	O
track_map	pointer
)	O
;	O
Free	O
(	O
This	pointer
->	O
buffer	pointer
)	O
;	O
return	O
close	pointer
(	O
This	pointer
->	O
fd	int
)	O
;	O
}	O
static	O
int	O
check_geom	function
(	O
struct	O
device	struct
*	O
dev	pointer
,	O
int	O
media	char
,	O
union	O
bootsector	union
*	O
boot	struct
)	O
{	O
int	O
sect	int
;	O
if	O
(	O
media	char
>=	O
0xfc	int
&&	O
media	char
<=	O
0xff	int
)	O
return	O
1	int
;	O
if	O
(	O
!	O
IS_MFORMAT_ONLY	O
(	O
dev	pointer
)	O
)	O
{	O
if	O
(	O
compare	function
(	O
dev	pointer
->	O
sectors	short
,	O
19	int
)	O
&&	O
compare	function
(	O
dev	pointer
->	O
sectors	short
,	O
23	int
)	O
&&	O
compare	function
(	O
dev	pointer
->	O
sectors	short
,	O
24	int
)	O
&&	O
compare	function
(	O
dev	pointer
->	O
sectors	short
,	O
46	int
)	O
&&	O
compare	function
(	O
dev	pointer
->	O
sectors	short
,	O
48	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
compare	function
(	O
dev	pointer
->	O
heads	short
,	O
2	int
)	O
)	O
return	O
1	int
;	O
}	O
if	O
(	O
boot	struct
)	O
{	O
sect	int
=	O
WORD	O
(	O
nsect	array
)	O
;	O
if	O
(	O
(	O
sect	int
!=	O
19	int
&&	O
sect	int
!=	O
23	int
&&	O
sect	int
!=	O
24	int
&&	O
sect	int
!=	O
46	int
&&	O
sect	int
!=	O
48	int
)	O
||	O
(	O
!	O
IS_MFORMAT_ONLY	O
(	O
dev	pointer
)	O
&&	O
compare	function
(	O
dev	pointer
->	O
sectors	short
,	O
sect	int
)	O
)	O
||	O
WORD	O
(	O
nheads	array
)	O
!=	O
2	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
set_geom	pointer
(	O
union	O
bootsector	union
*	O
boot	struct
,	O
struct	O
device	struct
*	O
dev	pointer
)	O
{	O
dev	pointer
->	O
heads	short
=	O
2	int
;	O
dev	pointer
->	O
use_2m	int
=	O
0xff	int
;	O
if	O
(	O
boot	struct
)	O
{	O
dev	pointer
->	O
sectors	short
=	O
WORD	O
(	O
nsect	array
)	O
;	O
if	O
(	O
WORD	O
(	O
psect	array
)	O
)	O
dev	pointer
->	O
tracks	int
=	O
WORD	O
(	O
psect	array
)	O
/	O
dev	pointer
->	O
sectors	short
/	O
2	int
;	O
}	O
}	O
static	O
int	O
config_geom	function
(	O
Stream_t	struct
*	O
Stream	pointer
UNUSEDP	O
,	O
struct	O
device	struct
*	O
dev	pointer
,	O
struct	O
device	struct
*	O
orig_dev	pointer
UNUSEDP	O
,	O
int	O
media	char
,	O
union	O
bootsector	union
*	O
boot	struct
)	O
{	O
if	O
(	O
check_geom	function
(	O
dev	pointer
,	O
media	char
,	O
boot	struct
)	O
)	O
return	O
1	int
;	O
set_geom	pointer
(	O
boot	struct
,	O
dev	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
Class_t	struct
XdfClass	struct
=	O
{	O
xdf_read	function
,	O
xdf_write	function
,	O
xdf_flush	function
,	O
xdf_free	function
,	O
config_geom	function
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
Stream_t	struct
*	O
XdfOpen	function
(	O
struct	O
device	struct
*	O
dev	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
mode	int
,	O
char	O
*	O
errmsg	pointer
,	O
struct	O
xdf_info	struct
*	O
info	pointer
)	O
{	O
Xdf_t	struct
*	O
This	pointer
;	O
off_t	long
begin	char
,	O
end	char
;	O
union	O
bootsector	union
*	O
boot	struct
;	O
unsigned	O
int	O
type	enum
;	O
if	O
(	O
dev	pointer
&&	O
(	O
!	O
SHOULD_USE_XDF	O
(	O
dev	pointer
)	O
||	O
check_geom	function
(	O
dev	pointer
,	O
0	int
,	O
0	int
)	O
)	O
)	O
return	O
NULL	O
;	O
This	pointer
=	O
New	O
(	O
Xdf_t	struct
)	O
;	O
if	O
(	O
!	O
This	pointer
)	O
return	O
NULL	O
;	O
This	pointer
->	O
Class	pointer
=	O
&	O
XdfClass	struct
;	O
This	pointer
->	O
sector_size	int
=	O
512	int
;	O
This	pointer
->	O
stretch	int
=	O
0	int
;	O
precmd	pointer
(	O
dev	pointer
)	O
;	O
This	pointer
->	O
fd	int
=	O
open	function
(	O
name	pointer
,	O
mode	int
|	O
dev	pointer
->	O
mode	int
|	O
O_EXCL	int
|	O
O_NDELAY	O
)	O
;	O
if	O
(	O
This	pointer
->	O
fd	int
<	O
0	int
)	O
{	O
snprintf	function
(	O
errmsg	pointer
,	O
199	int
,	O
"xdf floppy: open: \"%s\""	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
goto	O
exit_0	O
;	O
}	O
closeExec	function
(	O
This	pointer
->	O
fd	int
)	O
;	O
This	pointer
->	O
drive	char
=	O
GET_DRIVE	function
(	O
This	pointer
->	O
fd	int
)	O
;	O
if	O
(	O
This	pointer
->	O
drive	char
<	O
0	int
)	O
goto	O
exit_1	O
;	O
This	pointer
->	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
96	int
*	O
512	int
)	O
;	O
if	O
(	O
!	O
This	pointer
->	O
buffer	pointer
)	O
goto	O
exit_1	O
;	O
This	pointer
->	O
current_track	int
=	O
-	O
1	int
;	O
This	pointer
->	O
track_map	pointer
=	O
(	O
TrackMap_t	struct
*	O
)	O
calloc	function
(	O
96	int
,	O
sizeof	O
(	O
TrackMap_t	struct
)	O
)	O
;	O
if	O
(	O
!	O
This	pointer
->	O
track_map	pointer
)	O
goto	O
exit_2	O
;	O
if	O
(	O
lock_dev	function
(	O
This	pointer
->	O
fd	int
,	O
mode	int
==	O
O_RDWR	int
,	O
dev	pointer
)	O
)	O
{	O
snprintf	function
(	O
errmsg	pointer
,	O
199	int
,	O
"xdf floppy: device \"%s\" busy:"	pointer
,	O
dev	pointer
->	O
name	pointer
)	O
;	O
goto	O
exit_3	O
;	O
}	O
This	pointer
->	O
track_size	char
=	O
11	int
;	O
This	pointer
->	O
track0_size	int
=	O
6	int
;	O
This	pointer
->	O
rate	int
=	O
0	int
;	O
This	pointer
->	O
FatSize	int
=	O
9	int
;	O
This	pointer
->	O
RootDirSize	int
=	O
1	int
;	O
decompose	function
(	O
This	pointer
,	O
0	int
,	O
512	int
,	O
&	O
begin	char
,	O
&	O
end	char
,	O
0	int
)	O
;	O
if	O
(	O
load_data	function
(	O
This	pointer
,	O
0	int
,	O
1	int
,	O
1	int
)	O
<	O
0	int
)	O
{	O
This	pointer
->	O
rate	int
=	O
0x43	int
;	O
if	O
(	O
load_data	function
(	O
This	pointer
,	O
0	int
,	O
1	int
,	O
1	int
)	O
<	O
0	int
)	O
goto	O
exit_3	O
;	O
}	O
boot	struct
=	O
(	O
union	O
bootsector	union
*	O
)	O
This	pointer
->	O
buffer	pointer
;	O
This	pointer
->	O
FatSize	int
=	O
WORD	O
(	O
fatlen	array
)	O
;	O
This	pointer
->	O
RootDirSize	int
=	O
WORD	O
(	O
dirents	array
)	O
/	O
16	int
;	O
This	pointer
->	O
track_size	char
=	O
WORD	O
(	O
nsect	array
)	O
;	O
for	O
(	O
type	enum
=	O
0	int
;	O
type	enum
<	O
NUMBER	O
(	O
xdf_table	array
)	O
;	O
type	enum
++	O
)	O
{	O
if	O
(	O
xdf_table	array
[	O
type	enum
]	O
.	O
track_size	char
==	O
This	pointer
->	O
track_size	char
)	O
{	O
This	pointer
->	O
map	array
=	O
xdf_table	array
[	O
type	enum
]	O
.	O
map	array
;	O
This	pointer
->	O
track0_size	int
=	O
xdf_table	array
[	O
type	enum
]	O
.	O
track0_size	int
;	O
This	pointer
->	O
rootskip	int
=	O
xdf_table	array
[	O
type	enum
]	O
.	O
rootskip	int
;	O
This	pointer
->	O
rate	int
=	O
xdf_table	array
[	O
type	enum
]	O
.	O
rate	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
type	enum
==	O
NUMBER	O
(	O
xdf_table	array
)	O
)	O
goto	O
exit_3	O
;	O
if	O
(	O
info	pointer
)	O
{	O
info	pointer
->	O
RootDirSize	int
=	O
This	pointer
->	O
RootDirSize	int
;	O
info	pointer
->	O
FatSize	int
=	O
This	pointer
->	O
FatSize	int
;	O
info	pointer
->	O
BadSectors	int
=	O
5	int
;	O
}	O
decompose	function
(	O
This	pointer
,	O
0	int
,	O
512	int
,	O
&	O
begin	char
,	O
&	O
end	char
,	O
1	int
)	O
;	O
This	pointer
->	O
refs	int
=	O
1	int
;	O
This	pointer
->	O
Next	pointer
=	O
0	int
;	O
This	pointer
->	O
Buffer	pointer
=	O
0	int
;	O
if	O
(	O
dev	pointer
)	O
set_geom	pointer
(	O
boot	struct
,	O
dev	pointer
)	O
;	O
return	O
(	O
Stream_t	struct
*	O
)	O
This	pointer
;	O
exit_3	O
:	O
Free	O
(	O
This	pointer
->	O
track_map	pointer
)	O
;	O
exit_2	O
:	O
Free	O
(	O
This	pointer
->	O
buffer	pointer
)	O
;	O
exit_1	O
:	O
close	pointer
(	O
This	pointer
->	O
fd	int
)	O
;	O
exit_0	O
:	O
Free	O
(	O
This	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
