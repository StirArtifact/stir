typedef	O
unsigned	O
char	O
*	O
STR	pointer
;	O
typedef	O
unsigned	O
long	O
int	O
BLOCK	long
;	O
unsigned	O
char	O
free_map	array
[	O
65535	int
]	O
;	O
char	O
system_function	char
=	O
'I'	O
;	O
unsigned	O
long	O
int	O
mon_disk_read	long
=	O
0	int
;	O
unsigned	O
long	O
int	O
mon_disk_write	long
=	O
0	int
;	O
unsigned	O
long	O
int	O
mon_os_file_read	long
=	O
0	int
;	O
unsigned	O
long	O
int	O
mon_interpreter	long
=	O
0	int
;	O
unsigned	O
long	O
int	O
mon_blink	long
=	O
0	int
;	O
unsigned	O
long	O
int	O
mon_symbol_table	long
=	O
0	int
;	O
unsigned	O
long	O
int	O
mon_term_io	long
=	O
0	int
;	O
int	O
error_count	int
;	O
int	O
fatal_error	int
;	O
int	O
blkgc	int
=	O
1	int
;	O
int	O
follow_dirs	int
=	O
1	int
;	O
unsigned	O
long	O
int	O
blocks_marked	long
;	O
unsigned	O
long	O
int	O
total_blocks_marked	long
;	O
int	O
set_block_used	function
(	O
blk_num	long
)	O
BLOCK	long
blk_num	long
;	O
{	O
if	O
(	O
(	O
free_map	array
[	O
blk_num	long
/	O
8	int
]	O
>>	O
(	O
blk_num	long
%	O
8	int
)	O
)	O
&	O
1	int
)	O
return	O
(	O
0	int
)	O
;	O
free_map	array
[	O
blk_num	long
/	O
8	int
]	O
|=	O
(	O
1	int
<<	O
(	O
blk_num	long
%	O
8	int
)	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
get_block_used	function
(	O
blk_num	long
)	O
BLOCK	long
blk_num	long
;	O
{	O
if	O
(	O
(	O
free_map	array
[	O
blk_num	long
/	O
8	int
]	O
>>	O
(	O
blk_num	long
%	O
8	int
)	O
)	O
&	O
1	int
)	O
return	O
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
struct	O
disk_blk	struct
{	O
ENTRY	struct
*	O
entry	struct
;	O
BLOCK	long
blk_num	long
;	O
BLOCK	long
cont_ptr	long
;	O
BLOCK	long
tree_head	long
;	O
BLOCK	long
act_blk_num	long
;	O
BLOCK	long
act_tree_head	long
;	O
long	O
size	long
;	O
int	O
level	int
;	O
int	O
type	int
;	O
int	O
directory	int
;	O
unsigned	O
char	O
*	O
block	pointer
;	O
unsigned	O
char	O
*	O
current_pos	pointer
;	O
unsigned	O
char	O
*	O
block_end	pointer
;	O
unsigned	O
char	O
current_name	array
[	O
256	int
]	O
;	O
int	O
current_name_len	int
;	O
unsigned	O
char	O
last_block_name	array
[	O
256	int
]	O
;	O
int	O
last_block_name_len	int
;	O
}	O
;	O
typedef	O
struct	O
disk_blk	struct
DISK_BLK	struct
;	O
DISK_BLK	struct
disk_blocks	array
[	O
MAX_LEVELS	int
]	O
;	O
DISK_BLK	struct
temp_block	struct
;	O
void	O
dspl_char	function
(	O
ch	int
)	O
int	O
ch	int
;	O
{	O
if	O
(	O
(	O
ch	int
>=	O
' '	O
)	O
&&	O
(	O
ch	int
<=	O
'~'	O
)	O
)	O
putchar	function
(	O
ch	int
)	O
;	O
else	O
printf	function
(	O
"'%d'"	pointer
,	O
ch	int
)	O
;	O
}	O
void	O
dspl_string	function
(	O
string	pointer
,	O
size	long
)	O
STR	pointer
string	pointer
;	O
int	O
size	long
;	O
{	O
while	O
(	O
size	long
--	O
>	O
0	int
)	O
dspl_char	function
(	O
*	O
string	pointer
++	O
)	O
;	O
}	O
void	O
path	function
(	O
level	int
)	O
int	O
level	int
;	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<=	O
level	int
)	O
{	O
printf	function
(	O
"\n  LEVEL %d  BLOCK: %lu --> %lu"	pointer
,	O
disk_blocks	array
[	O
i	int
]	O
.	O
level	int
,	O
disk_blocks	array
[	O
i	int
]	O
.	O
act_blk_num	long
,	O
disk_blocks	array
[	O
i	int
]	O
.	O
cont_ptr	long
)	O
;	O
printf	function
(	O
"\n   NAME: "	pointer
)	O
;	O
dspl_string	function
(	O
disk_blocks	array
[	O
i	int
]	O
.	O
current_name	array
,	O
disk_blocks	array
[	O
i	int
]	O
.	O
current_name_len	int
)	O
;	O
i	int
++	O
;	O
}	O
if	O
(	O
++	O
error_count	int
>=	O
50	int
)	O
fatal_error	int
=	O
1	int
;	O
}	O
int	O
string_compare	function
(	O
name1	pointer
,	O
len1	int
,	O
name2	pointer
,	O
len2	int
)	O
STR	pointer
name1	pointer
,	O
name2	pointer
;	O
int	O
len1	int
,	O
len2	int
;	O
{	O
int	O
max_len	int
=	O
min	O
(	O
len1	int
,	O
len2	int
)	O
;	O
int	O
len	int
=	O
0	int
;	O
while	O
(	O
(	O
len	int
<	O
max_len	int
)	O
&&	O
(	O
name1	pointer
[	O
len	int
]	O
==	O
name2	pointer
[	O
len	int
]	O
)	O
)	O
len	int
++	O
;	O
if	O
(	O
len	int
<	O
len2	int
)	O
{	O
if	O
(	O
len	int
==	O
len1	int
)	O
return	O
(	O
2	int
)	O
;	O
else	O
if	O
(	O
name1	pointer
[	O
len	int
]	O
<	O
name2	pointer
[	O
len	int
]	O
)	O
return	O
(	O
2	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
len	int
<	O
len1	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
cnv_string_to_long	function
(	O
s1b	pointer
,	O
s1e	pointer
,	O
i	int
)	O
STR	pointer
s1b	pointer
,	O
s1e	pointer
;	O
unsigned	O
long	O
int	O
*	O
i	int
;	O
{	O
unsigned	O
long	O
int	O
rslt	long
=	O
0	int
,	O
rslt1	long
=	O
0	int
;	O
while	O
(	O
(	O
s1b	pointer
!=	O
s1e	pointer
)	O
&&	O
(	O
*	O
s1b	pointer
>=	O
'0'	O
)	O
&&	O
(	O
*	O
s1b	pointer
<=	O
'9'	O
)	O
)	O
{	O
if	O
(	O
(	O
rslt	long
=	O
(	O
rslt	long
*	O
10	int
)	O
+	O
(	O
*	O
s1b	pointer
++	O
-	O
48	int
)	O
)	O
<	O
rslt1	long
)	O
return	O
(	O
0	int
)	O
;	O
rslt1	long
=	O
rslt	long
;	O
}	O
*	O
i	int
=	O
rslt	long
;	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
read_block	function
(	O
seg	pointer
,	O
blk_num	long
,	O
dblock	pointer
,	O
head_block	long
)	O
SEGD	struct
*	O
seg	pointer
;	O
BLOCK	long
blk_num	long
;	O
DISK_BLK	struct
*	O
dblock	pointer
;	O
BLOCK	long
head_block	long
;	O
{	O
unsigned	O
char	O
*	O
ptr1	pointer
,	O
*	O
ptr2	pointer
;	O
if	O
(	O
blk_num	long
==	O
19551	int
)	O
{	O
int	O
i	int
;	O
i	int
=	O
0	int
;	O
}	O
dblock	pointer
->	O
block	pointer
=	O
ent_blk	O
(	O
dblock	pointer
->	O
entry	struct
)	O
;	O
dblock	pointer
->	O
act_tree_head	long
=	O
head_block	long
;	O
dblock	pointer
->	O
act_blk_num	long
=	O
blk_num	long
;	O
if	O
(	O
!	O
(	O
get_ent_copy	function
(	O
dblock	pointer
->	O
entry	struct
,	O
seg	pointer
,	O
blk_num	long
)	O
)	O
)	O
return	O
(	O
1	int
)	O
;	O
dblock	pointer
->	O
blk_num	long
=	O
str2long	function
(	O
dblock	pointer
->	O
block	pointer
,	O
blk_id_pos	int
)	O
;	O
dblock	pointer
->	O
cont_ptr	long
=	O
str2long	function
(	O
dblock	pointer
->	O
block	pointer
,	O
blk_nxt_id_pos	int
)	O
;	O
dblock	pointer
->	O
tree_head	long
=	O
str2long	function
(	O
dblock	pointer
->	O
block	pointer
,	O
blk_top_id_pos	int
)	O
;	O
dblock	pointer
->	O
size	long
=	O
str2short	function
(	O
dblock	pointer
->	O
block	pointer
,	O
blk_end_pos	int
)	O
-	O
blk_data_start	int
;	O
dblock	pointer
->	O
level	int
=	O
dblock	pointer
->	O
block	pointer
[	O
blk_level_pos	int
]	O
-	O
'0'	O
;	O
dblock	pointer
->	O
type	int
=	O
blk_typ	O
(	O
dblock	pointer
->	O
block	pointer
)	O
;	O
if	O
(	O
dblock	pointer
->	O
type	int
==	O
'D'	O
)	O
dblock	pointer
->	O
directory	int
=	O
'Y'	O
;	O
else	O
dblock	pointer
->	O
directory	int
=	O
'N'	O
;	O
ptr1	pointer
=	O
&	O
dblock	pointer
->	O
block	pointer
[	O
blk_data_start	int
]	O
;	O
ptr2	pointer
=	O
ptr1	pointer
+	O
dblock	pointer
->	O
size	long
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
check_saf	function
(	O
seg	pointer
,	O
nam	pointer
,	O
len	int
)	O
SEGD	struct
*	O
seg	pointer
;	O
STR	pointer
nam	pointer
;	O
int	O
len	int
;	O
{	O
BLOCK	long
head_blk_num	long
=	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
;	O
BLOCK	long
cont_ptr	long
;	O
int	O
err	int
=	O
0	int
;	O
STR	pointer
ptr1	pointer
,	O
ptr2	pointer
;	O
int	O
blk_error	int
=	O
0	int
;	O
do	O
{	O
blocks_marked	long
++	O
;	O
total_blocks_marked	long
++	O
;	O
if	O
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
blk_num	long
!=	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
)	O
{	O
printf	function
(	O
"\nBLOCK %lu HAS WRONG BLOCK ID, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
,	O
head_blk_num	long
)	O
;	O
err	int
++	O
;	O
}	O
if	O
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
tree_head	long
!=	O
head_blk_num	long
)	O
{	O
printf	function
(	O
"\nBLOCK %lu HAS WRONG HEAD BLOCK, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
,	O
head_blk_num	long
)	O
;	O
err	int
++	O
;	O
}	O
if	O
(	O
!	O
set_block_used	function
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
)	O
)	O
{	O
printf	function
(	O
"\nSAF BLOCK %lu USED MULTIPLE TIMES, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
,	O
head_blk_num	long
)	O
;	O
err	int
++	O
;	O
}	O
if	O
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
type	int
!=	O
seq_typ	int
)	O
{	O
printf	function
(	O
"\nBLOCK %lu NOT A SAF BLOCK, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
,	O
head_blk_num	long
)	O
;	O
err	int
++	O
;	O
}	O
if	O
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
level	int
!=	O
'0'	O
)	O
{	O
printf	function
(	O
"\nBLOCK %lu SAF not LEVEL 0, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
,	O
head_blk_num	long
)	O
;	O
err	int
++	O
;	O
}	O
ptr1	pointer
=	O
disk_blocks	array
[	O
0	int
]	O
.	O
block	pointer
+	O
blk_data_start	int
;	O
ptr2	pointer
=	O
ptr1	pointer
+	O
disk_blocks	array
[	O
0	int
]	O
.	O
size	long
;	O
while	O
(	O
ptr1	pointer
<	O
ptr2	pointer
)	O
ptr1	pointer
+=	O
*	O
ptr1	pointer
+	O
1	int
;	O
if	O
(	O
ptr1	pointer
!=	O
ptr2	pointer
)	O
{	O
printf	function
(	O
"\nBLOCK %lu SAF SIZE ERROR, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
,	O
head_blk_num	long
)	O
;	O
err	int
++	O
;	O
}	O
cont_ptr	long
=	O
disk_blocks	array
[	O
0	int
]	O
.	O
cont_ptr	long
;	O
}	O
while	O
(	O
!	O
err	int
&&	O
cont_ptr	long
&&	O
!	O
(	O
blk_error	int
=	O
read_block	function
(	O
seg	pointer
,	O
cont_ptr	long
,	O
&	O
disk_blocks	array
[	O
0	int
]	O
,	O
head_blk_num	long
)	O
)	O
)	O
;	O
if	O
(	O
blk_error	int
)	O
{	O
printf	function
(	O
"\nERROR READING SAF BLOCK %lu HEAD BLOCK %lu"	pointer
,	O
cont_ptr	long
,	O
head_blk_num	long
)	O
;	O
err	int
++	O
;	O
}	O
return	O
(	O
err	int
)	O
;	O
}	O
int	O
check_struct_level	function
(	O
seg	pointer
,	O
dsk_blk_ind	int
,	O
next_block	long
,	O
start_name	pointer
,	O
start_name_len	int
,	O
end_name	pointer
,	O
end_name_len	int
,	O
level	int
)	O
SEGD	struct
*	O
seg	pointer
;	O
int	O
dsk_blk_ind	int
;	O
BLOCK	long
next_block	long
;	O
STR	pointer
start_name	pointer
,	O
end_name	pointer
;	O
int	O
start_name_len	int
,	O
end_name_len	int
,	O
level	int
;	O
{	O
STR	pointer
ptr1	pointer
,	O
ptr2	pointer
,	O
ptr3	pointer
,	O
ptr4	pointer
;	O
int	O
errs	int
=	O
0	int
;	O
int	O
i	int
,	O
j	int
;	O
BLOCK	long
block_num	long
,	O
next_block_num	long
;	O
unsigned	O
char	O
*	O
namebuf	pointer
,	O
*	O
namebuf1	pointer
;	O
int	O
namelen	int
,	O
namelen1	int
,	O
err	int
=	O
0	int
;	O
blocks_marked	long
++	O
;	O
total_blocks_marked	long
++	O
;	O
namebuf	pointer
=	O
&	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
last_block_name	array
[	O
0	int
]	O
;	O
namelen	int
=	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
last_block_name_len	int
;	O
namebuf1	pointer
=	O
&	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
current_name	array
[	O
0	int
]	O
;	O
if	O
(	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
blk_num	long
!=	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
act_blk_num	long
)	O
{	O
printf	function
(	O
"\nBLOCK %lu HAS WRONG BLOCK ID, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
act_blk_num	long
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
tree_head	long
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
err	int
++	O
;	O
}	O
if	O
(	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
tree_head	long
!=	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
)	O
{	O
printf	function
(	O
"\nBLOCK %lu HAS WRONG HEAD BLOCK, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
act_blk_num	long
,	O
disk_blocks	array
[	O
0	int
]	O
.	O
act_blk_num	long
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
err	int
++	O
;	O
}	O
if	O
(	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
level	int
!=	O
level	int
)	O
{	O
printf	function
(	O
"\n LEVEL FOR BLOCK IS %d BUT EXPECTED %d"	pointer
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
level	int
,	O
level	int
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
return	O
(	O
++	O
errs	int
)	O
;	O
}	O
if	O
(	O
!	O
set_block_used	function
(	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
act_blk_num	long
)	O
)	O
{	O
printf	function
(	O
"\nBLOCK %lu USED MULTIPLE TIMES"	pointer
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
act_blk_num	long
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
return	O
(	O
++	O
errs	int
)	O
;	O
}	O
if	O
(	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
cont_ptr	long
!=	O
next_block	long
)	O
{	O
printf	function
(	O
"\n NEXT POINTER FOR BLOCK IS %lu BUT EXPECTED %lu"	pointer
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
cont_ptr	long
,	O
next_block	long
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
return	O
(	O
++	O
errs	int
)	O
;	O
}	O
ptr1	pointer
=	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
block	pointer
+	O
blk_data_start	int
+	O
1	int
;	O
i	int
=	O
*	O
ptr1	pointer
++	O
;	O
namelen1	int
=	O
0	int
;	O
while	O
(	O
i	int
--	O
>	O
0	int
)	O
namebuf1	pointer
[	O
namelen1	int
++	O
]	O
=	O
*	O
ptr1	pointer
++	O
;	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
current_name_len	int
=	O
namelen1	int
;	O
if	O
(	O
namelen	int
&&	O
string_compare	function
(	O
namebuf	pointer
,	O
namelen	int
,	O
namebuf1	pointer
,	O
namelen1	int
)	O
!=	O
2	int
)	O
{	O
printf	function
(	O
"\nFIRST ENTRY SMALLER THAN LAST ENTRY IN PREV BLOCK"	pointer
)	O
;	O
printf	function
(	O
"\n PREV NAME: "	pointer
)	O
;	O
dspl_string	function
(	O
namebuf	pointer
,	O
namelen	int
)	O
;	O
printf	function
(	O
"\n CURR NAME: "	pointer
)	O
;	O
dspl_string	function
(	O
namebuf1	pointer
,	O
namelen1	int
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
}	O
if	O
(	O
string_compare	function
(	O
start_name	pointer
,	O
start_name_len	int
,	O
namebuf1	pointer
,	O
namelen1	int
)	O
==	O
1	int
)	O
{	O
printf	function
(	O
"\nFIRST ENTRY SMALLER THAN INDEX SPLITKEY"	pointer
)	O
;	O
printf	function
(	O
"\n SPLIT KEY: "	pointer
)	O
;	O
dspl_string	function
(	O
start_name	pointer
,	O
start_name_len	int
)	O
;	O
printf	function
(	O
"\n CURR NAME: "	pointer
)	O
;	O
dspl_string	function
(	O
namebuf1	pointer
,	O
namelen1	int
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
}	O
ptr1	pointer
=	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
block	pointer
+	O
blk_data_start	int
;	O
ptr2	pointer
=	O
ptr1	pointer
+	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
size	long
;	O
while	O
(	O
ptr1	pointer
<	O
ptr2	pointer
)	O
{	O
ptr1	pointer
++	O
;	O
ptr1	pointer
+=	O
*	O
ptr1	pointer
+	O
1	int
;	O
if	O
(	O
ptr1	pointer
<	O
ptr2	pointer
)	O
{	O
ptr1	pointer
+=	O
*	O
ptr1	pointer
+	O
1	int
;	O
}	O
}	O
if	O
(	O
ptr1	pointer
!=	O
ptr2	pointer
)	O
{	O
printf	function
(	O
"\nBLOCK %lu SIZE ERROR, HEAD BLOCK %lu"	pointer
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
act_blk_num	long
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
tree_head	long
)	O
;	O
err	int
++	O
;	O
}	O
ptr1	pointer
=	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
block	pointer
+	O
blk_data_start	int
;	O
while	O
(	O
(	O
ptr1	pointer
<	O
ptr2	pointer
)	O
&&	O
!	O
fatal_error	int
)	O
{	O
namelen1	int
=	O
*	O
ptr1	pointer
++	O
;	O
i	int
=	O
*	O
ptr1	pointer
++	O
;	O
ptr3	pointer
=	O
ptr1	pointer
+	O
i	int
;	O
ptr3	pointer
+=	O
*	O
ptr3	pointer
+	O
1	int
;	O
j	int
=	O
i	int
;	O
ptr4	pointer
=	O
ptr1	pointer
;	O
while	O
(	O
j	int
--	O
>	O
0	int
)	O
namebuf1	pointer
[	O
namelen1	int
++	O
]	O
=	O
*	O
ptr4	pointer
++	O
;	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
current_name_len	int
=	O
namelen1	int
;	O
if	O
(	O
string_compare	function
(	O
namebuf	pointer
,	O
namelen	int
,	O
namebuf1	pointer
,	O
namelen1	int
)	O
!=	O
2	int
&&	O
namelen	int
)	O
{	O
printf	function
(	O
"\nCOLLATION ERROR"	pointer
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
return	O
(	O
++	O
errs	int
)	O
;	O
}	O
if	O
(	O
ptr3	pointer
<	O
ptr2	pointer
)	O
{	O
block_num	long
=	O
str2long	function
(	O
ptr1	pointer
,	O
i	int
+	O
1	int
)	O
;	O
ptr1	pointer
=	O
ptr3	pointer
+	O
*	O
(	O
ptr3	pointer
+	O
1	int
)	O
+	O
3	int
;	O
if	O
(	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
level	int
!=	O
0	int
)	O
{	O
next_block_num	long
=	O
0	int
;	O
if	O
(	O
ptr1	pointer
<	O
ptr2	pointer
)	O
next_block_num	long
=	O
str2long	function
(	O
ptr1	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
cont_ptr	long
)	O
if	O
(	O
get_ent_copy	function
(	O
temp_block	struct
.	O
entry	struct
,	O
seg	pointer
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
cont_ptr	long
)	O
)	O
{	O
ptr1	pointer
=	O
ent_blk	O
(	O
temp_block	struct
.	O
entry	struct
)	O
+	O
blk_data_start	int
+	O
1	int
;	O
ptr4	pointer
=	O
ent_blk	O
(	O
temp_block	struct
.	O
entry	struct
)	O
+	O
str2short	function
(	O
ent_blk	O
(	O
temp_block	struct
.	O
entry	struct
)	O
,	O
blk_end_pos	int
)	O
;	O
ptr1	pointer
+=	O
*	O
ptr1	pointer
+	O
1	int
;	O
i	int
=	O
*	O
ptr1	pointer
++	O
;	O
if	O
(	O
ptr1	pointer
+	O
i	int
+	O
1	int
<	O
ptr4	pointer
)	O
next_block_num	long
=	O
str2long	function
(	O
ptr1	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
read_block	function
(	O
seg	pointer
,	O
block_num	long
,	O
&	O
disk_blocks	array
[	O
dsk_blk_ind	int
+	O
1	int
]	O
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
tree_head	long
)	O
)	O
{	O
printf	function
(	O
"\nERROR READING BLOCK %lu"	pointer
,	O
block_num	long
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
}	O
else	O
errs	int
+=	O
check_struct_level	function
(	O
seg	pointer
,	O
dsk_blk_ind	int
+	O
1	int
,	O
next_block_num	long
,	O
namebuf	pointer
,	O
namelen	int
,	O
namebuf1	pointer
,	O
namelen1	int
,	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
level	int
-	O
1	int
)	O
;	O
}	O
namelen	int
=	O
0	int
;	O
while	O
(	O
namelen	int
<	O
namelen1	int
)	O
{	O
namebuf	pointer
[	O
namelen	int
]	O
=	O
namebuf1	pointer
[	O
namelen	int
]	O
;	O
namelen	int
++	O
;	O
}	O
disk_blocks	array
[	O
dsk_blk_ind	int
]	O
.	O
last_block_name_len	int
=	O
namelen	int
;	O
}	O
else	O
if	O
(	O
string_compare	function
(	O
end_name	pointer
,	O
end_name_len	int
,	O
namebuf1	pointer
,	O
namelen1	int
)	O
!=	O
0	int
)	O
{	O
printf	function
(	O
"\nSPLIT KEY MISMATCH"	pointer
)	O
;	O
path	function
(	O
dsk_blk_ind	int
)	O
;	O
return	O
(	O
++	O
errs	int
)	O
;	O
}	O
ptr1	pointer
=	O
ptr3	pointer
;	O
}	O
return	O
(	O
errs	int
)	O
;	O
}	O
void	O
check_struct	function
(	O
seg	pointer
,	O
blk_num	long
,	O
name	int
,	O
len	int
,	O
dirdepth	int
)	O
SEGD	struct
*	O
seg	pointer
;	O
BLOCK	long
blk_num	long
;	O
STR	pointer
name	int
;	O
int	O
len	int
;	O
int	O
dirdepth	int
;	O
{	O
unsigned	O
char	O
start	array
[	O
1	int
]	O
,	O
end	array
[	O
3	int
]	O
;	O
unsigned	O
long	O
int	O
blocks_in_directory	long
=	O
0	int
;	O
int	O
directory	int
=	O
0	int
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
MAX_LEVELS	int
)	O
{	O
disk_blocks	array
[	O
i	int
]	O
.	O
last_block_name_len	int
=	O
0	int
;	O
disk_blocks	array
[	O
i	int
]	O
.	O
current_name_len	int
=	O
0	int
;	O
i	int
++	O
;	O
}	O
if	O
(	O
read_block	function
(	O
seg	pointer
,	O
blk_num	long
,	O
&	O
disk_blocks	array
[	O
0	int
]	O
,	O
blk_num	long
)	O
)	O
{	O
printf	function
(	O
"\nERROR READING BLOCK"	pointer
)	O
;	O
++	O
error_count	int
;	O
return	O
;	O
}	O
if	O
(	O
!	O
root_P	O
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
block	pointer
)	O
)	O
{	O
printf	function
(	O
"\nNOT A ROOT BLOCK\n"	pointer
)	O
;	O
++	O
error_count	int
;	O
return	O
;	O
}	O
if	O
(	O
blk_typ_P	O
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
block	pointer
,	O
dir_typ	int
)	O
)	O
{	O
printf	function
(	O
"\n%*s"	pointer
,	O
dirdepth	int
,	O
" "	pointer
)	O
;	O
dspl_string	function
(	O
name	int
,	O
len	int
)	O
;	O
printf	function
(	O
" -> block number: %lu"	pointer
,	O
blk_num	long
)	O
;	O
directory	int
=	O
1	int
;	O
}	O
blocks_marked	long
=	O
0	int
;	O
end	array
[	O
0	int
]	O
=	O
255	int
;	O
end	array
[	O
1	int
]	O
=	O
disk_blocks	array
[	O
0	int
]	O
.	O
level	int
+	O
'0'	O
;	O
if	O
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
type	int
==	O
seq_typ	int
)	O
{	O
error_count	int
+=	O
check_saf	function
(	O
seg	pointer
,	O
name	int
,	O
len	int
)	O
;	O
blocks_in_directory	long
+=	O
blocks_marked	long
;	O
}	O
else	O
if	O
(	O
!	O
(	O
i	int
=	O
check_struct_level	function
(	O
seg	pointer
,	O
0	int
,	O
0L	int
,	O
start	array
,	O
0	int
,	O
end	array
,	O
2	int
,	O
disk_blocks	array
[	O
0	int
]	O
.	O
level	int
)	O
)	O
&&	O
follow_dirs	int
&&	O
(	O
blk_typ_P	O
(	O
disk_blocks	array
[	O
0	int
]	O
.	O
block	pointer
,	O
dir_typ	int
)	O
)	O
)	O
{	O
unsigned	O
char	O
key	array
[	O
256	int
]	O
,	O
val	array
[	O
256	int
]	O
;	O
int	O
klen	int
=	O
0	int
,	O
vlen	int
;	O
HAND	struct
han	pointer
;	O
bt_open	function
(	O
seg	pointer
,	O
blk_num	long
,	O
&	O
han	pointer
,	O
0	int
)	O
;	O
blocks_in_directory	long
+=	O
blocks_marked	long
;	O
while	O
(	O
(	O
klen	int
=	O
bt_next	function
(	O
&	O
han	pointer
,	O
key	array
,	O
klen	int
,	O
key	array
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
(	O
vlen	int
=	O
bt_get	function
(	O
&	O
han	pointer
,	O
key	array
,	O
klen	int
,	O
val	array
)	O
)	O
>=	O
5	int
)	O
&&	O
(	O
4	int
==	O
val	array
[	O
0	int
]	O
)	O
)	O
{	O
blocks_marked	long
=	O
0	int
;	O
check_struct	function
(	O
seg	pointer
,	O
str2long	function
(	O
val	array
,	O
1	int
)	O
,	O
key	array
,	O
klen	int
,	O
1	int
+	O
dirdepth	int
)	O
;	O
blocks_in_directory	long
+=	O
blocks_marked	long
;	O
}	O
}	O
}	O
else	O
{	O
error_count	int
+=	O
i	int
;	O
blocks_in_directory	long
+=	O
blocks_marked	long
;	O
}	O
blocks_marked	long
=	O
blocks_in_directory	long
;	O
if	O
(	O
directory	int
)	O
{	O
printf	function
(	O
"\n%*s%lu BLOCKS"	pointer
,	O
dirdepth	int
,	O
" "	pointer
,	O
blocks_in_directory	long
)	O
;	O
}	O
}	O
BLOCK	long
nextnum	function
(	O
hand	pointer
,	O
key	array
,	O
klen	int
)	O
HAND	struct
*	O
hand	pointer
;	O
STR	pointer
key	array
;	O
int	O
klen	int
;	O
{	O
klen	int
=	O
bt_next	function
(	O
hand	pointer
,	O
key	array
,	O
klen	int
,	O
key	array
)	O
;	O
if	O
(	O
klen	int
<=	O
0	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
klen	int
!=	O
4	int
)	O
{	O
printf	function
(	O
"BAD SIZE KEY IN FREELIST\n"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
return	O
str2long	function
(	O
key	array
,	O
0	int
)	O
;	O
}	O
int	O
wbcheck_usage	function
(	O
)	O
{	O
printf	function
(	O
"\nUsage: wbcheck FILE\nUsage: wbcheck FILE BLOCKNUMBER\n\n  Checks the structure of the database named by FILE and\n  reclaims temporary trees to the freelist.\n"	pointer
)	O
;	O
return	O
2	int
;	O
}	O
int	O
main	function
(	O
argc	int
,	O
argv	array
)	O
int	O
argc	int
;	O
char	O
*	O
argv	array
[	O
]	O
;	O
{	O
unsigned	O
int	O
i	int
=	O
0	int
;	O
BLOCK	long
blk_num	long
=	O
0	int
;	O
SEGD	struct
*	O
seg	pointer
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
printf	function
(	O
"NO FILE\n"	pointer
)	O
;	O
return	O
wbcheck_usage	function
(	O
)	O
;	O
}	O
if	O
(	O
argc	int
>	O
3	int
)	O
{	O
printf	function
(	O
"TOO MANY ARGUMENTS\n"	pointer
)	O
;	O
return	O
wbcheck_usage	function
(	O
)	O
;	O
}	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
char	O
*	O
ptr1	pointer
,	O
*	O
ptr	pointer
=	O
&	O
argv	array
[	O
2	int
]	O
[	O
0	int
]	O
;	O
ptr1	pointer
=	O
ptr	pointer
;	O
while	O
(	O
(	O
*	O
ptr1	pointer
>=	O
'0'	O
)	O
&&	O
(	O
*	O
ptr1	pointer
<=	O
'9'	O
)	O
)	O
ptr1	pointer
++	O
;	O
if	O
(	O
*	O
ptr1	pointer
)	O
{	O
printf	function
(	O
"NOT A NUMBER\n"	pointer
)	O
;	O
return	O
wbcheck_usage	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
cnv_string_to_long	function
(	O
ptr	pointer
,	O
ptr1	pointer
,	O
&	O
blk_num	long
)	O
)	O
{	O
printf	function
(	O
"NUMBER TOO LARGE\n"	pointer
)	O
;	O
return	O
wbcheck_usage	function
(	O
)	O
;	O
}	O
blkgc	int
=	O
0	int
;	O
follow_dirs	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
"--help"	pointer
,	O
argv	array
[	O
1	int
]	O
)	O
)	O
{	O
wbcheck_usage	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
init_wb	function
(	O
75	int
,	O
150	int
,	O
16384	int
)	O
;	O
seg	pointer
=	O
open_seg	function
(	O
argv	array
[	O
1	int
]	O
,	O
blkgc	int
)	O
;	O
if	O
(	O
seg	pointer
==	O
0	int
)	O
{	O
seg	pointer
=	O
open_segd	function
(	O
argv	array
[	O
1	int
]	O
,	O
blkgc	int
,	O
!	O
0	int
)	O
;	O
if	O
(	O
seg	pointer
==	O
0	int
)	O
{	O
printf	function
(	O
"COULD NOT OPEN FILE \"%s\"\n"	pointer
,	O
argv	array
[	O
1	int
]	O
)	O
;	O
return	O
2	int
;	O
}	O
printf	function
(	O
"OPENING CORRUPTLY CLOSED FILE\n"	pointer
)	O
;	O
}	O
while	O
(	O
(	O
i	int
<	O
MAX_LEVELS	int
)	O
&&	O
(	O
disk_blocks	array
[	O
i	int
]	O
.	O
entry	struct
=	O
allocate_ent	function
(	O
)	O
)	O
)	O
i	int
++	O
;	O
if	O
(	O
i	int
<	O
MAX_LEVELS	int
||	O
!	O
(	O
temp_block	struct
.	O
entry	struct
=	O
allocate_ent	function
(	O
)	O
)	O
)	O
{	O
printf	function
(	O
"UNABLE TO ALLOCATE ENOUGH ENTRIES\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
MAP_SIZE	int
)	O
free_map	array
[	O
i	int
++	O
]	O
=	O
0	int
;	O
error_count	int
=	O
0	int
;	O
fatal_error	int
=	O
0	int
;	O
total_blocks_marked	long
=	O
0	int
;	O
check_struct	function
(	O
seg	pointer
,	O
blk_num	long
,	O
""	pointer
,	O
0	int
,	O
1	int
)	O
;	O
printf	function
(	O
"\n%lu BLOCKS MARKED IN USE"	pointer
,	O
total_blocks_marked	long
)	O
;	O
if	O
(	O
error_count	int
)	O
{	O
printf	function
(	O
"\n %d ERRORS\n"	pointer
,	O
error_count	int
)	O
;	O
return	O
1	int
;	O
}	O
printf	function
(	O
"\nNO STRUCTURE ERRORS FOUND\n"	pointer
)	O
;	O
if	O
(	O
!	O
blkgc	int
)	O
return	O
0	int
;	O
{	O
HAND	struct
han	pointer
;	O
unsigned	O
char	O
key	array
[	O
5	int
*	O
4	int
]	O
,	O
tmp	array
[	O
4	int
]	O
;	O
BLOCK	long
used	long
=	O
0	int
,	O
num_freed	long
=	O
0	int
,	O
num_collected	long
=	O
0	int
,	O
fnum	long
;	O
int	O
flc_image_len	int
,	O
i	int
,	O
j	int
=	O
0	int
;	O
bt_open	function
(	O
seg	pointer
,	O
0L	int
,	O
&	O
han	pointer
,	O
0	int
)	O
;	O
if	O
(	O
4	int
!=	O
bt_get	function
(	O
&	O
han	pointer
,	O
"USED"	pointer
,	O
4	int
,	O
key	array
)	O
)	O
exit	function
(	O
2	int
)	O
;	O
used	long
=	O
str2long	function
(	O
key	array
,	O
0	int
)	O
;	O
flc_image_len	int
=	O
bt_get	function
(	O
&	O
han	pointer
,	O
"FLC"	pointer
,	O
3	int
,	O
key	array
)	O
;	O
bt_open	function
(	O
seg	pointer
,	O
2L	int
,	O
&	O
han	pointer
,	O
0	int
)	O
;	O
if	O
(	O
0	int
>	O
(	O
flc_image_len	int
)	O
)	O
flc_image_len	int
=	O
0	int
;	O
i	int
=	O
-	O
4	int
+	O
(	O
flc_image_len	int
)	O
;	O
while	O
(	O
0	int
<=	O
i	int
)	O
{	O
fnum	long
=	O
str2long	function
(	O
key	array
,	O
i	int
)	O
;	O
if	O
(	O
!	O
(	O
get_block_used	function
(	O
fnum	long
)	O
||	O
(	O
0	int
<	O
bt_get	function
(	O
&	O
han	pointer
,	O
&	O
key	array
[	O
i	int
]	O
,	O
4	int
,	O
tmp	array
)	O
)	O
)	O
)	O
{	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
j	int
++	O
]	O
=	O
str2long	function
(	O
key	array
,	O
i	int
)	O
;	O
set_block_used	function
(	O
fnum	long
)	O
;	O
}	O
i	int
=	O
-	O
4	int
+	O
(	O
i	int
)	O
;	O
}	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
j	int
)	O
;	O
blk_num	long
=	O
nextnum	function
(	O
&	O
han	pointer
,	O
key	array
,	O
0	int
)	O
;	O
while	O
(	O
blk_num	long
)	O
{	O
if	O
(	O
get_block_used	function
(	O
blk_num	long
)	O
)	O
{	O
printf	function
(	O
"\nA block in the FREELIST is acutally being used: %lu"	pointer
,	O
blk_num	long
)	O
;	O
num_freed	long
++	O
;	O
flush_flc	function
(	O
seg	pointer
,	O
flc_len	int
-	O
5	int
)	O
;	O
bt_rem	function
(	O
&	O
han	pointer
,	O
key	array
,	O
4	int
,	O
0L	int
)	O
;	O
}	O
else	O
set_block_used	function
(	O
blk_num	long
)	O
;	O
blk_num	long
=	O
nextnum	function
(	O
&	O
han	pointer
,	O
key	array
,	O
4	int
)	O
;	O
}	O
blk_num	long
=	O
0	int
;	O
printf	function
(	O
"\n    reclaiming unused blocks:"	pointer
)	O
;	O
while	O
(	O
used	long
>	O
++	O
blk_num	long
)	O
if	O
(	O
!	O
get_block_used	function
(	O
blk_num	long
)	O
)	O
{	O
printf	function
(	O
" %lu"	pointer
,	O
blk_num	long
)	O
;	O
num_collected	long
++	O
;	O
flc_fill	function
(	O
seg	pointer
)	O
;	O
flush_flc	function
(	O
seg	pointer
,	O
flc_len	int
-	O
2	int
)	O
;	O
lck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
seg_flc	O
(	O
seg	pointer
)	O
[	O
seg_flc_len	O
(	O
seg	pointer
)	O
]	O
=	O
blk_num	long
;	O
seg_set_flc_len	O
(	O
seg	pointer
,	O
1	int
+	O
seg_flc_len	O
(	O
seg	pointer
)	O
)	O
;	O
unlck	function
(	O
seg_lck	O
(	O
seg	pointer
)	O
)	O
;	O
}	O
close_seg	function
(	O
seg	pointer
,	O
1	int
)	O
;	O
printf	function
(	O
"\nFREELIST: %lu blocks removed; %lu blocks added.\n"	pointer
,	O
num_freed	long
,	O
num_collected	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
display_disk_statistics	function
(	O
b	long
,	O
t	char
,	O
r	long
,	O
w	long
)	O
BLOCK	long
b	long
;	O
char	O
t	char
;	O
unsigned	O
long	O
r	long
,	O
w	long
;	O
{	O
}	O
