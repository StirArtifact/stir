int	O
keep_going	int
;	O
int	O
compile_only	int
;	O
char	O
*	O
mbox_url	pointer
;	O
int	O
sieve_debug	int
;	O
int	O
verbose	int
;	O
char	O
*	O
script	pointer
;	O
int	O
expression_option	int
;	O
int	O
dry_run	int
;	O
static	O
int	O
sieve_print_locus	int
=	O
1	int
;	O
static	O
int	O
no_program_name	int
;	O
static	O
mu_list_t	pointer
env_list	pointer
;	O
static	O
mu_list_t	pointer
var_list	pointer
;	O
static	O
int	O
sieve_setenv	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
char	O
*	O
str	pointer
=	O
item	pointer
;	O
mu_sieve_machine_t	pointer
mach	pointer
=	O
data	pointer
;	O
int	O
rc	int
=	O
mu_sieve_set_environ	function
(	O
mach	pointer
,	O
str	pointer
,	O
str	pointer
+	O
strlen	function
(	O
str	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"can't set environment item %s: %s"	pointer
)	O
,	O
str	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
sieve_setvar	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
char	O
*	O
str	pointer
=	O
item	pointer
;	O
mu_sieve_machine_t	pointer
mach	pointer
=	O
data	pointer
;	O
mu_sieve_variable_initialize	function
(	O
mach	pointer
,	O
str	pointer
,	O
str	pointer
+	O
strlen	function
(	O
str	pointer
)	O
+	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
modify_debug_flags	function
(	O
mu_debug_level_t	int
set	pointer
,	O
mu_debug_level_t	int
clr	int
)	O
{	O
mu_debug_level_t	int
lev	int
;	O
mu_debug_get_category_level	function
(	O
mu_sieve_debug_handle	int
,	O
&	O
lev	int
)	O
;	O
mu_debug_set_category_level	function
(	O
mu_sieve_debug_handle	int
,	O
(	O
lev	int
&	O
~	O
clr	int
)	O
|	O
set	pointer
)	O
;	O
}	O
static	O
void	O
set_debug_level	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
for	O
(	O
;	O
*	O
arg	pointer
;	O
arg	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
arg	pointer
)	O
{	O
case	O
'T'	O
:	O
modify_debug_flags	function
(	O
MU_DEBUG_LEVEL_UPTO	O
(	O
MU_DEBUG_TRACE9	int
)	O
,	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_ERROR	int
)	O
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
modify_debug_flags	function
(	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_PROT	int
)	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
modify_debug_flags	function
(	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_TRACE1	int
)	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
modify_debug_flags	function
(	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_TRACE4	int
)	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
modify_debug_flags	function
(	O
MU_DEBUG_LEVEL_MASK	O
(	O
MU_DEBUG_TRACE9	int
)	O
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
mu_error	function
(	O
_	O
(	O
"%c is not a valid debug flag"	pointer
)	O
,	O
*	O
arg	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
cli_compile_and_dump	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
compile_only	int
=	O
2	int
;	O
}	O
static	O
void	O
cli_debug	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
set_debug_level	function
(	O
arg	pointer
)	O
;	O
}	O
static	O
void	O
cli_email	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
int	O
rc	int
=	O
mu_set_user_email	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_parseopt_error	function
(	O
po	pointer
,	O
_	O
(	O
"invalid email: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
static	O
void	O
assign	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
,	O
mu_list_t	pointer
*	O
plist	pointer
,	O
char	O
const	O
*	O
what	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
arg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
mu_parseopt_error	function
(	O
po	pointer
,	O
_	O
(	O
"malformed %s: %s"	pointer
)	O
,	O
what	pointer
,	O
arg	pointer
)	O
;	O
else	O
{	O
char	O
*	O
str	pointer
;	O
str	pointer
=	O
mu_strdup	function
(	O
arg	pointer
)	O
;	O
str	pointer
[	O
p	pointer
-	O
arg	pointer
]	O
=	O
0	int
;	O
if	O
(	O
!	O
*	O
plist	pointer
)	O
{	O
mu_list_create	function
(	O
plist	pointer
)	O
;	O
mu_list_set_destroy_item	function
(	O
*	O
plist	pointer
,	O
mu_list_free_item	function
)	O
;	O
}	O
mu_list_append	function
(	O
*	O
plist	pointer
,	O
str	pointer
)	O
;	O
}	O
}	O
static	O
void	O
cli_env	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
assign	function
(	O
po	pointer
,	O
opt	pointer
,	O
arg	pointer
,	O
&	O
env_list	pointer
,	O
_	O
(	O
"environment setting"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
cli_var	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
assign	function
(	O
po	pointer
,	O
opt	pointer
,	O
arg	pointer
,	O
&	O
var_list	pointer
,	O
_	O
(	O
"variable assignment"	pointer
)	O
)	O
;	O
}	O
static	O
struct	O
mu_option	struct
sieve_options	array
[	O
]	O
=	O
{	O
{	O
"dry-run"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"do not execute any actions, just print what would be done"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
dry_run	int
}	O
,	O
{	O
"no-actions"	pointer
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_ALIAS	int
}	O
,	O
{	O
"keep-going"	pointer
,	O
'k'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"keep on going if execution fails on a message"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
keep_going	int
}	O
,	O
{	O
"compile-only"	pointer
,	O
'c'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"compile script and exit"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
compile_only	int
}	O
,	O
{	O
"dump"	pointer
,	O
'D'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"compile script, dump disassembled sieve code to terminal and exit"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_compile_and_dump	function
}	O
,	O
{	O
"mbox-url"	pointer
,	O
'f'	O
,	O
N_	O
(	O
"MBOX"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"mailbox to sieve (defaults to user's mail spool)"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
mbox_url	pointer
}	O
,	O
{	O
"ticket"	pointer
,	O
't'	O
,	O
N_	O
(	O
"TICKET"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"ticket file for user authentication"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
mu_ticket_file	pointer
}	O
,	O
{	O
"debug"	pointer
,	O
'd'	O
,	O
N_	O
(	O
"FLAGS"	pointer
)	O
,	O
MU_OPTION_ARG_OPTIONAL	int
,	O
N_	O
(	O
"debug flags (defaults to \""	pointer
D_DEFAULT	pointer
"\")"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_debug	function
,	O
D_DEFAULT	pointer
}	O
,	O
{	O
"verbose"	pointer
,	O
'v'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"log all actions"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
verbose	int
}	O
,	O
{	O
"line-info"	pointer
,	O
0	int
,	O
N_	O
(	O
"BOOL"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"print source location along with action logs (default)"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
sieve_print_locus	int
}	O
,	O
{	O
"email"	pointer
,	O
'e'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"override user email address"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_email	function
}	O
,	O
{	O
"expression"	pointer
,	O
'E'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"treat SCRIPT as Sieve program text"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
expression_option	int
}	O
,	O
{	O
"no-program-name"	pointer
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"do not prefix diagnostic messages with the program name"	pointer
)	O
,	O
mu_c_int	int
,	O
&	O
no_program_name	int
}	O
,	O
{	O
"environment"	pointer
,	O
0	int
,	O
N_	O
(	O
"NAME=VALUE"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set sieve environment value"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_env	function
}	O
,	O
{	O
"variable"	pointer
,	O
0	int
,	O
N_	O
(	O
"NAME=VALUE"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set sieve variable"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_var	function
}	O
,	O
MU_OPTION_END	O
}	O
,	O
*	O
options	array
[	O
]	O
=	O
{	O
sieve_options	array
,	O
NULL	O
}	O
;	O
int	O
mu_compat_printer	function
(	O
void	O
*	O
data	pointer
,	O
mu_log_level_t	int
level	int
,	O
const	O
char	O
*	O
buf	pointer
)	O
{	O
fputs	function
(	O
buf	pointer
,	O
stderr	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_debug	function
(	O
void	O
*	O
data	pointer
,	O
mu_config_value_t	struct
*	O
val	pointer
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
val	pointer
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
set_debug_level	function
(	O
val	pointer
->	O
v	array
.	O
string	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_email	function
(	O
void	O
*	O
data	pointer
,	O
mu_config_value_t	struct
*	O
val	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
val	pointer
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_set_user_email	function
(	O
val	pointer
->	O
v	array
.	O
string	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"invalid email: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct
sieve_cfg_param	array
[	O
]	O
=	O
{	O
{	O
"keep-going"	pointer
,	O
mu_c_bool	int
,	O
&	O
keep_going	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Do not abort if execution fails on a message."	pointer
)	O
}	O
,	O
{	O
"mbox-url"	pointer
,	O
mu_c_string	int
,	O
&	O
mbox_url	pointer
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Mailbox to sieve (defaults to user's mail spool)."	pointer
)	O
,	O
N_	O
(	O
"url"	pointer
)	O
}	O
,	O
{	O
"ticket"	pointer
,	O
mu_c_string	int
,	O
&	O
mu_ticket_file	pointer
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Ticket file for user authentication."	pointer
)	O
,	O
N_	O
(	O
"ticket"	pointer
)	O
}	O
,	O
{	O
"debug"	pointer
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_debug	function
,	O
N_	O
(	O
"Debug flags.  Argument consists of one or more of the following "	pointer
"flags:\n"	pointer
"   g - main parser traces\n"	pointer
"   T - mailutils traces (sieve.trace9)\n"	pointer
"   P - network protocols (sieve.prot)\n"	pointer
"   t - sieve trace (MU_SIEVE_DEBUG_TRACE)\n"	pointer
"   i - sieve instructions trace (MU_SIEVE_DEBUG_INSTR)."	pointer
)	O
,	O
N_	O
(	O
"arg: string"	pointer
)	O
}	O
,	O
{	O
"verbose"	pointer
,	O
mu_c_bool	int
,	O
&	O
verbose	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Log all executed actions."	pointer
)	O
}	O
,	O
{	O
"line-info"	pointer
,	O
mu_c_bool	int
,	O
&	O
sieve_print_locus	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Print source locations along with action logs (default)."	pointer
)	O
}	O
,	O
{	O
"email"	pointer
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_email	function
,	O
N_	O
(	O
"Set user email address."	pointer
)	O
,	O
N_	O
(	O
"arg: string"	pointer
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
char	O
*	O
sieve_capa	array
[	O
]	O
=	O
{	O
"debug"	pointer
,	O
"mailbox"	pointer
,	O
"locking"	pointer
,	O
"logging"	pointer
,	O
"mailer"	pointer
,	O
"sieve"	pointer
,	O
NULL	O
}	O
;	O
static	O
struct	O
mu_cli_setup	struct
cli	struct
=	O
{	O
options	array
,	O
sieve_cfg_param	array
,	O
N_	O
(	O
"GNU sieve -- a mail filtering tool."	pointer
)	O
,	O
"SCRIPT"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"Sieve-specific debug levels:\n\n  trace1  -  print parse tree before optimization\n  trace2  -  print parse tree after optimization\n  trace3  -  print parser traces\n  trace4  -  print tests and actions being executed\n  trace9  -  print each Sieve instruction being executed\n\nCompatibility debug flags:\n  g - main parser traces\n  T - mailutils traces (same as --debug-level=sieve.trace0-trace1)\n  P - network protocols (same as --debug-level=sieve.=prot)\n  t - sieve trace (same as --debug-level=sieve.=trace4)\n  i - sieve instructions trace (same as --debug-level=sieve.=trace9)\n"	pointer
)	O
}	O
;	O
static	O
void	O
_sieve_action_log	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
const	O
char	O
*	O
action	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
size_t	long
uid	int
=	O
0	int
;	O
mu_message_t	pointer
msg	pointer
;	O
mu_stream_t	pointer
stream	pointer
;	O
mu_sieve_get_diag_stream	function
(	O
mach	pointer
,	O
&	O
stream	pointer
)	O
;	O
msg	pointer
=	O
mu_sieve_get_message	function
(	O
mach	pointer
)	O
;	O
mu_message_get_uid	function
(	O
msg	pointer
,	O
&	O
uid	int
)	O
;	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"\033s<%d>\033%c<%d>"	pointer
,	O
MU_LOG_NOTICE	int
,	O
sieve_print_locus	int
?	O
'O'	O
:	O
'X'	O
,	O
MU_LOGMODE_LOCUS	int
)	O
;	O
mu_stream_printf	function
(	O
stream	pointer
,	O
_	O
(	O
"%s on msg uid %lu"	pointer
)	O
,	O
action	pointer
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
if	O
(	O
fmt	pointer
&&	O
strlen	function
(	O
fmt	pointer
)	O
)	O
{	O
mu_stream_printf	function
(	O
stream	pointer
,	O
": "	pointer
)	O
;	O
mu_stream_vprintf	function
(	O
stream	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
}	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"\n"	pointer
)	O
;	O
mu_stream_unref	function
(	O
stream	pointer
)	O
;	O
}	O
static	O
int	O
sieve_message	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	pointer
instr	pointer
;	O
mu_message_t	pointer
msg	pointer
;	O
mu_attribute_t	pointer
attr	pointer
;	O
rc	int
=	O
mu_stdio_stream_create	function
(	O
&	O
instr	pointer
,	O
MU_STDIN_FD	int
,	O
MU_STREAM_SEEK	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot create stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
EX_SOFTWARE	int
;	O
}	O
rc	int
=	O
mu_stream_to_message	function
(	O
instr	pointer
,	O
&	O
msg	pointer
)	O
;	O
mu_stream_unref	function
(	O
instr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot create message from stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
EX_SOFTWARE	int
;	O
}	O
mu_message_get_attribute	function
(	O
msg	pointer
,	O
&	O
attr	pointer
)	O
;	O
mu_attribute_unset_deleted	function
(	O
attr	pointer
)	O
;	O
rc	int
=	O
mu_sieve_message	function
(	O
mach	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
EX_SOFTWARE	int
;	O
return	O
mu_attribute_is_deleted	function
(	O
attr	pointer
)	O
?	O
1	int
:	O
EX_OK	int
;	O
}	O
static	O
int	O
sieve_mailbox	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
int	O
rc	int
;	O
mu_mailbox_t	pointer
mbox	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_create_default	function
(	O
&	O
mbox	pointer
,	O
mbox_url	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
mbox	pointer
)	O
mu_error	function
(	O
_	O
(	O
"could not create mailbox `%s': %s"	pointer
)	O
,	O
mbox_url	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
else	O
mu_error	function
(	O
_	O
(	O
"could not create default mailbox: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
mu_sieve_is_dry_run	function
(	O
mach	pointer
)	O
)	O
rc	int
=	O
mu_mailbox_open	function
(	O
mbox	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
else	O
rc	int
=	O
mu_mailbox_open	function
(	O
mbox	pointer
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
{	O
if	O
(	O
mbox	pointer
)	O
{	O
mu_url_t	pointer
url	pointer
=	O
NULL	O
;	O
mu_mailbox_get_url	function
(	O
mbox	pointer
,	O
&	O
url	pointer
)	O
;	O
mu_error	function
(	O
_	O
(	O
"cannot open mailbox %s: %s"	pointer
)	O
,	O
mu_url_to_string	function
(	O
url	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
mu_error	function
(	O
_	O
(	O
"cannot open default mailbox: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_mailbox_destroy	function
(	O
&	O
mbox	pointer
)	O
;	O
goto	O
cleanup	O
;	O
}	O
rc	int
=	O
mu_sieve_mailbox	function
(	O
mach	pointer
,	O
mbox	pointer
)	O
;	O
cleanup	O
:	O
if	O
(	O
mbox	pointer
&&	O
!	O
dry_run	int
)	O
{	O
int	O
e	pointer
;	O
if	O
(	O
(	O
e	pointer
=	O
mu_mailbox_expunge	function
(	O
mbox	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
mbox	pointer
)	O
mu_error	function
(	O
_	O
(	O
"expunge on mailbox `%s' failed: %s"	pointer
)	O
,	O
mbox_url	pointer
,	O
mu_strerror	function
(	O
e	pointer
)	O
)	O
;	O
else	O
mu_error	function
(	O
_	O
(	O
"expunge on default mailbox failed: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
e	pointer
)	O
)	O
;	O
}	O
if	O
(	O
e	pointer
&&	O
!	O
rc	int
)	O
rc	int
=	O
e	pointer
;	O
}	O
mu_sieve_machine_destroy	function
(	O
&	O
mach	pointer
)	O
;	O
mu_mailbox_close	function
(	O
mbox	pointer
)	O
;	O
mu_mailbox_destroy	function
(	O
&	O
mbox	pointer
)	O
;	O
return	O
rc	int
?	O
EX_SOFTWARE	int
:	O
EX_OK	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	long
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
mu_sieve_machine_t	pointer
mach	pointer
;	O
int	O
rc	int
;	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
mu_auth_register_module	function
(	O
&	O
mu_auth_tls_module	struct
)	O
;	O
mu_cli_capa_register	function
(	O
&	O
mu_cli_capa_sieve	struct
)	O
;	O
mu_sieve_debug_init	function
(	O
)	O
;	O
mu_register_all_formats	O
(	O
)	O
;	O
mu_cli	function
(	O
argc	long
,	O
argv	pointer
,	O
&	O
cli	struct
,	O
sieve_capa	array
,	O
NULL	O
,	O
&	O
argc	long
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
dry_run	int
)	O
verbose	int
++	O
;	O
if	O
(	O
no_program_name	int
)	O
{	O
mu_stream_t	pointer
errstr	pointer
;	O
mu_log_tag	pointer
=	O
NULL	O
;	O
rc	int
=	O
mu_stdstream_strerr_create	function
(	O
&	O
errstr	pointer
,	O
MU_STRERR_STDERR	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_stream_destroy	function
(	O
&	O
mu_strerr	pointer
)	O
;	O
mu_strerr	pointer
=	O
errstr	pointer
;	O
}	O
}	O
if	O
(	O
argc	long
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"script must be specified"	pointer
)	O
)	O
;	O
exit	function
(	O
EX_USAGE	int
)	O
;	O
}	O
else	O
if	O
(	O
argc	long
==	O
1	int
)	O
{	O
if	O
(	O
expression_option	int
)	O
script	pointer
=	O
mu_strdup	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
mu_stream_t	pointer
mstr	pointer
;	O
mu_off_t	long
size	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_memory_stream_create	function
(	O
&	O
mstr	pointer
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_memory_stream_create"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
EX_SOFTWARE	int
)	O
;	O
}	O
rc	int
=	O
mu_stream_copy	function
(	O
mstr	pointer
,	O
mu_strin	pointer
,	O
0	int
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_copy"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
EX_SOFTWARE	int
)	O
;	O
}	O
rc	int
=	O
mu_stream_seek	function
(	O
mstr	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
EX_SOFTWARE	int
)	O
;	O
}	O
script	pointer
=	O
mu_alloc	function
(	O
size	long
+	O
1	int
)	O
;	O
rc	int
=	O
mu_stream_read	function
(	O
mstr	pointer
,	O
script	pointer
,	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_read"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
EX_SOFTWARE	int
)	O
;	O
}	O
script	pointer
[	O
size	long
]	O
=	O
0	int
;	O
mu_stream_destroy	function
(	O
&	O
mstr	pointer
)	O
;	O
expression_option	int
=	O
1	int
;	O
}	O
else	O
script	pointer
=	O
mu_tilde_expansion	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
mu_error	function
(	O
_	O
(	O
"only one SCRIPT can be specified"	pointer
)	O
)	O
;	O
exit	function
(	O
EX_USAGE	int
)	O
;	O
}	O
rc	int
=	O
mu_sieve_machine_create	function
(	O
&	O
mach	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot initialize sieve machine: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
EX_SOFTWARE	int
;	O
}	O
mu_sieve_set_environ	function
(	O
mach	pointer
,	O
"location"	pointer
,	O
"MS"	pointer
)	O
;	O
mu_sieve_set_environ	function
(	O
mach	pointer
,	O
"phase"	pointer
,	O
"post"	pointer
)	O
;	O
mu_list_foreach	function
(	O
env_list	pointer
,	O
sieve_setenv	function
,	O
mach	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
env_list	pointer
)	O
;	O
if	O
(	O
var_list	pointer
)	O
{	O
mu_sieve_require_variables	function
(	O
mach	pointer
)	O
;	O
mu_list_foreach	function
(	O
var_list	pointer
,	O
sieve_setvar	function
,	O
mach	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
var_list	pointer
)	O
;	O
}	O
if	O
(	O
verbose	int
)	O
mu_sieve_set_logger	function
(	O
mach	pointer
,	O
_sieve_action_log	function
)	O
;	O
if	O
(	O
expression_option	int
)	O
{	O
struct	O
mu_locus_point	struct
pt	pointer
;	O
pt	pointer
.	O
mu_file	pointer
=	O
"stdin"	pointer
;	O
pt	pointer
.	O
mu_line	int
=	O
1	int
;	O
pt	pointer
.	O
mu_col	int
=	O
0	int
;	O
rc	int
=	O
mu_sieve_compile_text	function
(	O
mach	pointer
,	O
script	pointer
,	O
strlen	function
(	O
script	pointer
)	O
,	O
&	O
pt	pointer
)	O
;	O
}	O
else	O
rc	int
=	O
mu_sieve_compile	function
(	O
mach	pointer
,	O
script	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
EX_CONFIG	int
;	O
if	O
(	O
compile_only	int
)	O
{	O
if	O
(	O
compile_only	int
==	O
2	int
)	O
{	O
mu_sieve_set_dbg_stream	function
(	O
mach	pointer
,	O
mu_strout	pointer
)	O
;	O
mu_sieve_disass	function
(	O
mach	pointer
)	O
;	O
}	O
return	O
EX_OK	int
;	O
}	O
mu_sieve_set_dry_run	function
(	O
mach	pointer
,	O
dry_run	int
)	O
;	O
if	O
(	O
mbox_url	pointer
&&	O
strcmp	function
(	O
mbox_url	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
rc	int
=	O
sieve_message	function
(	O
mach	pointer
)	O
;	O
else	O
rc	int
=	O
sieve_mailbox	function
(	O
mach	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
