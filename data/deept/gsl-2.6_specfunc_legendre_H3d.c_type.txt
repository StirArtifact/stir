static	O
int	O
legendre_H3d_lnnorm	function
(	O
const	O
int	O
ell	int
,	O
const	O
double	O
lambda	double
,	O
double	O
*	O
result	pointer
)	O
{	O
double	O
abs_lam	double
=	O
fabs	function
(	O
lambda	double
)	O
;	O
if	O
(	O
abs_lam	double
==	O
0.0	int
)	O
{	O
*	O
result	pointer
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
lambda	double
>	O
(	O
ell	int
+	O
1.0	int
)	O
/	O
GSL_ROOT3_DBL_EPSILON	int
)	O
{	O
double	O
rat	double
=	O
(	O
ell	int
+	O
1.0	int
)	O
/	O
lambda	double
;	O
double	O
ln_lam2ell2	double
=	O
2.0	int
*	O
log	function
(	O
lambda	double
)	O
+	O
log	function
(	O
1.0	int
+	O
rat	double
*	O
rat	double
)	O
;	O
double	O
lg_corrected	double
=	O
-	O
2.0	int
*	O
(	O
ell	int
+	O
1.0	int
)	O
+	O
M_LNPI	int
+	O
(	O
ell	int
+	O
0.5	int
)	O
*	O
ln_lam2ell2	double
+	O
1.0	int
/	O
(	O
288.0	int
*	O
lambda	double
*	O
lambda	double
)	O
;	O
double	O
angle_terms	double
=	O
lambda	double
*	O
2.0	int
*	O
rat	double
*	O
(	O
1.0	int
-	O
rat	double
*	O
rat	double
/	O
3.0	int
)	O
;	O
*	O
result	pointer
=	O
log	function
(	O
abs_lam	double
)	O
+	O
lg_corrected	double
+	O
angle_terms	double
-	O
M_LNPI	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct
lg_r	struct
;	O
gsl_sf_result	struct
lg_theta	struct
;	O
gsl_sf_result	struct
ln_sinh	struct
;	O
gsl_sf_lngamma_complex_e	function
(	O
ell	int
+	O
1.0	int
,	O
lambda	double
,	O
&	O
lg_r	struct
,	O
&	O
lg_theta	struct
)	O
;	O
gsl_sf_lnsinh_e	function
(	O
M_PI	int
*	O
abs_lam	double
,	O
&	O
ln_sinh	struct
)	O
;	O
*	O
result	pointer
=	O
log	function
(	O
abs_lam	double
)	O
+	O
ln_sinh	struct
.	O
val	double
+	O
2.0	int
*	O
lg_r	struct
.	O
val	double
-	O
M_LNPI	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
legendre_H3d_series	function
(	O
const	O
int	O
ell	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
int	O
nmax	int
=	O
5000	int
;	O
const	O
double	O
shheta	double
=	O
sinh	function
(	O
0.5	int
*	O
eta	double
)	O
;	O
const	O
double	O
ln_zp1	double
=	O
M_LN2	int
+	O
log	function
(	O
1.0	int
+	O
shheta	double
*	O
shheta	double
)	O
;	O
const	O
double	O
ln_zm1	double
=	O
M_LN2	int
+	O
2.0	int
*	O
log	function
(	O
shheta	double
)	O
;	O
const	O
double	O
zeta	double
=	O
-	O
shheta	double
*	O
shheta	double
;	O
gsl_sf_result	struct
lg_lp32	struct
;	O
double	O
term	double
=	O
1.0	int
;	O
double	O
sum	double
=	O
1.0	int
;	O
double	O
sum_err	double
=	O
0.0	int
;	O
gsl_sf_result	struct
lnsheta	struct
;	O
double	O
lnN	double
;	O
double	O
lnpre_val	double
,	O
lnpre_err	double
,	O
lnprepow	double
;	O
int	O
stat_e	int
;	O
int	O
n	int
;	O
gsl_sf_lngamma_e	function
(	O
ell	int
+	O
3.0	int
/	O
2.0	int
,	O
&	O
lg_lp32	struct
)	O
;	O
gsl_sf_lnsinh_e	function
(	O
eta	double
,	O
&	O
lnsheta	struct
)	O
;	O
legendre_H3d_lnnorm	function
(	O
ell	int
,	O
lambda	double
,	O
&	O
lnN	double
)	O
;	O
lnprepow	double
=	O
0.5	int
*	O
(	O
ell	int
+	O
0.5	int
)	O
*	O
(	O
ln_zm1	double
-	O
ln_zp1	double
)	O
;	O
lnpre_val	double
=	O
lnprepow	double
+	O
0.5	int
*	O
(	O
lnN	double
+	O
M_LNPI	int
-	O
M_LN2	int
-	O
lnsheta	struct
.	O
val	double
)	O
-	O
lg_lp32	struct
.	O
val	double
-	O
log	function
(	O
fabs	function
(	O
lambda	double
)	O
)	O
;	O
lnpre_err	double
=	O
lnsheta	struct
.	O
err	double
+	O
lg_lp32	struct
.	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
lnpre_val	double
)	O
;	O
lnpre_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
lnN	double
)	O
+	O
M_LNPI	int
+	O
M_LN2	int
)	O
;	O
lnpre_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
0.5	int
*	O
(	O
ell	int
+	O
0.5	int
)	O
*	O
(	O
fabs	function
(	O
ln_zm1	double
)	O
+	O
fabs	function
(	O
ln_zp1	double
)	O
)	O
)	O
;	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<	O
nmax	int
;	O
n	int
++	O
)	O
{	O
double	O
aR	double
=	O
n	int
-	O
0.5	int
;	O
term	double
*=	O
(	O
aR	double
*	O
aR	double
+	O
lambda	double
*	O
lambda	double
)	O
*	O
zeta	double
/	O
(	O
ell	int
+	O
n	int
+	O
0.5	int
)	O
/	O
n	int
;	O
sum	double
+=	O
term	double
;	O
sum_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
term	double
)	O
;	O
if	O
(	O
fabs	function
(	O
term	double
/	O
sum	double
)	O
<	O
2.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
lnpre_val	double
,	O
lnpre_err	double
,	O
sum	double
,	O
fabs	function
(	O
term	double
)	O
+	O
sum_err	double
,	O
result	pointer
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
(	O
n	int
==	O
nmax	int
?	O
GSL_EMAXITER	int
:	O
GSL_SUCCESS	int
)	O
)	O
;	O
}	O
static	O
int	O
legendre_H3d_CF1_ser	function
(	O
const	O
int	O
ell	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
coth_eta	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
pre	double
=	O
hypot	function
(	O
lambda	double
,	O
ell	int
+	O
1.0	int
)	O
/	O
(	O
(	O
2.0	int
*	O
ell	int
+	O
3	int
)	O
*	O
coth_eta	double
)	O
;	O
const	O
int	O
maxk	int
=	O
20000	int
;	O
double	O
tk	double
=	O
1.0	int
;	O
double	O
sum	double
=	O
1.0	int
;	O
double	O
rhok	double
=	O
0.0	int
;	O
double	O
sum_err	double
=	O
0.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<	O
maxk	int
;	O
k	int
++	O
)	O
{	O
double	O
tlk	double
=	O
(	O
2.0	int
*	O
ell	int
+	O
1.0	int
+	O
2.0	int
*	O
k	int
)	O
;	O
double	O
l1k	double
=	O
(	O
ell	int
+	O
1.0	int
+	O
k	int
)	O
;	O
double	O
ak	double
=	O
-	O
(	O
lambda	double
*	O
lambda	double
+	O
l1k	double
*	O
l1k	double
)	O
/	O
(	O
tlk	double
*	O
(	O
tlk	double
+	O
2.0	int
)	O
*	O
coth_eta	double
*	O
coth_eta	double
)	O
;	O
rhok	double
=	O
-	O
ak	double
*	O
(	O
1.0	int
+	O
rhok	double
)	O
/	O
(	O
1.0	int
+	O
ak	double
*	O
(	O
1.0	int
+	O
rhok	double
)	O
)	O
;	O
tk	double
*=	O
rhok	double
;	O
sum	double
+=	O
tk	double
;	O
sum_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
k	int
*	O
fabs	function
(	O
tk	double
)	O
;	O
if	O
(	O
fabs	function
(	O
tk	double
/	O
sum	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
result	pointer
->	O
val	double
=	O
pre	double
*	O
sum	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
pre	double
*	O
tk	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
fabs	function
(	O
pre	double
*	O
sum_err	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
if	O
(	O
k	int
>=	O
maxk	int
)	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_legendre_H3d_0_e	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
eta	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
eta	double
==	O
0.0	int
||	O
lambda	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
1.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
lam_eta	double
=	O
lambda	double
*	O
eta	double
;	O
gsl_sf_result	struct
s	struct
;	O
gsl_sf_sin_err_e	function
(	O
lam_eta	double
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
lam_eta	double
)	O
,	O
&	O
s	struct
)	O
;	O
if	O
(	O
eta	double
>	O
-	O
0.5	int
*	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
double	O
f	pointer
=	O
2.0	int
/	O
lambda	double
*	O
exp	function
(	O
-	O
eta	double
)	O
;	O
result	pointer
->	O
val	double
=	O
f	pointer
*	O
s	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
f	pointer
*	O
s	struct
.	O
val	double
)	O
*	O
(	O
fabs	function
(	O
eta	double
)	O
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
;	O
result	pointer
->	O
err	double
+=	O
fabs	function
(	O
f	pointer
)	O
*	O
s	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
else	O
{	O
double	O
f	pointer
=	O
1.0	int
/	O
(	O
lambda	double
*	O
sinh	function
(	O
eta	double
)	O
)	O
;	O
result	pointer
->	O
val	double
=	O
f	pointer
*	O
s	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
f	pointer
*	O
s	struct
.	O
val	double
)	O
*	O
(	O
fabs	function
(	O
eta	double
)	O
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
;	O
result	pointer
->	O
err	double
+=	O
fabs	function
(	O
f	pointer
)	O
*	O
s	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_legendre_H3d_1_e	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
xi	double
=	O
fabs	function
(	O
eta	double
*	O
lambda	double
)	O
;	O
const	O
double	O
lsq	double
=	O
lambda	double
*	O
lambda	double
;	O
const	O
double	O
lsqp1	double
=	O
lsq	double
+	O
1.0	int
;	O
if	O
(	O
eta	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
eta	double
==	O
0.0	int
||	O
lambda	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
xi	double
<	O
GSL_ROOT5_DBL_EPSILON	int
&&	O
eta	double
<	O
GSL_ROOT5_DBL_EPSILON	int
)	O
{	O
double	O
etasq	double
=	O
eta	double
*	O
eta	double
;	O
double	O
xisq	double
=	O
xi	double
*	O
xi	double
;	O
double	O
term1	double
=	O
(	O
etasq	double
+	O
xisq	double
)	O
/	O
3.0	int
;	O
double	O
term2	double
=	O
-	O
(	O
2.0	int
*	O
etasq	double
*	O
etasq	double
+	O
5.0	int
*	O
etasq	double
*	O
xisq	double
+	O
3.0	int
*	O
xisq	double
*	O
xisq	double
)	O
/	O
90.0	int
;	O
double	O
sinh_term	double
=	O
1.0	int
-	O
eta	double
*	O
eta	double
/	O
6.0	int
*	O
(	O
1.0	int
-	O
7.0	int
/	O
60.0	int
*	O
eta	double
*	O
eta	double
)	O
;	O
double	O
pre	double
=	O
sinh_term	double
/	O
sqrt	function
(	O
lsqp1	double
)	O
/	O
eta	double
;	O
result	pointer
->	O
val	double
=	O
pre	double
*	O
(	O
term1	double
+	O
term2	double
)	O
;	O
result	pointer
->	O
err	double
=	O
pre	double
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
term1	double
)	O
+	O
fabs	function
(	O
term2	double
)	O
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
sin_term	double
;	O
double	O
cos_term	double
;	O
double	O
coth_term	double
;	O
double	O
sinh_term	double
;	O
double	O
sin_term_err	double
;	O
double	O
cos_term_err	double
;	O
double	O
t1	double
;	O
double	O
pre_val	double
;	O
double	O
pre_err	double
;	O
double	O
term1	double
;	O
double	O
term2	double
;	O
if	O
(	O
xi	double
<	O
GSL_ROOT5_DBL_EPSILON	int
)	O
{	O
sin_term	double
=	O
1.0	int
-	O
xi	double
*	O
xi	double
/	O
6.0	int
*	O
(	O
1.0	int
-	O
xi	double
*	O
xi	double
/	O
20.0	int
)	O
;	O
cos_term	double
=	O
1.0	int
-	O
0.5	int
*	O
xi	double
*	O
xi	double
*	O
(	O
1.0	int
-	O
xi	double
*	O
xi	double
/	O
12.0	int
)	O
;	O
sin_term_err	double
=	O
GSL_DBL_EPSILON	int
;	O
cos_term_err	double
=	O
GSL_DBL_EPSILON	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct
sin_xi_result	struct
;	O
gsl_sf_result	struct
cos_xi_result	struct
;	O
gsl_sf_sin_e	function
(	O
xi	double
,	O
&	O
sin_xi_result	struct
)	O
;	O
gsl_sf_cos_e	function
(	O
xi	double
,	O
&	O
cos_xi_result	struct
)	O
;	O
sin_term	double
=	O
sin_xi_result	struct
.	O
val	double
/	O
xi	double
;	O
cos_term	double
=	O
cos_xi_result	struct
.	O
val	double
;	O
sin_term_err	double
=	O
sin_xi_result	struct
.	O
err	double
/	O
fabs	function
(	O
xi	double
)	O
;	O
cos_term_err	double
=	O
cos_xi_result	struct
.	O
err	double
;	O
}	O
if	O
(	O
eta	double
<	O
GSL_ROOT5_DBL_EPSILON	int
)	O
{	O
coth_term	double
=	O
1.0	int
+	O
eta	double
*	O
eta	double
/	O
3.0	int
*	O
(	O
1.0	int
-	O
eta	double
*	O
eta	double
/	O
15.0	int
)	O
;	O
sinh_term	double
=	O
1.0	int
-	O
eta	double
*	O
eta	double
/	O
6.0	int
*	O
(	O
1.0	int
-	O
7.0	int
/	O
60.0	int
*	O
eta	double
*	O
eta	double
)	O
;	O
}	O
else	O
{	O
coth_term	double
=	O
eta	double
/	O
tanh	function
(	O
eta	double
)	O
;	O
sinh_term	double
=	O
eta	double
/	O
sinh	function
(	O
eta	double
)	O
;	O
}	O
t1	double
=	O
sqrt	function
(	O
lsqp1	double
)	O
*	O
eta	double
;	O
pre_val	double
=	O
sinh_term	double
/	O
t1	double
;	O
pre_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
pre_val	double
)	O
;	O
term1	double
=	O
sin_term	double
*	O
coth_term	double
;	O
term2	double
=	O
cos_term	double
;	O
result	pointer
->	O
val	double
=	O
pre_val	double
*	O
(	O
term1	double
-	O
term2	double
)	O
;	O
result	pointer
->	O
err	double
=	O
pre_err	double
*	O
fabs	function
(	O
term1	double
-	O
term2	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
pre_val	double
*	O
(	O
sin_term_err	double
*	O
coth_term	double
+	O
cos_term_err	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
pre_val	double
*	O
fabs	function
(	O
term1	double
-	O
term2	double
)	O
*	O
(	O
fabs	function
(	O
eta	double
)	O
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_legendre_H3d_e	function
(	O
const	O
int	O
ell	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
abs_lam	double
=	O
fabs	function
(	O
lambda	double
)	O
;	O
const	O
double	O
lsq	double
=	O
abs_lam	double
*	O
abs_lam	double
;	O
const	O
double	O
xi	double
=	O
abs_lam	double
*	O
eta	double
;	O
const	O
double	O
cosh_eta	double
=	O
cosh	function
(	O
eta	double
)	O
;	O
if	O
(	O
eta	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
eta	double
>	O
GSL_LOG_DBL_MAX	int
)	O
{	O
OVERFLOW_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
ell	int
==	O
0	int
)	O
{	O
return	O
gsl_sf_legendre_H3d_0_e	function
(	O
lambda	double
,	O
eta	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
ell	int
==	O
1	int
)	O
{	O
return	O
gsl_sf_legendre_H3d_1_e	function
(	O
lambda	double
,	O
eta	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
eta	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
xi	double
<	O
1.0	int
)	O
{	O
return	O
legendre_H3d_series	function
(	O
ell	int
,	O
lambda	double
,	O
eta	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
ell	int
*	O
ell	int
+	O
lsq	double
)	O
/	O
sqrt	function
(	O
1.0	int
+	O
lsq	double
)	O
/	O
(	O
cosh_eta	double
*	O
cosh_eta	double
)	O
<	O
5.0	int
*	O
GSL_ROOT3_DBL_EPSILON	int
)	O
{	O
gsl_sf_result	struct
P	struct
;	O
double	O
lm	double
;	O
int	O
stat_P	int
=	O
gsl_sf_conicalP_large_x_e	function
(	O
-	O
ell	int
-	O
0.5	int
,	O
lambda	double
,	O
cosh_eta	double
,	O
&	O
P	struct
,	O
&	O
lm	double
)	O
;	O
if	O
(	O
P	struct
.	O
val	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_P	int
;	O
}	O
else	O
{	O
double	O
lnN	double
;	O
gsl_sf_result	struct
lnsh	struct
;	O
double	O
ln_abslam	double
;	O
double	O
lnpre_val	double
,	O
lnpre_err	double
;	O
int	O
stat_e	int
;	O
gsl_sf_lnsinh_e	function
(	O
eta	double
,	O
&	O
lnsh	struct
)	O
;	O
legendre_H3d_lnnorm	function
(	O
ell	int
,	O
lambda	double
,	O
&	O
lnN	double
)	O
;	O
ln_abslam	double
=	O
log	function
(	O
abs_lam	double
)	O
;	O
lnpre_val	double
=	O
0.5	int
*	O
(	O
M_LNPI	int
+	O
lnN	double
-	O
M_LN2	int
-	O
lnsh	struct
.	O
val	double
)	O
-	O
ln_abslam	double
;	O
lnpre_err	double
=	O
lnsh	struct
.	O
err	double
;	O
lnpre_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
0.5	int
*	O
(	O
M_LNPI	int
+	O
M_LN2	int
+	O
fabs	function
(	O
lnN	double
)	O
)	O
+	O
fabs	function
(	O
ln_abslam	double
)	O
)	O
;	O
lnpre_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
lnpre_val	double
)	O
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
lnpre_val	double
+	O
lm	double
,	O
lnpre_err	double
,	O
P	struct
.	O
val	double
,	O
P	struct
.	O
err	double
,	O
result	pointer
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_P	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
abs_lam	double
>	O
1000.0	int
*	O
ell	int
*	O
ell	int
)	O
{	O
gsl_sf_result	struct
P	struct
;	O
double	O
lm	double
;	O
int	O
stat_P	int
=	O
gsl_sf_conicalP_xgt1_neg_mu_largetau_e	function
(	O
ell	int
+	O
0.5	int
,	O
lambda	double
,	O
cosh_eta	double
,	O
eta	double
,	O
&	O
P	struct
,	O
&	O
lm	double
)	O
;	O
if	O
(	O
P	struct
.	O
val	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
stat_P	int
;	O
}	O
else	O
{	O
double	O
lnN	double
;	O
gsl_sf_result	struct
lnsh	struct
;	O
double	O
ln_abslam	double
;	O
double	O
lnpre_val	double
,	O
lnpre_err	double
;	O
int	O
stat_e	int
;	O
gsl_sf_lnsinh_e	function
(	O
eta	double
,	O
&	O
lnsh	struct
)	O
;	O
legendre_H3d_lnnorm	function
(	O
ell	int
,	O
lambda	double
,	O
&	O
lnN	double
)	O
;	O
ln_abslam	double
=	O
log	function
(	O
abs_lam	double
)	O
;	O
lnpre_val	double
=	O
0.5	int
*	O
(	O
M_LNPI	int
+	O
lnN	double
-	O
M_LN2	int
-	O
lnsh	struct
.	O
val	double
)	O
-	O
ln_abslam	double
;	O
lnpre_err	double
=	O
lnsh	struct
.	O
err	double
;	O
lnpre_err	double
+=	O
GSL_DBL_EPSILON	int
*	O
(	O
0.5	int
*	O
(	O
M_LNPI	int
+	O
M_LN2	int
+	O
fabs	function
(	O
lnN	double
)	O
)	O
+	O
fabs	function
(	O
ln_abslam	double
)	O
)	O
;	O
lnpre_err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
lnpre_val	double
)	O
;	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
lnpre_val	double
+	O
lm	double
,	O
lnpre_err	double
,	O
P	struct
.	O
val	double
,	O
P	struct
.	O
err	double
,	O
result	pointer
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_P	int
)	O
;	O
}	O
}	O
else	O
{	O
const	O
double	O
coth_eta	double
=	O
1.0	int
/	O
tanh	function
(	O
eta	double
)	O
;	O
const	O
double	O
coth_err_mult	double
=	O
fabs	function
(	O
eta	double
)	O
+	O
1.0	int
;	O
gsl_sf_result	struct
rH	struct
;	O
int	O
stat_CF1	int
=	O
legendre_H3d_CF1_ser	function
(	O
ell	int
,	O
lambda	double
,	O
coth_eta	double
,	O
&	O
rH	struct
)	O
;	O
double	O
Hlm1	double
;	O
double	O
Hl	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Hlp1	double
=	O
rH	struct
.	O
val	double
*	O
Hl	double
;	O
int	O
lp	int
;	O
for	O
(	O
lp	int
=	O
ell	int
;	O
lp	int
>	O
0	int
;	O
lp	int
--	O
)	O
{	O
double	O
root_term_0	double
=	O
hypot	function
(	O
lambda	double
,	O
lp	int
)	O
;	O
double	O
root_term_1	double
=	O
hypot	function
(	O
lambda	double
,	O
lp	int
+	O
1.0	int
)	O
;	O
Hlm1	double
=	O
(	O
(	O
2.0	int
*	O
lp	int
+	O
1.0	int
)	O
*	O
coth_eta	double
*	O
Hl	double
-	O
root_term_1	double
*	O
Hlp1	double
)	O
/	O
root_term_0	double
;	O
Hlp1	double
=	O
Hl	double
;	O
Hl	double
=	O
Hlm1	double
;	O
}	O
if	O
(	O
fabs	function
(	O
Hl	double
)	O
>	O
fabs	function
(	O
Hlp1	double
)	O
)	O
{	O
gsl_sf_result	struct
H0	struct
;	O
int	O
stat_H0	int
=	O
gsl_sf_legendre_H3d_0_e	function
(	O
lambda	double
,	O
eta	double
,	O
&	O
H0	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
/	O
Hl	double
*	O
H0	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
GSL_SQRT_DBL_MIN	int
/	O
fabs	function
(	O
Hl	double
)	O
*	O
H0	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
fabs	function
(	O
rH	struct
.	O
err	double
/	O
rH	struct
.	O
val	double
)	O
*	O
(	O
ell	int
+	O
1.0	int
)	O
*	O
coth_err_mult	double
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_H0	int
,	O
stat_CF1	int
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct
H1	struct
;	O
int	O
stat_H1	int
=	O
gsl_sf_legendre_H3d_1_e	function
(	O
lambda	double
,	O
eta	double
,	O
&	O
H1	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
/	O
Hlp1	double
*	O
H1	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
GSL_SQRT_DBL_MIN	int
/	O
fabs	function
(	O
Hlp1	double
)	O
*	O
H1	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
fabs	function
(	O
rH	struct
.	O
err	double
/	O
rH	struct
.	O
val	double
)	O
*	O
(	O
ell	int
+	O
1.0	int
)	O
*	O
coth_err_mult	double
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_H1	int
,	O
stat_CF1	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_legendre_H3d_array	function
(	O
const	O
int	O
lmax	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
,	O
double	O
*	O
result_array	pointer
)	O
{	O
if	O
(	O
eta	double
<	O
0.0	int
||	O
lmax	int
<	O
0	int
)	O
{	O
int	O
ell	int
;	O
for	O
(	O
ell	int
=	O
0	int
;	O
ell	int
<=	O
lmax	int
;	O
ell	int
++	O
)	O
result_array	pointer
[	O
ell	int
]	O
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
eta	double
>	O
GSL_LOG_DBL_MAX	int
)	O
{	O
int	O
ell	int
;	O
for	O
(	O
ell	int
=	O
0	int
;	O
ell	int
<=	O
lmax	int
;	O
ell	int
++	O
)	O
result_array	pointer
[	O
ell	int
]	O
=	O
0.0	int
;	O
GSL_ERROR	O
(	O
"overflow"	pointer
,	O
GSL_EOVRFLW	int
)	O
;	O
}	O
else	O
if	O
(	O
lmax	int
==	O
0	int
)	O
{	O
gsl_sf_result	struct
H0	struct
;	O
int	O
stat	int
=	O
gsl_sf_legendre_H3d_e	function
(	O
0	int
,	O
lambda	double
,	O
eta	double
,	O
&	O
H0	struct
)	O
;	O
result_array	pointer
[	O
0	int
]	O
=	O
H0	struct
.	O
val	double
;	O
return	O
stat	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct
r_Hlp1	struct
;	O
gsl_sf_result	struct
r_Hl	struct
;	O
int	O
stat_lmax	int
=	O
gsl_sf_legendre_H3d_e	function
(	O
lmax	int
,	O
lambda	double
,	O
eta	double
,	O
&	O
r_Hlp1	struct
)	O
;	O
int	O
stat_lmaxm1	int
=	O
gsl_sf_legendre_H3d_e	function
(	O
lmax	int
-	O
1	int
,	O
lambda	double
,	O
eta	double
,	O
&	O
r_Hl	struct
)	O
;	O
int	O
stat_max	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_lmax	int
,	O
stat_lmaxm1	int
)	O
;	O
const	O
double	O
coth_eta	double
=	O
1.0	int
/	O
tanh	function
(	O
eta	double
)	O
;	O
int	O
stat_recursion	int
=	O
GSL_SUCCESS	int
;	O
double	O
Hlp1	double
=	O
r_Hlp1	struct
.	O
val	double
;	O
double	O
Hl	double
=	O
r_Hl	struct
.	O
val	double
;	O
double	O
Hlm1	double
;	O
int	O
ell	int
;	O
result_array	pointer
[	O
lmax	int
]	O
=	O
Hlp1	double
;	O
result_array	pointer
[	O
lmax	int
-	O
1	int
]	O
=	O
Hl	double
;	O
for	O
(	O
ell	int
=	O
lmax	int
-	O
1	int
;	O
ell	int
>	O
0	int
;	O
ell	int
--	O
)	O
{	O
double	O
root_term_0	double
=	O
hypot	function
(	O
lambda	double
,	O
ell	int
)	O
;	O
double	O
root_term_1	double
=	O
hypot	function
(	O
lambda	double
,	O
ell	int
+	O
1.0	int
)	O
;	O
Hlm1	double
=	O
(	O
(	O
2.0	int
*	O
ell	int
+	O
1.0	int
)	O
*	O
coth_eta	double
*	O
Hl	double
-	O
root_term_1	double
*	O
Hlp1	double
)	O
/	O
root_term_0	double
;	O
result_array	pointer
[	O
ell	int
-	O
1	int
]	O
=	O
Hlm1	double
;	O
if	O
(	O
!	O
(	O
Hlm1	double
<	O
GSL_DBL_MAX	int
)	O
)	O
stat_recursion	int
=	O
GSL_EOVRFLW	int
;	O
Hlp1	double
=	O
Hl	double
;	O
Hl	double
=	O
Hlm1	double
;	O
}	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_recursion	int
,	O
stat_max	int
)	O
;	O
}	O
}	O
double	O
gsl_sf_legendre_H3d_0	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_legendre_H3d_0_e	function
(	O
lambda	double
,	O
eta	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_legendre_H3d_1	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_legendre_H3d_1_e	function
(	O
lambda	double
,	O
eta	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_legendre_H3d	function
(	O
const	O
int	O
l	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
eta	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_legendre_H3d_e	function
(	O
l	int
,	O
lambda	double
,	O
eta	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
