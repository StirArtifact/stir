struct	O
getopt_data	struct
{	O
char	O
*	O
extra_doc	pointer
;	O
}	O
;	O
static	O
void	O
mh_extra_help_hook	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
struct	O
getopt_data	struct
*	O
data	pointer
=	O
po	pointer
->	O
po_data	pointer
;	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"%s\n"	pointer
,	O
_	O
(	O
data	pointer
->	O
extra_doc	pointer
)	O
)	O
;	O
}	O
static	O
void	O
augment_argv	function
(	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
*	O
pargv	pointer
)	O
{	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
int	O
i	int
,	O
j	int
;	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
char	O
const	O
*	O
val	array
=	O
mh_global_profile_get	O
(	O
mu_program_name	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
val	array
)	O
return	O
;	O
if	O
(	O
mu_wordsplit	struct
(	O
val	array
,	O
&	O
ws	pointer
,	O
MU_WRDSF_DEFFLAGS	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot split line `%s': %s"	pointer
)	O
,	O
val	array
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
argc	int
=	O
*	O
pargc	pointer
+	O
ws	pointer
.	O
ws_wordc	long
;	O
argv	pointer
=	O
calloc	function
(	O
argc	int
+	O
1	int
,	O
sizeof	O
*	O
argv	pointer
)	O
;	O
if	O
(	O
!	O
argv	pointer
)	O
mh_err_memory	function
(	O
1	int
)	O
;	O
i	int
=	O
0	int
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
(	O
*	O
pargv	pointer
)	O
[	O
0	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ws	pointer
.	O
ws_wordc	long
;	O
i	int
++	O
,	O
j	int
++	O
)	O
argv	pointer
[	O
i	int
]	O
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
j	int
]	O
;	O
for	O
(	O
j	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
,	O
j	int
++	O
)	O
argv	pointer
[	O
i	int
]	O
=	O
(	O
*	O
pargv	pointer
)	O
[	O
j	int
]	O
;	O
argv	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
ws	pointer
.	O
ws_wordc	long
=	O
0	int
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
*	O
pargc	pointer
=	O
argc	int
;	O
*	O
pargv	pointer
=	O
argv	pointer
;	O
}	O
static	O
void	O
process_std_options	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
struct	O
mu_parseopt	struct
*	O
po	pointer
)	O
{	O
if	O
(	O
argc	int
!=	O
1	int
)	O
return	O
;	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
"--help"	pointer
)	O
==	O
0	int
)	O
{	O
mu_program_help	function
(	O
po	pointer
,	O
mu_strout	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
"--version"	pointer
)	O
==	O
0	int
)	O
{	O
mu_version_hook	function
(	O
po	pointer
,	O
mu_strout	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
process_folder_arg	function
(	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
argv	pointer
,	O
struct	O
mu_parseopt	struct
*	O
po	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
argc	int
=	O
*	O
pargc	pointer
;	O
struct	O
mu_option	struct
*	O
opt	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
po	pointer
->	O
po_optv	pointer
[	O
i	int
]	O
)	O
return	O
;	O
if	O
(	O
MU_OPTION_IS_VALID_LONG_OPTION	O
(	O
po	pointer
->	O
po_optv	pointer
[	O
i	int
]	O
)	O
&&	O
strcmp	function
(	O
po	pointer
->	O
po_optv	pointer
[	O
i	int
]	O
->	O
opt_long	pointer
,	O
"folder"	pointer
)	O
==	O
0	int
)	O
break	O
;	O
}	O
opt	pointer
=	O
po	pointer
->	O
po_optv	pointer
[	O
i	int
]	O
;	O
for	O
(	O
i	int
=	O
j	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'+'	O
)	O
{	O
opt	pointer
->	O
opt_set	pointer
(	O
po	pointer
,	O
opt	pointer
,	O
argv	pointer
[	O
i	int
]	O
+	O
1	int
)	O
;	O
}	O
else	O
argv	pointer
[	O
j	int
++	O
]	O
=	O
argv	pointer
[	O
i	int
]	O
;	O
}	O
argv	pointer
[	O
j	int
]	O
=	O
NULL	O
;	O
*	O
pargc	pointer
=	O
j	int
;	O
}	O
void	O
mh_opt_set_folder	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
mh_set_current_folder	function
(	O
arg	pointer
)	O
;	O
}	O
static	O
struct	O
mu_option	struct
folder_option	array
[	O
]	O
=	O
{	O
{	O
"folder"	pointer
,	O
0	int
,	O
N_	O
(	O
"FOLDER"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set current folder"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
mh_opt_set_folder	function
}	O
,	O
MU_OPTION_END	O
}	O
;	O
void	O
mh_version_hook	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"%s (%s %s)\n"	pointer
,	O
mu_program_name	pointer
,	O
PACKAGE_NAME	pointer
,	O
PACKAGE_VERSION	pointer
)	O
;	O
mu_stream_printf	function
(	O
stream	pointer
,	O
mu_version_copyright	array
,	O
_	O
(	O
"(C)"	pointer
)	O
)	O
;	O
mu_stream_printf	function
(	O
stream	pointer
,	O
_	O
(	O
"\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n"	pointer
)	O
)	O
;	O
}	O
static	O
int	O
has_folder_option	function
(	O
struct	O
mu_option	struct
*	O
opt	pointer
)	O
{	O
while	O
(	O
!	O
MU_OPTION_IS_END	O
(	O
opt	pointer
)	O
)	O
{	O
if	O
(	O
MU_OPTION_IS_VALID_LONG_OPTION	O
(	O
opt	pointer
)	O
&&	O
strcmp	function
(	O
opt	pointer
->	O
opt_long	pointer
,	O
"folder"	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
++	O
opt	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
opt_init	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
*	O
optv	pointer
,	O
struct	O
mh_optinit	struct
*	O
optinit	pointer
)	O
{	O
if	O
(	O
!	O
optinit	pointer
)	O
return	O
;	O
for	O
(	O
;	O
optinit	pointer
->	O
opt	pointer
;	O
optinit	pointer
++	O
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
optv	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
struct	O
mu_option	struct
*	O
opt	pointer
;	O
for	O
(	O
opt	pointer
=	O
optv	pointer
[	O
i	int
]	O
;	O
!	O
MU_OPTION_IS_END	O
(	O
opt	pointer
)	O
;	O
opt	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
opt	pointer
->	O
opt_long	pointer
,	O
optinit	pointer
->	O
opt	pointer
)	O
==	O
0	int
)	O
{	O
char	O
const	O
*	O
val	array
=	O
mh_global_profile_get	O
(	O
optinit	pointer
->	O
var	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
val	array
)	O
{	O
(	O
opt	pointer
->	O
opt_set	pointer
?	O
opt	pointer
->	O
opt_set	pointer
:	O
mu_option_set_value	function
)	O
(	O
po	pointer
,	O
opt	pointer
,	O
val	array
)	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
void	O
mh_getopt_ext	function
(	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
*	O
pargv	pointer
,	O
struct	O
mu_option	struct
*	O
options	pointer
,	O
int	O
mhflags	int
,	O
struct	O
mh_optinit	struct
*	O
optinit	pointer
,	O
char	O
*	O
argdoc	pointer
,	O
char	O
*	O
progdoc	pointer
,	O
char	O
*	O
extradoc	pointer
)	O
{	O
int	O
argc	int
=	O
*	O
pargc	pointer
;	O
char	O
*	O
*	O
argv	pointer
=	O
*	O
pargv	pointer
;	O
struct	O
mu_parseopt	struct
po	pointer
;	O
struct	O
mu_option	struct
*	O
optv	pointer
[	O
3	int
]	O
;	O
struct	O
getopt_data	struct
getopt_data	struct
;	O
char	O
const	O
*	O
args	array
[	O
3	int
]	O
;	O
int	O
flags	int
=	O
MU_PARSEOPT_SINGLE_DASH	int
|	O
MU_PARSEOPT_IMMEDIATE	int
;	O
int	O
i	int
;	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
po	pointer
.	O
po_negation	pointer
=	O
"no"	pointer
;	O
flags	int
|=	O
MU_PARSEOPT_NEGATION	int
;	O
if	O
(	O
(	O
mhflags	int
&	O
MH_GETOPT_DEFAULT_FOLDER	int
)	O
||	O
has_folder_option	function
(	O
options	pointer
)	O
)	O
{	O
po	pointer
.	O
po_special_args	pointer
=	O
N_	O
(	O
"[+FOLDER]"	pointer
)	O
;	O
flags	int
|=	O
MU_PARSEOPT_SPECIAL_ARGS	int
;	O
}	O
if	O
(	O
argdoc	pointer
)	O
{	O
args	array
[	O
0	int
]	O
=	O
argdoc	pointer
;	O
args	array
[	O
1	int
]	O
=	O
NULL	O
;	O
po	pointer
.	O
po_prog_args	pointer
=	O
args	array
;	O
flags	int
|=	O
MU_PARSEOPT_PROG_ARGS	int
;	O
}	O
if	O
(	O
progdoc	pointer
)	O
{	O
po	pointer
.	O
po_prog_doc	pointer
=	O
progdoc	pointer
;	O
flags	int
|=	O
MU_PARSEOPT_PROG_DOC	int
;	O
}	O
getopt_data	struct
.	O
extra_doc	pointer
=	O
extradoc	pointer
;	O
if	O
(	O
extradoc	pointer
)	O
{	O
po	pointer
.	O
po_help_hook	pointer
=	O
mh_extra_help_hook	function
;	O
flags	int
|=	O
MU_PARSEOPT_HELP_HOOK	int
;	O
}	O
po	pointer
.	O
po_data	pointer
=	O
&	O
getopt_data	struct
;	O
flags	int
|=	O
MU_PARSEOPT_DATA	int
;	O
po	pointer
.	O
po_exit_error	int
=	O
1	int
;	O
flags	int
|=	O
MU_PARSEOPT_EXIT_ERROR	int
;	O
po	pointer
.	O
po_package_name	pointer
=	O
PACKAGE_NAME	pointer
;	O
flags	int
|=	O
MU_PARSEOPT_PACKAGE_NAME	int
;	O
po	pointer
.	O
po_package_url	pointer
=	O
PACKAGE_URL	pointer
;	O
flags	int
|=	O
MU_PARSEOPT_PACKAGE_URL	int
;	O
po	pointer
.	O
po_bug_address	pointer
=	O
PACKAGE_BUGREPORT	pointer
;	O
flags	int
|=	O
MU_PARSEOPT_BUG_ADDRESS	int
;	O
po	pointer
.	O
po_version_hook	pointer
=	O
mh_version_hook	function
;	O
flags	int
|=	O
MU_PARSEOPT_VERSION_HOOK	int
;	O
mu_set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
mh_init	function
(	O
)	O
;	O
augment_argv	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
i	int
=	O
0	int
;	O
if	O
(	O
mhflags	int
&	O
MH_GETOPT_DEFAULT_FOLDER	int
)	O
optv	pointer
[	O
i	int
++	O
]	O
=	O
folder_option	array
;	O
if	O
(	O
options	pointer
)	O
optv	pointer
[	O
i	int
++	O
]	O
=	O
options	pointer
;	O
optv	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
opt_init	function
(	O
&	O
po	pointer
,	O
optv	pointer
,	O
optinit	pointer
)	O
;	O
if	O
(	O
mu_parseopt	struct
(	O
&	O
po	pointer
,	O
argc	int
,	O
argv	pointer
,	O
optv	pointer
,	O
flags	int
)	O
)	O
exit	function
(	O
po	pointer
.	O
po_exit_error	int
)	O
;	O
argc	int
-=	O
po	pointer
.	O
po_arg_start	int
;	O
argv	pointer
+=	O
po	pointer
.	O
po_arg_start	int
;	O
process_std_options	function
(	O
argc	int
,	O
argv	pointer
,	O
&	O
po	pointer
)	O
;	O
process_folder_arg	function
(	O
&	O
argc	int
,	O
argv	pointer
,	O
&	O
po	pointer
)	O
;	O
if	O
(	O
!	O
argdoc	pointer
&&	O
argc	int
)	O
{	O
mu_diag_init	function
(	O
)	O
;	O
mu_stream_printf	function
(	O
mu_strerr	pointer
,	O
"\033s<%d>"	pointer
,	O
MU_DIAG_ERROR	O
)	O
;	O
mu_stream_printf	function
(	O
mu_strerr	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"unrecognized extra arguments:"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
mu_stream_printf	function
(	O
mu_strerr	pointer
,	O
" %s"	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
mu_stream_write	function
(	O
mu_strerr	pointer
,	O
"\n"	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
*	O
pargc	pointer
=	O
argc	int
;	O
*	O
pargv	pointer
=	O
argv	pointer
;	O
mh_init2	function
(	O
)	O
;	O
}	O
void	O
mh_getopt	function
(	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
*	O
pargv	pointer
,	O
struct	O
mu_option	struct
*	O
options	pointer
,	O
int	O
mhflags	int
,	O
char	O
*	O
argdoc	pointer
,	O
char	O
*	O
progdoc	pointer
,	O
char	O
*	O
extradoc	pointer
)	O
{	O
mh_getopt_ext	function
(	O
pargc	pointer
,	O
pargv	pointer
,	O
options	pointer
,	O
mhflags	int
,	O
NULL	O
,	O
argdoc	pointer
,	O
progdoc	pointer
,	O
extradoc	pointer
)	O
;	O
}	O
void	O
mh_opt_notimpl	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
mu_error	function
(	O
_	O
(	O
"option is not yet implemented: %s"	pointer
)	O
,	O
opt	pointer
->	O
opt_long	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
void	O
mh_opt_notimpl_warning	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
if	O
(	O
opt	pointer
->	O
opt_type	enum
==	O
mu_c_bool	int
)	O
{	O
int	O
val	array
;	O
if	O
(	O
mu_str_to_c	function
(	O
arg	pointer
,	O
opt	pointer
->	O
opt_type	enum
,	O
&	O
val	array
,	O
NULL	O
)	O
==	O
0	int
&&	O
!	O
val	array
)	O
return	O
;	O
}	O
mu_error	function
(	O
_	O
(	O
"ignoring not implemented option %s"	pointer
)	O
,	O
opt	pointer
->	O
opt_long	pointer
)	O
;	O
}	O
void	O
mh_opt_clear_string	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
*	O
sptr	pointer
=	O
opt	pointer
->	O
opt_ptr	pointer
;	O
free	function
(	O
*	O
sptr	pointer
)	O
;	O
*	O
sptr	pointer
=	O
NULL	O
;	O
}	O
void	O
mh_opt_find_file	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
mh_find_file	function
(	O
arg	pointer
,	O
opt	pointer
->	O
opt_ptr	pointer
)	O
;	O
}	O
void	O
mh_opt_read_formfile	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
mh_read_formfile	function
(	O
arg	pointer
,	O
opt	pointer
->	O
opt_ptr	pointer
)	O
;	O
}	O
void	O
mh_opt_parse_formfile	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
mh_format_destroy	function
(	O
(	O
mh_format_t	pointer
*	O
)	O
opt	pointer
->	O
opt_ptr	pointer
)	O
;	O
if	O
(	O
mh_format_file_parse	function
(	O
opt	pointer
->	O
opt_ptr	pointer
,	O
arg	pointer
,	O
MH_FMT_PARSE_DEFAULT	int
)	O
)	O
exit	function
(	O
1	int
)	O
;	O
}	O
void	O
mh_opt_parse_format	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
mh_format_destroy	function
(	O
(	O
mh_format_t	pointer
*	O
)	O
opt	pointer
->	O
opt_ptr	pointer
)	O
;	O
if	O
(	O
mh_format_string_parse	function
(	O
opt	pointer
->	O
opt_ptr	pointer
,	O
arg	pointer
,	O
NULL	O
,	O
MH_FMT_PARSE_DEFAULT	int
)	O
)	O
exit	function
(	O
1	int
)	O
;	O
}	O
