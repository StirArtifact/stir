extern	O
struct	O
keyword	struct
*	O
in_word_set	function
(	O
register	O
char	O
*	O
str	pointer
,	O
register	O
unsigned	O
int	O
len	int
)	O
;	O
static	O
int	O
nonblockmode	int
;	O
static	O
catalog_t	struct
*	O
catalog	struct
;	O
void	O
uih_freecatalog	function
(	O
uih_context	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
catalog	struct
!=	O
NULL	O
)	O
free_catalog	function
(	O
catalog	struct
)	O
,	O
catalog	struct
=	O
NULL	O
;	O
}	O
int	O
uih_loadcatalog	function
(	O
uih_context	struct
*	O
c	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
static	O
int	O
firsttime	int
=	O
1	int
;	O
xio_file	pointer
f	pointer
=	O
xio_getcatalog	function
(	O
name	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
XIO_FAILED	O
)	O
{	O
if	O
(	O
firsttime	int
)	O
{	O
firsttime	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
c	pointer
->	O
errstring	pointer
=	O
"Catalog file not found"	pointer
;	O
return	O
0	int
;	O
}	O
firsttime	int
=	O
0	int
;	O
if	O
(	O
catalog	struct
!=	O
NULL	O
)	O
free_catalog	function
(	O
catalog	struct
)	O
;	O
catalog	struct
=	O
load_catalog	function
(	O
f	pointer
,	O
&	O
c	pointer
->	O
errstring	pointer
)	O
;	O
return	O
(	O
catalog	struct
!=	O
NULL	O
)	O
;	O
}	O
static	O
void	O
handler	pointer
(	O
void	O
*	O
userdata	pointer
)	O
{	O
struct	O
uih_context	struct
*	O
uih	pointer
=	O
userdata	pointer
;	O
uih	pointer
->	O
playc	pointer
->	O
playframe	int
++	O
;	O
uih	pointer
->	O
inanimation	int
=	O
2	int
;	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
timerin	int
)	O
tl_remove_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
timerin	int
=	O
0	int
;	O
}	O
static	O
void	O
handler1	function
(	O
void	O
*	O
userdata	pointer
)	O
{	O
struct	O
uih_context	struct
*	O
uih	pointer
=	O
userdata	pointer
;	O
uih	pointer
->	O
playc	pointer
->	O
playframe	int
++	O
;	O
uih	pointer
->	O
inanimation	int
=	O
2	int
;	O
tl_update_time	function
(	O
)	O
;	O
tl_reset_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
;	O
uih_setcomplettehandler	function
(	O
uih	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
uih_skipframe	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
if	O
(	O
uih	pointer
->	O
play	int
&&	O
uih	pointer
->	O
playc	pointer
->	O
timerin	int
)	O
handler	pointer
(	O
uih	pointer
)	O
,	O
tl_reset_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
;	O
}	O
int	O
uih_replayenable	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
xio_file	pointer
f	pointer
,	O
xio_path	pointer
filename	pointer
)	O
{	O
struct	O
uih_playcontext	struct
*	O
p	pointer
;	O
if	O
(	O
uih	pointer
->	O
play	int
)	O
{	O
uih	pointer
->	O
errstring	pointer
=	O
"Replay is arelady active"	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
f	pointer
==	O
XIO_FAILED	O
)	O
{	O
uih	pointer
->	O
errstring	pointer
=	O
"File open failed"	pointer
;	O
return	O
0	int
;	O
}	O
p	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
,	O
1	int
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
uih	pointer
->	O
errstring	pointer
=	O
"Out of memory"	pointer
;	O
return	O
0	int
;	O
}	O
p	pointer
->	O
file	pointer
=	O
f	pointer
;	O
p	pointer
->	O
playframe	int
=	O
1	int
;	O
p	pointer
->	O
timer	struct
=	O
tl_create_timer	function
(	O
)	O
;	O
p	pointer
->	O
frametime	int
=	O
0	int
;	O
p	pointer
->	O
morph	int
=	O
0	int
;	O
p	pointer
->	O
morphjulia	int
=	O
0	int
;	O
tl_update_time	function
(	O
)	O
;	O
tl_reset_timer	function
(	O
p	pointer
->	O
timer	struct
)	O
;	O
tl_set_handler	function
(	O
p	pointer
->	O
timer	struct
,	O
handler	pointer
,	O
uih	pointer
)	O
;	O
uih_stoptimers	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
stoppedtimers	int
)	O
tl_stop_timer	function
(	O
p	pointer
->	O
timer	struct
)	O
;	O
uih	pointer
->	O
playc	pointer
=	O
p	pointer
;	O
uih	pointer
->	O
play	int
=	O
1	int
;	O
uih	pointer
->	O
playc	pointer
->	O
line	int
=	O
1	int
;	O
if	O
(	O
filename	pointer
!=	O
NULL	O
)	O
{	O
uih	pointer
->	O
playc	pointer
->	O
directory	pointer
=	O
xio_getdirectory	function
(	O
filename	pointer
)	O
;	O
}	O
else	O
{	O
uih	pointer
->	O
playc	pointer
->	O
directory	pointer
=	O
xio_getdirectory	function
(	O
XIO_EMPTYPATH	pointer
)	O
;	O
}	O
uih	pointer
->	O
playc	pointer
->	O
level	int
=	O
0	int
;	O
uih_playupdate	function
(	O
uih	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
uih_replaydisable	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
if	O
(	O
uih	pointer
->	O
play	int
)	O
{	O
int	O
i	pointer
;	O
uih	pointer
->	O
play	int
=	O
0	int
;	O
tl_free_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
;	O
xio_close	O
(	O
uih	pointer
->	O
playc	pointer
->	O
file	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
uih	pointer
->	O
playc	pointer
->	O
level	int
;	O
i	pointer
++	O
)	O
xio_close	O
(	O
uih	pointer
->	O
playc	pointer
->	O
prevfiles	array
[	O
i	pointer
]	O
)	O
;	O
uih	pointer
->	O
display	int
=	O
1	int
;	O
uih	pointer
->	O
nonfractalscreen	int
=	O
0	int
;	O
uih_setcomplettehandler	function
(	O
uih	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
free	function
(	O
uih	pointer
->	O
playc	pointer
->	O
directory	pointer
)	O
;	O
free	function
(	O
uih	pointer
->	O
playc	pointer
)	O
;	O
}	O
}	O
static	O
char	O
*	O
errstring	pointer
;	O
static	O
char	O
token	array
[	O
1024	int
]	O
;	O
static	O
int	O
first	pointer
;	O
static	O
int	O
last	pointer
;	O
static	O
int	O
parsenext	int
;	O
static	O
void	O
skipblank	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
int	O
c	pointer
;	O
do	O
{	O
c	pointer
=	O
xio_getc	O
(	O
FD	O
)	O
;	O
if	O
(	O
c	pointer
==	O
'\n'	O
)	O
uih	pointer
->	O
playc	pointer
->	O
line	int
++	O
;	O
if	O
(	O
c	pointer
==	O
';'	O
)	O
while	O
(	O
c	pointer
!=	O
'\n'	O
&&	O
!	O
xio_feof	O
(	O
FD	O
)	O
)	O
{	O
c	pointer
=	O
xio_getc	O
(	O
FD	O
)	O
;	O
if	O
(	O
c	pointer
==	O
'\n'	O
)	O
uih	pointer
->	O
playc	pointer
->	O
line	int
++	O
;	O
}	O
while	O
(	O
xio_feof	O
(	O
FD	O
)	O
&&	O
uih	pointer
->	O
playc	pointer
->	O
level	int
)	O
{	O
xio_close	O
(	O
FD	O
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
file	pointer
=	O
uih	pointer
->	O
playc	pointer
->	O
prevfiles	array
[	O
--	O
uih	pointer
->	O
playc	pointer
->	O
level	int
]	O
;	O
uih	pointer
->	O
playc	pointer
->	O
line	int
=	O
1	int
;	O
}	O
}	O
while	O
(	O
c	pointer
==	O
' '	O
||	O
c	pointer
==	O
'\t'	O
||	O
c	pointer
==	O
'\n'	O
||	O
c	pointer
==	O
'\r'	O
)	O
;	O
xio_ungetc	O
(	O
c	pointer
,	O
FD	O
)	O
;	O
}	O
static	O
int	O
gettoken	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
int	O
c	pointer
;	O
int	O
i	pointer
=	O
0	int
;	O
skipblank	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
first	pointer
&&	O
(	O
c	pointer
=	O
xio_getc	O
(	O
FD	O
)	O
!=	O
'('	O
)	O
)	O
{	O
seterr	O
(	O
"Expected ("	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
first	pointer
)	O
skipblank	function
(	O
uih	pointer
)	O
,	O
first	pointer
=	O
0	int
;	O
if	O
(	O
xio_feof	O
(	O
FD	O
)	O
)	O
{	O
seterr	O
(	O
"Unexpected end of file 1"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
c	pointer
=	O
xio_getc	O
(	O
FD	O
)	O
)	O
==	O
'"'	O
)	O
{	O
token	array
[	O
i	pointer
]	O
=	O
'"'	O
;	O
i	pointer
++	O
;	O
do	O
{	O
c	pointer
=	O
xio_getc	O
(	O
FD	O
)	O
;	O
if	O
(	O
c	pointer
==	O
XIO_EOF	O
)	O
{	O
seterr	O
(	O
"Unexpected end of file 2"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	pointer
==	O
'\n'	O
)	O
uih	pointer
->	O
playc	pointer
->	O
line	int
++	O
;	O
if	O
(	O
c	pointer
==	O
'\\'	O
)	O
token	array
[	O
i	pointer
]	O
=	O
xio_getc	O
(	O
FD	O
)	O
;	O
else	O
token	array
[	O
i	pointer
]	O
=	O
c	pointer
;	O
i	pointer
++	O
;	O
if	O
(	O
i	pointer
>=	O
1024	int
)	O
{	O
seterr	O
(	O
"Token is too long"	pointer
)	O
;	O
i	pointer
=	O
0	int
;	O
}	O
}	O
while	O
(	O
c	pointer
!=	O
'"'	O
)	O
;	O
}	O
else	O
xio_ungetc	O
(	O
c	pointer
,	O
FD	O
)	O
;	O
do	O
{	O
c	pointer
=	O
xio_getc	O
(	O
FD	O
)	O
;	O
if	O
(	O
c	pointer
==	O
XIO_EOF	O
)	O
{	O
seterr	O
(	O
"Unexpected end of file 2"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
token	array
[	O
i	pointer
]	O
=	O
c	pointer
;	O
i	pointer
++	O
;	O
if	O
(	O
i	pointer
>=	O
1024	int
)	O
{	O
seterr	O
(	O
"Token is too long"	pointer
)	O
;	O
i	pointer
=	O
0	int
;	O
}	O
}	O
while	O
(	O
c	pointer
!=	O
' '	O
&&	O
c	pointer
!=	O
'\t'	O
&&	O
c	pointer
!=	O
')'	O
&&	O
c	pointer
!=	O
'\n'	O
)	O
;	O
i	pointer
--	O
;	O
token	array
[	O
i	pointer
]	O
=	O
0	int
;	O
skipblank	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
c	pointer
==	O
')'	O
)	O
{	O
last	pointer
=	O
1	int
;	O
return	O
i	pointer
;	O
}	O
c	pointer
=	O
xio_getc	O
(	O
FD	O
)	O
;	O
while	O
(	O
xio_feof	O
(	O
FD	O
)	O
&&	O
uih	pointer
->	O
playc	pointer
->	O
level	int
)	O
uih	pointer
->	O
playc	pointer
->	O
file	pointer
=	O
uih	pointer
->	O
playc	pointer
->	O
prevfiles	array
[	O
--	O
uih	pointer
->	O
playc	pointer
->	O
level	int
]	O
,	O
uih	pointer
->	O
playc	pointer
->	O
line	int
=	O
1	int
;	O
if	O
(	O
c	pointer
==	O
XIO_EOF	O
)	O
{	O
seterr	O
(	O
"Unexpected end of file 3"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	pointer
==	O
')'	O
)	O
{	O
last	pointer
=	O
1	int
;	O
return	O
i	pointer
;	O
}	O
xio_ungetc	O
(	O
c	pointer
,	O
FD	O
)	O
;	O
return	O
i	pointer
;	O
}	O
static	O
int	O
getint	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
int	O
param	int
;	O
gettoken	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
sscanf	function
(	O
token	array
,	O
"%i"	pointer
,	O
&	O
param	int
)	O
==	O
0	int
)	O
{	O
seterr	O
(	O
"Integer parameter expected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
(	O
param	int
)	O
;	O
}	O
static	O
number_t	double
getfloat	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
double	O
param	int
;	O
gettoken	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
sscanf	function
(	O
token	array
,	O
"%lG"	pointer
,	O
&	O
param	int
)	O
==	O
0	int
)	O
{	O
seterr	O
(	O
"Floating point number expected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
(	O
param	int
)	O
;	O
}	O
static	O
char	O
*	O
getkeystring	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
gettoken	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
token	array
[	O
0	int
]	O
==	O
'\''	O
)	O
return	O
&	O
token	array
[	O
1	int
]	O
;	O
return	O
token	array
;	O
}	O
static	O
char	O
*	O
getstring	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
int	O
l	int
;	O
l	int
=	O
gettoken	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
token	array
[	O
0	int
]	O
!=	O
'"'	O
||	O
token	array
[	O
l	int
-	O
1	int
]	O
!=	O
'"'	O
||	O
l	int
==	O
1	int
)	O
{	O
seterr	O
(	O
"String parameter expected"	pointer
)	O
;	O
return	O
token	array
;	O
}	O
token	array
[	O
l	int
-	O
1	int
]	O
=	O
0	int
;	O
return	O
token	array
+	O
1	int
;	O
}	O
static	O
int	O
getnstring	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
char	O
*	O
*	O
str	pointer
)	O
{	O
char	O
*	O
text	pointer
=	O
getkeystring	function
(	O
uih	pointer
)	O
;	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
str	pointer
[	O
i	pointer
]	O
==	O
NULL	O
)	O
{	O
seterr	O
(	O
"Inexpected parameter"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
text	pointer
,	O
str	pointer
[	O
i	pointer
]	O
)	O
)	O
return	O
i	pointer
;	O
}	O
}	O
static	O
int	O
getbool	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
if	O
(	O
gettoken	function
(	O
uih	pointer
)	O
!=	O
2	int
)	O
{	O
seterr	O
(	O
"Booelan type parameter expected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
token	array
[	O
0	int
]	O
!=	O
'#'	O
)	O
{	O
seterr	O
(	O
"Booelan type parameter expected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
token	array
[	O
1	int
]	O
==	O
't'	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
token	array
[	O
1	int
]	O
==	O
'f'	O
)	O
{	O
return	O
0	int
;	O
}	O
seterr	O
(	O
"Booelan type parameter expected"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
uih_play_formula	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
char	O
*	O
fname	pointer
=	O
getkeystring	function
(	O
uih	pointer
)	O
;	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
nformulas	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
formulas	int
[	O
i	pointer
]	O
.	O
shortname	pointer
,	O
fname	pointer
)	O
)	O
{	O
set_formula	function
(	O
uih	pointer
->	O
fcontext	pointer
,	O
i	pointer
)	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
return	O
;	O
}	O
}	O
seterr	O
(	O
"Unknown formula type"	pointer
)	O
;	O
}	O
void	O
uih_play_setview	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
cr	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ci	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
<	O
0	int
||	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
<	O
0	int
)	O
{	O
seterr	O
(	O
"view:Invalid viewpoint"	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
+	O
0.00001	int
;	O
}	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
void	O
uih_play_setview2	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
cr	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ci	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
<	O
0	int
||	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
<	O
0	int
)	O
{	O
seterr	O
(	O
"animateview:Invalid viewpoint"	pointer
)	O
;	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
+	O
0.00001	int
;	O
}	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
}	O
void	O
uih_playmorph	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
cr	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ci	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
<	O
0	int
||	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
<	O
0	int
)	O
{	O
seterr	O
(	O
"morphview:Invalid viewpoint"	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
=	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
=	O
0.0001	int
;	O
}	O
uih	pointer
->	O
playc	pointer
->	O
morph	int
=	O
1	int
;	O
}	O
void	O
uih_playmove	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
playc	pointer
->	O
source	struct
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
cr	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ci	double
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
rr	double
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
.	O
ri	double
;	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
<	O
0	int
||	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
<	O
0	int
)	O
{	O
seterr	O
(	O
"morphview:Invalid viewpoint"	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
rr	double
=	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
.	O
ri	double
=	O
0.0001	int
;	O
}	O
uih	pointer
->	O
playc	pointer
->	O
morph	int
=	O
1	int
;	O
}	O
void	O
uih_playmorphjulia	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
number_t	double
r	int
,	O
number_t	double
i	pointer
)	O
{	O
uih	pointer
->	O
playc	pointer
->	O
sr	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
pre	double
;	O
uih	pointer
->	O
playc	pointer
->	O
si	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
pim	double
;	O
uih	pointer
->	O
playc	pointer
->	O
dr	double
=	O
r	int
;	O
uih	pointer
->	O
playc	pointer
->	O
di	double
=	O
i	pointer
;	O
uih	pointer
->	O
playc	pointer
->	O
morphjulia	int
=	O
1	int
;	O
}	O
void	O
uih_playmorphangle	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
number_t	double
angle	double
)	O
{	O
uih	pointer
->	O
playc	pointer
->	O
morphangle	int
=	O
1	int
;	O
uih	pointer
->	O
playc	pointer
->	O
srcangle	double
=	O
uih	pointer
->	O
fcontext	pointer
->	O
angle	double
;	O
uih	pointer
->	O
playc	pointer
->	O
destangle	double
=	O
angle	double
;	O
}	O
void	O
uih_playautorotate	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
&&	O
uih	pointer
->	O
fastrotate	int
)	O
uih_rotatemode	function
(	O
uih	pointer
,	O
ROTATE_CONTINUOUS	int
)	O
;	O
else	O
uih_rotatemode	function
(	O
uih	pointer
,	O
ROTATE_NONE	int
)	O
;	O
}	O
void	O
uih_playfilter	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
char	O
*	O
fname	pointer
=	O
getkeystring	function
(	O
uih	pointer
)	O
;	O
int	O
mode	int
;	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
uih_nfilters	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
uih_filters	array
[	O
i	pointer
]	O
->	O
shortname	pointer
,	O
fname	pointer
)	O
)	O
{	O
mode	int
=	O
getbool	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
mode	int
)	O
uih_enablefilter	function
(	O
uih	pointer
,	O
i	pointer
)	O
;	O
else	O
uih_disablefilter	function
(	O
uih	pointer
,	O
i	pointer
)	O
;	O
return	O
;	O
}	O
}	O
mode	int
=	O
getbool	function
(	O
uih	pointer
)	O
;	O
seterr	O
(	O
"Unknown filter"	pointer
)	O
;	O
}	O
void	O
uih_playpalette	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
int	O
n1	int
=	O
getint	function
(	O
uih	pointer
)	O
;	O
int	O
n2	int
=	O
getint	function
(	O
uih	pointer
)	O
;	O
int	O
shift	int
=	O
getint	function
(	O
uih	pointer
)	O
;	O
if	O
(	O
n1	int
<	O
1	int
||	O
n1	int
>	O
PALGORITHMS	int
)	O
{	O
seterr	O
(	O
"Unknown palette type"	pointer
)	O
;	O
}	O
if	O
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
mkpalette	function
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
,	O
n2	int
,	O
n1	int
-	O
1	int
)	O
!=	O
0	int
)	O
{	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
uih	pointer
->	O
palettetype	int
=	O
n1	int
;	O
uih	pointer
->	O
palettechanged	int
=	O
1	int
;	O
uih	pointer
->	O
paletteseed	int
=	O
n2	int
;	O
if	O
(	O
shiftpalette	function
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
,	O
shift	int
)	O
)	O
{	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
uih	pointer
->	O
paletteshift	int
=	O
shift	int
;	O
}	O
void	O
uih_playdefpalette	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
int	O
shift	int
)	O
{	O
if	O
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
mkdefaultpalette	function
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
)	O
!=	O
0	int
)	O
{	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
uih	pointer
->	O
palettetype	int
=	O
0	int
;	O
uih	pointer
->	O
palettechanged	int
=	O
1	int
;	O
if	O
(	O
shiftpalette	function
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
,	O
shift	int
)	O
)	O
{	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
uih	pointer
->	O
paletteshift	int
=	O
shift	int
;	O
}	O
void	O
uih_zoomcenter	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
number_t	double
p1	double
,	O
number_t	double
p2	double
)	O
{	O
uih	pointer
->	O
xcenter	double
=	O
p1	double
;	O
uih	pointer
->	O
ycenter	double
=	O
p2	double
;	O
uih	pointer
->	O
xcenterm	int
=	O
INT_MAX	O
;	O
uih	pointer
->	O
ycenterm	int
=	O
INT_MAX	O
;	O
}	O
extern	O
char	O
*	O
xtextposnames	array
[	O
]	O
;	O
extern	O
char	O
*	O
ytextposnames	array
[	O
]	O
;	O
void	O
uih_playtextpos	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
int	O
x	pointer
,	O
y	pointer
;	O
x	pointer
=	O
getnstring	function
(	O
uih	pointer
,	O
xtextposnames	array
)	O
;	O
y	pointer
=	O
getnstring	function
(	O
uih	pointer
,	O
ytextposnames	array
)	O
;	O
uih_settextpos	function
(	O
uih	pointer
,	O
x	pointer
,	O
y	pointer
)	O
;	O
}	O
void	O
uih_playusleep	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
int	O
time	int
)	O
{	O
parsenext	int
=	O
0	int
;	O
uih	pointer
->	O
playc	pointer
->	O
frametime	int
=	O
time	int
;	O
if	O
(	O
time	int
<	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
)	O
{	O
tl_slowdown_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
,	O
time	int
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
playframe	int
++	O
;	O
}	O
else	O
{	O
tl_set_interval	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
,	O
time	int
)	O
;	O
if	O
(	O
!	O
uih	pointer
->	O
playc	pointer
->	O
timerin	int
)	O
{	O
uih	pointer
->	O
playc	pointer
->	O
timerin	int
=	O
1	int
;	O
tl_add_timer	function
(	O
syncgroup	pointer
,	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
;	O
}	O
else	O
printf	function
(	O
"Internal program error #12 %i\n"	pointer
,	O
uih	pointer
->	O
playc	pointer
->	O
playframe	int
)	O
;	O
}	O
uih	pointer
->	O
playc	pointer
->	O
starttime	int
=	O
tl_lookup_timer	function
(	O
uih	pointer
->	O
playc	pointer
->	O
timer	struct
)	O
;	O
}	O
void	O
uih_playtextsleep	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih_playusleep	function
(	O
uih	pointer
,	O
500000	int
+	O
1000000	int
*	O
(	O
uih	pointer
->	O
nletters	int
+	O
uih	pointer
->	O
todisplayletters	int
)	O
/	O
uih	pointer
->	O
letterspersec	int
)	O
;	O
uih	pointer
->	O
nletters	int
=	O
0	int
;	O
uih	pointer
->	O
todisplayletters	int
=	O
0	int
;	O
}	O
void	O
uih_playwait	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
parsenext	int
=	O
0	int
;	O
if	O
(	O
!	O
uih	pointer
->	O
uncomplette	int
&&	O
!	O
uih	pointer
->	O
display	int
&&	O
!	O
uih	pointer
->	O
recalculatemode	int
&&	O
!	O
uih	pointer
->	O
displaytext	int
&&	O
!	O
uih	pointer
->	O
clearscreen	int
)	O
{	O
uih	pointer
->	O
playc	pointer
->	O
playframe	int
++	O
;	O
}	O
else	O
{	O
uih_setcomplettehandler	function
(	O
uih	pointer
,	O
handler1	function
,	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_playjulia	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
int	O
julia	pointer
)	O
{	O
julia	pointer
=	O
!	O
julia	pointer
;	O
if	O
(	O
julia	pointer
!=	O
uih	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
)	O
{	O
uih	pointer
->	O
fcontext	pointer
->	O
mandelbrot	int
=	O
julia	pointer
;	O
uih	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_playcalculate	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
void	O
uih_playzoom	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
zoomactive	int
=	O
1	int
;	O
}	O
void	O
uih_playunzoom	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
zoomactive	int
=	O
-	O
1	int
;	O
}	O
void	O
uih_playstop	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
uih	pointer
->	O
zoomactive	int
=	O
0	int
;	O
}	O
void	O
uih_playmessage	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
char	O
*	O
message	pointer
;	O
if	O
(	O
catalog	struct
==	O
NULL	O
)	O
{	O
uih_text	function
(	O
uih	pointer
,	O
"No catalog file loaded"	pointer
)	O
;	O
return	O
;	O
}	O
message	pointer
=	O
find_text	function
(	O
catalog	struct
,	O
name	pointer
)	O
;	O
if	O
(	O
message	pointer
==	O
NULL	O
)	O
{	O
uih_text	function
(	O
uih	pointer
,	O
"Message not found in catalog file"	pointer
)	O
;	O
return	O
;	O
}	O
uih_text	function
(	O
uih	pointer
,	O
message	pointer
)	O
;	O
}	O
void	O
uih_playinit	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
int	O
i	pointer
;	O
uih	pointer
->	O
fcontext	pointer
->	O
version	int
++	O
;	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
step	double
=	O
0	int
;	O
uih	pointer
->	O
speedup	double
=	O
STEP	O
;	O
uih	pointer
->	O
maxstep	double
=	O
MAXSTEP	O
;	O
uih_fastrotatedisable	function
(	O
uih	pointer
)	O
;	O
uih_disablejulia	function
(	O
uih	pointer
)	O
;	O
uih_cycling_off	function
(	O
uih	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
uih_nfilters	int
;	O
i	pointer
++	O
)	O
uih_disablefilter	function
(	O
uih	pointer
,	O
i	pointer
)	O
;	O
uih_setperbutation	function
(	O
uih	pointer
,	O
0	int
,	O
0	int
)	O
;	O
set_formula	function
(	O
uih	pointer
->	O
fcontext	pointer
,	O
0	int
)	O
;	O
uih_setperiodicity	function
(	O
uih	pointer
,	O
1	int
)	O
;	O
uih_setmaxiter	function
(	O
uih	pointer
,	O
170	int
)	O
;	O
uih_setincoloringmode	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
uih_setoutcoloringmode	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
uih_setcycling	function
(	O
uih	pointer
,	O
30	int
)	O
;	O
uih_display	function
(	O
uih	pointer
)	O
;	O
uih_setfastmode	function
(	O
uih	pointer
,	O
2	int
)	O
;	O
uih_setintcolor	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
uih_setouttcolor	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
uih_setplane	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
uih_setguessing	function
(	O
uih	pointer
,	O
3	int
)	O
;	O
uih_angle	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
uih_rotatemode	function
(	O
uih	pointer
,	O
0	int
)	O
;	O
uih_rotationspeed	function
(	O
uih	pointer
,	O
10	int
)	O
;	O
uih	pointer
->	O
xtextpos	int
=	O
1	int
;	O
uih	pointer
->	O
ytextpos	int
=	O
1	int
;	O
if	O
(	O
mkdefaultpalette	function
(	O
uih	pointer
->	O
zengine	pointer
->	O
fractalc	pointer
->	O
palette	struct
)	O
!=	O
0	int
)	O
{	O
uih_newimage	O
(	O
uih	pointer
)	O
;	O
}	O
}	O
void	O
uih_playload	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
xio_path	pointer
file	pointer
)	O
{	O
xio_file	pointer
f	pointer
;	O
xio_pathdata	array
tmp	array
;	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
level	int
==	O
MAXLEVEL	int
)	O
{	O
seterr	O
(	O
"Include level overflow"	pointer
)	O
;	O
return	O
;	O
}	O
xio_addfname	O
(	O
tmp	array
,	O
uih	pointer
->	O
playc	pointer
->	O
directory	pointer
,	O
file	pointer
)	O
;	O
f	pointer
=	O
xio_ropen	O
(	O
tmp	array
)	O
;	O
if	O
(	O
f	pointer
==	O
XIO_FAILED	O
)	O
{	O
seterr	O
(	O
"File not found"	pointer
)	O
;	O
return	O
;	O
}	O
uih	pointer
->	O
playc	pointer
->	O
prevfiles	array
[	O
uih	pointer
->	O
playc	pointer
->	O
level	int
]	O
=	O
uih	pointer
->	O
playc	pointer
->	O
file	pointer
;	O
uih	pointer
->	O
playc	pointer
->	O
level	int
++	O
;	O
uih	pointer
->	O
playc	pointer
->	O
file	pointer
=	O
f	pointer
;	O
uih	pointer
->	O
playc	pointer
->	O
line	int
=	O
1	int
;	O
}	O
void	O
uih_playupdate	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
{	O
int	O
len	int
;	O
struct	O
keyword	struct
*	O
k	double
;	O
static	O
char	O
errtext	array
[	O
1024	int
]	O
;	O
errstring	pointer
=	O
NULL	O
;	O
while	O
(	O
uih	pointer
->	O
play	int
&&	O
uih	pointer
->	O
playc	pointer
->	O
playframe	int
&&	O
errstring	pointer
==	O
NULL	O
)	O
{	O
parsenext	int
=	O
1	int
;	O
uih	pointer
->	O
playc	pointer
->	O
playframe	int
--	O
;	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
morph	int
)	O
{	O
uih	pointer
->	O
fcontext	pointer
->	O
s	struct
=	O
uih	pointer
->	O
playc	pointer
->	O
destination	struct
;	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
morph	int
=	O
0	int
;	O
}	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
morphangle	int
)	O
{	O
uih_angle	function
(	O
uih	pointer
,	O
uih	pointer
->	O
playc	pointer
->	O
destangle	double
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
morphangle	int
=	O
0	int
;	O
}	O
if	O
(	O
uih	pointer
->	O
playc	pointer
->	O
morphjulia	int
)	O
{	O
uih	pointer
->	O
fcontext	pointer
->	O
pre	double
=	O
uih	pointer
->	O
playc	pointer
->	O
dr	double
;	O
uih	pointer
->	O
fcontext	pointer
->	O
pim	double
=	O
uih	pointer
->	O
playc	pointer
->	O
di	double
;	O
uih_animate_image	O
(	O
uih	pointer
)	O
;	O
uih	pointer
->	O
playc	pointer
->	O
morphjulia	int
=	O
0	int
;	O
}	O
while	O
(	O
!	O
xio_feof	O
(	O
FD	O
)	O
&&	O
parsenext	int
&&	O
errstring	pointer
==	O
NULL	O
)	O
{	O
first	pointer
=	O
1	int
;	O
last	pointer
=	O
0	int
;	O
len	int
=	O
gettoken	function
(	O
uih	pointer
)	O
;	O
first	pointer
=	O
0	int
;	O
if	O
(	O
(	O
k	double
=	O
in_word_set	function
(	O
token	array
,	O
len	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
k	double
->	O
type	int
)	O
{	O
case	O
GENERIC	int
:	O
{	O
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
uih_context	struct
*	O
uih	pointer
)	O
)	O
k	double
->	O
callback	pointer
)	O
(	O
uih	pointer
)	O
;	O
break	O
;	O
}	O
case	O
PARAM_INTEGER	int
:	O
{	O
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
uih_context	struct
*	O
,	O
int	O
)	O
)	O
k	double
->	O
callback	pointer
)	O
(	O
uih	pointer
,	O
getint	function
(	O
uih	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
PARAM_FLOAT	int
:	O
{	O
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
uih_context	struct
*	O
,	O
number_t	double
)	O
)	O
k	double
->	O
callback	pointer
)	O
(	O
uih	pointer
,	O
getfloat	function
(	O
uih	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
PARAM_KEYSTRING	int
:	O
{	O
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
uih_context	struct
*	O
,	O
char	O
*	O
)	O
)	O
k	double
->	O
callback	pointer
)	O
(	O
uih	pointer
,	O
getkeystring	function
(	O
uih	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
PARAM_STRING	int
:	O
{	O
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
uih_context	struct
*	O
,	O
char	O
*	O
)	O
)	O
k	double
->	O
callback	pointer
)	O
(	O
uih	pointer
,	O
getstring	function
(	O
uih	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
PARAM_NSTRING	int
:	O
{	O
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
uih_context	struct
*	O
,	O
int	O
)	O
)	O
k	double
->	O
callback	pointer
)	O
(	O
uih	pointer
,	O
getnstring	function
(	O
uih	pointer
,	O
k	double
->	O
userdata	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
PARAM_BOOL	int
:	O
{	O
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
uih_context	struct
*	O
,	O
int	O
)	O
)	O
k	double
->	O
callback	pointer
)	O
(	O
uih	pointer
,	O
getbool	function
(	O
uih	pointer
)	O
)	O
;	O
break	O
;	O
}	O
case	O
PARAM_COORD	int
:	O
{	O
number_t	double
f1	pointer
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
number_t	double
f2	pointer
=	O
getfloat	function
(	O
uih	pointer
)	O
;	O
(	O
(	O
void	O
(	O
*	O
)	O
(	O
struct	O
uih_context	struct
*	O
,	O
number_t	double
,	O
number_t	double
)	O
)	O
k	double
->	O
callback	pointer
)	O
(	O
uih	pointer
,	O
f1	pointer
,	O
f2	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
seterr	O
(	O
"Unknown command"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
last	pointer
)	O
{	O
seterr	O
(	O
"Too many parameters"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
xio_feof	O
(	O
FD	O
)	O
&&	O
parsenext	int
)	O
||	O
errstring	pointer
)	O
{	O
uih_replaydisable	function
(	O
uih	pointer
)	O
;	O
}	O
}	O
if	O
(	O
errstring	pointer
!=	O
NULL	O
)	O
{	O
sprintf	function
(	O
errtext	array
,	O
"Line %i:%-200s"	pointer
,	O
uih	pointer
->	O
playc	pointer
->	O
line	int
,	O
errstring	pointer
)	O
;	O
uih	pointer
->	O
errstring	pointer
=	O
errtext	array
;	O
}	O
}	O
void	O
uih_load	function
(	O
struct	O
uih_context	struct
*	O
uih	pointer
,	O
xio_file	pointer
f	pointer
,	O
xio_path	pointer
filename	pointer
)	O
{	O
nonblockmode	int
=	O
1	int
;	O
uih_replayenable	function
(	O
uih	pointer
,	O
f	pointer
,	O
filename	pointer
)	O
;	O
uih_replaydisable	function
(	O
uih	pointer
)	O
;	O
nonblockmode	int
=	O
0	int
;	O
}	O
