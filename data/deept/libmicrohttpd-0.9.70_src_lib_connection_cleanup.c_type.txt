static	O
void	O
connection_cleanup_upgraded	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_UpgradeResponseHandle	struct
*	O
urh	pointer
=	O
connection	pointer
->	O
request	pointer
.	O
urh	pointer
;	O
if	O
(	O
NULL	O
==	O
urh	pointer
)	O
return	O
;	O
connection	pointer
->	O
request	pointer
.	O
urh	pointer
=	O
NULL	O
;	O
free	function
(	O
urh	pointer
)	O
;	O
}	O
void	O
MHD_connection_cleanup_	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
daemon	function
->	O
cleanup_tail	pointer
)	O
)	O
{	O
DLL_remove	O
(	O
daemon	function
->	O
cleanup_head	pointer
,	O
daemon	function
->	O
cleanup_tail	pointer
,	O
pos	long
)	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
(	O
MHD_TM_THREAD_PER_CONNECTION	int
==	O
daemon	function
->	O
threading_mode	enum
)	O
&&	O
(	O
!	O
pos	long
->	O
thread_joined	bool
)	O
&&	O
(	O
!	O
MHD_join_thread_	O
(	O
pos	long
->	O
pid	int
.	O
handle	long
)	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to join a thread\n"	pointer
)	O
)	O
;	O
connection_cleanup_upgraded	function
(	O
pos	long
)	O
;	O
MHD_pool_destroy	function
(	O
pos	long
->	O
pool	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_connection_cb	pointer
)	O
daemon	function
->	O
notify_connection_cb	pointer
(	O
daemon	function
->	O
notify_connection_cb_cls	pointer
,	O
pos	long
,	O
MHD_CONNECTION_NOTIFY_CLOSED	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
(	O
const	O
struct	O
sockaddr	struct
*	O
)	O
&	O
pos	long
->	O
addr	pointer
,	O
pos	long
->	O
addr_len	int
)	O
;	O
if	O
(	O
MHD_ELS_EPOLL	int
==	O
daemon	function
->	O
event_loop_syscall	enum
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
{	O
EDLL_remove	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
if	O
(	O
(	O
-	O
1	int
!=	O
daemon	function
->	O
epoll_fd	int
)	O
&&	O
(	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
)	O
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
pos	long
->	O
socket_fd	int
,	O
NULL	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to remove FD from epoll set\n"	pointer
)	O
)	O
;	O
pos	long
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
;	O
}	O
}	O
if	O
(	O
NULL	O
!=	O
pos	long
->	O
request	pointer
.	O
response	pointer
)	O
{	O
MHD_response_queue_for_destroy	function
(	O
pos	long
->	O
request	pointer
.	O
response	pointer
)	O
;	O
pos	long
->	O
request	pointer
.	O
response	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
pos	long
->	O
socket_fd	int
)	O
MHD_socket_close_chk_	O
(	O
pos	long
->	O
socket_fd	int
)	O
;	O
free	function
(	O
pos	long
)	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
daemon	function
->	O
connections	int
--	O
;	O
daemon	function
->	O
at_limit	bool
=	O
false	int
;	O
}	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
}	O
