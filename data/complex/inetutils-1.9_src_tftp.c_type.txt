char	O
ackbuf	array(char)
[	O
PKTSIZE	O
]	O
;	O
int	O
timeout	int
;	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
timeoutbuf	array(struct(array(long),int,struct(array(long))))
;	O
static	O
void	O
nak	(int)->(void)
(	O
int	O
)	O
;	O
static	O
int	O
makerequest	(int,*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),*(char))->(int)
(	O
int	O
,	O
const	O
char	O
*	O
,	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
printstats	(*(char),long)->(void)
(	O
const	O
char	O
*	O
,	O
unsigned	O
long	O
)	O
;	O
static	O
void	O
startclock	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
stopclock	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
timer	(int)->(void)
(	O
int	O
)	O
;	O
static	O
void	O
tpacket	(*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
const	O
char	O
*	O
,	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
,	O
int	O
)	O
;	O
static	O
int	O
rexmtval	int
=	O
TIMEOUT	int
;	O
static	O
int	O
maxtimeout	int
=	O
5	int
*	O
TIMEOUT	int
;	O
static	O
struct	O
sockaddr_storage	struct(short,array(char),long)
peeraddr	struct(short,array(char),long)
;	O
static	O
socklen_t	int
peerlen	int
;	O
static	O
int	O
f	int
=	O
-	O
1	int
;	O
static	O
int	O
port	int
;	O
static	O
int	O
trace	int
;	O
static	O
int	O
verbose	int
;	O
static	O
int	O
connected	int
;	O
char	O
mode	array(char)
[	O
32	int
]	O
;	O
char	O
line	*(char)
[	O
200	int
]	O
;	O
int	O
margc	int
;	O
char	O
*	O
margv	array(*(char))
[	O
20	int
]	O
;	O
char	O
*	O
prompt	*(char)
=	O
"tftp"	*(char)
;	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
toplevel	array(struct(array(long),int,struct(array(long))))
;	O
void	O
intr	(int)->(void)
(	O
int	O
signo	int
)	O
;	O
void	O
get	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
help	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
modecmd	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
put	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
quit	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setascii	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setbinary	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setpeer	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setrexmt	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
settimeout	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
settrace	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
setverbose	(int,*(*(char)))->(void)
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
status	int
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
static	O
void	O
command	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
getusage	(*(char))->(void)
(	O
char	O
*	O
)	O
;	O
static	O
void	O
makeargv	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
putusage	(*(char))->(void)
(	O
char	O
*	O
)	O
;	O
static	O
void	O
settftpmode	(*(char))->(void)
(	O
char	O
*	O
)	O
;	O
static	O
in_port_t	short
get_port	(*(struct(short,array(char),long)))->(short)
(	O
struct	O
sockaddr_storage	struct(short,array(char),long)
*	O
)	O
;	O
static	O
void	O
set_port	(*(struct(short,array(char),long)),short)->(void)
(	O
struct	O
sockaddr_storage	struct(short,array(char),long)
*	O
,	O
in_port_t	short
)	O
;	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
{	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
help	(int,*(*(char)))->(void)
;	O
void	O
(	O
*	O
handler	*((int,*(*(char)))->(void))
)	O
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
}	O
;	O
char	O
vhelp	array(char)
[	O
]	O
=	O
"toggle verbose mode"	*(char)
;	O
char	O
thelp	array(char)
[	O
]	O
=	O
"toggle packet tracing"	*(char)
;	O
char	O
chelp	array(char)
[	O
]	O
=	O
"connect to remote tftp"	*(char)
;	O
char	O
qhelp	array(char)
[	O
]	O
=	O
"exit tftp"	*(char)
;	O
char	O
hhelp	array(char)
[	O
]	O
=	O
"print help information"	*(char)
;	O
char	O
shelp	array(char)
[	O
]	O
=	O
"send file"	*(char)
;	O
char	O
rhelp	array(char)
[	O
]	O
=	O
"receive file"	*(char)
;	O
char	O
mhelp	array(char)
[	O
]	O
=	O
"set file transfer mode"	*(char)
;	O
char	O
sthelp	array(char)
[	O
]	O
=	O
"show current status"	*(char)
;	O
char	O
xhelp	array(char)
[	O
]	O
=	O
"set per-packet retransmission timeout"	*(char)
;	O
char	O
ihelp	array(char)
[	O
]	O
=	O
"set total retransmission timeout"	*(char)
;	O
char	O
ashelp	array(char)
[	O
]	O
=	O
"set mode to netascii"	*(char)
;	O
char	O
bnhelp	array(char)
[	O
]	O
=	O
"set mode to octet"	*(char)
;	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
cmdtab	array(struct(*(char),*(char),*((int,*(*(char)))->(void))))
[	O
]	O
=	O
{	O
{	O
"connect"	*(char)
,	O
chelp	array(char)
,	O
setpeer	(int,*(*(char)))->(void)
}	O
,	O
{	O
"mode"	*(char)
,	O
mhelp	array(char)
,	O
modecmd	(int,*(*(char)))->(void)
}	O
,	O
{	O
"put"	*(char)
,	O
shelp	array(char)
,	O
put	(int,*(*(char)))->(void)
}	O
,	O
{	O
"get"	*(char)
,	O
rhelp	array(char)
,	O
get	(int,*(*(char)))->(void)
}	O
,	O
{	O
"quit"	*(char)
,	O
qhelp	array(char)
,	O
quit	(int,*(*(char)))->(void)
}	O
,	O
{	O
"verbose"	*(char)
,	O
vhelp	array(char)
,	O
setverbose	(int,*(*(char)))->(void)
}	O
,	O
{	O
"trace"	*(char)
,	O
thelp	array(char)
,	O
settrace	(int,*(*(char)))->(void)
}	O
,	O
{	O
"status"	*(char)
,	O
sthelp	array(char)
,	O
status	int
}	O
,	O
{	O
"binary"	*(char)
,	O
bnhelp	array(char)
,	O
setbinary	(int,*(*(char)))->(void)
}	O
,	O
{	O
"ascii"	*(char)
,	O
ashelp	array(char)
,	O
setascii	(int,*(*(char)))->(void)
}	O
,	O
{	O
"rexmt"	*(char)
,	O
xhelp	array(char)
,	O
setrexmt	(int,*(*(char)))->(void)
}	O
,	O
{	O
"timeout"	*(char)
,	O
ihelp	array(char)
,	O
settimeout	(int,*(*(char)))->(void)
}	O
,	O
{	O
"?"	*(char)
,	O
hhelp	array(char)
,	O
help	(int,*(*(char)))->(void)
}	O
,	O
{	O
0	int
}	O
}	O
;	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
getcmd	(*(char))->(*(struct(*(char),*(char),*((int,*`)->(void)))))
(	O
register	O
char	O
*	O
name	*(char)
)	O
;	O
char	O
*	O
tail	(*(char))->(*(char))
(	O
char	O
*	O
filename	*(char)
)	O
;	O
const	O
char	O
args_doc	*(char)
[	O
]	O
=	O
"[HOST [PORT]]"	*(char)
;	O
const	O
char	O
doc	*(char)
[	O
]	O
=	O
"Trivial file transfer protocol client"	*(char)
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
argp_options	array(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"verbose"	*(char)
,	O
'v'	O
,	O
NULL	O
,	O
0	int
,	O
"verbose output"	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
char	O
*	O
hostport_argv	array(*(char))
[	O
3	int
]	O
=	O
{	O
"connect"	*(char)
}	O
;	O
int	O
hostport_argc	int
=	O
1	int
;	O
static	O
in_port_t	short
get_port	(*(struct(short,array(char),long)))->(short)
(	O
struct	O
sockaddr_storage	struct(short,array(char),long)
*	O
ss	*(struct(short,array(char),long))
)	O
{	O
switch	O
(	O
ss	*(struct(short,array(char),long))
->	O
ss_family	short
)	O
{	O
case	O
AF_INET6	O
:	O
return	O
ntohs	(short)->(short)
(	O
(	O
(	O
struct	O
sockaddr_in6	struct(short,short,int,struct(union(array(char),array(short),array(int))),int)
*	O
)	O
ss	*(struct(short,array(char),long))
)	O
->	O
sin6_port	short
)	O
;	O
break	O
;	O
case	O
AF_INET	O
:	O
default	O
:	O
return	O
ntohs	(short)->(short)
(	O
(	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
)	O
ss	*(struct(short,array(char),long))
)	O
->	O
sin_port	short
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
set_port	(*(struct(short,array(char),long)),short)->(void)
(	O
struct	O
sockaddr_storage	struct(short,array(char),long)
*	O
ss	*(struct(short,array(char),long))
,	O
in_port_t	short
port	int
)	O
{	O
switch	O
(	O
ss	*(struct(short,array(char),long))
->	O
ss_family	short
)	O
{	O
case	O
AF_INET6	O
:	O
(	O
(	O
struct	O
sockaddr_in6	struct(short,short,int,struct(union(array(char),array(short),array(int))),int)
*	O
)	O
ss	*(struct(short,array(char),long))
)	O
->	O
sin6_port	short
=	O
htons	(short)->(short)
(	O
port	int
)	O
;	O
break	O
;	O
case	O
AF_INET	O
:	O
default	O
:	O
(	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
)	O
ss	*(struct(short,array(char),long))
)	O
->	O
sin_port	short
=	O
htons	(short)->(short)
(	O
port	int
)	O
;	O
break	O
;	O
}	O
}	O
void	O
recvfile	(int,*(char),*(char))->(void)
(	O
int	O
,	O
char	O
*	O
,	O
char	O
*	O
)	O
;	O
void	O
send_file	(int,*(char),*(char))->(void)
(	O
int	O
,	O
char	O
*	O
,	O
char	O
*	O
)	O
;	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
ARGP_KEY_ARG	int
:	O
if	O
(	O
state	*(int)
->	O
arg_num	int
>=	O
2	int
||	O
hostport_argc	int
>=	O
3	int
)	O
argp_usage	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(void)
(	O
state	*(int)
)	O
;	O
hostport_argv	array(*(char))
[	O
hostport_argc	int
++	O
]	O
=	O
arg	*(char)
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
argp_options	array(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
args_doc	*(char)
,	O
doc	*(char)
}	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
struct	O
servent	struct(*(char),*(*(char)),int,*(char))
*	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"tftp"	*(char)
,	O
default_program_authors	array(*(char))
)	O
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
=	O
getservbyname	(*(char),*(char))->(*(struct(*(char),*(*(char)),int,*(char))))
(	O
"tftp"	*(char)
,	O
"udp"	*(char)
)	O
;	O
if	O
(	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
==	O
0	int
)	O
port	int
=	O
69	int
;	O
else	O
port	int
=	O
ntohs	(short)->(short)
(	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
->	O
s_port	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
mode	array(char)
,	O
"netascii"	*(char)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
intr	(int)->(void)
)	O
;	O
if	O
(	O
hostport_argc	int
>	O
1	int
)	O
{	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
toplevel	array(struct(array(long),int,struct(array(long))))
)	O
!=	O
0	int
)	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
setpeer	(int,*(*(char)))->(void)
(	O
hostport_argc	int
,	O
hostport_argv	array(*(char))
)	O
;	O
}	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
toplevel	array(struct(array(long),int,struct(array(long))))
)	O
!=	O
0	int
)	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
command	()->(void)
(	O
)	O
;	O
}	O
char	O
*	O
hostname	*(char)
;	O
static	O
int	O
resolve_name	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
err	long
;	O
struct	O
sockaddr_storage	struct(short,array(char),long)
ss	*(struct(short,array(char),long))
;	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
*	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
,	O
*	O
aiptr	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
0	int
,	O
sizeof	O
(	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
)	O
)	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_family	int
=	O
AF_UNSPEC	O
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_socktype	int
=	O
SOCK_DGRAM	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
=	O
AI_CANONNAME	int
;	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
.	O
ai_flags	int
+=	O
AI_ADDRCONFIG	int
;	O
err	long
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
name	*(char)
,	O
"tftp"	*(char)
,	O
&	O
hints	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))
,	O
&	O
aiptr	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
err	long
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"tftp: %s: %s\n"	*(char)
,	O
name	*(char)
,	O
gai_strerror	(int)->(*(char))
(	O
err	long
)	O
)	O
;	O
return	O
RESOLVE_FAIL	O
;	O
}	O
if	O
(	O
f	int
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
f	int
)	O
;	O
f	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
aiptr	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
;	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
=	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
{	O
f	int
=	O
socket	(int,int,int)->(int)
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_socktype	int
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_protocol	int
)	O
;	O
if	O
(	O
f	int
<	O
0	int
)	O
continue	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ss	*(struct(short,array(char),long))
,	O
0	int
,	O
sizeof	O
(	O
ss	*(struct(short,array(char),long))
)	O
)	O
;	O
ss	*(struct(short,array(char),long))
.	O
ss_family	short
=	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_family	int
;	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
f	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
ss	*(struct(short,array(char),long))
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
f	int
)	O
;	O
f	int
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
peerlen	int
=	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
peeraddr	struct(short,array(char),long)
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addr	*(struct(short,array(char)))
,	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_addrlen	int
)	O
;	O
connected	int
=	O
1	int
;	O
free	(*(void))->(void)
(	O
hostname	*(char)
)	O
;	O
hostname	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
->	O
ai_canonname	*(char)
)	O
;	O
break	O
;	O
}	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
aiptr	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
ai	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
==	O
NULL	O
)	O
return	O
RESOLVE_FAIL	O
;	O
else	O
return	O
RESOLVE_OK	int
;	O
}	O
static	O
void	O
get_args	(*(char),*(char),*(int),*(*(*(char))))->(void)
(	O
char	O
*	O
arg0	*(char)
,	O
char	O
*	O
prompt	*(char)
,	O
int	O
*	O
argc	int
,	O
char	O
*	O
*	O
*	O
argv	*(*(char))
)	O
{	O
size_t	long
arg0_len	long
=	O
strlen	(*(char))->(long)
(	O
arg0	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
line	*(char)
,	O
arg0	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
line	*(char)
,	O
" "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
prompt	*(char)
)	O
;	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	*(char)
+	O
arg0_len	long
+	O
1	int
,	O
sizeof	O
line	*(char)
-	O
arg0_len	long
-	O
1	int
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
makeargv	()->(void)
(	O
)	O
;	O
*	O
argc	int
=	O
margc	int
;	O
*	O
argv	*(*(char))
=	O
margv	array(*(char))
;	O
}	O
void	O
setpeer	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	(*(char),*(char),*(int),*(*(*(char))))->(void)
(	O
"Connect"	*(char)
,	O
"(to) "	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
argc	int
>	O
3	int
)	O
{	O
printf	(*(char))->(int)
(	O
"usage: %s host-name [port]\n"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
resolve_name	(*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
)	O
{	O
case	O
RESOLVE_OK	int
:	O
break	O
;	O
case	O
RESOLVE_FAIL	O
:	O
return	O
;	O
}	O
if	O
(	O
argc	int
==	O
3	int
)	O
{	O
port	int
=	O
atoi	(*(char))->(int)
(	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
if	O
(	O
port	int
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%s: bad port number\n"	*(char)
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
connected	int
=	O
0	int
;	O
return	O
;	O
}	O
}	O
else	O
{	O
struct	O
servent	struct(*(char),*(*(char)),int,*(char))
*	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
;	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
=	O
getservbyname	(*(char),*(char))->(*(struct(*(char),*(*(char)),int,*(char))))
(	O
"tftp"	*(char)
,	O
"udp"	*(char)
)	O
;	O
if	O
(	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"udp/tftp: unknown service\n"	*(char)
)	O
;	O
port	int
=	O
ntohs	(short)->(short)
(	O
sp	*(struct(*(char),*(*(char)),int,*(char)))
->	O
s_port	int
)	O
;	O
}	O
connected	int
=	O
1	int
;	O
}	O
struct	O
modes	int
{	O
char	O
*	O
m_name	*(char)
;	O
char	O
*	O
m_mode	*(char)
;	O
}	O
modes	int
[	O
]	O
=	O
{	O
{	O
"ascii"	*(char)
,	O
"netascii"	*(char)
}	O
,	O
{	O
"netascii"	*(char)
,	O
"netascii"	*(char)
}	O
,	O
{	O
"binary"	*(char)
,	O
"octet"	*(char)
}	O
,	O
{	O
"image"	*(char)
,	O
"octet"	*(char)
}	O
,	O
{	O
"octet"	*(char)
,	O
"octet"	*(char)
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
void	O
modecmd	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
register	O
struct	O
modes	int
*	O
p	*(void)
;	O
char	O
*	O
sep	*(char)
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Using %s mode to transfer files.\n"	*(char)
,	O
mode	array(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
==	O
2	int
)	O
{	O
for	O
(	O
p	*(void)
=	O
modes	int
;	O
p	*(void)
->	O
m_name	*(char)
;	O
p	*(void)
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
p	*(void)
->	O
m_name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
p	*(void)
->	O
m_name	*(char)
)	O
{	O
settftpmode	(*(char))->(void)
(	O
p	*(void)
->	O
m_mode	*(char)
)	O
;	O
return	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%s: unknown mode\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"usage: %s ["	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
sep	*(char)
=	O
" "	*(char)
;	O
for	O
(	O
p	*(void)
=	O
modes	int
;	O
p	*(void)
->	O
m_name	*(char)
;	O
p	*(void)
++	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s%s"	*(char)
,	O
sep	*(char)
,	O
p	*(void)
->	O
m_name	*(char)
)	O
;	O
if	O
(	O
*	O
sep	*(char)
==	O
' '	O
)	O
sep	*(char)
=	O
" | "	*(char)
;	O
}	O
printf	(*(char))->(int)
(	O
" ]\n"	*(char)
)	O
;	O
return	O
;	O
}	O
void	O
setbinary	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
settftpmode	(*(char))->(void)
(	O
"octet"	*(char)
)	O
;	O
}	O
void	O
setascii	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
settftpmode	(*(char))->(void)
(	O
"netascii"	*(char)
)	O
;	O
}	O
static	O
void	O
settftpmode	(*(char))->(void)
(	O
char	O
*	O
newmode	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
mode	array(char)
,	O
newmode	*(char)
)	O
;	O
if	O
(	O
verbose	int
)	O
printf	(*(char))->(int)
(	O
"mode set to %s\n"	*(char)
,	O
mode	array(char)
)	O
;	O
}	O
void	O
put	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
fd	int
;	O
register	O
int	O
n	long
;	O
register	O
char	O
*	O
cp	*(char)
,	O
*	O
targ	*(char)
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	(*(char),*(char),*(int),*(*(*(char))))->(void)
(	O
"send"	*(char)
,	O
"(file) "	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
putusage	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
targ	*(char)
=	O
argv	*(*(char))
[	O
argc	int
-	O
1	int
]	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
argc	int
-	O
1	int
]	O
,	O
':'	O
)	O
)	O
{	O
char	O
*	O
cp	*(char)
;	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
argc	int
-	O
1	int
;	O
n	long
++	O
)	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
n	long
]	O
,	O
':'	O
)	O
)	O
{	O
putusage	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
cp	*(char)
=	O
argv	*(*(char))
[	O
argc	int
-	O
1	int
]	O
;	O
if	O
(	O
cp	*(char)
[	O
0	int
]	O
==	O
'['	O
)	O
{	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cp	*(char)
,	O
']'	O
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
return	O
;	O
*	O
cp	*(char)
=	O
0	int
;	O
targ	*(char)
=	O
cp	*(char)
+	O
1	int
;	O
cp	*(char)
=	O
argv	*(*(char))
[	O
argc	int
-	O
1	int
]	O
+	O
1	int
;	O
if	O
(	O
targ	*(char)
[	O
0	int
]	O
==	O
':'	O
)	O
++	O
targ	*(char)
;	O
else	O
{	O
targ	*(char)
=	O
argv	*(*(char))
[	O
argc	int
-	O
1	int
]	O
;	O
cp	*(char)
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
targ	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cp	*(char)
,	O
':'	O
)	O
;	O
*	O
targ	*(char)
++	O
=	O
0	int
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
cp	*(char)
)	O
==	O
0	int
)	O
cp	*(char)
=	O
NULL	O
;	O
}	O
if	O
(	O
cp	*(char)
!=	O
NULL	O
&&	O
resolve_name	(*(char))->(int)
(	O
cp	*(char)
)	O
!=	O
RESOLVE_OK	int
)	O
return	O
;	O
}	O
if	O
(	O
!	O
connected	int
)	O
{	O
printf	(*(char))->(int)
(	O
"No target machine specified.\n"	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
argc	int
<	O
4	int
)	O
{	O
cp	*(char)
=	O
argc	int
==	O
2	int
?	O
tail	(*(char))->(*(char))
(	O
targ	*(char)
)	O
:	O
argv	*(*(char))
[	O
1	int
]	O
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
cp	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"tftp: "	*(char)
)	O
;	O
perror	(*(char))->(void)
(	O
cp	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	(*(char))->(int)
(	O
"putting %s to %s:%s [%s]\n"	*(char)
,	O
cp	*(char)
,	O
hostname	*(char)
,	O
targ	*(char)
,	O
mode	array(char)
)	O
;	O
set_port	(*(struct(short,array(char),long)),short)->(void)
(	O
&	O
peeraddr	struct(short,array(char),long)
,	O
port	int
)	O
;	O
send_file	(int,*(char),*(char))->(void)
(	O
fd	int
,	O
targ	*(char)
,	O
mode	array(char)
)	O
;	O
return	O
;	O
}	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
targ	*(char)
,	O
'\0'	O
)	O
;	O
*	O
cp	*(char)
++	O
=	O
'/'	O
;	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
argc	int
-	O
1	int
;	O
n	long
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
cp	*(char)
,	O
tail	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
n	long
]	O
)	O
)	O
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
argv	*(*(char))
[	O
n	long
]	O
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"tftp: "	*(char)
)	O
;	O
perror	(*(char))->(void)
(	O
argv	*(*(char))
[	O
n	long
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	(*(char))->(int)
(	O
"putting %s to %s:%s [%s]\n"	*(char)
,	O
argv	*(*(char))
[	O
n	long
]	O
,	O
hostname	*(char)
,	O
targ	*(char)
,	O
mode	array(char)
)	O
;	O
set_port	(*(struct(short,array(char),long)),short)->(void)
(	O
&	O
peeraddr	struct(short,array(char),long)
,	O
port	int
)	O
;	O
send_file	(int,*(char),*(char))->(void)
(	O
fd	int
,	O
targ	*(char)
,	O
mode	array(char)
)	O
;	O
}	O
}	O
static	O
void	O
putusage	(*(char))->(void)
(	O
char	O
*	O
s	long
)	O
{	O
printf	(*(char))->(int)
(	O
"usage: %s file ... host:target, or\n"	*(char)
,	O
s	long
)	O
;	O
printf	(*(char))->(int)
(	O
"       %s file ... target (when already connected)\n"	*(char)
,	O
s	long
)	O
;	O
}	O
void	O
get	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
fd	int
;	O
register	O
int	O
n	long
;	O
register	O
char	O
*	O
cp	*(char)
;	O
char	O
*	O
src	*(char)
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	(*(char),*(char),*(int),*(*(*(char))))->(void)
(	O
"get"	*(char)
,	O
"(files) "	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
getusage	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
connected	int
)	O
{	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
argc	int
;	O
n	long
++	O
)	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
n	long
]	O
,	O
':'	O
)	O
==	O
0	int
)	O
{	O
getusage	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
}	O
for	O
(	O
n	long
=	O
1	int
;	O
n	long
<	O
argc	int
;	O
n	long
++	O
)	O
{	O
src	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
n	long
]	O
,	O
':'	O
)	O
;	O
if	O
(	O
src	*(char)
==	O
NULL	O
)	O
src	*(char)
=	O
argv	*(*(char))
[	O
n	long
]	O
;	O
else	O
if	O
(	O
src	*(char)
==	O
argv	*(*(char))
[	O
n	long
]	O
)	O
{	O
++	O
src	*(char)
;	O
}	O
else	O
{	O
cp	*(char)
=	O
argv	*(*(char))
[	O
n	long
]	O
;	O
if	O
(	O
cp	*(char)
[	O
0	int
]	O
==	O
'['	O
)	O
{	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
n	long
]	O
,	O
']'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
{	O
src	*(char)
=	O
cp	*(char)
+	O
1	int
;	O
*	O
cp	*(char)
=	O
0	int
;	O
if	O
(	O
*	O
src	*(char)
==	O
':'	O
)	O
++	O
src	*(char)
;	O
cp	*(char)
=	O
argv	*(*(char))
[	O
n	long
]	O
+	O
1	int
;	O
}	O
}	O
else	O
{	O
*	O
src	*(char)
++	O
=	O
0	int
;	O
}	O
if	O
(	O
cp	*(char)
!=	O
NULL	O
&&	O
resolve_name	(*(char))->(int)
(	O
cp	*(char)
)	O
!=	O
RESOLVE_OK	int
)	O
continue	O
;	O
}	O
if	O
(	O
argc	int
<	O
4	int
)	O
{	O
cp	*(char)
=	O
argc	int
==	O
3	int
?	O
argv	*(*(char))
[	O
2	int
]	O
:	O
tail	(*(char))->(*(char))
(	O
src	*(char)
)	O
;	O
fd	int
=	O
creat	(*(char),int)->(int)
(	O
cp	*(char)
,	O
0644	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"tftp: "	*(char)
)	O
;	O
perror	(*(char))->(void)
(	O
cp	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	(*(char))->(int)
(	O
"getting from %s:%s to %s [%s]\n"	*(char)
,	O
hostname	*(char)
,	O
src	*(char)
,	O
cp	*(char)
,	O
mode	array(char)
)	O
;	O
set_port	(*(struct(short,array(char),long)),short)->(void)
(	O
&	O
peeraddr	struct(short,array(char),long)
,	O
port	int
)	O
;	O
recvfile	(int,*(char),*(char))->(void)
(	O
fd	int
,	O
src	*(char)
,	O
mode	array(char)
)	O
;	O
break	O
;	O
}	O
cp	*(char)
=	O
tail	(*(char))->(*(char))
(	O
src	*(char)
)	O
;	O
fd	int
=	O
creat	(*(char),int)->(int)
(	O
cp	*(char)
,	O
0644	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"tftp: "	*(char)
)	O
;	O
perror	(*(char))->(void)
(	O
cp	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
verbose	int
)	O
printf	(*(char))->(int)
(	O
"getting from %s:%s to %s [%s]\n"	*(char)
,	O
hostname	*(char)
,	O
src	*(char)
,	O
cp	*(char)
,	O
mode	array(char)
)	O
;	O
set_port	(*(struct(short,array(char),long)),short)->(void)
(	O
&	O
peeraddr	struct(short,array(char),long)
,	O
port	int
)	O
;	O
recvfile	(int,*(char),*(char))->(void)
(	O
fd	int
,	O
src	*(char)
,	O
mode	array(char)
)	O
;	O
}	O
}	O
static	O
void	O
getusage	(*(char))->(void)
(	O
char	O
*	O
s	long
)	O
{	O
printf	(*(char))->(int)
(	O
"usage: %s host:file host:file ... file, or\n"	*(char)
,	O
s	long
)	O
;	O
printf	(*(char))->(int)
(	O
"       %s file file ... file if connected\n"	*(char)
,	O
s	long
)	O
;	O
}	O
void	O
setrexmt	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
t	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	(*(char),*(char),*(int),*(*(*(char))))->(void)
(	O
"Rexmt-timeout"	*(char)
,	O
"(value) "	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
printf	(*(char))->(int)
(	O
"usage: %s value\n"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
t	int
=	O
atoi	(*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
t	int
<	O
0	int
)	O
printf	(*(char))->(int)
(	O
"%s: bad value\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
else	O
rexmtval	int
=	O
t	int
;	O
}	O
void	O
settimeout	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
t	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
get_args	(*(char),*(char),*(int),*(*(*(char))))->(void)
(	O
"Maximum-timeout"	*(char)
,	O
"(value) "	*(char)
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
printf	(*(char))->(int)
(	O
"usage: %s value\n"	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
;	O
}	O
t	int
=	O
atoi	(*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
t	int
<	O
0	int
)	O
printf	(*(char))->(int)
(	O
"%s: bad value\n"	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
else	O
maxtimeout	int
=	O
t	int
;	O
}	O
void	O
status	int
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
if	O
(	O
connected	int
)	O
printf	(*(char))->(int)
(	O
"Connected to %s.\n"	*(char)
,	O
hostname	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"Not connected.\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Mode: %s Verbose: %s Tracing: %s\n"	*(char)
,	O
mode	array(char)
,	O
verbose	int
?	O
"on"	*(char)
:	O
"off"	*(char)
,	O
trace	int
?	O
"on"	*(char)
:	O
"off"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Rexmt-interval: %d seconds, Max-timeout: %d seconds\n"	*(char)
,	O
rexmtval	int
,	O
maxtimeout	int
)	O
;	O
}	O
void	O
intr	(int)->(void)
(	O
int	O
signo	int
)	O
{	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
SIG_IGN	O
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
toplevel	array(struct(array(long),int,struct(array(long))))
,	O
-	O
1	int
)	O
;	O
}	O
char	O
*	O
tail	(*(char))->(*(char))
(	O
char	O
*	O
filename	*(char)
)	O
{	O
register	O
char	O
*	O
s	long
;	O
while	O
(	O
*	O
filename	*(char)
)	O
{	O
s	long
=	O
strrchr	(*(char),int)->(*(char))
(	O
filename	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
s	long
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
s	long
[	O
1	int
]	O
)	O
return	O
(	O
s	long
+	O
1	int
)	O
;	O
*	O
s	long
=	O
'\0'	O
;	O
}	O
return	O
filename	*(char)
;	O
}	O
static	O
void	O
command	()->(void)
(	O
void	O
)	O
{	O
register	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
;	O
for	O
(	O
;	O
;	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s> "	*(char)
,	O
prompt	*(char)
)	O
;	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	*(char)
,	O
sizeof	O
line	*(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
0	int
)	O
{	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
else	O
continue	O
;	O
}	O
if	O
(	O
line	*(char)
[	O
0	int
]	O
==	O
0	int
)	O
continue	O
;	O
makeargv	()->(void)
(	O
)	O
;	O
if	O
(	O
margc	int
==	O
0	int
)	O
continue	O
;	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
=	O
getcmd	(*(char))->(*(struct(*(char),*(char),*((int,*`)->(void)))))
(	O
margv	array(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
==	O
(	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
)	O
-	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Ambiguous command\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"?Invalid command\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
(	O
*	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
->	O
handler	*((int,*(*(char)))->(void))
)	O
(	O
margc	int
,	O
margv	array(*(char))
)	O
;	O
}	O
}	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
getcmd	(*(char))->(*(struct(*(char),*(char),*((int,*`)->(void)))))
(	O
register	O
char	O
*	O
name	*(char)
)	O
{	O
register	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
;	O
register	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
,	O
*	O
found	*(struct(*(char),*(char),*((int,*(*`))->(void))))
;	O
register	O
int	O
nmatches	int
,	O
longest	int
;	O
longest	int
=	O
0	int
;	O
nmatches	int
=	O
0	int
;	O
found	*(struct(*(char),*(char),*((int,*(*`))->(void))))
=	O
0	int
;	O
for	O
(	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
=	O
cmdtab	array(struct(*(char),*(char),*((int,*(*(char)))->(void))))
;	O
(	O
p	*(void)
=	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
->	O
name	*(char)
)	O
!=	O
NULL	O
;	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
++	O
)	O
{	O
for	O
(	O
q	*(char)
=	O
name	*(char)
;	O
*	O
q	*(char)
==	O
*	O
p	*(void)
++	O
;	O
q	*(char)
++	O
)	O
if	O
(	O
*	O
q	*(char)
==	O
0	int
)	O
return	O
(	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
)	O
;	O
if	O
(	O
!	O
*	O
q	*(char)
)	O
{	O
if	O
(	O
q	*(char)
-	O
name	*(char)
>	O
longest	int
)	O
{	O
longest	int
=	O
q	*(char)
-	O
name	*(char)
;	O
nmatches	int
=	O
1	int
;	O
found	*(struct(*(char),*(char),*((int,*(*`))->(void))))
=	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
;	O
}	O
else	O
if	O
(	O
q	*(char)
-	O
name	*(char)
==	O
longest	int
)	O
nmatches	int
++	O
;	O
}	O
}	O
if	O
(	O
nmatches	int
>	O
1	int
)	O
return	O
(	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
)	O
-	O
1	int
;	O
return	O
found	*(struct(*(char),*(char),*((int,*(*`))->(void))))
;	O
}	O
static	O
void	O
makeargv	()->(void)
(	O
void	O
)	O
{	O
register	O
char	O
*	O
cp	*(char)
;	O
register	O
char	O
*	O
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
margv	array(*(char))
;	O
margc	int
=	O
0	int
;	O
for	O
(	O
cp	*(char)
=	O
line	*(char)
;	O
*	O
cp	*(char)
;	O
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
cp	*(char)
)	O
)	O
cp	*(char)
++	O
;	O
if	O
(	O
*	O
cp	*(char)
==	O
'\0'	O
)	O
break	O
;	O
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
++	O
=	O
cp	*(char)
;	O
margc	int
+=	O
1	int
;	O
while	O
(	O
*	O
cp	*(char)
!=	O
'\0'	O
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
cp	*(char)
)	O
)	O
cp	*(char)
++	O
;	O
if	O
(	O
*	O
cp	*(char)
==	O
'\0'	O
)	O
break	O
;	O
*	O
cp	*(char)
++	O
=	O
'\0'	O
;	O
}	O
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
++	O
=	O
0	int
;	O
}	O
void	O
quit	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
help	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
register	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Commands may be abbreviated.  Commands are:\n\n"	*(char)
)	O
;	O
for	O
(	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
=	O
cmdtab	array(struct(*(char),*(char),*((int,*(*(char)))->(void))))
;	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
->	O
name	*(char)
;	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
++	O
)	O
printf	(*(char))->(int)
(	O
"%-*s\t%s\n"	*(char)
,	O
(	O
int	O
)	O
HELPINDENT	O
,	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
->	O
name	*(char)
,	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
->	O
help	(int,*(*(char)))->(void)
)	O
;	O
return	O
;	O
}	O
while	O
(	O
--	O
argc	int
>	O
0	int
)	O
{	O
register	O
char	O
*	O
arg	*(char)
;	O
arg	*(char)
=	O
*	O
++	O
argv	*(*(char))
;	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
=	O
getcmd	(*(char))->(*(struct(*(char),*(char),*((int,*`)->(void)))))
(	O
arg	*(char)
)	O
;	O
if	O
(	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
==	O
(	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
)	O
-	O
1	int
)	O
printf	(*(char))->(int)
(	O
"?Ambiguous help command %s\n"	*(char)
,	O
arg	*(char)
)	O
;	O
else	O
if	O
(	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
==	O
(	O
struct	O
cmd	struct(*(char),*(char),*((int,*(*(char)))->(void)))
*	O
)	O
0	int
)	O
printf	(*(char))->(int)
(	O
"?Invalid help command %s\n"	*(char)
,	O
arg	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
c	*(struct(*(char),*(char),*((int,*(*`))->(void))))
->	O
help	(int,*(*(char)))->(void)
)	O
;	O
}	O
}	O
void	O
settrace	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
trace	int
=	O
!	O
trace	int
;	O
printf	(*(char))->(int)
(	O
"Packet tracing %s.\n"	*(char)
,	O
trace	int
?	O
"on"	*(char)
:	O
"off"	*(char)
)	O
;	O
}	O
void	O
setverbose	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
verbose	int
=	O
!	O
verbose	int
;	O
printf	(*(char))->(int)
(	O
"Verbose mode %s.\n"	*(char)
,	O
verbose	int
?	O
"on"	*(char)
:	O
"off"	*(char)
)	O
;	O
}	O
void	O
send_file	(int,*(char),*(char))->(void)
(	O
int	O
fd	int
,	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
mode	array(char)
)	O
{	O
register	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
r_init	()->(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))))
(	O
void	O
)	O
,	O
*	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
register	O
int	O
n	long
;	O
volatile	O
int	O
block	int
,	O
size	int
,	O
convert	int
;	O
volatile	O
unsigned	O
long	O
amount	long
;	O
struct	O
sockaddr_storage	struct(short,array(char),long)
from	struct(short,array(char),long)
;	O
socklen_t	int
fromlen	int
;	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
startclock	()->(void)
(	O
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
r_init	()->(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))))
(	O
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
)	O
ackbuf	array(char)
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
"r"	*(char)
)	O
;	O
convert	int
=	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"netascii"	*(char)
)	O
;	O
block	int
=	O
0	int
;	O
amount	long
=	O
0	int
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
timer	(int)->(void)
)	O
;	O
do	O
{	O
if	O
(	O
block	int
==	O
0	int
)	O
size	int
=	O
makerequest	(int,*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),*(char))->(int)
(	O
WRQ	int
,	O
name	*(char)
,	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
mode	array(char)
)	O
-	O
4	int
;	O
else	O
{	O
size	int
=	O
readit	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(struct(short,union(array(char),struct`,array(char))))),int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
convert	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
nak	(int)->(void)
(	O
errno	O
+	O
100	int
)	O
;	O
break	O
;	O
}	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
DATA	int
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
;	O
}	O
timeout	int
=	O
0	int
;	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
timeoutbuf	array(struct(array(long),int,struct(array(long))))
)	O
;	O
send_data	O
:	O
if	O
(	O
trace	int
)	O
tpacket	(*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
"sent"	*(char)
,	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
size	int
+	O
4	int
)	O
;	O
n	long
=	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
f	int
,	O
(	O
const	O
char	O
*	O
)	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
size	int
+	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
peeraddr	struct(short,array(char),long)
,	O
peerlen	int
)	O
;	O
if	O
(	O
n	long
!=	O
size	int
+	O
4	int
)	O
{	O
perror	(*(char))->(void)
(	O
"tftp: sendto"	*(char)
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
read_ahead	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
convert	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
alarm	(int)->(int)
(	O
rexmtval	int
)	O
;	O
do	O
{	O
fromlen	int
=	O
sizeof	O
(	O
from	struct(short,array(char),long)
)	O
;	O
n	long
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
f	int
,	O
ackbuf	array(char)
,	O
sizeof	O
(	O
ackbuf	array(char)
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
&	O
fromlen	int
)	O
;	O
}	O
while	O
(	O
n	long
<=	O
0	int
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
"tftp: recvfrom"	*(char)
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
set_port	(*(struct(short,array(char),long)),short)->(void)
(	O
&	O
peeraddr	struct(short,array(char),long)
,	O
get_port	(*(struct(short,array(char),long)))->(short)
(	O
&	O
from	struct(short,array(char),long)
)	O
)	O
;	O
if	O
(	O
trace	int
)	O
tpacket	(*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
"received"	*(char)
,	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
n	long
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
ntohs	(short)->(short)
(	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
ntohs	(short)->(short)
(	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
)	O
;	O
if	O
(	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
ERROR	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error code %d: %s\n"	*(char)
,	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_code	O
,	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_msg	O
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
if	O
(	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
ACK	int
)	O
{	O
int	O
j	int
;	O
if	O
(	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
==	O
block	int
)	O
break	O
;	O
j	int
=	O
synchnet	(int)->(int)
(	O
f	int
)	O
;	O
if	O
(	O
j	int
&&	O
trace	int
)	O
printf	(*(char))->(int)
(	O
"discarded %d packets\n"	*(char)
,	O
j	int
)	O
;	O
if	O
(	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
==	O
(	O
block	int
-	O
1	int
)	O
)	O
goto	O
send_data	O
;	O
}	O
}	O
if	O
(	O
block	int
>	O
0	int
)	O
amount	long
+=	O
size	int
;	O
block	int
++	O
;	O
}	O
while	O
(	O
size	int
==	O
SEGSIZE	int
||	O
block	int
==	O
1	int
)	O
;	O
abort	()->(void)
:	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
stopclock	()->(void)
(	O
)	O
;	O
if	O
(	O
amount	long
>	O
0	int
)	O
printstats	(*(char),long)->(void)
(	O
"Sent"	*(char)
,	O
amount	long
)	O
;	O
}	O
void	O
recvfile	(int,*(char),*(char))->(void)
(	O
int	O
fd	int
,	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
mode	array(char)
)	O
{	O
register	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
*	O
w_init	()->(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))))
(	O
void	O
)	O
;	O
register	O
int	O
n	long
;	O
volatile	O
int	O
block	int
,	O
size	int
,	O
firsttrip	int
;	O
volatile	O
unsigned	O
long	O
amount	long
;	O
struct	O
sockaddr_storage	struct(short,array(char),long)
from	struct(short,array(char),long)
;	O
socklen_t	int
fromlen	int
;	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
volatile	O
int	O
convert	int
;	O
startclock	()->(void)
(	O
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
w_init	()->(*(struct(short,union(array(char),struct(union`,array(char)),array(char)))))
(	O
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
)	O
ackbuf	array(char)
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
"w"	*(char)
)	O
;	O
convert	int
=	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
mode	array(char)
,	O
"netascii"	*(char)
)	O
;	O
block	int
=	O
1	int
;	O
firsttrip	int
=	O
1	int
;	O
amount	long
=	O
0	int
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
timer	(int)->(void)
)	O
;	O
do	O
{	O
if	O
(	O
firsttrip	int
)	O
{	O
size	int
=	O
makerequest	(int,*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),*(char))->(int)
(	O
RRQ	int
,	O
name	*(char)
,	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
mode	array(char)
)	O
;	O
firsttrip	int
=	O
0	int
;	O
}	O
else	O
{	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
ACK	int
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
(	O
block	int
)	O
)	O
;	O
size	int
=	O
4	int
;	O
block	int
++	O
;	O
}	O
timeout	int
=	O
0	int
;	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
timeoutbuf	array(struct(array(long),int,struct(array(long))))
)	O
;	O
send_ack	O
:	O
if	O
(	O
trace	int
)	O
tpacket	(*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
"sent"	*(char)
,	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
size	int
)	O
;	O
if	O
(	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
f	int
,	O
ackbuf	array(char)
,	O
size	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
peeraddr	struct(short,array(char),long)
,	O
peerlen	int
)	O
!=	O
size	int
)	O
{	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
perror	(*(char))->(void)
(	O
"tftp: sendto"	*(char)
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
write_behind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
convert	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
alarm	(int)->(int)
(	O
rexmtval	int
)	O
;	O
do	O
{	O
fromlen	int
=	O
sizeof	O
(	O
from	struct(short,array(char),long)
)	O
;	O
n	long
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
f	int
,	O
(	O
char	O
*	O
)	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
PKTSIZE	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,array(char),long)
,	O
&	O
fromlen	int
)	O
;	O
}	O
while	O
(	O
n	long
<=	O
0	int
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
"tftp: recvfrom"	*(char)
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
set_port	(*(struct(short,array(char),long)),short)->(void)
(	O
&	O
peeraddr	struct(short,array(char),long)
,	O
get_port	(*(struct(short,array(char),long)))->(short)
(	O
&	O
from	struct(short,array(char),long)
)	O
)	O
;	O
if	O
(	O
trace	int
)	O
tpacket	(*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
"received"	*(char)
,	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
n	long
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
ntohs	(short)->(short)
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
)	O
;	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
ntohs	(short)->(short)
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
)	O
;	O
if	O
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
ERROR	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error code %d: %s\n"	*(char)
,	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_code	O
,	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_msg	O
)	O
;	O
goto	O
abort	()->(void)
;	O
}	O
if	O
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
==	O
DATA	int
)	O
{	O
int	O
j	int
;	O
if	O
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
==	O
block	int
)	O
break	O
;	O
j	int
=	O
synchnet	(int)->(int)
(	O
f	int
)	O
;	O
if	O
(	O
j	int
&&	O
trace	int
)	O
printf	(*(char))->(int)
(	O
"discarded %d packets\n"	*(char)
,	O
j	int
)	O
;	O
if	O
(	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
==	O
(	O
block	int
-	O
1	int
)	O
)	O
goto	O
send_ack	O
;	O
}	O
}	O
size	int
=	O
writeit	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(struct(short,union(array(char),struct`,array(char))))),int,int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
dp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
n	long
-	O
4	int
,	O
convert	int
)	O
;	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
nak	(int)->(void)
(	O
errno	O
+	O
100	int
)	O
;	O
break	O
;	O
}	O
amount	long
+=	O
size	int
;	O
}	O
while	O
(	O
size	int
==	O
SEGSIZE	int
)	O
;	O
abort	()->(void)
:	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
ACK	int
)	O
;	O
ap	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
block	int
)	O
;	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
f	int
,	O
ackbuf	array(char)
,	O
4	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
peeraddr	struct(short,array(char),long)
,	O
peerlen	int
)	O
;	O
write_behind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
convert	int
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
stopclock	()->(void)
(	O
)	O
;	O
if	O
(	O
amount	long
>	O
0	int
)	O
printstats	(*(char),long)->(void)
(	O
"Received"	*(char)
,	O
amount	long
)	O
;	O
}	O
static	O
int	O
makerequest	(int,*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),*(char))->(int)
(	O
int	O
request	int
,	O
const	O
char	O
*	O
name	*(char)
,	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
const	O
char	O
*	O
mode	array(char)
)	O
{	O
register	O
char	O
*	O
cp	*(char)
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
request	int
)	O
;	O
cp	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_stuff	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
cp	*(char)
,	O
name	*(char)
)	O
;	O
cp	*(char)
+=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
*	O
cp	*(char)
++	O
=	O
'\0'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
cp	*(char)
,	O
mode	array(char)
)	O
;	O
cp	*(char)
+=	O
strlen	(*(char))->(long)
(	O
mode	array(char)
)	O
;	O
*	O
cp	*(char)
++	O
=	O
'\0'	O
;	O
return	O
cp	*(char)
-	O
(	O
char	O
*	O
)	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
}	O
struct	O
errmsg	struct(int,*(char))
{	O
int	O
e_code	int
;	O
const	O
char	O
*	O
e_msg	*(char)
;	O
}	O
errmsgs	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
EUNDEF	int
,	O
"Undefined error code"	*(char)
}	O
,	O
{	O
ENOTFOUND	int
,	O
"File not found"	*(char)
}	O
,	O
{	O
EACCESS	int
,	O
"Access violation"	*(char)
}	O
,	O
{	O
ENOSPACE	int
,	O
"Disk full or allocation exceeded"	*(char)
}	O
,	O
{	O
EBADOP	int
,	O
"Illegal TFTP operation"	*(char)
}	O
,	O
{	O
EBADID	int
,	O
"Unknown transfer ID"	*(char)
}	O
,	O
{	O
EEXISTS	int
,	O
"File already exists"	*(char)
}	O
,	O
{	O
ENOUSER	int
,	O
"No such user"	*(char)
}	O
,	O
{	O
-	O
1	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
nak	(int)->(void)
(	O
int	O
error	(int,int,*(char))->(void)
)	O
{	O
register	O
struct	O
errmsg	struct(int,*(char))
*	O
pe	*(struct(int,*(char)))
;	O
register	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
;	O
int	O
length	int
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
=	O
(	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
)	O
ackbuf	array(char)
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
ERROR	int
)	O
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_code	O
=	O
htons	(short)->(short)
(	O
(	O
unsigned	O
short	O
)	O
error	(int,int,*(char))->(void)
)	O
;	O
for	O
(	O
pe	*(struct(int,*(char)))
=	O
errmsgs	array(struct(int,*(char)))
;	O
pe	*(struct(int,*(char)))
->	O
e_code	int
>=	O
0	int
;	O
pe	*(struct(int,*(char)))
++	O
)	O
if	O
(	O
pe	*(struct(int,*(char)))
->	O
e_code	int
==	O
error	(int,int,*(char))->(void)
)	O
break	O
;	O
if	O
(	O
pe	*(struct(int,*(char)))
->	O
e_code	int
<	O
0	int
)	O
{	O
pe	*(struct(int,*(char)))
->	O
e_msg	*(char)
=	O
strerror	(int)->(*(char))
(	O
error	(int,int,*(char))->(void)
-	O
100	int
)	O
;	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_code	O
=	O
EUNDEF	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_msg	O
,	O
pe	*(struct(int,*(char)))
->	O
e_msg	*(char)
)	O
;	O
length	int
=	O
strlen	(*(char))->(long)
(	O
pe	*(struct(int,*(char)))
->	O
e_msg	*(char)
)	O
+	O
4	int
;	O
if	O
(	O
trace	int
)	O
tpacket	(*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
"sent"	*(char)
,	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
length	int
)	O
;	O
if	O
(	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
f	int
,	O
ackbuf	array(char)
,	O
length	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
peeraddr	struct(short,array(char),long)
,	O
peerlen	int
)	O
!=	O
length	int
)	O
perror	(*(char))->(void)
(	O
"nak"	*(char)
)	O
;	O
}	O
static	O
void	O
tpacket	(*(char),*(struct(short,union(array(char),struct(union`,array(char)),array(char)))),int)->(void)
(	O
const	O
char	O
*	O
s	long
,	O
struct	O
tftphdr	struct(short,union(array(char),struct(union(short,short),array(char)),array(char)))
*	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
,	O
int	O
n	long
)	O
{	O
static	O
char	O
*	O
opcodes	array(*(char))
[	O
]	O
=	O
{	O
"#0"	*(char)
,	O
"RRQ"	*(char)
,	O
"WRQ"	*(char)
,	O
"DATA"	*(char)
,	O
"ACK"	*(char)
,	O
"ERROR"	*(char)
}	O
;	O
register	O
char	O
*	O
cp	*(char)
,	O
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
unsigned	O
short	O
op	short
=	O
ntohs	(short)->(short)
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_opcode	short
)	O
;	O
if	O
(	O
op	short
<	O
RRQ	int
||	O
op	short
>	O
ERROR	int
)	O
printf	(*(char))->(int)
(	O
"%s opcode=%x "	*(char)
,	O
s	long
,	O
op	short
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%s %s "	*(char)
,	O
s	long
,	O
opcodes	array(*(char))
[	O
op	short
]	O
)	O
;	O
switch	O
(	O
op	short
)	O
{	O
case	O
RRQ	int
:	O
case	O
WRQ	int
:	O
n	long
-=	O
2	int
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
cp	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_stuff	O
)	O
;	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cp	*(char)
,	O
'\0'	O
)	O
;	O
printf	(*(char))->(int)
(	O
"<file=%s, mode=%s>\n"	*(char)
,	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
cp	*(char)
+	O
1	int
)	O
;	O
break	O
;	O
case	O
DATA	int
:	O
printf	(*(char))->(int)
(	O
"<block=%d, %d bytes>\n"	*(char)
,	O
ntohs	(short)->(short)
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
)	O
,	O
n	long
-	O
4	int
)	O
;	O
break	O
;	O
case	O
ACK	int
:	O
printf	(*(char))->(int)
(	O
"<block=%d>\n"	*(char)
,	O
ntohs	(short)->(short)
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_block	O
)	O
)	O
;	O
break	O
;	O
case	O
ERROR	int
:	O
printf	(*(char))->(int)
(	O
"<code=%d, msg=%s>\n"	*(char)
,	O
ntohs	(short)->(short)
(	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_code	O
)	O
,	O
tp	*(struct(short,union(array(char),struct(union(short,short),array(char)),array(char))))
->	O
th_msg	O
)	O
;	O
break	O
;	O
}	O
}	O
struct	O
timeval	struct(long,long)
tstart	struct(long,long)
;	O
struct	O
timeval	struct(long,long)
tstop	struct(long,long)
;	O
static	O
void	O
startclock	()->(void)
(	O
void	O
)	O
{	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
tstart	struct(long,long)
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
stopclock	()->(void)
(	O
void	O
)	O
{	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
tstop	struct(long,long)
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
printstats	(*(char),long)->(void)
(	O
const	O
char	O
*	O
direction	*(char)
,	O
unsigned	O
long	O
amount	long
)	O
{	O
double	O
delta	double
;	O
delta	double
=	O
(	O
(	O
tstop	struct(long,long)
.	O
tv_sec	long
*	O
10.	int
)	O
+	O
(	O
tstop	struct(long,long)
.	O
tv_usec	long
/	O
100000	int
)	O
)	O
-	O
(	O
(	O
tstart	struct(long,long)
.	O
tv_sec	long
*	O
10.	int
)	O
+	O
(	O
tstart	struct(long,long)
.	O
tv_usec	long
/	O
100000	int
)	O
)	O
;	O
delta	double
=	O
delta	double
/	O
10.	int
;	O
printf	(*(char))->(int)
(	O
"%s %d bytes in %.1f seconds"	*(char)
,	O
direction	*(char)
,	O
(	O
int	O
)	O
amount	long
,	O
delta	double
)	O
;	O
if	O
(	O
verbose	int
)	O
printf	(*(char))->(int)
(	O
" [%.0f bits/sec]"	*(char)
,	O
(	O
amount	long
*	O
8.	int
)	O
/	O
delta	double
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
timer	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
timeout	int
+=	O
rexmtval	int
;	O
if	O
(	O
timeout	int
>=	O
maxtimeout	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Transfer timed out.\n"	*(char)
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
toplevel	array(struct(array(long),int,struct(array(long))))
,	O
-	O
1	int
)	O
;	O
}	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
timeoutbuf	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
