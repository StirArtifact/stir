error_t	(*(int))->(int)
_treefs_s_fsys_getroot	(*(struct(struct,int,*(struct(int,*`,struct`,*`,struct`,int,int,int,*`,*`,*`)),int,int,int,int,int,int,int,*(*(()->(void))),*(struct),*(struct),*(void))),int,*(int),int,*(int),int,int,*(int),*(char),*(int),*(int))->(int)
(	O
struct	O
treefs_fsys	struct(struct,int,*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void))),int,int,int,int,int,int,int,*(*(()->(void))),*(struct),*(struct),*(void))
*	O
fsys	*(struct)
,	O
mach_port_t	O
dotdot	int
,	O
uid_t	O
*	O
uids	*(int)
,	O
unsigned	O
nuids	int
,	O
uid_t	O
*	O
gids	*(int)
,	O
unsigned	O
ngids	int
,	O
int	O
flags	int
,	O
retry_type	O
*	O
retry	*(int)
,	O
char	O
*	O
retry_name	*(char)
,	O
file_t	O
*	O
result	*(int)
,	O
mach_msg_type_name_t	O
*	O
result_type	*(int)
)	O
{	O
error_t	(*(int))->(int)
err	O
;	O
mode_t	int
type	enum(int,int,int,int)
;	O
struct	O
treefs_node	struct(int,*(struct),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct),*(void))
*	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
;	O
struct	O
treefs_auth	struct(int,*(int),*(int),int,int,int,*(void))
*	O
auth	*(struct)
;	O
flags	int
&=	O
O_HURD	O
;	O
err	O
=	O
treefs_fsys_get_root	()->(int)
(	O
fsys	*(struct)
,	O
&	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
O_NOTRANS	O
)	O
)	O
{	O
fsys_t	O
child_fsys	O
;	O
do	O
{	O
err	O
=	O
treefs_node_get_active_trans	(*(struct(int,*(struct(struct`,int,*`,int,int,int,int,int,int,int,*`,*`,*`,*`)),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*`,short,short,*`,short,short)),*(void))),*(struct(int,*(struct(struct`,int,*`,int,int,int,int,int,int,int,*`,*`,*`,*`)),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*`,short,short,*`,short,short)),*(void))),int,*(int),*(int))->(int)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
,	O
0	int
,	O
0	int
,	O
&	O
dotdot	int
,	O
&	O
child_fsys	O
)	O
;	O
if	O
(	O
err	O
==	O
0	int
&&	O
child_fsys	O
!=	O
MACH_PORT_NULL	O
)	O
{	O
err	O
=	O
fsys_getroot	()->(int)
(	O
child_fsys	O
,	O
dotdot	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
uids	*(int)
,	O
nuids	int
,	O
gids	*(int)
,	O
ngids	int
,	O
flags	int
,	O
retry	*(int)
,	O
retry_name	*(char)
,	O
result	*(int)
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
||	O
err	O
==	O
EMIG_SERVER_DIED	O
)	O
treefs_node_drop_active_trans	(*(struct(int,*(struct(struct`,int,*`,int,int,int,int,int,int,int,*`,*`,*`,*`)),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*`,short,short,*`,short,short)),*(void))),int)->(void)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
,	O
control_port	*(int)
)	O
;	O
}	O
}	O
while	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
||	O
err	O
==	O
MIG_SERVER_DIED	O
)	O
;	O
if	O
(	O
err	O
||	O
child_fsys	O
)	O
{	O
if	O
(	O
!	O
err	O
&&	O
*	O
result	*(int)
!=	O
MACH_PORT_NULL	O
)	O
*	O
result_type	*(int)
=	O
MACH_MSG_TYPE_MOVE_SEND	O
;	O
else	O
*	O
result_type	*(int)
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
if	O
(	O
!	O
err	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
dotdot	int
)	O
;	O
treefs_node_unref	(*(struct(int,*(struct(struct`,int,*`,int,int,int,int,int,int,int,*`,*`,*`,*`)),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*`,short,short,*`,short,short)),*(void))))->(void)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
)	O
;	O
return	O
err	O
;	O
}	O
}	O
pthread_mutex_lock	()->(int)
(	O
&	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
->	O
lock	int
)	O
;	O
type	enum(int,int,int,int)
=	O
treefs_node_type	()->(int)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
S_IFLNK	O
&&	O
!	O
(	O
flags	int
&	O
(	O
O_NOLINK	O
|	O
O_NOTRANS	O
)	O
)	O
)	O
{	O
int	O
sym_len	int
=	O
1000	int
;	O
char	O
path_buf	O
[	O
sym_len	int
+	O
1	int
]	O
,	O
*	O
path	*(char)
=	O
path_buf	O
;	O
err	O
=	O
treefs_node_get_symlink	()->(int)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
,	O
path	*(char)
,	O
&	O
sym_len	int
)	O
;	O
if	O
(	O
err	O
==	O
E2BIG	O
)	O
{	O
path	*(char)
=	O
alloca	O
(	O
sym_len	int
+	O
1	int
)	O
;	O
err	O
=	O
treefs_node_get_symlink	()->(int)
(	O
node	*(struct)
,	O
path	*(char)
,	O
&	O
sym_len	int
)	O
;	O
}	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
if	O
(	O
*	O
path	*(char)
==	O
'/'	O
)	O
{	O
*	O
retry	*(int)
=	O
FS_RETRY_MAGICAL	O
;	O
*	O
result	*(int)
=	O
MACH_PORT_NULL	O
;	O
*	O
result_type	*(int)
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
dotdot	int
)	O
;	O
}	O
else	O
{	O
*	O
retry	*(int)
=	O
FS_RETRY_REAUTH	O
;	O
*	O
result	*(int)
=	O
dotdot	int
;	O
*	O
result_type	*(int)
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
}	O
strcpy	O
(	O
retry_name	*(char)
,	O
path	*(char)
)	O
;	O
goto	O
out	O
;	O
}	O
err	O
=	O
treefs_node_create_auth	()->(int)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
,	O
uids	*(int)
,	O
nuids	int
,	O
gids	*(int)
,	O
ngids	int
,	O
&	O
auth	*(struct)
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
out	O
;	O
*	O
retry	*(int)
=	O
FS_RETRY_NORMAL	O
;	O
*	O
retry_name	*(char)
=	O
'\0'	O
;	O
*	O
result_type	*(int)
=	O
MACH_MSG_TYPE_MAKE_SEND	O
;	O
err	O
=	O
treefs_node_create_right	(*(struct(int,*(struct(struct`,int,*`,int,int,int,int,int,int,int,*`,*`,*`,*`)),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*`,short,short,*`,short,short)),*(void))),int,int,*(struct(int,*(int),*(int),int,int,int,*(void))),*(int))->(int)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
,	O
dotdot	int
,	O
flags	int
,	O
auth	*(struct)
,	O
result	*(int)
)	O
;	O
treefs_node_auth_unref	()->(int)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
,	O
auth	*(struct)
)	O
;	O
out	O
:	O
treefs_node_release	(*(struct(int,*(struct(struct`,int,*`,int,int,int,int,int,int,int,*`,*`,*`,*`)),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*`,short,short,*`,short,short)),*(void))))->(void)
(	O
root	*(struct(int,*(struct(struct,int,*(struct`),int,int,int,int,int,int,int,*(*`),*(struct`),*(struct`),*(void))),struct,*(char),struct,int,int,int,*(*(()->(void))),*(struct(*(*`),short,short,*(char),short,short)),*(void)))
)	O
;	O
return	O
err	O
;	O
}	O
