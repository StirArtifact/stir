ESint32	long
EDMAPROC	O
Look4Met1	(long,*(char))->(long)
(	O
CLASSID	long
id	long
,	O
EPChar	*(char)
MetName	*(char)
)	O
;	O
EPVoid	*(void)
EDMAPROC	O
edma_smet3s	(*(char),*(char),*(char))->(*(void))
(	O
EPChar	*(char)
cn	*(char)
,	O
EPChar	*(char)
Id	long
,	O
EPChar	*(char)
Sig	array(char)
,	O
...	O
)	O
{	O
CLASSID	long
idc	long
;	O
EPVoid	*(void)
r	*(void)
;	O
va_list	*(char)
p	*(char)
;	O
if	O
(	O
cn	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_smet3] Invalid Class Name (NULL)"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
Id	long
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_smet3] Invalid Static Method Name (NULL)"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
Sig	array(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_smet3] Invalid "	*(char)
"Static Method Signature (NULL)"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
idc	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
cn	*(char)
)	O
;	O
if	O
(	O
idc	long
==	O
-	O
1	int
)	O
{	O
return	O
(	O
EPVoid	*(void)
)	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_smet3s] Class '%s' "	*(char)
"don't exist"	*(char)
,	O
cn	*(char)
)	O
;	O
}	O
va_start	O
(	O
p	*(char)
,	O
Sig	array(char)
)	O
;	O
r	*(void)
=	O
(	O
EPVoid	*(void)
)	O
edma_smet3sx	(long,*(char),*(char),*(char))->(*(void))
(	O
idc	long
,	O
Id	long
,	O
Sig	array(char)
,	O
p	*(char)
)	O
;	O
va_end	O
(	O
p	*(char)
)	O
;	O
return	O
r	*(void)
;	O
}	O
EPVoid	*(void)
EDMAPROC	O
edma_smet3sx	(long,*(char),*(char),*(char))->(*(void))
(	O
CLASSID	long
idc	long
,	O
EPChar	*(char)
Id	long
,	O
EPChar	*(char)
Sig	array(char)
,	O
va_list	*(char)
p	*(char)
)	O
{	O
OBJID	long
sObj	long
;	O
EUint32	long
i	long
,	O
l	long
;	O
EUint32	long
n	long
,	O
j	long
,	O
k	long
;	O
EChar	char
MiSig	array(char)
[	O
50	int
]	O
;	O
EChar	char
SAux	array(char)
[	O
2	int
]	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
MiSig	array(char)
,	O
0	int
,	O
50	int
)	O
;	O
j	long
=	O
strlen	(*(char))->(int)
(	O
Sig	array(char)
)	O
;	O
n	long
=	O
0	int
;	O
SAux	array(char)
[	O
1	int
]	O
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
j	long
;	O
i	long
++	O
)	O
if	O
(	O
(	O
Sig	array(char)
[	O
i	long
]	O
!=	O
'O'	O
)	O
&&	O
(	O
Sig	array(char)
[	O
i	long
]	O
!=	O
'L'	O
)	O
)	O
{	O
SAux	array(char)
[	O
0	int
]	O
=	O
*	O
(	O
Sig	array(char)
+	O
i	long
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
MiSig	array(char)
,	O
SAux	array(char)
)	O
;	O
n	long
++	O
;	O
}	O
else	O
if	O
(	O
Sig	array(char)
[	O
i	long
]	O
==	O
'O'	O
)	O
{	O
sObj	long
=	O
(	O
OBJID	long
)	O
(	O
*	O
(	O
(	O
EPUint32	*(long)
)	O
p	*(char)
+	O
n	long
)	O
)	O
;	O
strncat	(*(char),*(char),int)->(*(char))
(	O
MiSig	array(char)
,	O
gClass	O
[	O
idc	long
]	O
->	O
ClassName	array(char)
,	O
50	int
)	O
;	O
n	long
++	O
;	O
}	O
else	O
{	O
l	long
=	O
strchr	(*(char),int)->(*(char))
(	O
Sig	array(char)
+	O
i	long
,	O
';'	O
)	O
-	O
(	O
Sig	array(char)
+	O
i	long
)	O
-	O
1	int
;	O
k	long
=	O
strlen	(*(char))->(int)
(	O
MiSig	array(char)
)	O
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
MiSig	array(char)
+	O
k	long
,	O
Sig	array(char)
+	O
i	long
+	O
1	int
,	O
l	long
)	O
;	O
i	long
+=	O
(	O
l	long
+	O
1	int
)	O
;	O
n	long
++	O
;	O
}	O
return	O
0	int
;	O
}	O
EPVoid	*(void)
EDMAPROC	O
edma_smet3	(*(char),*(char))->(*(void))
(	O
EPChar	*(char)
cn	*(char)
,	O
EPChar	*(char)
Id	long
,	O
...	O
)	O
{	O
CLASSID	long
idc	long
;	O
EPVoid	*(void)
r	*(void)
;	O
va_list	*(char)
p	*(char)
;	O
if	O
(	O
cn	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_smet3] Invalid Class Name (NULL)"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
Id	long
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_smet3] Invalid Static Method Name (NULL)"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
idc	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
cn	*(char)
)	O
;	O
if	O
(	O
idc	long
==	O
-	O
1	int
)	O
{	O
return	O
(	O
EPVoid	*(void)
)	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_met3] Class '%s' "	*(char)
"don't exist"	*(char)
,	O
cn	*(char)
)	O
;	O
}	O
if	O
(	O
ProcMapTable	*(char)
[	O
idc	long
]	O
!=	O
CLASS_LOADED	int
)	O
edma_load_class_imp	(long)->(long)
(	O
idc	long
)	O
;	O
va_start	O
(	O
p	*(char)
,	O
Id	long
)	O
;	O
r	*(void)
=	O
edma_smet3x	(long,*(char),*(char))->(*(void))
(	O
idc	long
,	O
Id	long
,	O
p	*(char)
)	O
;	O
va_end	O
(	O
p	*(char)
)	O
;	O
return	O
r	*(void)
;	O
}	O
EPVoid	*(void)
EDMAPROC	O
edma_smet3x	(long,*(char),*(char))->(*(void))
(	O
CLASSID	long
cid	long
,	O
EPChar	*(char)
Id	long
,	O
va_list	*(char)
p	*(char)
)	O
{	O
EUint32	long
i	long
;	O
EPVoid	*(void)
r	*(void)
;	O
PPROC	*(()->(long))
Func	*(()->(long))
;	O
long	O
*	O
p2	array(*(long))
[	O
16	int
]	O
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
cid	long
,	O
"edma_get_class_module"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
Id	long
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_smet3] Invalid Static Method Name (NULL)"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
i	long
=	O
Look4Met1	(long,*(char))->(long)
(	O
cid	long
,	O
Id	long
)	O
;	O
if	O
(	O
i	long
==	O
-	O
1	int
)	O
return	O
(	O
EPVoid	*(void)
)	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_smet3x] Method '%s' "	*(char)
"not found in class '%s'"	*(char)
,	O
Id	long
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array(char)
)	O
;	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
cid	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
Static	char
)	O
{	O
Func	*(()->(long))
=	O
(	O
PPROC	*(()->(long))
)	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
cid	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
[	O
i	long
]	O
.	O
Func	*(()->(long))
;	O
p2	array(*(long))
[	O
0	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
p2	array(*(long))
[	O
1	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
p2	array(*(long))
[	O
2	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
p2	array(*(long))
[	O
3	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
p2	array(*(long))
[	O
4	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
p2	array(*(long))
[	O
5	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
p2	array(*(long))
[	O
6	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
p2	array(*(long))
[	O
7	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
p2	array(*(long))
[	O
8	int
]	O
=	O
va_arg	O
(	O
p	*(char)
,	O
long	O
*	O
)	O
;	O
r	*(void)
=	O
(	O
EPVoid	*(void)
)	O
Func	*(()->(long))
(	O
cid	long
,	O
p2	array(*(long))
[	O
0	int
]	O
,	O
p2	array(*(long))
[	O
1	int
]	O
,	O
p2	array(*(long))
[	O
2	int
]	O
,	O
p2	array(*(long))
[	O
3	int
]	O
,	O
p2	array(*(long))
[	O
4	int
]	O
,	O
p2	array(*(long))
[	O
5	int
]	O
,	O
p2	array(*(long))
[	O
6	int
]	O
,	O
p2	array(*(long))
[	O
7	int
]	O
,	O
p2	array(*(long))
[	O
8	int
]	O
)	O
;	O
return	O
r	*(void)
;	O
}	O
else	O
{	O
return	O
(	O
EPVoid	*(void)
)	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_smet3x] Method '%s' "	*(char)
"isn't static"	*(char)
,	O
Id	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
Look4Met1	(long,*(char))->(long)
(	O
CLASSID	long
Tipo	long
,	O
EPChar	*(char)
MetName	*(char)
)	O
{	O
EUint32	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
Tipo	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
MetName	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
i	long
==	O
gClass	O
[	O
Tipo	long
]	O
->	O
nMet	short
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
return	O
i	long
;	O
}	O
}	O
