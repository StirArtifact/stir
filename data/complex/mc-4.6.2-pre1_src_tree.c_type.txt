extern	O
int	O
command_prompt	int
;	O
static	O
int	O
tree_navigation_flag	int
;	O
struct	O
WTree	struct
{	O
Widget	struct
widget	*(struct)
;	O
struct	O
TreeStore	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(char),*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`))))),int,int)
*	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
char	O
search_buffer	array(char)
[	O
256	int
]	O
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
*	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
;	O
int	O
is_panel	int
;	O
int	O
active	int
;	O
int	O
searching	int
;	O
int	O
topdiff	int
;	O
}	O
;	O
static	O
void	O
save_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
;	O
static	O
void	O
tree_rescan_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
)	O
;	O
static	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
back_ptr	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(int))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
ptr	*(*(void))
,	O
int	O
*	O
count	int
)	O
{	O
int	O
i	array(int)
=	O
0	int
;	O
while	O
(	O
ptr	*(*(void))
&&	O
ptr	*(*(void))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
i	array(int)
<	O
*	O
count	int
)	O
{	O
ptr	*(*(void))
=	O
ptr	*(*(void))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
i	array(int)
++	O
;	O
}	O
*	O
count	int
=	O
i	array(int)
;	O
return	O
ptr	*(*(void))
;	O
}	O
static	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
forw_ptr	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(int))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
ptr	*(*(void))
,	O
int	O
*	O
count	int
)	O
{	O
int	O
i	array(int)
=	O
0	int
;	O
while	O
(	O
ptr	*(*(void))
&&	O
ptr	*(*(void))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
i	array(int)
<	O
*	O
count	int
)	O
{	O
ptr	*(*(void))
=	O
ptr	*(*(void))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
i	array(int)
++	O
;	O
}	O
*	O
count	int
=	O
i	array(int)
;	O
return	O
ptr	*(*(void))
;	O
}	O
static	O
void	O
remove_callback	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(void))->(void)
(	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
,	O
void	O
*	O
data	*(void)
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
data	*(void)
;	O
if	O
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
==	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
else	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
}	O
static	O
void	O
tree_remove_entry	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),*(char))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
char	O
*	O
name	*(char)
)	O
{	O
(	O
void	O
)	O
tree	*(struct)
;	O
tree_store_remove_entry	(*(char))->(void)
(	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
tree_destroy	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_store_remove_entry_remove_hook	(*((*(struct(*`,int,long,*`,int,int,*`,*`)),*(void))->(void)))->(void)
(	O
remove_callback	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(void))->(void)
)	O
;	O
save_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
g_free	(*(void))->(void)
(	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
)	O
;	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
=	O
0	int
;	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
}	O
static	O
void	O
load_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_store_load	()->(int)
(	O
)	O
;	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
tree_chdir	(*(struct),*(char))->(void)
(	O
tree	*(struct)
,	O
home_dir	*(char)
)	O
;	O
}	O
static	O
void	O
save_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
int	O
error	*(struct(int,int,*(char)))
;	O
(	O
void	O
)	O
tree	*(struct)
;	O
error	*(struct(int,int,*(char)))
=	O
tree_store_save	()->(int)
(	O
)	O
;	O
if	O
(	O
error	*(struct(int,int,*(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Cannot open the %s file for writing:\n%s\n"	*(char)
)	O
,	O
MC_TREE	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
error	*(struct(int,int,*(char)))
)	O
)	O
;	O
}	O
}	O
static	O
void	O
tree_show_mini_info	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int,int)->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
int	O
tree_lines	int
,	O
int	O
tree_cols	int
)	O
{	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
h	*(struct)
=	O
tree	*(struct)
->	O
widget	*(struct)
.	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
line	int
;	O
if	O
(	O
tree	*(struct)
->	O
is_panel	int
)	O
{	O
if	O
(	O
!	O
show_mini_info	int
)	O
return	O
;	O
line	int
=	O
tree_lines	int
+	O
2	int
;	O
}	O
else	O
line	int
=	O
tree_lines	int
+	O
1	int
;	O
widget_move	O
(	O
&	O
tree	*(struct)
->	O
widget	*(struct)
,	O
line	int
,	O
1	int
)	O
;	O
hline	(int,int)->(void)
(	O
' '	O
,	O
tree_cols	int
)	O
;	O
widget_move	O
(	O
&	O
tree	*(struct)
->	O
widget	*(struct)
,	O
line	int
,	O
1	int
)	O
;	O
if	O
(	O
tree	*(struct)
->	O
searching	int
)	O
{	O
attrset	(int)->(void)
(	O
TREE_NORMALC	O
(	O
h	*(struct)
)	O
)	O
;	O
attrset	(int)->(void)
(	O
DLG_FOCUSC	O
(	O
h	*(struct)
)	O
)	O
;	O
addch	O
(	O
PATH_SEP	char
)	O
;	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	(*(char),int)->(*(char))
(	O
tree	*(struct)
->	O
search_buffer	array(char)
,	O
tree_cols	int
-	O
2	int
)	O
)	O
;	O
addch	O
(	O
' '	O
)	O
;	O
attrset	(int)->(void)
(	O
DLG_FOCUSC	O
(	O
h	*(struct)
)	O
)	O
;	O
}	O
else	O
{	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	(*(char),int)->(*(char))
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
tree_cols	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
h	*(struct)
=	O
tree	*(struct)
->	O
widget	*(struct)
.	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
;	O
int	O
i	array(int)
,	O
j	int
,	O
topsublevel	int
;	O
int	O
x	array(long)
,	O
y	short
;	O
int	O
tree_lines	int
,	O
tree_cols	int
;	O
x	array(long)
=	O
y	short
=	O
0	int
;	O
tree_lines	int
=	O
tlines	O
(	O
tree	*(struct)
)	O
;	O
tree_cols	int
=	O
tree	*(struct)
->	O
widget	*(struct)
.	O
cols	int
;	O
attrset	(int)->(void)
(	O
TREE_NORMALC	O
(	O
h	*(struct)
)	O
)	O
;	O
widget_move	O
(	O
(	O
Widget	struct
*	O
)	O
tree	*(struct)
,	O
y	short
,	O
x	array(long)
)	O
;	O
if	O
(	O
tree	*(struct)
->	O
is_panel	int
)	O
{	O
tree_cols	int
-=	O
2	int
;	O
x	array(long)
=	O
y	short
=	O
1	int
;	O
}	O
g_free	(*(void))->(void)
(	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
)	O
;	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
=	O
g_new	O
(	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
,	O
tree_lines	int
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
tree_lines	int
;	O
i	array(int)
++	O
)	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
[	O
i	array(int)
]	O
=	O
NULL	O
;	O
if	O
(	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
topsublevel	int
=	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
;	O
else	O
topsublevel	int
=	O
0	int
;	O
if	O
(	O
!	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
tree	*(struct)
->	O
topdiff	int
=	O
0	int
;	O
}	O
current	*(struct)
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
i	array(int)
=	O
0	int
;	O
while	O
(	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
i	array(int)
<	O
tree	*(struct)
->	O
topdiff	int
)	O
{	O
current	*(struct)
=	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
<	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
current	*(struct)
->	O
name	*(char)
)	O
)	O
==	O
0	int
)	O
i	array(int)
++	O
;	O
}	O
else	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
==	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
for	O
(	O
j	int
=	O
strlen	(*(char))->(long)
(	O
current	*(struct)
->	O
name	*(char)
)	O
-	O
1	int
;	O
current	*(struct)
->	O
name	*(char)
[	O
j	int
]	O
!=	O
PATH_SEP	char
;	O
j	int
--	O
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
j	int
)	O
==	O
0	int
)	O
i	array(int)
++	O
;	O
}	O
else	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
==	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
+	O
1	int
&&	O
strlen	(*(char))->(long)
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
>	O
1	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
)	O
==	O
0	int
)	O
i	array(int)
++	O
;	O
}	O
}	O
tree	*(struct)
->	O
topdiff	int
=	O
i	array(int)
;	O
}	O
else	O
current	*(struct)
=	O
back_ptr	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(int))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
current	*(struct)
,	O
&	O
tree	*(struct)
->	O
topdiff	int
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
tree_lines	int
;	O
i	array(int)
++	O
)	O
{	O
widget_move	O
(	O
&	O
tree	*(struct)
->	O
widget	*(struct)
,	O
y	short
+	O
i	array(int)
,	O
x	array(long)
)	O
;	O
hline	(int,int)->(void)
(	O
' '	O
,	O
tree_cols	int
)	O
;	O
widget_move	O
(	O
&	O
tree	*(struct)
->	O
widget	*(struct)
,	O
y	short
+	O
i	array(int)
,	O
x	array(long)
)	O
;	O
if	O
(	O
!	O
current	*(struct)
)	O
continue	O
;	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
[	O
i	array(int)
]	O
=	O
current	*(struct)
;	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
==	O
topsublevel	int
)	O
{	O
if	O
(	O
tree	*(struct)
->	O
active	int
&&	O
current	*(struct)
==	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
!	O
use_colors	int
&&	O
!	O
tree	*(struct)
->	O
is_panel	int
)	O
attrset	(int)->(void)
(	O
MARKED_COLOR	O
)	O
;	O
else	O
attrset	(int)->(void)
(	O
SELECTED_COLOR	O
)	O
;	O
}	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	(*(char),int)->(*(char))
(	O
current	*(struct)
->	O
name	*(char)
,	O
tree_cols	int
-	O
6	int
)	O
)	O
;	O
}	O
else	O
{	O
acs	O
(	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
current	*(struct)
->	O
sublevel	int
-	O
topsublevel	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
tree_cols	int
-	O
8	int
-	O
3	int
*	O
j	int
<	O
9	int
)	O
break	O
;	O
addch	O
(	O
' '	O
)	O
;	O
if	O
(	O
current	*(struct)
->	O
submask	long
&	O
(	O
1	int
<<	O
(	O
j	int
+	O
topsublevel	int
+	O
1	int
)	O
)	O
)	O
addch	O
(	O
ACS_VLINE	O
)	O
;	O
else	O
addch	O
(	O
' '	O
)	O
;	O
addch	O
(	O
' '	O
)	O
;	O
}	O
addch	O
(	O
' '	O
)	O
;	O
j	int
++	O
;	O
if	O
(	O
!	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
||	O
!	O
(	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
submask	long
&	O
(	O
1	int
<<	O
current	*(struct)
->	O
sublevel	int
)	O
)	O
)	O
addch	O
(	O
ACS_LLCORNER	O
)	O
;	O
else	O
addch	O
(	O
ACS_LTEE	char
)	O
;	O
addch	O
(	O
ACS_HLINE	O
)	O
;	O
noacs	O
(	O
)	O
;	O
if	O
(	O
tree	*(struct)
->	O
active	int
&&	O
current	*(struct)
==	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
!	O
use_colors	int
&&	O
!	O
tree	*(struct)
->	O
is_panel	int
)	O
attrset	(int)->(void)
(	O
MARKED_COLOR	O
)	O
;	O
else	O
attrset	(int)->(void)
(	O
SELECTED_COLOR	O
)	O
;	O
}	O
addch	O
(	O
' '	O
)	O
;	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	(*(char),int)->(*(char))
(	O
current	*(struct)
->	O
subname	*(char)
,	O
tree_cols	int
-	O
2	int
-	O
4	int
-	O
3	int
*	O
j	int
)	O
)	O
;	O
}	O
addch	O
(	O
' '	O
)	O
;	O
attrset	(int)->(void)
(	O
TREE_NORMALC	O
(	O
h	*(struct)
)	O
)	O
;	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
while	O
(	O
current	*(struct)
)	O
{	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
<	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
current	*(struct)
->	O
name	*(char)
)	O
)	O
==	O
0	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
==	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
for	O
(	O
j	int
=	O
strlen	(*(char))->(long)
(	O
current	*(struct)
->	O
name	*(char)
)	O
-	O
1	int
;	O
current	*(struct)
->	O
name	*(char)
[	O
j	int
]	O
!=	O
PATH_SEP	char
;	O
j	int
--	O
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
j	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
==	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
+	O
1	int
&&	O
strlen	(*(char))->(long)
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
>	O
1	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
)	O
==	O
0	int
)	O
break	O
;	O
}	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
}	O
}	O
tree_show_mini_info	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int,int)->(void)
(	O
tree	*(struct)
,	O
tree_lines	int
,	O
tree_cols	int
)	O
;	O
}	O
static	O
void	O
check_focus	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
if	O
(	O
tree	*(struct)
->	O
topdiff	int
<	O
3	int
)	O
tree	*(struct)
->	O
topdiff	int
=	O
3	int
;	O
else	O
if	O
(	O
tree	*(struct)
->	O
topdiff	int
>=	O
tlines	O
(	O
tree	*(struct)
)	O
-	O
3	int
)	O
tree	*(struct)
->	O
topdiff	int
=	O
tlines	O
(	O
tree	*(struct)
)	O
-	O
3	int
-	O
1	int
;	O
}	O
static	O
void	O
tree_move_backward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
int	O
i	array(int)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
;	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
current	*(struct)
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
while	O
(	O
j	int
<	O
i	array(int)
&&	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sublevel	int
>=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
current	*(struct)
=	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
==	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
current	*(struct)
;	O
j	int
++	O
;	O
}	O
}	O
i	array(int)
=	O
j	int
;	O
}	O
else	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
back_ptr	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(int))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
,	O
&	O
i	array(int)
)	O
;	O
tree	*(struct)
->	O
topdiff	int
-=	O
i	array(int)
;	O
check_focus	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
tree_move_forward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
int	O
i	array(int)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
;	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
current	*(struct)
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
while	O
(	O
j	int
<	O
i	array(int)
&&	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sublevel	int
>=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
current	*(struct)
->	O
sublevel	int
==	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
current	*(struct)
;	O
j	int
++	O
;	O
}	O
}	O
i	array(int)
=	O
j	int
;	O
}	O
else	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
forw_ptr	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(int))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
,	O
&	O
i	array(int)
)	O
;	O
tree	*(struct)
->	O
topdiff	int
+=	O
i	array(int)
;	O
check_focus	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
tree_move_to_child	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
;	O
if	O
(	O
!	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
return	O
;	O
current	*(struct)
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
current	*(struct)
&&	O
current	*(struct)
->	O
sublevel	int
>	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
current	*(struct)
;	O
tree	*(struct)
->	O
topdiff	int
++	O
;	O
check_focus	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
else	O
{	O
tree_rescan_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
current	*(struct)
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
current	*(struct)
&&	O
current	*(struct)
->	O
sublevel	int
>	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
current	*(struct)
;	O
tree	*(struct)
->	O
topdiff	int
++	O
;	O
check_focus	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
}	O
}	O
static	O
int	O
tree_move_to_parent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(int)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
if	O
(	O
!	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
return	O
0	int
;	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
current	*(struct)
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
while	O
(	O
current	*(struct)
&&	O
current	*(struct)
->	O
sublevel	int
>=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
current	*(struct)
=	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
tree	*(struct)
->	O
topdiff	int
--	O
;	O
}	O
if	O
(	O
!	O
current	*(struct)
)	O
current	*(struct)
=	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
current	*(struct)
;	O
check_focus	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
!=	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
static	O
void	O
tree_move_to_top	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
tree	*(struct)
->	O
topdiff	int
=	O
0	int
;	O
}	O
static	O
void	O
tree_move_to_bottom	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_last	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
tree	*(struct)
->	O
topdiff	int
=	O
tlines	O
(	O
tree	*(struct)
)	O
-	O
3	int
-	O
1	int
;	O
}	O
void	O
tree_chdir	(*(struct),*(char))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
const	O
char	O
*	O
dir	*(struct)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
;	O
current	*(struct)
=	O
tree_store_whereis	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
dir	*(struct)
)	O
;	O
if	O
(	O
current	*(struct)
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
current	*(struct)
;	O
check_focus	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
}	O
void	O
sync_tree	(*(char))->(void)
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
tree_chdir	(*(struct),*(char))->(void)
(	O
the_tree	*(struct)
,	O
path	*(char)
)	O
;	O
}	O
static	O
void	O
tree_event	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
int	O
y	short
)	O
{	O
if	O
(	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
[	O
y	short
]	O
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
[	O
y	short
]	O
;	O
tree	*(struct)
->	O
topdiff	int
=	O
y	short
;	O
}	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
chdir_sel	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
;	O
static	O
void	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
if	O
(	O
!	O
(	O
xtree_mode	int
&&	O
tree	*(struct)
->	O
is_panel	int
)	O
)	O
return	O
;	O
if	O
(	O
is_idle	()->(int)
(	O
)	O
)	O
chdir_sel	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
int	O
event_callback	(*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))),*(void))->(int)
(	O
Gpm_Event	struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))
*	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
,	O
void	O
*	O
data	*(void)
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
data	*(void)
;	O
if	O
(	O
!	O
(	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
type	enum(int,int,int,int)
&	O
GPM_UP	int
)	O
)	O
return	O
MOU_NORMAL	int
;	O
if	O
(	O
tree	*(struct)
->	O
is_panel	int
)	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
y	short
--	O
;	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
y	short
--	O
;	O
if	O
(	O
!	O
tree	*(struct)
->	O
active	int
)	O
change_panel	()->(void)
(	O
)	O
;	O
if	O
(	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
y	short
<	O
0	int
)	O
{	O
tree_move_backward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
tlines	O
(	O
tree	*(struct)
)	O
-	O
1	int
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
y	short
>=	O
tlines	O
(	O
tree	*(struct)
)	O
)	O
{	O
tree_move_forward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
tlines	O
(	O
tree	*(struct)
)	O
-	O
1	int
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
else	O
{	O
tree_event	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
y	short
)	O
;	O
if	O
(	O
(	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
type	enum(int,int,int,int)
&	O
(	O
GPM_UP	int
|	O
GPM_DOUBLE	int
)	O
)	O
==	O
(	O
GPM_UP	int
|	O
GPM_DOUBLE	int
)	O
)	O
{	O
chdir_sel	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
}	O
return	O
MOU_NORMAL	int
;	O
}	O
static	O
int	O
search_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),*(char))->(int)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
char	O
*	O
text	*(char)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
;	O
int	O
len	int
;	O
int	O
wrapped	int
=	O
0	int
;	O
int	O
found	int
=	O
0	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
current	*(struct)
=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
found	int
=	O
0	int
;	O
while	O
(	O
!	O
wrapped	int
||	O
current	*(struct)
!=	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
subname	*(char)
,	O
text	*(char)
,	O
len	int
)	O
==	O
0	int
)	O
{	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
current	*(struct)
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
!	O
current	*(struct)
)	O
{	O
current	*(struct)
=	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
wrapped	int
=	O
1	int
;	O
}	O
tree	*(struct)
->	O
topdiff	int
++	O
;	O
}	O
check_focus	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
found	int
;	O
}	O
static	O
void	O
tree_do_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
int	O
key	*(void)
)	O
{	O
size_t	long
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
strlen	(*(char))->(long)
(	O
tree	*(struct)
->	O
search_buffer	array(char)
)	O
;	O
if	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
&&	O
(	O
key	*(void)
==	O
KEY_BACKSPACE	int
)	O
)	O
tree	*(struct)
->	O
search_buffer	array(char)
[	O
--	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
]	O
=	O
0	int
;	O
else	O
{	O
if	O
(	O
key	*(void)
&&	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
<	O
sizeof	O
(	O
tree	*(struct)
->	O
search_buffer	array(char)
)	O
)	O
{	O
tree	*(struct)
->	O
search_buffer	array(char)
[	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
]	O
=	O
key	*(void)
;	O
tree	*(struct)
->	O
search_buffer	array(char)
[	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
+	O
1	int
]	O
=	O
0	int
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
++	O
;	O
}	O
}	O
if	O
(	O
!	O
search_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),*(char))->(int)
(	O
tree	*(struct)
,	O
tree	*(struct)
->	O
search_buffer	array(char)
)	O
)	O
tree	*(struct)
->	O
search_buffer	array(char)
[	O
--	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
]	O
=	O
0	int
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
tree_rescan_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
char	O
old_dir	array(char)
[	O
MC_MAXPATHLEN	O
]	O
;	O
if	O
(	O
!	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
||	O
!	O
mc_get_current_wd	(*(char),int)->(*(char))
(	O
old_dir	array(char)
,	O
MC_MAXPATHLEN	O
)	O
||	O
mc_chdir	(*(char))->(int)
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
)	O
return	O
;	O
tree_store_rescan	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
mc_chdir	(*(char))->(int)
(	O
old_dir	array(char)
)	O
;	O
}	O
static	O
void	O
tree_forget_cmd	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
data	*(void)
;	O
if	O
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
tree_remove_entry	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),*(char))->(void)
(	O
tree	*(struct)
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
tree_copy	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),*(char))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
const	O
char	O
*	O
default_dest	*(char)
)	O
{	O
char	O
*	O
dest	*(int)
;	O
off_t	long
count	int
=	O
0	int
;	O
double	O
bytes	*(struct)
=	O
0	int
;	O
FileOpContext	struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))
*	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
;	O
if	O
(	O
!	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
return	O
;	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
cmd_buf	array(char)
,	O
sizeof	O
(	O
cmd_buf	array(char)
)	O
,	O
_	O
(	O
"Copy \"%s\" directory to:"	*(char)
)	O
,	O
name_trunc	(*(char),int)->(*(char))
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
50	int
)	O
)	O
;	O
dest	*(int)
=	O
input_expand_dialog	(*(char),*(char),*(char))->(*(char))
(	O
_	O
(	O
" Copy "	*(char)
)	O
,	O
cmd_buf	array(char)
,	O
default_dest	*(char)
)	O
;	O
if	O
(	O
!	O
dest	*(int)
)	O
return	O
;	O
if	O
(	O
!	O
*	O
dest	*(int)
)	O
{	O
g_free	(*(void))->(void)
(	O
dest	*(int)
)	O
;	O
return	O
;	O
}	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
=	O
file_op_context_new	(enum(int,int,int))->(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))))
(	O
OP_COPY	int
)	O
;	O
file_op_context_create_ui	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))),int)->(void)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
,	O
FALSE	O
)	O
;	O
copy_dir_dir	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))),*(char),*(char),int,int,int,*(struct),*(long),*(double))->(int)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
dest	*(int)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
count	int
,	O
&	O
bytes	*(struct)
)	O
;	O
file_op_context_destroy	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))))->(void)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
)	O
;	O
g_free	(*(void))->(void)
(	O
dest	*(int)
)	O
;	O
}	O
static	O
void	O
tree_help_cmd	()->(void)
(	O
void	O
)	O
{	O
interactive_display	(*(char),*(char))->(void)
(	O
NULL	O
,	O
"[Directory Tree]"	*(char)
)	O
;	O
}	O
static	O
void	O
tree_copy_cmd	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
data	*(void)
;	O
tree_copy	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),*(char))->(void)
(	O
tree	*(struct)
,	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
tree_move	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),*(char))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
,	O
const	O
char	O
*	O
default_dest	*(char)
)	O
{	O
char	O
*	O
dest	*(int)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
buf	*(char)
;	O
double	O
bytes	*(struct)
=	O
0	int
;	O
off_t	long
count	int
=	O
0	int
;	O
FileOpContext	struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))
*	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
;	O
if	O
(	O
!	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
return	O
;	O
g_snprintf	(*(char),long,*(char))->(int)
(	O
cmd_buf	array(char)
,	O
sizeof	O
(	O
cmd_buf	array(char)
)	O
,	O
_	O
(	O
"Move \"%s\" directory to:"	*(char)
)	O
,	O
name_trunc	(*(char),int)->(*(char))
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
50	int
)	O
)	O
;	O
dest	*(int)
=	O
input_expand_dialog	(*(char),*(char),*(char))->(*(char))
(	O
_	O
(	O
" Move "	*(char)
)	O
,	O
cmd_buf	array(char)
,	O
default_dest	*(char)
)	O
;	O
if	O
(	O
!	O
dest	*(int)
)	O
return	O
;	O
if	O
(	O
!	O
*	O
dest	*(int)
)	O
{	O
g_free	(*(void))->(void)
(	O
dest	*(int)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
dest	*(int)
,	O
&	O
buf	*(char)
)	O
)	O
{	O
message	*(char)
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot stat the destination \n %s "	*(char)
)	O
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
g_free	(*(void))->(void)
(	O
dest	*(int)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
buf	*(char)
.	O
st_mode	int
)	O
)	O
{	O
file_error	(*(char),*(char))->(int)
(	O
_	O
(	O
" Destination \"%s\" must be a directory \n %s "	*(char)
)	O
,	O
dest	*(int)
)	O
;	O
g_free	(*(void))->(void)
(	O
dest	*(int)
)	O
;	O
return	O
;	O
}	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
=	O
file_op_context_new	(enum(int,int,int))->(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))))
(	O
OP_MOVE	int
)	O
;	O
file_op_context_create_ui	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))),int)->(void)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
,	O
FALSE	O
)	O
;	O
move_dir_dir	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))),*(char),*(char),*(long),*(double))->(int)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
dest	*(int)
,	O
&	O
count	int
,	O
&	O
bytes	*(struct)
)	O
;	O
file_op_context_destroy	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))))->(void)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
)	O
;	O
g_free	(*(void))->(void)
(	O
dest	*(int)
)	O
;	O
}	O
static	O
void	O
tree_move_cmd	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
data	*(void)
;	O
tree_move	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),*(char))->(void)
(	O
tree	*(struct)
,	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
tree_rmdir_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
off_t	long
count	int
=	O
0	int
;	O
double	O
bytes	*(struct)
=	O
0	int
;	O
FileOpContext	struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))
*	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
;	O
if	O
(	O
!	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
return	O
;	O
if	O
(	O
confirm_delete	int
)	O
{	O
char	O
*	O
buf	*(char)
;	O
int	O
result	long
;	O
buf	*(char)
=	O
g_strdup_printf	(*(char))->(*(char))
(	O
_	O
(	O
"  Delete %s?  "	*(char)
)	O
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
result	long
=	O
query_dialog	(*(char),*(char),int,int)->(int)
(	O
_	O
(	O
" Delete "	*(char)
)	O
,	O
buf	*(char)
,	O
3	int
,	O
2	int
,	O
_	O
(	O
"&Yes"	*(char)
)	O
,	O
_	O
(	O
"&No"	*(char)
)	O
)	O
;	O
g_free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
;	O
}	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
=	O
file_op_context_new	(enum(int,int,int))->(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))))
(	O
OP_DELETE	int
)	O
;	O
file_op_context_create_ui	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))),int)->(void)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
,	O
FALSE	O
)	O
;	O
if	O
(	O
erase_dir	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))),*(char),*(long),*(double))->(int)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
&	O
count	int
,	O
&	O
bytes	*(struct)
)	O
==	O
FILE_CONT	int
)	O
tree_forget_cmd	(*(void))->(void)
(	O
tree	*(struct)
)	O
;	O
file_op_context_destroy	(*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*`,*`)->(int)),int,int,int,int,*(char),struct(*(struct`),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void))))->(void)
(	O
ctx	*(struct(enum(int,int,int),double,long,long,int,long,double,int,int,long,int,int,*((*(char),*(struct`))->(int)),int,int,int,int,*(char),struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int),struct(int,*(int),*(int)),int,int,int,*(void)))
)	O
;	O
}	O
static	O
void	O
set_navig_label	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
;	O
static	O
void	O
tree_toggle_navig	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
data	*(void)
;	O
tree_navigation_flag	int
=	O
1	int
-	O
tree_navigation_flag	int
;	O
set_navig_label	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
set_navig_label	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
buttonbar_set_label_data	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,*(char),*((*(void))->(void)),*(void))->(void)
(	O
tree	*(struct)
->	O
widget	*(struct)
.	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
4	int
,	O
tree_navigation_flag	int
?	O
_	O
(	O
"Static"	*(char)
)	O
:	O
_	O
(	O
"Dynamc"	*(char)
)	O
,	O
tree_toggle_navig	(*(void))->(void)
,	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
move_down	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_move_forward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
1	int
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
move_up	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_move_backward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
1	int
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
move_home	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_move_to_top	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
move_end	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_move_to_bottom	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
int	O
move_left	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(int)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
int	O
v	*(void)
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
v	*(void)
=	O
tree_move_to_parent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(int)
(	O
tree	*(struct)
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
v	*(void)
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
move_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(int)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
tree_move_to_child	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
move_prevp	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_move_backward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
tlines	O
(	O
tree	*(struct)
)	O
-	O
1	int
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
move_nextp	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
tree_move_forward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
tlines	O
(	O
tree	*(struct)
)	O
-	O
1	int
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
maybe_chdir	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
chdir_sel	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
if	O
(	O
!	O
tree	*(struct)
->	O
is_panel	int
)	O
{	O
return	O
;	O
}	O
change_panel	()->(void)
(	O
)	O
;	O
if	O
(	O
do_cd	(*(char),enum(int,int))->(int)
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
cd_exact	int
)	O
)	O
{	O
select_item	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),struct(*(struct`),int),int,int,array(char),array(char),*(struct(*`,*`,*`)),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*`,*`)->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char))))->(void)
(	O
current_panel	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),struct(*(struct(int,*`,struct`,struct`)),int),int,int,array(char),array(char),*(struct(*(void),*(struct`),*(struct`))),*(char),int,int,int,double,int,int,int,int,int,int,int,*((*(void),*(void))->(int)),*(char),int,int,*(char),array(*(char)),*(struct),*(struct),int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,array(char)))
)	O
;	O
}	O
else	O
{	O
message	*(char)
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot chdir to \"%s\" \n %s "	*(char)
)	O
,	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
change_panel	()->(void)
(	O
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
;	O
}	O
static	O
void	O
tree_start_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
tree	*(struct)
->	O
searching	int
)	O
{	O
if	O
(	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
==	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
->	O
tree_last	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
tree_move_to_top	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
else	O
{	O
i	array(int)
=	O
tree_navigation_flag	int
;	O
tree_navigation_flag	int
=	O
0	int
;	O
tree_move_forward	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
1	int
)	O
;	O
tree_navigation_flag	int
=	O
i	array(int)
;	O
}	O
tree_do_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
tree	*(struct)
->	O
searching	int
=	O
1	int
;	O
tree	*(struct)
->	O
search_buffer	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
typedef	O
void	O
(	O
*	O
tree_key_action	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),*(struct`),*(struct`),array(char),*(*`),int,int,int,int)))->(void))
)	O
(	O
WTree	struct
*	O
)	O
;	O
typedef	O
struct	O
{	O
int	O
key_code	int
;	O
tree_key_action	*((*(struct(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`),*(struct`),*(struct`),array(char),*(*`),int,int,int,int)))->(void))
fn	*(()->(void))
;	O
}	O
tree_key_map	struct(int,*((*(struct(struct`,*`,*`,array(char),*`,int,int,int,int)))->(void)))
;	O
static	O
const	O
tree_key_map	struct(int,*((*(struct(struct`,*`,*`,array(char),*`,int,int,int,int)))->(void)))
tree_keymap	array(struct(int,*((*(struct(struct`,*`,*`,array(char),*`,int,int,int,int)))->(void))))
[	O
]	O
=	O
{	O
{	O
XCTRL	O
(	O
'n'	O
)	O
,	O
move_down	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
move_up	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_DOWN	int
,	O
move_down	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_UP	int
,	O
move_up	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
'\n'	O
,	O
chdir_sel	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_ENTER	int
,	O
chdir_sel	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_HOME	int
,	O
move_home	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_A1	int
,	O
move_home	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
ALT	O
(	O
'<'	O
)	O
,	O
move_home	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_END	int
,	O
move_end	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_C1	int
,	O
move_end	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
ALT	O
(	O
'>'	O
)	O
,	O
move_end	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_NPAGE	int
,	O
move_nextp	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_PPAGE	int
,	O
move_prevp	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
XCTRL	O
(	O
'v'	O
)	O
,	O
move_nextp	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
ALT	O
(	O
'v'	O
)	O
,	O
move_prevp	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
move_up	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
move_down	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
XCTRL	O
(	O
's'	O
)	O
,	O
tree_start_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
ALT	O
(	O
's'	O
)	O
,	O
tree_start_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
XCTRL	O
(	O
'r'	O
)	O
,	O
tree_rescan_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
KEY_DC	int
,	O
tree_rmdir_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
inline	O
cb_ret_t	enum(int,int)
tree_key	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(enum(int,int))
(	O
WTree	struct
*	O
tree	*(struct)
,	O
int	O
key	*(void)
)	O
{	O
int	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
tree_keymap	array(struct(int,*((*(struct(struct`,*`,*`,array(char),*`,int,int,int,int)))->(void))))
[	O
i	array(int)
]	O
.	O
key_code	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
key	*(void)
==	O
tree_keymap	array(struct(int,*((*(struct(struct`,*`,*`,array(char),*`,int,int,int,int)))->(void))))
[	O
i	array(int)
]	O
.	O
key_code	int
)	O
{	O
if	O
(	O
tree_keymap	array(struct(int,*((*(struct(struct`,*`,*`,array(char),*`,int,int,int,int)))->(void))))
[	O
i	array(int)
]	O
.	O
fn	*(()->(void))
!=	O
tree_start_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
)	O
tree	*(struct)
->	O
searching	int
=	O
0	int
;	O
(	O
*	O
tree_keymap	array(struct(int,*((*(struct(struct`,*`,*`,array(char),*`,int,int,int,int)))->(void))))
[	O
i	array(int)
]	O
.	O
fn	*(()->(void))
)	O
(	O
tree	*(struct)
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
if	O
(	O
key	*(void)
==	O
KEY_LEFT	int
)	O
return	O
move_left	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(int)
(	O
tree	*(struct)
)	O
?	O
MSG_HANDLED	int
:	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
key	*(void)
==	O
KEY_RIGHT	int
)	O
return	O
move_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(int)
(	O
tree	*(struct)
)	O
?	O
MSG_HANDLED	int
:	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
is_abort_char	(int)->(int)
(	O
key	*(void)
)	O
)	O
{	O
if	O
(	O
tree	*(struct)
->	O
is_panel	int
)	O
{	O
tree	*(struct)
->	O
searching	int
=	O
0	int
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
if	O
(	O
(	O
key	*(void)
>=	O
' '	O
&&	O
key	*(void)
<=	O
255	int
)	O
||	O
key	*(void)
==	O
KEY_BACKSPACE	int
)	O
{	O
if	O
(	O
tree	*(struct)
->	O
searching	int
)	O
{	O
tree_do_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
key	*(void)
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
!	O
command_prompt	int
)	O
{	O
tree_start_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
tree_do_search	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(void)
(	O
tree	*(struct)
,	O
key	*(void)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
tree	*(struct)
->	O
is_panel	int
?	O
MSG_HANDLED	int
:	O
MSG_NOT_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
static	O
void	O
tree_frame	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
h	*(struct)
,	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
attrset	(int)->(void)
(	O
NORMAL_COLOR	O
)	O
;	O
widget_erase	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
(	O
Widget	struct
*	O
)	O
tree	*(struct)
)	O
;	O
if	O
(	O
tree	*(struct)
->	O
is_panel	int
)	O
draw_double_box	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,int,int,int)->(void)
(	O
h	*(struct)
,	O
tree	*(struct)
->	O
widget	*(struct)
.	O
y	short
,	O
tree	*(struct)
->	O
widget	*(struct)
.	O
x	array(long)
,	O
tree	*(struct)
->	O
widget	*(struct)
.	O
lines	*(int)
,	O
tree	*(struct)
->	O
widget	*(struct)
.	O
cols	int
)	O
;	O
if	O
(	O
show_mini_info	int
&&	O
tree	*(struct)
->	O
is_panel	int
)	O
{	O
widget_move	O
(	O
tree	*(struct)
,	O
tlines	O
(	O
tree	*(struct)
)	O
+	O
1	int
,	O
1	int
)	O
;	O
hline	(int,int)->(void)
(	O
ACS_HLINE	O
,	O
tree	*(struct)
->	O
widget	*(struct)
.	O
cols	int
-	O
2	int
)	O
;	O
}	O
}	O
static	O
void	O
tree_rescan_command	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
data	*(void)
;	O
tree_rescan_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
void	O
tree_rmdir_command	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
data	*(void)
;	O
tree_rmdir_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
}	O
static	O
cb_ret_t	enum(int,int)
tree_callback	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
Widget	struct
*	O
w	*(int)
,	O
widget_msg_t	enum(int,int,int,int,int,int,int,int,int,int)
msg	*(char)
,	O
int	O
parm	int
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
(	O
WTree	struct
*	O
)	O
w	*(int)
;	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
h	*(struct)
=	O
tree	*(struct)
->	O
widget	*(struct)
.	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
switch	O
(	O
msg	*(char)
)	O
{	O
case	O
WIDGET_DRAW	int
:	O
tree_frame	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
h	*(struct)
,	O
tree	*(struct)
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_KEY	int
:	O
return	O
tree_key	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)),int)->(enum(int,int))
(	O
tree	*(struct)
,	O
parm	int
)	O
;	O
case	O
WIDGET_FOCUS	int
:	O
tree	*(struct)
->	O
active	int
=	O
1	int
;	O
buttonbar_set_label	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,*(char),*(()->(void)))->(void)
(	O
h	*(struct)
,	O
1	int
,	O
_	O
(	O
"Help"	*(char)
)	O
,	O
tree_help_cmd	()->(void)
)	O
;	O
buttonbar_set_label_data	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,*(char),*((*(void))->(void)),*(void))->(void)
(	O
h	*(struct)
,	O
2	int
,	O
_	O
(	O
"Rescan"	*(char)
)	O
,	O
tree_rescan_command	(*(void))->(void)
,	O
tree	*(struct)
)	O
;	O
buttonbar_set_label_data	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,*(char),*((*(void))->(void)),*(void))->(void)
(	O
h	*(struct)
,	O
3	int
,	O
_	O
(	O
"Forget"	*(char)
)	O
,	O
tree_forget_cmd	(*(void))->(void)
,	O
tree	*(struct)
)	O
;	O
buttonbar_set_label_data	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,*(char),*((*(void))->(void)),*(void))->(void)
(	O
h	*(struct)
,	O
5	int
,	O
_	O
(	O
"Copy"	*(char)
)	O
,	O
tree_copy_cmd	(*(void))->(void)
,	O
tree	*(struct)
)	O
;	O
buttonbar_set_label_data	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,*(char),*((*(void))->(void)),*(void))->(void)
(	O
h	*(struct)
,	O
6	int
,	O
_	O
(	O
"RenMov"	*(char)
)	O
,	O
tree_move_cmd	(*(void))->(void)
,	O
tree	*(struct)
)	O
;	O
buttonbar_clear_label	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int)->(void)
(	O
h	*(struct)
,	O
7	int
)	O
;	O
buttonbar_set_label_data	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,*(char),*((*(void))->(void)),*(void))->(void)
(	O
h	*(struct)
,	O
8	int
,	O
_	O
(	O
"Rmdir"	*(char)
)	O
,	O
tree_rmdir_command	(*(void))->(void)
,	O
tree	*(struct)
)	O
;	O
set_navig_label	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
buttonbar_redraw	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
h	*(struct)
)	O
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_UNFOCUS	int
:	O
tree	*(struct)
->	O
active	int
=	O
0	int
;	O
show_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
tree_destroy	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	(enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
msg	*(char)
,	O
parm	int
)	O
;	O
}	O
}	O
WTree	struct
*	O
tree_new	(int,int,int,int,int)->(*(struct))
(	O
int	O
is_panel	int
,	O
int	O
y	short
,	O
int	O
x	array(long)
,	O
int	O
lines	*(int)
,	O
int	O
cols	int
)	O
{	O
WTree	struct
*	O
tree	*(struct)
=	O
g_new	O
(	O
WTree	struct
,	O
1	int
)	O
;	O
init_widget	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),int,int,int,int,*((*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))),*(void))->(int)))->(void)
(	O
&	O
tree	*(struct)
->	O
widget	*(struct)
,	O
y	short
,	O
x	array(long)
,	O
lines	*(int)
,	O
cols	int
,	O
tree_callback	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
,	O
event_callback	(*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))),*(void))->(int)
)	O
;	O
tree	*(struct)
->	O
is_panel	int
=	O
is_panel	int
;	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
0	int
;	O
tree	*(struct)
->	O
store	*(struct(*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(char),*(struct(*(void),*(struct`),*(struct`))),int,int))
=	O
tree_store_get	()->(*(struct(*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)),*(char),*(struct(*`,*`,*`)),int,int)))
(	O
)	O
;	O
tree_store_add_entry_remove_hook	(*((*(struct(*`,int,long,*`,int,int,*`,*`)),*(void))->(void)),*(void))->(void)
(	O
remove_callback	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(void))->(void)
,	O
tree	*(struct)
)	O
;	O
tree	*(struct)
->	O
tree_shown	*(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
=	O
0	int
;	O
tree	*(struct)
->	O
search_buffer	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
tree	*(struct)
->	O
topdiff	int
=	O
tree	*(struct)
->	O
widget	*(struct)
.	O
lines	*(int)
/	O
2	int
;	O
tree	*(struct)
->	O
searching	int
=	O
0	int
;	O
tree	*(struct)
->	O
active	int
=	O
0	int
;	O
widget_want_cursor	O
(	O
tree	*(struct)
->	O
widget	*(struct)
,	O
0	int
)	O
;	O
load_tree	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,*`,*`,*`,*`,int,int)),*(struct(*`,int,long,*`,int,int,*`,*`)),array(char),*(*(struct`)),int,int,int,int)))->(void)
(	O
tree	*(struct)
)	O
;	O
return	O
tree	*(struct)
;	O
}	O
char	O
*	O
tree_selected_name	(*(struct))->(*(char))
(	O
WTree	struct
*	O
tree	*(struct)
)	O
{	O
return	O
tree	*(struct)
->	O
selected_ptr	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
;	O
}	O
