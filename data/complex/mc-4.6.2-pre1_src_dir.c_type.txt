int	O
show_dot_files	int
=	O
1	int
;	O
int	O
show_backups	int
=	O
1	int
;	O
int	O
mix_all_files	int
=	O
0	int
;	O
static	O
int	O
reverse	int
=	O
1	int
;	O
static	O
int	O
case_sensitive	int
=	O
OS_SORT_CASE_SENSITIVE_DEFAULT	int
;	O
sort_orders_t	struct(*(char),*((*(struct(int,*`,struct`,struct`)),*(struct(int,*`,struct`,struct`)))->(int)))
sort_orders	array(struct(*(char),*((*(struct(int,*`,struct`,struct`)),*(struct(int,*`,struct`,struct`)))->(int))))
[	O
SORT_TYPES_TOTAL	O
]	O
=	O
{	O
{	O
N_	O
(	O
"&Unsorted"	*(char)
)	O
,	O
unsorted	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
}	O
,	O
{	O
N_	O
(	O
"&Name"	*(char)
)	O
,	O
sort_name	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
}	O
,	O
{	O
N_	O
(	O
"&Extension"	*(char)
)	O
,	O
sort_ext	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
}	O
,	O
{	O
N_	O
(	O
"&Modify time"	*(char)
)	O
,	O
sort_time	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
}	O
,	O
{	O
N_	O
(	O
"&Access time"	*(char)
)	O
,	O
sort_atime	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
}	O
,	O
{	O
N_	O
(	O
"C&Hange time"	*(char)
)	O
,	O
sort_ctime	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
}	O
,	O
{	O
N_	O
(	O
"&Size"	*(char)
)	O
,	O
sort_size	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
}	O
,	O
{	O
N_	O
(	O
"&Inode"	*(char)
)	O
,	O
sort_inode	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
}	O
,	O
}	O
;	O
typedef	O
enum	O
{	O
STRCOLL_NO	int
,	O
STRCOLL_YES	int
,	O
STRCOLL_TEST	int
}	O
strcoll_status	enum(int,int,int)
;	O
static	O
int	O
string_sortcomp	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
str1	*(char)
,	O
const	O
char	O
*	O
str2	*(char)
)	O
{	O
static	O
strcoll_status	enum(int,int,int)
use_strcoll	enum(int,int,int)
=	O
STRCOLL_TEST	int
;	O
if	O
(	O
case_sensitive	int
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
str1	*(char)
,	O
str2	*(char)
)	O
;	O
}	O
if	O
(	O
use_strcoll	enum(int,int,int)
==	O
STRCOLL_TEST	int
)	O
{	O
if	O
(	O
strcoll	(*(char),*(char))->(int)
(	O
"a"	*(char)
,	O
"B"	*(char)
)	O
*	O
strcoll	(*(char),*(char))->(int)
(	O
"B"	*(char)
,	O
"c"	*(char)
)	O
>	O
0	int
)	O
{	O
use_strcoll	enum(int,int,int)
=	O
STRCOLL_YES	int
;	O
}	O
else	O
{	O
use_strcoll	enum(int,int,int)
=	O
STRCOLL_NO	int
;	O
}	O
}	O
if	O
(	O
use_strcoll	enum(int,int,int)
==	O
STRCOLL_NO	int
)	O
return	O
g_strcasecmp	(*(char),*(char))->(int)
(	O
str1	*(char)
,	O
str2	*(char)
)	O
;	O
else	O
return	O
strcoll	(*(char),*(char))->(int)
(	O
str1	*(char)
,	O
str2	*(char)
)	O
;	O
}	O
int	O
unsorted	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
a	*(void)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
b	*(void)
)	O
{	O
(	O
void	O
)	O
a	*(void)
;	O
(	O
void	O
)	O
b	*(void)
;	O
return	O
0	int
;	O
}	O
int	O
sort_name	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
a	*(void)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
b	*(void)
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	*(void)
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	*(void)
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
return	O
string_sortcomp	(*(char),*(char))->(int)
(	O
a	*(void)
->	O
fname	*(char)
,	O
b	*(void)
->	O
fname	*(char)
)	O
*	O
reverse	int
;	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_ext	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
a	*(void)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
b	*(void)
)	O
{	O
const	O
char	O
*	O
exta	*(char)
,	O
*	O
extb	*(char)
;	O
int	O
r	*(struct)
;	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	*(void)
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	*(void)
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
{	O
exta	*(char)
=	O
extension	(*(char))->(*(char))
(	O
a	*(void)
->	O
fname	*(char)
)	O
;	O
extb	*(char)
=	O
extension	(*(char))->(*(char))
(	O
b	*(void)
->	O
fname	*(char)
)	O
;	O
r	*(struct)
=	O
string_sortcomp	(*(char),*(char))->(int)
(	O
exta	*(char)
,	O
extb	*(char)
)	O
;	O
if	O
(	O
r	*(struct)
)	O
return	O
r	*(struct)
*	O
reverse	int
;	O
else	O
return	O
sort_name	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
a	*(void)
,	O
b	*(void)
)	O
;	O
}	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_time	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
a	*(void)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
b	*(void)
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	*(void)
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	*(void)
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
{	O
int	O
result	long
=	O
a	*(void)
->	O
st	*(struct)
.	O
st_mtime	O
<	O
b	*(void)
->	O
st	*(struct)
.	O
st_mtime	O
?	O
-	O
1	int
:	O
a	*(void)
->	O
st	*(struct)
.	O
st_mtime	O
>	O
b	*(void)
->	O
st	*(struct)
.	O
st_mtime	O
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
result	long
*	O
reverse	int
;	O
else	O
return	O
sort_name	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
a	*(void)
,	O
b	*(void)
)	O
;	O
}	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_ctime	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
a	*(void)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
b	*(void)
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	*(void)
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	*(void)
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
{	O
int	O
result	long
=	O
a	*(void)
->	O
st	*(struct)
.	O
st_ctime	O
<	O
b	*(void)
->	O
st	*(struct)
.	O
st_ctime	O
?	O
-	O
1	int
:	O
a	*(void)
->	O
st	*(struct)
.	O
st_ctime	O
>	O
b	*(void)
->	O
st	*(struct)
.	O
st_ctime	O
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
result	long
*	O
reverse	int
;	O
else	O
return	O
sort_name	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
a	*(void)
,	O
b	*(void)
)	O
;	O
}	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_atime	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
a	*(void)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
b	*(void)
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	*(void)
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	*(void)
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
{	O
int	O
result	long
=	O
a	*(void)
->	O
st	*(struct)
.	O
st_atime	O
<	O
b	*(void)
->	O
st	*(struct)
.	O
st_atime	O
?	O
-	O
1	int
:	O
a	*(void)
->	O
st	*(struct)
.	O
st_atime	O
>	O
b	*(void)
->	O
st	*(struct)
.	O
st_atime	O
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
result	long
*	O
reverse	int
;	O
else	O
return	O
sort_name	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
a	*(void)
,	O
b	*(void)
)	O
;	O
}	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_inode	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
a	*(void)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
b	*(void)
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	*(void)
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	*(void)
)	O
;	O
if	O
(	O
ad	int
==	O
bd	int
||	O
mix_all_files	int
)	O
return	O
(	O
a	*(void)
->	O
st	*(struct)
.	O
st_ino	long
-	O
b	*(void)
->	O
st	*(struct)
.	O
st_ino	long
)	O
*	O
reverse	int
;	O
else	O
return	O
bd	int
-	O
ad	int
;	O
}	O
int	O
sort_size	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
a	*(void)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
b	*(void)
)	O
{	O
int	O
ad	int
=	O
MY_ISDIR	O
(	O
a	*(void)
)	O
;	O
int	O
bd	int
=	O
MY_ISDIR	O
(	O
b	*(void)
)	O
;	O
int	O
result	long
=	O
0	int
;	O
if	O
(	O
ad	int
!=	O
bd	int
&&	O
!	O
mix_all_files	int
)	O
return	O
bd	int
-	O
ad	int
;	O
result	long
=	O
a	*(void)
->	O
st	*(struct)
.	O
st_size	long
<	O
b	*(void)
->	O
st	*(struct)
.	O
st_size	long
?	O
-	O
1	int
:	O
a	*(void)
->	O
st	*(struct)
.	O
st_size	long
>	O
b	*(void)
->	O
st	*(struct)
.	O
st_size	long
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
result	long
*	O
reverse	int
;	O
else	O
return	O
sort_name	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
a	*(void)
,	O
b	*(void)
)	O
;	O
}	O
void	O
do_sort	(*(struct(*(struct(int,*`,struct`,struct`)),int)),*((*(void),*(void))->(int)),int,int,int)->(void)
(	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
sortfn	(*(void),*(void))->(int)
*	O
sort	*((*(void),*(void))->(int))
,	O
int	O
top	*(char)
,	O
int	O
reverse_f	int
,	O
int	O
case_sensitive_f	int
)	O
{	O
int	O
dot_dot_found	int
=	O
0	int
;	O
if	O
(	O
top	*(char)
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
0	int
]	O
.	O
fname	*(char)
,	O
".."	*(char)
)	O
)	O
dot_dot_found	int
=	O
1	int
;	O
reverse	int
=	O
reverse_f	int
?	O
-	O
1	int
:	O
1	int
;	O
case_sensitive	int
=	O
case_sensitive_f	int
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
&	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
dot_dot_found	int
]	O
,	O
top	*(char)
+	O
1	int
-	O
dot_dot_found	int
,	O
sizeof	O
(	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
)	O
,	O
sort	*((*(void),*(void))->(int))
)	O
;	O
}	O
void	O
clean_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)),int)->(void)
(	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
int	O
count	int
)	O
{	O
int	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
count	int
;	O
i	array(int)
++	O
)	O
{	O
g_free	(*(void))->(void)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fname	*(char)
)	O
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fname	*(char)
=	O
0	int
;	O
}	O
}	O
static	O
int	O
add_dotdot_to_list	(*(struct(*(struct(int,*`,struct`,struct`)),int)),int)->(int)
(	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
int	O
index	(*(char),int)->(*(char))
)	O
{	O
if	O
(	O
index	(*(char),int)->(*(char))
==	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
)	O
{	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_realloc	(*(void),long)->(*(void))
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
sizeof	O
(	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
)	O
*	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
+	O
RESIZE_STEPS	int
)	O
)	O
;	O
if	O
(	O
!	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
return	O
0	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
+=	O
RESIZE_STEPS	int
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
index	(*(char),int)->(*(char))
]	O
,	O
0	int
,	O
sizeof	O
(	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
)	O
)	O
;	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
index	(*(char),int)->(*(char))
]	O
.	O
fnamelen	int
=	O
2	int
;	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
index	(*(char),int)->(*(char))
]	O
.	O
fname	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
".."	*(char)
)	O
;	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
index	(*(char),int)->(*(char))
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
0	int
;	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
index	(*(char),int)->(*(char))
]	O
.	O
f	float
.	O
stale_link	int
=	O
0	int
;	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
index	(*(char),int)->(*(char))
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
0	int
;	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
index	(*(char),int)->(*(char))
]	O
.	O
f	float
.	O
marked	int
=	O
0	int
;	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
[	O
index	(*(char),int)->(*(char))
]	O
.	O
st	*(struct)
.	O
st_mode	int
=	O
040755	int
;	O
return	O
1	int
;	O
}	O
int	O
set_zero_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)))->(int)
(	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
{	O
return	O
(	O
add_dotdot_to_list	(*(struct(*(struct(int,*`,struct`,struct`)),int)),int)->(int)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
handle_dirent	(*(struct(*(struct(int,*`,struct`,struct`)),int)),*(char),*(struct(long,long,short,char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,*(int),*(int))->(int)
(	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
const	O
char	O
*	O
filter	*(char)
,	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
int	O
next_free	int
,	O
int	O
*	O
link_to_dir	int
,	O
int	O
*	O
stale_link	int
)	O
{	O
if	O
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
2	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
show_dot_files	int
&&	O
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
show_backups	int
&&	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
NLENGTH	O
(	O
dp	*(struct(long,long,short,char,array(char)))
)	O
-	O
1	int
]	O
==	O
'~'	O
)	O
return	O
0	int
;	O
if	O
(	O
mc_lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
-	O
1	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
0	int
,	O
sizeof	O
(	O
*	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
)	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
tree_store_mark_checked	(*(char))->(void)
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
*	O
link_to_dir	int
=	O
0	int
;	O
*	O
stale_link	int
=	O
0	int
;	O
if	O
(	O
S_ISLNK	O
(	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
buf2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
&	O
buf2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
*	O
link_to_dir	int
=	O
S_ISDIR	O
(	O
buf2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
!=	O
0	int
;	O
else	O
*	O
stale_link	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
S_ISDIR	O
(	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
||	O
*	O
link_to_dir	int
)	O
&&	O
filter	*(char)
&&	O
!	O
regexp_match	(*(char),*(char),int)->(int)
(	O
filter	*(char)
,	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
match_file	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
next_free	int
==	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
)	O
{	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_realloc	(*(void),long)->(*(void))
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
sizeof	O
(	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
)	O
*	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
+	O
RESIZE_STEPS	int
)	O
)	O
;	O
if	O
(	O
!	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
return	O
-	O
1	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
+=	O
RESIZE_STEPS	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
handle_path	(*(struct(*(struct(int,*`,struct`,struct`)),int)),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,*(int),*(int))->(int)
(	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
const	O
char	O
*	O
path	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
int	O
next_free	int
,	O
int	O
*	O
link_to_dir	int
,	O
int	O
*	O
stale_link	int
)	O
{	O
if	O
(	O
path	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
path	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
path	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
path	*(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
path	*(char)
[	O
2	int
]	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
mc_lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
path	*(char)
,	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
S_ISDIR	O
(	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
tree_store_mark_checked	(*(char))->(void)
(	O
path	*(char)
)	O
;	O
*	O
link_to_dir	int
=	O
0	int
;	O
*	O
stale_link	int
=	O
0	int
;	O
if	O
(	O
S_ISLNK	O
(	O
buf1	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
buf2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
path	*(char)
,	O
&	O
buf2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
*	O
link_to_dir	int
=	O
S_ISDIR	O
(	O
buf2	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
!=	O
0	int
;	O
else	O
*	O
stale_link	int
=	O
1	int
;	O
}	O
if	O
(	O
next_free	int
==	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
)	O
{	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_realloc	(*(void),long)->(*(void))
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
sizeof	O
(	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
)	O
*	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
+	O
RESIZE_STEPS	int
)	O
)	O
;	O
if	O
(	O
!	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
return	O
-	O
1	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
+=	O
RESIZE_STEPS	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
do_load_dir	(*(char),*(struct(*(struct(int,*`,struct`,struct`)),int)),*((*(void),*(void))->(int)),int,int,*(char))->(int)
(	O
const	O
char	O
*	O
path	*(char)
,	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
sortfn	(*(void),*(void))->(int)
*	O
sort	*((*(void),*(void))->(int))
,	O
int	O
reverse	int
,	O
int	O
case_sensitive	int
,	O
const	O
char	O
*	O
filter	*(char)
)	O
{	O
DIR	struct
*	O
dirp	*(struct)
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
;	O
int	O
status	int
,	O
link_to_dir	int
,	O
stale_link	int
;	O
int	O
next_free	int
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct)
;	O
if	O
(	O
set_zero_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)))->(int)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
==	O
0	int
)	O
return	O
next_free	int
;	O
next_free	int
++	O
;	O
dirp	*(struct)
=	O
mc_opendir	(*(char))->(*(struct))
(	O
path	*(char)
)	O
;	O
if	O
(	O
!	O
dirp	*(struct)
)	O
{	O
message	*(char)
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot read directory contents"	*(char)
)	O
)	O
;	O
return	O
next_free	int
;	O
}	O
tree_store_start_check	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
path	*(char)
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
"/"	*(char)
)	O
)	O
next_free	int
--	O
;	O
while	O
(	O
(	O
dp	*(struct(long,long,short,char,array(char)))
=	O
mc_readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
)	O
)	O
{	O
status	int
=	O
handle_dirent	(*(struct(*(struct(int,*`,struct`,struct`)),int)),*(char),*(struct(long,long,short,char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,*(int),*(int))->(int)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
filter	*(char)
,	O
dp	*(struct(long,long,short,char,array(char)))
,	O
&	O
st	*(struct)
,	O
next_free	int
,	O
&	O
link_to_dir	int
,	O
&	O
stale_link	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
{	O
tree_store_end_check	()->(void)
(	O
)	O
;	O
mc_closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
return	O
next_free	int
;	O
}	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
fnamelen	int
=	O
NLENGTH	O
(	O
dp	*(struct(long,long,short,char,array(char)))
)	O
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
fname	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
marked	int
=	O
0	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
link_to_dir	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
stale_link	int
=	O
stale_link	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
0	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
st	*(struct)
=	O
st	*(struct)
;	O
next_free	int
++	O
;	O
if	O
(	O
!	O
(	O
next_free	int
%	O
32	int
)	O
)	O
rotate_dash	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
next_free	int
)	O
{	O
do_sort	(*(struct(*(struct(int,*`,struct`,struct`)),int)),*((*(void),*(void))->(int)),int,int,int)->(void)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
sort	*((*(void),*(void))->(int))
,	O
next_free	int
-	O
1	int
,	O
reverse	int
,	O
case_sensitive	int
)	O
;	O
}	O
mc_closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
tree_store_end_check	()->(void)
(	O
)	O
;	O
return	O
next_free	int
;	O
}	O
int	O
link_isdir	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
file	*(char)
)	O
{	O
if	O
(	O
file	*(char)
->	O
f	float
.	O
link_to_dir	int
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
if_link_is_exe	(*(char),*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))))->(int)
(	O
const	O
char	O
*	O
full_name	*(char)
,	O
const	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
*	O
file	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
b	*(void)
;	O
if	O
(	O
S_ISLNK	O
(	O
file	*(char)
->	O
st	*(struct)
.	O
st_mode	int
)	O
&&	O
!	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
full_name	*(char)
,	O
&	O
b	*(void)
)	O
)	O
{	O
return	O
is_exe	(int)->(int)
(	O
b	*(void)
.	O
st_mode	int
)	O
;	O
}	O
else	O
return	O
1	int
;	O
}	O
static	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
=	O
{	O
0	int
,	O
0	int
}	O
;	O
static	O
void	O
alloc_dir_copy	(int)->(void)
(	O
int	O
size	long
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
size	long
<	O
size	long
)	O
{	O
if	O
(	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
size	long
;	O
i	array(int)
++	O
)	O
{	O
g_free	(*(void))->(void)
(	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fname	*(char)
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
;	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
0	int
;	O
}	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_new	O
(	O
file_entry	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))
,	O
size	long
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
size	long
;	O
i	array(int)
++	O
)	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fname	*(char)
=	O
0	int
;	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
size	long
=	O
size	long
;	O
}	O
}	O
int	O
do_reload_dir	(*(char),*(struct(*(struct(int,*`,struct`,struct`)),int)),*((*(void),*(void))->(int)),int,int,int,*(char))->(int)
(	O
const	O
char	O
*	O
path	*(char)
,	O
dir_list	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
*	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
sortfn	(*(void),*(void))->(int)
*	O
sort	*((*(void),*(void))->(int))
,	O
int	O
count	int
,	O
int	O
rev	int
,	O
int	O
case_sensitive	int
,	O
const	O
char	O
*	O
filter	*(char)
)	O
{	O
DIR	struct
*	O
dirp	*(struct)
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
;	O
int	O
next_free	int
=	O
0	int
;	O
int	O
i	array(int)
,	O
status	int
,	O
link_to_dir	int
,	O
stale_link	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct)
;	O
int	O
marked_cnt	int
;	O
GHashTable	struct
*	O
marked_files	*(struct)
;	O
dirp	*(struct)
=	O
mc_opendir	(*(char))->(*(struct))
(	O
path	*(char)
)	O
;	O
if	O
(	O
!	O
dirp	*(struct)
)	O
{	O
message	*(char)
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot read directory contents"	*(char)
)	O
)	O
;	O
clean_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)),int)->(void)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
count	int
)	O
;	O
return	O
set_zero_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)))->(int)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
;	O
}	O
tree_store_start_check	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
path	*(char)
)	O
;	O
marked_files	*(struct)
=	O
g_hash_table_new	(*((*(void))->(int)),*((*(void),*(void))->(int)))->(*(struct))
(	O
g_str_hash	(*(void))->(int)
,	O
g_str_equal	(*(void),*(void))->(int)
)	O
;	O
alloc_dir_copy	(int)->(void)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
size	long
)	O
;	O
for	O
(	O
marked_cnt	int
=	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
count	int
;	O
i	array(int)
++	O
)	O
{	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fnamelen	int
=	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fnamelen	int
;	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fname	*(char)
=	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fname	*(char)
;	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
marked	int
=	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
marked	int
;	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
dir_size_computed	int
;	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
link_to_dir	int
;	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
stale_link	int
=	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
stale_link	int
;	O
if	O
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
f	float
.	O
marked	int
)	O
{	O
g_hash_table_insert	(*(struct),*(void),*(void))->(int)
(	O
marked_files	*(struct)
,	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
.	O
fname	*(char)
,	O
&	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
.	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
)	O
;	O
marked_cnt	int
++	O
;	O
}	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
path	*(char)
,	O
"/"	*(char)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
set_zero_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)))->(int)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
==	O
0	int
)	O
{	O
clean_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)),int)->(void)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
count	int
)	O
;	O
clean_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)),int)->(void)
(	O
&	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
,	O
count	int
)	O
;	O
return	O
next_free	int
;	O
}	O
next_free	int
++	O
;	O
}	O
while	O
(	O
(	O
dp	*(struct(long,long,short,char,array(char)))
=	O
mc_readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
)	O
)	O
{	O
status	int
=	O
handle_dirent	(*(struct(*(struct(int,*`,struct`,struct`)),int)),*(char),*(struct(long,long,short,char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int,*(int),*(int))->(int)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
filter	*(char)
,	O
dp	*(struct(long,long,short,char,array(char)))
,	O
&	O
st	*(struct)
,	O
next_free	int
,	O
&	O
link_to_dir	int
,	O
&	O
stale_link	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
{	O
mc_closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
tree_store_end_check	()->(void)
(	O
)	O
;	O
g_hash_table_destroy	(*(struct))->(void)
(	O
marked_files	*(struct)
)	O
;	O
return	O
next_free	int
;	O
}	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
marked	int
=	O
0	int
;	O
if	O
(	O
marked_cnt	int
>	O
0	int
)	O
{	O
if	O
(	O
(	O
g_hash_table_lookup	(*(struct),*(void))->(*(void))
(	O
marked_files	*(struct)
,	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
)	O
)	O
{	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
marked	int
=	O
1	int
;	O
marked_cnt	int
--	O
;	O
}	O
}	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
fnamelen	int
=	O
NLENGTH	O
(	O
dp	*(struct(long,long,short,char,array(char)))
)	O
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
fname	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
link_to_dir	int
=	O
link_to_dir	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
stale_link	int
=	O
stale_link	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
0	int
;	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
[	O
next_free	int
]	O
.	O
st	*(struct)
=	O
st	*(struct)
;	O
next_free	int
++	O
;	O
if	O
(	O
!	O
(	O
next_free	int
%	O
16	int
)	O
)	O
rotate_dash	()->(void)
(	O
)	O
;	O
}	O
mc_closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
tree_store_end_check	()->(void)
(	O
)	O
;	O
g_hash_table_destroy	(*(struct))->(void)
(	O
marked_files	*(struct)
)	O
;	O
if	O
(	O
next_free	int
)	O
{	O
do_sort	(*(struct(*(struct(int,*`,struct`,struct`)),int)),*((*(void),*(void))->(int)),int,int,int)->(void)
(	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
sort	*((*(void),*(void))->(int))
,	O
next_free	int
-	O
1	int
,	O
rev	int
,	O
case_sensitive	int
)	O
;	O
}	O
clean_dir	(*(struct(*(struct(int,*`,struct`,struct`)),int)),int)->(void)
(	O
&	O
dir_copy	struct(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),struct(int,int,int,int))),int)
,	O
count	int
)	O
;	O
return	O
next_free	int
;	O
}	O
