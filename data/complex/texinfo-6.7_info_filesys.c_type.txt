static	O
char	O
*	O
info_file_in_path	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
char	O
*	O
filename	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
char	O
*	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
char	O
*	O
dirname	*(char)
,	O
char	O
*	O
fname	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
static	O
char	O
*	O
filesys_read_compressed	(*(char),*(long))->(*(char))
(	O
char	O
*	O
pathname	*(char)
,	O
size_t	long
*	O
filesize	*(long)
)	O
;	O
static	O
char	O
*	O
filesys_decompressor_for_file	(*(char))->(*(char))
(	O
char	O
*	O
filename	*(char)
)	O
;	O
static	O
int	O
compressed_filename_p	(*(char))->(int)
(	O
char	O
*	O
filename	*(char)
)	O
;	O
typedef	O
struct	O
{	O
char	O
*	O
suffix	*(char)
;	O
char	O
*	O
decompressor	*(char)
;	O
}	O
COMPRESSION_ALIST	struct(*(char),*(char))
;	O
static	O
char	O
*	O
info_suffixes	array(*(char))
[	O
]	O
=	O
{	O
".info"	*(char)
,	O
"-info"	*(char)
,	O
"/index"	*(char)
,	O
".inf"	*(char)
,	O
""	*(char)
,	O
NULL	O
}	O
;	O
static	O
COMPRESSION_ALIST	struct(*(char),*(char))
compress_suffixes	array(struct(*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
".gz"	*(char)
,	O
"gzip -d"	*(char)
}	O
,	O
{	O
".lz"	*(char)
,	O
"lzip -d"	*(char)
}	O
,	O
{	O
".xz"	*(char)
,	O
"unxz"	*(char)
}	O
,	O
{	O
".bz2"	*(char)
,	O
"bunzip2"	*(char)
}	O
,	O
{	O
".z"	*(char)
,	O
"gunzip"	*(char)
}	O
,	O
{	O
".lzma"	*(char)
,	O
"unlzma"	*(char)
}	O
,	O
{	O
".Z"	*(char)
,	O
"uncompress"	*(char)
}	O
,	O
{	O
".Y"	*(char)
,	O
"unyabba"	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
char	O
*	O
info_find_fullpath	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
char	O
*	O
partial	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
char	O
*	O
fullpath	*(char)
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"looking for file \"%s\""	*(char)
)	O
,	O
partial	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
&	O
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
filesys_error_number	int
=	O
0	int
;	O
if	O
(	O
!	O
partial	*(char)
||	O
!	O
*	O
partial	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
IS_ABSOLUTE	O
(	O
partial	*(char)
)	O
||	O
partial	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
IS_SLASH	O
(	O
partial	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
fullpath	*(char)
=	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
0	int
,	O
partial	*(char)
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
}	O
else	O
if	O
(	O
partial	*(char)
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
partial	*(char)
=	O
tilde_expand_word	(*(char))->(*(char))
(	O
partial	*(char)
)	O
;	O
fullpath	*(char)
=	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
0	int
,	O
partial	*(char)
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
}	O
else	O
fullpath	*(char)
=	O
info_file_in_path	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
partial	*(char)
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
if	O
(	O
!	O
fullpath	*(char)
)	O
filesys_error_number	int
=	O
ENOENT	int
;	O
return	O
fullpath	*(char)
;	O
}	O
char	O
*	O
info_file_find_next_in_path	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
char	O
*	O
filename	*(char)
,	O
int	O
*	O
path_index	*(int)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
&	O
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
*	O
filename	*(char)
||	O
STREQ	O
(	O
filename	*(char)
,	O
"."	*(char)
)	O
||	O
STREQ	O
(	O
filename	*(char)
,	O
".."	*(char)
)	O
)	O
return	O
NULL	O
;	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
dirname	*(char)
,	O
*	O
with_extension	*(char)
=	O
0	int
;	O
dirname	*(char)
=	O
infopath_next	(*(int))->(*(char))
(	O
path_index	*(int)
)	O
;	O
if	O
(	O
!	O
dirname	*(char)
)	O
break	O
;	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"looking for file %s in %s"	*(char)
)	O
,	O
filename	*(char)
,	O
dirname	*(char)
)	O
)	O
;	O
if	O
(	O
*	O
dirname	*(char)
==	O
'~'	O
)	O
{	O
char	O
*	O
expanded_dirname	*(char)
=	O
tilde_expand_word	(*(char))->(*(char))
(	O
dirname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
dirname	*(char)
)	O
;	O
dirname	*(char)
=	O
expanded_dirname	*(char)
;	O
}	O
with_extension	*(char)
=	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
dirname	*(char)
,	O
filename	*(char)
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
if	O
(	O
with_extension	*(char)
)	O
{	O
if	O
(	O
!	O
IS_ABSOLUTE	O
(	O
with_extension	*(char)
)	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
s	*(char)
,	O
"%s%s"	*(char)
,	O
"./"	*(char)
,	O
with_extension	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
with_extension	*(char)
)	O
;	O
return	O
s	*(char)
;	O
}	O
else	O
return	O
with_extension	*(char)
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
info_file_in_path	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
char	O
*	O
filename	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
int	O
i	int
=	O
0	int
;	O
return	O
info_file_find_next_in_path	(*(char),*(int),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
filename	*(char)
,	O
&	O
i	int
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
}	O
char	O
*	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
char	O
*	O
dirname	*(char)
,	O
char	O
*	O
filename	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
char	O
*	O
try_filename	*(char)
;	O
register	O
int	O
i	int
,	O
pre_suffix_length	int
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
&	O
dummy	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
dirname	*(char)
)	O
pre_suffix_length	int
+=	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
;	O
pre_suffix_length	int
+=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
try_filename	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
pre_suffix_length	int
+	O
30	int
)	O
;	O
try_filename	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
dirname	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
try_filename	*(char)
,	O
dirname	*(char)
)	O
;	O
if	O
(	O
!	O
IS_SLASH	O
(	O
try_filename	*(char)
[	O
(	O
strlen	(*(char))->(long)
(	O
try_filename	*(char)
)	O
)	O
-	O
1	int
]	O
)	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
try_filename	*(char)
,	O
"/"	*(char)
)	O
;	O
pre_suffix_length	int
++	O
;	O
}	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
try_filename	*(char)
,	O
filename	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
info_suffixes	array(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
int	O
statable	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
try_filename	*(char)
+	O
pre_suffix_length	int
,	O
info_suffixes	array(*(char))
[	O
i	int
]	O
)	O
;	O
statable	int
=	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
try_filename	*(char)
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
0	int
)	O
;	O
if	O
(	O
statable	int
)	O
{	O
if	O
(	O
S_ISREG	O
(	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
{	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"found file %s"	*(char)
)	O
,	O
try_filename	*(char)
)	O
)	O
;	O
return	O
try_filename	*(char)
;	O
}	O
else	O
if	O
(	O
S_ISDIR	O
(	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
{	O
char	O
*	O
newpath	*(char)
,	O
*	O
new_filename	*(char)
;	O
newpath	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
try_filename	*(char)
)	O
;	O
new_filename	*(char)
=	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
newpath	*(char)
,	O
filename	*(char)
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
free	(*(void))->(void)
(	O
newpath	*(char)
)	O
;	O
if	O
(	O
new_filename	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
try_filename	*(char)
)	O
;	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"found file %s"	*(char)
)	O
,	O
new_filename	*(char)
)	O
)	O
;	O
return	O
new_filename	*(char)
;	O
}	O
}	O
}	O
else	O
{	O
register	O
int	O
j	int
,	O
pre_compress_suffix_length	int
;	O
pre_compress_suffix_length	int
=	O
strlen	(*(char))->(long)
(	O
try_filename	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
compress_suffixes	array(struct(*(char),*(char)))
[	O
j	int
]	O
.	O
suffix	*(char)
;	O
j	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
try_filename	*(char)
+	O
pre_compress_suffix_length	int
,	O
compress_suffixes	array(struct(*(char),*(char)))
[	O
j	int
]	O
.	O
suffix	*(char)
)	O
;	O
statable	int
=	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
try_filename	*(char)
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
0	int
)	O
;	O
if	O
(	O
statable	int
&&	O
(	O
S_ISREG	O
(	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
)	O
{	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"found file %s"	*(char)
)	O
,	O
try_filename	*(char)
)	O
)	O
;	O
return	O
try_filename	*(char)
;	O
}	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
try_filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
filesys_read_info_file	(*(char),*(long),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(int))->(*(char))
(	O
char	O
*	O
pathname	*(char)
,	O
size_t	long
*	O
filesize	*(long)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
int	O
*	O
is_compressed	*(int)
)	O
{	O
size_t	long
fsize	long
;	O
char	O
*	O
contents	*(char)
;	O
fsize	long
=	O
filesys_error_number	int
=	O
0	int
;	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
pathname	*(char)
,	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
fsize	long
=	O
(	O
long	O
)	O
finfo	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
;	O
if	O
(	O
compressed_filename_p	(*(char))->(int)
(	O
pathname	*(char)
)	O
)	O
{	O
*	O
is_compressed	*(int)
=	O
1	int
;	O
contents	*(char)
=	O
filesys_read_compressed	(*(char),*(long))->(*(char))
(	O
pathname	*(char)
,	O
&	O
fsize	long
)	O
;	O
}	O
else	O
{	O
int	O
descriptor	int
;	O
*	O
is_compressed	*(int)
=	O
0	int
;	O
descriptor	int
=	O
open	(*(char),int)->(int)
(	O
pathname	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0666	int
)	O
;	O
if	O
(	O
descriptor	int
<	O
0	int
)	O
{	O
filesys_error_number	int
=	O
errno	O
;	O
return	O
NULL	O
;	O
}	O
contents	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
fsize	long
)	O
;	O
if	O
(	O
(	O
read	*((*(void),*(char),long)->(long))
(	O
descriptor	int
,	O
contents	*(char)
,	O
fsize	long
)	O
)	O
!=	O
fsize	long
)	O
{	O
filesys_error_number	int
=	O
errno	O
;	O
close	*((*(void))->(int))
(	O
descriptor	int
)	O
;	O
free	(*(void))->(void)
(	O
contents	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
contents	*(char)
[	O
fsize	long
]	O
=	O
0	int
;	O
close	*((*(void))->(int))
(	O
descriptor	int
)	O
;	O
}	O
*	O
filesize	*(long)
=	O
fsize	long
;	O
return	O
contents	*(char)
;	O
}	O
static	O
char	O
*	O
filesys_read_compressed	(*(char),*(long))->(*(char))
(	O
char	O
*	O
pathname	*(char)
,	O
size_t	long
*	O
filesize	*(long)
)	O
{	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
command	*(char)
,	O
*	O
decompressor	*(char)
;	O
char	O
*	O
contents	*(char)
=	O
NULL	O
;	O
*	O
filesize	*(long)
=	O
filesys_error_number	int
=	O
0	int
;	O
decompressor	*(char)
=	O
filesys_decompressor_for_file	(*(char))->(*(char))
(	O
pathname	*(char)
)	O
;	O
if	O
(	O
!	O
decompressor	*(char)
)	O
return	O
NULL	O
;	O
command	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
15	int
+	O
strlen	(*(char))->(long)
(	O
pathname	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
decompressor	*(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
command	*(char)
,	O
"%s%s < %s"	*(char)
,	O
decompressor	*(char)
,	O
STRIP_DOT_EXE	int
?	O
".exe"	*(char)
:	O
""	*(char)
,	O
pathname	*(char)
)	O
;	O
if	O
(	O
info_windows_initialized_p	int
)	O
{	O
char	O
*	O
temp	*(char)
;	O
temp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
5	int
+	O
strlen	(*(char))->(long)
(	O
command	*(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
temp	*(char)
,	O
"%s..."	*(char)
,	O
command	*(char)
)	O
;	O
message_in_echo_area	(*(char))->(void)
(	O
"%s"	*(char)
,	O
temp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
temp	*(char)
)	O
;	O
}	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
command	*(char)
,	O
FOPEN_RBIN	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
command	*(char)
)	O
;	O
if	O
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
size_t	long
offset	long
,	O
size	long
;	O
char	O
*	O
chunk	*(char)
;	O
offset	long
=	O
size	long
=	O
0	int
;	O
chunk	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
FILESYS_PIPE_BUFFER_SIZE	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
size_t	long
bytes_read	long
;	O
bytes_read	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
chunk	*(char)
,	O
1	int
,	O
FILESYS_PIPE_BUFFER_SIZE	O
,	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
bytes_read	long
+	O
offset	long
>=	O
size	long
)	O
contents	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
contents	*(char)
,	O
size	long
+=	O
(	O
2	int
*	O
FILESYS_PIPE_BUFFER_SIZE	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
contents	*(char)
+	O
offset	long
,	O
chunk	*(char)
,	O
bytes_read	long
)	O
;	O
offset	long
+=	O
bytes_read	long
;	O
if	O
(	O
bytes_read	long
!=	O
FILESYS_PIPE_BUFFER_SIZE	O
)	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
chunk	*(char)
)	O
;	O
if	O
(	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
contents	*(char)
)	O
free	(*(void))->(void)
(	O
contents	*(char)
)	O
;	O
contents	*(char)
=	O
NULL	O
;	O
filesys_error_number	int
=	O
errno	O
;	O
}	O
else	O
{	O
contents	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
contents	*(char)
,	O
1	int
+	O
offset	long
)	O
;	O
contents	*(char)
[	O
offset	long
]	O
=	O
'\0'	O
;	O
*	O
filesize	*(long)
=	O
offset	long
;	O
}	O
}	O
else	O
{	O
filesys_error_number	int
=	O
errno	O
;	O
}	O
if	O
(	O
info_windows_initialized_p	int
)	O
unmessage_in_echo_area	()->(void)
(	O
)	O
;	O
return	O
contents	*(char)
;	O
}	O
static	O
int	O
compressed_filename_p	(*(char))->(int)
(	O
char	O
*	O
filename	*(char)
)	O
{	O
char	O
*	O
decompressor	*(char)
;	O
decompressor	*(char)
=	O
filesys_decompressor_for_file	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
decompressor	*(char)
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
filesys_decompressor_for_file	(*(char))->(*(char))
(	O
char	O
*	O
filename	*(char)
)	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
extension	*(char)
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
-	O
1	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
filename	*(char)
[	O
i	int
]	O
==	O
'.'	O
)	O
{	O
extension	*(char)
=	O
filename	*(char)
+	O
i	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
extension	*(char)
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
compress_suffixes	array(struct(*(char),*(char)))
[	O
i	int
]	O
.	O
suffix	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
FILENAME_CMP	O
(	O
extension	*(char)
,	O
compress_suffixes	array(struct(*(char),*(char)))
[	O
i	int
]	O
.	O
suffix	*(char)
)	O
==	O
0	int
)	O
return	O
compress_suffixes	array(struct(*(char),*(char)))
[	O
i	int
]	O
.	O
decompressor	*(char)
;	O
return	O
NULL	O
;	O
}	O
int	O
filesys_error_number	int
=	O
0	int
;	O
static	O
char	O
*	O
errmsg_buf	*(char)
=	O
NULL	O
;	O
static	O
int	O
errmsg_buf_size	int
=	O
0	int
;	O
char	O
*	O
filesys_error_string	(*(char),int)->(*(char))
(	O
char	O
*	O
filename	*(char)
,	O
int	O
error_num	int
)	O
{	O
int	O
len	long
;	O
char	O
*	O
result	*(char)
;	O
if	O
(	O
error_num	int
==	O
0	int
)	O
return	O
NULL	O
;	O
result	*(char)
=	O
strerror	(int)->(*(char))
(	O
error_num	int
)	O
;	O
len	long
=	O
4	int
+	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
result	*(char)
)	O
;	O
if	O
(	O
len	long
>=	O
errmsg_buf_size	int
)	O
errmsg_buf	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
errmsg_buf	*(char)
,	O
(	O
errmsg_buf_size	int
=	O
2	int
+	O
len	long
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
errmsg_buf	*(char)
,	O
"%s: %s"	*(char)
,	O
filename	*(char)
,	O
result	*(char)
)	O
;	O
return	O
errmsg_buf	*(char)
;	O
}	O
int	O
is_dir_name	(*(char))->(int)
(	O
char	O
*	O
filename	*(char)
)	O
{	O
unsigned	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
info_suffixes	array(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
unsigned	O
c	int
;	O
char	O
trydir	array(char)
[	O
50	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
trydir	array(char)
,	O
"dir"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
trydir	array(char)
,	O
info_suffixes	array(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
mbscasecmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
trydir	array(char)
)	O
==	O
0	int
)	O
return	O
1	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
compress_suffixes	array(struct(*(char),*(char)))
[	O
c	int
]	O
.	O
suffix	*(char)
;	O
c	int
++	O
)	O
{	O
char	O
dir_compressed	array(char)
[	O
50	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dir_compressed	array(char)
,	O
trydir	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
dir_compressed	array(char)
,	O
compress_suffixes	array(struct(*(char),*(char)))
[	O
c	int
]	O
.	O
suffix	*(char)
)	O
;	O
if	O
(	O
mbscasecmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
dir_compressed	array(char)
)	O
==	O
0	int
)	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
