static	O
int	O
mc_debug	int
=	O
0	int
;	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
{	O
Intersection	char
board	*(char)
[	O
BOARDSIZE	O
]	O
;	O
int	O
local_context	array(int)
[	O
BOARDSIZE	O
]	O
;	O
int	O
queue	array(int)
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
move_values_white	array(int)
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
move_values_black	array(int)
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
partitioned_move_value_sums_white	array(int)
[	O
NUM_MOVE_PARTITIONS	int
]	O
;	O
unsigned	O
int	O
partitioned_move_value_sums_black	array(int)
[	O
NUM_MOVE_PARTITIONS	int
]	O
;	O
int	O
move_partition_lists_white	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
move_partition_lists_black	array(int)
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
move_value_sum_white	int
;	O
unsigned	O
int	O
move_value_sum_black	int
;	O
int	O
board_ko_pos	int
;	O
int	O
reference_stone	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
next_stone	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
first_liberty_edge	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
previous_liberty_edge	array(int)
[	O
4	int
*	O
BOARDMAX	O
]	O
;	O
int	O
next_liberty_edge	array(int)
[	O
4	int
*	O
BOARDMAX	O
]	O
;	O
Hash_data	struct(array(long))
hash	struct(array(long))
;	O
}	O
;	O
static	O
void	O
mc_add_liberty_edge	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
pos	int
,	O
int	O
lib	int
,	O
int	O
dir	int
)	O
{	O
int	O
this_liberty_edge	int
=	O
(	O
lib	int
<<	O
2	int
)	O
|	O
dir	int
;	O
int	O
reference	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
pos	int
]	O
;	O
int	O
first_liberty_edge	array(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
;	O
if	O
(	O
first_liberty_edge	array(int)
)	O
{	O
int	O
second_liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
first_liberty_edge	array(int)
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
previous_liberty_edge	array(int)
[	O
this_liberty_edge	int
]	O
=	O
first_liberty_edge	array(int)
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
this_liberty_edge	int
]	O
=	O
second_liberty_edge	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
first_liberty_edge	array(int)
]	O
=	O
this_liberty_edge	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
previous_liberty_edge	array(int)
[	O
second_liberty_edge	int
]	O
=	O
this_liberty_edge	int
;	O
}	O
else	O
{	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
=	O
this_liberty_edge	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
this_liberty_edge	int
]	O
=	O
this_liberty_edge	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
previous_liberty_edge	array(int)
[	O
this_liberty_edge	int
]	O
=	O
this_liberty_edge	int
;	O
}	O
}	O
static	O
int	O
mc_remove_liberty_edge	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
pos	int
,	O
int	O
lib	int
,	O
int	O
dir	int
)	O
{	O
int	O
reference	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
pos	int
]	O
;	O
int	O
this_liberty_edge	int
=	O
(	O
lib	int
<<	O
2	int
)	O
|	O
dir	int
;	O
int	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
this_liberty_edge	int
]	O
;	O
int	O
previous	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
previous_liberty_edge	array(int)
[	O
this_liberty_edge	int
]	O
;	O
if	O
(	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
==	O
this_liberty_edge	int
)	O
{	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
previous	int
]	O
=	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
previous_liberty_edge	array(int)
[	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
=	O
previous	int
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
==	O
this_liberty_edge	int
)	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
=	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
return	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
static	O
void	O
mc_join_strings	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
reference	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
str2	int
]	O
;	O
int	O
liberty_edge2	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
;	O
int	O
liberty_edge1	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
str1	int
]	O
]	O
;	O
int	O
next1	int
;	O
int	O
next2	int
;	O
int	O
pos	int
=	O
str1	int
;	O
do	O
{	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
pos	int
]	O
=	O
reference	int
;	O
pos	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
pos	int
]	O
;	O
}	O
while	O
(	O
pos	int
!=	O
str1	int
)	O
;	O
next1	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
str1	int
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
str1	int
]	O
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
str2	int
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
str2	int
]	O
=	O
next1	int
;	O
if	O
(	O
liberty_edge1	int
!=	O
0	int
)	O
{	O
next1	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge1	int
]	O
;	O
next2	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge2	int
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge1	int
]	O
=	O
next2	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge2	int
]	O
=	O
next1	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
previous_liberty_edge	array(int)
[	O
next1	int
]	O
=	O
liberty_edge2	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
previous_liberty_edge	array(int)
[	O
next2	int
]	O
=	O
liberty_edge1	int
;	O
}	O
}	O
static	O
void	O
mc_queue_max_two_liberties	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int)->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
str	int
)	O
{	O
int	O
reference	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
str	int
]	O
;	O
int	O
first_liberty_edge	array(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
;	O
int	O
first_liberty	int
=	O
first_liberty_edge	array(int)
>>	O
2	int
;	O
int	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
first_liberty_edge	array(int)
]	O
;	O
int	O
second_liberty	int
;	O
if	O
(	O
first_liberty	int
==	O
NO_MOVE	O
)	O
return	O
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array(int)
)	O
{	O
if	O
(	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
first_liberty	int
)	O
{	O
second_liberty	int
=	O
liberty_edge	int
>>	O
2	int
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array(int)
)	O
{	O
if	O
(	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
first_liberty	int
&&	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
second_liberty	int
)	O
return	O
;	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge	int
]	O
;	O
}	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
first_liberty	int
)	O
;	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
second_liberty	int
)	O
;	O
return	O
;	O
}	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge	int
]	O
;	O
}	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
first_liberty	int
)	O
;	O
}	O
static	O
int	O
mc_remove_string	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int)->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
str	int
)	O
{	O
int	O
color	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos	int
=	O
str	int
;	O
int	O
num_removed_stones	int
=	O
0	int
;	O
int	O
k	int
;	O
do	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
<	O
4	int
&&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
other	int
)	O
{	O
mc_queue_max_two_liberties	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int)->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
;	O
mc_add_liberty_edge	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
,	O
pos	int
,	O
k	int
)	O
;	O
}	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
;	O
}	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
=	O
EMPTY	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
NW	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
14	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
SW	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
12	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
SE	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
10	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
NE	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
8	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
6	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
4	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
2	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
^=	O
color	int
;	O
hashdata_invert_stone	(*(struct(array(long))),int,int)->(void)
(	O
&	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
hash	struct(array(long))
)	O
,	O
pos	int
,	O
color	int
)	O
;	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
)	O
;	O
num_removed_stones	int
++	O
;	O
pos	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
pos	int
]	O
;	O
}	O
while	O
(	O
pos	int
!=	O
str	int
)	O
;	O
return	O
num_removed_stones	int
;	O
}	O
static	O
void	O
mc_init_board_from_global_board	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))))->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
)	O
{	O
int	O
stones	*(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
num_stones	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
r	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
,	O
board	*(char)
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
)	O
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
=	O
board_ko_pos	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
hash	struct(array(long))
=	O
board_hash	struct(array(long))
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
)	O
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
0	int
]	O
=	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
geometry	int
=	O
(	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
SE	O
(	O
pos	int
)	O
]	O
<<	O
14	int
)	O
|	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
NE	O
(	O
pos	int
)	O
]	O
<<	O
12	int
)	O
|	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
NW	O
(	O
pos	int
)	O
]	O
<<	O
10	int
)	O
|	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
SW	O
(	O
pos	int
)	O
]	O
<<	O
8	int
)	O
|	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
<<	O
6	int
)	O
|	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
<<	O
4	int
)	O
|	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
<<	O
2	int
)	O
|	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
=	O
geometry	int
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
s	int
;	O
int	O
captured_black_stones	int
=	O
0	int
;	O
int	O
captured_white_stones	int
=	O
0	int
;	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
pos	int
,	O
WHITE	int
)	O
)	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
1	int
<<	O
20	int
;	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
pos	int
,	O
BLACK	int
)	O
)	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
1	int
<<	O
21	int
;	O
if	O
(	O
is_suicide	(int,int)->(int)
(	O
pos	int
,	O
WHITE	int
)	O
)	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
1	int
<<	O
22	int
;	O
if	O
(	O
is_suicide	(int,int)->(int)
(	O
pos	int
,	O
BLACK	int
)	O
)	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
1	int
<<	O
23	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
4	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
s	int
]	O
]	O
==	O
BLACK	int
&&	O
countlib	(int)->(int)
(	O
pos	int
+	O
delta	array(int)
[	O
s	int
]	O
)	O
==	O
1	int
)	O
captured_black_stones	int
+=	O
countstones	(int)->(int)
(	O
pos	int
+	O
delta	array(int)
[	O
s	int
]	O
)	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
s	int
]	O
]	O
==	O
WHITE	int
&&	O
countlib	(int)->(int)
(	O
pos	int
+	O
delta	array(int)
[	O
s	int
]	O
)	O
==	O
1	int
)	O
captured_white_stones	int
+=	O
countstones	(int)->(int)
(	O
pos	int
+	O
delta	array(int)
[	O
s	int
]	O
)	O
;	O
}	O
if	O
(	O
captured_black_stones	int
>	O
3	int
)	O
captured_black_stones	int
=	O
3	int
;	O
if	O
(	O
captured_white_stones	int
>	O
3	int
)	O
captured_white_stones	int
=	O
3	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
captured_black_stones	int
<<	O
16	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
captured_white_stones	int
<<	O
18	int
;	O
}	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
pos	int
]	O
==	O
0	int
)	O
{	O
num_stones	int
=	O
findstones	(int,int,*(int))->(int)
(	O
pos	int
,	O
BOARDMAX	O
,	O
stones	*(int)
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
pos	int
]	O
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_stones	int
;	O
r	int
++	O
)	O
{	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
stones	*(int)
[	O
r	int
]	O
]	O
=	O
stones	*(int)
[	O
(	O
r	int
+	O
1	int
)	O
%	O
num_stones	int
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
stones	*(int)
[	O
r	int
]	O
]	O
=	O
pos	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
stones	*(int)
[	O
r	int
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
mc_add_liberty_edge	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
stones	*(int)
[	O
r	int
]	O
,	O
stones	*(int)
[	O
r	int
]	O
+	O
delta	array(int)
[	O
k	int
]	O
,	O
(	O
k	int
+	O
2	int
)	O
%	O
4	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
mc_showboard	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
i	int
,	O
j	int
;	O
draw_letter_coordinates	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n%2d"	*(char)
,	O
board_size	int
-	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
==	O
EMPTY	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %c"	*(char)
,	O
is_hoshi_point	(int,int)->(int)
(	O
i	int
,	O
j	int
)	O
?	O
'+'	O
:	O
'.'	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %c"	*(char)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
==	O
BLACK	int
?	O
'X'	O
:	O
'O'	O
)	O
;	O
}	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
draw_letter_coordinates	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
int	O
mc_countstones	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
str	int
,	O
int	O
maxstones	int
)	O
{	O
int	O
stone	int
=	O
str	int
;	O
int	O
num_stones	int
=	O
0	int
;	O
do	O
{	O
num_stones	int
++	O
;	O
stone	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
stone	int
]	O
;	O
}	O
while	O
(	O
stone	int
!=	O
str	int
&&	O
num_stones	int
<	O
maxstones	int
)	O
;	O
return	O
num_stones	int
;	O
}	O
static	O
int	O
mc_is_in_atari	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,*(int))->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
str	int
,	O
int	O
*	O
lib	int
)	O
{	O
int	O
reference	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
str	int
]	O
;	O
int	O
first_liberty_edge	array(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
;	O
int	O
liberty	int
=	O
first_liberty_edge	array(int)
>>	O
2	int
;	O
int	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
first_liberty_edge	array(int)
]	O
;	O
if	O
(	O
lib	int
)	O
*	O
lib	int
=	O
liberty	int
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array(int)
)	O
{	O
if	O
(	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
liberty	int
)	O
return	O
0	int
;	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge	int
]	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
mc_is_in_atari2	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
first_liberty	int
,	O
int	O
first_liberty_edge	array(int)
)	O
{	O
int	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
first_liberty_edge	array(int)
]	O
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array(int)
)	O
{	O
if	O
(	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
first_liberty	int
)	O
return	O
0	int
;	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge	int
]	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
mc_stones_in_atari	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
maxstones	int
)	O
{	O
int	O
k	int
;	O
int	O
stones_in_atari	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
&&	O
stones_in_atari	int
<	O
maxstones	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
mc_is_in_atari	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,*(int))->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
NULL	O
)	O
)	O
stones_in_atari	int
+=	O
mc_countstones	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
maxstones	int
-	O
stones_in_atari	int
)	O
;	O
}	O
return	O
stones_in_atari	int
;	O
}	O
static	O
int	O
mc_has_two_liberties_one_given	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,*(int))->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
str	int
,	O
int	O
first_liberty	int
,	O
int	O
*	O
second_liberty	int
)	O
{	O
int	O
reference	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
str	int
]	O
;	O
int	O
first_liberty_edge	array(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
reference	int
]	O
;	O
int	O
liberty_edge	int
=	O
first_liberty_edge	array(int)
;	O
*	O
second_liberty	int
=	O
NO_MOVE	O
;	O
do	O
{	O
int	O
liberty	int
=	O
liberty_edge	int
>>	O
2	int
;	O
if	O
(	O
liberty	int
!=	O
first_liberty	int
)	O
{	O
if	O
(	O
*	O
second_liberty	int
==	O
NO_MOVE	O
)	O
*	O
second_liberty	int
=	O
liberty	int
;	O
else	O
if	O
(	O
liberty	int
!=	O
*	O
second_liberty	int
)	O
return	O
0	int
;	O
}	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge	int
]	O
;	O
}	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array(int)
)	O
;	O
return	O
(	O
*	O
second_liberty	int
!=	O
NO_MOVE	O
)	O
;	O
}	O
static	O
int	O
mc_is_self_atari	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
captured	int
=	O
NO_MOVE	O
;	O
int	O
liberty	int
=	O
NO_MOVE	O
;	O
int	O
reference	int
;	O
int	O
other	int
;	O
if	O
(	O
(	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
)	O
+	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
)	O
+	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
)	O
+	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
)	O
)	O
>	O
1	int
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
first_liberty_edge	array(int)
;	O
int	O
liberty_edge	int
;	O
int	O
additional_liberty	int
=	O
0	int
;	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
pos2	int
!=	O
liberty	int
)	O
{	O
if	O
(	O
liberty	int
!=	O
NO_MOVE	O
)	O
return	O
0	int
;	O
else	O
liberty	int
=	O
pos2	int
;	O
}	O
}	O
else	O
if	O
(	O
IS_STONE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
)	O
)	O
{	O
first_liberty_edge	array(int)
=	O
(	O
pos	int
<<	O
2	int
)	O
|	O
k	int
;	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
first_liberty_edge	array(int)
]	O
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array(int)
)	O
{	O
int	O
lib	int
=	O
liberty_edge	int
>>	O
2	int
;	O
if	O
(	O
lib	int
!=	O
pos	int
)	O
{	O
additional_liberty	int
=	O
1	int
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
lib	int
!=	O
liberty	int
)	O
{	O
if	O
(	O
liberty	int
!=	O
NO_MOVE	O
)	O
return	O
0	int
;	O
else	O
liberty	int
=	O
lib	int
;	O
}	O
}	O
else	O
break	O
;	O
}	O
liberty_edge	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_liberty_edge	array(int)
[	O
liberty_edge	int
]	O
;	O
}	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
!=	O
color	int
&&	O
additional_liberty	int
==	O
0	int
)	O
{	O
captured	int
=	O
pos2	int
;	O
if	O
(	O
pos2	int
!=	O
liberty	int
)	O
{	O
if	O
(	O
liberty	int
!=	O
NO_MOVE	O
)	O
return	O
0	int
;	O
else	O
liberty	int
=	O
pos2	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
liberty	int
==	O
NO_MOVE	O
||	O
captured	int
==	O
NO_MOVE	O
)	O
return	O
1	int
;	O
reference	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
captured	int
]	O
;	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
int	O
stone	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
do	O
{	O
int	O
m	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
4	int
;	O
m	int
++	O
)	O
{	O
int	O
pos2	int
=	O
stone	int
+	O
delta	array(int)
[	O
m	int
]	O
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
==	O
other	int
&&	O
pos2	int
!=	O
captured	int
&&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
pos2	int
]	O
==	O
reference	int
)	O
return	O
0	int
;	O
}	O
stone	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
stone	int
]	O
;	O
}	O
while	O
(	O
stone	int
!=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
mc_update_local_context	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int)->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
pos	int
)	O
{	O
int	O
min_white_liberties	int
=	O
0	int
;	O
int	O
min_black_liberties	int
=	O
0	int
;	O
int	O
white_liberty_through_stones	int
=	O
0	int
;	O
int	O
black_liberty_through_stones	int
=	O
0	int
;	O
int	O
min_white_captured_stones	int
=	O
0	int
;	O
int	O
min_black_captured_stones	int
=	O
0	int
;	O
int	O
white_suicide	int
=	O
0	int
;	O
int	O
black_suicide	int
=	O
0	int
;	O
int	O
white_self_atari	int
=	O
0	int
;	O
int	O
black_self_atari	int
=	O
0	int
;	O
int	O
white_captured_stones	int
=	O
0	int
;	O
int	O
black_captured_stones	int
=	O
0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
switch	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
)	O
{	O
case	O
EMPTY	int
:	O
min_white_liberties	int
++	O
;	O
min_black_liberties	int
++	O
;	O
break	O
;	O
case	O
WHITE	int
:	O
if	O
(	O
mc_is_in_atari2	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
(	O
pos	int
<<	O
2	int
)	O
|	O
k	int
)	O
)	O
{	O
min_black_liberties	int
++	O
;	O
min_white_captured_stones	int
++	O
;	O
}	O
else	O
white_liberty_through_stones	int
=	O
1	int
;	O
break	O
;	O
case	O
BLACK	int
:	O
if	O
(	O
mc_is_in_atari2	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
(	O
pos	int
<<	O
2	int
)	O
|	O
k	int
)	O
)	O
{	O
min_white_liberties	int
++	O
;	O
min_black_captured_stones	int
++	O
;	O
}	O
else	O
black_liberty_through_stones	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
min_white_liberties	int
+	O
white_liberty_through_stones	int
==	O
0	int
)	O
{	O
white_suicide	int
=	O
1	int
;	O
white_self_atari	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
min_white_liberties	int
<=	O
1	int
)	O
white_self_atari	int
=	O
mc_is_self_atari	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
WHITE	int
)	O
;	O
if	O
(	O
min_black_liberties	int
+	O
black_liberty_through_stones	int
==	O
0	int
)	O
{	O
black_suicide	int
=	O
1	int
;	O
black_self_atari	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
min_black_liberties	int
<=	O
1	int
)	O
black_self_atari	int
=	O
mc_is_self_atari	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
BLACK	int
)	O
;	O
if	O
(	O
min_white_captured_stones	int
>=	O
3	int
)	O
white_captured_stones	int
=	O
3	int
;	O
else	O
if	O
(	O
min_white_captured_stones	int
>	O
0	int
)	O
white_captured_stones	int
=	O
mc_stones_in_atari	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
BLACK	int
,	O
3	int
)	O
;	O
if	O
(	O
min_black_captured_stones	int
>=	O
3	int
)	O
black_captured_stones	int
=	O
3	int
;	O
else	O
if	O
(	O
min_black_captured_stones	int
>	O
0	int
)	O
black_captured_stones	int
=	O
mc_stones_in_atari	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
WHITE	int
,	O
3	int
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
&=	O
0xffff	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
black_captured_stones	int
<<	O
16	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
white_captured_stones	int
<<	O
18	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
white_self_atari	int
<<	O
20	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
black_self_atari	int
<<	O
21	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
white_suicide	int
<<	O
22	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
pos	int
]	O
|=	O
black_suicide	int
<<	O
23	int
;	O
}	O
static	O
int	O
mc_play_move	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
captured_stones	*(int)
=	O
0	int
;	O
int	O
num_direct_liberties	int
=	O
0	int
;	O
int	O
pos2	int
;	O
while	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
0	int
]	O
!=	O
1	int
)	O
{	O
pos2	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
0	int
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
0	int
]	O
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
pos2	int
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
pos2	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
pos	int
==	O
PASS_MOVE	int
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
hash	struct(array(long))
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
pos	int
==	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
mc_is_suicide	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
color	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
hash	struct(array(long))
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
=	O
color	int
;	O
hashdata_invert_stone	(*(struct(array(long))),int,int)->(void)
(	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
hash	struct(array(long))
,	O
pos	int
,	O
color	int
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
pos	int
]	O
=	O
pos	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
NW	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
14	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
SW	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
12	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
SE	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
10	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
NE	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
8	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
6	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
4	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
2	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
|=	O
color	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
pos	int
]	O
=	O
pos	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
pos	int
]	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
mc_add_liberty_edge	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
pos2	int
,	O
(	O
k	int
+	O
2	int
)	O
%	O
4	int
)	O
;	O
num_direct_liberties	int
++	O
;	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos2	int
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
liberty	int
;	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
pos	int
]	O
!=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
reference_stone	array(int)
[	O
pos2	int
]	O
)	O
{	O
if	O
(	O
mc_has_two_liberties_one_given	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,*(int))->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos2	int
,	O
pos	int
,	O
&	O
liberty	int
)	O
)	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
liberty	int
)	O
;	O
mc_join_strings	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
pos2	int
)	O
;	O
}	O
mc_remove_liberty_edge	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos2	int
,	O
pos	int
,	O
k	int
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
if	O
(	O
mc_remove_liberty_edge	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos2	int
,	O
pos	int
,	O
k	int
)	O
==	O
0	int
)	O
captured_stones	*(int)
+=	O
mc_remove_string	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos2	int
)	O
;	O
else	O
mc_queue_max_two_liberties	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int)->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos2	int
)	O
;	O
}	O
}	O
if	O
(	O
captured_stones	*(int)
==	O
1	int
&&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
next_stone	array(int)
[	O
pos	int
]	O
==	O
pos	int
&&	O
num_direct_liberties	int
==	O
0	int
)	O
{	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
first_liberty_edge	array(int)
[	O
pos	int
]	O
>>	O
2	int
;	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
hash	struct(array(long))
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
)	O
;	O
}	O
mc_queue_max_two_liberties	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int)->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
)	O
;	O
for	O
(	O
pos2	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
0	int
]	O
;	O
pos2	int
!=	O
1	int
;	O
pos2	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
pos2	int
]	O
)	O
if	O
(	O
pos2	int
!=	O
pos	int
)	O
mc_update_local_context	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int)->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos2	int
)	O
;	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
struct	O
mc_pattern_table	struct(array(short),array(int))
{	O
unsigned	O
short	O
geometry_table	array(short)
[	O
65536	int
]	O
;	O
unsigned	O
int	O
values	array(float)
[	O
(	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
*	O
NUM_PROPERTIES	int
]	O
;	O
}	O
;	O
static	O
struct	O
mc_pattern_table	struct(array(short),array(int))
mc_patterns	struct(array(short),array(int))
;	O
static	O
int	O
mc_find_pattern_number	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
near_previous_move	int
)	O
{	O
int	O
local_context	array(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
local_context	array(int)
[	O
move	*(int)
]	O
;	O
int	O
properties	int
;	O
int	O
geometry	int
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
properties	int
=	O
(	O
(	O
(	O
local_context	array(int)
>>	O
16	int
)	O
&	O
0xa0	int
)	O
|	O
(	O
(	O
local_context	array(int)
>>	O
14	int
)	O
&	O
0x40	int
)	O
|	O
(	O
(	O
local_context	array(int)
>>	O
17	int
)	O
&	O
0x06	int
)	O
|	O
(	O
(	O
local_context	array(int)
>>	O
13	int
)	O
&	O
0x18	int
)	O
)	O
;	O
geometry	int
=	O
local_context	array(int)
&	O
0xffff	int
;	O
}	O
else	O
{	O
properties	int
=	O
(	O
local_context	array(int)
>>	O
15	int
)	O
&	O
0xfe	int
;	O
geometry	int
=	O
(	O
(	O
(	O
local_context	array(int)
&	O
0x5555	int
)	O
<<	O
1	int
)	O
|	O
(	O
(	O
local_context	array(int)
&	O
0xaaaa	int
)	O
>>	O
1	int
)	O
)	O
;	O
}	O
return	O
(	O
(	O
mc_patterns	struct(array(short),array(int))
.	O
geometry_table	array(short)
[	O
geometry	int
]	O
<<	O
8	int
)	O
|	O
properties	int
|	O
near_previous_move	int
)	O
;	O
}	O
static	O
unsigned	O
short	O
mc_register_geometry_pattern	(int,short)->(short)
(	O
unsigned	O
int	O
pattern	*(struct)
,	O
unsigned	O
short	O
n	int
)	O
{	O
int	O
k	int
;	O
int	O
j	int
;	O
unsigned	O
int	O
transformed_pattern	int
;	O
if	O
(	O
mc_patterns	struct(array(short),array(int))
.	O
geometry_table	array(short)
[	O
pattern	*(struct)
]	O
!=	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
transformed_pattern	int
=	O
pattern	*(struct)
;	O
if	O
(	O
k	int
>=	O
4	int
)	O
{	O
transformed_pattern	int
=	O
(	O
(	O
(	O
pattern	*(struct)
&	O
0x0300	int
)	O
<<	O
6	int
)	O
|	O
(	O
(	O
pattern	*(struct)
&	O
0x000c	int
)	O
<<	O
4	int
)	O
|	O
(	O
(	O
pattern	*(struct)
&	O
0x0c00	int
)	O
<<	O
2	int
)	O
|	O
(	O
pattern	*(struct)
&	O
0x0033	int
)	O
|	O
(	O
(	O
pattern	*(struct)
&	O
0x3000	int
)	O
>>	O
2	int
)	O
|	O
(	O
(	O
pattern	*(struct)
&	O
0x00c0	int
)	O
>>	O
4	int
)	O
|	O
(	O
(	O
pattern	*(struct)
&	O
0xc000	int
)	O
>>	O
6	int
)	O
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
k	int
%	O
4	int
;	O
j	int
++	O
)	O
{	O
transformed_pattern	int
=	O
(	O
(	O
(	O
transformed_pattern	int
&	O
0xc0c0	int
)	O
>>	O
6	int
)	O
|	O
(	O
(	O
transformed_pattern	int
&	O
0x3f3f	int
)	O
<<	O
2	int
)	O
)	O
;	O
}	O
mc_patterns	struct(array(short),array(int))
.	O
geometry_table	array(short)
[	O
transformed_pattern	int
]	O
=	O
n	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
mc_init_pattern_geometries	()->(void)
(	O
void	O
)	O
{	O
unsigned	O
int	O
pattern	*(struct)
;	O
unsigned	O
short	O
n	int
=	O
1	int
;	O
static	O
int	O
initialized	int
=	O
0	int
;	O
if	O
(	O
initialized	int
)	O
return	O
;	O
initialized	int
=	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc_patterns	struct(array(short),array(int))
.	O
geometry_table	array(short)
,	O
0	int
,	O
sizeof	O
(	O
mc_patterns	struct(array(short),array(int))
.	O
geometry_table	array(short)
)	O
)	O
;	O
for	O
(	O
pattern	*(struct)
=	O
0	int
;	O
pattern	*(struct)
<	O
65536	int
;	O
pattern	*(struct)
++	O
)	O
{	O
unsigned	O
int	O
off_board	int
=	O
(	O
pattern	*(struct)
&	O
(	O
pattern	*(struct)
>>	O
1	int
)	O
)	O
&	O
0x5555	int
;	O
if	O
(	O
off_board	int
==	O
0x0	int
||	O
off_board	int
==	O
0x1410	int
||	O
off_board	int
==	O
0x5450	int
)	O
n	int
+=	O
mc_register_geometry_pattern	(int,short)->(short)
(	O
pattern	*(struct)
,	O
n	int
)	O
;	O
}	O
gg_assert	O
(	O
n	int
==	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
;	O
}	O
static	O
void	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
int	O
pattern	*(struct)
[	O
8	int
]	O
,	O
int	O
*	O
matching_geometries	*(int)
,	O
int	O
n	int
)	O
{	O
int	O
k	int
;	O
int	O
geometry	int
=	O
0	int
;	O
if	O
(	O
n	int
==	O
8	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
pattern	*(struct)
[	O
k	int
]	O
==	O
'O'	O
)	O
geometry	int
|=	O
WHITE	int
<<	O
(	O
2	int
*	O
k	int
)	O
;	O
else	O
if	O
(	O
pattern	*(struct)
[	O
k	int
]	O
==	O
'X'	O
)	O
geometry	int
|=	O
BLACK	int
<<	O
(	O
2	int
*	O
k	int
)	O
;	O
else	O
if	O
(	O
pattern	*(struct)
[	O
k	int
]	O
==	O
'+'	O
||	O
pattern	*(struct)
[	O
k	int
]	O
==	O
'|'	O
||	O
pattern	*(struct)
[	O
k	int
]	O
==	O
'-'	O
)	O
geometry	int
|=	O
(	O
WHITE	int
|	O
BLACK	int
)	O
<<	O
(	O
2	int
*	O
k	int
)	O
;	O
}	O
if	O
(	O
mc_patterns	struct(array(short),array(int))
.	O
geometry_table	array(short)
[	O
geometry	int
]	O
!=	O
0	int
)	O
{	O
matching_geometries	*(int)
[	O
mc_patterns	struct(array(short),array(int))
.	O
geometry_table	array(short)
[	O
geometry	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
else	O
{	O
int	O
new_pattern	array(int)
[	O
8	int
]	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_pattern	array(int)
,	O
pattern	*(struct)
,	O
sizeof	O
(	O
new_pattern	array(int)
)	O
)	O
;	O
switch	O
(	O
pattern	*(struct)
[	O
n	int
]	O
)	O
{	O
case	O
'.'	O
:	O
case	O
'O'	O
:	O
case	O
'X'	O
:	O
case	O
'|'	O
:	O
case	O
'-'	O
:	O
case	O
'+'	O
:	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'.'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'O'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'.'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'X'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'.'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'O'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'X'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'.'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'O'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'X'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array(int)
[	O
n	int
]	O
=	O
'+'	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
new_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
int	O
*	O
properties	int
,	O
int	O
shift	int
,	O
int	O
mask	int
,	O
int	O
value	*(char)
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_PROPERTIES	int
;	O
k	int
++	O
)	O
if	O
(	O
(	O
(	O
k	int
>>	O
shift	int
)	O
&	O
mask	int
)	O
==	O
value	*(char)
)	O
properties	int
[	O
k	int
]	O
=	O
0	int
;	O
}	O
static	O
void	O
mc_analyze_properties	(*(char),*(int))->(void)
(	O
char	O
*	O
buf	*(char)
,	O
int	O
*	O
properties	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_PROPERTIES	int
;	O
k	int
++	O
)	O
properties	int
[	O
k	int
]	O
=	O
1	int
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"near"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
0	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"far"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
0	int
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xcap0"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xcap1+"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xcap1-"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xcap1"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xcap2+"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xcap2-"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xcap2"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xcap3"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
2	int
)	O
;	O
}	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ocap0"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ocap1+"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ocap1-"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ocap1"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ocap2+"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ocap2-"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ocap2"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ocap3"	*(char)
)	O
)	O
{	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
2	int
)	O
;	O
}	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xsafe"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
5	int
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xunsafe"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
5	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"osafe"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
6	int
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"ounsafe"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
6	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xsuicide"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
7	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"xnosuicide"	*(char)
)	O
)	O
mc_clear_properties	(*(int),int,int,int)->(void)
(	O
properties	int
,	O
7	int
,	O
1	int
,	O
1	int
)	O
;	O
}	O
int	O
mc_get_size_of_pattern_values_table	()->(int)
(	O
void	O
)	O
{	O
return	O
(	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
*	O
NUM_PROPERTIES	int
;	O
}	O
int	O
mc_load_patterns_from_db	(*(char),*(int))->(int)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
unsigned	O
int	O
*	O
values	array(float)
)	O
{	O
FILE	struct
*	O
pattern_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
buf	*(char)
[	O
80	int
]	O
;	O
unsigned	O
int	O
value	*(char)
;	O
int	O
pattern_line	int
=	O
0	int
;	O
int	O
current_pattern	array(int)
[	O
8	int
]	O
;	O
int	O
patterns_expanded	int
=	O
0	int
;	O
int	O
*	O
matching_geometries	*(int)
;	O
int	O
properties	int
[	O
NUM_PROPERTIES	int
]	O
;	O
int	O
k	int
;	O
int	O
m	int
;	O
if	O
(	O
!	O
values	array(float)
)	O
values	array(float)
=	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
;	O
mc_init_pattern_geometries	()->(void)
(	O
)	O
;	O
pattern_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
pattern_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Failed to open %s file.\n"	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
matching_geometries	*(int)
=	O
malloc	(long)->(*(void))
(	O
(	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
matching_geometries	*(int)
)	O
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
NUM_GEOMETRIES	int
;	O
k	int
++	O
)	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
NUM_PROPERTIES	int
;	O
m	int
++	O
)	O
values	array(float)
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
=	O
0xffffffffU	int
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
80	int
,	O
pattern_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
".xXoO|+-?%"	*(char)
,	O
buf	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
patterns_expanded	int
=	O
0	int
;	O
if	O
(	O
pattern_line	int
==	O
0	int
)	O
{	O
current_pattern	array(int)
[	O
5	int
]	O
=	O
buf	*(char)
[	O
0	int
]	O
;	O
current_pattern	array(int)
[	O
2	int
]	O
=	O
buf	*(char)
[	O
1	int
]	O
;	O
current_pattern	array(int)
[	O
6	int
]	O
=	O
buf	*(char)
[	O
2	int
]	O
;	O
}	O
else	O
if	O
(	O
pattern_line	int
==	O
1	int
)	O
{	O
current_pattern	array(int)
[	O
1	int
]	O
=	O
buf	*(char)
[	O
0	int
]	O
;	O
current_pattern	array(int)
[	O
3	int
]	O
=	O
buf	*(char)
[	O
2	int
]	O
;	O
}	O
else	O
if	O
(	O
pattern_line	int
==	O
2	int
)	O
{	O
current_pattern	array(int)
[	O
4	int
]	O
=	O
buf	*(char)
[	O
0	int
]	O
;	O
current_pattern	array(int)
[	O
0	int
]	O
=	O
buf	*(char)
[	O
1	int
]	O
;	O
current_pattern	array(int)
[	O
7	int
]	O
=	O
buf	*(char)
[	O
2	int
]	O
;	O
}	O
pattern_line	int
++	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
":%u"	*(char)
,	O
&	O
value	*(char)
)	O
==	O
1	int
)	O
{	O
if	O
(	O
value	*(char)
>	O
10000000	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning: pattern values should be at most 10000000."	*(char)
)	O
;	O
if	O
(	O
!	O
patterns_expanded	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
matching_geometries	*(int)
,	O
0	int
,	O
(	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
matching_geometries	*(int)
)	O
)	O
;	O
mc_match_geometries	(array(int),*(int),int)->(void)
(	O
current_pattern	array(int)
,	O
matching_geometries	*(int)
,	O
0	int
)	O
;	O
patterns_expanded	int
=	O
1	int
;	O
}	O
mc_analyze_properties	(*(char),*(int))->(void)
(	O
buf	*(char)
,	O
properties	int
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
NUM_GEOMETRIES	int
;	O
k	int
++	O
)	O
if	O
(	O
matching_geometries	*(int)
[	O
k	int
]	O
)	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
NUM_PROPERTIES	int
;	O
m	int
++	O
)	O
if	O
(	O
properties	int
[	O
m	int
]	O
&&	O
values	array(float)
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
==	O
0xffffffffU	int
)	O
values	array(float)
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
=	O
value	*(char)
;	O
pattern_line	int
=	O
0	int
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pattern_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
NUM_GEOMETRIES	int
;	O
k	int
++	O
)	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
NUM_PROPERTIES	int
;	O
m	int
++	O
)	O
if	O
(	O
values	array(float)
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
==	O
0xffffffffU	int
)	O
values	array(float)
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
=	O
1	int
;	O
free	(*(void))->(void)
(	O
matching_geometries	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
void	O
mc_init_patterns	(*(int))->(void)
(	O
const	O
unsigned	O
int	O
*	O
values	array(float)
)	O
{	O
mc_init_pattern_geometries	()->(void)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
,	O
values	array(float)
,	O
sizeof	O
(	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
)	O
)	O
;	O
}	O
static	O
void	O
mc_init_move_values	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))))->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_white	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_white	array(int)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_black	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_black	array(int)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_white	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_white	array(int)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_black	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_black	array(int)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
,	O
0	int
,	O
sizeof	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
)	O
)	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_white	int
=	O
0.0	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_black	int
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_MOVE_PARTITIONS	int
;	O
k	int
++	O
)	O
{	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
[	O
k	int
]	O
=	O
1	int
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
[	O
k	int
]	O
=	O
1	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
partition	int
=	O
pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
if	O
(	O
!	O
mc_is_suicide	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
WHITE	int
)	O
)	O
{	O
int	O
pattern	*(struct)
=	O
mc_find_pattern_number	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
WHITE	int
,	O
0	int
)	O
;	O
unsigned	O
int	O
value	*(char)
=	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
[	O
pattern	*(struct)
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_white	array(int)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_white	array(int)
[	O
partition	int
]	O
+=	O
value	*(char)
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_white	int
+=	O
value	*(char)
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
[	O
pos	int
]	O
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
[	O
partition	int
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
[	O
partition	int
]	O
=	O
pos	int
;	O
}	O
if	O
(	O
!	O
mc_is_suicide	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
BLACK	int
)	O
)	O
{	O
int	O
pattern	*(struct)
=	O
mc_find_pattern_number	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
BLACK	int
,	O
0	int
)	O
;	O
unsigned	O
int	O
value	*(char)
=	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
[	O
pattern	*(struct)
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_black	array(int)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_black	array(int)
[	O
partition	int
]	O
+=	O
value	*(char)
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_black	int
+=	O
value	*(char)
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
[	O
pos	int
]	O
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
[	O
partition	int
]	O
;	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
[	O
partition	int
]	O
=	O
pos	int
;	O
}	O
}	O
}	O
}	O
static	O
void	O
mc_add_move	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int,*(int),*(int),*(int),*(int))->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
partition	int
,	O
unsigned	O
int	O
*	O
move_values	*(float)
,	O
int	O
*	O
partition_lists	*(int)
,	O
unsigned	O
int	O
*	O
partition_sums	*(int)
,	O
unsigned	O
int	O
*	O
move_value_sum	*(int)
)	O
{	O
int	O
pattern	*(struct)
=	O
mc_find_pattern_number	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
color	int
,	O
0	int
)	O
;	O
unsigned	O
int	O
value	*(char)
=	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
[	O
pattern	*(struct)
]	O
;	O
partition_lists	*(int)
[	O
pos	int
]	O
=	O
partition_lists	*(int)
[	O
partition	int
]	O
;	O
partition_lists	*(int)
[	O
partition	int
]	O
=	O
pos	int
;	O
move_values	*(float)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
partition_sums	*(int)
[	O
partition	int
]	O
+=	O
value	*(char)
;	O
*	O
move_value_sum	*(int)
+=	O
value	*(char)
;	O
}	O
static	O
void	O
mc_update_move	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int,*(int),*(int),*(int))->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
partition	int
,	O
unsigned	O
int	O
*	O
move_values	*(float)
,	O
unsigned	O
int	O
*	O
partition_sums	*(int)
,	O
unsigned	O
int	O
*	O
move_value_sum	*(int)
)	O
{	O
int	O
pattern	*(struct)
=	O
mc_find_pattern_number	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
color	int
,	O
0	int
)	O
;	O
unsigned	O
int	O
value	*(char)
=	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
[	O
pattern	*(struct)
]	O
;	O
partition_sums	*(int)
[	O
partition	int
]	O
+=	O
value	*(char)
-	O
move_values	*(float)
[	O
pos	int
]	O
;	O
*	O
move_value_sum	*(int)
+=	O
value	*(char)
-	O
move_values	*(float)
[	O
pos	int
]	O
;	O
move_values	*(float)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
}	O
static	O
void	O
mc_remove_move	(int,int,*(int),*(int),*(int),*(int))->(void)
(	O
int	O
pos	int
,	O
int	O
partition	int
,	O
unsigned	O
int	O
*	O
move_values	*(float)
,	O
int	O
*	O
partition_lists	*(int)
,	O
unsigned	O
int	O
*	O
partition_sums	*(int)
,	O
unsigned	O
int	O
*	O
move_value_sum	*(int)
)	O
{	O
int	O
pos2	int
;	O
int	O
pos3	int
;	O
for	O
(	O
pos2	int
=	O
partition	int
;	O
partition_lists	*(int)
[	O
pos2	int
]	O
!=	O
1	int
;	O
pos2	int
=	O
partition_lists	*(int)
[	O
pos2	int
]	O
)	O
{	O
if	O
(	O
partition_lists	*(int)
[	O
pos2	int
]	O
==	O
pos	int
)	O
break	O
;	O
}	O
pos3	int
=	O
partition_lists	*(int)
[	O
pos2	int
]	O
;	O
partition_lists	*(int)
[	O
pos2	int
]	O
=	O
partition_lists	*(int)
[	O
pos3	int
]	O
;	O
partition_lists	*(int)
[	O
pos3	int
]	O
=	O
0	int
;	O
partition_sums	*(int)
[	O
partition	int
]	O
-=	O
move_values	*(float)
[	O
pos	int
]	O
;	O
*	O
move_value_sum	*(int)
-=	O
move_values	*(float)
[	O
pos	int
]	O
;	O
move_values	*(float)
[	O
pos	int
]	O
=	O
0.0	int
;	O
}	O
static	O
void	O
mc_update_move_values	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))))->(void)
(	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
)	O
{	O
int	O
pos	int
;	O
int	O
partition	int
;	O
for	O
(	O
pos	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
0	int
]	O
;	O
pos	int
!=	O
1	int
;	O
pos	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
pos	int
]	O
)	O
{	O
partition	int
=	O
pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
if	O
(	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
||	O
mc_is_suicide	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
WHITE	int
)	O
)	O
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
[	O
pos	int
]	O
!=	O
0	int
)	O
{	O
mc_remove_move	(int,int,*(int),*(int),*(int),*(int))->(void)
(	O
pos	int
,	O
partition	int
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_white	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_white	array(int)
,	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_white	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
[	O
pos	int
]	O
==	O
0	int
)	O
mc_add_move	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int,*(int),*(int),*(int),*(int))->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
WHITE	int
,	O
partition	int
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_white	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_white	array(int)
,	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_white	int
)	O
;	O
else	O
mc_update_move	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int,*(int),*(int),*(int))->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
WHITE	int
,	O
partition	int
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_white	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_white	array(int)
,	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_white	int
)	O
;	O
}	O
if	O
(	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
||	O
mc_is_suicide	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
BLACK	int
)	O
)	O
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
[	O
pos	int
]	O
!=	O
0	int
)	O
{	O
mc_remove_move	(int,int,*(int),*(int),*(int),*(int))->(void)
(	O
pos	int
,	O
partition	int
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_black	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_black	array(int)
,	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_black	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
[	O
pos	int
]	O
==	O
0	int
)	O
mc_add_move	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int,*(int),*(int),*(int),*(int))->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
BLACK	int
,	O
partition	int
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_black	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_black	array(int)
,	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_black	int
)	O
;	O
else	O
mc_update_move	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int,*(int),*(int),*(int))->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
BLACK	int
,	O
partition	int
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_black	array(int)
,	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_black	array(int)
,	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_black	int
)	O
;	O
}	O
}	O
}	O
struct	O
mc_game	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
{	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
;	O
int	O
move_history	array(int)
[	O
600	int
]	O
;	O
unsigned	O
char	O
settled	array(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
color_to_move	int
;	O
int	O
last_move	int
;	O
int	O
consecutive_passes	int
;	O
int	O
consecutive_ko_captures	int
;	O
int	O
depth	int
;	O
}	O
;	O
static	O
int	O
mc_generate_random_move	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)))->(int)
(	O
struct	O
mc_game	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
*	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
)	O
{	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
=	O
&	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
;	O
int	O
last_move	int
=	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
last_move	int
;	O
int	O
color	int
=	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
color_to_move	int
;	O
int	O
depth	int
=	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
depth	int
;	O
int	O
pos	int
;	O
int	O
near_moves	array(int)
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
saved_near_move_values	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
num_near_moves	int
;	O
unsigned	O
int	O
*	O
move_values	*(float)
;	O
unsigned	O
int	O
*	O
partition_sums	*(int)
;	O
int	O
*	O
partition_lists	*(int)
;	O
unsigned	O
int	O
*	O
move_value_sum	*(int)
;	O
unsigned	O
int	O
saved_ko_value	int
=	O
0	int
;	O
int	O
partition	int
;	O
int	O
move	*(int)
;	O
int	O
k	int
;	O
int	O
x	int
;	O
if	O
(	O
depth	int
>	O
600	int
)	O
{	O
if	O
(	O
mc_debug	int
)	O
{	O
int	O
pos	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reached 600 iterations.\n"	*(char)
)	O
;	O
mc_showboard	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
depth	int
;	O
k	int
++	O
)	O
gprintf	(*(char))->(int)
(	O
"%1m "	*(char)
,	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
move_history	array(int)
[	O
k	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"%1m "	*(char)
,	O
pos	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"white %7d black %7d white near %7d black near %7d\n"	*(char)
,	O
(	O
int	O
)	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_white	array(int)
[	O
pos	int
]	O
,	O
(	O
int	O
)	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_black	array(int)
[	O
pos	int
]	O
,	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
[	O
mc_find_pattern_number	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
WHITE	int
,	O
1	int
)	O
]	O
,	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
[	O
mc_find_pattern_number	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
BLACK	int
,	O
1	int
)	O
]	O
)	O
;	O
}	O
}	O
return	O
PASS_MOVE	int
;	O
}	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
move_values	*(float)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_white	array(int)
;	O
partition_sums	*(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_white	array(int)
;	O
partition_lists	*(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_white	array(int)
;	O
move_value_sum	*(int)
=	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_white	int
;	O
}	O
else	O
{	O
move_values	*(float)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_values_black	array(int)
;	O
partition_sums	*(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
partitioned_move_value_sums_black	array(int)
;	O
partition_lists	*(int)
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_partition_lists_black	array(int)
;	O
move_value_sum	*(int)
=	O
&	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
move_value_sum_black	int
;	O
}	O
num_near_moves	int
=	O
0	int
;	O
if	O
(	O
last_move	int
!=	O
PASS_MOVE	int
)	O
{	O
for	O
(	O
pos	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
0	int
]	O
;	O
pos	int
!=	O
1	int
;	O
pos	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
queue	array(int)
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
partition_lists	*(int)
[	O
pos	int
]	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
old_value	int
=	O
move_values	*(float)
[	O
pos	int
]	O
;	O
int	O
pattern	*(struct)
=	O
mc_find_pattern_number	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int,int)->(int)
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
pos	int
,	O
color	int
,	O
1	int
)	O
;	O
unsigned	O
int	O
new_value	int
=	O
mc_patterns	struct(array(short),array(int))
.	O
values	array(float)
[	O
pattern	*(struct)
]	O
;	O
partition	int
=	O
pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
saved_near_move_values	array(int)
[	O
num_near_moves	int
]	O
=	O
old_value	int
;	O
near_moves	array(int)
[	O
num_near_moves	int
++	O
]	O
=	O
pos	int
;	O
move_values	*(float)
[	O
pos	int
]	O
=	O
new_value	int
;	O
partition_sums	*(int)
[	O
partition	int
]	O
+=	O
new_value	int
-	O
old_value	int
;	O
*	O
move_value_sum	*(int)
+=	O
new_value	int
-	O
old_value	int
;	O
}	O
}	O
}	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
WEST	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
EAST	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
partition	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
saved_ko_value	int
=	O
move_values	*(float)
[	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
]	O
;	O
move_values	*(float)
[	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
]	O
=	O
0	int
;	O
partition_sums	*(int)
[	O
partition	int
]	O
-=	O
saved_ko_value	int
;	O
*	O
move_value_sum	*(int)
-=	O
saved_ko_value	int
;	O
}	O
}	O
if	O
(	O
*	O
move_value_sum	*(int)
==	O
0	int
)	O
move	*(int)
=	O
PASS_MOVE	int
;	O
else	O
{	O
x	int
=	O
(	O
int	O
)	O
(	O
gg_drand	()->(double)
(	O
)	O
*	O
*	O
move_value_sum	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_MOVE_PARTITIONS	int
;	O
k	int
++	O
)	O
{	O
x	int
-=	O
partition_sums	*(int)
[	O
k	int
]	O
;	O
if	O
(	O
x	int
<	O
0	int
)	O
break	O
;	O
}	O
x	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
gg_drand	()->(double)
(	O
)	O
*	O
partition_sums	*(int)
[	O
k	int
]	O
)	O
;	O
for	O
(	O
pos	int
=	O
partition_lists	*(int)
[	O
k	int
]	O
;	O
pos	int
!=	O
1	int
;	O
pos	int
=	O
partition_lists	*(int)
[	O
pos	int
]	O
)	O
{	O
x	int
-=	O
move_values	*(float)
[	O
pos	int
]	O
;	O
if	O
(	O
x	int
<	O
0	int
)	O
break	O
;	O
}	O
move	*(int)
=	O
pos	int
;	O
}	O
if	O
(	O
saved_ko_value	int
>	O
0	int
)	O
{	O
partition	int
=	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
partition_sums	*(int)
[	O
partition	int
]	O
+=	O
saved_ko_value	int
-	O
move_values	*(float)
[	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
]	O
;	O
*	O
move_value_sum	*(int)
+=	O
saved_ko_value	int
-	O
move_values	*(float)
[	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
]	O
;	O
move_values	*(float)
[	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board_ko_pos	int
]	O
=	O
saved_ko_value	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_near_moves	int
;	O
k	int
++	O
)	O
{	O
unsigned	O
int	O
old_value	int
;	O
unsigned	O
int	O
new_value	int
;	O
pos	int
=	O
near_moves	array(int)
[	O
k	int
]	O
;	O
partition	int
=	O
pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
old_value	int
=	O
move_values	*(float)
[	O
pos	int
]	O
;	O
new_value	int
=	O
saved_near_move_values	array(int)
[	O
k	int
]	O
;	O
move_values	*(float)
[	O
pos	int
]	O
=	O
new_value	int
;	O
partition_sums	*(int)
[	O
partition	int
]	O
+=	O
new_value	int
-	O
old_value	int
;	O
*	O
move_value_sum	*(int)
+=	O
new_value	int
-	O
old_value	int
;	O
}	O
return	O
move	*(int)
;	O
}	O
static	O
int	O
mc_play_random_move	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)),int)->(int)
(	O
struct	O
mc_game	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
*	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
,	O
int	O
move	*(int)
)	O
{	O
int	O
result	int
=	O
mc_play_move	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))),int,int)->(int)
(	O
&	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
,	O
move	*(int)
,	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
color_to_move	int
)	O
;	O
mc_update_move_values	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))))->(void)
(	O
&	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
)	O
;	O
if	O
(	O
result	int
)	O
{	O
if	O
(	O
is_pass	(int)->(int)
(	O
move	*(int)
)	O
)	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
consecutive_passes	int
++	O
;	O
else	O
{	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
consecutive_passes	int
=	O
0	int
;	O
}	O
if	O
(	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
.	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
consecutive_ko_captures	int
++	O
;	O
else	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
consecutive_ko_captures	int
=	O
0	int
;	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
move_history	array(int)
[	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
depth	int
]	O
=	O
move	*(int)
;	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
last_move	int
=	O
move	*(int)
;	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
color_to_move	int
=	O
OTHER_COLOR	O
(	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
color_to_move	int
)	O
;	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
depth	int
++	O
;	O
}	O
return	O
result	int
;	O
}	O
static	O
int	O
mc_play_random_game	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)))->(int)
(	O
struct	O
mc_game	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
*	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
)	O
{	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
=	O
&	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
;	O
int	O
score	float
=	O
0	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
result	int
;	O
int	O
move	*(int)
;	O
while	O
(	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
consecutive_passes	int
<	O
3	int
)	O
{	O
move	*(int)
=	O
mc_generate_random_move	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)))->(int)
(	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
)	O
;	O
result	int
=	O
mc_play_random_move	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)),int)->(int)
(	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
,	O
move	*(int)
)	O
;	O
ASSERT1	O
(	O
result	int
,	O
move	*(int)
)	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
MC_ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
settled	array(char)
[	O
pos	int
]	O
==	O
WHITE	int
)	O
score	float
++	O
;	O
else	O
if	O
(	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
->	O
settled	array(char)
[	O
pos	int
]	O
==	O
BLACK	int
)	O
score	float
--	O
;	O
else	O
{	O
int	O
pos2	int
=	O
pos	int
;	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
)	O
)	O
break	O
;	O
}	O
score	float
+=	O
2	int
*	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
==	O
WHITE	int
)	O
-	O
1	int
;	O
}	O
}	O
return	O
score	float
;	O
}	O
struct	O
bitboard	struct(array(int))
{	O
unsigned	O
int	O
bits	array(int)
[	O
1	int
+	O
BOARDMAX	O
/	O
32	int
]	O
;	O
}	O
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
{	O
int	O
move	*(int)
;	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
;	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
{	O
int	O
wins	int
;	O
int	O
games	int
;	O
float	O
sum_scores	float
;	O
float	O
sum_scores2	float
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
struct	O
bitboard	struct(array(int))
untested	struct(array(int))
;	O
Hash_data	struct(array(long))
boardhash	struct(array(long))
;	O
}	O
;	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
{	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
nodes	int
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
unsigned	O
int	O
*	O
hashtable_odd	*(int)
;	O
unsigned	O
int	O
*	O
hashtable_even	*(int)
;	O
unsigned	O
int	O
hashtable_size	int
;	O
int	O
num_nodes	int
;	O
int	O
num_used_nodes	int
;	O
int	O
num_arcs	int
;	O
int	O
num_used_arcs	int
;	O
int	O
*	O
forbidden_moves	*(int)
;	O
struct	O
mc_game	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
;	O
int	O
move_score	array(int)
[	O
BOARDSIZE	O
]	O
;	O
int	O
move_ordering	array(int)
[	O
BOARDSIZE	O
]	O
;	O
int	O
inverse_move_ordering	array(int)
[	O
BOARDSIZE	O
]	O
;	O
int	O
num_ordered_moves	int
;	O
}	O
;	O
static	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
uct_init_node	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(int))->(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))))
(	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
*	O
allowed_moves	array(int)
)	O
{	O
int	O
pos	int
;	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	int
[	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
num_used_nodes	int
++	O
]	O
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
wins	int
=	O
0	int
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
=	O
0	int
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sum_scores	float
=	O
0.0	int
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sum_scores2	float
=	O
0.0	int
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
untested	struct(array(int))
.	O
bits	array(int)
,	O
0	int
,	O
sizeof	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
untested	struct(array(int))
.	O
bits	array(int)
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
.	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
!	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
forbidden_moves	*(int)
[	O
pos	int
]	O
&&	O
(	O
!	O
allowed_moves	array(int)
||	O
allowed_moves	array(int)
[	O
pos	int
]	O
)	O
)	O
{	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
untested	struct(array(int))
.	O
bits	array(int)
[	O
pos	int
/	O
32	int
]	O
|=	O
1	int
<<	O
pos	int
%	O
32	int
;	O
}	O
}	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
boardhash	struct(array(long))
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
.	O
hash	struct(array(long))
;	O
return	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
static	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
uct_find_node	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),int)->(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))))
(	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
move	*(int)
)	O
{	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
Hash_data	struct(array(long))
*	O
boardhash	struct(array(long))
=	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
.	O
hash	struct(array(long))
;	O
unsigned	O
int	O
hash_index	int
=	O
hashdata_remainder	O
(	O
*	O
boardhash	struct(array(long))
,	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
hashtable_size	int
)	O
;	O
unsigned	O
int	O
*	O
hashtable	*(int)
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
hashtable_even	*(int)
;	O
if	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
depth	int
&	O
1	int
)	O
hashtable	*(int)
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
hashtable_odd	*(int)
;	O
while	O
(	O
hashtable	*(int)
[	O
hash_index	int
]	O
!=	O
0	int
)	O
{	O
int	O
node_index	int
=	O
hashtable	*(int)
[	O
hash_index	int
]	O
;	O
gg_assert	O
(	O
node_index	int
>	O
0	int
&&	O
node_index	int
<	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
num_nodes	int
)	O
;	O
if	O
(	O
hashdata_is_equal	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	int
[	O
node_index	int
]	O
.	O
boardhash	struct(array(long))
,	O
*	O
boardhash	struct(array(long))
)	O
)	O
{	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	int
[	O
node_index	int
]	O
;	O
break	O
;	O
}	O
hash_index	int
++	O
;	O
if	O
(	O
hash_index	int
>=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
hashtable_size	int
)	O
hash_index	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
uct_init_node	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(int))->(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))))
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
NULL	O
)	O
;	O
gg_assert	O
(	O
hash_index	int
<	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
hashtable_size	int
)	O
;	O
hashtable	*(int)
[	O
hash_index	int
]	O
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
-	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	int
;	O
}	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
[	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
num_used_arcs	int
++	O
]	O
;	O
gg_assert	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
num_used_arcs	int
<	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
num_arcs	int
)	O
;	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
=	O
move	*(int)
;	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
else	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
NULL	O
;	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
}	O
return	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
static	O
void	O
uct_update_move_ordering	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),int)->(void)
(	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
move	*(int)
)	O
{	O
int	O
score	float
=	O
++	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_score	array(int)
[	O
move	*(int)
]	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
n	int
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
inverse_move_ordering	array(int)
[	O
move	*(int)
]	O
;	O
int	O
preceding_move	int
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
preceding_move	int
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_ordering	array(int)
[	O
n	int
-	O
1	int
]	O
;	O
if	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_score	array(int)
[	O
preceding_move	int
]	O
>=	O
score	float
)	O
return	O
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_ordering	array(int)
[	O
n	int
-	O
1	int
]	O
=	O
move	*(int)
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_ordering	array(int)
[	O
n	int
]	O
=	O
preceding_move	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
inverse_move_ordering	array(int)
[	O
move	*(int)
]	O
=	O
n	int
-	O
1	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
inverse_move_ordering	array(int)
[	O
preceding_move	int
]	O
=	O
n	int
;	O
}	O
}	O
static	O
void	O
uct_init_move_ordering	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)))->(void)
(	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_score	array(int)
,	O
0	int
,	O
sizeof	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_score	array(int)
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_ordering	array(int)
[	O
k	int
]	O
=	O
pos	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
inverse_move_ordering	array(int)
[	O
pos	int
]	O
=	O
k	int
;	O
k	int
++	O
;	O
}	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
num_ordered_moves	int
=	O
k	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_score	array(int)
[	O
pos	int
]	O
=	O
(	O
int	O
)	O
(	O
10	int
*	O
potential_moves	array(float)
[	O
pos	int
]	O
)	O
-	O
1	int
;	O
uct_update_move_ordering	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),int)->(void)
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
pos	int
)	O
;	O
}	O
}	O
}	O
static	O
float	O
uct_finish_and_score_game	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)))->(float)
(	O
struct	O
mc_game	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
*	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
)	O
{	O
return	O
komi	float
+	O
mc_play_random_game	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)))->(int)
(	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
)	O
;	O
}	O
static	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
uct_play_move	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),float,*(float),*(int))->(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))))
(	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
float	O
alpha	float
,	O
float	O
*	O
gamma	(double)->(double)
,	O
int	O
*	O
move	*(int)
)	O
{	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
int	O
pos	int
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
next_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
best_winrate_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
float	O
best_uct_value	float
=	O
0.0	int
;	O
float	O
best_winrate	float
=	O
0.0	int
;	O
for	O
(	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
float	O
winrate	float
=	O
(	O
float	O
)	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
wins	int
/	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
;	O
float	O
uct_value	float
;	O
float	O
log_games_ratio	float
=	O
log	(double)->(double)
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
)	O
/	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
;	O
float	O
x	int
=	O
winrate	float
*	O
(	O
1.0	int
-	O
winrate	float
)	O
+	O
sqrt	(double)->(double)
(	O
2.0	int
*	O
log_games_ratio	float
)	O
;	O
if	O
(	O
x	int
<	O
0.25	int
)	O
x	int
=	O
0.25	int
;	O
uct_value	float
=	O
winrate	float
+	O
sqrt	(double)->(double)
(	O
2	int
*	O
log_games_ratio	float
*	O
x	int
/	O
(	O
1	int
+	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
depth	int
)	O
)	O
;	O
if	O
(	O
uct_value	float
>	O
best_uct_value	float
)	O
{	O
next_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
best_uct_value	float
=	O
uct_value	float
;	O
}	O
if	O
(	O
winrate	float
>	O
best_winrate	float
)	O
{	O
best_winrate_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
best_winrate	float
=	O
winrate	float
;	O
}	O
}	O
*	O
gamma	(double)->(double)
=	O
best_winrate	float
;	O
if	O
(	O
best_winrate	float
>	O
alpha	float
)	O
next_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
best_winrate_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
else	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
-	O
1	int
;	O
k	int
<	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
num_ordered_moves	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
==	O
-	O
1	int
&&	O
best_uct_value	float
>	O
0.0	int
)	O
continue	O
;	O
else	O
if	O
(	O
k	int
==	O
-	O
1	int
)	O
pos	int
=	O
mc_generate_random_move	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)))->(int)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
)	O
;	O
else	O
pos	int
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
move_ordering	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
untested	struct(array(int))
.	O
bits	array(int)
[	O
pos	int
/	O
32	int
]	O
&	O
(	O
1	int
<<	O
(	O
pos	int
%	O
32	int
)	O
)	O
)	O
{	O
int	O
r	int
;	O
int	O
proper_small_eye	int
=	O
1	int
;	O
struct	O
mc_board	struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))
*	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
=	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
;	O
*	O
move	*(int)
=	O
pos	int
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
untested	struct(array(int))
.	O
bits	array(int)
[	O
*	O
move	*(int)
/	O
32	int
]	O
&=	O
~	O
(	O
1	int
<<	O
*	O
move	*(int)
%	O
32	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
r	int
]	O
]	O
==	O
EMPTY	int
||	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
r	int
]	O
]	O
==	O
OTHER_COLOR	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
color_to_move	int
)	O
)	O
{	O
proper_small_eye	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
proper_small_eye	int
)	O
{	O
int	O
diagonal_value	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
4	int
;	O
r	int
<	O
8	int
;	O
r	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
r	int
]	O
;	O
if	O
(	O
!	O
MC_ON_BOARD	O
(	O
pos2	int
)	O
)	O
diagonal_value	int
++	O
;	O
else	O
if	O
(	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
->	O
board	*(char)
[	O
pos2	int
]	O
==	O
OTHER_COLOR	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
color_to_move	int
)	O
)	O
diagonal_value	int
+=	O
2	int
;	O
}	O
if	O
(	O
diagonal_value	int
>	O
3	int
)	O
proper_small_eye	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
proper_small_eye	int
&&	O
mc_play_random_move	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)),int)->(int)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
,	O
*	O
move	*(int)
)	O
)	O
return	O
uct_find_node	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),int)->(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))))
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
*	O
move	*(int)
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
next_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
)	O
{	O
mc_play_random_move	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)),int)->(int)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
,	O
PASS_MOVE	int
)	O
;	O
*	O
move	*(int)
=	O
PASS_MOVE	int
;	O
return	O
uct_find_node	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),int)->(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))))
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
PASS_MOVE	int
)	O
;	O
}	O
*	O
move	*(int)
=	O
next_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
;	O
mc_play_random_move	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)),int)->(int)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
,	O
next_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
)	O
;	O
return	O
next_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
static	O
float	O
uct_traverse_tree	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),float,float)->(float)
(	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
float	O
alpha	float
,	O
float	O
beta	float
)	O
{	O
int	O
color	int
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
color_to_move	int
;	O
int	O
num_passes	int
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
consecutive_passes	int
;	O
float	O
result	int
;	O
float	O
gamma	(double)->(double)
;	O
int	O
move	*(int)
=	O
PASS_MOVE	int
;	O
if	O
(	O
num_passes	int
==	O
3	int
||	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
.	O
depth	int
>=	O
UCT_MAX_SEARCH_DEPTH	O
||	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
==	O
0	int
&&	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	int
)	O
)	O
result	int
=	O
uct_finish_and_score_game	(*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)))->(float)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
)	O
;	O
else	O
{	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
next_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
;	O
next_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
=	O
uct_play_move	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),float,*(float),*(int))->(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))))
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
alpha	float
,	O
&	O
gamma	(double)->(double)
,	O
&	O
move	*(int)
)	O
;	O
gamma	(double)->(double)
+=	O
0.00	int
;	O
if	O
(	O
gamma	(double)->(double)
>	O
0.8	int
)	O
gamma	(double)->(double)
=	O
0.8	int
;	O
result	int
=	O
uct_traverse_tree	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),float,float)->(float)
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
next_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
,	O
beta	float
,	O
gamma	(double)->(double)
)	O
;	O
}	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
++	O
;	O
if	O
(	O
(	O
result	int
>	O
0	int
)	O
^	O
(	O
color	int
==	O
WHITE	int
)	O
)	O
{	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
wins	int
++	O
;	O
if	O
(	O
move	*(int)
!=	O
PASS_MOVE	int
)	O
uct_update_move_ordering	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),int)->(void)
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
move	*(int)
)	O
;	O
}	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sum_scores	float
+=	O
result	int
;	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
sum_scores2	float
+=	O
result	int
*	O
result	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
uct_find_best_children	(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),*(*(struct(int,*(struct`),*(struct`)))),int)->(int)
(	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
*	O
children	*(*(struct(int,*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)))))
,	O
int	O
n	int
)	O
{	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
float	O
best_score	float
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
best_child	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
int	O
found_moves	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
k	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
found_moves	array(int)
,	O
0	int
,	O
sizeof	O
(	O
found_moves	array(int)
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
best_score	float
=	O
0.0	int
;	O
best_child	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
for	O
(	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
!	O
found_moves	array(int)
[	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
]	O
&&	O
best_score	float
*	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
<	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
wins	int
)	O
{	O
best_child	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
best_score	float
=	O
(	O
float	O
)	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
wins	int
/	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
;	O
}	O
}	O
if	O
(	O
!	O
best_child	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
)	O
break	O
;	O
children	*(*(struct(int,*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)))))
[	O
k	int
]	O
=	O
best_child	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
found_moves	array(int)
[	O
best_child	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
]	O
=	O
1	int
;	O
}	O
return	O
k	int
;	O
}	O
static	O
void	O
uct_dump_tree_recursive	(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,int,int)->(void)
(	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
int	O
color	int
,	O
int	O
cutoff	int
,	O
int	O
depth	int
)	O
{	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
if	O
(	O
depth	int
>	O
50	int
)	O
return	O
;	O
for	O
(	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
=	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
sgftreeAddPlayLast	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,int,int)->(void)
(	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
color	int
,	O
I	O
(	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
)	O
,	O
J	O
(	O
child_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
)	O
)	O
;	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
buf	*(char)
,	O
100	int
,	O
"%d/%d (%5.3f)"	*(char)
,	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
wins	int
,	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
,	O
(	O
float	O
)	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
wins	int
/	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
if	O
(	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
>=	O
cutoff	int
)	O
uct_dump_tree_recursive	(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,int,int)->(void)
(	O
child_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
,	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
cutoff	int
,	O
depth	int
+	O
1	int
)	O
;	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
lastnode	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
lastnode	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
}	O
static	O
void	O
uct_dump_tree	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(char),int,int)->(void)
(	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
const	O
char	O
*	O
filename	*(char)
,	O
int	O
color	int
,	O
int	O
cutoff	int
)	O
{	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
sgftree_clear	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(void)
(	O
&	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
sgftreeCreateHeaderNode	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,float,int)->(void)
(	O
&	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
board_size	int
,	O
komi	float
,	O
0	int
)	O
;	O
sgffile_printboard	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(void)
(	O
&	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
uct_dump_tree_recursive	(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,int,int)->(void)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
nodes	int
[	O
0	int
]	O
,	O
&	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
color	int
,	O
cutoff	int
,	O
0	int
)	O
;	O
writesgf	(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(int)
(	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
root	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
filename	*(char)
)	O
;	O
sgfFreeNode	(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(void)
(	O
sgf_tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
root	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
void	O
uct_genmove	(int,*(int),*(int),*(int),int,*(float),*(int))->(void)
(	O
int	O
color	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
forbidden_moves	*(int)
,	O
int	O
*	O
allowed_moves	array(int)
,	O
int	O
nodes	int
,	O
float	O
*	O
move_values	*(float)
,	O
int	O
*	O
move_frequencies	*(int)
)	O
{	O
struct	O
uct_tree	struct(*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long)))),*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
float	O
best_score	float
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
struct	O
mc_game	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
;	O
int	O
most_games	int
;	O
struct	O
uct_node	struct(int,int,float,float,*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`))))),struct(array(int)),struct(array(long)))
*	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
most_games_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
int	O
pos	int
;	O
mc_init_board_from_global_board	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))))->(void)
(	O
&	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
.	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
)	O
;	O
mc_init_move_values	(*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long)))))->(void)
(	O
&	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
.	O
mc	*(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))))
)	O
;	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
.	O
color_to_move	int
=	O
color	int
;	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
.	O
consecutive_passes	int
=	O
0	int
;	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
.	O
consecutive_ko_captures	int
=	O
0	int
;	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
.	O
last_move	int
=	O
get_last_move	()->(int)
(	O
)	O
;	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
.	O
depth	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
.	O
settled	array(char)
[	O
pos	int
]	O
=	O
forbidden_moves	*(int)
[	O
pos	int
]	O
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
=	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
=	O
malloc	(long)->(*(void))
(	O
nodes	int
*	O
sizeof	O
(	O
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
)	O
)	O
;	O
gg_assert	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
)	O
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
nodes	int
*	O
sizeof	O
(	O
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
)	O
)	O
;	O
gg_assert	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
)	O
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_size	int
=	O
nodes	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_odd	*(int)
=	O
calloc	(long,long)->(*(void))
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_size	int
,	O
sizeof	O
(	O
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_odd	*(int)
)	O
)	O
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_even	*(int)
=	O
calloc	(long,long)->(*(void))
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_size	int
,	O
sizeof	O
(	O
*	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_even	*(int)
)	O
)	O
;	O
gg_assert	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_odd	*(int)
)	O
;	O
gg_assert	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_even	*(int)
)	O
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
num_nodes	int
=	O
nodes	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
num_arcs	int
=	O
nodes	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
num_used_nodes	int
=	O
0	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
num_used_arcs	int
=	O
0	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
forbidden_moves	*(int)
=	O
forbidden_moves	*(int)
;	O
uct_init_node	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(int))->(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))))
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
allowed_moves	array(int)
)	O
;	O
uct_init_move_ordering	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)))->(void)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
while	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
num_used_arcs	int
<	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
num_arcs	int
-	O
10	int
)	O
{	O
int	O
last_used_arcs	int
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
num_used_arcs	int
;	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
game	*(struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int))
=	O
starting_position	struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct(array(long))),array(int),array(char),int,int,int,int,int)
;	O
uct_traverse_tree	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),float,float)->(float)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
[	O
0	int
]	O
,	O
1.0	int
,	O
0.9	int
)	O
;	O
if	O
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
num_used_arcs	int
==	O
last_used_arcs	int
)	O
break	O
;	O
}	O
best_score	float
=	O
0.0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	int
;	O
for	O
(	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
[	O
0	int
]	O
.	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
move_frequencies	*(int)
[	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
]	O
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
;	O
move_values	*(float)
[	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
]	O
=	O
(	O
float	O
)	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
wins	int
/	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
;	O
if	O
(	O
best_score	float
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
<	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
wins	int
)	O
{	O
*	O
move	*(int)
=	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
;	O
best_score	float
=	O
(	O
float	O
)	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
wins	int
/	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
;	O
}	O
}	O
if	O
(	O
0	int
)	O
uct_dump_tree	(*(struct(*(struct(int,int,float,float,*`,struct`,struct`)),*(struct(int,*`,*`)),*(int),*(int),int,int,int,int,int,*(int),struct(struct(array(char),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),int,int,int,array(int),array(int),array(int),array(int),array(int),struct`),array(int),array(char),int,int,int,int,int),array(int),array(int),array(int),int)),*(char),int,int)->(void)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
"/tmp/ucttree.sgf"	*(char)
,	O
color	int
,	O
50	int
)	O
;	O
if	O
(	O
mc_debug	int
)	O
{	O
while	O
(	O
1	int
)	O
{	O
float	O
mean	float
;	O
float	O
std	float
;	O
most_games	int
=	O
0	int
;	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
=	O
NULL	O
;	O
most_games_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
for	O
(	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
[	O
0	int
]	O
.	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
{	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
most_games	int
<	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
)	O
{	O
most_games	int
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
;	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
=	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
most_games_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
}	O
}	O
if	O
(	O
most_games	int
==	O
0	int
)	O
break	O
;	O
mean	float
=	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
sum_scores	float
/	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
;	O
std	float
=	O
sqrt	(double)->(double)
(	O
(	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
sum_scores2	float
-	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
sum_scores	float
*	O
mean	float
)	O
/	O
(	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
-	O
1	int
)	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%1m "	*(char)
,	O
most_games_arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
move	*(int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%6d %6d %5.3f %5.3f %5.3f %5.3f\n"	*(char)
,	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
wins	int
,	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
,	O
(	O
float	O
)	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
wins	int
/	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
,	O
mean	float
,	O
std	float
,	O
mean	float
/	O
(	O
std	float
+	O
0.001	int
)	O
)	O
;	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
=	O
-	O
most_games_node	*(struct(int,int,float,float,*(struct(int,*(struct`),*(struct`))),struct(array(int)),struct(array(long))))
->	O
games	int
;	O
}	O
for	O
(	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
[	O
0	int
]	O
.	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
;	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
=	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
=	O
-	O
arc	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
;	O
{	O
int	O
n	int
;	O
struct	O
uct_arc	struct(int,*(struct),*(struct(int,*(struct),*(struct(int,*(struct`),*(struct`))))))
*	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
[	O
7	int
]	O
;	O
int	O
depth	int
=	O
0	int
;	O
n	int
=	O
uct_find_best_children	(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),*(*(struct(int,*(struct`),*(struct`)))),int)->(int)
(	O
&	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
[	O
0	int
]	O
,	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
,	O
7	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"Principal variation:\n"	*(char)
)	O
;	O
while	O
(	O
n	int
>	O
0	int
&&	O
depth	int
<	O
80	int
)	O
{	O
int	O
k	int
;	O
gprintf	(*(char))->(int)
(	O
"%C "	*(char)
,	O
color	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
[	O
k	int
]	O
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
gprintf	(*(char))->(int)
(	O
"%1m "	*(char)
,	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
[	O
k	int
]	O
->	O
move	*(int)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%5.3f"	*(char)
,	O
(	O
float	O
)	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
wins	int
/	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
" (%d games)"	*(char)
,	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
games	int
)	O
;	O
if	O
(	O
k	int
<	O
n	int
-	O
1	int
)	O
gprintf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
}	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
color	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
n	int
=	O
uct_find_best_children	(*(struct(int,int,float,float,*(struct(int,*`,*`)),struct(array(int)),struct(array(long)))),*(*(struct(int,*(struct`),*(struct`)))),int)->(int)
(	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
[	O
0	int
]	O
->	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
,	O
7	int
)	O
;	O
depth	int
++	O
;	O
}	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
nodes	int
)	O
;	O
free	(*(void))->(void)
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
arcs	*(struct(int,*(struct(int,int,float,float,*(struct`),struct(array(int)),struct(array(long)))),*(struct(int,*(struct`),*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_odd	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
tree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
.	O
hashtable_even	*(int)
)	O
;	O
}	O
