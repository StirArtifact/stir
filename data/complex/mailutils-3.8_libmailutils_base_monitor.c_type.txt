pthread_mutex_t	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
monitor_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
union	O
_p_lock	union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))
{	O
pthread_rwlock_t	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
mutex	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
;	O
}	O
;	O
typedef	O
union	O
_p_lock	union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))
*	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
;	O
static	O
int	O
monitor_pthread_create	(*(*(union(union(struct`,array(char),long)))))->(int)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
*	O
)	O
;	O
static	O
void	O
monitor_pthread_destroy	(*(*(union(union(struct`,array(char),long)))))->(void)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
*	O
)	O
;	O
static	O
int	O
monitor_pthread_rdlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
;	O
static	O
int	O
monitor_pthread_wrlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
;	O
static	O
int	O
monitor_pthread_unlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
;	O
int	O
mu_monitor_create	(*(*(struct(*(void),*(void),int,int))),int,*(void))->(int)
(	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
*	O
pmonitor	*(*(struct(*(void),*(void),int,int)))
,	O
int	O
flags	int
,	O
void	O
*	O
owner	*(void)
)	O
{	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
monitor	*(struct(*(void),*(void),int,int))
;	O
if	O
(	O
pmonitor	*(*(struct(*(void),*(void),int,int)))
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
monitor	*(struct(*(void),*(void),int,int))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
monitor	*(struct(*(void),*(void),int,int))
)	O
)	O
;	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
{	O
int	O
status	int
=	O
monitor_pthread_create	(*(*(union(union(struct`,array(char),long)))))->(int)
(	O
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
*	O
)	O
&	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
)	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
monitor	*(struct(*(void),*(void),int,int))
)	O
;	O
return	O
status	int
;	O
}	O
}	O
monitor	*(struct(*(void),*(void),int,int))
->	O
owner	*(void)
=	O
owner	*(void)
;	O
monitor	*(struct(*(void),*(void),int,int))
->	O
allocated	int
=	O
1	int
;	O
monitor	*(struct(*(void),*(void),int,int))
->	O
flags	int
=	O
flags	int
;	O
*	O
pmonitor	*(*(struct(*(void),*(void),int,int)))
=	O
monitor	*(struct(*(void),*(void),int,int))
;	O
return	O
0	int
;	O
}	O
void	O
*	O
mu_monitor_get_owner	(*(struct(*(void),*(void),int,int)))->(*(void))
(	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
monitor	*(struct(*(void),*(void),int,int))
)	O
{	O
return	O
(	O
monitor	*(struct(*(void),*(void),int,int))
==	O
NULL	O
)	O
?	O
NULL	O
:	O
monitor	*(struct(*(void),*(void),int,int))
->	O
owner	*(void)
;	O
}	O
void	O
mu_monitor_destroy	(*(*(struct(*(void),*(void),int,int))),*(void))->(void)
(	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
*	O
pmonitor	*(*(struct(*(void),*(void),int,int)))
,	O
void	O
*	O
owner	*(void)
)	O
{	O
if	O
(	O
pmonitor	*(*(struct(*(void),*(void),int,int)))
&&	O
*	O
pmonitor	*(*(struct(*(void),*(void),int,int)))
)	O
{	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
monitor	*(struct(*(void),*(void),int,int))
=	O
*	O
pmonitor	*(*(struct(*(void),*(void),int,int)))
;	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
owner	*(void)
==	O
owner	*(void)
)	O
{	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
monitor_pthread_destroy	(*(*(union(union(struct`,array(char),long)))))->(void)
(	O
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
*	O
)	O
&	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
monitor	*(struct(*(void),*(void),int,int))
)	O
;	O
*	O
pmonitor	*(*(struct(*(void),*(void),int,int)))
=	O
NULL	O
;	O
}	O
}	O
int	O
mu_monitor_rdlock	(*(struct(*(void),*(void),int,int)))->(int)
(	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
monitor	*(struct(*(void),*(void),int,int))
)	O
{	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
)	O
{	O
if	O
(	O
!	O
monitor	*(struct(*(void),*(void),int,int))
->	O
allocated	int
)	O
{	O
int	O
status	int
=	O
STATIC_LOCK	O
(	O
&	O
monitor_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
==	O
NULL	O
)	O
{	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
status	int
=	O
monitor_pthread_create	(*(*(union(union(struct`,array(char),long)))))->(int)
(	O
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
*	O
)	O
&	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
)	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
STATIC_UNLOCK	O
(	O
&	O
monitor_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
status	int
;	O
}	O
}	O
monitor	*(struct(*(void),*(void),int,int))
->	O
allocated	int
=	O
1	int
;	O
STATIC_UNLOCK	O
(	O
&	O
monitor_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
return	O
monitor_pthread_rdlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_monitor_wrlock	(*(struct(*(void),*(void),int,int)))->(int)
(	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
monitor	*(struct(*(void),*(void),int,int))
)	O
{	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
)	O
{	O
if	O
(	O
!	O
monitor	*(struct(*(void),*(void),int,int))
->	O
allocated	int
)	O
{	O
int	O
status	int
=	O
STATIC_LOCK	O
(	O
&	O
monitor_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
==	O
NULL	O
)	O
{	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
status	int
=	O
monitor_pthread_create	(*(*(union(union(struct`,array(char),long)))))->(int)
(	O
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
*	O
)	O
&	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
)	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
STATIC_UNLOCK	O
(	O
&	O
monitor_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
status	int
;	O
}	O
}	O
monitor	*(struct(*(void),*(void),int,int))
->	O
allocated	int
=	O
1	int
;	O
STATIC_UNLOCK	O
(	O
&	O
monitor_lock	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
}	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
return	O
monitor_pthread_wrlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_monitor_unlock	(*(struct(*(void),*(void),int,int)))->(int)
(	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
monitor	*(struct(*(void),*(void),int,int))
)	O
{	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
)	O
{	O
if	O
(	O
monitor	*(struct(*(void),*(void),int,int))
->	O
flags	int
==	O
MU_MONITOR_PTHREAD	int
)	O
return	O
monitor_pthread_unlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
monitor	*(struct(*(void),*(void),int,int))
->	O
data	*(void)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_monitor_wait	(*(struct(*(void),*(void),int,int)))->(int)
(	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
monitor	*(struct(*(void),*(void),int,int))
MU_ARG_UNUSED	O
)	O
{	O
return	O
ENOSYS	int
;	O
}	O
int	O
mu_monitor_notify	(*(struct(*(void),*(void),int,int)))->(int)
(	O
mu_monitor_t	*(struct(*(void),*(void),int,int))
monitor	*(struct(*(void),*(void),int,int))
MU_ARG_UNUSED	O
)	O
{	O
return	O
ENOSYS	int
;	O
}	O
static	O
int	O
monitor_pthread_create	(*(*(union(union(struct`,array(char),long)))))->(int)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
*	O
plock	*(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))
)	O
{	O
int	O
status	int
;	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
)	O
;	O
if	O
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
status	int
=	O
RWLOCK_INIT	O
(	O
&	O
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
->	O
mutex	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
;	O
return	O
status	int
;	O
}	O
*	O
plock	*(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))
=	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
;	O
return	O
0	int
;	O
}	O
static	O
void	O
monitor_pthread_destroy	(*(*(union(union(struct`,array(char),long)))))->(void)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
*	O
plock	*(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))
)	O
{	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
=	O
*	O
plock	*(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))
;	O
if	O
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
{	O
RWLOCK_DESTROY	O
(	O
&	O
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
->	O
mutex	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
;	O
}	O
*	O
plock	*(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))
=	O
NULL	O
;	O
}	O
static	O
int	O
monitor_pthread_rdlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
{	O
return	O
RWLOCK_RDLOCK	O
(	O
&	O
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
->	O
mutex	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
)	O
;	O
}	O
static	O
int	O
monitor_pthread_wrlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
{	O
return	O
RWLOCK_WRLOCK	O
(	O
&	O
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
->	O
mutex	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
)	O
;	O
}	O
static	O
int	O
monitor_pthread_unlock	(*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long))))->(int)
(	O
p_lock_t	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
)	O
{	O
return	O
RWLOCK_UNLOCK	O
(	O
&	O
(	O
lock	*(union(union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)))
->	O
mutex	union(struct(int,int,int,int,int,int,int,int,char,array(char),long,int),array(char),long)
)	O
)	O
;	O
}	O
