typedef	O
off_t	long
scm_t_off	long
;	O
struct	O
apply_data	struct(int,int)
{	O
SCM	(*(int))->((*(void))->(int))
proc	int
;	O
SCM	(*(int))->((*(void))->(int))
arg	int
;	O
}	O
;	O
SCM	(*(int))->((*(void))->(int))
apply_catch_body	(*(void))->(int)
(	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
apply_data	struct(int,int)
*	O
xp	*(struct(int,int))
=	O
data	*(void)
;	O
return	O
scm_apply_0	()->(int)
(	O
xp	*(struct(int,int))
->	O
proc	int
,	O
xp	*(struct(int,int))
->	O
arg	int
)	O
;	O
}	O
static	O
SCM	(*(int))->((*(void))->(int))
eval_catch_handler	(*(void),int,int)->(int)
(	O
void	O
*	O
data	*(void)
,	O
SCM	(*(int))->((*(void))->(int))
tag	int
,	O
SCM	(*(int))->((*(void))->(int))
throw_args	int
)	O
{	O
scm_handle_by_message_noexit	()->(int)
(	O
"dico"	*(char)
,	O
tag	int
,	O
throw_args	int
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
*	O
(	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
*	O
)	O
data	*(void)
,	O
1	int
)	O
;	O
}	O
struct	O
scheme_exec_data	struct((*(int))->((*(void))->(int)),*(void),int)
{	O
SCM	(*(int))->((*(void))->(int))
(	O
*	O
handler	*(int)
)	O
(	O
void	O
*	O
data	*(void)
)	O
;	O
void	O
*	O
data	*(void)
;	O
SCM	(*(int))->((*(void))->(int))
result	*(int)
;	O
}	O
;	O
static	O
SCM	(*(int))->((*(void))->(int))
scheme_safe_exec_body	(*(void))->(int)
(	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
scheme_exec_data	struct((*(int))->((*(void))->(int)),*(void),int)
*	O
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
=	O
data	*(void)
;	O
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
->	O
result	*(int)
=	O
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
->	O
handler	*(int)
(	O
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
->	O
data	*(void)
)	O
;	O
return	O
SCM_BOOL_F	O
;	O
}	O
static	O
int	O
guile_safe_exec	((*(int))->(int),*(void),*(int))->(int)
(	O
SCM	(*(int))->((*(void))->(int))
(	O
*	O
handler	*(int)
)	O
(	O
void	O
*	O
data	*(void)
)	O
,	O
void	O
*	O
data	*(void)
,	O
SCM	(*(int))->((*(void))->(int))
*	O
result	*(int)
)	O
{	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
jmp_env	array(struct(array(long),int,struct(array(long))))
;	O
struct	O
scheme_exec_data	struct((*(int))->((*(void))->(int)),*(void),int)
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
jmp_env	array(struct(array(long),int,struct(array(long))))
)	O
)	O
return	O
1	int
;	O
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
.	O
handler	*(int)
=	O
handler	*(int)
;	O
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
.	O
data	*(void)
=	O
data	*(void)
;	O
scm_c_with_throw_handler	()->(int)
(	O
SCM_BOOL_T	O
,	O
scheme_safe_exec_body	(*(void))->(int)
,	O
(	O
void	O
*	O
)	O
&	O
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
,	O
eval_catch_handler	(*(void),int,int)->(int)
,	O
&	O
jmp_env	array(struct(array(long),int,struct(array(long))))
,	O
0	int
)	O
;	O
if	O
(	O
result	*(int)
)	O
*	O
result	*(int)
=	O
ed	*(struct((*(int))->((*(void))->(int)),*(void),int))
.	O
result	*(int)
;	O
return	O
0	int
;	O
}	O
struct	O
load_closure	struct(*(char),int,*(*(char)))
{	O
char	O
*	O
filename	*(char)
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
}	O
;	O
static	O
SCM	(*(int))->((*(void))->(int))
load_path_handler	(*(void))->(int)
(	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
load_closure	struct(*(char),int,*(*(char)))
*	O
lp	*(struct(*(char),int,*(*(char))))
=	O
data	*(void)
;	O
scm_set_program_arguments	()->(int)
(	O
lp	*(struct(*(char),int,*(*(char))))
->	O
argc	int
,	O
lp	*(struct(*(char),int,*(*(char))))
->	O
argv	*(*(char))
,	O
lp	*(struct(*(char),int,*(*(char))))
->	O
filename	*(char)
)	O
;	O
scm_primitive_load_path	()->(int)
(	O
scm_from_locale_string	()->(int)
(	O
lp	*(struct(*(char),int,*(*(char))))
->	O
filename	*(char)
)	O
)	O
;	O
return	O
SCM_UNDEFINED	O
;	O
}	O
static	O
int	O
guile_load	(*(char),*(char))->(int)
(	O
char	O
*	O
filename	*(char)
,	O
char	O
*	O
args	*(struct)
)	O
{	O
struct	O
load_closure	struct(*(char),int,*(*(char)))
lc	struct(*(char),int,*(*(char)))
;	O
if	O
(	O
args	*(struct)
)	O
{	O
struct	O
wordsplit	()->(int)
ws	*(int)
;	O
if	O
(	O
wordsplit	()->(int)
(	O
args	*(struct)
,	O
&	O
ws	*(int)
,	O
WRDSF_DEFFLAGS	O
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"wordsplit: %s"	*(char)
,	O
wordsplit_strerror	()->(int)
(	O
&	O
ws	*(int)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
lc	struct(*(char),int,*(*(char)))
.	O
argc	int
=	O
ws	*(int)
.	O
ws_wordc	O
;	O
lc	struct(*(char),int,*(*(char)))
.	O
argv	*(*(char))
=	O
ws	*(int)
.	O
ws_wordv	O
;	O
wordsplit_free	()->(int)
(	O
&	O
ws	*(int)
)	O
;	O
}	O
else	O
{	O
lc	struct(*(char),int,*(*(char)))
.	O
argc	int
=	O
0	int
;	O
lc	struct(*(char),int,*(*(char)))
.	O
argv	*(*(char))
=	O
NULL	O
;	O
}	O
lc	struct(*(char),int,*(*(char)))
.	O
filename	*(char)
=	O
filename	*(char)
;	O
return	O
guile_safe_exec	((*(int))->(int),*(void),*(int))->(int)
(	O
load_path_handler	(*(void))->(int)
,	O
&	O
lc	struct(*(char),int,*(*(char)))
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
_add_load_path	(*(char))->(void)
(	O
char	O
*	O
path	*(char)
)	O
{	O
SCM	(*(int))->((*(void))->(int))
scm	int
,	O
path_scm	O
;	O
SCM	(*(int))->((*(void))->(int))
*	O
pscm	O
;	O
path_scm	O
=	O
SCM_VARIABLE_REF	()->(int)
(	O
scm_c_lookup	()->(int)
(	O
"%load-path"	*(char)
)	O
)	O
;	O
for	O
(	O
scm	int
=	O
path_scm	O
;	O
scm	int
!=	O
SCM_EOL	O
;	O
scm	int
=	O
SCM_CDR	()->(int)
(	O
scm	int
)	O
)	O
{	O
SCM	(*(int))->((*(void))->(int))
val	*(char)
=	O
SCM_CAR	()->(int)
(	O
scm	int
)	O
;	O
if	O
(	O
scm_is_string	()->(int)
(	O
val	*(char)
)	O
)	O
{	O
char	O
*	O
s	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
val	*(char)
)	O
;	O
int	O
res	int
=	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
path	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
if	O
(	O
res	int
==	O
0	int
)	O
return	O
;	O
}	O
}	O
pscm	O
=	O
SCM_VARIABLE_LOC	()->(int)
(	O
scm_c_lookup	()->(int)
(	O
"%load-path"	*(char)
)	O
)	O
;	O
*	O
pscm	O
=	O
scm_append	()->(int)
(	O
scm_list_3	()->(int)
(	O
path_scm	O
,	O
scm_list_1	()->(int)
(	O
scm_from_locale_string	()->(int)
(	O
path	*(char)
)	O
)	O
,	O
SCM_EOL	O
)	O
)	O
;	O
}	O
static	O
void	O
memerr	(*(char))->(void)
(	O
const	O
char	O
*	O
fname	*(char)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: not enough memory"	*(char)
)	O
,	O
fname	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
proc_name	(int)->(*(char))
(	O
SCM	(*(int))->((*(void))->(int))
proc	int
)	O
{	O
return	O
scm_to_locale_string	()->(int)
(	O
scm_symbol_to_string	()->(int)
(	O
scm_procedure_name	()->(int)
(	O
proc	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
str_rettype_error	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: invalid return type"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
rettype_error	(int)->(void)
(	O
SCM	(*(int))->((*(void))->(int))
proc	int
)	O
{	O
char	O
*	O
name	*(char)
=	O
proc_name	(int)->(*(char))
(	O
proc	int
)	O
;	O
str_rettype_error	(*(char))->(void)
(	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
static	O
int	O
guile_call_proc	(*(int),int,int)->(int)
(	O
SCM	(*(int))->((*(void))->(int))
*	O
result	*(int)
,	O
SCM	(*(int))->((*(void))->(int))
proc	int
,	O
SCM	(*(int))->((*(void))->(int))
arglist	int
)	O
{	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
jmp_env	array(struct(array(long),int,struct(array(long))))
;	O
struct	O
apply_data	struct(int,int)
adata	struct(int,int)
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
jmp_env	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
proc_name	(int)->(*(char))
(	O
proc	int
)	O
;	O
dico_log	(int,int,*(char))->(void)
(	O
L_NOTICE	int
,	O
0	int
,	O
_	O
(	O
"procedure `%s' failed: see error output for details"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
adata	struct(int,int)
.	O
proc	int
=	O
proc	int
;	O
adata	struct(int,int)
.	O
arg	int
=	O
arglist	int
;	O
*	O
result	*(int)
=	O
scm_c_with_throw_handler	()->(int)
(	O
SCM_BOOL_T	O
,	O
apply_catch_body	(*(void))->(int)
,	O
&	O
adata	struct(int,int)
,	O
eval_catch_handler	(*(void),int,int)->(int)
,	O
&	O
jmp_env	array(struct(array(long),int,struct(array(long))))
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
scm_t_bits	O
_guile_dico_key_tag	int
;	O
static	O
SCM	(*(int))->((*(void))->(int))
dico_new_scm_key	(*(*(struct(*(char),*(void),*(struct`),int))))->(int)
(	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
*	O
pkey	*(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)))
)	O
{	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
kptr	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
;	O
kptr	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
=	O
scm_gc_malloc	()->(int)
(	O
sizeof	O
(	O
*	O
kptr	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
)	O
,	O
"Dico key"	*(char)
)	O
;	O
*	O
pkey	*(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)))
=	O
kptr	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
;	O
SCM_RETURN_NEWSMOB	()->(int)
(	O
_guile_dico_key_tag	int
,	O
kptr	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
)	O
;	O
}	O
static	O
size_t	long
_guile_dico_key_free	(int)->(long)
(	O
SCM	(*(int))->((*(void))->(int))
message_smob	int
)	O
{	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
kp	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
=	O
(	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
)	O
SCM_CDR	()->(int)
(	O
message_smob	int
)	O
;	O
dico_key_deinit	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)))->(void)
(	O
kp	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_guile_dico_key_print	(int,int,*(int))->(int)
(	O
SCM	(*(int))->((*(void))->(int))
message_smob	int
,	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
,	O
scm_print_state	O
*	O
pstate	*(int)
)	O
{	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
kp	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
=	O
(	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
)	O
SCM_CDR	()->(int)
(	O
message_smob	int
)	O
;	O
scm_puts	()->(int)
(	O
"#<key "	*(char)
,	O
port	*(char)
)	O
;	O
scm_puts	()->(int)
(	O
kp	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
->	O
strat	*(struct)
->	O
name	*(char)
,	O
port	*(char)
)	O
;	O
scm_puts	()->(int)
(	O
" ("	*(char)
,	O
port	*(char)
)	O
;	O
scm_puts	()->(int)
(	O
kp	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
->	O
word	*(char)
,	O
port	*(char)
)	O
;	O
scm_puts	()->(int)
(	O
")>"	*(char)
,	O
port	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
_guile_init_dico_key	()->(void)
(	O
void	O
)	O
{	O
_guile_dico_key_tag	int
=	O
scm_make_smob_type	()->(int)
(	O
"Dico key"	*(char)
,	O
sizeof	O
(	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
)	O
)	O
;	O
scm_set_smob_free	()->(int)
(	O
_guile_dico_key_tag	int
,	O
_guile_dico_key_free	(int)->(long)
)	O
;	O
scm_set_smob_print	()->(int)
(	O
_guile_dico_key_tag	int
,	O
_guile_dico_key_print	(int,int,*(int))->(int)
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_key_p	O
,	O
"dico-key?"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
obj	O
)	O
,	O
"Return @samp{#t} if @var{obj} is a selection key."	*(char)
)	O
{	O
return	O
CELL_IS_KEY	O
(	O
obj	O
)	O
?	O
SCM_BOOL_T	O
:	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_key__word	O
,	O
"dico-key->word"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
key	*(char)
)	O
,	O
"Return search word from the @var{key}."	*(char)
)	O
{	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
kp	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
;	O
SCM_ASSERT	()->(int)
(	O
CELL_IS_KEY	O
(	O
key	*(char)
)	O
,	O
key	*(char)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
kp	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
=	O
(	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
)	O
SCM_CDR	()->(int)
(	O
key	*(char)
)	O
;	O
return	O
scm_from_locale_string	()->(int)
(	O
kp	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
->	O
word	*(char)
)	O
;	O
}	O
scm_t_bits	O
_guile_strategy_tag	int
;	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
{	O
dico_strategy_t	*(struct)
strat	*(struct)
;	O
}	O
;	O
static	O
SCM	(*(int))->((*(void))->(int))
_make_strategy	(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))))->(int)
(	O
const	O
dico_strategy_t	*(struct)
strat	*(struct)
)	O
{	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
;	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
=	O
scm_gc_malloc	()->(int)
(	O
sizeof	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
)	O
,	O
"strategy"	*(char)
)	O
;	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
=	O
strat	*(struct)
;	O
SCM_RETURN_NEWSMOB	()->(int)
(	O
_guile_strategy_tag	int
,	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
)	O
;	O
}	O
static	O
size_t	long
_guile_strategy_free	(int)->(long)
(	O
SCM	(*(int))->((*(void))->(int))
message_smob	int
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
_guile_strategy_print	(int,int,*(int))->(int)
(	O
SCM	(*(int))->((*(void))->(int))
message_smob	int
,	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
,	O
scm_print_state	O
*	O
pstate	*(int)
)	O
{	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
=	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
)	O
SCM_CDR	()->(int)
(	O
message_smob	int
)	O
;	O
scm_puts	()->(int)
(	O
"#<strategy "	*(char)
,	O
port	*(char)
)	O
;	O
scm_puts	()->(int)
(	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
->	O
name	*(char)
,	O
port	*(char)
)	O
;	O
scm_puts	()->(int)
(	O
" ["	*(char)
,	O
port	*(char)
)	O
;	O
scm_puts	()->(int)
(	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
->	O
descr	*(char)
,	O
port	*(char)
)	O
;	O
scm_puts	()->(int)
(	O
"]>"	*(char)
,	O
port	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
_guile_init_strategy	()->(void)
(	O
void	O
)	O
{	O
_guile_strategy_tag	int
=	O
scm_make_smob_type	()->(int)
(	O
"strategy"	*(char)
,	O
sizeof	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
)	O
)	O
;	O
scm_set_smob_free	()->(int)
(	O
_guile_strategy_tag	int
,	O
_guile_strategy_free	(int)->(long)
)	O
;	O
scm_set_smob_print	()->(int)
(	O
_guile_strategy_tag	int
,	O
_guile_strategy_print	(int,int,*(int))->(int)
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_strat_selector_p	O
,	O
"dico-strat-selector?"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
strat	*(struct)
)	O
,	O
"Return true if @var{strat} has a selector."	*(char)
)	O
{	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
;	O
SCM_ASSERT	()->(int)
(	O
CELL_IS_STRAT	O
(	O
strat	*(struct)
)	O
,	O
strat	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
=	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
)	O
SCM_CDR	()->(int)
(	O
strat	*(struct)
)	O
;	O
return	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
->	O
sel	*((*(char),*(void))->(int))
?	O
SCM_BOOL_T	O
:	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_strat_select_p	O
,	O
"dico-strat-select?"	*(char)
,	O
3	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
strat	*(struct)
,	O
SCM	(*(int))->((*(void))->(int))
word	*(char)
,	O
SCM	(*(int))->((*(void))->(int))
key	*(char)
)	O
,	O
"Return true if @var{key} matches @var{word} as per strategy selector @var{strat}."	*(char)
)	O
{	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
;	O
struct	O
dico_strategy	struct(*(char),*(char),*((int,*(struct),*(char))->(int)),*(void),int,*(struct))
*	O
stratp	*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)))
;	O
char	O
*	O
wordstr	*(char)
;	O
int	O
rc	int
;	O
SCM_ASSERT	()->(int)
(	O
CELL_IS_STRAT	O
(	O
strat	*(struct)
)	O
,	O
strat	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
word	*(char)
)	O
,	O
word	*(char)
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
=	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
)	O
SCM_CDR	()->(int)
(	O
strat	*(struct)
)	O
;	O
stratp	*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)))
=	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
;	O
wordstr	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
word	*(char)
)	O
;	O
if	O
(	O
scm_is_string	()->(int)
(	O
key	*(char)
)	O
)	O
{	O
char	O
*	O
keystr	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
key	*(char)
)	O
;	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
skey	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),int)
;	O
rc	int
=	O
dico_key_init	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(int)
(	O
&	O
skey	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),int)
,	O
stratp	*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)))
,	O
keystr	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
keystr	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	(*(void))->(void)
(	O
wordstr	*(char)
)	O
;	O
scm_misc_error	()->(int)
(	O
FUNC_NAME	O
,	O
"key initialization failed: ~S"	*(char)
,	O
scm_list_1	()->(int)
(	O
key	*(char)
)	O
)	O
;	O
}	O
rc	int
=	O
dico_key_match	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
(	O
&	O
skey	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),int)
,	O
wordstr	*(char)
)	O
;	O
dico_key_deinit	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)))->(void)
(	O
&	O
skey	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),int)
)	O
;	O
}	O
else	O
{	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
kptr	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
;	O
SCM_ASSERT	()->(int)
(	O
CELL_IS_KEY	O
(	O
key	*(char)
)	O
,	O
key	*(char)
,	O
SCM_ARG3	O
,	O
FUNC_NAME	O
)	O
;	O
kptr	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
=	O
(	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
)	O
SCM_CDR	()->(int)
(	O
key	*(char)
)	O
;	O
rc	int
=	O
dico_key_match	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
(	O
kptr	*(struct(*(char),*(void),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`))),int))
,	O
wordstr	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
wordstr	*(char)
)	O
;	O
return	O
rc	int
?	O
SCM_BOOL_T	O
:	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_strat_name	O
,	O
"dico-strat-name"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
strat	*(struct)
)	O
,	O
"Return the name of the strategy @var{strat}."	*(char)
)	O
{	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
;	O
SCM_ASSERT	()->(int)
(	O
CELL_IS_STRAT	O
(	O
strat	*(struct)
)	O
,	O
strat	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
=	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
)	O
SCM_CDR	()->(int)
(	O
strat	*(struct)
)	O
;	O
return	O
scm_from_locale_string	()->(int)
(	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
->	O
name	*(char)
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_strat_description	O
,	O
"dico-strat-description"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
strat	*(struct)
)	O
,	O
"Return a textual description of the strategy @var{strat}."	*(char)
)	O
{	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
;	O
SCM_ASSERT	()->(int)
(	O
CELL_IS_STRAT	O
(	O
strat	*(struct)
)	O
,	O
strat	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
=	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
)	O
SCM_CDR	()->(int)
(	O
strat	*(struct)
)	O
;	O
return	O
scm_from_locale_string	()->(int)
(	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
->	O
descr	*(char)
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_strat_default_p	O
,	O
"dico-strat-default?"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
strat	*(struct)
)	O
,	O
"Return true if @var{strat} is a default strategy."	*(char)
)	O
{	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
;	O
SCM_ASSERT	()->(int)
(	O
CELL_IS_STRAT	O
(	O
strat	*(struct)
)	O
,	O
strat	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
=	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
)	O
SCM_CDR	()->(int)
(	O
strat	*(struct)
)	O
;	O
return	O
dico_strategy_is_default_p	O
(	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
)	O
?	O
SCM_BOOL_T	O
:	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_make_key	O
,	O
"dico-make-key"	*(char)
,	O
2	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
strat	*(struct)
,	O
SCM	(*(int))->((*(void))->(int))
word	*(char)
)	O
,	O
"Make a key for given @var{word} and strategy @var{strat}."	*(char)
)	O
{	O
SCM	(*(int))->((*(void))->(int))
ret	O
;	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
key	*(char)
;	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
;	O
char	O
*	O
wordstr	*(char)
;	O
int	O
rc	int
;	O
SCM_ASSERT	()->(int)
(	O
CELL_IS_STRAT	O
(	O
strat	*(struct)
)	O
,	O
strat	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
word	*(char)
)	O
,	O
word	*(char)
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
=	O
(	O
struct	O
_guile_strategy	struct(*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))))
*	O
)	O
SCM_CDR	()->(int)
(	O
strat	*(struct)
)	O
;	O
wordstr	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
word	*(char)
)	O
;	O
ret	O
=	O
dico_new_scm_key	(*(*(struct(*(char),*(void),*(struct`),int))))->(int)
(	O
&	O
key	*(char)
)	O
;	O
rc	int
=	O
dico_key_init	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(int)
(	O
key	*(char)
,	O
sp	*(struct(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct`)))))
->	O
strat	*(struct)
,	O
wordstr	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
wordstr	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
scm_misc_error	()->(int)
(	O
FUNC_NAME	O
,	O
"key initialization failed: ~S"	*(char)
,	O
scm_list_1	()->(int)
(	O
ret	O
)	O
)	O
;	O
return	O
ret	O
;	O
}	O
static	O
int	O
_guile_selector	(int,*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
(	O
int	O
cmd	int
,	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
key	*(char)
,	O
const	O
char	O
*	O
dict_word	*(char)
)	O
{	O
SCM	(*(int))->((*(void))->(int))
result	*(int)
;	O
SCM	(*(int))->((*(void))->(int))
list	array(*(struct))
=	O
scm_list_4	O
(	O
(	O
SCM	(*(int))->((*(void))->(int))
)	O
key	*(char)
->	O
strat	*(struct)
->	O
closure	*(void)
,	O
scm_from_int	()->(int)
(	O
cmd	int
)	O
,	O
scm_from_locale_string	()->(int)
(	O
key	*(char)
->	O
word	*(char)
)	O
,	O
scm_from_locale_string	()->(int)
(	O
dict_word	*(char)
)	O
)	O
;	O
if	O
(	O
guile_safe_exec	((*(int))->(int),*(void),*(int))->(int)
(	O
apply_catch_body	(*(void))->(int)
,	O
list	array(*(struct))
,	O
&	O
result	*(int)
)	O
)	O
return	O
0	int
;	O
return	O
result	*(int)
!=	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_register_strat	O
,	O
"dico-register-strat"	*(char)
,	O
2	int
,	O
1	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
strat	*(struct)
,	O
SCM	(*(int))->((*(void))->(int))
descr	*(char)
,	O
SCM	(*(int))->((*(void))->(int))
fun	O
)	O
,	O
"Register a new strategy."	*(char)
)	O
{	O
struct	O
dico_strategy	struct(*(char),*(char),*((int,*(struct),*(char))->(int)),*(void),int,*(struct))
strategy	*(char)
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
strat	*(struct)
)	O
,	O
strat	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
descr	*(char)
)	O
,	O
descr	*(char)
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
if	O
(	O
!	O
SCM_UNBNDP	()->(int)
(	O
fun	O
)	O
)	O
SCM_ASSERT	()->(int)
(	O
scm_procedure_p	()->(int)
(	O
fun	O
)	O
,	O
fun	O
,	O
SCM_ARG3	O
,	O
FUNC_NAME	O
)	O
;	O
strategy	*(char)
.	O
name	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
strat	*(struct)
)	O
;	O
strategy	*(char)
.	O
descr	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
descr	*(char)
)	O
;	O
if	O
(	O
SCM_UNBNDP	()->(int)
(	O
fun	O
)	O
)	O
{	O
strategy	*(char)
.	O
sel	*((*(char),*(void))->(int))
=	O
NULL	O
;	O
strategy	*(char)
.	O
closure	*(void)
=	O
NULL	O
;	O
}	O
else	O
{	O
strategy	*(char)
.	O
sel	*((*(char),*(void))->(int))
=	O
_guile_selector	(int,*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
;	O
strategy	*(char)
.	O
closure	*(void)
=	O
fun	O
;	O
}	O
dico_strategy_add	(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))))->(int)
(	O
&	O
strategy	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
strategy	*(char)
.	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
strategy	*(char)
.	O
descr	*(char)
)	O
;	O
return	O
SCM_UNSPECIFIED	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_register_markup	O
,	O
"dico-register-markup"	*(char)
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void))->(int))
type	enum(int,int,int)
)	O
,	O
"Register new markup type."	*(char)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
str	*(struct)
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
type	enum(int,int,int)
)	O
,	O
type	enum(int,int,int)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
str	*(struct)
=	O
scm_to_locale_string	()->(int)
(	O
type	enum(int,int,int)
)	O
;	O
rc	int
=	O
dico_markup_register	(*(char))->(int)
(	O
str	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
str	*(struct)
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
ENOMEM	int
:	O
scm_report_out_of_memory	()->(int)
(	O
)	O
;	O
break	O
;	O
case	O
EINVAL	int
:	O
scm_misc_error	()->(int)
(	O
FUNC_NAME	O
,	O
"Invalid markup name: ~S"	*(char)
,	O
scm_list_1	()->(int)
(	O
type	enum(int,int,int)
)	O
)	O
;	O
default	O
:	O
scm_misc_error	()->(int)
(	O
FUNC_NAME	O
,	O
"Unexpected error: ~S"	*(char)
,	O
scm_list_1	()->(int)
(	O
scm_from_int	()->(int)
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
return	O
SCM_UNSPECIFIED	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_dico_current_markup	O
,	O
"dico-current-markup"	*(char)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
(	O
)	O
,	O
"Return current dico markup type."	*(char)
)	O
{	O
return	O
scm_from_locale_string	()->(int)
(	O
dico_markup_type	*(char)
)	O
;	O
}	O
static	O
scm_t_port_type	O
*	O
scm_dico_port_type	*(int)
;	O
struct	O
_guile_dico_port	struct(*(struct))
{	O
dico_stream_t	*(struct)
str	*(struct)
;	O
}	O
;	O
static	O
SCM	(*(int))->((*(void))->(int))
_make_dico_port	(*(struct))->(int)
(	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
struct	O
_guile_dico_port	struct(*(struct))
*	O
dp	*(struct(*(struct)))
;	O
dp	*(struct(*(struct)))
=	O
scm_gc_typed_calloc	()->(int)
(	O
struct	O
_guile_dico_port	struct(*(struct))
)	O
;	O
dp	*(struct(*(struct)))
->	O
str	*(struct)
=	O
str	*(struct)
;	O
return	O
scm_c_make_port	()->(int)
(	O
scm_dico_port_type	*(int)
,	O
SCM_BUF0	O
|	O
SCM_WRTNG	O
,	O
(	O
scm_t_bits	O
)	O
dp	*(struct(*(struct)))
)	O
;	O
}	O
static	O
void	O
_dico_port_close	(int)->(void)
(	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
)	O
{	O
struct	O
_guile_dico_port	struct(*(struct))
*	O
dp	*(struct(*(struct)))
=	O
DICO_PORT	O
(	O
port	*(char)
)	O
;	O
if	O
(	O
dp	*(struct(*(struct)))
&&	O
dp	*(struct(*(struct)))
->	O
str	*(struct)
)	O
dico_stream_flush	(*(struct))->(int)
(	O
dp	*(struct(*(struct)))
->	O
str	*(struct)
)	O
;	O
}	O
static	O
size_t	long
_dico_port_write	(int,int,long,long)->(long)
(	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
,	O
SCM	(*(int))->((*(void))->(int))
src	*(char)
,	O
size_t	long
start	*(int)
,	O
size_t	long
count	long
)	O
{	O
struct	O
_guile_dico_port	struct(*(struct))
*	O
dp	*(struct(*(struct)))
=	O
DICO_PORT	O
(	O
port	*(char)
)	O
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
dp	*(struct(*(struct)))
->	O
str	*(struct)
,	O
SCM_BYTEVECTOR_CONTENTS	()->(int)
(	O
src	*(char)
)	O
+	O
start	*(int)
,	O
count	long
)	O
;	O
return	O
count	long
;	O
}	O
static	O
scm_t_off	long
_dico_port_seek	(int,long,int)->(long)
(	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
,	O
scm_t_off	long
offset	long
,	O
int	O
whence	int
)	O
{	O
struct	O
_guile_dico_port	struct(*(struct))
*	O
dp	*(struct(*(struct)))
=	O
DICO_PORT	O
(	O
port	*(char)
)	O
;	O
return	O
(	O
scm_t_off	long
)	O
dico_stream_seek	(*(struct),long,int)->(long)
(	O
dp	*(struct(*(struct)))
->	O
str	*(struct)
,	O
(	O
off_t	long
)	O
offset	long
,	O
whence	int
)	O
;	O
}	O
static	O
int	O
_dico_port_print	(int,int,*(int))->(int)
(	O
SCM	(*(int))->((*(void))->(int))
exp	int
,	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
,	O
scm_print_state	O
*	O
pstate	*(int)
)	O
{	O
scm_puts	()->(int)
(	O
"#<Dico port>"	*(char)
,	O
port	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
_guile_init_dico_port	()->(void)
(	O
void	O
)	O
{	O
scm_dico_port_type	*(int)
=	O
scm_make_port_type	()->(int)
(	O
"dico-port"	*(char)
,	O
NULL	O
,	O
_dico_port_write	(int,int,long,long)->(long)
)	O
;	O
scm_set_port_print	()->(int)
(	O
scm_dico_port_type	*(int)
,	O
_dico_port_print	(int,int,*(int))->(int)
)	O
;	O
scm_set_port_needs_close_on_gc	()->(int)
(	O
scm_dico_port_type	*(int)
,	O
1	int
)	O
;	O
scm_set_port_close	()->(int)
(	O
scm_dico_port_type	*(int)
,	O
_dico_port_close	(int)->(void)
)	O
;	O
scm_set_port_seek	()->(int)
(	O
scm_dico_port_type	*(int)
,	O
_dico_port_seek	(int,long,int)->(long)
)	O
;	O
}	O
static	O
scm_t_port_type	O
*	O
scm_dico_log_port_type	*(int)
;	O
static	O
SCM	(*(int))->((*(void))->(int))
_make_dico_log_port	(int)->(int)
(	O
int	O
level	int
)	O
{	O
dico_stream_t	*(struct)
str	*(struct)
=	O
dico_log_stream_create	(int)->(*(struct))
(	O
level	int
)	O
;	O
return	O
str	*(struct)
?	O
_make_dico_port	(*(struct))->(int)
(	O
str	*(struct)
)	O
:	O
SCM_BOOL_F	O
;	O
}	O
static	O
int	O
_dico_log_port_print	(int,int,*(int))->(int)
(	O
SCM	(*(int))->((*(void))->(int))
exp	int
,	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
,	O
scm_print_state	O
*	O
pstate	*(int)
)	O
{	O
scm_puts	()->(int)
(	O
"#<Dico log port>"	*(char)
,	O
port	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
_guile_init_dico_log_port	()->(void)
(	O
void	O
)	O
{	O
scm_dico_log_port_type	*(int)
=	O
scm_make_port_type	()->(int)
(	O
"dico-log-port"	*(char)
,	O
NULL	O
,	O
_dico_port_write	(int,int,long,long)->(long)
)	O
;	O
scm_set_port_print	()->(int)
(	O
scm_dico_log_port_type	*(int)
,	O
_dico_log_port_print	(int,int,*(int))->(int)
)	O
;	O
scm_set_port_close	()->(int)
(	O
scm_dico_log_port_type	*(int)
,	O
_dico_port_close	(int)->(void)
)	O
;	O
scm_set_port_needs_close_on_gc	()->(int)
(	O
scm_dico_log_port_type	*(int)
,	O
1	int
)	O
;	O
scm_set_port_seek	()->(int)
(	O
scm_dico_log_port_type	*(int)
,	O
_dico_port_seek	(int,long,int)->(long)
)	O
;	O
}	O
static	O
void	O
_guile_init_funcs	()->(void)
(	O
void	O
)	O
{	O
}	O
static	O
int	O
guile_debug	int
;	O
static	O
char	O
*	O
guile_init_script	*(char)
;	O
static	O
char	O
*	O
guile_init_args	*(char)
;	O
static	O
char	O
*	O
guile_init_fun	*(char)
;	O
enum	O
guile_proc_ind	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
{	O
open_proc	int
,	O
close_proc	int
,	O
info_proc	int
,	O
descr_proc	int
,	O
lang_proc	int
,	O
match_proc	int
,	O
define_proc	int
,	O
output_proc	int
,	O
result_count_proc	int
,	O
compare_count_proc	int
,	O
free_result_proc	int
,	O
result_headers_proc	int
,	O
db_mime_header_proc	int
,	O
MAX_PROC	int
}	O
;	O
static	O
char	O
*	O
guile_proc_name	array(*(char))
[	O
]	O
=	O
{	O
"open"	*(char)
,	O
"close"	*(char)
,	O
"info"	*(char)
,	O
"descr"	*(char)
,	O
"lang"	*(char)
,	O
"match"	*(char)
,	O
"define"	*(char)
,	O
"output"	*(char)
,	O
"result-count"	*(char)
,	O
"compare-count"	*(char)
,	O
"free-result"	*(char)
,	O
"result-headers"	*(char)
,	O
"db-mime-header"	*(char)
}	O
;	O
typedef	O
SCM	(*(int))->((*(void))->(int))
guile_vtab	array(int)
[	O
MAX_PROC	int
]	O
;	O
static	O
guile_vtab	array(int)
global_vtab	array(int)
;	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
{	O
const	O
char	O
*	O
dbname	*(char)
;	O
guile_vtab	array(int)
vtab	array(int)
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
SCM	(*(int))->((*(void))->(int))
handle	int
;	O
}	O
;	O
static	O
int	O
proc_name_to_index	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_PROC	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
guile_proc_name	array(*(char))
[	O
i	int
]	O
,	O
name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
return	O
i	int
;	O
}	O
struct	O
init_struct	struct(*(char),*(char))
{	O
const	O
char	O
*	O
init_fun	*(char)
;	O
const	O
char	O
*	O
db_name	*(char)
;	O
}	O
;	O
static	O
SCM	(*(int))->((*(void))->(int))
call_init_handler	(*(void))->(int)
(	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
init_struct	struct(*(char),*(char))
*	O
p	*(char)
=	O
(	O
struct	O
init_struct	struct(*(char),*(char))
*	O
)	O
data	*(void)
;	O
SCM	(*(int))->((*(void))->(int))
procsym	int
=	O
SCM_VARIABLE_REF	()->(int)
(	O
scm_c_lookup	()->(int)
(	O
p	*(char)
->	O
init_fun	*(char)
)	O
)	O
;	O
SCM	(*(int))->((*(void))->(int))
arg	int
;	O
if	O
(	O
p	*(char)
->	O
db_name	*(char)
)	O
arg	int
=	O
scm_from_locale_string	()->(int)
(	O
p	*(char)
->	O
db_name	*(char)
)	O
;	O
else	O
arg	int
=	O
SCM_BOOL_F	O
;	O
return	O
scm_apply_0	()->(int)
(	O
procsym	int
,	O
scm_list_1	()->(int)
(	O
arg	int
)	O
)	O
;	O
}	O
static	O
int	O
init_vtab	(*(char),*(char),array(int))->(int)
(	O
const	O
char	O
*	O
init_fun	*(char)
,	O
const	O
char	O
*	O
dbname	*(char)
,	O
guile_vtab	array(int)
vtab	array(int)
)	O
{	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
struct	O
init_struct	struct(*(char),*(char))
istr	struct(*(char),*(char))
;	O
istr	struct(*(char),*(char))
.	O
init_fun	*(char)
=	O
init_fun	*(char)
;	O
istr	struct(*(char),*(char))
.	O
db_name	*(char)
=	O
dbname	*(char)
;	O
if	O
(	O
guile_safe_exec	((*(int))->(int),*(void),*(int))->(int)
(	O
call_init_handler	(*(void))->(int)
,	O
&	O
istr	struct(*(char),*(char))
,	O
&	O
res	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
scm_list_p	()->(int)
(	O
res	int
)	O
&&	O
res	int
!=	O
SCM_EOL	O
)	O
{	O
str_rettype_error	(*(char))->(void)
(	O
init_fun	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
;	O
res	int
!=	O
SCM_EOL	O
;	O
res	int
=	O
SCM_CDR	()->(int)
(	O
res	int
)	O
)	O
{	O
int	O
idx	int
;	O
char	O
*	O
ident	*(char)
;	O
SCM	(*(int))->((*(void))->(int))
name	*(char)
,	O
proc	int
;	O
SCM	(*(int))->((*(void))->(int))
car	O
=	O
SCM_CAR	()->(int)
(	O
res	int
)	O
;	O
if	O
(	O
!	O
scm_list_p	()->(int)
(	O
res	int
)	O
||	O
!	O
scm_is_string	()->(int)
(	O
name	*(char)
=	O
SCM_CAR	()->(int)
(	O
car	O
)	O
)	O
||	O
!	O
scm_procedure_p	()->(int)
(	O
proc	int
=	O
SCM_CDR	()->(int)
(	O
car	O
)	O
)	O
)	O
{	O
str_rettype_error	(*(char))->(void)
(	O
init_fun	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
ident	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
name	*(char)
)	O
;	O
idx	int
=	O
proc_name_to_index	(*(char))->(int)
(	O
ident	*(char)
)	O
;	O
if	O
(	O
idx	int
==	O
MAX_PROC	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: %s: unknown virtual function"	*(char)
)	O
,	O
init_fun	*(char)
,	O
ident	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ident	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
free	(*(void))->(void)
(	O
ident	*(char)
)	O
;	O
vtab	array(int)
[	O
idx	int
]	O
=	O
proc	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_load_path	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),*(char))->(int)
(	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
*	O
opt	*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct`),*(char))->(int))))
,	O
const	O
char	O
*	O
val	*(char)
)	O
{	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
tmp	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
val	*(char)
)	O
;	O
if	O
(	O
!	O
tmp	*(char)
)	O
return	O
1	int
;	O
for	O
(	O
p	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
tmp	*(char)
,	O
":"	*(char)
)	O
;	O
p	*(char)
;	O
p	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
":"	*(char)
)	O
)	O
_add_load_path	(*(char))->(void)
(	O
p	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
init_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
debug	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
guile_debug	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
script	O
)	O
,	O
dico_opt_string	int
,	O
&	O
guile_init_script	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
args	*(struct)
)	O
,	O
dico_opt_string	int
,	O
&	O
guile_init_args	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
load	O
-	O
path	*(char)
)	O
,	O
dico_opt_null	int
,	O
NULL	O
,	O
{	O
0	int
}	O
,	O
set_load_path	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),*(char))->(int)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
fun	O
)	O
,	O
dico_opt_string	int
,	O
&	O
guile_init_fun	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
mod_init	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
;	O
scm_init_guile	()->(int)
(	O
)	O
;	O
scm_load_goops	()->(int)
(	O
)	O
;	O
if	O
(	O
dico_parseopt	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),int,*(*(char)),int,*(int))->(int)
(	O
init_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
_guile_init_strategy	()->(void)
(	O
)	O
;	O
_guile_init_dico_key	()->(void)
(	O
)	O
;	O
_guile_init_dico_port	()->(void)
(	O
)	O
;	O
_guile_init_dico_log_port	()->(void)
(	O
)	O
;	O
_guile_init_funcs	()->(void)
(	O
)	O
;	O
port	*(char)
=	O
_make_dico_log_port	(int)->(int)
(	O
L_ERR	int
)	O
;	O
if	O
(	O
port	*(char)
==	O
SCM_BOOL_F	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: cannot initialize error port"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
scm_set_current_output_port	()->(int)
(	O
port	*(char)
)	O
;	O
scm_set_current_error_port	()->(int)
(	O
port	*(char)
)	O
;	O
if	O
(	O
guile_init_script	*(char)
&&	O
guile_load	(*(char),*(char))->(int)
(	O
guile_init_script	*(char)
,	O
guile_init_args	*(char)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: cannot load init script %s"	*(char)
)	O
,	O
guile_init_script	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
guile_init_fun	*(char)
&&	O
init_vtab	(*(char),*(char),array(int))->(int)
(	O
guile_init_fun	*(char)
,	O
NULL	O
,	O
global_vtab	array(int)
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
dico_handle_t	*(struct)
mod_init_db	(*(char),int,*(*(char)))->(*(struct))
(	O
const	O
char	O
*	O
dbname	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
;	O
int	O
i	int
;	O
int	O
err	int
=	O
0	int
;	O
char	O
*	O
init_script	*(char)
=	O
NULL	O
;	O
char	O
*	O
init_args	*(char)
=	O
NULL	O
;	O
char	O
*	O
init_fun	*(char)
=	O
guile_init_fun	*(char)
;	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
db_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
script	O
)	O
,	O
dico_opt_string	int
,	O
&	O
init_script	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
args	*(struct)
)	O
,	O
dico_opt_string	int
,	O
&	O
init_args	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
fun	O
)	O
,	O
dico_opt_string	int
,	O
&	O
init_fun	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),int,*(*(char)),int,*(int))->(int)
(	O
db_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
,	O
argc	int
,	O
argv	*(*(char))
,	O
DICO_PARSEOPT_PERMUTE	int
,	O
&	O
i	int
)	O
)	O
return	O
NULL	O
;	O
argc	int
-=	O
i	int
;	O
argv	*(*(char))
+=	O
i	int
;	O
if	O
(	O
init_script	*(char)
&&	O
guile_load	(*(char),*(char))->(int)
(	O
init_script	*(char)
,	O
init_args	*(char)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: cannot load init script %s"	*(char)
)	O
,	O
init_script	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
db	*(char)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
db	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
db	*(char)
)	O
{	O
memerr	(*(char))->(void)
(	O
"mod_init_db"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
db	*(char)
->	O
dbname	*(char)
=	O
dbname	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
db	*(char)
->	O
vtab	array(int)
,	O
global_vtab	array(int)
,	O
sizeof	O
(	O
db	*(char)
->	O
vtab	array(int)
)	O
)	O
;	O
if	O
(	O
init_fun	*(char)
&&	O
init_vtab	(*(char),*(char),array(int))->(int)
(	O
init_fun	*(char)
,	O
dbname	*(char)
,	O
db	*(char)
->	O
vtab	array(int)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
db	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_PROC	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
db	*(char)
->	O
vtab	array(int)
[	O
i	int
]	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
open_proc	int
:	O
case	O
match_proc	int
:	O
case	O
define_proc	int
:	O
case	O
output_proc	int
:	O
case	O
result_count_proc	int
:	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: %s: void virtual function"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
guile_proc_name	array(*(char))
[	O
i	int
]	O
)	O
;	O
err	int
++	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
err	int
)	O
{	O
free	(*(void))->(void)
(	O
db	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
db	*(char)
->	O
argc	int
=	O
argc	int
;	O
db	*(char)
->	O
argv	*(*(char))
=	O
argv	*(*(char))
;	O
return	O
(	O
dico_handle_t	*(struct)
)	O
db	*(char)
;	O
}	O
static	O
int	O
mod_free_db	(*(struct))->(int)
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
hp	*(struct)
;	O
free	(*(void))->(void)
(	O
db	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mod_close	(*(struct))->(int)
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
hp	*(struct)
;	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
if	O
(	O
db	*(char)
->	O
vtab	array(int)
[	O
close_proc	int
]	O
)	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
db	*(char)
->	O
vtab	array(int)
[	O
close_proc	int
]	O
,	O
scm_list_1	()->(int)
(	O
db	*(char)
->	O
handle	int
)	O
)	O
)	O
return	O
1	int
;	O
scm_gc_unprotect_object	()->(int)
(	O
db	*(char)
->	O
handle	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
SCM	(*(int))->((*(void))->(int))
argv_to_scm	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
SCM	(*(int))->((*(void))->(int))
scm_first	O
=	O
SCM_EOL	O
,	O
scm_last	O
;	O
for	O
(	O
;	O
argc	int
;	O
argc	int
--	O
,	O
argv	*(*(char))
++	O
)	O
{	O
SCM	(*(int))->((*(void))->(int))
new	O
=	O
scm_cons	()->(int)
(	O
scm_from_locale_string	()->(int)
(	O
*	O
argv	*(*(char))
)	O
,	O
SCM_EOL	O
)	O
;	O
if	O
(	O
scm_first	O
==	O
SCM_EOL	O
)	O
scm_last	O
=	O
scm_first	O
=	O
new	O
;	O
else	O
{	O
SCM_SETCDR	()->(int)
(	O
scm_last	O
,	O
new	O
)	O
;	O
scm_last	O
=	O
new	O
;	O
}	O
}	O
return	O
scm_first	O
;	O
}	O
static	O
SCM	(*(int))->((*(void))->(int))
assoc_to_scm	(*(struct))->(int)
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
)	O
{	O
SCM	(*(int))->((*(void))->(int))
scm_first	O
=	O
SCM_EOL	O
,	O
scm_last	O
;	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
;	O
struct	O
dico_assoc	struct(*(char),*(char))
*	O
p	*(char)
;	O
itr	*((*(void),*(void))->(int))
=	O
dico_assoc_iterator	(*(struct))->(*(struct))
(	O
assoc	*(struct)
)	O
;	O
for	O
(	O
p	*(char)
=	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
p	*(char)
;	O
p	*(char)
=	O
dico_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
SCM	(*(int))->((*(void))->(int))
new	O
=	O
scm_cons	()->(int)
(	O
scm_cons	()->(int)
(	O
scm_from_locale_string	()->(int)
(	O
p	*(char)
->	O
key	*(char)
)	O
,	O
scm_from_locale_string	()->(int)
(	O
p	*(char)
->	O
value	*(char)
)	O
)	O
,	O
SCM_EOL	O
)	O
;	O
if	O
(	O
scm_first	O
==	O
SCM_EOL	O
)	O
scm_last	O
=	O
scm_first	O
=	O
new	O
;	O
else	O
{	O
SCM_SETCDR	()->(int)
(	O
scm_last	O
,	O
new	O
)	O
;	O
scm_last	O
=	O
new	O
;	O
}	O
}	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
return	O
scm_first	O
;	O
}	O
static	O
void	O
scm_to_assoc	(*(struct),int)->(void)
(	O
dico_assoc_list_t	*(struct)
assoc	*(struct)
,	O
SCM	(*(int))->((*(void))->(int))
scm	int
)	O
{	O
dico_assoc_clear	(*(struct))->(int)
(	O
assoc	*(struct)
)	O
;	O
for	O
(	O
;	O
scm	int
!=	O
SCM_EOL	O
&&	O
scm_list_p	()->(int)
(	O
scm	int
)	O
;	O
scm	int
=	O
SCM_CDR	()->(int)
(	O
scm	int
)	O
)	O
{	O
SCM	(*(int))->((*(void))->(int))
elt	O
=	O
SCM_CAR	()->(int)
(	O
scm	int
)	O
;	O
if	O
(	O
!	O
scm_is_pair	()->(int)
(	O
elt	O
)	O
)	O
{	O
scm_misc_error	()->(int)
(	O
NULL	O
,	O
"Wrong element type: ~S"	*(char)
,	O
scm_list_1	()->(int)
(	O
elt	O
)	O
)	O
;	O
}	O
dico_assoc_append	(*(struct),*(char),*(char))->(int)
(	O
assoc	*(struct)
,	O
scm_to_locale_string	()->(int)
(	O
SCM_CAR	()->(int)
(	O
elt	O
)	O
)	O
,	O
scm_to_locale_string	()->(int)
(	O
SCM_CDR	()->(int)
(	O
elt	O
)	O
)	O
)	O
;	O
}	O
}	O
static	O
int	O
mod_open	(*(struct))->(int)
(	O
dico_handle_t	*(struct)
dp	*(struct(*(struct)))
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
dp	*(struct(*(struct)))
;	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
db	*(char)
->	O
handle	int
,	O
db	*(char)
->	O
vtab	array(int)
[	O
open_proc	int
]	O
,	O
scm_cons	()->(int)
(	O
scm_from_locale_string	()->(int)
(	O
db	*(char)
->	O
dbname	*(char)
)	O
,	O
argv_to_scm	(int,*(*(char)))->(int)
(	O
db	*(char)
->	O
argc	int
,	O
db	*(char)
->	O
argv	*(*(char))
)	O
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
db	*(char)
->	O
handle	int
==	O
SCM_EOL	O
||	O
db	*(char)
->	O
handle	int
==	O
SCM_BOOL_F	O
)	O
return	O
1	int
;	O
scm_gc_protect_object	()->(int)
(	O
db	*(char)
->	O
handle	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
mod_get_text	(*(struct(*(char),array(int),int,*(*(char)),int)),int)->(*(char))
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
,	O
int	O
n	long
)	O
{	O
if	O
(	O
db	*(char)
->	O
vtab	array(int)
[	O
n	long
]	O
)	O
{	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
db	*(char)
->	O
vtab	array(int)
[	O
n	long
]	O
,	O
scm_list_1	()->(int)
(	O
db	*(char)
->	O
handle	int
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
scm_is_string	()->(int)
(	O
res	int
)	O
)	O
return	O
scm_to_locale_string	()->(int)
(	O
res	int
)	O
;	O
else	O
{	O
rettype_error	(int)->(void)
(	O
db	*(char)
->	O
vtab	array(int)
[	O
n	long
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
mod_info	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
hp	*(struct)
;	O
return	O
mod_get_text	(*(struct(*(char),array(int),int,*(*(char)),int)),int)->(*(char))
(	O
db	*(char)
,	O
info_proc	int
)	O
;	O
}	O
static	O
char	O
*	O
mod_descr	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
hp	*(struct)
;	O
return	O
mod_get_text	(*(struct(*(char),array(int),int,*(*(char)),int)),int)->(*(char))
(	O
db	*(char)
,	O
descr_proc	int
)	O
;	O
}	O
static	O
dico_list_t	*(struct)
scm_to_langlist	(int,int)->(*(struct))
(	O
SCM	(*(int))->((*(void))->(int))
scm	int
,	O
SCM	(*(int))->((*(void))->(int))
procsym	int
)	O
{	O
dico_list_t	*(struct)
list	array(*(struct))
=	O
NULL	O
;	O
if	O
(	O
scm	int
==	O
SCM_EOL	O
)	O
return	O
NULL	O
;	O
else	O
if	O
(	O
scm_is_string	()->(int)
(	O
scm	int
)	O
)	O
{	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
,	O
scm_to_locale_string	()->(int)
(	O
scm	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
scm_list_p	()->(int)
(	O
scm	int
)	O
)	O
{	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
for	O
(	O
;	O
scm	int
!=	O
SCM_EOL	O
&&	O
scm_list_p	()->(int)
(	O
scm	int
)	O
;	O
scm	int
=	O
SCM_CDR	()->(int)
(	O
scm	int
)	O
)	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
,	O
scm_to_locale_string	()->(int)
(	O
SCM_CAR	()->(int)
(	O
scm	int
)	O
)	O
)	O
;	O
}	O
else	O
rettype_error	(int)->(void)
(	O
procsym	int
)	O
;	O
return	O
list	array(*(struct))
;	O
}	O
static	O
int	O
mod_lang	(*(struct),array(*(struct)))->(int)
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
dico_list_t	*(struct)
list	array(*(struct))
[	O
2	int
]	O
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
hp	*(struct)
;	O
SCM	(*(int))->((*(void))->(int))
proc	int
=	O
db	*(char)
->	O
vtab	array(int)
[	O
lang_proc	int
]	O
;	O
list	array(*(struct))
[	O
0	int
]	O
=	O
list	array(*(struct))
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
proc	int
)	O
{	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
proc	int
,	O
scm_list_1	()->(int)
(	O
db	*(char)
->	O
handle	int
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
res	int
==	O
SCM_EOL	O
)	O
;	O
else	O
if	O
(	O
scm_is_string	()->(int)
(	O
res	int
)	O
)	O
{	O
list	array(*(struct))
[	O
0	int
]	O
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
[	O
0	int
]	O
,	O
scm_to_locale_string	()->(int)
(	O
res	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
scm_is_pair	()->(int)
(	O
res	int
)	O
)	O
{	O
list	array(*(struct))
[	O
0	int
]	O
=	O
scm_to_langlist	(int,int)->(*(struct))
(	O
SCM_CAR	()->(int)
(	O
res	int
)	O
,	O
proc	int
)	O
;	O
list	array(*(struct))
[	O
1	int
]	O
=	O
scm_to_langlist	(int,int)->(*(struct))
(	O
SCM_CDR	()->(int)
(	O
res	int
)	O
,	O
proc	int
)	O
;	O
}	O
else	O
{	O
rettype_error	(int)->(void)
(	O
proc	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
;	O
SCM	(*(int))->((*(void))->(int))
result	*(int)
;	O
}	O
;	O
static	O
dico_result_t	*(struct)
make_guile_result	(*(struct(*(char),array(int),int,*(*(char)),int)),int)->(*(struct))
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
,	O
SCM	(*(int))->((*(void))->(int))
res	int
)	O
{	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
rp	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
rp	*(struct)
)	O
)	O
;	O
if	O
(	O
rp	*(struct)
)	O
{	O
rp	*(struct)
->	O
db	*(char)
=	O
db	*(char)
;	O
rp	*(struct)
->	O
result	*(int)
=	O
res	int
;	O
}	O
return	O
(	O
dico_result_t	*(struct)
)	O
rp	*(struct)
;	O
}	O
static	O
dico_result_t	*(struct)
mod_match	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
const	O
dico_strategy_t	*(struct)
strat	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
hp	*(struct)
;	O
SCM	(*(int))->((*(void))->(int))
scm_strat	O
=	O
_make_strategy	(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))))->(int)
(	O
strat	*(struct)
)	O
;	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
*	O
key	*(char)
;	O
SCM	(*(int))->((*(void))->(int))
scm_key	O
;	O
scm_key	O
=	O
dico_new_scm_key	(*(*(struct(*(char),*(void),*(struct`),int))))->(int)
(	O
&	O
key	*(char)
)	O
;	O
if	O
(	O
dico_key_init	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(int)
(	O
key	*(char)
,	O
strat	*(struct)
,	O
word	*(char)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_match: key initialization failed"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
db	*(char)
->	O
vtab	array(int)
[	O
match_proc	int
]	O
,	O
scm_list_3	()->(int)
(	O
db	*(char)
->	O
handle	int
,	O
scm_strat	O
,	O
scm_key	O
)	O
)	O
)	O
return	O
NULL	O
;	O
dico_key_deinit	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)))->(void)
(	O
key	*(char)
)	O
;	O
if	O
(	O
res	int
==	O
SCM_BOOL_F	O
||	O
res	int
==	O
SCM_EOL	O
)	O
return	O
NULL	O
;	O
scm_gc_protect_object	()->(int)
(	O
res	int
)	O
;	O
return	O
make_guile_result	(*(struct(*(char),array(int),int,*(*(char)),int)),int)->(*(struct))
(	O
db	*(char)
,	O
res	int
)	O
;	O
}	O
static	O
dico_result_t	*(struct)
mod_define	(*(struct),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
hp	*(struct)
;	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
db	*(char)
->	O
vtab	array(int)
[	O
define_proc	int
]	O
,	O
scm_list_2	()->(int)
(	O
db	*(char)
->	O
handle	int
,	O
scm_from_locale_string	()->(int)
(	O
word	*(char)
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
res	int
==	O
SCM_BOOL_F	O
||	O
res	int
==	O
SCM_EOL	O
)	O
return	O
NULL	O
;	O
scm_gc_protect_object	()->(int)
(	O
res	int
)	O
;	O
return	O
make_guile_result	(*(struct(*(char),array(int),int,*(*(char)),int)),int)->(*(struct))
(	O
db	*(char)
,	O
res	int
)	O
;	O
}	O
static	O
int	O
mod_output_result	(*(struct),long,*(struct))->(int)
(	O
dico_result_t	*(struct)
rp	*(struct)
,	O
size_t	long
n	long
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
int	O
rc	int
;	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
=	O
(	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
)	O
rp	*(struct)
;	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
SCM	(*(int))->((*(void))->(int))
oport	O
=	O
scm_current_output_port	O
(	O
)	O
;	O
SCM	(*(int))->((*(void))->(int))
port	*(char)
=	O
_make_dico_port	(*(struct))->(int)
(	O
str	*(struct)
)	O
;	O
scm_set_current_output_port	()->(int)
(	O
port	*(char)
)	O
;	O
rc	int
=	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
output_proc	int
]	O
,	O
scm_list_2	()->(int)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
result	*(int)
,	O
scm_from_int	()->(int)
(	O
n	long
)	O
)	O
)	O
;	O
scm_set_current_output_port	()->(int)
(	O
oport	O
)	O
;	O
_dico_port_close	(int)->(void)
(	O
port	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
mod_result_count	(*(struct))->(long)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
=	O
(	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
)	O
rp	*(struct)
;	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
result_count_proc	int
]	O
,	O
scm_list_1	()->(int)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
result	*(int)
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
scm_is_integer	()->(int)
(	O
res	int
)	O
)	O
return	O
scm_to_int32	()->(int)
(	O
res	int
)	O
;	O
else	O
rettype_error	(int)->(void)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
result_count_proc	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
mod_compare_count	(*(struct))->(long)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
=	O
(	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
)	O
rp	*(struct)
;	O
if	O
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
compare_count_proc	int
]	O
)	O
{	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
compare_count_proc	int
]	O
,	O
scm_list_1	()->(int)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
result	*(int)
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
scm_is_integer	()->(int)
(	O
res	int
)	O
)	O
return	O
scm_to_int32	()->(int)
(	O
res	int
)	O
;	O
else	O
rettype_error	(int)->(void)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
compare_count_proc	int
]	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
mod_free_result	(*(struct))->(void)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
=	O
(	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
)	O
rp	*(struct)
;	O
if	O
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
free_result_proc	int
]	O
)	O
{	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
free_result_proc	int
]	O
,	O
scm_list_1	()->(int)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
result	*(int)
)	O
)	O
;	O
}	O
scm_gc_unprotect_object	()->(int)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
result	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
)	O
;	O
}	O
static	O
int	O
mod_result_headers	(*(struct),*(struct))->(int)
(	O
dico_result_t	*(struct)
rp	*(struct)
,	O
dico_assoc_list_t	*(struct)
hdr	*(struct)
)	O
{	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
=	O
(	O
struct	O
guile_result	struct(*(struct(*(char),array(int),int,*(*(char)),int)),int)
*	O
)	O
rp	*(struct)
;	O
SCM	(*(int))->((*(void))->(int))
proc	int
=	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
db	*(char)
->	O
vtab	array(int)
[	O
result_headers_proc	int
]	O
;	O
if	O
(	O
proc	int
)	O
{	O
SCM	(*(int))->((*(void))->(int))
res	int
;	O
if	O
(	O
guile_call_proc	(*(int),int,int)->(int)
(	O
&	O
res	int
,	O
proc	int
,	O
scm_list_2	()->(int)
(	O
gres	*(struct(*(struct(*(char),array(int),int,*(*`),int)),int))
->	O
result	*(int)
,	O
assoc_to_scm	(*(struct))->(int)
(	O
hdr	*(struct)
)	O
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
scm_list_p	()->(int)
(	O
res	int
)	O
)	O
{	O
rettype_error	(int)->(void)
(	O
proc	int
)	O
;	O
return	O
1	int
;	O
}	O
scm_to_assoc	(*(struct),int)->(void)
(	O
hdr	*(struct)
,	O
res	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
mod_db_mime_header	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
db	*(char)
=	O
(	O
struct	O
_guile_database	struct(*(char),array(int),int,*(*(char)),int)
*	O
)	O
hp	*(struct)
;	O
return	O
mod_get_text	(*(struct(*(char),array(int),int,*(*(char)),int)),int)->(*(char))
(	O
db	*(char)
,	O
db_mime_header_proc	int
)	O
;	O
}	O
struct	O
dico_database_module	struct(int,int,*((int,*(*(char)))->(int)),*((*(char),int,*(*(char)))->(*(struct))),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(*(char))),*((*(struct))->(*(char))),*((*(struct),array(*(struct)))->(int)),*((*(struct),*(struct),*(char))->(*(struct))),*((*(struct),*(char))->(*(struct))),*((*(struct),long,*(struct))->(int)),*((*(struct))->(long)),*((*(struct))->(long)),*((*(struct))->(void)),*((*(struct),*(struct))->(int)),*((int,*(*(char)))->(int)),*((*(struct))->(*(char))),*((*(char),int,*(*(char)),*(void))->(*(struct))),*((*(struct))->(int)),*((*(struct),long)->(*(struct))))
DICO_EXPORT	O
(	O
guile	O
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NONE	int
,	O
.	O
dico_init	*((int,*(*(char)))->(int))
=	O
mod_init	(int,*(*(char)))->(int)
,	O
.	O
dico_init_db	*((*(char),int,*(*(char)))->(*(struct)))
=	O
mod_init_db	(*(char),int,*(*(char)))->(*(struct))
,	O
.	O
dico_free_db	*((*(struct))->(int))
=	O
mod_free_db	(*(struct))->(int)
,	O
.	O
dico_open	*((*(struct))->(int))
=	O
mod_open	(*(struct))->(int)
,	O
.	O
dico_close	*((*(struct))->(int))
=	O
mod_close	(*(struct))->(int)
,	O
.	O
dico_db_info	*((*(struct))->(*(char)))
=	O
mod_info	(*(struct))->(*(char))
,	O
.	O
dico_db_descr	*((*(struct))->(*(char)))
=	O
mod_descr	(*(struct))->(*(char))
,	O
.	O
dico_db_lang	*((*(struct),array(*(struct)))->(int))
=	O
mod_lang	(*(struct),array(*(struct)))->(int)
,	O
.	O
dico_match	*((*(struct),*(struct),*(char))->(*(struct)))
=	O
mod_match	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
,	O
.	O
dico_define	*((*(struct),*(char))->(*(struct)))
=	O
mod_define	(*(struct),*(char))->(*(struct))
,	O
.	O
dico_output_result	*((*(struct),long,*(struct))->(int))
=	O
mod_output_result	(*(struct),long,*(struct))->(int)
,	O
.	O
dico_result_count	*((*(struct))->(long))
=	O
mod_result_count	(*(struct))->(long)
,	O
.	O
dico_compare_count	*((*(struct))->(long))
=	O
mod_compare_count	(*(struct))->(long)
,	O
.	O
dico_free_result	*((*(struct))->(void))
=	O
mod_free_result	(*(struct))->(void)
,	O
.	O
dico_result_headers	*((*(struct),*(struct))->(int))
=	O
mod_result_headers	(*(struct),*(struct))->(int)
,	O
.	O
dico_db_mime_header	*((*(struct))->(*(char)))
=	O
mod_db_mime_header	(*(struct))->(*(char))
}	O
;	O
