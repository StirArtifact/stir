extern	O
int	O
optind	int
;	O
typedef	O
enum	O
{	O
NOPARM	int
,	O
OPTIONAL	int
,	O
BOOLEAN	int
,	O
CHAR	int
,	O
CHOICE	int
,	O
SHORT	int
,	O
INT	int
,	O
STRING	int
,	O
FLAG_STRING	int
}	O
option_types	enum(int,int,int,int,int,int,int,int,int)
;	O
typedef	O
struct	O
option_type	struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))))
{	O
char	O
letter	char
;	O
option_types	enum(int,int,int,int,int,int,int,int,int)
type	enum(int,int,int,int,int,int,int,int,int)
;	O
boolean	enum(int,int,int)
set	enum(int,int,int)
;	O
char	O
need_string	char
;	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
;	O
union	O
{	O
struct	O
{	O
char	O
*	O
string	*(char)
;	O
boolean	enum(int,int,int)
default_opt	enum(int,int,int)
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
;	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
void	O
)	O
;	O
char	O
*	O
help_string	*(char)
;	O
}	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
;	O
struct	O
{	O
char	O
*	O
string	*(char)
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
value	*(char)
)	O
;	O
char	O
*	O
help_string	*(char)
;	O
}	O
ooptional	struct(*(char),*((*(char),*(char),*(char))->(void)),*(char))
;	O
struct	O
{	O
char	O
*	O
true_string	*(char)
;	O
char	O
*	O
false_string	*(char)
;	O
boolean	enum(int,int,int)
*	O
var	*(enum(int,int,int))
;	O
boolean	enum(int,int,int)
default_value	enum(int,int,int)
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
boolean	enum(int,int,int)
value	*(char)
)	O
;	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
boolean	enum(int,int,int)
value	*(char)
)	O
;	O
char	O
*	O
true_help_string	*(char)
;	O
char	O
*	O
false_help_string	*(char)
;	O
}	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
;	O
struct	O
{	O
char	O
*	O
string	*(char)
;	O
char	O
*	O
var	*(enum(int,int,int))
;	O
char	O
default_value	enum(int,int,int)
;	O
char	O
*	O
valid_set	*(char)
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
value	*(char)
,	O
char	O
*	O
valid_set	*(char)
)	O
;	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
char	O
value	*(char)
)	O
;	O
char	O
*	O
help_string	*(char)
;	O
}	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
;	O
struct	O
{	O
char	O
*	O
var	*(enum(int,int,int))
;	O
char	O
*	O
choice1_string	*(char)
;	O
char	O
*	O
choice2_string	*(char)
;	O
char	O
choice1	char
;	O
char	O
choice2	char
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
value	*(char)
)	O
;	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
char	O
value	*(char)
)	O
;	O
char	O
*	O
choice1_help_string	*(char)
;	O
char	O
*	O
choice2_help_string	*(char)
;	O
}	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
;	O
struct	O
{	O
char	O
*	O
string	*(char)
;	O
short	O
*	O
var	*(enum(int,int,int))
;	O
short	O
default_value	enum(int,int,int)
;	O
char	O
*	O
special_string	*(char)
;	O
short	O
special_value	short
;	O
short	O
min	short
;	O
short	O
max	short
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
short	O
value	*(char)
,	O
short	O
min	short
,	O
short	O
max	short
)	O
;	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
short	O
value	*(char)
)	O
;	O
char	O
*	O
help_string	*(char)
;	O
char	O
*	O
special_help_string	*(char)
;	O
}	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
;	O
struct	O
{	O
char	O
*	O
string	*(char)
;	O
int	O
*	O
var	*(enum(int,int,int))
;	O
int	O
default_value	enum(int,int,int)
;	O
char	O
*	O
special_string	*(char)
;	O
short	O
special_value	short
;	O
int	O
min	short
;	O
int	O
max	short
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
int	O
value	*(char)
,	O
int	O
min	short
,	O
int	O
max	short
)	O
;	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
int	O
value	*(char)
)	O
;	O
char	O
*	O
help_string	*(char)
;	O
char	O
*	O
special_help_string	*(char)
;	O
}	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
;	O
struct	O
{	O
char	O
*	O
string	*(char)
;	O
char	O
*	O
*	O
var	*(enum(int,int,int))
;	O
char	O
*	O
default_value	enum(int,int,int)
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
value	*(char)
)	O
;	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
char	O
*	O
value	*(char)
)	O
;	O
char	O
*	O
help_string	*(char)
;	O
}	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
;	O
struct	O
{	O
char	O
*	O
set_string	*(char)
;	O
char	O
*	O
not_set_string	*(char)
;	O
boolean	enum(int,int,int)
flag_var	enum(int,int,int)
;	O
char	O
*	O
*	O
var	*(enum(int,int,int))
;	O
boolean	enum(int,int,int)
default_value	enum(int,int,int)
;	O
char	O
*	O
true_value	*(char)
;	O
char	O
*	O
false_value	*(char)
;	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
boolean	enum(int,int,int)
value	*(char)
,	O
char	O
*	O
true_value	*(char)
,	O
char	O
*	O
false_value	*(char)
)	O
;	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
boolean	enum(int,int,int)
value	*(char)
,	O
char	O
*	O
string_value	*(char)
)	O
;	O
char	O
*	O
set_help_string	*(char)
;	O
char	O
*	O
not_set_help_string	*(char)
;	O
}	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
;	O
}	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
;	O
}	O
option_type	struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))))
;	O
static	O
void	O
set_option	(int,*(char),*(char),*(char))->(void)
(	O
int	O
option	struct(*(char),int,*(int),int)
,	O
char	O
*	O
prefix	*(char)
,	O
const	O
char	O
*	O
option_name	*(char)
,	O
char	O
*	O
value	*(char)
)	O
;	O
static	O
void	O
set_option_default	(int)->(void)
(	O
int	O
option	struct(*(char),int,*(int),int)
)	O
;	O
static	O
int	O
short_options	array(int)
[	O
62	int
]	O
;	O
static	O
struct	O
option_type	struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))))
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
MAX_OPTIONS	int
+	O
1	int
]	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
MAX_OPTIONS	int
+	O
1	int
]	O
;	O
static	O
int	O
next_option	int
;	O
static	O
int	O
next_long_option	int
;	O
static	O
int	O
this_option	int
;	O
void	O
setup_options	()->(void)
(	O
void	O
)	O
{	O
next_option	int
=	O
0	int
;	O
next_long_option	int
=	O
0	int
;	O
}	O
void	O
handle_string_options	(*(char))->(void)
(	O
char	O
*	O
options	*(char)
)	O
{	O
int	O
opt_argc	int
=	O
-	O
1	int
;	O
char	O
arguments	array(array(char))
[	O
100	int
]	O
[	O
100	int
]	O
;	O
char	O
*	O
opt_argv	array(*(char))
[	O
100	int
]	O
;	O
int	O
options_index	int
=	O
-	O
1	int
;	O
int	O
argv_index	int
=	O
0	int
;	O
boolean	enum(int,int,int)
quoted	enum(int,int,int)
=	O
FALSE	int
;	O
boolean	enum(int,int,int)
ended	enum(int,int,int)
=	O
FALSE	int
;	O
if	O
(	O
options	*(char)
==	O
(	O
char	O
*	O
)	O
0	int
)	O
return	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
options	*(char)
)	O
==	O
0	int
)	O
return	O
;	O
while	O
(	O
ended	enum(int,int,int)
==	O
FALSE	int
)	O
{	O
switch	O
(	O
options	*(char)
[	O
++	O
options_index	int
]	O
)	O
{	O
case	O
' '	O
:	O
case	O
'	'	O
:	O
if	O
(	O
quoted	enum(int,int,int)
)	O
{	O
if	O
(	O
argv_index	int
==	O
0	int
)	O
opt_argc	int
+=	O
1	int
;	O
arguments	array(array(char))
[	O
opt_argc	int
]	O
[	O
argv_index	int
++	O
]	O
=	O
options	*(char)
[	O
options_index	int
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
argv_index	int
>	O
0	int
)	O
{	O
arguments	array(array(char))
[	O
opt_argc	int
]	O
[	O
argv_index	int
]	O
=	O
'\0'	O
;	O
argv_index	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'\0'	O
:	O
if	O
(	O
argv_index	int
>	O
0	int
)	O
{	O
arguments	array(array(char))
[	O
opt_argc	int
]	O
[	O
argv_index	int
]	O
=	O
'\0'	O
;	O
argv_index	int
=	O
0	int
;	O
}	O
ended	enum(int,int,int)
=	O
TRUE	int
;	O
break	O
;	O
case	O
'"'	O
:	O
if	O
(	O
quoted	enum(int,int,int)
)	O
quoted	enum(int,int,int)
=	O
FALSE	int
;	O
else	O
quoted	enum(int,int,int)
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
argv_index	int
==	O
0	int
)	O
opt_argc	int
+=	O
1	int
;	O
arguments	array(array(char))
[	O
opt_argc	int
]	O
[	O
argv_index	int
++	O
]	O
=	O
options	*(char)
[	O
options_index	int
]	O
;	O
break	O
;	O
}	O
}	O
opt_argc	int
+=	O
1	int
;	O
for	O
(	O
argv_index	int
=	O
0	int
;	O
argv_index	int
<	O
opt_argc	int
;	O
argv_index	int
++	O
)	O
opt_argv	array(*(char))
[	O
argv_index	int
+	O
1	int
]	O
=	O
arguments	array(array(char))
[	O
argv_index	int
]	O
;	O
opt_argv	array(*(char))
[	O
0	int
]	O
=	O
opt_argv	array(*(char))
[	O
1	int
]	O
;	O
opt_argc	int
+=	O
1	int
;	O
handle_options	(int,*(*(char)))->(int)
(	O
opt_argc	int
,	O
opt_argv	array(*(char))
)	O
;	O
return	O
;	O
}	O
unsigned	O
int	O
handle_options	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
option	struct(*(char),int,*(int),int)
;	O
int	O
option_index	int
;	O
int	O
short_option_index	int
=	O
0	int
;	O
int	O
long_option_index	int
;	O
char	O
short_option_list	array(char)
[	O
125	int
]	O
;	O
optind	int
=	O
1	int
;	O
for	O
(	O
option_index	int
=	O
0	int
;	O
option_index	int
<	O
next_long_option	int
;	O
option_index	int
++	O
)	O
{	O
if	O
(	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
)	O
{	O
short_option_list	array(char)
[	O
short_option_index	int
++	O
]	O
=	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
;	O
if	O
(	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
)	O
short_option_list	array(char)
[	O
short_option_index	int
++	O
]	O
=	O
':'	O
;	O
}	O
}	O
long_options	array(struct(*(char),int,*(int),int))
[	O
next_long_option	int
]	O
.	O
name	*(char)
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
next_long_option	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
next_long_option	int
]	O
.	O
flag	*(int)
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
next_long_option	int
]	O
.	O
val	int
=	O
0	int
;	O
while	O
(	O
(	O
option	struct(*(char),int,*(int),int)
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
(	O
unsigned	O
int	O
)	O
argc	int
,	O
argv	*(*(char))
,	O
short_option_list	array(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
&	O
long_option_index	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
option	struct(*(char),int,*(int),int)
==	O
'?'	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gettext	(*(char))->(*(char))
(	O
CMD_NAME	*(char)
": failed to parse options\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
option	struct(*(char),int,*(int),int)
!=	O
0	int
)	O
{	O
char	O
*	O
option_name	*(char)
;	O
option_name	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
2	int
)	O
;	O
option_name	*(char)
[	O
0	int
]	O
=	O
option	struct(*(char),int,*(int),int)
;	O
option_name	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
option_index	int
=	O
SHORT_OPTION	O
(	O
option	struct(*(char),int,*(int),int)
)	O
;	O
set_option	(int,*(char),*(char),*(char))->(void)
(	O
option_index	int
,	O
"-"	*(char)
,	O
option_name	*(char)
,	O
optarg	*(char)
)	O
;	O
}	O
else	O
{	O
set_option	(int,*(char),*(char),*(char))->(void)
(	O
this_option	int
,	O
"--"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
,	O
optarg	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
optind	int
)	O
;	O
}	O
void	O
noparm_option	(*(char),*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s	*(char)
,	O
boolean	enum(int,int,int)
default_opt	enum(int,int,int)
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
)	O
,	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
void	O
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
s	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
default_opt	enum(int,int,int)
&&	O
set_default	*(()->(void))
==	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
NOPARM	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
string	*(char)
=	O
s	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
default_opt	enum(int,int,int)
=	O
default_opt	enum(int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
set_default	*(()->(void))
=	O
set_default	*(()->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
help_string	*(char)
=	O
help_string	*(char)
;	O
}	O
void	O
optional_string_option	(*(char),*(char),*((*(char),*(char),*(char))->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s	*(char)
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
value	*(char)
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
s	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
2	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
OPTIONAL	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ooptional	struct(*(char),*((*(char),*(char),*(char))->(void)),*(char))
.	O
string	*(char)
=	O
s	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ooptional	struct(*(char),*((*(char),*(char),*(char))->(void)),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ooptional	struct(*(char),*((*(char),*(char),*(char))->(void)),*(char))
.	O
help_string	*(char)
=	O
help_string	*(char)
;	O
}	O
void	O
boolean_option	(*(char),*(char),*(char),enum(int,int,int),*(enum(int,int,int)),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
s2	*(char)
,	O
boolean	enum(int,int,int)
default_value	enum(int,int,int)
,	O
boolean	enum(int,int,int)
*	O
var	*(enum(int,int,int))
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
boolean	enum(int,int,int)
value	*(char)
)	O
,	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
boolean	enum(int,int,int)
value	*(char)
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
true_help_string	*(char)
,	O
char	O
*	O
false_help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
c	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s1	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s1	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
s2	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s2	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
==	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
!=	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
!=	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
!=	O
(	O
set_default	*(()->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
BOOLEAN	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
true_string	*(char)
=	O
s1	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
false_string	*(char)
=	O
s2	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
=	O
var	*(enum(int,int,int))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
=	O
default_value	enum(int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
=	O
set_default	*(()->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
true_help_string	*(char)
=	O
true_help_string	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
false_help_string	*(char)
=	O
false_help_string	*(char)
;	O
}	O
void	O
choice_option	(*(char),*(char),*(char),char,char,*(char),*((*(char),*(char),char)->(void)),*((char)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
s2	*(char)
,	O
char	O
choice1	char
,	O
char	O
choice2	char
,	O
char	O
*	O
var	*(enum(int,int,int))
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
value	*(char)
)	O
,	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
char	O
value	*(char)
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
choice1_help_string	*(char)
,	O
char	O
*	O
choice2_help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s1	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s1	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
s2	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s2	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
==	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
!=	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
!=	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
!=	O
(	O
set_default	*(()->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
CHOICE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
=	O
var	*(enum(int,int,int))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1_string	*(char)
=	O
s1	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2_string	*(char)
=	O
s2	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1	char
=	O
choice1	char
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2	char
=	O
choice2	char
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
=	O
set_default	*(()->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1_help_string	*(char)
=	O
choice1_help_string	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2_help_string	*(char)
=	O
choice2_help_string	*(char)
;	O
}	O
void	O
char_option	(*(char),*(char),char,*(char),*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s	*(char)
,	O
char	O
default_value	enum(int,int,int)
,	O
char	O
*	O
valid_set	*(char)
,	O
char	O
*	O
var	*(enum(int,int,int))
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
value	*(char)
,	O
char	O
*	O
var	*(enum(int,int,int))
)	O
,	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
char	O
value	*(char)
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
==	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
!=	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
!=	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
!=	O
(	O
set_default	*(()->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
CHAR	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
string	*(char)
=	O
s	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
var	*(enum(int,int,int))
=	O
var	*(enum(int,int,int))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
default_value	enum(int,int,int)
=	O
default_value	enum(int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
valid_set	*(char)
=	O
valid_set	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
set_default	*(()->(void))
=	O
set_default	*(()->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
help_string	*(char)
=	O
help_string	*(char)
;	O
}	O
void	O
short_option	(*(char),*(char),short,*(char),short,short,short,*(short),*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s	*(char)
,	O
short	O
default_value	enum(int,int,int)
,	O
char	O
*	O
special_string	*(char)
,	O
short	O
special_value	short
,	O
short	O
min	short
,	O
short	O
max	short
,	O
short	O
*	O
var	*(enum(int,int,int))
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
short	O
value	*(char)
,	O
short	O
min	short
,	O
short	O
max	short
)	O
,	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
short	O
value	*(char)
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
help_string	*(char)
,	O
char	O
*	O
special_help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
special_string	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
special_string	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
==	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
!=	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
!=	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
!=	O
(	O
set_default	*(()->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
SHORT	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
string	*(char)
=	O
s	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
=	O
var	*(enum(int,int,int))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
min	short
=	O
min	short
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
max	short
=	O
max	short
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
=	O
default_value	enum(int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
=	O
set_default	*(()->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
help_string	*(char)
=	O
help_string	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
special_string	*(char)
=	O
special_string	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
special_value	short
=	O
special_value	short
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
special_help_string	*(char)
=	O
special_help_string	*(char)
;	O
}	O
void	O
int_option	(*(char),*(char),int,*(char),int,int,int,*(int),*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s	*(char)
,	O
int	O
default_value	enum(int,int,int)
,	O
char	O
*	O
special_string	*(char)
,	O
int	O
special_value	short
,	O
int	O
min	short
,	O
int	O
max	short
,	O
int	O
*	O
var	*(enum(int,int,int))
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
int	O
value	*(char)
,	O
int	O
min	short
,	O
int	O
max	short
)	O
,	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
int	O
value	*(char)
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
help_string	*(char)
,	O
char	O
*	O
special_help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
special_string	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
special_string	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
==	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
!=	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
!=	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
!=	O
(	O
set_default	*(()->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
INT	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
string	*(char)
=	O
s	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
=	O
var	*(enum(int,int,int))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
min	short
=	O
min	short
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
max	short
=	O
max	short
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
=	O
default_value	enum(int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
=	O
set_default	*(()->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
help_string	*(char)
=	O
help_string	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
special_string	*(char)
=	O
special_string	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
special_value	short
=	O
special_value	short
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
special_help_string	*(char)
=	O
special_help_string	*(char)
;	O
}	O
void	O
string_option	(*(char),*(char),*(char),*(*(char)),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),enum(int,int,int,int,int,int),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
default_value	enum(int,int,int)
,	O
char	O
*	O
*	O
var	*(enum(int,int,int))
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
value	*(char)
)	O
,	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
char	O
*	O
value	*(char)
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
(	O
var	*(enum(int,int,int))
==	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
!=	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
!=	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
!=	O
(	O
set_default	*(()->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
STRING	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
TRUE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
string	*(char)
=	O
s	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
var	*(enum(int,int,int))
=	O
var	*(enum(int,int,int))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
default_value	enum(int,int,int)
=	O
default_value	enum(int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
set_default	*(()->(void))
=	O
set_default	*(()->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
help_string	*(char)
=	O
help_string	*(char)
;	O
}	O
void	O
flag_string_option	(*(char),*(char),*(char),enum(int,int,int),*(char),*(char),*(*(char)),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),enum(int,int,int,int,int,int),*(char),*(char))->(void)
(	O
char	O
*	O
c	*(char)
,	O
char	O
*	O
s1	*(char)
,	O
char	O
*	O
s2	*(char)
,	O
boolean	enum(int,int,int)
default_value	enum(int,int,int)
,	O
char	O
*	O
true_value	*(char)
,	O
char	O
*	O
false_value	*(char)
,	O
char	O
*	O
*	O
var	*(enum(int,int,int))
,	O
void	O
(	O
*	O
handler	*((*(char),*(char))->(void))
)	O
(	O
const	O
char	O
*	O
p	*(char)
,	O
const	O
char	O
*	O
s	*(char)
,	O
boolean	enum(int,int,int)
value	*(char)
,	O
char	O
*	O
true_value	*(char)
,	O
char	O
*	O
false_value	*(char)
)	O
,	O
void	O
(	O
*	O
set_default	*(()->(void))
)	O
(	O
boolean	enum(int,int,int)
value	*(char)
,	O
char	O
*	O
string_value	*(char)
)	O
,	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
,	O
char	O
*	O
set_help_string	*(char)
,	O
char	O
*	O
not_set_help_string	*(char)
)	O
{	O
int	O
option_index	int
=	O
next_option	int
++	O
;	O
if	O
(	O
c	*(char)
)	O
{	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
*	O
c	*(char)
;	O
SHORT_OPTION	O
(	O
*	O
c	*(char)
)	O
=	O
option_index	int
;	O
}	O
else	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
letter	char
=	O
0	int
;	O
if	O
(	O
s1	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s1	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
1	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
;	O
}	O
if	O
(	O
s2	*(char)
)	O
{	O
int	O
long_option_index	int
=	O
next_long_option	int
++	O
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
name	*(char)
=	O
s2	*(char)
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
has_arg	int
=	O
0	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
flag	*(int)
=	O
&	O
this_option	int
;	O
long_options	array(struct(*(char),int,*(int),int))
[	O
long_option_index	int
]	O
.	O
val	int
=	O
option_index	int
|	O
OPT_FLAG	int
;	O
}	O
if	O
(	O
(	O
next_option	int
>	O
MAX_OPTIONS	int
)	O
||	O
(	O
next_long_option	int
>	O
MAX_OPTIONS	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
==	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
var	*(enum(int,int,int))
!=	O
NULL	O
)	O
&&	O
(	O
handler	*((*(char),*(char))->(void))
!=	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
handler	*((*(char),*(char))->(void))
==	O
NULL	O
)	O
!=	O
(	O
set_default	*(()->(void))
==	O
NULL	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
type	enum(int,int,int,int,int,int,int,int,int)
=	O
FLAG_STRING	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
class	enum(int,int,int,int,int,int)
=	O
class	enum(int,int,int,int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
need_string	char
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
set	enum(int,int,int)
=	O
FALSE	int
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
=	O
var	*(enum(int,int,int))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_string	*(char)
=	O
s1	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
not_set_string	*(char)
=	O
s2	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
=	O
default_value	enum(int,int,int)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
true_value	*(char)
=	O
true_value	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
false_value	*(char)
=	O
false_value	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
=	O
handler	*((*(char),*(char))->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
=	O
set_default	*(()->(void))
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_help_string	*(char)
=	O
set_help_string	*(char)
;	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
.	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
not_set_help_string	*(char)
=	O
not_set_help_string	*(char)
;	O
}	O
void	O
set_option	(int,*(char),*(char),*(char))->(void)
(	O
int	O
index	(*(char),int)->(*(char))
,	O
char	O
*	O
prefix	*(char)
,	O
const	O
char	O
*	O
option_name	*(char)
,	O
char	O
*	O
value	*(char)
)	O
{	O
boolean	enum(int,int,int)
flag_set	enum(int,int,int)
=	O
(	O
(	O
index	(*(char),int)->(*(char))
&	O
OPT_FLAG	int
)	O
!=	O
0	int
)	O
;	O
struct	O
option_type	struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))))
*	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
;	O
if	O
(	O
flag_set	enum(int,int,int)
)	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
=	O
&	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
index	(*(char),int)->(*(char))
-	O
OPT_FLAG	int
]	O
;	O
else	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
=	O
&	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
index	(*(char),int)->(*(char))
]	O
;	O
if	O
(	O
value	*(char)
)	O
dm	(char,int,*(char))->(void)
(	O
'o'	O
,	O
3	int
,	O
"Trying to set option %s%s to %s\n"	*(char)
,	O
prefix	*(char)
,	O
option_name	*(char)
,	O
value	*(char)
)	O
;	O
else	O
dm	(char,int,*(char))->(void)
(	O
'o'	O
,	O
3	int
,	O
"Trying to set option %s%s\n"	*(char)
,	O
prefix	*(char)
,	O
option_name	*(char)
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
set	enum(int,int,int)
)	O
{	O
dm	(char,int,*(char))->(void)
(	O
'o'	O
,	O
3	int
,	O
"Option %s%s already set\n"	*(char)
,	O
prefix	*(char)
,	O
option_name	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
type	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
NOPARM	int
:	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
)	O
;	O
break	O
;	O
case	O
OPTIONAL	int
:	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ooptional	struct(*(char),*((*(char),*(char),*(char))->(void)),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
value	*(char)
)	O
;	O
break	O
;	O
case	O
BOOLEAN	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
(	O
!	O
flag_set	enum(int,int,int)
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
!	O
flag_set	enum(int,int,int)
)	O
;	O
}	O
break	O
;	O
case	O
CHAR	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
!=	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gettext	(*(char))->(*(char))
(	O
CMD_NAME	*(char)
": must have one character parameter for %s%s flag, but got '%s'\n"	*(char)
)	O
,	O
prefix	*(char)
,	O
option_name	*(char)
,	O
value	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
*	O
value	*(char)
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
*	O
value	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
valid_set	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
CHOICE	int
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
prefix	*(char)
)	O
==	O
1	int
)	O
{	O
if	O
(	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
!=	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gettext	(*(char))->(*(char))
(	O
CMD_NAME	*(char)
": must have one character parameter for %s%s flag, but got '%s'\n"	*(char)
)	O
,	O
prefix	*(char)
,	O
option_name	*(char)
,	O
value	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
*	O
value	*(char)
!=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1	char
)	O
&&	O
(	O
*	O
value	*(char)
!=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2	char
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gettext	(*(char))->(*(char))
(	O
CMD_NAME	*(char)
": option %s%s can only take %c or %c, not %c\n"	*(char)
)	O
,	O
prefix	*(char)
,	O
option_name	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1	char
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2	char
,	O
*	O
value	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
*	O
value	*(char)
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
*	O
value	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
char	O
chosen_value	char
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
option_name	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1_string	*(char)
)	O
==	O
0	int
)	O
{	O
chosen_value	char
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1	char
;	O
}	O
else	O
{	O
chosen_value	char
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2	char
;	O
}	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
chosen_value	char
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
chosen_value	char
)	O
;	O
}	O
}	O
break	O
;	O
case	O
SHORT	int
:	O
if	O
(	O
flag_set	enum(int,int,int)
)	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
special_value	short
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
special_value	short
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
min	short
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
max	short
)	O
;	O
}	O
}	O
else	O
{	O
int	O
intvalue	int
=	O
atoi	(*(char))->(int)
(	O
value	*(char)
)	O
;	O
if	O
(	O
(	O
intvalue	int
>	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
max	short
)	O
||	O
(	O
intvalue	int
<	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
min	short
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gettext	(*(char))->(*(char))
(	O
CMD_NAME	*(char)
": option %s%s not between %d and %d\n"	*(char)
)	O
,	O
prefix	*(char)
,	O
option_name	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
min	short
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
max	short
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
(	O
short	O
)	O
intvalue	int
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
(	O
short	O
)	O
intvalue	int
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
min	short
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
max	short
)	O
;	O
}	O
}	O
break	O
;	O
case	O
INT	int
:	O
if	O
(	O
flag_set	enum(int,int,int)
)	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
special_value	short
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
special_value	short
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
min	short
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
max	short
)	O
;	O
}	O
}	O
else	O
{	O
int	O
intvalue	int
=	O
atoi	(*(char))->(int)
(	O
value	*(char)
)	O
;	O
if	O
(	O
(	O
intvalue	int
>	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
max	short
)	O
||	O
(	O
intvalue	int
<	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
min	short
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gettext	(*(char))->(*(char))
(	O
CMD_NAME	*(char)
": option %s%s not between %d and %d\n"	*(char)
)	O
,	O
prefix	*(char)
,	O
option_name	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
min	short
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
max	short
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
intvalue	int
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
intvalue	int
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
min	short
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
max	short
)	O
;	O
}	O
}	O
break	O
;	O
case	O
STRING	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
strdup	(*(char))->(*(char))
(	O
value	*(char)
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
value	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
FLAG_STRING	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
if	O
(	O
flag_set	enum(int,int,int)
)	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
true_value	*(char)
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
strdup	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
true_value	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
false_value	*(char)
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
strdup	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
false_value	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
NULL	O
;	O
}	O
}	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
handler	*((*(char),*(char))->(void))
)	O
)	O
(	O
prefix	*(char)
,	O
option_name	*(char)
,	O
!	O
flag_set	enum(int,int,int)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
true_value	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
false_value	*(char)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
set	enum(int,int,int)
=	O
TRUE	int
;	O
dm	(char,int,*(char))->(void)
(	O
'o'	O
,	O
3	int
,	O
"Succeeded - %s%s has not been set before\n"	*(char)
,	O
prefix	*(char)
,	O
option_name	*(char)
)	O
;	O
}	O
void	O
set_option_default	(int)->(void)
(	O
int	O
index	(*(char),int)->(*(char))
)	O
{	O
option_type	struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))))
*	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
=	O
&	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
index	(*(char),int)->(*(char))
]	O
;	O
dm	(char,int,*(char))->(void)
(	O
'o'	O
,	O
3	int
,	O
"Trying to set option %d to default value\n"	*(char)
,	O
index	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
set	enum(int,int,int)
)	O
{	O
dm	(char,int,*(char))->(void)
(	O
'o'	O
,	O
3	int
,	O
"Option %d already set\n"	*(char)
,	O
index	(*(char),int)->(*(char))
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
type	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
NOPARM	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
default_opt	enum(int,int,int)
)	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
)	O
;	O
break	O
;	O
case	O
OPTIONAL	int
:	O
break	O
;	O
case	O
BOOLEAN	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
)	O
;	O
}	O
break	O
;	O
case	O
CHAR	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
default_value	enum(int,int,int)
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
default_value	enum(int,int,int)
)	O
;	O
}	O
break	O
;	O
case	O
CHOICE	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1	char
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1	char
)	O
;	O
}	O
break	O
;	O
case	O
SHORT	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
)	O
;	O
}	O
break	O
;	O
case	O
INT	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
)	O
;	O
}	O
break	O
;	O
case	O
STRING	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
default_value	enum(int,int,int)
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
strdup	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
default_value	enum(int,int,int)
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
default_value	enum(int,int,int)
)	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
strdup	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
default_value	enum(int,int,int)
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
NULL	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
FLAG_STRING	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
)	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
true_value	*(char)
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
strdup	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
true_value	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
false_value	*(char)
)	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
strdup	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
false_value	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
var	*(enum(int,int,int))
)	O
=	O
NULL	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
default_value	enum(int,int,int)
)	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
true_value	*(char)
)	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
1	int
,	O
strdup	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
true_value	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
1	int
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
false_value	*(char)
)	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
0	int
,	O
strdup	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
false_value	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_default	*(()->(void))
)	O
)	O
(	O
0	int
,	O
NULL	O
)	O
;	O
}	O
}	O
}	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
dm	(char,int,*(char))->(void)
(	O
'o'	O
,	O
3	int
,	O
"Succeeded - option %d has not been set before\n"	*(char)
,	O
index	(*(char),int)->(*(char))
)	O
;	O
}	O
void	O
print_usage_msgs	(enum(int,int,int,int,int,int))->(void)
(	O
option_class	enum(int,int,int,int,int,int)
class	enum(int,int,int,int,int,int)
)	O
{	O
int	O
option_index	int
;	O
switch	O
(	O
class	enum(int,int,int,int,int,int)
)	O
{	O
case	O
OPT_MISC	int
:	O
printf	(*(char))->(int)
(	O
gettext	(*(char))->(*(char))
(	O
"Miscellaneous options:\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_PAGE_FURNITURE	int
:	O
printf	(*(char))->(int)
(	O
gettext	(*(char))->(*(char))
(	O
"Page furniture options:\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_TEXT_FORMAT	int
:	O
printf	(*(char))->(int)
(	O
gettext	(*(char))->(*(char))
(	O
"Text formatting options:\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_PRINT	int
:	O
printf	(*(char))->(int)
(	O
gettext	(*(char))->(*(char))
(	O
"Print selection options:\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_PAGE_FORMAT	int
:	O
printf	(*(char))->(int)
(	O
gettext	(*(char))->(*(char))
(	O
"Page format options:\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPT_OUTPUT	int
:	O
printf	(*(char))->(int)
(	O
gettext	(*(char))->(*(char))
(	O
"Output options:\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
for	O
(	O
option_index	int
=	O
0	int
;	O
option_index	int
<	O
next_option	int
;	O
option_index	int
++	O
)	O
{	O
option_type	struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))))
*	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
=	O
&	O
option_list	array(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
[	O
option_index	int
]	O
;	O
if	O
(	O
class	enum(int,int,int,int,int,int)
==	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
class	enum(int,int,int,int,int,int)
)	O
{	O
switch	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
type	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
NOPARM	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
onoparm	struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char))
.	O
help_string	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
OPTIONAL	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ooptional	struct(*(char),*((*(char),*(char),*(char))->(void)),*(char))
.	O
string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s[=<string>]"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ooptional	struct(*(char),*((*(char),*(char),*(char))->(void)),*(char))
.	O
string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ooptional	struct(*(char),*((*(char),*(char),*(char))->(void)),*(char))
.	O
help_string	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
BOOLEAN	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
true_string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
true_string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
true_help_string	*(char)
)	O
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"--%c  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
false_string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
false_string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
obool	struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char))
.	O
false_help_string	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
CHAR	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c <char>  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s <char>"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochar	struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char))
.	O
help_string	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
CHOICE	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c %c  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1_string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1_string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice1_help_string	*(char)
)	O
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c %c  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2_string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2_string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ochoice	struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char))
.	O
choice2_help_string	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
SHORT	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c <number>  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s=<number>"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
help_string	*(char)
)	O
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
special_string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s\n    %s\n"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
special_string	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oshrt	struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char))
.	O
special_help_string	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
INT	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c <number>  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s=<number>"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
help_string	*(char)
)	O
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
special_string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s\n    %s\n"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
special_string	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oint	struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char))
.	O
special_help_string	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
STRING	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c <string>  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s=<string>"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
ostrng	struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char))
.	O
help_string	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
FLAG_STRING	int
:	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"-%c <string>  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s=<string>"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_help_string	*(char)
)	O
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
printf	(*(char))->(int)
(	O
"--%c  "	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
letter	char
)	O
;	O
if	O
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
set_string	*(char)
)	O
printf	(*(char))->(int)
(	O
"--%s"	*(char)
,	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
not_set_string	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n    %s\n"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
op	*(struct(char,enum(int,int,int,int,int,int,int,int,int),enum(int,int,int),char,enum(int,int,int,int,int,int),union(struct(*(char),enum(int,int,int),*((*`,*`)->(void)),*(()->(void)),*(char)),struct(*(char),*((*`,*`,*`)->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*`,*`,enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*`,*`,char,*`)->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*`,*`,char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*`,*`,short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*`,*`,int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*`),*(char),*((*`,*`,*`)->(void)),*((*`)->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*`),enum(int,int,int),*(char),*(char),*((*`,*`,enum(int,int,int),*`,*`)->(void)),*((enum(int,int,int),*`)->(void)),*(char),*(char)))))
->	O
t	union(struct(*(char),enum(int,int,int),*((*(char),*(char))->(void)),*(()->(void)),*(char)),struct(*(char),*((*(char),*(char),*(char))->(void)),*(char)),struct(*(char),*(char),*(enum(int,int,int)),enum(int,int,int),*((*(char),*(char),enum(int,int,int))->(void)),*((enum(int,int,int))->(void)),*(char),*(char)),struct(*(char),*(char),char,*(char),*((*(char),*(char),char,*(char))->(void)),*((char)->(void)),*(char)),struct(*(char),*(char),*(char),char,char,*((*(char),*(char),char)->(void)),*((char)->(void)),*(char),*(char)),struct(*(char),*(short),short,*(char),short,short,short,*((*(char),*(char),short,short,short)->(void)),*((short)->(void)),*(char),*(char)),struct(*(char),*(int),int,*(char),short,int,int,*((*(char),*(char),int,int,int)->(void)),*((int)->(void)),*(char),*(char)),struct(*(char),*(*(char)),*(char),*((*(char),*(char),*(char))->(void)),*((*(char))->(void)),*(char)),struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char)))
.	O
oflg	struct(*(char),*(char),enum(int,int,int),*(*(char)),enum(int,int,int),*(char),*(char),*((*(char),*(char),enum(int,int,int),*(char),*(char))->(void)),*((enum(int,int,int),*(char))->(void)),*(char),*(char))
.	O
not_set_help_string	*(char)
)	O
)	O
;	O
}	O
}	O
}	O
}	O
void	O
set_option_defaults	()->(void)
(	O
void	O
)	O
{	O
int	O
option_index	int
;	O
for	O
(	O
option_index	int
=	O
0	int
;	O
option_index	int
<	O
next_option	int
;	O
option_index	int
++	O
)	O
{	O
set_option_default	(int)->(void)
(	O
option_index	int
)	O
;	O
}	O
}	O
