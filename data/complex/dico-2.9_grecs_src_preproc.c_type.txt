int	O
grecs_log_to_stderr	int
=	O
1	int
;	O
void	O
(	O
*	O
grecs_log_setup_hook	*(()->(void))
)	O
(	O
)	O
=	O
NULL	O
;	O
struct	O
input_file_ident	struct(long,long)
{	O
ino_t	long
i_node	long
;	O
dev_t	long
device	long
;	O
}	O
;	O
struct	O
buffer_ctx	struct(*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
{	O
struct	O
buffer_ctx	struct(*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
grecs_locus_t	struct(struct(*(char),int,int),struct(*(char),int,int))
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
;	O
size_t	long
namelen	long
;	O
size_t	long
xlines	long
;	O
struct	O
input_file_ident	struct(long,long)
id	*(char)
;	O
FILE	struct
*	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
;	O
extern	O
int	O
grecs_grecs__flex_debug	int
;	O
static	O
struct	O
buffer_ctx	struct(*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
static	O
char	O
*	O
linebufbase	*(char)
=	O
NULL	O
;	O
static	O
size_t	long
linebufsize	long
=	O
0	int
;	O
static	O
char	O
*	O
linebuf	*(char)
;	O
static	O
size_t	long
bufsize	long
;	O
static	O
char	O
*	O
putback_buffer	*(char)
;	O
static	O
size_t	long
putback_size	long
;	O
static	O
size_t	long
putback_max	long
;	O
static	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
;	O
static	O
size_t	long
include_pos	long
;	O
static	O
int	O
include_once	int
;	O
static	O
int	O
push_source	(*(char),int)->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
once	int
)	O
;	O
static	O
int	O
pop_source	()->(int)
(	O
void	O
)	O
;	O
static	O
int	O
parse_include	(*(char),int)->(int)
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
once	int
)	O
;	O
ssize_t	long
grecs_getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
char	O
*	O
*	O
pbuf	*(*(char))
,	O
size_t	long
*	O
psize	*(long)
,	O
FILE	struct
*	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
)	O
{	O
char	O
*	O
buf	*(char)
=	O
*	O
pbuf	*(*(char))
;	O
size_t	long
size	*(long)
=	O
*	O
psize	*(long)
;	O
ssize_t	long
off	long
=	O
0	int
;	O
if	O
(	O
!	O
buf	*(char)
)	O
{	O
size	*(long)
=	O
1	int
;	O
buf	*(char)
=	O
grecs_malloc	(long)->(*(void))
(	O
size	*(long)
)	O
;	O
}	O
do	O
{	O
if	O
(	O
off	long
==	O
size	*(long)
-	O
1	int
)	O
{	O
size_t	long
nsize	long
=	O
2	int
*	O
size	*(long)
;	O
if	O
(	O
nsize	long
<	O
size	*(long)
)	O
grecs_alloc_die	()->(void)
(	O
)	O
;	O
buf	*(char)
=	O
grecs_realloc	(*(void),long)->(*(void))
(	O
buf	*(char)
,	O
nsize	long
)	O
;	O
size	*(long)
=	O
nsize	long
;	O
}	O
if	O
(	O
!	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
+	O
off	long
,	O
size	*(long)
-	O
off	long
,	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
)	O
)	O
{	O
if	O
(	O
off	long
==	O
0	int
)	O
off	long
=	O
-	O
1	int
;	O
break	O
;	O
}	O
off	long
+=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
+	O
off	long
)	O
;	O
}	O
while	O
(	O
buf	*(char)
[	O
off	long
-	O
1	int
]	O
!=	O
'\n'	O
)	O
;	O
*	O
pbuf	*(*(char))
=	O
buf	*(char)
;	O
*	O
psize	*(long)
=	O
size	*(long)
;	O
return	O
off	long
;	O
}	O
static	O
void	O
putback	(*(char))->(void)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
size_t	long
len	long
;	O
if	O
(	O
!	O
*	O
str	*(char)
)	O
return	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
len	long
>	O
putback_max	long
)	O
{	O
putback_max	long
=	O
len	long
;	O
putback_buffer	*(char)
=	O
grecs_realloc	(*(void),long)->(*(void))
(	O
putback_buffer	*(char)
,	O
putback_max	long
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
putback_buffer	*(char)
,	O
str	*(char)
)	O
;	O
putback_size	long
=	O
len	long
-	O
1	int
;	O
}	O
static	O
void	O
pp_line_stmt	()->(void)
(	O
)	O
{	O
size_t	long
ls_size	long
;	O
size_t	long
pb_size	long
;	O
if	O
(	O
grecs_asprintf	(*(*(char)),*(long),*(char))->(int)
(	O
&	O
linebufbase	*(char)
,	O
&	O
linebufsize	long
,	O
"#line %lu \"%s\" %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
POINT	O
.	O
line	int
,	O
POINT	O
.	O
file	*(char)
,	O
(	O
unsigned	O
long	O
)	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
xlines	long
)	O
)	O
grecs_alloc_die	()->(void)
(	O
)	O
;	O
ls_size	long
=	O
strlen	(*(char))->(long)
(	O
linebufbase	*(char)
)	O
;	O
pb_size	long
=	O
putback_size	long
+	O
ls_size	long
+	O
1	int
;	O
if	O
(	O
pb_size	long
>	O
putback_max	long
)	O
{	O
putback_max	long
=	O
pb_size	long
;	O
putback_buffer	*(char)
=	O
grecs_realloc	(*(void),long)->(*(void))
(	O
putback_buffer	*(char)
,	O
putback_max	long
)	O
;	O
}	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
xlines	long
++	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
putback_buffer	*(char)
+	O
putback_size	long
,	O
linebufbase	*(char)
)	O
;	O
putback_size	long
+=	O
ls_size	long
;	O
}	O
static	O
int	O
next_line	()->(int)
(	O
)	O
{	O
ssize_t	long
rc	int
;	O
do	O
{	O
if	O
(	O
putback_size	long
)	O
{	O
if	O
(	O
putback_size	long
+	O
1	int
>	O
bufsize	long
)	O
{	O
bufsize	long
=	O
putback_size	long
+	O
1	int
;	O
linebuf	*(char)
=	O
grecs_realloc	(*(void),long)->(*(void))
(	O
linebuf	*(char)
,	O
bufsize	long
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
linebuf	*(char)
,	O
putback_buffer	*(char)
)	O
;	O
rc	int
=	O
putback_size	long
;	O
putback_size	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
return	O
0	int
;	O
else	O
rc	int
=	O
grecs_getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
linebuf	*(char)
,	O
&	O
bufsize	long
,	O
INFILE	O
)	O
;	O
}	O
while	O
(	O
rc	int
==	O
-	O
1	int
&&	O
pop_source	()->(int)
(	O
)	O
==	O
0	int
)	O
;	O
return	O
rc	int
;	O
}	O
size_t	long
grecs_preproc_fill_buffer	(*(char),long)->(long)
(	O
char	O
*	O
buf	*(char)
,	O
size_t	long
size	*(long)
)	O
{	O
size_t	long
bufsize	long
=	O
size	*(long)
;	O
while	O
(	O
next_line	()->(int)
(	O
)	O
>	O
0	int
)	O
{	O
char	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
;	O
size_t	long
len	long
;	O
int	O
is_line	int
=	O
0	int
;	O
for	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
=	O
linebuf	*(char)
;	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
&&	O
isspace	(int)->(int)
(	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
++	O
)	O
;	O
if	O
(	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
==	O
'#'	O
)	O
{	O
size_t	long
l	long
;	O
for	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
++	O
;	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
&&	O
isspace	(int)->(int)
(	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
++	O
)	O
;	O
l	long
=	O
strlen	(*(char))->(long)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
;	O
if	O
(	O
STRMATCH	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
,	O
l	long
,	O
"include_once"	*(char)
)	O
)	O
{	O
if	O
(	O
parse_include	(*(char),int)->(int)
(	O
linebuf	*(char)
,	O
1	int
)	O
)	O
putback	(*(char))->(void)
(	O
"/*include_once*/\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
STRMATCH	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
,	O
l	long
,	O
"include"	*(char)
)	O
)	O
{	O
if	O
(	O
parse_include	(*(char),int)->(int)
(	O
linebuf	*(char)
,	O
0	int
)	O
)	O
putback	(*(char))->(void)
(	O
"/*include*/\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
STRMATCH	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
,	O
l	long
,	O
"line"	*(char)
)	O
)	O
is_line	int
=	O
1	int
;	O
}	O
len	long
=	O
strlen	(*(char))->(long)
(	O
linebuf	*(char)
)	O
;	O
if	O
(	O
len	long
>	O
size	*(long)
)	O
len	long
=	O
size	*(long)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
,	O
linebuf	*(char)
,	O
len	long
)	O
;	O
buf	*(char)
+=	O
len	long
;	O
size	*(long)
-=	O
len	long
;	O
if	O
(	O
size	*(long)
==	O
0	int
)	O
{	O
putback	(*(char))->(void)
(	O
linebuf	*(char)
+	O
len	long
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
is_line	int
&&	O
len	long
>	O
0	int
&&	O
linebuf	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
POINT	O
.	O
line	int
++	O
;	O
}	O
return	O
bufsize	long
-	O
size	*(long)
;	O
}	O
static	O
struct	O
buffer_ctx	struct(*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
ctx_lookup	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(*(struct(*`,struct`,long,long,struct`,*`)),struct(struct(*`,int,int),struct(*`,int,int)),long,long,struct(long,long),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct)
)	O
{	O
struct	O
buffer_ctx	struct(*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
if	O
(	O
!	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
return	O
NULL	O
;	O
for	O
(	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
=	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
=	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
if	O
(	O
STAT_ID_EQ	O
(	O
*	O
st	*(struct)
,	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
id	*(char)
)	O
)	O
break	O
;	O
return	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
}	O
const	O
char	O
*	O
grecs_preprocessor	*(char)
=	O
NULL	O
;	O
static	O
struct	O
grecs_list	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))
*	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
;	O
static	O
struct	O
grecs_list	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))
*	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
;	O
size_t	long
grecs_include_path_count	(int)->(long)
(	O
int	O
flag	int
)	O
{	O
size_t	long
count	long
=	O
0	int
;	O
if	O
(	O
flag	int
&	O
GRECS_STD_INCLUDE	int
)	O
count	long
+=	O
grecs_list_size	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))->(long)
(	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
;	O
if	O
(	O
flag	int
&	O
GRECS_USR_INCLUDE	int
)	O
count	long
+=	O
grecs_list_size	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))->(long)
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
;	O
return	O
count	long
;	O
}	O
static	O
int	O
foreach_dir	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),int,*((int,*(char),*(void))->(int)),*(void))->(int)
(	O
struct	O
grecs_list	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))
*	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
int	O
flag	int
,	O
int	O
(	O
*	O
fun	*((*(void),*(void))->(int))
)	O
(	O
int	O
,	O
const	O
char	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
grecs_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(void))
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
rc	int
==	O
0	int
&&	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
rc	int
=	O
fun	*((*(void),*(void))->(int))
(	O
flag	int
,	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
data	*(void)
,	O
data	*(void)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
grecs_foreach_include_dir	(int,*((int,*(char),*(void))->(int)),*(void))->(int)
(	O
int	O
flag	int
,	O
int	O
(	O
*	O
fun	*((*(void),*(void))->(int))
)	O
(	O
int	O
,	O
const	O
char	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
flag	int
&	O
GRECS_STD_INCLUDE	int
)	O
rc	int
=	O
foreach_dir	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),int,*((int,*(char),*(void))->(int)),*(void))->(int)
(	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
GRECS_STD_INCLUDE	int
,	O
fun	*((*(void),*(void))->(int))
,	O
data	*(void)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
(	O
flag	int
&	O
GRECS_USR_INCLUDE	int
)	O
)	O
rc	int
=	O
foreach_dir	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),int,*((int,*(char),*(void))->(int)),*(void))->(int)
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
GRECS_USR_INCLUDE	int
,	O
fun	*((*(void),*(void))->(int))
,	O
data	*(void)
)	O
;	O
return	O
rc	int
;	O
}	O
struct	O
file_data	struct(*(char),long,*(char),long,int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
size_t	long
namelen	long
;	O
char	O
*	O
buf	*(char)
;	O
size_t	long
buflen	long
;	O
int	O
found	int
;	O
}	O
;	O
static	O
int	O
pp_list_find	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(struct(*(char),long,*(char),long,int)))->(int)
(	O
struct	O
grecs_list	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void)))
*	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
struct	O
file_data	struct(*(char),long,*(char),long,int)
*	O
dptr	*(struct(*(char),long,*(char),long,int))
)	O
{	O
struct	O
grecs_list_entry	struct(*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void))),*(void))
*	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
if	O
(	O
!	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
return	O
0	int
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
list	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
head	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
!	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
found	int
&&	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
{	O
const	O
char	O
*	O
dir	*(char)
=	O
ep	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
data	*(void)
;	O
size_t	long
size	*(long)
=	O
strlen	(*(char))->(long)
(	O
dir	*(char)
)	O
+	O
1	int
+	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
namelen	long
+	O
1	int
;	O
if	O
(	O
size	*(long)
>	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buflen	long
)	O
{	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buflen	long
=	O
size	*(long)
;	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buf	*(char)
=	O
grecs_realloc	(*(void),long)->(*(void))
(	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buf	*(char)
,	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buflen	long
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buf	*(char)
,	O
dir	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buf	*(char)
,	O
"/"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buf	*(char)
,	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
name	*(char)
)	O
;	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
found	int
=	O
access	(*(char),int)->(int)
(	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
buf	*(char)
,	O
F_OK	int
)	O
==	O
0	int
;	O
}	O
return	O
dptr	*(struct(*(char),long,*(char),long,int))
->	O
found	int
;	O
}	O
static	O
void	O
incl_free	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
grecs_free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
}	O
void	O
grecs_include_path_clear	()->(void)
(	O
)	O
{	O
if	O
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
grecs_list_clear	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
;	O
if	O
(	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
grecs_list_clear	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
;	O
}	O
void	O
grecs_include_path_setup_v	(*(*(char)))->(void)
(	O
char	O
*	O
*	O
dirs	*(*(char))
)	O
{	O
if	O
(	O
!	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
{	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
=	O
grecs_list_create	()->(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
(	O
)	O
;	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
free_entry	*((*(void))->(void))
=	O
incl_free	(*(void))->(void)
;	O
}	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
=	O
grecs_list_create	()->(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
(	O
)	O
;	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
free_entry	*((*(void))->(void))
=	O
incl_free	(*(void))->(void)
;	O
if	O
(	O
dirs	*(*(char))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
dirs	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
grecs_list_append	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(void))->(void)
(	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
grecs_strdup	(*(char))->(*(char))
(	O
dirs	*(*(char))
[	O
i	int
]	O
)	O
)	O
;	O
}	O
}	O
void	O
grecs_include_path_setup	(*(char))->(void)
(	O
const	O
char	O
*	O
dir	*(char)
,	O
...	O
)	O
{	O
const	O
char	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
;	O
char	O
*	O
*	O
argv	*(*(char))
=	O
NULL	O
;	O
size_t	long
argc	int
=	O
0	int
;	O
size_t	long
argi	long
=	O
0	int
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
dir	*(char)
)	O
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
=	O
dir	*(char)
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
argi	long
==	O
argc	int
)	O
{	O
if	O
(	O
argc	int
==	O
0	int
)	O
argc	int
=	O
16	int
;	O
else	O
argc	int
+=	O
16	int
;	O
argv	*(*(char))
=	O
grecs_realloc	(*(void),long)->(*(void))
(	O
argv	*(*(char))
,	O
argc	int
*	O
sizeof	O
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
}	O
argv	*(*(char))
[	O
argi	long
++	O
]	O
=	O
(	O
char	O
*	O
)	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
;	O
if	O
(	O
!	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
break	O
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
=	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
const	O
char	O
*	O
)	O
;	O
}	O
grecs_include_path_setup_v	(*(*(char)))->(void)
(	O
argv	*(*(char))
)	O
;	O
grecs_free	(*(void))->(void)
(	O
argv	*(*(char))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
grecs_preproc_add_include_dir	(*(char))->(void)
(	O
char	O
*	O
dir	*(char)
)	O
{	O
if	O
(	O
!	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
{	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
=	O
grecs_list_create	()->(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))
(	O
)	O
;	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
->	O
free_entry	*((*(void))->(void))
=	O
incl_free	(*(void))->(void)
;	O
}	O
grecs_list_append	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(void))->(void)
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
grecs_strdup	(*(char))->(*(char))
(	O
dir	*(char)
)	O
)	O
;	O
}	O
static	O
struct	O
grecs_symtab	O
*	O
incl_sources	*(struct)
;	O
static	O
unsigned	O
incl_hasher	(*(void),long)->(int)
(	O
void	O
*	O
data	*(void)
,	O
unsigned	O
long	O
n_buckets	long
)	O
{	O
const	O
struct	O
input_file_ident	struct(long,long)
*	O
id	*(char)
=	O
data	*(void)
;	O
return	O
(	O
id	*(char)
->	O
i_node	long
+	O
id	*(char)
->	O
device	long
)	O
%	O
n_buckets	long
;	O
}	O
static	O
int	O
incl_compare	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
data1	*(void)
,	O
void	O
const	O
*	O
data2	*(void)
)	O
{	O
const	O
struct	O
input_file_ident	struct(long,long)
*	O
id1	*(struct(long,long))
=	O
data1	*(void)
;	O
const	O
struct	O
input_file_ident	struct(long,long)
*	O
id2	*(struct(long,long))
=	O
data2	*(void)
;	O
return	O
!	O
(	O
id1	*(struct(long,long))
->	O
device	long
==	O
id2	*(struct(long,long))
->	O
device	long
&&	O
id1	*(struct(long,long))
->	O
i_node	long
==	O
id2	*(struct(long,long))
->	O
i_node	long
)	O
;	O
}	O
static	O
int	O
incl_copy	(*(void),*(void))->(int)
(	O
void	O
*	O
dst	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
void	O
*	O
src	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dst	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
src	*(struct(enum(int,int,int),struct(struct(*(char),int,int),struct(*(char),int,int)),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(struct(enum(int,int,int),struct(struct`,struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),struct(struct`,struct`),union(*`,*`))),*(char),struct(struct(*(char),int,int),struct(*(char),int,int)),union(*(struct(int,struct`,union`)),*(struct))))
,	O
sizeof	O
(	O
struct	O
input_file_ident	struct(long,long)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
source_lookup	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct)
)	O
{	O
struct	O
input_file_ident	struct(long,long)
key	*(void)
;	O
int	O
install	*(int)
=	O
1	int
;	O
if	O
(	O
!	O
incl_sources	*(struct)
)	O
{	O
incl_sources	*(struct)
=	O
grecs_symtab_create	(long,*((*(void),long)->(int)),*((*(void),*(void))->(int)),*((*(void),*(void))->(int)),*((long)->(*(void))),*((*(void))->(void)))->(*(struct))
(	O
sizeof	O
(	O
struct	O
input_file_ident	struct(long,long)
)	O
,	O
incl_hasher	(*(void),long)->(int)
,	O
incl_compare	(*(void),*(void))->(int)
,	O
incl_copy	(*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
incl_sources	*(struct)
)	O
grecs_alloc_die	()->(void)
(	O
)	O
;	O
}	O
key	*(void)
.	O
i_node	long
=	O
st	*(struct)
->	O
st_ino	long
;	O
key	*(void)
.	O
device	long
=	O
st	*(struct)
->	O
st_dev	long
;	O
if	O
(	O
!	O
grecs_symtab_lookup_or_install	(*(struct),*(void),*(int))->(*(void))
(	O
incl_sources	*(struct)
,	O
&	O
key	*(void)
,	O
&	O
install	*(int)
)	O
)	O
grecs_alloc_die	()->(void)
(	O
)	O
;	O
return	O
!	O
install	*(int)
;	O
}	O
static	O
int	O
push_source	(*(char),int)->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
once	int
)	O
{	O
FILE	struct
*	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
;	O
struct	O
buffer_ctx	struct(*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct)
;	O
int	O
rc	int
=	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	*(char)
,	O
&	O
st	*(struct)
)	O
;	O
if	O
(	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
{	O
if	O
(	O
rc	int
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
LOCUS	O
,	O
errno	O
,	O
_	O
(	O
"Cannot stat `%s'"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
POINT	O
.	O
file	*(char)
&&	O
STAT_ID_EQ	O
(	O
st	*(struct)
,	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
id	*(char)
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
LOCUS	O
,	O
0	int
,	O
_	O
(	O
"Recursive inclusion"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
=	O
ctx_lookup	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(*(struct(*`,struct`,long,long,struct`,*`)),struct(struct(*`,int,int),struct(*`,int,int)),long,long,struct(long,long),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))
(	O
&	O
st	*(struct)
)	O
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
LOCUS	O
,	O
0	int
,	O
_	O
(	O
"Recursive inclusion"	*(char)
)	O
)	O
;	O
if	O
(	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
)	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
,	O
0	int
,	O
_	O
(	O
"`%s' already included here"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
else	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
LOCUS	O
,	O
0	int
,	O
_	O
(	O
"`%s' already included at top level"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
rc	int
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
errno	O
,	O
_	O
(	O
"Cannot stat `%s'"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
once	int
&&	O
source_lookup	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
&	O
st	*(struct)
)	O
)	O
return	O
-	O
1	int
;	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
?	O
&	O
LOCUS	O
:	O
NULL	O
,	O
errno	O
,	O
_	O
(	O
"Cannot open `%s'"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
=	O
grecs_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
)	O
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
file	*(char)
=	O
grecs_install_text	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
line	int
=	O
1	int
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
col	int
=	O
0	int
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
.	O
file	*(char)
=	O
NULL	O
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
.	O
line	int
=	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
end	struct(*(char),int,int)
.	O
col	int
=	O
0	int
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
xlines	long
=	O
0	int
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
namelen	long
=	O
strlen	(*(char))->(long)
(	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
locus	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
.	O
file	*(char)
)	O
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
id	*(char)
.	O
i_node	long
=	O
st	*(struct)
.	O
st_ino	long
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
id	*(char)
.	O
device	long
=	O
st	*(struct)
.	O
st_dev	long
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
infile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
=	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
=	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
if	O
(	O
grecs_grecs__flex_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Processing file `%s'\n"	*(char)
,	O
name	*(char)
)	O
;	O
pp_line_stmt	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
pop_source	()->(int)
(	O
)	O
{	O
struct	O
buffer_ctx	struct(*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
if	O
(	O
!	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
return	O
1	int
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
INFILE	O
)	O
;	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
=	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
prev	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),*(void)))
;	O
grecs_free	(*(void))->(void)
(	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
;	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
=	O
ctx	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
;	O
if	O
(	O
include_pos	long
<	O
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
.	O
gl_pathc	long
)	O
{	O
push_source	(*(char),int)->(int)
(	O
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
.	O
gl_pathv	*(*(char))
[	O
include_pos	long
++	O
]	O
,	O
include_once	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
.	O
gl_pathc	long
)	O
{	O
globfree	(*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(void)
(	O
&	O
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
)	O
;	O
include_pos	long
=	O
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
.	O
gl_pathc	long
=	O
0	int
;	O
}	O
if	O
(	O
!	O
context_stack	*(struct(*(struct(*(struct`),struct(struct`,struct`),long,long,struct(long,long),*(struct`))),struct(struct(*(char),int,int),struct(*(char),int,int)),long,long,struct(long,long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
{	O
if	O
(	O
grecs_grecs__flex_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"End of input\n"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
POINT	O
.	O
line	int
++	O
;	O
if	O
(	O
grecs_grecs__flex_debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Resuming file `%s' at line %lu\n"	*(char)
,	O
POINT	O
.	O
file	*(char)
,	O
(	O
unsigned	O
long	O
)	O
POINT	O
.	O
line	int
)	O
;	O
pp_line_stmt	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
grecs_find_include_file	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
allow_cwd	int
)	O
{	O
static	O
char	O
*	O
cwd	short
=	O
"."	*(char)
;	O
struct	O
file_data	struct(*(char),long,*(char),long,int)
fd	struct(*(char),long,*(char),long,int)
;	O
fd	struct(*(char),long,*(char),long,int)
.	O
name	*(char)
=	O
name	*(char)
;	O
fd	struct(*(char),long,*(char),long,int)
.	O
namelen	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
fd	struct(*(char),long,*(char),long,int)
.	O
buf	*(char)
=	O
NULL	O
;	O
fd	struct(*(char),long,*(char),long,int)
.	O
buflen	long
=	O
0	int
;	O
fd	struct(*(char),long,*(char),long,int)
.	O
found	int
=	O
0	int
;	O
if	O
(	O
!	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
grecs_include_path_setup	(*(char))->(void)
(	O
NULL	O
)	O
;	O
if	O
(	O
allow_cwd	int
)	O
{	O
grecs_list_append	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(void))->(void)
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
cwd	short
)	O
;	O
pp_list_find	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(struct(*(char),long,*(char),long,int)))->(int)
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
&	O
fd	struct(*(char),long,*(char),long,int)
)	O
;	O
grecs_list_remove_tail	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))))->(*(void))
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
)	O
;	O
}	O
else	O
pp_list_find	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(struct(*(char),long,*(char),long,int)))->(int)
(	O
grecs_usr_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
&	O
fd	struct(*(char),long,*(char),long,int)
)	O
;	O
if	O
(	O
!	O
fd	struct(*(char),long,*(char),long,int)
.	O
found	int
)	O
{	O
pp_list_find	(*(struct(*(struct(*`,*`,*`)),*(struct(*`,*`,*`)),long,*((*`,*`)->(int)),*((*`)->(void)))),*(struct(*(char),long,*(char),long,int)))->(int)
(	O
grecs_std_include_path	*(struct(*(struct(*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(void))),long,*((*(void),*(void))->(int)),*((*(void))->(void))))
,	O
&	O
fd	struct(*(char),long,*(char),long,int)
)	O
;	O
if	O
(	O
!	O
fd	struct(*(char),long,*(char),long,int)
.	O
found	int
)	O
return	O
NULL	O
;	O
}	O
return	O
fd	struct(*(char),long,*(char),long,int)
.	O
buf	*(char)
;	O
}	O
static	O
int	O
isglob	(*(char))->(int)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
s	*(char)
;	O
s	*(char)
++	O
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"*?["	*(char)
,	O
*	O
s	*(char)
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_include	(*(char),int)->(int)
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
once	int
)	O
{	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
;	O
char	O
*	O
tmp	*(char)
=	O
NULL	O
;	O
char	O
*	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
=	O
NULL	O
;	O
int	O
rc	int
=	O
1	int
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
(	O
text	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
WRDSF_DEFFLAGS	O
)	O
)	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
LOCUS	O
,	O
0	int
,	O
_	O
(	O
"Cannot parse include line"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
.	O
ws_wordc	long
!=	O
2	int
)	O
{	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
;	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
LOCUS	O
,	O
0	int
,	O
_	O
(	O
"invalid include statement"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
size_t	long
len	long
;	O
int	O
allow_cwd	int
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
.	O
ws_wordv	*(*(char))
[	O
1	int
]	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
;	O
if	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
0	int
]	O
==	O
'<'	O
&&	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
len	long
-	O
1	int
]	O
==	O
'>'	O
)	O
{	O
allow_cwd	int
=	O
0	int
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
++	O
;	O
}	O
else	O
allow_cwd	int
=	O
1	int
;	O
if	O
(	O
isglob	(*(char))->(int)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
)	O
{	O
switch	O
(	O
glob	(*(char),int,*((*(char),int)->(int)),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
,	O
0	int
,	O
NULL	O
,	O
&	O
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
)	O
)	O
{	O
case	O
0	int
:	O
include_pos	long
=	O
0	int
;	O
include_once	int
=	O
once	int
;	O
break	O
;	O
case	O
GLOB_NOSPACE	int
:	O
grecs_alloc_die	()->(void)
(	O
)	O
;	O
case	O
GLOB_NOMATCH	int
:	O
break	O
;	O
default	O
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
LOCUS	O
,	O
0	int
,	O
_	O
(	O
"read error"	*(char)
)	O
)	O
;	O
}	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
char	O
*	O
q	*(char)
=	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
;	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
=	O
grecs_find_include_file	(*(char),int)->(*(char))
(	O
q	*(char)
,	O
allow_cwd	int
)	O
;	O
if	O
(	O
!	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
&	O
LOCUS	O
,	O
0	int
,	O
_	O
(	O
"%s: No such file or directory"	*(char)
)	O
,	O
q	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
rc	int
=	O
push_source	(*(char),int)->(int)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
,	O
once	int
)	O
;	O
else	O
if	O
(	O
include_pos	long
<	O
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
.	O
gl_pathc	long
)	O
rc	int
=	O
push_source	(*(char),int)->(int)
(	O
include_glob	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(void))),*((*(char))->(*(void))),*((*(char),*(void))->(int)),*((*(char),*(void))->(int)))
.	O
gl_pathv	*(*(char))
[	O
include_pos	long
++	O
]	O
,	O
once	int
)	O
;	O
grecs_free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
grecs_preproc_init	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
push_source	(*(char),int)->(int)
(	O
name	*(char)
,	O
0	int
)	O
;	O
}	O
void	O
grecs_preproc_done	()->(void)
(	O
)	O
{	O
grecs_symtab_free	(*(struct))->(void)
(	O
incl_sources	*(struct)
)	O
;	O
incl_sources	*(struct)
=	O
NULL	O
;	O
grecs_free	(*(void))->(void)
(	O
linebuf	*(char)
)	O
;	O
linebuf	*(char)
=	O
NULL	O
;	O
bufsize	long
=	O
0	int
;	O
grecs_free	(*(void))->(void)
(	O
putback_buffer	*(char)
)	O
;	O
putback_buffer	*(char)
=	O
NULL	O
;	O
putback_size	long
=	O
putback_max	long
=	O
0	int
;	O
free	(*(void))->(void)
(	O
linebufbase	*(char)
)	O
;	O
linebufbase	*(char)
=	O
NULL	O
;	O
linebufsize	long
=	O
0	int
;	O
}	O
int	O
grecs_preproc_run	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
config_file	*(char)
,	O
const	O
char	O
*	O
extpp	*(char)
)	O
{	O
size_t	long
i	int
;	O
char	O
buffer	*(char)
[	O
512	int
]	O
;	O
if	O
(	O
grecs_preproc_init	(*(char))->(int)
(	O
config_file	*(char)
)	O
)	O
return	O
1	int
;	O
if	O
(	O
extpp	*(char)
)	O
{	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
setup_file	*(char)
;	O
char	O
*	O
cmd	enum(int,int,int)
=	O
NULL	O
;	O
setup_file	*(char)
=	O
grecs_find_include_file	(*(char),int)->(*(char))
(	O
"pp-setup"	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
setup_file	*(char)
)	O
{	O
size_t	long
size	*(long)
=	O
0	int
;	O
if	O
(	O
grecs_asprintf	(*(*(char)),*(long),*(char))->(int)
(	O
&	O
cmd	enum(int,int,int)
,	O
&	O
size	*(long)
,	O
"%s %s -"	*(char)
,	O
extpp	*(char)
,	O
setup_file	*(char)
)	O
)	O
grecs_alloc_die	()->(void)
(	O
)	O
;	O
grecs_free	(*(void))->(void)
(	O
setup_file	*(char)
)	O
;	O
}	O
else	O
cmd	enum(int,int,int)
=	O
grecs_strdup	(*(char))->(*(char))
(	O
extpp	*(char)
)	O
;	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
cmd	enum(int,int,int)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
errno	O
,	O
_	O
(	O
"Unable to start external preprocessor `%s'"	*(char)
)	O
,	O
cmd	enum(int,int,int)
)	O
;	O
grecs_free	(*(void))->(void)
(	O
cmd	enum(int,int,int)
)	O
;	O
return	O
1	int
;	O
}	O
while	O
(	O
(	O
i	int
=	O
grecs_preproc_fill_buffer	(*(char),long)->(long)
(	O
buffer	*(char)
,	O
sizeof	O
buffer	*(char)
)	O
)	O
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buffer	*(char)
,	O
1	int
,	O
i	int
,	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
grecs_free	(*(void))->(void)
(	O
cmd	enum(int,int,int)
)	O
;	O
}	O
else	O
{	O
while	O
(	O
(	O
i	int
=	O
grecs_preproc_fill_buffer	(*(char),long)->(long)
(	O
buffer	*(char)
,	O
sizeof	O
buffer	*(char)
)	O
)	O
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buffer	*(char)
,	O
1	int
,	O
i	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
grecs_preproc_done	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
FILE	struct
*	O
grecs_preproc_extrn_start	(*(char),*(int))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
file_name	*(char)
,	O
pid_t	int
*	O
ppid	*(int)
)	O
{	O
int	O
pout	array(int)
[	O
2	int
]	O
;	O
pid_t	int
pid	int
;	O
int	O
i	int
;	O
FILE	struct
*	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
=	O
NULL	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
pout	array(int)
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
errno	O
,	O
"pipe"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
switch	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
pout	array(int)
[	O
1	int
]	O
!=	O
1	int
)	O
{	O
if	O
(	O
dup2	(int,int)->(int)
(	O
pout	array(int)
[	O
1	int
]	O
,	O
1	int
)	O
==	O
-	O
1	int
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
errno	O
,	O
"dup2"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
getdtablesize	()->(int)
(	O
)	O
;	O
i	int
>	O
2	int
;	O
i	int
--	O
)	O
close	(int)->(int)
(	O
i	int
)	O
;	O
if	O
(	O
!	O
grecs_log_to_stderr	int
)	O
{	O
int	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
2	int
]	O
;	O
char	O
*	O
buf	*(char)
=	O
NULL	O
;	O
size_t	long
size	*(long)
=	O
0	int
;	O
FILE	struct
*	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
)	O
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
errno	O
,	O
"pipe"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
switch	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
1	int
]	O
!=	O
2	int
&&	O
dup2	(int,int)->(int)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
1	int
]	O
,	O
2	int
)	O
==	O
-	O
1	int
)	O
{	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
errno	O
,	O
"dup2"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
close	(int)->(int)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
grecs_preproc_run	(*(char),*(char))->(int)
(	O
file_name	*(char)
,	O
grecs_preprocessor	*(char)
)	O
)	O
exit	(int)->(void)
(	O
127	int
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
case	O
-	O
1	int
:	O
if	O
(	O
grecs_log_setup_hook	*(()->(void))
)	O
grecs_log_setup_hook	*(()->(void))
(	O
)	O
;	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
errno	O
,	O
_	O
(	O
"Cannot run `%s'"	*(char)
)	O
,	O
grecs_preprocessor	*(char)
)	O
;	O
exit	(int)->(void)
(	O
127	int
)	O
;	O
default	O
:	O
close	(int)->(int)
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
1	int
]	O
)	O
;	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(struct(*(struct(*(struct`),*(char),int,*(struct`))),*(char),int,*(struct)))
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
grecs_log_setup_hook	*(()->(void))
)	O
grecs_log_setup_hook	*(()->(void))
(	O
)	O
;	O
while	O
(	O
grecs_getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
buf	*(char)
,	O
&	O
size	*(long)
,	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
)	O
>	O
0	int
)	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
0	int
,	O
"%s"	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
grecs_preproc_run	(*(char),*(char))->(int)
(	O
file_name	*(char)
,	O
grecs_preprocessor	*(char)
)	O
;	O
}	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
case	O
-	O
1	int
:	O
grecs_error	(*(struct(struct(*(char),int,int),struct(*(char),int,int))),int,*(char))->(void)
(	O
NULL	O
,	O
errno	O
,	O
_	O
(	O
"Cannot run `%s'"	*(char)
)	O
,	O
grecs_preprocessor	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
close	(int)->(int)
(	O
pout	array(int)
[	O
1	int
]	O
)	O
;	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pout	array(int)
[	O
0	int
]	O
,	O
"r"	*(char)
)	O
;	O
break	O
;	O
}	O
*	O
ppid	*(int)
=	O
pid	int
;	O
return	O
fp	*(struct(*((*(char),*(void))->(int)),*(void)))
;	O
}	O
void	O
grecs_preproc_extrn_shutdown	(int)->(void)
(	O
pid_t	int
pid	int
)	O
{	O
int	O
status	int
;	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
}	O
