const	O
char	O
*	O
ctf_strraw_explicit	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
name	*(char)
,	O
ctf_strs_t	O
*	O
strtab	O
)	O
{	O
ctf_strs_t	O
*	O
ctsp	O
=	O
&	O
fp	*(struct)
->	O
ctf_str	O
[	O
CTF_NAME_STID	O
(	O
name	*(char)
)	O
]	O
;	O
if	O
(	O
(	O
CTF_NAME_STID	O
(	O
name	*(char)
)	O
==	O
CTF_STRTAB_0	O
)	O
&&	O
(	O
strtab	O
!=	O
NULL	O
)	O
)	O
ctsp	O
=	O
strtab	O
;	O
if	O
(	O
CTF_NAME_STID	O
(	O
name	*(char)
)	O
==	O
CTF_STRTAB_1	O
&&	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
!=	O
NULL	O
)	O
return	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
name	*(char)
)	O
;	O
if	O
(	O
CTF_NAME_STID	O
(	O
name	*(char)
)	O
==	O
CTF_STRTAB_0	O
&&	O
name	*(char)
>=	O
ctsp	O
->	O
cts_len	O
&&	O
name	*(char)
<	O
fp	*(struct)
->	O
ctf_str_prov_offset	O
)	O
return	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_prov_strtab	O
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
name	*(char)
)	O
;	O
if	O
(	O
ctsp	O
->	O
cts_strs	O
!=	O
NULL	O
&&	O
CTF_NAME_OFFSET	O
(	O
name	*(char)
)	O
<	O
ctsp	O
->	O
cts_len	O
)	O
return	O
(	O
ctsp	O
->	O
cts_strs	O
+	O
CTF_NAME_OFFSET	O
(	O
name	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
ctf_strraw	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
name	*(char)
)	O
{	O
return	O
ctf_strraw_explicit	O
(	O
fp	*(struct)
,	O
name	*(char)
,	O
NULL	O
)	O
;	O
}	O
const	O
char	O
*	O
ctf_strptr	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
uint32_t	int
name	*(char)
)	O
{	O
const	O
char	O
*	O
s	*(char)
=	O
ctf_strraw	O
(	O
fp	*(struct)
,	O
name	*(char)
)	O
;	O
return	O
(	O
s	*(char)
!=	O
NULL	O
?	O
s	*(char)
:	O
"(?)"	*(char)
)	O
;	O
}	O
static	O
void	O
ctf_str_purge_atom_refs	O
(	O
ctf_str_atom_t	O
*	O
atom	O
)	O
{	O
ctf_str_atom_ref_t	O
*	O
ref	O
,	O
*	O
next	*(char)
;	O
for	O
(	O
ref	O
=	O
ctf_list_next	O
(	O
&	O
atom	O
->	O
csa_refs	O
)	O
;	O
ref	O
!=	O
NULL	O
;	O
ref	O
=	O
next	*(char)
)	O
{	O
next	*(char)
=	O
ctf_list_next	O
(	O
ref	O
)	O
;	O
ctf_list_delete	O
(	O
&	O
atom	O
->	O
csa_refs	O
,	O
ref	O
)	O
;	O
free	(*(void))->(void)
(	O
ref	O
)	O
;	O
}	O
}	O
static	O
void	O
ctf_str_free_atom	O
(	O
void	O
*	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
ctf_str_atom_t	O
*	O
atom	O
=	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
ctf_str_purge_atom_refs	O
(	O
atom	O
)	O
;	O
free	(*(void))->(void)
(	O
atom	O
)	O
;	O
}	O
int	O
ctf_str_create_atoms	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
fp	*(struct)
->	O
ctf_str_atoms	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_string	O
,	O
ctf_hash_eq_string	O
,	O
free	(*(void))->(void)
,	O
ctf_str_free_atom	O
)	O
;	O
if	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
==	O
NULL	O
)	O
return	O
-	O
ENOMEM	O
;	O
if	O
(	O
!	O
fp	*(struct)
->	O
ctf_prov_strtab	O
)	O
fp	*(struct)
->	O
ctf_prov_strtab	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_integer	O
,	O
ctf_hash_eq_integer	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
fp	*(struct)
->	O
ctf_prov_strtab	O
)	O
goto	O
oom_prov_strtab	O
;	O
errno	O
=	O
0	int
;	O
ctf_str_add	O
(	O
fp	*(struct)
,	O
""	*(char)
)	O
;	O
if	O
(	O
errno	O
==	O
ENOMEM	O
)	O
goto	O
oom_str_add	O
;	O
return	O
0	int
;	O
oom_str_add	O
:	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_prov_strtab	O
)	O
;	O
fp	*(struct)
->	O
ctf_prov_strtab	O
=	O
NULL	O
;	O
oom_prov_strtab	O
:	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
)	O
;	O
fp	*(struct)
->	O
ctf_str_atoms	O
=	O
NULL	O
;	O
return	O
-	O
ENOMEM	O
;	O
}	O
void	O
ctf_str_free_atoms	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_prov_strtab	O
)	O
;	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
)	O
;	O
}	O
static	O
ctf_str_atom_t	O
*	O
ctf_str_add_ref_internal	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
str	O
,	O
int	O
add_ref	O
,	O
int	O
make_provisional	O
,	O
uint32_t	int
*	O
ref	O
)	O
{	O
char	O
*	O
newstr	O
=	O
NULL	O
;	O
ctf_str_atom_t	O
*	O
atom	O
=	O
NULL	O
;	O
ctf_str_atom_ref_t	O
*	O
aref	O
=	O
NULL	O
;	O
atom	O
=	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
str	O
)	O
;	O
if	O
(	O
add_ref	O
)	O
{	O
if	O
(	O
(	O
aref	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
ctf_str_atom_ref	O
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
aref	O
->	O
caf_ref	O
=	O
ref	O
;	O
}	O
if	O
(	O
atom	O
)	O
{	O
if	O
(	O
add_ref	O
)	O
{	O
ctf_list_append	O
(	O
&	O
atom	O
->	O
csa_refs	O
,	O
aref	O
)	O
;	O
fp	*(struct)
->	O
ctf_str_num_refs	O
++	O
;	O
}	O
return	O
atom	O
;	O
}	O
if	O
(	O
(	O
atom	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
ctf_str_atom	O
)	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
oom	O
;	O
memset	O
(	O
atom	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
ctf_str_atom	O
)	O
)	O
;	O
if	O
(	O
(	O
newstr	O
=	O
strdup	O
(	O
str	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
oom	O
;	O
if	O
(	O
ctf_dynhash_insert	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
newstr	O
,	O
atom	O
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
atom	O
->	O
csa_str	O
=	O
newstr	O
;	O
atom	O
->	O
csa_snapshot_id	O
=	O
fp	*(struct)
->	O
ctf_snapshots	O
;	O
if	O
(	O
make_provisional	O
)	O
{	O
atom	O
->	O
csa_offset	O
=	O
fp	*(struct)
->	O
ctf_str_prov_offset	O
;	O
if	O
(	O
ctf_dynhash_insert	O
(	O
fp	*(struct)
->	O
ctf_prov_strtab	O
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
atom	O
->	O
csa_offset	O
,	O
(	O
void	O
*	O
)	O
atom	O
->	O
csa_str	O
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
fp	*(struct)
->	O
ctf_str_prov_offset	O
+=	O
strlen	O
(	O
atom	O
->	O
csa_str	O
)	O
+	O
1	int
;	O
}	O
if	O
(	O
add_ref	O
)	O
{	O
ctf_list_append	O
(	O
&	O
atom	O
->	O
csa_refs	O
,	O
aref	O
)	O
;	O
fp	*(struct)
->	O
ctf_str_num_refs	O
++	O
;	O
}	O
return	O
atom	O
;	O
oom	O
:	O
if	O
(	O
newstr	O
)	O
ctf_dynhash_remove	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
newstr	O
)	O
;	O
free	(*(void))->(void)
(	O
atom	O
)	O
;	O
free	(*(void))->(void)
(	O
aref	O
)	O
;	O
free	(*(void))->(void)
(	O
newstr	O
)	O
;	O
return	O
NULL	O
;	O
}	O
uint32_t	int
ctf_str_add	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
str	O
)	O
{	O
ctf_str_atom_t	O
*	O
atom	O
;	O
if	O
(	O
!	O
str	O
)	O
return	O
0	int
;	O
atom	O
=	O
ctf_str_add_ref_internal	O
(	O
fp	*(struct)
,	O
str	O
,	O
FALSE	O
,	O
TRUE	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
atom	O
)	O
return	O
0	int
;	O
return	O
atom	O
->	O
csa_offset	O
;	O
}	O
uint32_t	int
ctf_str_add_ref	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
str	O
,	O
uint32_t	int
*	O
ref	O
)	O
{	O
ctf_str_atom_t	O
*	O
atom	O
;	O
if	O
(	O
!	O
str	O
)	O
return	O
0	int
;	O
atom	O
=	O
ctf_str_add_ref_internal	O
(	O
fp	*(struct)
,	O
str	O
,	O
TRUE	int
,	O
TRUE	int
,	O
ref	O
)	O
;	O
if	O
(	O
!	O
atom	O
)	O
return	O
0	int
;	O
return	O
atom	O
->	O
csa_offset	O
;	O
}	O
int	O
ctf_str_add_external	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
str	O
,	O
uint32_t	int
offset	long
)	O
{	O
ctf_str_atom_t	O
*	O
atom	O
;	O
if	O
(	O
!	O
str	O
)	O
return	O
0	int
;	O
atom	O
=	O
ctf_str_add_ref_internal	O
(	O
fp	*(struct)
,	O
str	O
,	O
FALSE	O
,	O
FALSE	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
atom	O
)	O
return	O
0	int
;	O
atom	O
->	O
csa_external_offset	O
=	O
CTF_SET_STID	O
(	O
offset	long
,	O
CTF_STRTAB_1	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
ctf_str_remove_ref	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
const	O
char	O
*	O
str	O
,	O
uint32_t	int
*	O
ref	O
)	O
{	O
ctf_str_atom_ref_t	O
*	O
aref	O
,	O
*	O
anext	O
;	O
ctf_str_atom_t	O
*	O
atom	O
=	O
NULL	O
;	O
atom	O
=	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
str	O
)	O
;	O
if	O
(	O
!	O
atom	O
)	O
return	O
;	O
for	O
(	O
aref	O
=	O
ctf_list_next	O
(	O
&	O
atom	O
->	O
csa_refs	O
)	O
;	O
aref	O
!=	O
NULL	O
;	O
aref	O
=	O
anext	O
)	O
{	O
anext	O
=	O
ctf_list_next	O
(	O
aref	O
)	O
;	O
if	O
(	O
aref	O
->	O
caf_ref	O
==	O
ref	O
)	O
{	O
ctf_list_delete	O
(	O
&	O
atom	O
->	O
csa_refs	O
,	O
aref	O
)	O
;	O
free	(*(void))->(void)
(	O
aref	O
)	O
;	O
}	O
}	O
}	O
static	O
int	O
ctf_str_rollback_atom	O
(	O
void	O
*	O
key	O
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg	*(void)
)	O
{	O
ctf_str_atom_t	O
*	O
atom	O
=	O
(	O
ctf_str_atom_t	O
*	O
)	O
value	int
;	O
ctf_snapshot_id_t	struct(long,long)
*	O
id	int
=	O
(	O
ctf_snapshot_id_t	struct(long,long)
*	O
)	O
arg	*(void)
;	O
return	O
(	O
atom	O
->	O
csa_snapshot_id	O
>	O
id	int
->	O
snapshot_id	long
)	O
;	O
}	O
void	O
ctf_str_rollback	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
,	O
ctf_snapshot_id_t	struct(long,long)
id	int
)	O
{	O
ctf_dynhash_iter_remove	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
ctf_str_rollback_atom	O
,	O
&	O
id	int
)	O
;	O
}	O
static	O
void	O
ctf_str_purge_one_atom_refs	O
(	O
void	O
*	O
key	O
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg	*(void)
_libctf_unused_	O
)	O
{	O
ctf_str_atom_t	O
*	O
atom	O
=	O
(	O
ctf_str_atom_t	O
*	O
)	O
value	int
;	O
ctf_str_purge_atom_refs	O
(	O
atom	O
)	O
;	O
}	O
void	O
ctf_str_purge_refs	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
if	O
(	O
fp	*(struct)
->	O
ctf_str_num_refs	O
>	O
0	int
)	O
ctf_dynhash_iter	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
ctf_str_purge_one_atom_refs	O
,	O
NULL	O
)	O
;	O
fp	*(struct)
->	O
ctf_str_num_refs	O
=	O
0	int
;	O
}	O
static	O
void	O
ctf_str_update_refs	O
(	O
ctf_str_atom_t	O
*	O
refs	O
,	O
uint32_t	int
value	int
)	O
{	O
ctf_str_atom_ref_t	O
*	O
ref	O
;	O
for	O
(	O
ref	O
=	O
ctf_list_next	O
(	O
&	O
refs	O
->	O
csa_refs	O
)	O
;	O
ref	O
!=	O
NULL	O
;	O
ref	O
=	O
ctf_list_next	O
(	O
ref	O
)	O
)	O
*	O
(	O
ref	O
->	O
caf_ref	O
)	O
=	O
value	int
;	O
}	O
typedef	O
struct	O
ctf_strtab_write_state	O
{	O
ctf_strs_writable_t	O
*	O
strtab	O
;	O
size_t	long
strtab_count	O
;	O
ctf_str_atom_t	O
*	O
*	O
sorttab	O
;	O
size_t	long
i	*(struct)
;	O
ctf_str_atom_t	O
*	O
nullstr	O
;	O
}	O
ctf_strtab_write_state_t	O
;	O
static	O
void	O
ctf_str_count_strtab	O
(	O
void	O
*	O
key	O
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg	*(void)
)	O
{	O
ctf_str_atom_t	O
*	O
atom	O
=	O
(	O
ctf_str_atom_t	O
*	O
)	O
value	int
;	O
ctf_strtab_write_state_t	O
*	O
s	*(char)
=	O
(	O
ctf_strtab_write_state_t	O
*	O
)	O
arg	*(void)
;	O
if	O
(	O
s	*(char)
->	O
nullstr	O
==	O
atom	O
)	O
{	O
s	*(char)
->	O
strtab_count	O
++	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
ctf_list_empty_p	O
(	O
&	O
atom	O
->	O
csa_refs	O
)	O
)	O
{	O
if	O
(	O
!	O
atom	O
->	O
csa_external_offset	O
)	O
s	*(char)
->	O
strtab	O
->	O
cts_len	O
+=	O
strlen	O
(	O
atom	O
->	O
csa_str	O
)	O
+	O
1	int
;	O
s	*(char)
->	O
strtab_count	O
++	O
;	O
}	O
}	O
static	O
void	O
ctf_str_populate_sorttab	O
(	O
void	O
*	O
key	O
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg	*(void)
)	O
{	O
ctf_str_atom_t	O
*	O
atom	O
=	O
(	O
ctf_str_atom_t	O
*	O
)	O
value	int
;	O
ctf_strtab_write_state_t	O
*	O
s	*(char)
=	O
(	O
ctf_strtab_write_state_t	O
*	O
)	O
arg	*(void)
;	O
if	O
(	O
s	*(char)
->	O
nullstr	O
==	O
atom	O
)	O
return	O
;	O
if	O
(	O
!	O
ctf_list_empty_p	O
(	O
&	O
atom	O
->	O
csa_refs	O
)	O
)	O
s	*(char)
->	O
sorttab	O
[	O
s	*(char)
->	O
i	*(struct)
++	O
]	O
=	O
atom	O
;	O
}	O
static	O
int	O
ctf_str_sort_strtab	O
(	O
const	O
void	O
*	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
const	O
void	O
*	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
ctf_str_atom_t	O
*	O
*	O
one	O
=	O
(	O
ctf_str_atom_t	O
*	O
*	O
)	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
ctf_str_atom_t	O
*	O
*	O
two	O
=	O
(	O
ctf_str_atom_t	O
*	O
*	O
)	O
b	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
return	O
(	O
strcmp	O
(	O
(	O
*	O
one	O
)	O
->	O
csa_str	O
,	O
(	O
*	O
two	O
)	O
->	O
csa_str	O
)	O
)	O
;	O
}	O
ctf_strs_writable_t	O
ctf_str_write_strtab	O
(	O
ctf_file_t	struct
*	O
fp	*(struct)
)	O
{	O
ctf_strs_writable_t	O
strtab	O
;	O
ctf_str_atom_t	O
*	O
nullstr	O
;	O
uint32_t	int
cur_stroff	O
=	O
0	int
;	O
ctf_strtab_write_state_t	O
s	*(char)
;	O
ctf_str_atom_t	O
*	O
*	O
sorttab	O
;	O
size_t	long
i	*(struct)
;	O
int	O
any_external	O
=	O
0	int
;	O
memset	O
(	O
&	O
strtab	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
ctf_strs_writable	O
)	O
)	O
;	O
memset	O
(	O
&	O
s	*(char)
,	O
0	int
,	O
sizeof	O
(	O
struct	O
ctf_strtab_write_state	O
)	O
)	O
;	O
s	*(char)
.	O
strtab	O
=	O
&	O
strtab	O
;	O
nullstr	O
=	O
ctf_dynhash_lookup	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
!	O
nullstr	O
)	O
{	O
ctf_dprintf	O
(	O
"Internal error: null string not found in strtab.\n"	*(char)
)	O
;	O
strtab	O
.	O
cts_strs	O
=	O
NULL	O
;	O
return	O
strtab	O
;	O
}	O
s	*(char)
.	O
nullstr	O
=	O
nullstr	O
;	O
ctf_dynhash_iter	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
ctf_str_count_strtab	O
,	O
&	O
s	*(char)
)	O
;	O
strtab	O
.	O
cts_len	O
++	O
;	O
ctf_dprintf	O
(	O
"%lu bytes of strings in strtab.\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
strtab	O
.	O
cts_len	O
)	O
;	O
sorttab	O
=	O
calloc	(long,long)->(*(void))
(	O
s	*(char)
.	O
strtab_count	O
,	O
sizeof	O
(	O
ctf_str_atom_t	O
*	O
)	O
)	O
;	O
if	O
(	O
!	O
sorttab	O
)	O
goto	O
oom	O
;	O
sorttab	O
[	O
0	int
]	O
=	O
nullstr	O
;	O
s	*(char)
.	O
i	*(struct)
=	O
1	int
;	O
s	*(char)
.	O
sorttab	O
=	O
sorttab	O
;	O
ctf_dynhash_iter	O
(	O
fp	*(struct)
->	O
ctf_str_atoms	O
,	O
ctf_str_populate_sorttab	O
,	O
&	O
s	*(char)
)	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
&	O
sorttab	O
[	O
1	int
]	O
,	O
s	*(char)
.	O
strtab_count	O
-	O
1	int
,	O
sizeof	O
(	O
ctf_str_atom_t	O
*	O
)	O
,	O
ctf_str_sort_strtab	O
)	O
;	O
if	O
(	O
(	O
strtab	O
.	O
cts_strs	O
=	O
malloc	(long)->(*(void))
(	O
strtab	O
.	O
cts_len	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
oom_sorttab	O
;	O
if	O
(	O
!	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
)	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
=	O
ctf_dynhash_create	O
(	O
ctf_hash_integer	O
,	O
ctf_hash_eq_integer	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
)	O
goto	O
oom_strtab	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
s	*(char)
.	O
strtab_count	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_external_offset	O
)	O
{	O
any_external	O
=	O
1	int
;	O
ctf_str_update_refs	O
(	O
sorttab	O
[	O
i	*(struct)
]	O
,	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_external_offset	O
)	O
;	O
if	O
(	O
ctf_dynhash_insert	O
(	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_external_offset	O
,	O
(	O
void	O
*	O
)	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_str	O
)	O
<	O
0	int
)	O
goto	O
oom_strtab	O
;	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_offset	O
=	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_external_offset	O
;	O
}	O
else	O
{	O
ctf_str_update_refs	O
(	O
sorttab	O
[	O
i	*(struct)
]	O
,	O
cur_stroff	O
)	O
;	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_offset	O
=	O
cur_stroff	O
;	O
strcpy	O
(	O
&	O
strtab	O
.	O
cts_strs	O
[	O
cur_stroff	O
]	O
,	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_str	O
)	O
;	O
cur_stroff	O
+=	O
strlen	O
(	O
sorttab	O
[	O
i	*(struct)
]	O
->	O
csa_str	O
)	O
+	O
1	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
sorttab	O
)	O
;	O
if	O
(	O
!	O
any_external	O
)	O
{	O
ctf_dynhash_destroy	O
(	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
)	O
;	O
fp	*(struct)
->	O
ctf_syn_ext_strtab	O
=	O
NULL	O
;	O
}	O
ctf_dynhash_empty	O
(	O
fp	*(struct)
->	O
ctf_prov_strtab	O
)	O
;	O
fp	*(struct)
->	O
ctf_str_prov_offset	O
=	O
strtab	O
.	O
cts_len	O
+	O
1	int
;	O
return	O
strtab	O
;	O
oom_strtab	O
:	O
free	(*(void))->(void)
(	O
strtab	O
.	O
cts_strs	O
)	O
;	O
strtab	O
.	O
cts_strs	O
=	O
NULL	O
;	O
oom_sorttab	O
:	O
free	(*(void))->(void)
(	O
sorttab	O
)	O
;	O
oom	O
:	O
return	O
strtab	O
;	O
}	O
