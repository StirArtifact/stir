mu_mailbox_t	*(struct)
mbox	*(struct)
;	O
size_t	long
total	long
;	O
int	O
interactive	int
;	O
int	O
read_recipients	int
;	O
mu_url_t	*(struct)
secondary_url	*(struct)
;	O
static	O
mu_list_t	*(struct)
command_list	*(struct)
;	O
const	O
char	O
*	O
program_version	*(char)
=	O
"mail ("	*(char)
PACKAGE_STRING	*(char)
")"	*(char)
;	O
int	O
hint	*(struct)
;	O
char	O
*	O
file	*(char)
;	O
char	O
*	O
user	*(char)
;	O
int	O
mime_option	int
;	O
int	O
skip_empty_attachments	int
;	O
char	O
*	O
default_encoding	*(char)
;	O
char	O
*	O
default_content_type	*(char)
;	O
static	O
char	O
*	O
content_name	*(char)
;	O
static	O
char	O
*	O
content_filename	*(char)
;	O
static	O
void	O
cli_f_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
hint	*(struct)
|=	O
HINT_FILE_OPTION	int
;	O
}	O
static	O
void	O
cli_file_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
arg	*(char)
)	O
file	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
hint	*(struct)
|=	O
HINT_FILE_OPTION	int
;	O
}	O
static	O
void	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
switch	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
->	O
opt_short	int
)	O
{	O
case	O
'e'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"setq mode=exist"	*(char)
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"setq mode=print"	*(char)
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"set return-address=%s"	*(char)
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'q'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"set quit"	*(char)
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
read_recipients	int
=	O
1	int
;	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"set editheaders"	*(char)
)	O
;	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"setq mode=send"	*(char)
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"setq mode=headers"	*(char)
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"set ignore"	*(char)
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
util_do_command	(*(char))->(int)
(	O
"set norc"	*(char)
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"set noheader"	*(char)
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"%s"	*(char)
,	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"set byname"	*(char)
)	O
;	O
break	O
;	O
case	O
0	int
:	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"--%s: option should have been recognized"	*(char)
)	O
,	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
->	O
opt_long	*(char)
)	O
;	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
default	O
:	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"-%c: option should have been recognized"	*(char)
)	O
,	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
->	O
opt_short	int
)	O
;	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
}	O
static	O
void	O
cli_subject	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
hint	*(struct)
|=	O
HINT_SEND_MODE	int
;	O
send_append_header2	(*(char),*(char),int)->(void)
(	O
MU_HEADER_SUBJECT	*(char)
,	O
arg	*(char)
,	O
COMPOSE_REPLACE	int
)	O
;	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"set noasksub"	*(char)
)	O
;	O
}	O
static	O
void	O
cli_append	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
hint	*(struct)
|=	O
HINT_SEND_MODE	int
;	O
send_append_header	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
}	O
static	O
void	O
cli_attach	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
int	O
fd	int
=	O
-	O
1	int
;	O
hint	*(struct)
|=	O
HINT_SEND_MODE	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
arg	*(char)
=	O
NULL	O
;	O
fd	int
=	O
0	int
;	O
}	O
if	O
(	O
send_attach_file	(int,*(char),*(char),*(char),*(char),*(char))->(int)
(	O
fd	int
,	O
arg	*(char)
,	O
content_filename	*(char)
,	O
content_name	*(char)
,	O
default_content_type	*(char)
,	O
default_encoding	*(char)
)	O
)	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
mime_option	int
=	O
1	int
;	O
free	(*(void))->(void)
(	O
content_name	*(char)
)	O
;	O
content_name	*(char)
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
content_filename	*(char)
)	O
;	O
content_filename	*(char)
=	O
NULL	O
;	O
}	O
static	O
void	O
cli_attach_fd	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
int	O
rc	int
,	O
fd	int
;	O
hint	*(struct)
|=	O
HINT_SEND_MODE	int
;	O
rc	int
=	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
arg	*(char)
,	O
mu_c_int	int
,	O
&	O
fd	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"%s: bad descriptor"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
send_attach_file	(int,*(char),*(char),*(char),*(char),*(char))->(int)
(	O
fd	int
,	O
NULL	O
,	O
content_filename	*(char)
,	O
content_name	*(char)
,	O
default_content_type	*(char)
,	O
default_encoding	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
content_name	*(char)
)	O
;	O
content_name	*(char)
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
content_filename	*(char)
)	O
;	O
content_filename	*(char)
=	O
NULL	O
;	O
}	O
static	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
mail_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
'f'	O
,	O
NULL	O
,	O
MU_OPTION_HIDDEN	int
,	O
NULL	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_f_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"file"	*(char)
,	O
0	int
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
MU_OPTION_ARG_OPTIONAL	int
|	O
MU_OPTION_HIDDEN	int
,	O
NULL	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_file_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"exist"	*(char)
,	O
'e'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"return true if mail exists"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"byname"	*(char)
,	O
'F'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"save messages according to sender"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"headers"	*(char)
,	O
'H'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"write a header summary and exit"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"ignore"	*(char)
,	O
'i'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"ignore interrupts"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"norc"	*(char)
,	O
'n'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"do not read the system mailrc file"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"nosum"	*(char)
,	O
'N'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"do not display initial header summary"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"print"	*(char)
,	O
'p'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"print all mail to standard output"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"read"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_ALIAS	int
}	O
,	O
{	O
"return-address"	*(char)
,	O
'r'	O
,	O
N_	O
(	O
"ADDRESS"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"use address as the return address when sending mail"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"quit"	*(char)
,	O
'q'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"cause interrupts to terminate program"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"subject"	*(char)
,	O
's'	O
,	O
N_	O
(	O
"SUBJ"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"send a message with the given SUBJECT"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_subject	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"to"	*(char)
,	O
't'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"read recipients from the message header"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"user"	*(char)
,	O
'u'	O
,	O
N_	O
(	O
"USER"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"operate on USER's mailbox"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
user	*(char)
}	O
,	O
{	O
"append"	*(char)
,	O
'a'	O
,	O
N_	O
(	O
"HEADER: VALUE"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"append given header to the message being sent"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_append	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"alternative"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"force multipart/alternative content type"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
multipart_alternative	int
}	O
,	O
{	O
"skip-empty-attachments"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"skip attachments with empty body"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
skip_empty_attachments	int
}	O
,	O
{	O
"exec"	*(char)
,	O
'E'	O
,	O
N_	O
(	O
"COMMAND"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"execute COMMAND"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_command_option	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"encoding"	*(char)
,	O
0	int
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set encoding for subsequent --attach options"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
default_encoding	*(char)
}	O
,	O
{	O
"content-type"	*(char)
,	O
0	int
,	O
N_	O
(	O
"TYPE"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set content type for subsequent --attach options"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
default_content_type	*(char)
}	O
,	O
{	O
"content-name"	*(char)
,	O
0	int
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set the Content-Type name parameter for the next --attach option"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
content_name	*(char)
}	O
,	O
{	O
"content-filename"	*(char)
,	O
0	int
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set the Content-Disposition filename parameter for the next --attach option"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
content_filename	*(char)
}	O
,	O
{	O
"attach"	*(char)
,	O
'A'	O
,	O
N_	O
(	O
"FILE"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"attach FILE"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_attach	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"attach-fd"	*(char)
,	O
0	int
,	O
N_	O
(	O
"FD"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"attach from file descriptor FD"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_attach_fd	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"mime"	*(char)
,	O
'M'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"compose MIME messages"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
mime_option	int
}	O
,	O
MU_OPTION_END	O
}	O
,	O
*	O
options	array(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))))
[	O
]	O
=	O
{	O
mail_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
,	O
NULL	O
}	O
;	O
static	O
const	O
char	O
*	O
alt_args	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"[OPTION...] [file]"	*(char)
)	O
,	O
N_	O
(	O
"--file [OPTION...] [file]"	*(char)
)	O
,	O
N_	O
(	O
"--file=file [OPTION...]"	*(char)
)	O
,	O
NULL	O
}	O
;	O
static	O
struct	O
mu_cli_setup	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
cli	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
=	O
{	O
options	array(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))))
,	O
NULL	O
,	O
N_	O
(	O
"GNU mail -- process mail messages.\n"	*(char)
"If -f or --file is given, mail operates on the mailbox named "	*(char)
"by the first argument, or the user's mbox, if no argument given."	*(char)
)	O
,	O
N_	O
(	O
"[address...]"	*(char)
)	O
,	O
alt_args	array(*(char))
,	O
NULL	O
,	O
1	int
,	O
1	int
}	O
;	O
static	O
char	O
*	O
mail_capa	array(*(char))
[	O
]	O
=	O
{	O
"address"	*(char)
,	O
"debug"	*(char)
,	O
"mailbox"	*(char)
,	O
"locking"	*(char)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
mail_cmdline	(*(void),int)->(*(char))
(	O
void	O
*	O
closure	*(void)
,	O
int	O
cont	*(struct(enum(int,int),*(struct),union(*(char),struct(*(char),*(char),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*(void),long,*(struct`),*(char),*(void)),struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char)))))
MU_ARG_UNUSED	O
)	O
{	O
char	O
*	O
prompt	*(char)
=	O
(	O
char	O
*	O
)	O
closure	*(void)
;	O
char	O
*	O
rc	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_autoinc	*(char)
)	O
&&	O
!	O
mu_mailbox_is_updated	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
)	O
{	O
mu_mailbox_messages_count	(*(struct),*(long))->(int)
(	O
mbox	*(struct)
,	O
&	O
total	long
)	O
;	O
page_invalidate	(int)->(void)
(	O
0	int
)	O
;	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"New mail has arrived.\n"	*(char)
)	O
)	O
;	O
}	O
rc	int
=	O
ml_readline	(*(char))->(*(char))
(	O
prompt	*(char)
)	O
;	O
if	O
(	O
ml_got_interrupt	()->(int)
(	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Interrupt"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
rc	int
&&	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_ignoreeof	*(char)
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Use \"quit\" to quit."	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
char	O
*	O
default_setup	array(*(char))
[	O
]	O
=	O
{	O
"setq append"	*(char)
,	O
"set asksub"	*(char)
,	O
"set crt"	*(char)
,	O
"set noaskbcc"	*(char)
,	O
"set askcc"	*(char)
,	O
"set noautoprint"	*(char)
,	O
"set nobang"	*(char)
,	O
"set nocmd"	*(char)
,	O
"set nodot"	*(char)
,	O
"set escape=~"	*(char)
,	O
"set noflipr"	*(char)
,	O
"set nofolder"	*(char)
,	O
"set header"	*(char)
,	O
"set nohold"	*(char)
,	O
"set noignore"	*(char)
,	O
"set noignoreeof"	*(char)
,	O
"set indentprefix=\"\t\""	*(char)
,	O
"setq keep"	*(char)
,	O
"set nokeepsave"	*(char)
,	O
"set nometoo"	*(char)
,	O
"set noonehop"	*(char)
,	O
"set nooutfolder"	*(char)
,	O
"set nopage"	*(char)
,	O
"set prompt=\"? \""	*(char)
,	O
"set norecord"	*(char)
,	O
"set save"	*(char)
,	O
"set nosendmail"	*(char)
,	O
"set nosendwait"	*(char)
,	O
"set noshowto"	*(char)
,	O
"set nosign"	*(char)
,	O
"set noSign"	*(char)
,	O
"set toplines=5"	*(char)
,	O
"set autoinc"	*(char)
,	O
"set regex"	*(char)
,	O
"set replyprefix=\"Re: \""	*(char)
,	O
"set charset=auto"	*(char)
,	O
"set xmailer"	*(char)
,	O
"unfold subject"	*(char)
,	O
"sender mail-followup-to reply-to from"	*(char)
,	O
"set nocmd"	*(char)
,	O
"set metamail"	*(char)
,	O
"set recursivealiases"	*(char)
,	O
"set noinplacealiases"	*(char)
,	O
"set fromfield"	*(char)
,	O
"set headline=\"%>%a%4m %18f %16d %3L/%-5o %s\""	*(char)
,	O
"unset folder"	*(char)
,	O
"setq mode=read"	*(char)
,	O
"set noquit"	*(char)
,	O
"set rc"	*(char)
,	O
"set noflipr"	*(char)
,	O
"set noshowto"	*(char)
,	O
"set nobang"	*(char)
,	O
"set nullbody"	*(char)
,	O
"set nullbodymsg=\""	*(char)
N_	O
(	O
"Null message body; hope that's ok"	*(char)
)	O
"\""	*(char)
,	O
"set noonehop"	*(char)
,	O
"set nosendwait"	*(char)
,	O
}	O
;	O
static	O
void	O
do_and_quit	(*(char))->(void)
(	O
const	O
char	O
*	O
command	*(char)
)	O
{	O
int	O
rc	int
=	O
util_do_command	(*(char))->(int)
(	O
"%s"	*(char)
,	O
command	*(char)
)	O
;	O
mu_mailbox_close	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
exit	(int)->(void)
(	O
rc	int
!=	O
0	int
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
*	O
mode	int
=	O
NULL	O
,	O
*	O
prompt	*(char)
=	O
NULL	O
,	O
*	O
p	*(char)
;	O
int	O
i	int
,	O
rc	int
;	O
mu_stdstream_setup	(int)->(void)
(	O
MU_STDSTREAM_RESET_NONE	int
)	O
;	O
set_cursor	(int)->(void)
(	O
1	int
)	O
;	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
mu_register_all_formats	O
(	O
)	O
;	O
mu_auth_register_module	(*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
mu_auth_tls_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void)))
)	O
;	O
interactive	int
=	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
;	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
SIG_IGN	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
0	int
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGPIPE	int
,	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
!	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
)	O
setenv	(*(char),*(char),int)->(int)
(	O
"HOME"	*(char)
,	O
util_get_homedir	()->(*(char))
(	O
)	O
,	O
0	int
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"DEAD"	*(char)
,	O
util_fullpath	(*(char))->(*(char))
(	O
"~/dead.letter"	*(char)
)	O
,	O
0	int
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"EDITOR"	*(char)
,	O
"ed"	*(char)
,	O
0	int
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"LISTER"	*(char)
,	O
"ls"	*(char)
,	O
0	int
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"MAILRC"	*(char)
,	O
util_fullpath	(*(char))->(*(char))
(	O
"~/.mailrc"	*(char)
)	O
,	O
0	int
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"MBOX"	*(char)
,	O
util_fullpath	(*(char))->(*(char))
(	O
"~/mbox"	*(char)
)	O
,	O
0	int
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"PAGER"	*(char)
,	O
"more"	*(char)
,	O
0	int
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"SHELL"	*(char)
,	O
"sh"	*(char)
,	O
0	int
)	O
;	O
setenv	(*(char),*(char),int)->(int)
(	O
"VISUAL"	*(char)
,	O
"vi"	*(char)
,	O
0	int
)	O
;	O
util_do_command	(*(char))->(int)
(	O
"setq PID=\"%lu\""	*(char)
,	O
(	O
unsigned	O
long	O
)	O
getpid	()->(int)
(	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
default_setup	array(*(char))
)	O
/	O
sizeof	O
(	O
default_setup	array(*(char))
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
util_do_command	(*(char))->(int)
(	O
"%s"	*(char)
,	O
default_setup	array(*(char))
[	O
i	int
]	O
)	O
;	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LINES"	*(char)
)	O
;	O
if	O
(	O
p	*(char)
&&	O
p	*(char)
[	O
strspn	(*(char),*(char))->(long)
(	O
p	*(char)
,	O
"0123456789"	*(char)
)	O
]	O
==	O
0	int
)	O
util_do_command	(*(char))->(int)
(	O
"set screen=%s"	*(char)
,	O
p	*(char)
)	O
;	O
else	O
util_do_command	(*(char))->(int)
(	O
"set screen=%d"	*(char)
,	O
util_getlines	()->(int)
(	O
)	O
)	O
;	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"COLUMNS"	*(char)
)	O
;	O
if	O
(	O
p	*(char)
&&	O
p	*(char)
[	O
strspn	(*(char),*(char))->(long)
(	O
p	*(char)
,	O
"0123456789"	*(char)
)	O
]	O
==	O
0	int
)	O
util_do_command	(*(char))->(int)
(	O
"set columns=%s"	*(char)
,	O
p	*(char)
)	O
;	O
else	O
util_do_command	(*(char))->(int)
(	O
"set columns=%d"	*(char)
,	O
util_getcols	()->(int)
(	O
)	O
)	O
;	O
mailvar_set	(*(char),*(void),enum(int,int,int,int),int)->(int)
(	O
mailvar_name_sendmail	*(char)
,	O
mu_strdup	(*(char))->(*(char))
(	O
"sendmail:"	*(char)
PATH_SENDMAIL	O
)	O
,	O
mailvar_type_string	int
,	O
MOPTF_OVERWRITE	int
)	O
;	O
mu_cli	(int,*(*(char)),*(struct(*(*(struct`)),*(struct(*`,int,*`,long,*`,*`,*`)),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*`)->(void)))),*(*(char)),*(void),*(int),*(*(*(char))))->(void)
(	O
argc	int
,	O
argv	*(*(char))
,	O
&	O
cli	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
,	O
mail_capa	array(*(char))
,	O
NULL	O
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
default_content_type	*(char)
||	O
default_encoding	*(char)
)	O
mime_option	int
=	O
1	int
;	O
if	O
(	O
mime_option	int
)	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"set mime"	*(char)
)	O
;	O
if	O
(	O
read_recipients	int
)	O
{	O
argv	*(*(char))
+=	O
argc	int
;	O
argc	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
hint	*(struct)
&	O
(	O
HINT_SEND_MODE	int
|	O
HINT_FILE_OPTION	int
)	O
)	O
==	O
(	O
HINT_SEND_MODE	int
|	O
HINT_FILE_OPTION	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"conflicting options"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
hint	*(struct)
&	O
HINT_FILE_OPTION	int
)	O
{	O
if	O
(	O
file	*(char)
)	O
{	O
if	O
(	O
argc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"-f requires at most one command line argument"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
argc	int
)	O
{	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"-f requires at most one command line argument"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
file	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
user	*(char)
)	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
file	*(char)
,	O
"~/%s/mbox"	*(char)
,	O
user	*(char)
)	O
;	O
else	O
file	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
"~/mbox"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
argc	int
||	O
(	O
hint	*(struct)
&	O
HINT_SEND_MODE	int
)	O
)	O
util_cache_command	(*(*(struct)),*(char))->(void)
(	O
&	O
command_list	*(struct)
,	O
"setq mode=send"	*(char)
)	O
;	O
else	O
if	O
(	O
user	*(char)
)	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
file	*(char)
,	O
"%%%s"	*(char)
,	O
user	*(char)
)	O
;	O
if	O
(	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_rc	*(char)
)	O
)	O
util_do_command	(*(char))->(int)
(	O
"source %s"	*(char)
,	O
SITE_MAIL_RC	O
)	O
;	O
if	O
(	O
(	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"MAILRC"	*(char)
)	O
)	O
&&	O
*	O
p	*(char)
)	O
util_do_command	(*(char))->(int)
(	O
"source %s"	*(char)
,	O
getenv	(*(char))->(*(char))
(	O
"MAILRC"	*(char)
)	O
)	O
;	O
util_run_cached_commands	(*(*(struct)))->(void)
(	O
&	O
command_list	*(struct)
)	O
;	O
if	O
(	O
interactive	int
)	O
{	O
mu_stream_t	*(struct)
errstr	*(struct)
;	O
int	O
rc	int
=	O
mu_stdstream_strerr_create	(*(*(struct)),int,int,int,*(char),*(char))->(int)
(	O
&	O
errstr	*(struct)
,	O
MU_STRERR_STDERR	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
mu_strerr	*(struct)
)	O
;	O
mu_strerr	*(struct)
=	O
errstr	*(struct)
;	O
}	O
}	O
else	O
{	O
util_do_command	(*(char))->(int)
(	O
"set nocrt"	*(char)
)	O
;	O
util_do_command	(*(char))->(int)
(	O
"set noasksub"	*(char)
)	O
;	O
util_do_command	(*(char))->(int)
(	O
"set noaskcc"	*(char)
)	O
;	O
util_do_command	(*(char))->(int)
(	O
"set noaskbcc"	*(char)
)	O
;	O
}	O
if	O
(	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
mode	int
,	O
mailvar_name_mode	*(char)
,	O
mailvar_type_string	int
,	O
1	int
)	O
)	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
ml_readline_init	()->(void)
(	O
)	O
;	O
mail_set_my_name	(*(char))->(void)
(	O
user	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	int
,	O
"send"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
buf	*(char)
=	O
NULL	O
;	O
int	O
rc	int
;	O
mu_argcv_string	(int,*(*(char)),*(*(char)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
&	O
buf	*(char)
)	O
;	O
rc	int
=	O
util_do_command	(*(char))->(int)
(	O
"mail %s"	*(char)
,	O
buf	*(char)
)	O
;	O
return	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_mailx	*(char)
)	O
?	O
0	int
:	O
rc	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_create_default	(*(*(struct)),*(char))->(int)
(	O
&	O
mbox	*(struct)
,	O
file	*(char)
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
file	*(char)
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot create mailbox %s: %s"	*(char)
)	O
,	O
file	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot create mailbox: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
file	*(char)
)	O
{	O
mu_url_t	*(struct)
url	*(char)
;	O
if	O
(	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(char)
)	O
==	O
0	int
)	O
{	O
rc	int
=	O
mu_url_dup	(*(struct),*(*(struct)))->(int)
(	O
url	*(char)
,	O
&	O
secondary_url	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_url_dup"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
file	*(char)
,	O
0	int
,	O
strlen	(*(char))->(long)
(	O
file	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_open	(*(struct),int)->(int)
(	O
mbox	*(struct)
,	O
MU_STREAM_RDWR	O
|	O
MU_STREAM_CREAT	int
)	O
)	O
!=	O
0	int
)	O
{	O
mu_url_t	*(struct)
url	*(char)
=	O
NULL	O
;	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(char)
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot open mailbox %s: %s"	*(char)
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
mbox	*(struct)
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
total	long
=	O
0	int
;	O
else	O
{	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_scan	(*(struct),long,*(long))->(int)
(	O
mbox	*(struct)
,	O
1	int
,	O
&	O
total	long
)	O
)	O
!=	O
0	int
)	O
{	O
mu_url_t	*(struct)
url	*(char)
=	O
NULL	O
;	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(char)
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot read mailbox %s: %s"	*(char)
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	int
,	O
"exist"	*(char)
)	O
==	O
0	int
)	O
{	O
mu_mailbox_close	(*(struct))->(int)
(	O
mbox	*(struct)
)	O
;	O
return	O
(	O
total	long
<	O
1	int
)	O
?	O
1	int
:	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	int
,	O
"print"	*(char)
)	O
==	O
0	int
)	O
do_and_quit	(*(char))->(void)
(	O
"print *"	*(char)
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	int
,	O
"headers"	*(char)
)	O
==	O
0	int
)	O
do_and_quit	(*(char))->(void)
(	O
"from *"	*(char)
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	int
,	O
"read"	*(char)
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Unknown mode `%s'"	*(char)
)	O
,	O
mode	int
)	O
;	O
util_do_command	(*(char))->(int)
(	O
mailvar_name_quit	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
total	long
==	O
0	int
&&	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mode	int
,	O
"read"	*(char)
)	O
||	O
!	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_emptystart	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
secondary_url	*(struct)
)	O
mail_summary	(int,*(*(char)))->(int)
(	O
0	int
,	O
NULL	O
)	O
;	O
else	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"No mail for %s\n"	*(char)
)	O
,	O
user	*(char)
?	O
user	*(char)
:	O
mail_whoami	()->(*(char))
(	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_header	*(char)
)	O
)	O
{	O
util_do_command	(*(char))->(int)
(	O
"summary"	*(char)
)	O
;	O
util_do_command	(*(char))->(int)
(	O
"headers"	*(char)
)	O
;	O
}	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
prompt	*(char)
,	O
mailvar_name_prompt	*(char)
,	O
mailvar_type_string	int
,	O
0	int
)	O
;	O
mail_mainloop	(*((*(void),int)->(*(char))),*(void),int)->(void)
(	O
mail_cmdline	(*(void),int)->(*(char))
,	O
(	O
void	O
*	O
)	O
prompt	*(char)
,	O
1	int
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
util_do_command	(*(char))->(int)
(	O
mailvar_name_quit	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
void	O
mail_mainloop	(*((*(void),int)->(*(char))),*(void),int)->(void)
(	O
char	O
*	O
(	O
*	O
input	*(char)
)	O
(	O
void	O
*	O
,	O
int	O
)	O
,	O
void	O
*	O
closure	*(void)
,	O
int	O
do_history	int
)	O
{	O
char	O
*	O
command	*(char)
,	O
*	O
cmd	enum(int,int,int,int,int)
;	O
while	O
(	O
(	O
command	*(char)
=	O
(	O
*	O
input	*(char)
)	O
(	O
closure	*(void)
,	O
0	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
int	O
len	long
=	O
strlen	(*(char))->(long)
(	O
command	*(char)
)	O
;	O
while	O
(	O
len	long
>	O
0	int
&&	O
command	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
char	O
*	O
buf	*(char)
;	O
char	O
*	O
command2	*(char)
=	O
(	O
*	O
input	*(char)
)	O
(	O
closure	*(void)
,	O
1	int
)	O
;	O
if	O
(	O
!	O
command2	*(char)
)	O
{	O
command	*(char)
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
break	O
;	O
}	O
command	*(char)
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
buf	*(char)
=	O
mu_alloc	(long)->(*(void))
(	O
(	O
len	long
+	O
strlen	(*(char))->(long)
(	O
command2	*(char)
)	O
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
command	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
command2	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
command	*(char)
)	O
;	O
command	*(char)
=	O
buf	*(char)
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
command	*(char)
)	O
;	O
}	O
cmd	enum(int,int,int,int,int)
=	O
mu_str_stripws	(*(char))->(*(char))
(	O
command	*(char)
)	O
;	O
util_do_command	(*(char))->(int)
(	O
"%s"	*(char)
,	O
cmd	enum(int,int,int,int,int)
)	O
;	O
if	O
(	O
command	*(char)
)	O
free	(*(void))->(void)
(	O
command	*(char)
)	O
;	O
}	O
}	O
int	O
mail_warranty	(int,*(*(char)))->(int)
(	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
)	O
{	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"GNU Mailutils -- a suite of utilities for electronic mail\n"	*(char)
"Copyright (C) 1999-2019 Free Software Foundation, Inc.\n\n"	*(char)
)	O
)	O
;	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"   GNU Mailutils is free software; you can redistribute it and/or modify\n"	*(char)
"   it under the terms of the GNU General Public License as published by\n"	*(char)
"   the Free Software Foundation; either version 3 of the License, or\n"	*(char)
"   (at your option) any later version.\n"	*(char)
"\n"	*(char)
"   GNU Mailutils is distributed in the hope that it will be useful,\n"	*(char)
"   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"	*(char)
"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"	*(char)
"   GNU General Public License for more details.\n"	*(char)
"\n"	*(char)
"   You should have received a copy of the GNU General Public License along\n"	*(char)
"   with GNU Mailutils.  If not, see <http://www.gnu.org/licenses/>.\n"	*(char)
"\n"	*(char)
"\n"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
