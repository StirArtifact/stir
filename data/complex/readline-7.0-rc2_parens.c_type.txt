static	O
int	O
find_matching_open	(*(char),int,int)->(int)
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
int	O
rl_blink_matching_paren	int
=	O
0	int
;	O
static	O
int	O
_paren_blink_usec	int
=	O
500000	int
;	O
void	O
_rl_enable_paren_matching	(int)->(void)
(	O
on_or_off	int
)	O
int	O
on_or_off	int
;	O
{	O
if	O
(	O
on_or_off	int
)	O
{	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
')'	O
,	O
rl_insert_close	(int,int)->(int)
,	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
']'	O
,	O
rl_insert_close	(int,int)->(int)
,	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
'}'	O
,	O
rl_insert_close	(int,int)->(int)
,	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
')'	O
,	O
rl_insert_close	(int,int)->(int)
,	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
']'	O
,	O
rl_insert_close	(int,int)->(int)
,	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
'}'	O
,	O
rl_insert_close	(int,int)->(int)
,	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
}	O
else	O
{	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
')'	O
,	O
rl_insert	(int,int)->(int)
,	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
']'	O
,	O
rl_insert	(int,int)->(int)
,	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
'}'	O
,	O
rl_insert	(int,int)->(int)
,	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
')'	O
,	O
rl_insert	(int,int)->(int)
,	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
']'	O
,	O
rl_insert	(int,int)->(int)
,	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
rl_bind_key_in_map	(int,*((int,int)->(int)),*(struct(char,*((int,int)->(int)))))->(int)
(	O
'}'	O
,	O
rl_insert	(int,int)->(int)
,	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
)	O
;	O
}	O
}	O
int	O
rl_set_paren_blink_timeout	(int)->(int)
(	O
u	int
)	O
int	O
u	int
;	O
{	O
int	O
o	int
;	O
o	int
=	O
_paren_blink_usec	int
;	O
if	O
(	O
u	int
>	O
0	int
)	O
_paren_blink_usec	int
=	O
u	int
;	O
return	O
(	O
o	int
)	O
;	O
}	O
int	O
rl_insert_close	(int,int)->(int)
(	O
count	int
,	O
invoking_key	int
)	O
int	O
count	int
,	O
invoking_key	int
;	O
{	O
if	O
(	O
rl_explicit_arg	int
||	O
!	O
rl_blink_matching_paren	int
)	O
_rl_insert_char	(int,int)->(int)
(	O
count	int
,	O
invoking_key	int
)	O
;	O
else	O
{	O
int	O
orig_point	int
,	O
match_point	int
,	O
ready	int
;	O
struct	O
timeval	struct(long,long)
timer	struct(long,long)
;	O
fd_set	struct(array(long))
readfds	struct(array(long))
;	O
_rl_insert_char	(int,int)->(int)
(	O
1	int
,	O
invoking_key	int
)	O
;	O
(	O
*	O
rl_redisplay_function	*(()->(void))
)	O
(	O
)	O
;	O
match_point	int
=	O
find_matching_open	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
-	O
2	int
,	O
invoking_key	int
)	O
;	O
if	O
(	O
match_point	int
<	O
0	int
)	O
return	O
1	int
;	O
FD_ZERO	O
(	O
&	O
readfds	struct(array(long))
)	O
;	O
FD_SET	O
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_instream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
&	O
readfds	struct(array(long))
)	O
;	O
USEC_TO_TIMEVAL	O
(	O
_paren_blink_usec	int
,	O
timer	struct(long,long)
)	O
;	O
orig_point	int
=	O
rl_point	int
;	O
rl_point	int
=	O
match_point	int
;	O
(	O
*	O
rl_redisplay_function	*(()->(void))
)	O
(	O
)	O
;	O
ready	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
1	int
,	O
&	O
readfds	struct(array(long))
,	O
(	O
fd_set	struct(array(long))
*	O
)	O
NULL	O
,	O
(	O
fd_set	struct(array(long))
*	O
)	O
NULL	O
,	O
&	O
timer	struct(long,long)
)	O
;	O
rl_point	int
=	O
orig_point	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
find_matching_open	(*(char),int,int)->(int)
(	O
string	*(char)
,	O
from	int
,	O
closer	int
)	O
char	O
*	O
string	*(char)
;	O
int	O
from	int
,	O
closer	int
;	O
{	O
register	O
int	O
i	int
;	O
int	O
opener	int
,	O
level	int
,	O
delimiter	int
;	O
switch	O
(	O
closer	int
)	O
{	O
case	O
']'	O
:	O
opener	int
=	O
'['	O
;	O
break	O
;	O
case	O
'}'	O
:	O
opener	int
=	O
'{'	O
;	O
break	O
;	O
case	O
')'	O
:	O
opener	int
=	O
'('	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
level	int
=	O
1	int
;	O
delimiter	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
from	int
;	O
i	int
>	O
-	O
1	int
;	O
i	int
--	O
)	O
{	O
if	O
(	O
delimiter	int
&&	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
delimiter	int
)	O
)	O
delimiter	int
=	O
0	int
;	O
else	O
if	O
(	O
rl_basic_quote_characters	*(char)
&&	O
strchr	(*(char),int)->(*(char))
(	O
rl_basic_quote_characters	*(char)
,	O
string	*(char)
[	O
i	int
]	O
)	O
)	O
delimiter	int
=	O
string	*(char)
[	O
i	int
]	O
;	O
else	O
if	O
(	O
!	O
delimiter	int
&&	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
closer	int
)	O
)	O
level	int
++	O
;	O
else	O
if	O
(	O
!	O
delimiter	int
&&	O
(	O
string	*(char)
[	O
i	int
]	O
==	O
opener	int
)	O
)	O
level	int
--	O
;	O
if	O
(	O
!	O
level	int
)	O
break	O
;	O
}	O
return	O
(	O
i	int
)	O
;	O
}	O
