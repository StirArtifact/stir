static	O
void	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Usage: nettle-pbkdf2 [OPTIONS] SALT\n"	*(char)
"Options:\n"	*(char)
"  --help                 Show this help.\n"	*(char)
"  -V, --version          Show version information.\n"	*(char)
"  -i, --iterations=COUNT Desired iteration count (default %d).\n"	*(char)
"  -l, --length=LENGTH    Desired output length (octets, default %d)\n"	*(char)
"  --raw                  Raw binary output.\n"	*(char)
"  --hex-salt             Use hex encoding for the salt.\n"	*(char)
,	O
DEFAULT_ITERATIONS	int
,	O
DEFAULT_LENGTH	int
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
unsigned	O
iterations	int
=	O
DEFAULT_ITERATIONS	int
;	O
unsigned	O
output_length	int
=	O
DEFAULT_LENGTH	int
;	O
char	O
password	array(char)
[	O
MAX_PASSWORD	int
]	O
;	O
size_t	long
password_length	long
;	O
uint8_t	char
*	O
output	*(char)
;	O
size_t	long
salt_length	long
;	O
char	O
*	O
salt	*(char)
;	O
int	O
raw	int
=	O
0	int
;	O
int	O
hex_salt	int
=	O
0	int
;	O
int	O
c	int
;	O
enum	O
{	O
OPT_HELP	int
=	O
0x300	int
,	O
OPT_RAW	int
,	O
OPT_HEX_SALT	int
}	O
;	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_HELP	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"length"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"iterations"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"raw"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_RAW	int
}	O
,	O
{	O
"hex-salt"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
OPT_HEX_SALT	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"Vl:i:"	*(char)
,	O
options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
'?'	O
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
case	O
OPT_HELP	int
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
'V'	O
:	O
printf	(*(char))->(int)
(	O
"nettle-pbkdf2 ("	*(char)
PACKAGE_STRING	*(char)
")\n"	*(char)
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
case	O
'l'	O
:	O
{	O
int	O
arg	int
;	O
arg	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
arg	int
<=	O
0	int
)	O
die	(*(char))->(void)
(	O
"Invalid length argument: `%s'\n"	*(char)
,	O
optarg	*(char)
)	O
;	O
output_length	int
=	O
arg	int
;	O
}	O
break	O
;	O
case	O
'i'	O
:	O
{	O
int	O
arg	int
;	O
arg	int
=	O
atoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
arg	int
<=	O
0	int
)	O
die	(*(char))->(void)
(	O
"Invalid iteration count: `%s'\n"	*(char)
,	O
optarg	*(char)
)	O
;	O
iterations	int
=	O
arg	int
;	O
}	O
break	O
;	O
case	O
OPT_RAW	int
:	O
raw	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_HEX_SALT	int
:	O
hex_salt	int
=	O
1	int
;	O
break	O
;	O
}	O
argv	*(*(char))
+=	O
optind	int
;	O
argc	int
-=	O
optind	int
;	O
if	O
(	O
argc	int
!=	O
1	int
)	O
{	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
salt	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
salt	*(char)
)	O
die	(*(char))->(void)
(	O
"strdup failed: Virtual memory exhausted.\n"	*(char)
)	O
;	O
salt_length	long
=	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
hex_salt	int
)	O
{	O
struct	O
base16_decode_ctx	struct(char,char)
base16	struct(char,char)
;	O
base16_decode_init	O
(	O
&	O
base16	struct(char,char)
)	O
;	O
if	O
(	O
!	O
base16_decode_update	O
(	O
&	O
base16	struct(char,char)
,	O
&	O
salt_length	long
,	O
(	O
uint8_t	char
*	O
)	O
salt	*(char)
,	O
salt_length	long
,	O
salt	*(char)
)	O
||	O
!	O
base16_decode_final	O
(	O
&	O
base16	struct(char,char)
)	O
)	O
die	(*(char))->(void)
(	O
"Invalid salt (expecting hex encoding).\n"	*(char)
)	O
;	O
}	O
password_length	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
password	array(char)
,	O
1	int
,	O
sizeof	O
(	O
password	array(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
password_length	long
==	O
sizeof	O
(	O
password	array(char)
)	O
)	O
die	(*(char))->(void)
(	O
"Password input too long. Current limit is %d characters.\n"	*(char)
,	O
(	O
int	O
)	O
sizeof	O
(	O
password	array(char)
)	O
-	O
1	int
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
die	(*(char))->(void)
(	O
"Reading password input failed: %s.\n"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
output	*(char)
=	O
xalloc	(long)->(*(void))
(	O
output_length	int
)	O
;	O
pbkdf2_hmac_sha256	O
(	O
password_length	long
,	O
(	O
const	O
uint8_t	char
*	O
)	O
password	array(char)
,	O
iterations	int
,	O
salt_length	long
,	O
(	O
const	O
uint8_t	char
*	O
)	O
salt	*(char)
,	O
output_length	int
,	O
output	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
salt	*(char)
)	O
;	O
if	O
(	O
raw	int
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
output	*(char)
,	O
output_length	int
,	O
1	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
unsigned	O
i	int
;	O
char	O
hex	array(char)
[	O
BASE16_ENCODE_LENGTH	O
(	O
8	int
)	O
+	O
1	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
+	O
8	int
<	O
output_length	int
;	O
i	int
+=	O
8	int
)	O
{	O
base16_encode_update	O
(	O
hex	array(char)
,	O
8	int
,	O
output	*(char)
+	O
i	int
)	O
;	O
hex	array(char)
[	O
BASE16_ENCODE_LENGTH	O
(	O
8	int
)	O
]	O
=	O
0	int
;	O
printf	(*(char))->(int)
(	O
"%s%c"	*(char)
,	O
hex	array(char)
,	O
i	int
%	O
64	int
==	O
56	int
?	O
'\n'	O
:	O
' '	O
)	O
;	O
}	O
base16_encode_update	O
(	O
hex	array(char)
,	O
output_length	int
-	O
i	int
,	O
output	*(char)
+	O
i	int
)	O
;	O
hex	array(char)
[	O
BASE16_ENCODE_LENGTH	O
(	O
output_length	int
-	O
i	int
)	O
]	O
=	O
0	int
;	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
hex	array(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
output	*(char)
)	O
;	O
if	O
(	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
die	(*(char))->(void)
(	O
"Write failed: %s\n"	*(char)
,	O
STRERROR	O
(	O
errno	O
)	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
