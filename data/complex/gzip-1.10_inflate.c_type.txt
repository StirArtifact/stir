struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
{	O
uch	char
e	char
;	O
uch	char
b	char
;	O
union	O
{	O
ush	short
n	int
;	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
t	*(struct(char,char))
;	O
}	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
;	O
}	O
;	O
static	O
int	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
;	O
static	O
unsigned	O
border	array(int)
[	O
]	O
=	O
{	O
16	int
,	O
17	int
,	O
18	int
,	O
0	int
,	O
8	int
,	O
7	int
,	O
9	int
,	O
6	int
,	O
10	int
,	O
5	int
,	O
11	int
,	O
4	int
,	O
12	int
,	O
3	int
,	O
13	int
,	O
2	int
,	O
14	int
,	O
1	int
,	O
15	int
}	O
;	O
static	O
ush	short
cplens	array(short)
[	O
]	O
=	O
{	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
13	int
,	O
15	int
,	O
17	int
,	O
19	int
,	O
23	int
,	O
27	int
,	O
31	int
,	O
35	int
,	O
43	int
,	O
51	int
,	O
59	int
,	O
67	int
,	O
83	int
,	O
99	int
,	O
115	int
,	O
131	int
,	O
163	int
,	O
195	int
,	O
227	int
,	O
258	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
ush	short
cplext	array(short)
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
0	int
,	O
99	int
,	O
99	int
}	O
;	O
static	O
ush	short
cpdist	array(short)
[	O
]	O
=	O
{	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
7	int
,	O
9	int
,	O
13	int
,	O
17	int
,	O
25	int
,	O
33	int
,	O
49	int
,	O
65	int
,	O
97	int
,	O
129	int
,	O
193	int
,	O
257	int
,	O
385	int
,	O
513	int
,	O
769	int
,	O
1025	int
,	O
1537	int
,	O
2049	int
,	O
3073	int
,	O
4097	int
,	O
6145	int
,	O
8193	int
,	O
12289	int
,	O
16385	int
,	O
24577	int
}	O
;	O
static	O
ush	short
cpdext	array(short)
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
4	int
,	O
4	int
,	O
5	int
,	O
5	int
,	O
6	int
,	O
6	int
,	O
7	int
,	O
7	int
,	O
8	int
,	O
8	int
,	O
9	int
,	O
9	int
,	O
10	int
,	O
10	int
,	O
11	int
,	O
11	int
,	O
12	int
,	O
12	int
,	O
13	int
,	O
13	int
}	O
;	O
static	O
ulg	long
bb	long
;	O
static	O
unsigned	O
bk	int
;	O
static	O
ush	short
mask_bits	array(short)
[	O
]	O
=	O
{	O
0x0000	int
,	O
0x0001	int
,	O
0x0003	int
,	O
0x0007	int
,	O
0x000f	int
,	O
0x001f	int
,	O
0x003f	int
,	O
0x007f	int
,	O
0x00ff	int
,	O
0x01ff	int
,	O
0x03ff	int
,	O
0x07ff	int
,	O
0x0fff	int
,	O
0x1fff	int
,	O
0x3fff	int
,	O
0x7fff	int
,	O
0xffff	int
}	O
;	O
static	O
int	O
lbits	int
=	O
9	int
;	O
static	O
int	O
dbits	int
=	O
6	int
;	O
static	O
unsigned	O
hufts	int
;	O
static	O
int	O
huft_build	(*(int),int,int,*(short),*(short),*(*(struct(char,char,union(short,*`)))),*(int))->(int)
(	O
unsigned	O
*	O
b	char
,	O
unsigned	O
n	int
,	O
unsigned	O
s	*(char)
,	O
ush	short
*	O
d	*(short)
,	O
ush	short
*	O
e	char
,	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
*	O
t	*(struct(char,char))
,	O
int	O
*	O
m	*(char)
)	O
{	O
unsigned	O
a	int
;	O
unsigned	O
c	array(int)
[	O
BMAX	int
+	O
1	int
]	O
;	O
unsigned	O
f	int
;	O
int	O
g	int
;	O
int	O
h	int
;	O
register	O
unsigned	O
i	int
;	O
register	O
unsigned	O
j	int
;	O
register	O
int	O
k	int
;	O
int	O
l	int
;	O
register	O
unsigned	O
*	O
p	*(int)
;	O
register	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
;	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
u	array(*(struct(char,char,union(short,*(struct(char,char,union`))))))
[	O
BMAX	int
]	O
;	O
unsigned	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
[	O
N_MAX	int
]	O
;	O
register	O
int	O
w	int
;	O
unsigned	O
x	array(int)
[	O
BMAX	int
+	O
1	int
]	O
;	O
unsigned	O
*	O
xp	*(int)
;	O
int	O
y	int
;	O
unsigned	O
z	int
;	O
memzero	O
(	O
c	array(int)
,	O
sizeof	O
(	O
c	array(int)
)	O
)	O
;	O
p	*(int)
=	O
b	char
;	O
i	int
=	O
n	int
;	O
do	O
{	O
Tracecv	O
(	O
*	O
p	*(int)
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
n	int
-	O
i	int
>=	O
' '	O
&&	O
n	int
-	O
i	int
<=	O
'~'	O
?	O
"%c %d\n"	*(char)
:	O
"0x%x %d\n"	*(char)
)	O
,	O
n	int
-	O
i	int
,	O
*	O
p	*(int)
)	O
)	O
;	O
c	array(int)
[	O
*	O
p	*(int)
]	O
++	O
;	O
p	*(int)
++	O
;	O
}	O
while	O
(	O
--	O
i	int
)	O
;	O
if	O
(	O
c	array(int)
[	O
0	int
]	O
==	O
n	int
)	O
{	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
=	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
malloc	(long)->(*(void))
(	O
3	int
*	O
sizeof	O
*	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
if	O
(	O
!	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
return	O
3	int
;	O
hufts	int
+=	O
3	int
;	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
[	O
0	int
]	O
.	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
t	*(struct(char,char))
=	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
NULL	O
;	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
[	O
1	int
]	O
.	O
e	char
=	O
99	int
;	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
[	O
1	int
]	O
.	O
b	char
=	O
1	int
;	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
[	O
2	int
]	O
.	O
e	char
=	O
99	int
;	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
[	O
2	int
]	O
.	O
b	char
=	O
1	int
;	O
*	O
t	*(struct(char,char))
=	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
+	O
1	int
;	O
*	O
m	*(char)
=	O
1	int
;	O
return	O
0	int
;	O
}	O
l	int
=	O
*	O
m	*(char)
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
BMAX	int
;	O
j	int
++	O
)	O
if	O
(	O
c	array(int)
[	O
j	int
]	O
)	O
break	O
;	O
k	int
=	O
j	int
;	O
if	O
(	O
(	O
unsigned	O
)	O
l	int
<	O
j	int
)	O
l	int
=	O
j	int
;	O
for	O
(	O
i	int
=	O
BMAX	int
;	O
i	int
;	O
i	int
--	O
)	O
if	O
(	O
c	array(int)
[	O
i	int
]	O
)	O
break	O
;	O
g	int
=	O
i	int
;	O
if	O
(	O
(	O
unsigned	O
)	O
l	int
>	O
i	int
)	O
l	int
=	O
i	int
;	O
*	O
m	*(char)
=	O
l	int
;	O
for	O
(	O
y	int
=	O
1	int
<<	O
j	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
,	O
y	int
<<=	O
1	int
)	O
if	O
(	O
(	O
y	int
-=	O
c	array(int)
[	O
j	int
]	O
)	O
<	O
0	int
)	O
return	O
2	int
;	O
if	O
(	O
(	O
y	int
-=	O
c	array(int)
[	O
i	int
]	O
)	O
<	O
0	int
)	O
return	O
2	int
;	O
c	array(int)
[	O
i	int
]	O
+=	O
y	int
;	O
x	array(int)
[	O
1	int
]	O
=	O
j	int
=	O
0	int
;	O
p	*(int)
=	O
c	array(int)
+	O
1	int
;	O
xp	*(int)
=	O
x	array(int)
+	O
2	int
;	O
while	O
(	O
--	O
i	int
)	O
{	O
*	O
xp	*(int)
++	O
=	O
(	O
j	int
+=	O
*	O
p	*(int)
++	O
)	O
;	O
}	O
p	*(int)
=	O
b	char
;	O
i	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
(	O
j	int
=	O
*	O
p	*(int)
++	O
)	O
!=	O
0	int
)	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
[	O
x	array(int)
[	O
j	int
]	O
++	O
]	O
=	O
i	int
;	O
}	O
while	O
(	O
++	O
i	int
<	O
n	int
)	O
;	O
n	int
=	O
x	array(int)
[	O
g	int
]	O
;	O
x	array(int)
[	O
0	int
]	O
=	O
i	int
=	O
0	int
;	O
p	*(int)
=	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
;	O
h	int
=	O
-	O
1	int
;	O
w	int
=	O
-	O
l	int
;	O
u	array(*(struct(char,char,union(short,*(struct(char,char,union`))))))
[	O
0	int
]	O
=	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
NULL	O
;	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
=	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
NULL	O
;	O
z	int
=	O
0	int
;	O
for	O
(	O
;	O
k	int
<=	O
g	int
;	O
k	int
++	O
)	O
{	O
a	int
=	O
c	array(int)
[	O
k	int
]	O
;	O
while	O
(	O
a	int
--	O
)	O
{	O
while	O
(	O
k	int
>	O
w	int
+	O
l	int
)	O
{	O
h	int
++	O
;	O
w	int
+=	O
l	int
;	O
z	int
=	O
(	O
z	int
=	O
g	int
-	O
w	int
)	O
>	O
(	O
unsigned	O
)	O
l	int
?	O
l	int
:	O
z	int
;	O
if	O
(	O
(	O
f	int
=	O
1	int
<<	O
(	O
j	int
=	O
k	int
-	O
w	int
)	O
)	O
>	O
a	int
+	O
1	int
)	O
{	O
f	int
-=	O
a	int
+	O
1	int
;	O
xp	*(int)
=	O
c	array(int)
+	O
k	int
;	O
if	O
(	O
j	int
<	O
z	int
)	O
while	O
(	O
++	O
j	int
<	O
z	int
)	O
{	O
if	O
(	O
(	O
f	int
<<=	O
1	int
)	O
<=	O
*	O
++	O
xp	*(int)
)	O
break	O
;	O
f	int
-=	O
*	O
xp	*(int)
;	O
}	O
}	O
z	int
=	O
1	int
<<	O
j	int
;	O
if	O
(	O
(	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
=	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
malloc	(long)->(*(void))
(	O
(	O
z	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
)	O
)	O
)	O
==	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
h	int
)	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
u	array(*(struct(char,char,union(short,*(struct(char,char,union`))))))
[	O
0	int
]	O
)	O
;	O
return	O
3	int
;	O
}	O
hufts	int
+=	O
z	int
+	O
1	int
;	O
*	O
t	*(struct(char,char))
=	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
+	O
1	int
;	O
*	O
(	O
t	*(struct(char,char))
=	O
&	O
(	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
->	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
t	*(struct(char,char))
)	O
)	O
=	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
NULL	O
;	O
u	array(*(struct(char,char,union(short,*(struct(char,char,union`))))))
[	O
h	int
]	O
=	O
++	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
if	O
(	O
h	int
)	O
{	O
x	array(int)
[	O
h	int
]	O
=	O
i	int
;	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
b	char
=	O
(	O
uch	char
)	O
l	int
;	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
e	char
=	O
(	O
uch	char
)	O
(	O
16	int
+	O
j	int
)	O
;	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
t	*(struct(char,char))
=	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
j	int
=	O
i	int
>>	O
(	O
w	int
-	O
l	int
)	O
;	O
u	array(*(struct(char,char,union(short,*(struct(char,char,union`))))))
[	O
h	int
-	O
1	int
]	O
[	O
j	int
]	O
=	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
;	O
}	O
}	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
b	char
=	O
(	O
uch	char
)	O
(	O
k	int
-	O
w	int
)	O
;	O
if	O
(	O
p	*(int)
>=	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
+	O
n	int
)	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
e	char
=	O
99	int
;	O
else	O
if	O
(	O
*	O
p	*(int)
<	O
s	*(char)
)	O
{	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
e	char
=	O
(	O
uch	char
)	O
(	O
*	O
p	*(int)
<	O
256	int
?	O
16	int
:	O
15	int
)	O
;	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
n	int
=	O
(	O
ush	short
)	O
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
}	O
else	O
{	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
e	char
=	O
(	O
uch	char
)	O
e	char
[	O
*	O
p	*(int)
-	O
s	*(char)
]	O
;	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
.	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
n	int
=	O
d	*(short)
[	O
*	O
p	*(int)
++	O
-	O
s	*(char)
]	O
;	O
}	O
f	int
=	O
1	int
<<	O
(	O
k	int
-	O
w	int
)	O
;	O
for	O
(	O
j	int
=	O
i	int
>>	O
w	int
;	O
j	int
<	O
z	int
;	O
j	int
+=	O
f	int
)	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
[	O
j	int
]	O
=	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
;	O
for	O
(	O
j	int
=	O
1	int
<<	O
(	O
k	int
-	O
1	int
)	O
;	O
i	int
&	O
j	int
;	O
j	int
>>=	O
1	int
)	O
i	int
^=	O
j	int
;	O
i	int
^=	O
j	int
;	O
while	O
(	O
(	O
i	int
&	O
(	O
(	O
1	int
<<	O
w	int
)	O
-	O
1	int
)	O
)	O
!=	O
x	array(int)
[	O
h	int
]	O
)	O
{	O
h	int
--	O
;	O
w	int
-=	O
l	int
;	O
}	O
}	O
}	O
return	O
y	int
!=	O
0	int
&&	O
g	int
!=	O
1	int
;	O
}	O
static	O
int	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
t	*(struct(char,char))
)	O
{	O
register	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
p	*(int)
,	O
*	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
p	*(int)
=	O
t	*(struct(char,char))
;	O
while	O
(	O
p	*(int)
!=	O
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
)	O
NULL	O
)	O
{	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
=	O
(	O
--	O
p	*(int)
)	O
->	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
t	*(struct(char,char))
;	O
free	(*(void))->(void)
(	O
p	*(int)
)	O
;	O
p	*(int)
=	O
q	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
inflate_codes	(*(struct(char,char,union(short,*(struct`)))),*(struct(char,char,union(short,*(struct`)))),int,int)->(int)
(	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
int	O
bl	int
,	O
int	O
bd	int
)	O
{	O
register	O
unsigned	O
e	char
;	O
unsigned	O
n	int
,	O
d	*(short)
;	O
unsigned	O
w	int
;	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
t	*(struct(char,char))
;	O
unsigned	O
ml	int
,	O
md	int
;	O
register	O
ulg	long
b	char
;	O
register	O
unsigned	O
k	int
;	O
b	char
=	O
bb	long
;	O
k	int
=	O
bk	int
;	O
w	int
=	O
wp	O
;	O
ml	int
=	O
mask_bits	array(short)
[	O
bl	int
]	O
;	O
md	int
=	O
mask_bits	array(short)
[	O
bd	int
]	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
NEEDBITS	O
(	O
(	O
unsigned	O
)	O
bl	int
)	O
if	O
(	O
(	O
e	char
=	O
(	O
t	*(struct(char,char))
=	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
ml	int
)	O
)	O
->	O
e	char
)	O
>	O
16	int
)	O
do	O
{	O
if	O
(	O
e	char
==	O
99	int
)	O
return	O
1	int
;	O
DUMPBITS	O
(	O
t	*(struct(char,char))
->	O
b	char
)	O
e	char
-=	O
16	int
;	O
NEEDBITS	O
(	O
e	char
)	O
}	O
while	O
(	O
(	O
e	char
=	O
(	O
t	*(struct(char,char))
=	O
t	*(struct(char,char))
->	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
t	*(struct(char,char))
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
mask_bits	array(short)
[	O
e	char
]	O
)	O
)	O
->	O
e	char
)	O
>	O
16	int
)	O
;	O
DUMPBITS	O
(	O
t	*(struct(char,char))
->	O
b	char
)	O
if	O
(	O
e	char
==	O
16	int
)	O
{	O
slide	O
[	O
w	int
++	O
]	O
=	O
(	O
uch	char
)	O
t	*(struct(char,char))
->	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
n	int
;	O
Tracevv	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c"	*(char)
,	O
slide	O
[	O
w	int
-	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
w	int
==	O
WSIZE	int
)	O
{	O
flush_output	O
(	O
w	int
)	O
;	O
w	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
e	char
==	O
15	int
)	O
break	O
;	O
NEEDBITS	O
(	O
e	char
)	O
n	int
=	O
t	*(struct(char,char))
->	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
n	int
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
mask_bits	array(short)
[	O
e	char
]	O
)	O
;	O
DUMPBITS	O
(	O
e	char
)	O
;	O
NEEDBITS	O
(	O
(	O
unsigned	O
)	O
bd	int
)	O
if	O
(	O
(	O
e	char
=	O
(	O
t	*(struct(char,char))
=	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
md	int
)	O
)	O
->	O
e	char
)	O
>	O
16	int
)	O
do	O
{	O
if	O
(	O
e	char
==	O
99	int
)	O
return	O
1	int
;	O
DUMPBITS	O
(	O
t	*(struct(char,char))
->	O
b	char
)	O
e	char
-=	O
16	int
;	O
NEEDBITS	O
(	O
e	char
)	O
}	O
while	O
(	O
(	O
e	char
=	O
(	O
t	*(struct(char,char))
=	O
t	*(struct(char,char))
->	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
t	*(struct(char,char))
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
mask_bits	array(short)
[	O
e	char
]	O
)	O
)	O
->	O
e	char
)	O
>	O
16	int
)	O
;	O
DUMPBITS	O
(	O
t	*(struct(char,char))
->	O
b	char
)	O
NEEDBITS	O
(	O
e	char
)	O
d	*(short)
=	O
w	int
-	O
t	*(struct(char,char))
->	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
n	int
-	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
mask_bits	array(short)
[	O
e	char
]	O
)	O
;	O
DUMPBITS	O
(	O
e	char
)	O
Tracevv	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\\[%d,%d]"	*(char)
,	O
w	int
-	O
d	*(short)
,	O
n	int
)	O
)	O
;	O
do	O
{	O
n	int
-=	O
(	O
e	char
=	O
(	O
e	char
=	O
WSIZE	int
-	O
(	O
(	O
d	*(short)
&=	O
WSIZE	int
-	O
1	int
)	O
>	O
w	int
?	O
d	*(short)
:	O
w	int
)	O
)	O
>	O
n	int
?	O
n	int
:	O
e	char
)	O
;	O
if	O
(	O
e	char
<=	O
(	O
d	*(short)
<	O
w	int
?	O
w	int
-	O
d	*(short)
:	O
d	*(short)
-	O
w	int
)	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
slide	O
+	O
w	int
,	O
slide	O
+	O
d	*(short)
,	O
e	char
)	O
;	O
w	int
+=	O
e	char
;	O
d	*(short)
+=	O
e	char
;	O
}	O
else	O
do	O
{	O
slide	O
[	O
w	int
++	O
]	O
=	O
slide	O
[	O
d	*(short)
++	O
]	O
;	O
Tracevv	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c"	*(char)
,	O
slide	O
[	O
w	int
-	O
1	int
]	O
)	O
)	O
;	O
}	O
while	O
(	O
--	O
e	char
)	O
;	O
if	O
(	O
w	int
==	O
WSIZE	int
)	O
{	O
flush_output	O
(	O
w	int
)	O
;	O
w	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
n	int
)	O
;	O
}	O
}	O
wp	O
=	O
w	int
;	O
bb	long
=	O
b	char
;	O
bk	int
=	O
k	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
inflate_stored	()->(int)
(	O
void	O
)	O
{	O
unsigned	O
n	int
;	O
unsigned	O
w	int
;	O
register	O
ulg	long
b	char
;	O
register	O
unsigned	O
k	int
;	O
b	char
=	O
bb	long
;	O
k	int
=	O
bk	int
;	O
w	int
=	O
wp	O
;	O
n	int
=	O
k	int
&	O
7	int
;	O
DUMPBITS	O
(	O
n	int
)	O
;	O
NEEDBITS	O
(	O
16	int
)	O
n	int
=	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
0xffff	int
)	O
;	O
DUMPBITS	O
(	O
16	int
)	O
NEEDBITS	O
(	O
16	int
)	O
if	O
(	O
n	int
!=	O
(	O
unsigned	O
)	O
(	O
(	O
~	O
b	char
)	O
&	O
0xffff	int
)	O
)	O
return	O
1	int
;	O
DUMPBITS	O
(	O
16	int
)	O
while	O
(	O
n	int
--	O
)	O
{	O
NEEDBITS	O
(	O
8	int
)	O
slide	O
[	O
w	int
++	O
]	O
=	O
(	O
uch	char
)	O
b	char
;	O
if	O
(	O
w	int
==	O
WSIZE	int
)	O
{	O
flush_output	O
(	O
w	int
)	O
;	O
w	int
=	O
0	int
;	O
}	O
DUMPBITS	O
(	O
8	int
)	O
}	O
wp	O
=	O
w	int
;	O
bb	long
=	O
b	char
;	O
bk	int
=	O
k	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
inflate_fixed	()->(int)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
int	O
bl	int
;	O
int	O
bd	int
;	O
unsigned	O
l	int
[	O
288	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
144	int
;	O
i	int
++	O
)	O
l	int
[	O
i	int
]	O
=	O
8	int
;	O
for	O
(	O
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
l	int
[	O
i	int
]	O
=	O
9	int
;	O
for	O
(	O
;	O
i	int
<	O
280	int
;	O
i	int
++	O
)	O
l	int
[	O
i	int
]	O
=	O
7	int
;	O
for	O
(	O
;	O
i	int
<	O
288	int
;	O
i	int
++	O
)	O
l	int
[	O
i	int
]	O
=	O
8	int
;	O
bl	int
=	O
7	int
;	O
if	O
(	O
(	O
i	int
=	O
huft_build	(*(int),int,int,*(short),*(short),*(*(struct(char,char,union(short,*`)))),*(int))->(int)
(	O
l	int
,	O
288	int
,	O
257	int
,	O
cplens	array(short)
,	O
cplext	array(short)
,	O
&	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
&	O
bl	int
)	O
)	O
!=	O
0	int
)	O
return	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
30	int
;	O
i	int
++	O
)	O
l	int
[	O
i	int
]	O
=	O
5	int
;	O
bd	int
=	O
5	int
;	O
if	O
(	O
(	O
i	int
=	O
huft_build	(*(int),int,int,*(short),*(short),*(*(struct(char,char,union(short,*`)))),*(int))->(int)
(	O
l	int
,	O
30	int
,	O
0	int
,	O
cpdist	array(short)
,	O
cpdext	array(short)
,	O
&	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
&	O
bd	int
)	O
)	O
>	O
1	int
)	O
{	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
inflate_codes	(*(struct(char,char,union(short,*(struct`)))),*(struct(char,char,union(short,*(struct`)))),int,int)->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
bl	int
,	O
bd	int
)	O
)	O
return	O
1	int
;	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
inflate_dynamic	()->(int)
(	O
void	O
)	O
{	O
int	O
i	int
;	O
unsigned	O
j	int
;	O
unsigned	O
l	int
;	O
unsigned	O
m	*(char)
;	O
unsigned	O
n	int
;	O
unsigned	O
w	int
;	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
struct	O
huft	struct(char,char,union(short,*(struct(char,char,union(short,*(struct`))))))
*	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
;	O
int	O
bl	int
;	O
int	O
bd	int
;	O
unsigned	O
nb	int
;	O
unsigned	O
nl	int
;	O
unsigned	O
nd	int
;	O
unsigned	O
ll	array(int)
[	O
286	int
+	O
30	int
]	O
;	O
register	O
ulg	long
b	char
;	O
register	O
unsigned	O
k	int
;	O
b	char
=	O
bb	long
;	O
k	int
=	O
bk	int
;	O
w	int
=	O
wp	O
;	O
NEEDBITS	O
(	O
5	int
)	O
nl	int
=	O
257	int
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
0x1f	int
)	O
;	O
DUMPBITS	O
(	O
5	int
)	O
NEEDBITS	O
(	O
5	int
)	O
nd	int
=	O
1	int
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
0x1f	int
)	O
;	O
DUMPBITS	O
(	O
5	int
)	O
NEEDBITS	O
(	O
4	int
)	O
nb	int
=	O
4	int
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
0xf	int
)	O
;	O
DUMPBITS	O
(	O
4	int
)	O
if	O
(	O
nl	int
>	O
286	int
||	O
nd	int
>	O
30	int
)	O
return	O
1	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nb	int
;	O
j	int
++	O
)	O
{	O
NEEDBITS	O
(	O
3	int
)	O
ll	array(int)
[	O
border	array(int)
[	O
j	int
]	O
]	O
=	O
(	O
unsigned	O
)	O
b	char
&	O
7	int
;	O
DUMPBITS	O
(	O
3	int
)	O
}	O
for	O
(	O
;	O
j	int
<	O
19	int
;	O
j	int
++	O
)	O
ll	array(int)
[	O
border	array(int)
[	O
j	int
]	O
]	O
=	O
0	int
;	O
bl	int
=	O
7	int
;	O
if	O
(	O
(	O
i	int
=	O
huft_build	(*(int),int,int,*(short),*(short),*(*(struct(char,char,union(short,*`)))),*(int))->(int)
(	O
ll	array(int)
,	O
19	int
,	O
19	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
&	O
bl	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
i	int
==	O
1	int
)	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
return	O
i	int
;	O
}	O
if	O
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
==	O
NULL	O
)	O
return	O
2	int
;	O
n	int
=	O
nl	int
+	O
nd	int
;	O
m	*(char)
=	O
mask_bits	array(short)
[	O
bl	int
]	O
;	O
i	int
=	O
l	int
=	O
0	int
;	O
while	O
(	O
(	O
unsigned	O
)	O
i	int
<	O
n	int
)	O
{	O
NEEDBITS	O
(	O
(	O
unsigned	O
)	O
bl	int
)	O
j	int
=	O
(	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
=	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
m	*(char)
)	O
)	O
->	O
b	char
;	O
DUMPBITS	O
(	O
j	int
)	O
if	O
(	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
->	O
e	char
==	O
99	int
)	O
{	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
return	O
2	int
;	O
}	O
j	int
=	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
->	O
v	union(short,*(struct(char,char,union(short,*(struct`)))))
.	O
n	int
;	O
if	O
(	O
j	int
<	O
16	int
)	O
ll	array(int)
[	O
i	int
++	O
]	O
=	O
l	int
=	O
j	int
;	O
else	O
if	O
(	O
j	int
==	O
16	int
)	O
{	O
NEEDBITS	O
(	O
2	int
)	O
j	int
=	O
3	int
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
3	int
)	O
;	O
DUMPBITS	O
(	O
2	int
)	O
if	O
(	O
(	O
unsigned	O
)	O
i	int
+	O
j	int
>	O
n	int
)	O
return	O
1	int
;	O
while	O
(	O
j	int
--	O
)	O
ll	array(int)
[	O
i	int
++	O
]	O
=	O
l	int
;	O
}	O
else	O
if	O
(	O
j	int
==	O
17	int
)	O
{	O
NEEDBITS	O
(	O
3	int
)	O
j	int
=	O
3	int
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
7	int
)	O
;	O
DUMPBITS	O
(	O
3	int
)	O
if	O
(	O
(	O
unsigned	O
)	O
i	int
+	O
j	int
>	O
n	int
)	O
return	O
1	int
;	O
while	O
(	O
j	int
--	O
)	O
ll	array(int)
[	O
i	int
++	O
]	O
=	O
0	int
;	O
l	int
=	O
0	int
;	O
}	O
else	O
{	O
NEEDBITS	O
(	O
7	int
)	O
j	int
=	O
11	int
+	O
(	O
(	O
unsigned	O
)	O
b	char
&	O
0x7f	int
)	O
;	O
DUMPBITS	O
(	O
7	int
)	O
if	O
(	O
(	O
unsigned	O
)	O
i	int
+	O
j	int
>	O
n	int
)	O
return	O
1	int
;	O
while	O
(	O
j	int
--	O
)	O
ll	array(int)
[	O
i	int
++	O
]	O
=	O
0	int
;	O
l	int
=	O
0	int
;	O
}	O
}	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
bb	long
=	O
b	char
;	O
bk	int
=	O
k	int
;	O
bl	int
=	O
lbits	int
;	O
if	O
(	O
(	O
i	int
=	O
huft_build	(*(int),int,int,*(short),*(short),*(*(struct(char,char,union(short,*`)))),*(int))->(int)
(	O
ll	array(int)
,	O
nl	int
,	O
257	int
,	O
cplens	array(short)
,	O
cplext	array(short)
,	O
&	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
&	O
bl	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
i	int
==	O
1	int
)	O
{	O
Trace	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" incomplete literal tree\n"	*(char)
)	O
)	O
;	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
}	O
return	O
i	int
;	O
}	O
bd	int
=	O
dbits	int
;	O
if	O
(	O
(	O
i	int
=	O
huft_build	(*(int),int,int,*(short),*(short),*(*(struct(char,char,union(short,*`)))),*(int))->(int)
(	O
ll	array(int)
+	O
nl	int
,	O
nd	int
,	O
0	int
,	O
cpdist	array(short)
,	O
cpdext	array(short)
,	O
&	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
&	O
bd	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
i	int
==	O
1	int
)	O
{	O
Trace	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" incomplete distance tree\n"	*(char)
)	O
)	O
;	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
}	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
return	O
i	int
;	O
}	O
{	O
int	O
err	int
=	O
inflate_codes	(*(struct(char,char,union(short,*(struct`)))),*(struct(char,char,union(short,*(struct`)))),int,int)->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
,	O
bl	int
,	O
bd	int
)	O
?	O
1	int
:	O
0	int
;	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
tl	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
huft_free	(*(struct(char,char,union(short,*(struct`)))))->(int)
(	O
td	*(struct(char,char,union(short,*(struct(char,char,union`)))))
)	O
;	O
return	O
err	int
;	O
}	O
}	O
static	O
int	O
inflate_block	(*(int))->(int)
(	O
int	O
*	O
e	char
)	O
{	O
unsigned	O
t	*(struct(char,char))
;	O
unsigned	O
w	int
;	O
register	O
ulg	long
b	char
;	O
register	O
unsigned	O
k	int
;	O
b	char
=	O
bb	long
;	O
k	int
=	O
bk	int
;	O
w	int
=	O
wp	O
;	O
NEEDBITS	O
(	O
1	int
)	O
*	O
e	char
=	O
(	O
int	O
)	O
b	char
&	O
1	int
;	O
DUMPBITS	O
(	O
1	int
)	O
NEEDBITS	O
(	O
2	int
)	O
t	*(struct(char,char))
=	O
(	O
unsigned	O
)	O
b	char
&	O
3	int
;	O
DUMPBITS	O
(	O
2	int
)	O
bb	long
=	O
b	char
;	O
bk	int
=	O
k	int
;	O
if	O
(	O
t	*(struct(char,char))
==	O
2	int
)	O
return	O
inflate_dynamic	()->(int)
(	O
)	O
;	O
if	O
(	O
t	*(struct(char,char))
==	O
0	int
)	O
return	O
inflate_stored	()->(int)
(	O
)	O
;	O
if	O
(	O
t	*(struct(char,char))
==	O
1	int
)	O
return	O
inflate_fixed	()->(int)
(	O
)	O
;	O
return	O
2	int
;	O
}	O
int	O
inflate	()->(int)
(	O
void	O
)	O
{	O
int	O
e	char
;	O
int	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
;	O
unsigned	O
h	int
;	O
wp	O
=	O
0	int
;	O
bk	int
=	O
0	int
;	O
bb	long
=	O
0	int
;	O
h	int
=	O
0	int
;	O
do	O
{	O
hufts	int
=	O
0	int
;	O
if	O
(	O
(	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
=	O
inflate_block	(*(int))->(int)
(	O
&	O
e	char
)	O
)	O
!=	O
0	int
)	O
return	O
r	struct(char,char,union(short,*(struct(char,char,union(short,*`)))))
;	O
if	O
(	O
hufts	int
>	O
h	int
)	O
h	int
=	O
hufts	int
;	O
}	O
while	O
(	O
!	O
e	char
)	O
;	O
while	O
(	O
bk	int
>=	O
8	int
)	O
{	O
bk	int
-=	O
8	int
;	O
inptr	int
--	O
;	O
}	O
flush_output	O
(	O
wp	O
)	O
;	O
Trace	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"<%u> "	*(char)
,	O
h	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
