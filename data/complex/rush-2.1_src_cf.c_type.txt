void	O
stringbuf_init	O
(	O
struct	O
stringbuf	O
*	O
sb	O
)	O
{	O
sb	O
->	O
buffer	*(struct)
=	O
NULL	O
;	O
sb	O
->	O
size	long
=	O
0	int
;	O
sb	O
->	O
pos	O
=	O
0	int
;	O
}	O
void	O
stringbuf_free	O
(	O
struct	O
stringbuf	O
*	O
sb	O
)	O
{	O
free	(*(void))->(void)
(	O
sb	O
->	O
buffer	*(struct)
)	O
;	O
stringbuf_init	O
(	O
sb	O
)	O
;	O
}	O
void	O
stringbuf_add_char	O
(	O
struct	O
stringbuf	O
*	O
sb	O
,	O
int	O
c	int
)	O
{	O
if	O
(	O
sb	O
->	O
pos	O
+	O
1	int
>	O
sb	O
->	O
size	long
)	O
sb	O
->	O
buffer	*(struct)
=	O
x2realloc	(*(void),*(long))->(*(void))
(	O
sb	O
->	O
buffer	*(struct)
,	O
&	O
sb	O
->	O
size	long
)	O
;	O
sb	O
->	O
buffer	*(struct)
[	O
sb	O
->	O
pos	O
++	O
]	O
=	O
c	int
;	O
}	O
void	O
stringbuf_add_array	O
(	O
struct	O
stringbuf	O
*	O
sb	O
,	O
char	O
const	O
*	O
str	*(char)
,	O
size_t	long
len	long
)	O
{	O
while	O
(	O
sb	O
->	O
pos	O
+	O
len	long
>	O
sb	O
->	O
size	long
)	O
sb	O
->	O
buffer	*(struct)
=	O
x2realloc	(*(void),*(long))->(*(void))
(	O
sb	O
->	O
buffer	*(struct)
,	O
&	O
sb	O
->	O
size	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
sb	O
->	O
buffer	*(struct)
+	O
sb	O
->	O
pos	O
,	O
str	*(char)
,	O
len	long
)	O
;	O
sb	O
->	O
pos	O
+=	O
len	long
;	O
}	O
void	O
stringbuf_add_string	O
(	O
struct	O
stringbuf	O
*	O
sb	O
,	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
stringbuf_add_array	O
(	O
sb	O
,	O
str	*(char)
,	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
)	O
;	O
}	O
void	O
stringbuf_add_num	O
(	O
struct	O
stringbuf	O
*	O
sb	O
,	O
unsigned	O
n	long
)	O
{	O
size_t	long
i	O
=	O
sb	O
->	O
pos	O
,	O
j	O
;	O
do	O
{	O
static	O
char	O
dig	O
[	O
]	O
=	O
"0123456789"	*(char)
;	O
stringbuf_add_char	O
(	O
sb	O
,	O
dig	O
[	O
n	long
%	O
10	int
]	O
)	O
;	O
n	long
/=	O
10	int
;	O
}	O
while	O
(	O
n	long
>	O
0	int
)	O
;	O
for	O
(	O
j	O
=	O
sb	O
->	O
pos	O
-	O
1	int
;	O
j	O
>	O
i	O
;	O
i	O
++	O
,	O
j	O
--	O
)	O
{	O
char	O
c	int
=	O
sb	O
->	O
buffer	*(struct)
[	O
i	O
]	O
;	O
sb	O
->	O
buffer	*(struct)
[	O
i	O
]	O
=	O
sb	O
->	O
buffer	*(struct)
[	O
j	O
]	O
;	O
sb	O
->	O
buffer	*(struct)
[	O
j	O
]	O
=	O
c	int
;	O
}	O
}	O
void	O
stringbuf_finish	O
(	O
struct	O
stringbuf	O
*	O
sb	O
)	O
{	O
stringbuf_add_char	O
(	O
sb	O
,	O
0	int
)	O
;	O
}	O
void	O
cfpoint_format	O
(	O
struct	O
cfpoint	O
const	O
*	O
cfp	O
,	O
struct	O
stringbuf	O
*	O
sb	O
)	O
{	O
if	O
(	O
cfp	O
->	O
filename	O
)	O
{	O
stringbuf_add_string	O
(	O
sb	O
,	O
cfp	O
->	O
filename	O
)	O
;	O
stringbuf_add_char	O
(	O
sb	O
,	O
':'	O
)	O
;	O
stringbuf_add_num	O
(	O
sb	O
,	O
cfp	O
->	O
line	O
)	O
;	O
if	O
(	O
cfp	O
->	O
column	O
)	O
{	O
stringbuf_add_char	O
(	O
sb	O
,	O
'.'	O
)	O
;	O
stringbuf_add_num	O
(	O
sb	O
,	O
cfp	O
->	O
column	O
)	O
;	O
}	O
}	O
}	O
void	O
cfloc_format	O
(	O
struct	O
cfloc	O
const	O
*	O
cfl	O
,	O
struct	O
stringbuf	O
*	O
sb	O
)	O
{	O
cfpoint_format	O
(	O
&	O
cfl	O
->	O
beg	O
,	O
sb	O
)	O
;	O
if	O
(	O
cfl	O
->	O
end	*(long)
.	O
filename	O
)	O
{	O
if	O
(	O
cfl	O
->	O
beg	O
.	O
filename	O
!=	O
cfl	O
->	O
end	*(long)
.	O
filename	O
)	O
{	O
stringbuf_add_char	O
(	O
sb	O
,	O
'-'	O
)	O
;	O
cfpoint_format	O
(	O
&	O
cfl	O
->	O
end	*(long)
,	O
sb	O
)	O
;	O
}	O
else	O
if	O
(	O
cfl	O
->	O
beg	O
.	O
line	O
!=	O
cfl	O
->	O
end	*(long)
.	O
line	O
)	O
{	O
stringbuf_add_char	O
(	O
sb	O
,	O
'-'	O
)	O
;	O
stringbuf_add_num	O
(	O
sb	O
,	O
cfl	O
->	O
end	*(long)
.	O
line	O
)	O
;	O
if	O
(	O
cfl	O
->	O
end	*(long)
.	O
column	O
)	O
{	O
stringbuf_add_char	O
(	O
sb	O
,	O
'.'	O
)	O
;	O
stringbuf_add_num	O
(	O
sb	O
,	O
cfl	O
->	O
end	*(long)
.	O
column	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
cfl	O
->	O
beg	O
.	O
column	O
&&	O
cfl	O
->	O
beg	O
.	O
column	O
!=	O
cfl	O
->	O
end	*(long)
.	O
column	O
)	O
{	O
stringbuf_add_char	O
(	O
sb	O
,	O
'-'	O
)	O
;	O
stringbuf_add_num	O
(	O
sb	O
,	O
cfl	O
->	O
end	*(long)
.	O
column	O
)	O
;	O
}	O
}	O
}	O
void	O
cfloc_print	O
(	O
struct	O
cfloc	O
const	O
*	O
cfl	O
,	O
FILE	struct
*	O
fp	O
)	O
{	O
struct	O
stringbuf	O
sb	O
;	O
stringbuf_init	O
(	O
&	O
sb	O
)	O
;	O
cfloc_format	O
(	O
cfl	O
,	O
&	O
sb	O
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
sb	O
.	O
buffer	*(struct)
,	O
sb	O
.	O
pos	O
,	O
1	int
,	O
fp	O
)	O
;	O
stringbuf_free	O
(	O
&	O
sb	O
)	O
;	O
}	O
void	O
vcferror	O
(	O
struct	O
cfloc	O
const	O
*	O
loc	O
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
)	O
{	O
struct	O
stringbuf	O
sb	O
;	O
stringbuf_init	O
(	O
&	O
sb	O
)	O
;	O
cfloc_format	O
(	O
loc	O
,	O
&	O
sb	O
)	O
;	O
stringbuf_add_array	O
(	O
&	O
sb	O
,	O
": "	*(char)
,	O
2	int
)	O
;	O
stringbuf_add_string	O
(	O
&	O
sb	O
,	O
fmt	*(char)
)	O
;	O
stringbuf_finish	O
(	O
&	O
sb	O
)	O
;	O
vlogmsg	O
(	O
LOG_ERR	O
,	O
sb	O
.	O
buffer	*(struct)
,	O
ap	O
)	O
;	O
stringbuf_free	O
(	O
&	O
sb	O
)	O
;	O
}	O
void	O
cferror	O
(	O
struct	O
cfloc	O
const	O
*	O
loc	O
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	O
;	O
va_start	O
(	O
ap	O
,	O
fmt	*(char)
)	O
;	O
vcferror	O
(	O
loc	O
,	O
fmt	*(char)
,	O
ap	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
struct	O
cfstream_file	O
{	O
CFSTREAM	O
base	O
;	O
FILE	struct
*	O
fp	O
;	O
}	O
;	O
static	O
CFSTREAM	O
*	O
cfstream_create	O
(	O
int	O
fd	int
,	O
size_t	long
bs	O
)	O
{	O
CFSTREAM	O
*	O
cf	O
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
cf	O
)	O
)	O
;	O
cf	O
->	O
fd	int
=	O
fd	int
;	O
cf	O
->	O
buffer	*(struct)
=	O
xmalloc	(long)->(*(void))
(	O
bs	O
)	O
;	O
cf	O
->	O
size	long
=	O
bs	O
;	O
cf	O
->	O
level	O
=	O
0	int
;	O
cf	O
->	O
pos	O
=	O
0	int
;	O
cf	O
->	O
eol	O
=	O
0	int
;	O
cf	O
->	O
eof	O
=	O
0	int
;	O
return	O
cf	O
;	O
}	O
CFSTREAM	O
*	O
cfstream_open_file	O
(	O
char	O
const	O
*	O
filename	O
)	O
{	O
int	O
fd	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
filename	O
,	O
&	O
st	O
)	O
)	O
{	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"cannot stat file %s: %s"	*(char)
)	O
,	O
filename	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
check_config_permissions	O
(	O
filename	O
,	O
&	O
st	O
)	O
)	O
die	O
(	O
config_error	int
,	O
NULL	O
,	O
_	O
(	O
"%s: file is not safe"	*(char)
)	O
,	O
filename	O
)	O
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
filename	O
,	O
O_RDONLY	O
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
_	O
(	O
"cannot open file %s: %s"	*(char)
)	O
,	O
filename	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
cfstream_create	O
(	O
fd	int
,	O
CFSTREAM_BUFSIZE	O
)	O
;	O
}	O
CFSTREAM	O
*	O
cfstream_open_stdin	O
(	O
void	O
)	O
{	O
return	O
cfstream_create	O
(	O
0	int
,	O
CFSTREAM_BUFSIZE	O
)	O
;	O
}	O
CFSTREAM	O
*	O
cfstream_open_mem	O
(	O
char	O
const	O
*	O
buffer	*(struct)
,	O
size_t	long
len	long
)	O
{	O
CFSTREAM	O
*	O
cf	O
=	O
cfstream_create	O
(	O
-	O
1	int
,	O
len	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
cf	O
->	O
buffer	*(struct)
,	O
buffer	*(struct)
,	O
len	long
)	O
;	O
cf	O
->	O
size	long
=	O
len	long
;	O
cf	O
->	O
level	O
=	O
len	long
;	O
return	O
cf	O
;	O
}	O
void	O
cfstream_close	O
(	O
CFSTREAM	O
*	O
cf	O
)	O
{	O
if	O
(	O
cf	O
->	O
fd	int
!=	O
-	O
1	int
)	O
close	*((*(void))->(int))
(	O
cf	O
->	O
fd	int
)	O
;	O
free	(*(void))->(void)
(	O
cf	O
->	O
buffer	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
cf	O
)	O
;	O
}	O
void	O
cfstream_rewind	O
(	O
CFSTREAM	O
*	O
cf	O
)	O
{	O
if	O
(	O
cf	O
->	O
fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
lseek	(int,long,int)->(long)
(	O
cf	O
->	O
fd	int
,	O
0	int
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
"lseek: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
cf	O
->	O
level	O
=	O
0	int
;	O
}	O
else	O
cf	O
->	O
level	O
=	O
cf	O
->	O
size	long
;	O
cf	O
->	O
pos	O
=	O
0	int
;	O
cf	O
->	O
eol	O
=	O
0	int
;	O
cf	O
->	O
eof	O
=	O
0	int
;	O
}	O
static	O
inline	O
size_t	long
cfstream_buf_avail	O
(	O
CFSTREAM	O
*	O
cf	O
)	O
{	O
return	O
cf	O
->	O
level	O
-	O
cf	O
->	O
pos	O
;	O
}	O
static	O
size_t	long
cfstream_avail	O
(	O
CFSTREAM	O
*	O
cf	O
)	O
{	O
size_t	long
avail	O
=	O
cfstream_buf_avail	O
(	O
cf	O
)	O
;	O
if	O
(	O
avail	O
==	O
0	int
)	O
{	O
if	O
(	O
cf	O
->	O
eof	O
||	O
cf	O
->	O
fd	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
else	O
{	O
ssize_t	long
rc	O
;	O
rc	O
=	O
read	*((*(void),*(char),long)->(long))
(	O
cf	O
->	O
fd	int
,	O
cf	O
->	O
buffer	*(struct)
,	O
cf	O
->	O
size	long
)	O
;	O
if	O
(	O
rc	O
==	O
-	O
1	int
)	O
die	O
(	O
system_error	int
,	O
NULL	O
,	O
"read: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
cf	O
->	O
level	O
=	O
rc	O
;	O
cf	O
->	O
pos	O
=	O
0	int
;	O
if	O
(	O
rc	O
==	O
0	int
)	O
{	O
cf	O
->	O
eof	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
avail	O
=	O
cfstream_buf_avail	O
(	O
cf	O
)	O
;	O
}	O
}	O
return	O
avail	O
;	O
}	O
static	O
inline	O
char	O
const	O
*	O
cfstream_buf_ptr	O
(	O
CFSTREAM	O
*	O
cf	O
)	O
{	O
return	O
cf	O
->	O
buffer	*(struct)
+	O
cf	O
->	O
pos	O
;	O
}	O
static	O
inline	O
void	O
cfstream_buf_advance	O
(	O
CFSTREAM	O
*	O
cf	O
,	O
size_t	long
n	long
)	O
{	O
cf	O
->	O
pos	O
+=	O
n	long
;	O
}	O
ssize_t	long
cfstream_read	O
(	O
CFSTREAM	O
*	O
cf	O
,	O
char	O
*	O
bufptr	O
,	O
size_t	long
bufsize	O
)	O
{	O
size_t	long
nrd	O
=	O
0	int
;	O
if	O
(	O
!	O
cf	O
)	O
return	O
0	int
;	O
while	O
(	O
nrd	O
<	O
bufsize	O
)	O
{	O
size_t	long
n	long
=	O
bufsize	O
-	O
nrd	O
;	O
size_t	long
avail	O
=	O
cfstream_avail	O
(	O
cf	O
)	O
;	O
if	O
(	O
avail	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
cf	O
->	O
eol	O
)	O
{	O
bufptr	O
[	O
nrd	O
++	O
]	O
=	O
'\n'	O
;	O
cf	O
->	O
eol	O
=	O
1	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
n	long
>	O
avail	O
)	O
n	long
=	O
avail	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bufptr	O
+	O
nrd	O
,	O
cfstream_buf_ptr	O
(	O
cf	O
)	O
,	O
n	long
)	O
;	O
cfstream_buf_advance	O
(	O
cf	O
,	O
n	long
)	O
;	O
nrd	O
+=	O
n	long
;	O
cf	O
->	O
eol	O
=	O
bufptr	O
[	O
nrd	O
-	O
1	int
]	O
==	O
'\n'	O
;	O
}	O
return	O
nrd	O
;	O
}	O
int	O
cfstream_same_file	O
(	O
CFSTREAM	O
*	O
cf	O
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
const	O
*	O
st	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
fst	O
;	O
if	O
(	O
cf	O
->	O
fd	int
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
cf	O
->	O
fd	int
,	O
&	O
fst	O
)	O
)	O
{	O
logmsg	O
(	O
LOG_ERR	O
,	O
"fstat: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
fst	O
.	O
st_dev	long
==	O
st	O
->	O
st_dev	long
&&	O
fst	O
.	O
st_ino	long
==	O
st	O
->	O
st_ino	long
;	O
}	O
const	O
char	O
default_entry	O
[	O
]	O
=	O
""	*(char)
;	O
void	O
cfparse	O
(	O
void	O
)	O
{	O
CFSTREAM	O
*	O
cf	O
;	O
char	O
const	O
*	O
filename	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
rush_config_file	O
,	O
F_OK	O
)	O
==	O
0	int
)	O
{	O
cf	O
=	O
cfstream_open_file	O
(	O
rush_config_file	O
)	O
;	O
filename	O
=	O
rush_config_file	O
;	O
}	O
else	O
if	O
(	O
default_entry	O
[	O
0	int
]	O
)	O
{	O
cf	O
=	O
cfstream_open_mem	O
(	O
default_entry	O
,	O
sizeof	O
(	O
default_entry	O
)	O
-	O
1	int
)	O
;	O
filename	O
=	O
"<built-in>"	*(char)
;	O
}	O
else	O
{	O
die	O
(	O
usage_error	int
,	O
NULL	O
,	O
_	O
(	O
"configuration file does not exist and no default is provided"	*(char)
)	O
)	O
;	O
}	O
cflex_setup	O
(	O
cf	O
,	O
filename	O
,	O
1	int
)	O
;	O
if	O
(	O
yyparse	O
(	O
)	O
)	O
die	O
(	O
config_error	int
,	O
NULL	O
,	O
_	O
(	O
"errors in configuration file"	*(char)
)	O
)	O
;	O
}	O
int	O
parse_file_mode	O
(	O
const	O
char	O
*	O
val	array(int)
,	O
mode_t	int
*	O
mode	O
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
char	O
*	O
q	O
;	O
unsigned	O
int	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
val	array(int)
,	O
&	O
q	O
,	O
8	int
)	O
;	O
if	O
(	O
*	O
q	O
||	O
(	O
n	long
&	O
~	O
0777	int
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"not a valid file mode"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
mode	O
=	O
n	long
;	O
return	O
0	int
;	O
}	O
int	O
absolute_dir_p	O
(	O
const	O
char	O
*	O
dir	enum(int,int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
enum	O
{	O
state_init	O
,	O
state_dot	O
,	O
state_double_dot	O
}	O
state	*(int)
=	O
state_init	O
;	O
if	O
(	O
dir	enum(int,int)
[	O
0	int
]	O
!=	O
'/'	O
)	O
return	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
dir	enum(int,int)
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
{	O
switch	O
(	O
*	O
p	*(void)
)	O
{	O
case	O
'.'	O
:	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
state_init	O
:	O
state	*(int)
=	O
state_dot	O
;	O
break	O
;	O
case	O
state_dot	O
:	O
state	*(int)
=	O
state_double_dot	O
;	O
break	O
;	O
case	O
state_double_dot	O
:	O
state	*(int)
=	O
state_init	O
;	O
}	O
break	O
;	O
case	O
'/'	O
:	O
if	O
(	O
state	*(int)
!=	O
state_init	O
)	O
return	O
0	int
;	O
break	O
;	O
default	O
:	O
state	*(int)
=	O
state_init	O
;	O
}	O
}	O
return	O
state	*(int)
==	O
state_init	O
;	O
}	O
static	O
int	O
check_dir	O
(	O
const	O
char	O
*	O
dir	enum(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	O
;	O
if	O
(	O
dir	enum(int,int)
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
if	O
(	O
dir	enum(int,int)
[	O
1	int
]	O
&&	O
!	O
absolute_dir_p	O
(	O
dir	enum(int,int)
+	O
1	int
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"not an absolute directory name"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
absolute_dir_p	O
(	O
dir	enum(int,int)
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"not an absolute directory name"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
dir	enum(int,int)
,	O
&	O
st	O
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"cannot stat %s: %s"	*(char)
)	O
,	O
dir	enum(int,int)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	O
.	O
st_mode	int
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"%s is not a directory"	*(char)
)	O
,	O
dir	enum(int,int)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
get_bool	O
(	O
const	O
char	O
*	O
val	array(int)
,	O
int	O
*	O
res	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"yes"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"on"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"t"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"true"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"1"	*(char)
)	O
==	O
0	int
)	O
*	O
res	O
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"no"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"off"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"nil"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"false"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
"0"	*(char)
)	O
==	O
0	int
)	O
*	O
res	O
=	O
0	int
;	O
else	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
copy_part	O
(	O
const	O
char	O
*	O
cstr	O
,	O
const	O
char	O
*	O
p	*(void)
,	O
char	O
*	O
*	O
pbuf	*(*(char))
)	O
{	O
size_t	long
len	long
=	O
p	*(void)
-	O
cstr	O
;	O
char	O
*	O
buf	O
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf	O
)	O
return	O
1	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	O
,	O
cstr	O
,	O
len	long
)	O
;	O
buf	O
[	O
len	long
]	O
=	O
0	int
;	O
*	O
pbuf	*(*(char))
=	O
buf	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_conn	O
(	O
const	O
char	O
*	O
cstr	O
,	O
char	O
*	O
*	O
pport	O
,	O
char	O
*	O
*	O
ppath	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
cstr	O
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
*	O
pport	O
=	O
NULL	O
;	O
*	O
ppath	O
=	O
strdup	(*(char))->(*(char))
(	O
cstr	O
)	O
;	O
return	O
*	O
ppath	O
==	O
NULL	O
;	O
}	O
else	O
if	O
(	O
copy_part	O
(	O
cstr	O
,	O
p	*(void)
,	O
ppath	O
)	O
)	O
return	O
1	int
;	O
else	O
cstr	O
=	O
p	*(void)
+	O
1	int
;	O
*	O
pport	O
=	O
strdup	(*(char))->(*(char))
(	O
cstr	O
)	O
;	O
return	O
*	O
pport	O
==	O
NULL	O
;	O
}	O
struct	O
socket_family	O
{	O
char	O
*	O
name	*(char)
;	O
size_t	long
len	long
;	O
int	O
family	O
;	O
}	O
;	O
static	O
struct	O
socket_family	O
socket_family	O
[	O
]	O
=	O
{	O
DEF	O
(	O
inet	O
,	O
AF_INET	O
)	O
,	O
DEF	O
(	O
unix	O
,	O
AF_UNIX	O
)	O
,	O
DEF	O
(	O
local	O
,	O
AF_UNIX	O
)	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
socket_family	O
*	O
find_family	O
(	O
const	O
char	O
*	O
s	long
,	O
size_t	long
len	long
)	O
{	O
struct	O
socket_family	O
*	O
fp	O
;	O
for	O
(	O
fp	O
=	O
socket_family	O
;	O
fp	O
->	O
name	*(char)
;	O
fp	O
++	O
)	O
if	O
(	O
len	long
==	O
fp	O
->	O
len	long
)	O
return	O
fp	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
parse_url	O
(	O
struct	O
cfloc	O
const	O
*	O
loc	O
,	O
const	O
char	O
*	O
cstr	O
,	O
int	O
*	O
pfamily	O
,	O
char	O
*	O
*	O
pport	O
,	O
char	O
*	O
*	O
ppath	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
cstr	O
,	O
':'	O
)	O
;	O
if	O
(	O
p	*(void)
)	O
{	O
struct	O
socket_family	O
*	O
fp	O
=	O
find_family	O
(	O
cstr	O
,	O
p	*(void)
-	O
cstr	O
)	O
;	O
if	O
(	O
!	O
fp	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"unknown address family"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
pfamily	O
=	O
fp	O
->	O
family	O
;	O
cstr	O
=	O
p	*(void)
+	O
1	int
;	O
if	O
(	O
cstr	O
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
if	O
(	O
cstr	O
[	O
1	int
]	O
==	O
'/'	O
)	O
{	O
return	O
parse_conn	O
(	O
cstr	O
+	O
2	int
,	O
pport	O
,	O
ppath	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
pfamily	O
==	O
AF_UNIX	O
)	O
{	O
*	O
pport	O
=	O
NULL	O
;	O
*	O
ppath	O
=	O
strdup	(*(char))->(*(char))
(	O
cstr	O
)	O
;	O
return	O
*	O
ppath	O
==	O
NULL	O
;	O
}	O
}	O
else	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"malformed URL"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
*	O
pfamily	O
=	O
AF_UNIX	O
;	O
*	O
pport	O
=	O
NULL	O
;	O
*	O
ppath	O
=	O
strdup	(*(char))->(*(char))
(	O
cstr	O
)	O
;	O
return	O
*	O
ppath	O
==	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
make_socket	O
(	O
struct	O
cfloc	O
const	O
*	O
loc	O
,	O
int	O
family	O
,	O
char	O
*	O
port	O
,	O
char	O
*	O
path	O
,	O
struct	O
rush_sockaddr	O
*	O
pa	O
)	O
{	O
union	O
{	O
struct	O
sockaddr	struct(short,array(char))
sa	O
;	O
struct	O
sockaddr_un	struct(short,array(char))
s_un	O
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
s_in	O
;	O
}	O
addr	O
;	O
socklen_t	int
socklen	O
;	O
short	O
pnum	O
;	O
long	O
num	long
;	O
char	O
*	O
p	*(void)
;	O
switch	O
(	O
family	O
)	O
{	O
case	O
AF_UNIX	O
:	O
if	O
(	O
port	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"port is meaningless for UNIX sockets"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
path	O
)	O
>	O
sizeof	O
addr	O
.	O
s_un	O
.	O
sun_path	array(char)
)	O
{	O
errno	O
=	O
EINVAL	O
;	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"UNIX socket name too long"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
addr	O
.	O
sa	O
.	O
sa_family	short
=	O
PF_UNIX	O
;	O
socklen	O
=	O
sizeof	O
(	O
addr	O
.	O
s_un	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
addr	O
.	O
s_un	O
.	O
sun_path	array(char)
,	O
path	O
)	O
;	O
break	O
;	O
case	O
AF_INET	O
:	O
addr	O
.	O
sa	O
.	O
sa_family	short
=	O
PF_INET	O
;	O
socklen	O
=	O
sizeof	O
(	O
addr	O
.	O
s_in	O
)	O
;	O
num	long
=	O
pnum	O
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
port	O
,	O
&	O
p	*(void)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
{	O
if	O
(	O
num	long
!=	O
pnum	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"bad port number"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pnum	O
=	O
htons	(short)->(short)
(	O
pnum	O
)	O
;	O
}	O
else	O
{	O
struct	O
servent	struct(*(char),*(*(char)),int,*(char))
*	O
sp	O
=	O
getservbyname	(*(char),*(char))->(*(struct(*(char),*(*(char)),int,*(char))))
(	O
port	O
,	O
"tcp"	*(char)
)	O
;	O
if	O
(	O
!	O
sp	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"unknown service name"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pnum	O
=	O
sp	O
->	O
s_port	int
;	O
}	O
if	O
(	O
!	O
path	O
)	O
addr	O
.	O
s_in	O
.	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
else	O
{	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
hp	O
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
path	O
)	O
;	O
if	O
(	O
!	O
hp	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"unknown host name %s"	*(char)
)	O
,	O
path	O
)	O
;	O
return	O
1	int
;	O
}	O
addr	O
.	O
sa	O
.	O
sa_family	short
=	O
hp	O
->	O
h_addrtype	int
;	O
switch	O
(	O
hp	O
->	O
h_addrtype	int
)	O
{	O
case	O
AF_INET	O
:	O
memmove	(*(void),*(void),long)->(*(void))
(	O
&	O
addr	O
.	O
s_in	O
.	O
sin_addr	struct(int)
,	O
hp	O
->	O
h_addr	O
,	O
4	int
)	O
;	O
addr	O
.	O
s_in	O
.	O
sin_port	short
=	O
pnum	O
;	O
break	O
;	O
default	O
:	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"unsupported address family"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"unsupported address family"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
pa	O
->	O
len	long
=	O
socklen	O
;	O
pa	O
->	O
sa	O
=	O
xmalloc	(long)->(*(void))
(	O
socklen	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
pa	O
->	O
sa	O
,	O
&	O
addr	O
.	O
sa	O
,	O
socklen	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
attrib_umask	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
return	O
parse_file_mode	O
(	O
arg	struct(int,int)
,	O
&	O
rule	*(char)
->	O
mask	O
,	O
loc	O
)	O
;	O
}	O
int	O
attrib_chroot	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
char	O
*	O
chroot_dir	O
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	struct(int,int)
)	O
;	O
int	O
rc	O
=	O
0	int
;	O
if	O
(	O
trimslash	O
(	O
chroot_dir	O
)	O
==	O
0	int
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"invalid chroot directory"	*(char)
)	O
)	O
;	O
rc	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
check_dir	O
(	O
chroot_dir	O
,	O
loc	O
)	O
)	O
rc	O
=	O
1	int
;	O
if	O
(	O
rc	O
)	O
free	(*(void))->(void)
(	O
chroot_dir	O
)	O
;	O
else	O
rule	*(char)
->	O
chroot_dir	O
=	O
chroot_dir	O
;	O
return	O
rc	O
;	O
}	O
int	O
attrib_chdir	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
rule	*(char)
->	O
home_dir	O
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	struct(int,int)
)	O
;	O
if	O
(	O
trimslash	O
(	O
rule	*(char)
->	O
home_dir	O
)	O
==	O
0	int
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"invalid home directory"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
attrib_fork	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
int	O
yes	O
;	O
if	O
(	O
get_bool	O
(	O
arg	struct(int,int)
,	O
&	O
yes	O
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"expected boolean value, but found `%s'"	*(char)
)	O
,	O
arg	struct(int,int)
)	O
;	O
return	O
1	int
;	O
}	O
rule	*(char)
->	O
fork	()->(int)
=	O
yes	O
?	O
rush_true	O
:	O
rush_false	O
;	O
return	O
0	int
;	O
}	O
int	O
attrib_acct	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
int	O
yes	O
;	O
if	O
(	O
get_bool	O
(	O
arg	struct(int,int)
,	O
&	O
yes	O
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"expected boolean value, but found `%s'"	*(char)
)	O
,	O
arg	struct(int,int)
)	O
;	O
return	O
1	int
;	O
}	O
rule	*(char)
->	O
acct	(*(char))->(int)
=	O
yes	O
?	O
rush_true	O
:	O
rush_false	O
;	O
return	O
0	int
;	O
}	O
int	O
attrib_post_socket	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
int	O
family	O
;	O
char	O
*	O
path	O
;	O
char	O
*	O
port	O
;	O
int	O
rc	O
;	O
if	O
(	O
parse_url	O
(	O
loc	O
,	O
arg	struct(int,int)
,	O
&	O
family	O
,	O
&	O
port	O
,	O
&	O
path	O
)	O
)	O
return	O
1	int
;	O
rc	O
=	O
make_socket	O
(	O
loc	O
,	O
family	O
,	O
port	O
?	O
port	O
:	O
"tcpmux"	*(char)
,	O
path	O
,	O
&	O
rule	*(char)
->	O
post_sockaddr	O
)	O
;	O
free	(*(void))->(void)
(	O
port	O
)	O
;	O
free	(*(void))->(void)
(	O
path	O
)	O
;	O
return	O
rc	O
;	O
}	O
static	O
int	O
attrib_text_domain	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
rule	*(char)
->	O
i18n	O
.	O
text_domain	O
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	struct(int,int)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
attrib_locale_dir	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
rule	*(char)
->	O
i18n	O
.	O
localedir	O
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	struct(int,int)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
attrib_locale	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
rule	*(char)
->	O
i18n	O
.	O
locale	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	struct(int,int)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
attrib_interactive	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
if	O
(	O
get_bool	O
(	O
arg	struct(int,int)
,	O
&	O
rule	*(char)
->	O
interactive	O
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"expected boolean value, but found `%s'"	*(char)
)	O
,	O
arg	struct(int,int)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
attrib_newgroup	O
(	O
struct	O
rush_rule	O
*	O
rule	*(char)
,	O
char	O
const	O
*	O
arg	struct(int,int)
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
struct	O
group	struct(*(char),*(char),int,*(*(char)))
*	O
grp	O
;	O
if	O
(	O
c_isdigit	(int)->(bool)
(	O
arg	struct(int,int)
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
unsigned	O
long	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	struct(int,int)
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
0	int
)	O
{	O
rule	*(char)
->	O
gid	int
=	O
n	long
;	O
return	O
0	int
;	O
}	O
}	O
grp	O
=	O
getgrnam	(*(char))->(*(struct(*(char),*(char),int,*(*(char)))))
(	O
arg	struct(int,int)
)	O
;	O
if	O
(	O
!	O
grp	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"no such group: %s"	*(char)
)	O
,	O
arg	struct(int,int)
)	O
;	O
return	O
1	int
;	O
}	O
rule	*(char)
->	O
gid	int
=	O
grp	O
->	O
gr_gid	int
;	O
return	O
0	int
;	O
}	O
struct	O
rule_attrib	O
{	O
char	O
const	O
*	O
name	*(char)
;	O
rule_attrib_setter_t	O
setter	O
;	O
}	O
;	O
static	O
struct	O
rule_attrib	O
attrib	O
[	O
]	O
=	O
{	O
{	O
"umask"	*(char)
,	O
attrib_umask	O
}	O
,	O
{	O
"chroot"	*(char)
,	O
attrib_chroot	O
}	O
,	O
{	O
"chdir"	*(char)
,	O
attrib_chdir	O
}	O
,	O
{	O
"fork"	*(char)
,	O
attrib_fork	O
}	O
,	O
{	O
"acct"	*(char)
,	O
attrib_acct	O
}	O
,	O
{	O
"post-socket"	*(char)
,	O
attrib_post_socket	O
}	O
,	O
{	O
"text-domain"	*(char)
,	O
attrib_text_domain	O
}	O
,	O
{	O
"locale-dir"	*(char)
,	O
attrib_locale_dir	O
}	O
,	O
{	O
"locale"	*(char)
,	O
attrib_locale	O
}	O
,	O
{	O
"interactive"	*(char)
,	O
attrib_interactive	O
}	O
,	O
{	O
"newgroup"	*(char)
,	O
attrib_newgroup	O
}	O
,	O
{	O
"newgrp"	*(char)
,	O
attrib_newgroup	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
rule_attrib_setter_t	O
rule_attrib_lookup	O
(	O
char	O
const	O
*	O
name	*(char)
)	O
{	O
struct	O
rule_attrib	O
*	O
ap	O
;	O
for	O
(	O
ap	O
=	O
attrib	O
;	O
ap	O
->	O
name	*(char)
;	O
ap	O
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ap	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
ap	O
->	O
setter	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
glattrib_debug	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arghead	O
)	O
{	O
if	O
(	O
debug_level	O
==	O
0	int
)	O
debug_level	O
=	O
arghead	O
->	O
intval	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
glattrib_sleep_time	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arghead	O
)	O
{	O
sleep_time	O
=	O
arghead	O
->	O
intval	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
glattrib_message	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arghead	O
)	O
{	O
int	O
n	long
=	O
string_to_error_index	O
(	O
arghead	O
->	O
strval	O
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
cferror	O
(	O
&	O
arghead	O
->	O
loc	O
,	O
_	O
(	O
"Unknown message reference"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
set_error_msg	O
(	O
n	long
,	O
arghead	O
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
->	O
strval	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
glattrib_regexp	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arg	struct(int,int)
)	O
{	O
for	O
(	O
;	O
arg	struct(int,int)
;	O
arg	struct(int,int)
=	O
arg	struct(int,int)
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
int	O
enable	O
,	O
flag	*(int)
;	O
char	O
*	O
p	*(void)
=	O
arg	struct(int,int)
->	O
strval	O
;	O
switch	O
(	O
*	O
p	*(void)
)	O
{	O
case	O
'+'	O
:	O
p	*(void)
++	O
;	O
enable	O
=	O
1	int
;	O
break	O
;	O
case	O
'-'	O
:	O
p	*(void)
++	O
;	O
enable	O
=	O
0	int
;	O
break	O
;	O
default	O
:	O
enable	O
=	O
1	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"extended"	*(char)
)	O
==	O
0	int
)	O
flag	*(int)
=	O
REG_EXTENDED	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"basic"	*(char)
)	O
==	O
0	int
)	O
{	O
flag	*(int)
=	O
REG_EXTENDED	O
;	O
enable	O
=	O
!	O
enable	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"icase"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"ignore-case"	*(char)
)	O
==	O
0	int
)	O
flag	*(int)
=	O
REG_ICASE	O
;	O
else	O
{	O
cferror	O
(	O
&	O
arg	struct(int,int)
->	O
loc	O
,	O
_	O
(	O
"unknown regexp flag: %s"	*(char)
)	O
,	O
p	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
enable	O
)	O
re_flags	O
|=	O
flag	*(int)
;	O
else	O
re_flags	O
&=	O
~	O
flag	*(int)
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
glattrib_include_security	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arg	struct(int,int)
)	O
{	O
int	O
rc	O
=	O
0	int
;	O
for	O
(	O
;	O
arg	struct(int,int)
;	O
arg	struct(int,int)
=	O
arg	struct(int,int)
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
if	O
(	O
cfck_keyword	O
(	O
arg	struct(int,int)
->	O
strval	O
)	O
)	O
{	O
cferror	O
(	O
&	O
arg	struct(int,int)
->	O
loc	O
,	O
_	O
(	O
"unknown keyword: %s"	*(char)
)	O
,	O
arg	struct(int,int)
->	O
strval	O
)	O
;	O
rc	O
=	O
1	int
;	O
}	O
}	O
return	O
rc	O
;	O
}	O
static	O
int	O
glattrib_acct_file_mode	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arg	struct(int,int)
)	O
{	O
return	O
parse_file_mode	O
(	O
arg	struct(int,int)
->	O
strval	O
,	O
&	O
rushdb_file_mode	int
,	O
&	O
arg	struct(int,int)
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
glattrib_acct_dir_mode	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arg	struct(int,int)
)	O
{	O
return	O
parse_file_mode	O
(	O
arg	struct(int,int)
->	O
strval	O
,	O
&	O
rushdb_dir_mode	int
,	O
&	O
arg	struct(int,int)
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
glattrib_acct_umask	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arg	struct(int,int)
)	O
{	O
return	O
parse_file_mode	O
(	O
arg	struct(int,int)
->	O
strval	O
,	O
&	O
rushdb_umask	int
,	O
&	O
arg	struct(int,int)
->	O
loc	O
)	O
;	O
}	O
static	O
int	O
glattrib_expand_undef	O
(	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arg	struct(int,int)
)	O
{	O
expand_undefined	O
=	O
arg	struct(int,int)
->	O
intval	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
global_attrib	O
global_attrib	O
[	O
]	O
=	O
{	O
{	O
"debug"	*(char)
,	O
"n"	*(char)
,	O
glattrib_debug	O
}	O
,	O
{	O
"sleep-time"	*(char)
,	O
"n"	*(char)
,	O
glattrib_sleep_time	O
}	O
,	O
{	O
"message"	*(char)
,	O
"ss"	*(char)
,	O
glattrib_message	O
}	O
,	O
{	O
"regexp"	*(char)
,	O
"s."	*(char)
,	O
glattrib_regexp	O
}	O
,	O
{	O
"include-security"	*(char)
,	O
"s."	*(char)
,	O
glattrib_include_security	O
}	O
,	O
{	O
"acct-file-mode"	*(char)
,	O
"s"	*(char)
,	O
glattrib_acct_file_mode	O
}	O
,	O
{	O
"acct-dir-mode"	*(char)
,	O
"s"	*(char)
,	O
glattrib_acct_dir_mode	O
}	O
,	O
{	O
"acct-umask"	*(char)
,	O
"s"	*(char)
,	O
glattrib_acct_umask	O
}	O
,	O
{	O
"expand-undefined"	*(char)
,	O
"b"	*(char)
,	O
glattrib_expand_undef	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
global_attrib	O
*	O
global_attrib_lookup	O
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
global_attrib	O
*	O
ap	O
;	O
for	O
(	O
ap	O
=	O
global_attrib	O
;	O
ap	O
->	O
name	*(char)
;	O
ap	O
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ap	O
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
ap	O
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
global_attrib_set	O
(	O
struct	O
global_attrib	O
*	O
glatt	O
,	O
int	O
argc	int
,	O
struct	O
argval	O
*	O
arghead	O
,	O
struct	O
cfloc	O
const	O
*	O
loc	O
)	O
{	O
struct	O
argval	O
*	O
arg	struct(int,int)
;	O
int	O
i	O
;	O
for	O
(	O
i	O
=	O
0	int
,	O
arg	struct(int,int)
=	O
arghead	O
;	O
arg	struct(int,int)
;	O
arg	struct(int,int)
=	O
arg	struct(int,int)
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
)	O
{	O
switch	O
(	O
glatt	O
->	O
argt	O
[	O
i	O
]	O
)	O
{	O
case	O
'n'	O
:	O
if	O
(	O
!	O
arg	struct(int,int)
->	O
isnum	O
)	O
{	O
cferror	O
(	O
&	O
arg	struct(int,int)
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"expected numeric argument"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
i	O
++	O
;	O
break	O
;	O
case	O
's'	O
:	O
i	O
++	O
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
get_bool	O
(	O
arg	struct(int,int)
->	O
strval	O
,	O
&	O
arg	struct(int,int)
->	O
intval	O
)	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
_	O
(	O
"expected boolean value, but found `%s'"	*(char)
)	O
,	O
arg	struct(int,int)
->	O
strval	O
)	O
;	O
return	O
;	O
}	O
i	O
++	O
;	O
break	O
;	O
case	O
'.'	O
:	O
break	O
;	O
case	O
0	int
:	O
cferror	O
(	O
&	O
arg	struct(int,int)
->	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
glatt	O
->	O
argt	O
[	O
i	O
]	O
&&	O
glatt	O
->	O
argt	O
[	O
i	O
]	O
!=	O
'.'	O
)	O
{	O
cferror	O
(	O
loc	O
,	O
"%s"	*(char)
,	O
_	O
(	O
"not enough many arguments"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
glatt	O
->	O
setter	O
(	O
argc	int
,	O
arghead	O
)	O
;	O
}	O
void	O
arglist_free	O
(	O
struct	O
argval	O
*	O
arg	struct(int,int)
)	O
{	O
while	O
(	O
arg	struct(int,int)
)	O
{	O
struct	O
argval	O
*	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
=	O
arg	struct(int,int)
->	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
;	O
free	(*(void))->(void)
(	O
arg	struct(int,int)
->	O
strval	O
)	O
;	O
free	(*(void))->(void)
(	O
arg	struct(int,int)
)	O
;	O
arg	struct(int,int)
=	O
next	*(struct(*(struct(*(struct`),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union`),union(struct`,struct`,int,struct`))),enum(int,int,int,int),struct(enum(int,int,int,int,int,int),union(*(char),struct(int,int))),union(struct(*(char),*(struct`)),struct(*(char),*(char),*(char),int,int,*(char)),int,struct(*(char),*(char)))))
;	O
}	O
}	O
