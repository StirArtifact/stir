void	O
xfree	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
p	*(*(void))
)	O
{	O
assert	O
(	O
p	*(*(void))
!=	O
NULL	O
)	O
;	O
if	O
(	O
*	O
p	*(*(void))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
*	O
p	*(*(void))
)	O
;	O
*	O
p	*(*(void))
=	O
NULL	O
;	O
}	O
void	O
mem_init	()->(void)
(	O
)	O
{	O
user_agent	*(char)
=	O
NULL	O
;	O
logfilename	*(char)
=	O
NULL	O
;	O
proxyknife_in	*(char)
=	O
NULL	O
;	O
proxyknife_out	*(char)
=	O
NULL	O
;	O
proxyknife_in_buffer	*(char)
=	O
NULL	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
=	O
NULL	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuser	*(char)
=	O
NULL	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mypass	*(char)
=	O
NULL	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuserpass	*(char)
=	O
NULL	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
header_auth	*(char)
=	O
NULL	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
socks5authreq	*(char)
=	O
NULL	O
;	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
buffer	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetport	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
protocol	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
key	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
checkreqin	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
req	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
req_get_via_http_proxy	*(char)
=	O
NULL	O
;	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
con_via_http_proxy	*(char)
=	O
NULL	O
;	O
}	O
void	O
xexit	(int)->(void)
(	O
int	O
status	int
)	O
{	O
if	O
(	O
logfilename	*(char)
)	O
free	(*(void))->(void)
(	O
logfilename	*(char)
)	O
;	O
if	O
(	O
user_agent	*(char)
)	O
free	(*(void))->(void)
(	O
user_agent	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
key	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
key	*(char)
)	O
;	O
if	O
(	O
proxyknife_in	*(char)
)	O
free	(*(void))->(void)
(	O
proxyknife_in	*(char)
)	O
;	O
if	O
(	O
proxyknife_out	*(char)
)	O
free	(*(void))->(void)
(	O
proxyknife_out	*(char)
)	O
;	O
if	O
(	O
proxyknife_in_buffer	*(char)
)	O
free	(*(void))->(void)
(	O
proxyknife_in_buffer	*(char)
)	O
;	O
if	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
)	O
free	(*(void))->(void)
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myhost	*(char)
)	O
;	O
if	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuser	*(char)
)	O
free	(*(void))->(void)
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuser	*(char)
)	O
;	O
if	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mypass	*(char)
)	O
free	(*(void))->(void)
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
mypass	*(char)
)	O
;	O
if	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuserpass	*(char)
)	O
free	(*(void))->(void)
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
myuserpass	*(char)
)	O
;	O
if	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
header_auth	*(char)
)	O
free	(*(void))->(void)
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
header_auth	*(char)
)	O
;	O
if	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
socks5authreq	*(char)
)	O
free	(*(void))->(void)
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
socks5authreq	*(char)
)	O
;	O
if	O
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
buffer	*(char)
)	O
free	(*(void))->(void)
(	O
my	struct(int,*(char),int,int,*(char),*(char),struct(int),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char))
.	O
buffer	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targethost	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetport	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetport	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
targetpath	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
protocol	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
protocol	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
req	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
req	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
checkreqin	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
checkreqin	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
req_get_via_http_proxy	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
req_get_via_http_proxy	*(char)
)	O
;	O
if	O
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
con_via_http_proxy	*(char)
)	O
free	(*(void))->(void)
(	O
target	struct(*(char),*(char),*(char),*(char),*(char),struct(short,short,struct(int),array(char)),*(char),*(char),*(char),*(char),*(char))
.	O
con_via_http_proxy	*(char)
)	O
;	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
void	O
*	O
xmalloc	(long)->(*(void))
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	*(*(void))
;	O
p	*(*(void))
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
p	*(*(void))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: xmalloc:Need more memory\n"	*(char)
,	O
progname	*(char)
)	O
;	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
return	O
p	*(*(void))
;	O
}	O
}	O
void	O
*	O
xrealloc	(*(void),long)->(*(void))
(	O
void	O
*	O
ptr	*(void)
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
p	*(*(void))
;	O
p	*(*(void))
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	*(void)
,	O
size	long
)	O
;	O
if	O
(	O
p	*(*(void))
==	O
NULL	O
)	O
{	O
xexit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
return	O
p	*(*(void))
;	O
}	O
}	O
void	O
*	O
prealloc	(*(void),long,*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(*(void))
(	O
void	O
*	O
ptr	*(void)
,	O
size_t	long
size	long
,	O
struct	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
*	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
{	O
void	O
*	O
p	*(*(void))
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
counter_mutex_malloc	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
p	*(*(void))
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	*(void)
,	O
size	long
)	O
;	O
if	O
(	O
p	*(*(void))
==	O
NULL	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
counter_mutex_malloc	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
counter_mutex_malloc	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
p	*(*(void))
;	O
}	O
}	O
void	O
*	O
pmalloc	(long,*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(*(void))
(	O
size_t	long
size	long
,	O
struct	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
*	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
{	O
void	O
*	O
p	*(*(void))
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
counter_mutex_malloc	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
p	*(*(void))
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
p	*(*(void))
==	O
NULL	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
counter_mutex_malloc	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
counter_mutex_malloc	union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long)
)	O
;	O
return	O
p	*(*(void))
;	O
}	O
}	O
void	O
thread_mem_init	(*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(void)
(	O
struct	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
*	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
{	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
line	*(char)
=	O
NULL	O
;	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
testproxy	*(char)
=	O
NULL	O
;	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
request	*(char)
=	O
NULL	O
;	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
reply	*(char)
=	O
NULL	O
;	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
proto_out	*(char)
=	O
NULL	O
;	O
}	O
void	O
thread_mem_clean	(*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(void)
(	O
struct	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
*	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
{	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
line	*(char)
)	O
pxfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
line	*(char)
)	O
)	O
;	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
testproxy	*(char)
)	O
pxfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
testproxy	*(char)
)	O
)	O
;	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
request	*(char)
)	O
pxfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
request	*(char)
)	O
)	O
;	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
reply	*(char)
)	O
pxfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
reply	*(char)
)	O
)	O
;	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
proto_out	*(char)
)	O
pxfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
proto_out	*(char)
)	O
)	O
;	O
}	O
void	O
pxfree	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
p	*(*(void))
)	O
{	O
assert	O
(	O
p	*(*(void))
!=	O
NULL	O
)	O
;	O
if	O
(	O
*	O
p	*(*(void))
)	O
free	(*(void))->(void)
(	O
*	O
p	*(*(void))
)	O
;	O
*	O
p	*(*(void))
=	O
NULL	O
;	O
}	O
void	O
x_pthread_exit	(*(void),*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(void)
(	O
void	O
*	O
retval	*(void)
,	O
struct	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
*	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
{	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
line	*(char)
)	O
free	(*(void))->(void)
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
line	*(char)
)	O
;	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
testproxy	*(char)
)	O
free	(*(void))->(void)
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
testproxy	*(char)
)	O
;	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
request	*(char)
)	O
free	(*(void))->(void)
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
request	*(char)
)	O
;	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
reply	*(char)
)	O
free	(*(void))->(void)
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
reply	*(char)
)	O
;	O
if	O
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
proto_out	*(char)
)	O
free	(*(void))->(void)
(	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
->	O
queue	struct(*(char),struct(short,short,struct(int),array(char)),*(char),int)
.	O
proto_out	*(char)
)	O
;	O
pthread_exit	(*(void))->(void)
(	O
retval	*(void)
)	O
;	O
}	O
void	O
*	O
update_string_thread	(*(*(char)),*(char),*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(*(void))
(	O
char	O
*	O
*	O
dst	*(char)
,	O
char	O
*	O
value	int
,	O
struct	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
*	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
{	O
int	O
size	long
;	O
if	O
(	O
*	O
dst	*(char)
!=	O
NULL	O
)	O
pxfree	(*(*(void)))->(void)
(	O
(	O
void	O
*	O
*	O
)	O
dst	*(char)
)	O
;	O
size	long
=	O
strlen	(*(char))->(long)
(	O
value	int
)	O
+	O
1	int
;	O
*	O
dst	*(char)
=	O
pmalloc	(long,*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(*(void))
(	O
size	long
,	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
;	O
if	O
(	O
*	O
dst	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
*	O
dst	*(char)
,	O
value	int
,	O
size	long
)	O
;	O
return	O
*	O
dst	*(char)
;	O
}	O
void	O
x_update_string_thread	(*(*(char)),*(char),*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(void)
(	O
char	O
*	O
*	O
dst	*(char)
,	O
char	O
*	O
value	int
,	O
struct	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
*	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
{	O
int	O
ret	int
=	O
EXIT_FAILURE	int
;	O
if	O
(	O
update_string_thread	(*(*(char)),*(char),*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(*(void))
(	O
dst	*(char)
,	O
value	int
,	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s %s: x_update_string_thread: "	*(char)
"fail to allocate memory!\n"	*(char)
,	O
progname	*(char)
,	O
__FILE__	O
)	O
;	O
x_pthread_exit	(*(void),*(struct(*(char),struct(*(char),struct(short,short,struct`,array(char)),*(char),int),*(char),*(char))))->(void)
(	O
(	O
void	O
*	O
)	O
&	O
ret	int
,	O
thread_mem	struct(*(char),struct(*(char),struct(short,short,struct(int),array(char)),*(char),int),*(char),*(char))
)	O
;	O
}	O
}	O
