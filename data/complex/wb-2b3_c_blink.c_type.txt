void	O
short2str	(*(char),int,int)->(void)
(	O
unsigned	O
char	O
*	O
str	*(char)
,	O
int	O
pos	int
,	O
int	O
cint	int
)	O
{	O
str	*(char)
[	O
(	O
pos	int
)	O
+	O
1	int
]	O
=	O
(	O
cint	int
)	O
&	O
0xff	int
;	O
str	*(char)
[	O
(	O
pos	int
)	O
+	O
0	int
]	O
=	O
(	O
cint	int
)	O
>>	O
8	int
;	O
return	O
;	O
}	O
short	O
str2short	(*(char),int)->(short)
(	O
unsigned	O
char	O
*	O
str	*(char)
,	O
int	O
pos	int
)	O
{	O
return	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	*(char)
)	O
)	O
[	O
(	O
pos	int
)	O
+	O
1	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	*(char)
)	O
)	O
[	O
pos	int
]	O
)	O
)	O
<<	O
8	int
)	O
;	O
}	O
void	O
long2str	(*(char),int,long)->(void)
(	O
unsigned	O
char	O
*	O
str	*(char)
,	O
int	O
pos	int
,	O
long	O
clong	long
)	O
{	O
str	*(char)
[	O
(	O
pos	int
)	O
+	O
3	int
]	O
=	O
(	O
clong	long
)	O
&	O
0xff	int
;	O
str	*(char)
[	O
(	O
pos	int
)	O
+	O
2	int
]	O
=	O
(	O
(	O
clong	long
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
str	*(char)
[	O
(	O
pos	int
)	O
+	O
1	int
]	O
=	O
(	O
(	O
clong	long
)	O
>>	O
0x10	int
)	O
&	O
0xff	int
;	O
str	*(char)
[	O
(	O
pos	int
)	O
+	O
0	int
]	O
=	O
(	O
clong	long
)	O
>>	O
0x18	int
;	O
return	O
;	O
}	O
long	O
str2long	(*(char),int)->(long)
(	O
unsigned	O
char	O
*	O
str	*(char)
,	O
int	O
pos	int
)	O
{	O
return	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	*(char)
)	O
)	O
[	O
(	O
pos	int
)	O
+	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	*(char)
)	O
)	O
[	O
(	O
pos	int
)	O
+	O
2	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	*(char)
)	O
)	O
[	O
(	O
pos	int
)	O
+	O
1	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	*(char)
)	O
)	O
[	O
pos	int
]	O
)	O
)	O
<<	O
0x8L	int
)	O
)	O
<<	O
0x8L	int
)	O
)	O
<<	O
0x8L	int
)	O
;	O
}	O
int	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
f_pos	int
,	O
int	O
f_len	int
)	O
{	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
f_len	int
)	O
;	O
subbytes_move	O
(	O
val_str	*(char)
,	O
f_pos	int
,	O
(	O
f_pos	int
)	O
+	O
(	O
f_len	int
)	O
,	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
return	O
(	O
f_len	int
)	O
+	O
1	int
+	O
(	O
b_pos	int
)	O
;	O
}	O
unsigned	O
char	O
leaf_split_key_str	array(char)
[	O
]	O
=	O
{	O
0xff	int
,	O
(	O
leaf	int
)	O
}	O
;	O
void	O
init_leaf_blk	(*(char),long,int)->(void)
(	O
unsigned	O
char	O
*	O
nblk	*(char)
,	O
long	O
bnum	long
,	O
int	O
typ	int
)	O
{	O
nblk	*(char)
[	O
(	O
blk_size	int
)	O
-	O
1	int
]	O
=	O
0xa	int
;	O
blk_set_id	O
(	O
nblk	*(char)
,	O
bnum	long
)	O
;	O
blk_set_nxt_id	O
(	O
nblk	*(char)
,	O
0	int
)	O
;	O
blk_set_top_id	O
(	O
nblk	*(char)
,	O
bnum	long
)	O
;	O
blk_set_time	O
(	O
nblk	*(char)
,	O
0	int
)	O
;	O
blk_set_level	O
(	O
nblk	*(char)
,	O
leaf	int
)	O
;	O
blk_set_typ	O
(	O
nblk	*(char)
,	O
typ	int
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
leaf_split_key_str	array(char)
,	O
0	int
,	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
(	O
(	O
(	O
typ	int
)	O
==	O
(	O
seq_typ	int
)	O
?	O
0	int
:	O
4	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
void	O
reroot	(*(char),*(char),long,int)->(void)
(	O
unsigned	O
char	O
*	O
rblk	*(char)
,	O
unsigned	O
char	O
*	O
nblk	*(char)
,	O
long	O
bnum	long
,	O
int	O
bsiz	int
)	O
{	O
int	O
rpos	int
=	O
blk_data_start	int
;	O
subbytes_move	O
(	O
rblk	*(char)
,	O
4	int
,	O
bsiz	int
,	O
nblk	*(char)
,	O
4	int
)	O
;	O
blk_set_nxt_id	O
(	O
rblk	*(char)
,	O
0	int
)	O
;	O
blk_set_level	O
(	O
rblk	*(char)
,	O
(	O
blk_level	O
(	O
rblk	*(char)
)	O
)	O
+	O
1	int
)	O
;	O
set_field_len	O
(	O
rblk	*(char)
,	O
rpos	int
,	O
0	int
)	O
;	O
rpos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
rblk	*(char)
,	O
(	O
rpos	int
)	O
+	O
1	int
,	O
leaf_split_key_str	array(char)
,	O
0	int
,	O
2	int
)	O
;	O
rblk	*(char)
[	O
(	O
rpos	int
)	O
-	O
1	int
]	O
=	O
(	O
blk_level	O
(	O
rblk	*(char)
)	O
)	O
-	O
1	int
;	O
rpos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
rblk	*(char)
,	O
rpos	int
,	O
nblk	*(char)
,	O
0	int
,	O
4	int
)	O
;	O
set_field_len	O
(	O
rblk	*(char)
,	O
rpos	int
,	O
1	int
)	O
;	O
rpos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
rblk	*(char)
,	O
(	O
rpos	int
)	O
+	O
1	int
,	O
leaf_split_key_str	array(char)
,	O
0	int
,	O
1	int
)	O
;	O
rblk	*(char)
[	O
(	O
rpos	int
)	O
-	O
1	int
]	O
=	O
blk_level	O
(	O
rblk	*(char)
)	O
;	O
blk_set_end	O
(	O
rblk	*(char)
,	O
rpos	int
)	O
;	O
return	O
;	O
}	O
void	O
init_next_blk	(*(char),*(char))->(void)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
unsigned	O
char	O
*	O
nblk	*(char)
)	O
{	O
nblk	*(char)
[	O
(	O
blk_size	int
)	O
-	O
1	int
]	O
=	O
0xa	int
;	O
blk_set_nxt_id	O
(	O
nblk	*(char)
,	O
blk_nxt_id	O
(	O
blk	*(char)
)	O
)	O
;	O
blk_set_top_id	O
(	O
nblk	*(char)
,	O
blk_top_id	O
(	O
blk	*(char)
)	O
)	O
;	O
blk_set_level	O
(	O
nblk	*(char)
,	O
blk_level	O
(	O
blk	*(char)
)	O
)	O
;	O
blk_set_typ	O
(	O
nblk	*(char)
,	O
blk_typ	O
(	O
blk	*(char)
)	O
)	O
;	O
blk_set_nxt_id	O
(	O
blk	*(char)
,	O
blk_id	O
(	O
nblk	*(char)
)	O
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
no_byts	*(char)
,	O
0	int
,	O
0	int
)	O
;	O
blk_set_end	O
(	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
return	O
;	O
}	O
int	O
split_key_pos	(*(char))->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
)	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	*(char)
)	O
;	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
L_lp	O
:	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
return	O
b_pos	int
;	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
b_pos	int
=	O
next_cnvpair	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
goto	O
L_lp	O
;	O
}	O
else	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s: blk past end %ld %d\n"	*(char)
,	O
"split_key_pos"	*(char)
,	O
blk_id	O
(	O
blk	*(char)
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
}	O
int	O
blk_find_pos	(*(char),*(char),int,*(int))->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_len	int
,	O
int	O
*	O
pkt	*(int)
)	O
{	O
if	O
(	O
(	O
k_len	int
)	O
<	O
0	int
)	O
{	O
if	O
(	O
(	O
k_len	int
)	O
==	O
(	O
end_of_chain	O
)	O
)	O
{	O
int	O
skpos	int
=	O
split_key_pos	(*(char))->(int)
(	O
blk	*(char)
)	O
;	O
pkt_pack	O
(	O
pkt	*(int)
,	O
(	O
end_of_chain_P	O
(	O
blk	*(char)
)	O
?	O
qpastp	O
:	O
pastend	O
)	O
,	O
skpos	int
,	O
0	int
,	O
blk_prev_key	(*(char),int)->(int)
(	O
blk	*(char)
,	O
skpos	int
)	O
)	O
;	O
}	O
else	O
pkt_pack	O
(	O
pkt	*(int)
,	O
qpastp	O
,	O
blk_data_start	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
int	O
k_pos	int
=	O
0	int
;	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	*(char)
)	O
;	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
int	O
p_pos	int
=	O
0	int
;	O
L_chknxt	O
:	O
if	O
(	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
<	O
(	O
k_pos	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	*(int)
,	O
qpastp	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
>	O
(	O
k_pos	int
)	O
)	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
int	O
T_b_pos	int
=	O
next_cnvpair	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
p_pos	int
=	O
b_pos	int
;	O
b_pos	int
=	O
T_b_pos	int
;	O
goto	O
L_chknxt	O
;	O
}	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	*(int)
,	O
pastend	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s1: blk past end %ld %d\n"	*(char)
,	O
"blk_find_pos"	*(char)
,	O
blk_id	O
(	O
blk	*(char)
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
int	O
i	int
=	O
(	O
b_pos	int
)	O
+	O
2	int
;	O
int	O
f_len	int
=	O
field_len	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
L_mchlp	O
:	O
if	O
(	O
(	O
k_pos	int
)	O
>=	O
(	O
k_len	int
)	O
)	O
if	O
(	O
(	O
f_len	int
)	O
>	O
0	int
)	O
{	O
pkt_pack	O
(	O
pkt	*(int)
,	O
pastp	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	*(int)
,	O
match	O
,	O
b_pos	int
,	O
k_len	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	*(int)
,	O
matchend	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s2: blk past end %ld %d\n"	*(char)
,	O
"blk_find_pos"	*(char)
,	O
blk_id	O
(	O
blk	*(char)
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
(	O
f_len	int
)	O
<=	O
0	int
)	O
||	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	*(char)
)	O
)	O
[	O
i	int
]	O
)	O
)	O
<	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
key_str	*(char)
)	O
)	O
[	O
k_pos	int
]	O
)	O
)	O
)	O
)	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
int	O
T_b_pos	int
=	O
next_cnvpair	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
p_pos	int
=	O
b_pos	int
;	O
b_pos	int
=	O
T_b_pos	int
;	O
goto	O
L_chknxt	O
;	O
}	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	*(int)
,	O
pastend	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s3: blk past end %ld %d\n"	*(char)
,	O
"blk_find_pos"	*(char)
,	O
blk_id	O
(	O
blk	*(char)
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	*(char)
)	O
)	O
[	O
i	int
]	O
)	O
)	O
>	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
key_str	*(char)
)	O
)	O
[	O
k_pos	int
]	O
)	O
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	*(int)
,	O
(	O
(	O
k_pos	int
)	O
>	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
?	O
pastp	O
:	O
qpastp	O
)	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
k_pos	int
=	O
(	O
k_pos	int
)	O
+	O
1	int
;	O
{	O
i	int
=	O
1	int
+	O
(	O
i	int
)	O
;	O
f_len	int
=	O
(	O
f_len	int
)	O
-	O
1	int
;	O
goto	O
L_mchlp	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
chain_find	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(char),int,*(int))->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
int	O
accmode	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_len	int
,	O
int	O
*	O
pkt	*(int)
)	O
{	O
L_chain_find	O
:	O
{	O
unsigned	O
char	O
*	O
blk	*(char)
=	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
if	O
(	O
!	O
(	O
blk_find_pos	(*(char),*(char),int,*(int))->(int)
(	O
blk	*(char)
,	O
key_str	*(char)
,	O
k_len	int
,	O
pkt	*(int)
)	O
)	O
)	O
{	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accmode	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	*(int)
)	O
)	O
==	O
(	O
matchend	O
)	O
)	O
||	O
(	O
(	O
pkt_match_type	O
(	O
pkt	*(int)
)	O
)	O
==	O
(	O
pastend	O
)	O
)	O
)	O
)	O
return	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
else	O
if	O
(	O
end_of_chain_P	O
(	O
blk	*(char)
)	O
)	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s: matched or past end of chain %ld:%ld\n"	*(char)
,	O
"chain_find"	*(char)
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
,	O
ent_id	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
)	O
;	O
pkt_set_match_type	O
(	O
pkt	*(int)
,	O
qpastp	O
)	O
;	O
return	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
}	O
else	O
{	O
chains_to_next	int
=	O
1	int
+	O
(	O
chains_to_next	int
)	O
;	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
switch_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,long,int)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accmode	int
,	O
blk_nxt_id	O
(	O
blk	*(char)
)	O
,	O
accmode	int
)	O
;	O
if	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
goto	O
L_chain_find	O
;	O
else	O
return	O
0	int
;	O
}	O
}	O
}	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
find_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,int,*(char),int)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
int	O
desired_level	int
,	O
int	O
last_level	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_len	int
)	O
{	O
L_find_ent	O
:	O
if	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
if	O
(	O
ents_ent_update_access_P	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,int)->(int)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accnone	O
,	O
accread	O
)	O
)	O
{	O
unsigned	O
char	O
*	O
blk	*(char)
=	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
int	O
blvl	int
=	O
blk_level	O
(	O
blk	*(char)
)	O
;	O
if	O
(	O
(	O
blvl	int
)	O
==	O
(	O
desired_level	int
)	O
)	O
return	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
else	O
if	O
(	O
(	O
blvl	int
)	O
<	O
(	O
desired_level	int
)	O
)	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< bad blk level %d (des=%d) in %ld:%ld\n"	*(char)
,	O
blvl	int
,	O
desired_level	int
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
,	O
ent_id	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
last_level	int
)	O
>=	O
0	int
)	O
&&	O
(	O
(	O
blvl	int
)	O
!=	O
(	O
(	O
last_level	int
)	O
-	O
1	int
)	O
)	O
)	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< bad blk level %d last=%d in %ld:%ld\n"	*(char)
,	O
blvl	int
,	O
last_level	int
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
,	O
ent_id	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
pkt	*(int)
[	O
pkt_size	int
]	O
;	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
chain_find	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(char),int,*(int))->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
,	O
key_str	*(char)
,	O
k_len	int
,	O
pkt	*(int)
)	O
;	O
if	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
{	O
int	O
pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
)	O
;	O
blk	*(char)
=	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
switch	O
(	O
pkt_match_type	O
(	O
pkt	*(int)
)	O
)	O
{	O
case	O
qpastp	O
:	O
case	O
pastp	O
:	O
;	O
break	O
;	O
case	O
match	O
:	O
if	O
(	O
(	O
blk_end	O
(	O
blk	*(char)
)	O
)	O
==	O
(	O
pos	int
)	O
)	O
{	O
pos	int
=	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
;	O
}	O
else	O
pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
pos	int
)	O
;	O
break	O
;	O
default	O
:	O
pos	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
(	O
pos	int
)	O
)	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s: bad-MATCH-TYPE %d blk %ld:%ld\n"	*(char)
,	O
"find_ent"	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
,	O
ent_id	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
)	O
;	O
{	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
switch_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,long,int)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
,	O
(	O
(	O
blk_end	O
(	O
blk	*(char)
)	O
)	O
==	O
(	O
pos	int
)	O
?	O
(	O
end_of_chain_P	O
(	O
blk	*(char)
)	O
?	O
str2long	(*(char),int)->(long)
(	O
blk	*(char)
,	O
-	O
6	int
+	O
(	O
pos	int
)	O
)	O
:	O
blk_nxt_id	O
(	O
blk	*(char)
)	O
)	O
:	O
str2long	(*(char),int)->(long)
(	O
blk	*(char)
,	O
1	int
+	O
(	O
pos	int
)	O
)	O
)	O
,	O
accnone	O
)	O
;	O
last_level	int
=	O
(	O
(	O
blk_end	O
(	O
blk	*(char)
)	O
)	O
==	O
(	O
pos	int
)	O
)	O
&&	O
(	O
!	O
(	O
end_of_chain_P	O
(	O
blk	*(char)
)	O
)	O
)	O
?	O
(	O
blk_level	O
(	O
blk	*(char)
)	O
)	O
+	O
1	int
:	O
blk_level	O
(	O
blk	*(char)
)	O
;	O
goto	O
L_find_ent	O
;	O
}	O
}	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
else	O
return	O
0	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
blk_prev_key	(*(char),int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
pos	int
)	O
{	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
int	O
p_pos	int
=	O
0	int
;	O
while	O
(	O
!	O
(	O
(	O
b_pos	int
)	O
>=	O
(	O
pos	int
)	O
)	O
)	O
{	O
{	O
int	O
T_b_pos	int
=	O
next_cnvpair	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
p_pos	int
=	O
b_pos	int
;	O
b_pos	int
=	O
T_b_pos	int
;	O
}	O
}	O
if	O
(	O
(	O
b_pos	int
)	O
>	O
(	O
pos	int
)	O
)	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s: blk past end %ld %d\n"	*(char)
,	O
"blk_prev_key"	*(char)
,	O
blk_id	O
(	O
blk	*(char)
)	O
,	O
p_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
return	O
p_pos	int
;	O
}	O
}	O
int	O
get_this_val	(*(char),int,*(char))->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
ans_str	*(char)
)	O
{	O
b_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
{	O
int	O
alen	int
=	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
(	O
b_pos	int
)	O
+	O
1	int
+	O
(	O
alen	int
)	O
,	O
ans_str	*(char)
,	O
0	int
)	O
;	O
return	O
alen	int
;	O
}	O
}	O
int	O
get_this_key	(*(char),int,*(char),*(char),*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(int))->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
unsigned	O
char	O
*	O
ans_str	*(char)
,	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
int	O
k_len	int
,	O
int	O
*	O
pkt	*(int)
)	O
{	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	*(char)
)	O
;	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
int	O
f_pos	int
=	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
int	O
f_siz	int
=	O
field_len	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
int	O
alen	int
=	O
(	O
f_pos	int
)	O
+	O
(	O
f_siz	int
)	O
;	O
if	O
(	O
(	O
key_str	*(char)
)	O
!=	O
(	O
ans_str	*(char)
)	O
)	O
subbytes_move	O
(	O
key_str	*(char)
,	O
0	int
,	O
f_pos	int
,	O
ans_str	*(char)
,	O
0	int
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
2	int
,	O
(	O
b_pos	int
)	O
+	O
2	int
+	O
(	O
f_siz	int
)	O
,	O
ans_str	*(char)
,	O
f_pos	int
)	O
;	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
)	O
;	O
return	O
alen	int
;	O
}	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
!=	O
(	O
b_end	int
)	O
)	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s: blk past end %ld %d\n"	*(char)
,	O
"chain_next"	*(char)
,	O
blk_id	O
(	O
blk	*(char)
)	O
,	O
s_pos	int
)	O
)	O
;	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
)	O
;	O
return	O
strangerr	O
;	O
}	O
else	O
if	O
(	O
end_of_chain_P	O
(	O
blk	*(char)
)	O
)	O
{	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
)	O
;	O
return	O
notpres	O
;	O
}	O
else	O
{	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
switch_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,long,int)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
,	O
blk_nxt_id	O
(	O
blk	*(char)
)	O
,	O
accread	O
)	O
;	O
if	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
chain_find	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(char),int,*(int))->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
,	O
key_str	*(char)
,	O
k_len	int
,	O
pkt	*(int)
)	O
;	O
if	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
return	O
chain_next	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),*(char),int,*(char),*(int))->(int)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
key_str	*(char)
,	O
k_len	int
,	O
ans_str	*(char)
,	O
pkt	*(int)
)	O
;	O
else	O
return	O
unkerr	O
;	O
}	O
}	O
}	O
int	O
chain_next	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),*(char),int,*(char),*(int))->(int)
(	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
ans_str	*(char)
,	O
int	O
*	O
pkt	*(int)
)	O
{	O
pkt_set_blk_to_cache	O
(	O
pkt	*(int)
,	O
ent_id	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
;	O
switch	O
(	O
pkt_match_type	O
(	O
pkt	*(int)
)	O
)	O
{	O
case	O
pastp	O
:	O
case	O
qpastp	O
:	O
return	O
get_this_key	(*(char),int,*(char),*(char),*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(int))->(int)
(	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
key_str	*(char)
,	O
ans_str	*(char)
,	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
k_len	int
,	O
pkt	*(int)
)	O
;	O
case	O
match	O
:	O
return	O
get_this_key	(*(char),int,*(char),*(char),*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(int))->(int)
(	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
next_cnvpair	O
(	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
,	O
key_str	*(char)
,	O
ans_str	*(char)
,	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
k_len	int
,	O
pkt	*(int)
)	O
;	O
default	O
:	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
)	O
;	O
return	O
notpres	O
;	O
}	O
}	O
int	O
blk_change_size	(*(char),int,int,int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
loc	int
,	O
int	O
growth	int
,	O
int	O
bsiz	int
)	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
growth	int
)	O
)	O
return	O
!	O
0	int
;	O
else	O
if	O
(	O
(	O
(	O
b_end	int
)	O
+	O
(	O
growth	int
)	O
)	O
>	O
(	O
bsiz	int
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
0	int
>	O
(	O
growth	int
)	O
)	O
{	O
subbytes_move_left	O
(	O
blk	*(char)
,	O
loc	int
,	O
b_end	int
,	O
blk	*(char)
,	O
(	O
loc	int
)	O
+	O
(	O
growth	int
)	O
)	O
;	O
blk_set_end	O
(	O
blk	*(char)
,	O
(	O
b_end	int
)	O
+	O
(	O
growth	int
)	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
subbytes_move_right	O
(	O
blk	*(char)
,	O
loc	int
,	O
b_end	int
,	O
blk	*(char)
,	O
(	O
loc	int
)	O
+	O
(	O
growth	int
)	O
)	O
;	O
blk_set_end	O
(	O
blk	*(char)
,	O
(	O
b_end	int
)	O
+	O
(	O
growth	int
)	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
}	O
int	O
blk_remove_key_and_val	(*(char),int,int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
b_pos	int
,	O
int	O
bsiz	int
)	O
{	O
int	O
nb_pos	int
=	O
next_cnvpair	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
if	O
(	O
(	O
field_len	O
(	O
blk	*(char)
,	O
nb_pos	int
)	O
)	O
>	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
)	O
{	O
int	O
delk_pos	int
=	O
(	O
field_len	O
(	O
blk	*(char)
,	O
nb_pos	int
)	O
)	O
-	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
;	O
set_field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
,	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
nb_pos	int
)	O
)	O
)	O
+	O
(	O
delk_pos	int
)	O
)	O
;	O
return	O
blk_change_size	(*(char),int,int,int)->(int)
(	O
blk	*(char)
,	O
2	int
+	O
(	O
nb_pos	int
)	O
,	O
(	O
(	O
b_pos	int
)	O
-	O
(	O
nb_pos	int
)	O
)	O
+	O
(	O
delk_pos	int
)	O
,	O
bsiz	int
)	O
;	O
}	O
else	O
return	O
blk_change_size	(*(char),int,int,int)->(int)
(	O
blk	*(char)
,	O
nb_pos	int
,	O
(	O
b_pos	int
)	O
-	O
(	O
nb_pos	int
)	O
,	O
bsiz	int
)	O
;	O
}	O
int	O
defer_insert_updates_P	int
=	O
0	int
;	O
int	O
parent_insert_update	(*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long,int,*(char),int,long)->(int)
(	O
SEGD	struct(int,int,long,*(char),*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),*(struct(*(struct(*`,int,union`)),int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long))),*(struct(*(struct(*`,int,union`)),int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long)
*	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
,	O
long	O
top_id	long
,	O
int	O
level	int
,	O
unsigned	O
char	O
*	O
nkey_str	*(char)
,	O
int	O
nk_len	int
,	O
long	O
n_id	long
)	O
{	O
int	O
pkt	*(int)
[	O
pkt_size	int
]	O
;	O
{	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
find_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,int,*(char),int)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
get_ent	(*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long,int)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
,	O
top_id	long
,	O
accnone	O
)	O
,	O
1	int
+	O
(	O
level	int
)	O
,	O
-	O
1	int
,	O
nkey_str	*(char)
,	O
nk_len	int
)	O
;	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
0	int
;	O
int	O
screw_case_P	int
=	O
0	int
;	O
unsigned	O
char	O
blkidstr	array(char)
[	O
4	int
]	O
;	O
unsigned	O
char	O
*	O
blk	*(char)
=	O
0	int
;	O
if	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
{	O
long2str	(*(char),int,long)->(void)
(	O
blkidstr	array(char)
,	O
0	int
,	O
n_id	long
)	O
;	O
if	O
(	O
ents_ent_update_access_P	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,int)->(int)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
,	O
accwrite	O
)	O
)	O
{	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
chain_find	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(char),int,*(int))->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accwrite	O
,	O
nkey_str	*(char)
,	O
nk_len	int
,	O
pkt	*(int)
)	O
;	O
blk	*(char)
=	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
}	O
else	O
{	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
)	O
;	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
0	int
;	O
}	O
if	O
(	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
&&	O
(	O
at_split_key_pos_P	(*(char),int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
)	O
)	O
{	O
screw_case_P	int
=	O
!	O
0	int
;	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
next_nonempty_ent	(*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
ent_seg	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
blk_nxt_id	O
(	O
blk	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< No next key found for index insert %ld:%ld\n"	*(char)
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
,	O
blk_id	O
(	O
blk	*(char)
)	O
)	O
)	O
;	O
}	O
if	O
(	O
(	O
!	O
(	O
defer_insert_updates_P	int
)	O
)	O
&&	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
&&	O
(	O
(	O
!	O
(	O
screw_case_P	int
)	O
)	O
||	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
&&	O
(	O
chain_put	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),*(char),int,*(char),int,*(int),*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(int)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
nkey_str	*(char)
,	O
nk_len	int
,	O
blkidstr	array(char)
,	O
4	int
,	O
pkt	*(int)
,	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
wcb_sar	int
)	O
)	O
)	O
return	O
!	O
0	int
;	O
else	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"WARNING: %s: couldn't update parent n-id=%ld nk-len=%d\n"	*(char)
,	O
"parent_insert_update"	*(char)
,	O
n_id	long
,	O
nk_len	int
)	O
)	O
;	O
deferred_inserts	int
=	O
1	int
+	O
(	O
deferred_inserts	int
)	O
;	O
if	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accwrite	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
int	O
at_split_key_pos_P	(*(char),int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
pos	int
)	O
{	O
return	O
(	O
blk_end	O
(	O
blk	*(char)
)	O
)	O
==	O
(	O
next_field	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
pos	int
)	O
)	O
)	O
;	O
}	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
next_nonempty_ent	(*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
SEGD	struct(int,int,long,*(char),*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),*(struct(*(struct(*`,int,union`)),int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long))),*(struct(*(struct(*`,int,union`)),int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long)
*	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
,	O
long	O
blknum	long
)	O
{	O
if	O
(	O
(	O
blknum	long
)	O
<=	O
0	int
)	O
return	O
0	int
;	O
else	O
{	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
get_ent	(*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long,int)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
,	O
blknum	long
,	O
accread	O
)	O
;	O
L_loop	O
:	O
if	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
ents_ent_update_access_P	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,int)->(int)
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accread	O
,	O
accwrite	O
)	O
;	O
if	O
(	O
!	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
!	O
(	O
blk_empty_P	O
(	O
ent_blk	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
)	O
)	O
return	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
else	O
if	O
(	O
!	O
(	O
blk_nxt_id	O
(	O
ent_blk	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
)	O
)	O
{	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accwrite	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
switch_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,long,int)->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accwrite	O
,	O
blk_nxt_id	O
(	O
ent_blk	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
,	O
accwrite	O
)	O
;	O
goto	O
L_loop	O
;	O
}	O
}	O
}	O
int	O
recon_this_key	(*(char),int,*(char),int,int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
)	O
{	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
int	O
k_size	int
=	O
0	int
;	O
while	O
(	O
!	O
(	O
(	O
b_pos	int
)	O
>	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
(	O
k_size	int
)	O
>	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
)	O
&&	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	*(char)
)	O
)	O
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
)	O
)	O
<=	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
key_str	*(char)
)	O
)	O
[	O
(	O
k_pos	int
)	O
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
]	O
)	O
)	O
)	O
)	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< bad key sequence %ld @ %d\n"	*(char)
,	O
blk_id	O
(	O
blk	*(char)
)	O
,	O
b_pos	int
)	O
)	O
;	O
k_size	int
=	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
;	O
if	O
(	O
(	O
k_size	int
)	O
>=	O
(	O
k_len	int
)	O
)	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< not-enough-room %d\n"	*(char)
,	O
k_len	int
)	O
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
2	int
,	O
(	O
b_pos	int
)	O
+	O
2	int
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
,	O
key_str	*(char)
,	O
(	O
k_pos	int
)	O
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
)	O
;	O
b_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
if	O
(	O
(	O
b_pos	int
)	O
<	O
(	O
blk_end	O
(	O
blk	*(char)
)	O
)	O
)	O
b_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
{	O
}	O
}	O
return	O
k_size	int
;	O
}	O
}	O
int	O
blk_insert_and_adjust	(*(char),int,int,*(char),int,*(char),int,int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
b_pos	int
,	O
int	O
k_pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
v_len	int
,	O
int	O
bsiz	int
)	O
{	O
{	O
int	O
oldk_pos	int
=	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
int	O
oldilen	int
=	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
int	O
ilen	int
=	O
(	O
k_len	int
)	O
-	O
(	O
oldk_pos	int
)	O
;	O
if	O
(	O
blk_change_size	(*(char),int,int,int)->(int)
(	O
blk	*(char)
,	O
b_pos	int
,	O
2	int
+	O
(	O
(	O
k_len	int
)	O
-	O
(	O
k_pos	int
)	O
)	O
+	O
1	int
+	O
(	O
v_len	int
)	O
,	O
bsiz	int
)	O
)	O
{	O
b_pos	int
=	O
1	int
+	O
(	O
b_pos	int
)	O
;	O
b_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
b_pos	int
,	O
key_str	*(char)
,	O
oldk_pos	int
,	O
ilen	int
)	O
;	O
b_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
b_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
set_field_len	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
(	O
oldilen	int
)	O
-	O
(	O
(	O
k_pos	int
)	O
-	O
(	O
oldk_pos	int
)	O
)	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
int	O
blk_simple_insert	(*(char),int,int,*(char),int,*(char),int,int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
b_pos	int
,	O
int	O
k_pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
v_len	int
,	O
int	O
bsiz	int
)	O
{	O
int	O
ilen	int
=	O
(	O
k_len	int
)	O
-	O
(	O
k_pos	int
)	O
;	O
if	O
(	O
blk_change_size	(*(char),int,int,int)->(int)
(	O
blk	*(char)
,	O
b_pos	int
,	O
3	int
+	O
(	O
v_len	int
)	O
+	O
(	O
ilen	int
)	O
,	O
bsiz	int
)	O
)	O
{	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
b_pos	int
=	O
1	int
+	O
(	O
b_pos	int
)	O
;	O
b_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
b_pos	int
,	O
key_str	*(char)
,	O
k_pos	int
,	O
ilen	int
)	O
;	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
b_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
int	O
blk_change_existing_value	(*(char),int,*(char),int,*(char),int,int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
v_len	int
,	O
int	O
bsiz	int
)	O
{	O
int	O
ov_len	int
=	O
0	int
;	O
int	O
v_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
ov_len	int
=	O
field_len	O
(	O
blk	*(char)
,	O
v_pos	int
)	O
;	O
if	O
(	O
blk_change_size	(*(char),int,int,int)->(int)
(	O
blk	*(char)
,	O
(	O
v_pos	int
)	O
+	O
(	O
ov_len	int
)	O
+	O
1	int
,	O
(	O
v_len	int
)	O
-	O
(	O
ov_len	int
)	O
,	O
bsiz	int
)	O
)	O
{	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
v_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
int	O
val_leaf_split	(*(char),*(char),int,*(char),int,int,*(char),int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
unsigned	O
char	O
*	O
nblk	*(char)
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
v_len	int
)	O
{	O
{	O
int	O
v_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
v_pos	int
)	O
;	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	*(char)
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
b_end	int
)	O
-	O
(	O
s_pos	int
)	O
)	O
>	O
(	O
(	O
v_pos	int
)	O
-	O
(	O
blk_data_start	int
)	O
)	O
)	O
{	O
int	O
m_len	int
=	O
field_len	O
(	O
blk	*(char)
,	O
s_pos	int
)	O
;	O
int	O
f_chr	int
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	*(char)
)	O
)	O
[	O
(	O
s_pos	int
)	O
+	O
2	int
]	O
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
(	O
m_len	int
)	O
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
s_pos	int
)	O
)	O
)	O
)	O
;	O
subbytes_move	O
(	O
key_str	*(char)
,	O
0	int
,	O
m_len	int
,	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
(	O
s_pos	int
)	O
+	O
2	int
,	O
b_end	int
,	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
(	O
m_len	int
)	O
+	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	*(char)
,	O
(	O
(	O
b_end	int
)	O
-	O
(	O
s_pos	int
)	O
)	O
+	O
(	O
m_len	int
)	O
+	O
(	O
blk_data_start	int
)	O
)	O
;	O
b_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
v_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
blk	*(char)
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
=	O
f_chr	int
;	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
m_len	int
)	O
;	O
}	O
else	O
{	O
int	O
nb_pos	int
=	O
(	O
blk_data_start	int
)	O
+	O
1	int
;	O
nb_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
nblk	*(char)
,	O
nb_pos	int
,	O
key_str	*(char)
,	O
0	int
,	O
k_len	int
)	O
;	O
nb_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
nblk	*(char)
,	O
nb_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
s_pos	int
,	O
b_end	int
,	O
nblk	*(char)
,	O
nb_pos	int
)	O
;	O
blk_set_end	O
(	O
nblk	*(char)
,	O
(	O
nb_pos	int
)	O
+	O
(	O
(	O
b_end	int
)	O
-	O
(	O
s_pos	int
)	O
)	O
)	O
;	O
}	O
set_field_len	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
1	int
)	O
;	O
blk_set_end	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
3	int
)	O
;	O
return	O
b_pos	int
;	O
}	O
}	O
int	O
qpastp_leaf_split	(*(char),*(char),int,*(char),int,int,*(char),int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
unsigned	O
char	O
*	O
nblk	*(char)
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
v_len	int
)	O
{	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	*(char)
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
>	O
(	O
(	O
b_pos	int
)	O
-	O
(	O
blk_data_start	int
)	O
)	O
)	O
{	O
int	O
m_len	int
=	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
int	O
f_chr	int
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	*(char)
)	O
)	O
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
(	O
m_len	int
)	O
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
)	O
;	O
subbytes_move	O
(	O
key_str	*(char)
,	O
0	int
,	O
m_len	int
,	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
2	int
,	O
b_end	int
,	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
(	O
m_len	int
)	O
+	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	*(char)
,	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
+	O
(	O
m_len	int
)	O
+	O
(	O
blk_data_start	int
)	O
)	O
;	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
b_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
key_str	*(char)
,	O
k_pos	int
,	O
(	O
k_len	int
)	O
-	O
(	O
k_pos	int
)	O
)	O
;	O
b_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
b_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
blk	*(char)
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
=	O
f_chr	int
;	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
m_len	int
)	O
;	O
}	O
else	O
{	O
int	O
nb_pos	int
=	O
(	O
blk_data_start	int
)	O
+	O
1	int
;	O
nb_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
nblk	*(char)
,	O
nb_pos	int
,	O
key_str	*(char)
,	O
0	int
,	O
k_len	int
)	O
;	O
nb_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
nblk	*(char)
,	O
nb_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
b_end	int
,	O
nblk	*(char)
,	O
nb_pos	int
)	O
;	O
blk_set_end	O
(	O
nblk	*(char)
,	O
(	O
nb_pos	int
)	O
+	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
)	O
;	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
blk	*(char)
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
key_str	*(char)
)	O
)	O
[	O
k_pos	int
]	O
)	O
;	O
}	O
set_field_len	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
1	int
)	O
;	O
blk_set_end	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
3	int
)	O
;	O
return	O
b_pos	int
;	O
}	O
}	O
int	O
pastp_leaf_split	(*(char),*(char),int,*(char),int,int,*(char),int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
unsigned	O
char	O
*	O
nblk	*(char)
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
v_len	int
)	O
{	O
{	O
int	O
m_len	int
=	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
;	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	*(char)
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
>	O
(	O
(	O
b_pos	int
)	O
-	O
(	O
blk_data_start	int
)	O
)	O
)	O
{	O
int	O
f_chr	int
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	*(char)
)	O
)	O
[	O
(	O
b_pos	int
)	O
+	O
2	int
+	O
(	O
(	O
k_pos	int
)	O
-	O
(	O
field_len	O
(	O
blk	*(char)
,	O
b_pos	int
)	O
)	O
)	O
]	O
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
(	O
m_len	int
)	O
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
)	O
;	O
subbytes_move	O
(	O
key_str	*(char)
,	O
0	int
,	O
m_len	int
,	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
2	int
,	O
b_end	int
,	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
(	O
m_len	int
)	O
+	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	*(char)
,	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
+	O
(	O
m_len	int
)	O
+	O
(	O
blk_data_start	int
)	O
)	O
;	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
m_len	int
)	O
;	O
b_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
key_str	*(char)
,	O
m_len	int
,	O
(	O
k_len	int
)	O
-	O
(	O
m_len	int
)	O
)	O
;	O
b_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
b_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
blk	*(char)
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
=	O
f_chr	int
;	O
set_field_len	O
(	O
blk	*(char)
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
}	O
else	O
{	O
int	O
nb_pos	int
=	O
(	O
blk_data_start	int
)	O
+	O
1	int
;	O
int	O
c_pos	int
=	O
(	O
b_pos	int
)	O
+	O
2	int
+	O
(	O
(	O
k_pos	int
)	O
-	O
(	O
m_len	int
)	O
)	O
;	O
nb_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
nblk	*(char)
,	O
nb_pos	int
,	O
key_str	*(char)
,	O
0	int
,	O
k_len	int
)	O
;	O
nb_pos	int
=	O
set_field	(*(char),int,*(char),int,int)->(int)
(	O
nblk	*(char)
,	O
nb_pos	int
,	O
val_str	*(char)
,	O
0	int
,	O
v_len	int
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
nb_pos	int
,	O
k_pos	int
)	O
;	O
set_field_len	O
(	O
nblk	*(char)
,	O
(	O
nb_pos	int
)	O
+	O
1	int
,	O
(	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
+	O
(	O
m_len	int
)	O
)	O
-	O
(	O
k_pos	int
)	O
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
c_pos	int
,	O
b_end	int
,	O
nblk	*(char)
,	O
(	O
nb_pos	int
)	O
+	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	*(char)
,	O
(	O
nb_pos	int
)	O
+	O
2	int
+	O
(	O
(	O
b_end	int
)	O
-	O
(	O
c_pos	int
)	O
)	O
)	O
;	O
}	O
set_field_len	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
1	int
)	O
;	O
blk_set_end	O
(	O
blk	*(char)
,	O
(	O
b_pos	int
)	O
+	O
3	int
)	O
;	O
return	O
b_pos	int
;	O
}	O
}	O
int	O
dummy_leaf_split	(*(char),*(char),int,*(char),int,int,*(char),int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
unsigned	O
char	O
*	O
nblk	*(char)
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
v_len	int
)	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s: bad-MATCH-TYPE blk %ld\n"	*(char)
,	O
"dummy_leaf_split"	*(char)
,	O
blk_id	O
(	O
blk	*(char)
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int_function	*(()->(int))
select_split_fun	(int)->(*(()->(int)))
(	O
int	O
type	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
pastp	O
:	O
return	O
pastp_leaf_split	(*(char),*(char),int,*(char),int,int,*(char),int)->(int)
;	O
case	O
qpastp	O
:	O
return	O
qpastp_leaf_split	(*(char),*(char),int,*(char),int,int,*(char),int)->(int)
;	O
case	O
match	O
:	O
return	O
val_leaf_split	(*(char),*(char),int,*(char),int,int,*(char),int)->(int)
;	O
default	O
:	O
return	O
dummy_leaf_split	(*(char),*(char),int,*(char),int,int,*(char),int)->(int)
;	O
}	O
}	O
int	O
chain_put	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),*(char),int,*(char),int,*(int),*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(int)
(	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	*(char)
,	O
int	O
v_len	int
,	O
int	O
*	O
pkt	*(int)
,	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
int	O
wcb	int
)	O
{	O
{	O
unsigned	O
char	O
*	O
blk	*(char)
=	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
int	O
blklev	int
=	O
blk_level	O
(	O
blk	*(char)
)	O
;	O
int	O
index_P	int
=	O
(	O
blklev	int
)	O
>	O
(	O
leaf	int
)	O
;	O
long	O
root_id	long
=	O
blk_top_id	O
(	O
blk	*(char)
)	O
;	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
0	int
;	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
0	int
;	O
SEGD	struct(int,int,long,*(char),*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),*(struct(*(struct(*`,int,union`)),int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long))),*(struct(*(struct(*`,int,union`)),int,union(struct(int,int,int,int,int,short,short,struct`),array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long)
*	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
=	O
ent_seg	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
int	O
bsiz	int
=	O
seg_bsiz	O
(	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
)	O
;	O
int	O
result_P	int
=	O
0	int
;	O
int	O
split_P	int
=	O
0	int
;	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
nkey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
int	O
nkey_pos	int
=	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
;	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
okey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
int	O
okey_pos	int
=	O
blk_data_start	int
;	O
long	O
n_id	long
=	O
0x0L	int
;	O
int	O
s_pos	int
=	O
0	int
;	O
unsigned	O
char	O
split_str	array(char)
[	O
0x100	int
]	O
;	O
int	O
s_len	int
=	O
0	int
;	O
pkt_set_blk_to_cache	O
(	O
pkt	*(int)
,	O
ent_id	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
;	O
if	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	*(int)
)	O
)	O
==	O
(	O
pastp	O
)	O
)	O
&&	O
(	O
blk_insert_and_adjust	(*(char),int,int,*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
pkt_key_pos	O
(	O
pkt	*(int)
)	O
,	O
key_str	*(char)
,	O
k_len	int
,	O
val_str	*(char)
,	O
v_len	int
,	O
bsiz	int
)	O
)	O
)	O
{	O
result_P	int
=	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	*(int)
)	O
)	O
==	O
(	O
qpastp	O
)	O
)	O
&&	O
(	O
blk_simple_insert	(*(char),int,int,*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
pkt_key_pos	O
(	O
pkt	*(int)
)	O
,	O
key_str	*(char)
,	O
k_len	int
,	O
val_str	*(char)
,	O
v_len	int
,	O
bsiz	int
)	O
)	O
)	O
{	O
result_P	int
=	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	*(int)
)	O
)	O
==	O
(	O
match	O
)	O
)	O
&&	O
(	O
blk_change_existing_value	(*(char),int,*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
key_str	*(char)
,	O
k_len	int
,	O
val_str	*(char)
,	O
v_len	int
,	O
bsiz	int
)	O
)	O
)	O
{	O
result_P	int
=	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
create_new_blk_ent	(*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
)	O
,	O
!	O
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
)	O
;	O
else	O
{	O
split_P	int
=	O
!	O
0	int
;	O
{	O
unsigned	O
char	O
*	O
nblk	*(char)
=	O
ent_blk	O
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
n_id	long
=	O
ent_id	O
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
init_next_blk	(*(char),*(char))->(void)
(	O
blk	*(char)
,	O
nblk	*(char)
)	O
;	O
block_splits	int
=	O
(	O
block_splits	int
)	O
+	O
1	int
;	O
s_pos	int
=	O
(	O
*	O
(	O
select_split_fun	(int)->(*(()->(int)))
(	O
pkt_match_type	O
(	O
pkt	*(int)
)	O
)	O
)	O
)	O
(	O
blk	*(char)
,	O
nblk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
key_str	*(char)
,	O
pkt_key_pos	O
(	O
pkt	*(int)
)	O
,	O
k_len	int
,	O
val_str	*(char)
,	O
v_len	int
)	O
;	O
s_len	int
=	O
1	int
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
s_pos	int
)	O
)	O
;	O
subbytes_move	O
(	O
nblk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
,	O
1	int
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
s_pos	int
)	O
)	O
+	O
(	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
,	O
split_str	array(char)
,	O
0	int
)	O
;	O
if	O
(	O
index_P	int
)	O
{	O
okey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
if	O
(	O
(	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
!=	O
(	O
s_pos	int
)	O
)	O
{	O
split_index_inserts	int
=	O
1	int
+	O
(	O
split_index_inserts	int
)	O
;	O
}	O
else	O
{	O
okey_pos	int
=	O
next_cnvpair	O
(	O
nblk	*(char)
,	O
blk_data_start	int
)	O
;	O
nkey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
nkey_pos	int
=	O
blk_data_start	int
;	O
}	O
}	O
if	O
(	O
(	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
==	O
(	O
s_pos	int
)	O
)	O
pkt_set_blk_to_cache	O
(	O
pkt	*(int)
,	O
ent_id	O
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
;	O
if	O
(	O
root_P	O
(	O
blk	*(char)
)	O
)	O
{	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
create_new_blk_ent	(*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
)	O
;	O
if	O
(	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
{	O
reroot	(*(char),*(char),long,int)->(void)
(	O
blk	*(char)
,	O
ent_blk	O
(	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
ent_id	O
(	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
seg_bsiz	O
(	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
)	O
)	O
;	O
if	O
(	O
(	O
nkey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
==	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
{	O
nkey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
pkt_set_blk_to_cache	O
(	O
pkt	*(int)
,	O
ent_id	O
(	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
;	O
}	O
}	O
}	O
result_P	int
=	O
!	O
0	int
;	O
}	O
}	O
if	O
(	O
(	O
result_P	int
)	O
&&	O
(	O
index_P	int
)	O
)	O
{	O
if	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
{	O
index_screw_case	int
=	O
1	int
+	O
(	O
index_screw_case	int
)	O
;	O
okey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
;	O
okey_pos	int
=	O
blk_data_start	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
split_P	int
)	O
)	O
okey_pos	int
=	O
next_cnvpair	O
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
;	O
{	O
unsigned	O
char	O
tmpstr	array(char)
[	O
4	int
]	O
;	O
int	O
oldv_pos	int
=	O
(	O
next_field	O
(	O
ent_blk	O
(	O
okey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
(	O
okey_pos	int
)	O
+	O
1	int
)	O
)	O
+	O
1	int
;	O
int	O
newv_pos	int
=	O
(	O
next_field	O
(	O
ent_blk	O
(	O
nkey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
(	O
nkey_pos	int
)	O
+	O
1	int
)	O
)	O
+	O
1	int
;	O
subbytes_move_left	O
(	O
ent_blk	O
(	O
okey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
oldv_pos	int
,	O
(	O
oldv_pos	int
)	O
+	O
4	int
,	O
tmpstr	array(char)
,	O
0	int
)	O
;	O
subbytes_move_left	O
(	O
ent_blk	O
(	O
nkey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
newv_pos	int
,	O
(	O
newv_pos	int
)	O
+	O
4	int
,	O
ent_blk	O
(	O
okey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
oldv_pos	int
)	O
;	O
subbytes_move_left	O
(	O
tmpstr	array(char)
,	O
0	int
,	O
4	int
,	O
ent_blk	O
(	O
nkey_ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
newv_pos	int
)	O
;	O
}	O
}	O
if	O
(	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
{	O
ents_ent_write	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))->(int)
(	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
nrent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accwrite	O
)	O
;	O
}	O
if	O
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
{	O
ents_ent_write	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))->(int)
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
ents_ent_update_access_P	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,int)->(int)
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accwrite	O
,	O
accnone	O
)	O
;	O
}	O
if	O
(	O
result_P	int
)	O
{	O
ent_set_dty	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
!	O
0	int
)	O
;	O
if	O
(	O
(	O
split_P	int
)	O
||	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
||	O
(	O
(	O
wcb_sap	int
)	O
&	O
(	O
wcb	int
)	O
)	O
)	O
ents_ent_write	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))->(int)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accwrite	O
)	O
;	O
}	O
if	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
{	O
ent_set_dty	O
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
!	O
0	int
)	O
;	O
ents_ent_write	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))->(int)
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
xent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accwrite	O
)	O
;	O
}	O
if	O
(	O
split_P	int
)	O
parent_insert_update	(*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)),long,int,*(char),int,long)->(int)
(	O
seg	*(struct(int,int,long,*(char),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),long,long,int,int)),*(struct(*(struct`),int,union(struct`,array(char),long))),*(struct(*(struct`),int,union(struct`,array(char),long))),int,*(long),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long))
,	O
root_id	long
,	O
blklev	int
,	O
split_str	array(char)
,	O
s_len	int
,	O
n_id	long
)	O
;	O
if	O
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accnone	O
)	O
;	O
return	O
result_P	int
;	O
}	O
}	O
