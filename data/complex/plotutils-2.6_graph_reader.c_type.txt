struct	O
ReaderStruct	struct(enum(int,int),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)
{	O
bool	enum(int,int)
transpose_axes	enum(int,int)
;	O
int	O
log_axis	int
;	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
data_type	enum(int,int,int,int,int,int)
format_type	enum(int,int,int,int,int,int)
;	O
bool	enum(int,int)
auto_abscissa	enum(int,int)
;	O
double	O
delta_x	double
;	O
double	O
initial_abscissa	double
;	O
bool	enum(int,int)
auto_bump	enum(int,int)
;	O
int	O
symbol	int
;	O
double	O
symbol_size	double
;	O
const	O
char	O
*	O
symbol_font_name	*(char)
;	O
int	O
linemode	int
;	O
double	O
line_width	double
;	O
double	O
fill_fraction	double
;	O
bool	enum(int,int)
use_color	enum(int,int)
;	O
bool	enum(int,int)
need_break	enum(int,int)
;	O
double	O
abscissa	double
;	O
}	O
;	O
typedef	O
enum	O
{	O
IN_PROGRESS	int
,	O
ENDED_BY_EOF	int
,	O
ENDED_BY_DATASET_TERMINATOR	int
,	O
ENDED_BY_MODE_CHANGE	int
}	O
dataset_status_t	enum(int,int,int,int)
;	O
static	O
bool	enum(int,int)
skip_some_whitespace	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
static	O
dataset_status_t	enum(int,int,int,int)
read_and_plot_dataset	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Multigrapher	struct
*	O
multigrapher	*(struct)
)	O
;	O
static	O
dataset_status_t	enum(int,int,int,int)
read_dataset	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))),*(int),*(int))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
*	O
p	*(void)
,	O
int	O
*	O
length	long
,	O
int	O
*	O
no_of_points	*(int)
)	O
;	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point_ascii	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point_ascii_errorbar	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point_binary	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point_gnuplot	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
static	O
void	O
reset_reader	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)))->(void)
(	O
Reader	struct
*	O
reader	*(struct)
)	O
;	O
static	O
void	O
skip_all_whitespace	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
Reader	struct
*	O
new_reader	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,enum(int,int),int,double,*(char),int,double,double,enum(int,int))->(*(struct))
(	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
data_type	enum(int,int,int,int,int,int)
format_type	enum(int,int,int,int,int,int)
,	O
bool	enum(int,int)
auto_abscissa	enum(int,int)
,	O
double	O
delta_x	double
,	O
double	O
abscissa	double
,	O
bool	enum(int,int)
transpose_axes	enum(int,int)
,	O
int	O
log_axis	int
,	O
bool	enum(int,int)
auto_bump	enum(int,int)
,	O
int	O
symbol	int
,	O
double	O
symbol_size	double
,	O
const	O
char	O
*	O
symbol_font_name	*(char)
,	O
int	O
linemode	int
,	O
double	O
line_width	double
,	O
double	O
fill_fraction	double
,	O
bool	enum(int,int)
use_color	enum(int,int)
)	O
{	O
Reader	struct
*	O
reader	*(struct)
;	O
reader	*(struct)
=	O
(	O
Reader	struct
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
Reader	struct
)	O
)	O
;	O
reader	*(struct)
->	O
need_break	enum(int,int)
=	O
true	int
;	O
reader	*(struct)
->	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
reader	*(struct)
->	O
format_type	enum(int,int,int,int,int,int)
=	O
format_type	enum(int,int,int,int,int,int)
;	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
=	O
auto_abscissa	enum(int,int)
;	O
reader	*(struct)
->	O
delta_x	double
=	O
delta_x	double
;	O
reader	*(struct)
->	O
initial_abscissa	double
=	O
abscissa	double
;	O
reader	*(struct)
->	O
abscissa	double
=	O
reader	*(struct)
->	O
initial_abscissa	double
;	O
reader	*(struct)
->	O
transpose_axes	enum(int,int)
=	O
transpose_axes	enum(int,int)
;	O
reader	*(struct)
->	O
log_axis	int
=	O
log_axis	int
;	O
reader	*(struct)
->	O
auto_bump	enum(int,int)
=	O
auto_bump	enum(int,int)
;	O
reader	*(struct)
->	O
symbol	int
=	O
symbol	int
;	O
reader	*(struct)
->	O
symbol_size	double
=	O
symbol_size	double
;	O
reader	*(struct)
->	O
symbol_font_name	*(char)
=	O
symbol_font_name	*(char)
;	O
reader	*(struct)
->	O
linemode	int
=	O
linemode	int
;	O
reader	*(struct)
->	O
line_width	double
=	O
line_width	double
;	O
reader	*(struct)
->	O
fill_fraction	double
=	O
fill_fraction	double
;	O
reader	*(struct)
->	O
use_color	enum(int,int)
=	O
use_color	enum(int,int)
;	O
return	O
reader	*(struct)
;	O
}	O
void	O
delete_reader	(*(struct))->(void)
(	O
Reader	struct
*	O
reader	*(struct)
)	O
{	O
free	(*(void))->(void)
(	O
reader	*(struct)
)	O
;	O
return	O
;	O
}	O
void	O
alter_reader_parameters	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,int,double,*(char),int,double,double,enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int),enum(int,int))->(void)
(	O
Reader	struct
*	O
reader	*(struct)
,	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
data_type	enum(int,int,int,int,int,int)
format_type	enum(int,int,int,int,int,int)
,	O
bool	enum(int,int)
auto_abscissa	enum(int,int)
,	O
double	O
delta_x	double
,	O
double	O
abscissa	double
,	O
int	O
symbol	int
,	O
double	O
symbol_size	double
,	O
const	O
char	O
*	O
symbol_font_name	*(char)
,	O
int	O
linemode	int
,	O
double	O
line_width	double
,	O
double	O
fill_fraction	double
,	O
bool	enum(int,int)
use_color	enum(int,int)
,	O
bool	enum(int,int)
new_symbol	enum(int,int)
,	O
bool	enum(int,int)
new_symbol_size	enum(int,int)
,	O
bool	enum(int,int)
new_symbol_font_name	enum(int,int)
,	O
bool	enum(int,int)
new_linemode	enum(int,int)
,	O
bool	enum(int,int)
new_line_width	enum(int,int)
,	O
bool	enum(int,int)
new_fill_fraction	enum(int,int)
,	O
bool	enum(int,int)
new_use_color	enum(int,int)
)	O
{	O
reader	*(struct)
->	O
need_break	enum(int,int)
=	O
true	int
;	O
reader	*(struct)
->	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
reader	*(struct)
->	O
format_type	enum(int,int,int,int,int,int)
=	O
format_type	enum(int,int,int,int,int,int)
;	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
=	O
auto_abscissa	enum(int,int)
;	O
reader	*(struct)
->	O
delta_x	double
=	O
delta_x	double
;	O
reader	*(struct)
->	O
initial_abscissa	double
=	O
abscissa	double
;	O
reader	*(struct)
->	O
abscissa	double
=	O
reader	*(struct)
->	O
initial_abscissa	double
;	O
if	O
(	O
new_symbol	enum(int,int)
)	O
reader	*(struct)
->	O
symbol	int
=	O
symbol	int
;	O
if	O
(	O
new_symbol_size	enum(int,int)
)	O
reader	*(struct)
->	O
symbol_size	double
=	O
symbol_size	double
;	O
if	O
(	O
new_symbol_font_name	enum(int,int)
)	O
reader	*(struct)
->	O
symbol_font_name	*(char)
=	O
symbol_font_name	*(char)
;	O
if	O
(	O
new_linemode	enum(int,int)
)	O
reader	*(struct)
->	O
linemode	int
=	O
linemode	int
;	O
if	O
(	O
new_line_width	enum(int,int)
)	O
reader	*(struct)
->	O
line_width	double
=	O
line_width	double
;	O
if	O
(	O
new_fill_fraction	enum(int,int)
)	O
reader	*(struct)
->	O
fill_fraction	double
=	O
fill_fraction	double
;	O
if	O
(	O
new_use_color	enum(int,int)
)	O
reader	*(struct)
->	O
use_color	enum(int,int)
=	O
use_color	enum(int,int)
;	O
return	O
;	O
}	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
{	O
dataset_status_t	enum(int,int,int,int)
status	enum(int,int,int,int)
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol	int
=	O
reader	*(struct)
->	O
symbol	int
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol_size	double
=	O
reader	*(struct)
->	O
symbol_size	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
symbol_font_name	*(char)
=	O
reader	*(struct)
->	O
symbol_font_name	*(char)
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
linemode	int
=	O
reader	*(struct)
->	O
linemode	int
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
line_width	double
=	O
reader	*(struct)
->	O
line_width	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
fill_fraction	double
=	O
reader	*(struct)
->	O
fill_fraction	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
use_color	enum(int,int)
=	O
reader	*(struct)
->	O
use_color	enum(int,int)
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
have_x_errorbar	enum(int,int)
=	O
false	int
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
have_y_errorbar	enum(int,int)
=	O
(	O
reader	*(struct)
->	O
format_type	enum(int,int,int,int,int,int)
==	O
T_ASCII_ERRORBAR	int
?	O
true	int
:	O
false	int
)	O
;	O
head	O
:	O
switch	O
(	O
reader	*(struct)
->	O
format_type	enum(int,int,int,int,int,int)
)	O
{	O
case	O
T_ASCII	int
:	O
default	O
:	O
status	enum(int,int,int,int)
=	O
read_point_ascii	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
reader	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
break	O
;	O
case	O
T_SINGLE	int
:	O
case	O
T_DOUBLE	int
:	O
case	O
T_INTEGER	int
:	O
status	enum(int,int,int,int)
=	O
read_point_binary	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
reader	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
break	O
;	O
case	O
T_ASCII_ERRORBAR	int
:	O
status	enum(int,int,int,int)
=	O
read_point_ascii_errorbar	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
reader	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
break	O
;	O
case	O
T_GNUPLOT	int
:	O
status	enum(int,int,int,int)
=	O
read_point_gnuplot	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
reader	*(struct)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
status	enum(int,int,int,int)
==	O
IN_PROGRESS	int
)	O
{	O
bool	enum(int,int)
bad_point	enum(int,int)
=	O
false	int
;	O
if	O
(	O
reader	*(struct)
->	O
log_axis	int
&	O
X_AXIS	int
)	O
{	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
>	O
0.0	int
)	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
log10	(double)->(double)
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
)	O
;	O
else	O
bad_point	enum(int,int)
=	O
true	int
;	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
have_x_errorbar	enum(int,int)
)	O
{	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmin	double
>	O
0.0	int
)	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmin	double
=	O
log10	(double)->(double)
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmin	double
)	O
;	O
else	O
bad_point	enum(int,int)
=	O
true	int
;	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmax	double
>	O
0.0	int
)	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmax	double
=	O
log10	(double)->(double)
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmax	double
)	O
;	O
else	O
bad_point	enum(int,int)
=	O
true	int
;	O
}	O
if	O
(	O
bad_point	enum(int,int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the inappropriate point (%g,%g) is dropped, as this is a log plot\n"	*(char)
,	O
progname	*(char)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
)	O
;	O
reader	*(struct)
->	O
need_break	enum(int,int)
=	O
true	int
;	O
goto	O
head	O
;	O
}	O
}	O
if	O
(	O
reader	*(struct)
->	O
log_axis	int
&	O
Y_AXIS	int
)	O
{	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
>	O
0.0	int
)	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
=	O
log10	(double)->(double)
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
)	O
;	O
else	O
bad_point	enum(int,int)
=	O
true	int
;	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
have_y_errorbar	enum(int,int)
)	O
{	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymin	double
>	O
0.0	int
)	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymin	double
=	O
log10	(double)->(double)
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymin	double
)	O
;	O
else	O
bad_point	enum(int,int)
=	O
true	int
;	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymax	double
>	O
0.0	int
)	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymax	double
=	O
log10	(double)->(double)
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymax	double
)	O
;	O
else	O
bad_point	enum(int,int)
=	O
true	int
;	O
}	O
if	O
(	O
bad_point	enum(int,int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the inappropriate point (%g,%g) is dropped, as this is a log plot\n"	*(char)
,	O
progname	*(char)
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
,	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
)	O
;	O
reader	*(struct)
->	O
need_break	enum(int,int)
=	O
true	int
;	O
goto	O
head	O
;	O
}	O
}	O
if	O
(	O
reader	*(struct)
->	O
transpose_axes	enum(int,int)
)	O
{	O
double	O
tmp	double
;	O
bool	enum(int,int)
tmp_bool	enum(int,int)
;	O
tmp	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
=	O
tmp	double
;	O
tmp	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmin	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmin	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymin	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymin	double
=	O
tmp	double
;	O
tmp	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmax	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmax	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymax	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymax	double
=	O
tmp	double
;	O
tmp_bool	enum(int,int)
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
have_x_errorbar	enum(int,int)
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
have_x_errorbar	enum(int,int)
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
have_y_errorbar	enum(int,int)
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
have_y_errorbar	enum(int,int)
=	O
tmp_bool	enum(int,int)
;	O
}	O
if	O
(	O
reader	*(struct)
->	O
need_break	enum(int,int)
)	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
pendown	enum(int,int)
=	O
false	int
;	O
else	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
pendown	enum(int,int)
=	O
true	int
;	O
reader	*(struct)
->	O
need_break	enum(int,int)
=	O
false	int
;	O
}	O
return	O
status	enum(int,int,int,int)
;	O
}	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point_ascii	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
{	O
int	O
items_read	int
,	O
lookahead	int
;	O
bool	enum(int,int)
two_newlines	enum(int,int)
;	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
reader	*(struct)
->	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
head	O
:	O
two_newlines	enum(int,int)
=	O
skip_some_whitespace	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
two_newlines	enum(int,int)
)	O
return	O
ENDED_BY_DATASET_TERMINATOR	int
;	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
return	O
ENDED_BY_EOF	int
;	O
lookahead	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
lookahead	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
lookahead	int
==	O
(	O
int	O
)	O
'#'	O
)	O
{	O
int	O
new_symbol	enum(int,int)
,	O
new_linemode	enum(int,int)
;	O
int	O
items_read	int
;	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"# m = %d, S = %d"	*(char)
,	O
&	O
new_linemode	enum(int,int)
,	O
&	O
new_symbol	enum(int,int)
)	O
;	O
if	O
(	O
items_read	int
==	O
2	int
)	O
{	O
reader	*(struct)
->	O
linemode	int
=	O
new_linemode	enum(int,int)
;	O
reader	*(struct)
->	O
symbol	int
=	O
new_symbol	enum(int,int)
;	O
return	O
ENDED_BY_MODE_CHANGE	int
;	O
}	O
else	O
{	O
char	O
c	char
;	O
do	O
{	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
c	char
,	O
sizeof	O
(	O
c	char
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
items_read	int
<=	O
0	int
)	O
return	O
ENDED_BY_EOF	int
;	O
}	O
while	O
(	O
c	char
!=	O
'\n'	O
)	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
(	O
int	O
)	O
'\n'	O
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
head	O
;	O
}	O
}	O
if	O
(	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
)	O
{	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
reader	*(struct)
->	O
abscissa	double
;	O
reader	*(struct)
->	O
abscissa	double
+=	O
reader	*(struct)
->	O
delta_x	double
;	O
}	O
else	O
{	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%lf"	*(char)
,	O
&	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
)	O
)	O
;	O
if	O
(	O
items_read	int
!=	O
1	int
)	O
return	O
ENDED_BY_EOF	int
;	O
}	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%lf"	*(char)
,	O
&	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
)	O
)	O
;	O
if	O
(	O
items_read	int
==	O
1	int
)	O
return	O
IN_PROGRESS	int
;	O
else	O
{	O
if	O
(	O
!	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: an input file terminated prematurely\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
ENDED_BY_EOF	int
;	O
}	O
}	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point_ascii_errorbar	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
{	O
int	O
items_read	int
,	O
lookahead	int
;	O
bool	enum(int,int)
two_newlines	enum(int,int)
;	O
double	O
error_size	double
;	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
reader	*(struct)
->	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
head	O
:	O
two_newlines	enum(int,int)
=	O
skip_some_whitespace	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
two_newlines	enum(int,int)
)	O
return	O
ENDED_BY_DATASET_TERMINATOR	int
;	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
return	O
ENDED_BY_EOF	int
;	O
lookahead	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
lookahead	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
lookahead	int
==	O
(	O
int	O
)	O
'#'	O
)	O
{	O
int	O
new_symbol	enum(int,int)
,	O
new_linemode	enum(int,int)
;	O
int	O
items_read	int
;	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"# m = %d, S = %d"	*(char)
,	O
&	O
new_linemode	enum(int,int)
,	O
&	O
new_symbol	enum(int,int)
)	O
;	O
if	O
(	O
items_read	int
==	O
2	int
)	O
{	O
reader	*(struct)
->	O
linemode	int
=	O
new_linemode	enum(int,int)
;	O
reader	*(struct)
->	O
symbol	int
=	O
new_symbol	enum(int,int)
;	O
return	O
ENDED_BY_MODE_CHANGE	int
;	O
}	O
else	O
{	O
char	O
c	char
;	O
do	O
{	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
c	char
,	O
sizeof	O
(	O
c	char
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
items_read	int
<=	O
0	int
)	O
return	O
ENDED_BY_EOF	int
;	O
}	O
while	O
(	O
c	char
!=	O
'\n'	O
)	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
(	O
int	O
)	O
'\n'	O
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
head	O
;	O
}	O
}	O
if	O
(	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
)	O
{	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
reader	*(struct)
->	O
abscissa	double
;	O
reader	*(struct)
->	O
abscissa	double
+=	O
reader	*(struct)
->	O
delta_x	double
;	O
}	O
else	O
{	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%lf"	*(char)
,	O
&	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
)	O
)	O
;	O
if	O
(	O
items_read	int
!=	O
1	int
)	O
return	O
ENDED_BY_EOF	int
;	O
}	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%lf"	*(char)
,	O
&	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
)	O
)	O
;	O
if	O
(	O
items_read	int
!=	O
1	int
)	O
{	O
if	O
(	O
!	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: an input file (in errorbar format) terminated prematurely\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
ENDED_BY_EOF	int
;	O
}	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%lf"	*(char)
,	O
&	O
error_size	double
)	O
;	O
if	O
(	O
items_read	int
!=	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: an input file (in errorbar format) terminated prematurely\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
ENDED_BY_EOF	int
;	O
}	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymin	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
-	O
error_size	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
ymax	double
=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
+	O
error_size	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmin	double
=	O
0.0	int
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
xmax	double
=	O
0.0	int
;	O
return	O
IN_PROGRESS	int
;	O
}	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point_binary	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
{	O
int	O
items_read	int
;	O
data_type	enum(int,int,int,int,int,int)
format_type	enum(int,int,int,int,int,int)
=	O
reader	*(struct)
->	O
format_type	enum(int,int,int,int,int,int)
;	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
reader	*(struct)
->	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
)	O
{	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
reader	*(struct)
->	O
abscissa	double
;	O
reader	*(struct)
->	O
abscissa	double
+=	O
reader	*(struct)
->	O
delta_x	double
;	O
}	O
else	O
{	O
switch	O
(	O
format_type	enum(int,int,int,int,int,int)
)	O
{	O
case	O
T_DOUBLE	int
:	O
default	O
:	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
void	O
*	O
)	O
&	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
)	O
,	O
sizeof	O
(	O
double	O
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
T_SINGLE	int
:	O
{	O
float	O
fx	float
;	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
void	O
*	O
)	O
&	O
fx	float
,	O
sizeof	O
(	O
fx	float
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
fx	float
;	O
}	O
break	O
;	O
case	O
T_INTEGER	int
:	O
{	O
int	O
ix	int
;	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
void	O
*	O
)	O
&	O
ix	int
,	O
sizeof	O
(	O
ix	int
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
ix	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
items_read	int
<=	O
0	int
)	O
return	O
ENDED_BY_EOF	int
;	O
}	O
if	O
(	O
(	O
format_type	enum(int,int,int,int,int,int)
==	O
T_DOUBLE	int
&&	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
==	O
DBL_MAX	O
)	O
||	O
(	O
format_type	enum(int,int,int,int,int,int)
==	O
T_SINGLE	int
&&	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
==	O
(	O
double	O
)	O
FLT_MAX	O
)	O
||	O
(	O
format_type	enum(int,int,int,int,int,int)
==	O
T_INTEGER	int
&&	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
==	O
(	O
double	O
)	O
INT_MAX	O
)	O
)	O
return	O
ENDED_BY_DATASET_TERMINATOR	int
;	O
switch	O
(	O
format_type	enum(int,int,int,int,int,int)
)	O
{	O
case	O
T_DOUBLE	int
:	O
default	O
:	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
void	O
*	O
)	O
&	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
)	O
,	O
sizeof	O
(	O
double	O
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
T_SINGLE	int
:	O
{	O
float	O
fy	float
;	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
void	O
*	O
)	O
&	O
fy	float
,	O
sizeof	O
(	O
fy	float
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
=	O
fy	float
;	O
}	O
break	O
;	O
case	O
T_INTEGER	int
:	O
{	O
int	O
iy	int
;	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
(	O
void	O
*	O
)	O
&	O
iy	int
,	O
sizeof	O
(	O
iy	int
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
=	O
iy	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
items_read	int
!=	O
1	int
)	O
{	O
if	O
(	O
!	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: an input file (in binary format) terminated prematurely\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
ENDED_BY_EOF	int
;	O
}	O
else	O
if	O
(	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
!=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
||	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
!=	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: a NaN (not-a-number) was encountered in a binary input file\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
ENDED_BY_EOF	int
;	O
}	O
else	O
return	O
IN_PROGRESS	int
;	O
}	O
static	O
dataset_status_t	enum(int,int,int,int)
read_point_gnuplot	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
{	O
int	O
lookahead	int
,	O
items_read	int
;	O
char	O
directive	char
,	O
c	char
;	O
bool	enum(int,int)
two_newlines	enum(int,int)
;	O
double	O
x	double
,	O
y	double
;	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
reader	*(struct)
->	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
head	O
:	O
two_newlines	enum(int,int)
=	O
skip_some_whitespace	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
two_newlines	enum(int,int)
)	O
{	O
skip_all_whitespace	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
return	O
ENDED_BY_EOF	int
;	O
else	O
return	O
ENDED_BY_DATASET_TERMINATOR	int
;	O
}	O
lookahead	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
lookahead	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
switch	O
(	O
lookahead	int
)	O
{	O
case	O
'C'	O
:	O
case	O
'#'	O
:	O
do	O
{	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
c	char
,	O
sizeof	O
(	O
c	char
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
items_read	int
<=	O
0	int
)	O
return	O
ENDED_BY_EOF	int
;	O
}	O
while	O
(	O
c	char
!=	O
'\n'	O
)	O
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
(	O
int	O
)	O
'\n'	O
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
goto	O
head	O
;	O
case	O
'i'	O
:	O
case	O
'o'	O
:	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c x=%lf y=%lf"	*(char)
,	O
&	O
directive	char
,	O
&	O
x	double
,	O
&	O
y	double
)	O
;	O
if	O
(	O
items_read	int
==	O
3	int
)	O
{	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
x	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
=	O
y	double
;	O
return	O
IN_PROGRESS	int
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: an input file in gnuplot format could not be parsed\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
ENDED_BY_EOF	int
;	O
}	O
case	O
'u'	O
:	O
do	O
{	O
items_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
c	char
,	O
sizeof	O
(	O
c	char
)	O
,	O
1	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
items_read	int
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: an input file in gnuplot format could not be parsed\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
ENDED_BY_EOF	int
;	O
}	O
}	O
while	O
(	O
c	char
!=	O
'\n'	O
)	O
;	O
reader	*(struct)
->	O
need_break	enum(int,int)
=	O
true	int
;	O
goto	O
head	O
;	O
default	O
:	O
items_read	int
=	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%lf %lf %c"	*(char)
,	O
&	O
x	double
,	O
&	O
y	double
,	O
&	O
directive	char
)	O
;	O
if	O
(	O
items_read	int
==	O
3	int
&&	O
(	O
directive	char
==	O
'i'	O
||	O
directive	char
==	O
'o'	O
||	O
directive	char
==	O
'u'	O
)	O
)	O
{	O
if	O
(	O
directive	char
==	O
'u'	O
)	O
{	O
reader	*(struct)
->	O
need_break	enum(int,int)
=	O
true	int
;	O
goto	O
head	O
;	O
}	O
else	O
{	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
x	double
=	O
x	double
;	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
->	O
y	double
=	O
y	double
;	O
return	O
IN_PROGRESS	int
;	O
}	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: an input file in gnuplot format could not be parsed\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
ENDED_BY_EOF	int
;	O
}	O
}	O
}	O
static	O
dataset_status_t	enum(int,int,int,int)
read_dataset	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))),*(int),*(int))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
*	O
p_addr	*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))
,	O
int	O
*	O
length	long
,	O
int	O
*	O
no_of_points	*(int)
)	O
{	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
p	*(void)
=	O
*	O
p_addr	*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))
;	O
dataset_status_t	enum(int,int,int,int)
status	enum(int,int,int,int)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
no_of_points	*(int)
>=	O
*	O
length	long
)	O
{	O
int	O
old_length	int
,	O
new_length	int
;	O
old_length	int
=	O
*	O
length	long
;	O
new_length	int
=	O
NEW_POINT_ARRAY_LENGTH	O
(	O
old_length	int
)	O
;	O
p	*(void)
=	O
(	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
p	*(void)
,	O
new_length	int
*	O
sizeof	O
(	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
)	O
)	O
;	O
*	O
length	long
=	O
new_length	int
;	O
}	O
status	enum(int,int,int,int)
=	O
read_point	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
reader	*(struct)
,	O
&	O
(	O
p	*(void)
[	O
*	O
no_of_points	*(int)
]	O
)	O
)	O
;	O
if	O
(	O
status	enum(int,int,int,int)
!=	O
IN_PROGRESS	int
)	O
break	O
;	O
(	O
*	O
no_of_points	*(int)
)	O
++	O
;	O
}	O
*	O
p_addr	*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))
=	O
p	*(void)
;	O
return	O
status	enum(int,int,int,int)
;	O
}	O
void	O
read_file	(*(struct),*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))),*(int),*(int))->(void)
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
*	O
*	O
p_addr	*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))
,	O
int	O
*	O
length	long
,	O
int	O
*	O
no_of_points	*(int)
)	O
{	O
dataset_status_t	enum(int,int,int,int)
status	enum(int,int,int,int)
;	O
do	O
{	O
status	enum(int,int,int,int)
=	O
read_dataset	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))),*(int),*(int))->(enum(int,int,int,int))
(	O
reader	*(struct)
,	O
p_addr	*(*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))
,	O
length	long
,	O
no_of_points	*(int)
)	O
;	O
if	O
(	O
status	enum(int,int,int,int)
==	O
ENDED_BY_MODE_CHANGE	int
)	O
{	O
bool	enum(int,int)
saved_auto_bump	enum(int,int)
;	O
saved_auto_bump	enum(int,int)
=	O
reader	*(struct)
->	O
auto_bump	enum(int,int)
;	O
reader	*(struct)
->	O
auto_bump	enum(int,int)
=	O
false	int
;	O
reset_reader	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)))->(void)
(	O
reader	*(struct)
)	O
;	O
reader	*(struct)
->	O
auto_bump	enum(int,int)
=	O
saved_auto_bump	enum(int,int)
;	O
}	O
else	O
reset_reader	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)))->(void)
(	O
reader	*(struct)
)	O
;	O
}	O
while	O
(	O
status	enum(int,int,int,int)
!=	O
ENDED_BY_EOF	int
)	O
;	O
}	O
static	O
void	O
reset_reader	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)))->(void)
(	O
Reader	struct
*	O
reader	*(struct)
)	O
{	O
reader	*(struct)
->	O
need_break	enum(int,int)
=	O
true	int
;	O
if	O
(	O
reader	*(struct)
->	O
auto_bump	enum(int,int)
)	O
reader	*(struct)
->	O
linemode	int
+=	O
(	O
(	O
reader	*(struct)
->	O
linemode	int
>	O
0	int
)	O
?	O
1	int
:	O
-	O
1	int
)	O
;	O
if	O
(	O
reader	*(struct)
->	O
auto_abscissa	enum(int,int)
)	O
reader	*(struct)
->	O
abscissa	double
=	O
reader	*(struct)
->	O
initial_abscissa	double
;	O
return	O
;	O
}	O
static	O
bool	enum(int,int)
skip_some_whitespace	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
lookahead	int
;	O
int	O
nlcount	int
=	O
0	int
;	O
do	O
{	O
lookahead	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
lookahead	int
==	O
(	O
int	O
)	O
'\n'	O
)	O
nlcount	int
++	O
;	O
}	O
while	O
(	O
lookahead	int
!=	O
EOF	O
&&	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
lookahead	int
)	O
&&	O
nlcount	int
<	O
2	int
)	O
;	O
if	O
(	O
lookahead	int
==	O
EOF	O
)	O
return	O
false	int
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
lookahead	int
,	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
(	O
nlcount	int
==	O
2	int
?	O
true	int
:	O
false	int
)	O
;	O
}	O
static	O
void	O
skip_all_whitespace	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
lookahead	int
;	O
do	O
lookahead	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
lookahead	int
!=	O
EOF	O
&&	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
lookahead	int
)	O
)	O
;	O
if	O
(	O
lookahead	int
==	O
EOF	O
)	O
return	O
;	O
else	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
lookahead	int
,	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
dataset_status_t	enum(int,int,int,int)
read_and_plot_dataset	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct))->(enum(int,int,int,int))
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Multigrapher	struct
*	O
multigrapher	*(struct)
)	O
{	O
dataset_status_t	enum(int,int,int,int)
status	enum(int,int,int,int)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
Point	struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
;	O
status	enum(int,int,int,int)
=	O
read_point	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(enum(int,int,int,int))
(	O
reader	*(struct)
,	O
&	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
if	O
(	O
status	enum(int,int,int,int)
!=	O
IN_PROGRESS	int
)	O
break	O
;	O
else	O
plot_point	(*(struct),*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int))))->(void)
(	O
multigrapher	*(struct)
,	O
&	O
point	*(struct(double,double,enum(int,int),enum(int,int),double,double,double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int)))
)	O
;	O
}	O
return	O
status	enum(int,int,int,int)
;	O
}	O
void	O
read_and_plot_file	(*(struct),*(struct))->(void)
(	O
Reader	struct
*	O
reader	*(struct)
,	O
Multigrapher	struct
*	O
multigrapher	*(struct)
)	O
{	O
dataset_status_t	enum(int,int,int,int)
status	enum(int,int,int,int)
;	O
do	O
{	O
status	enum(int,int,int,int)
=	O
read_and_plot_dataset	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)),*(struct))->(enum(int,int,int,int))
(	O
reader	*(struct)
,	O
multigrapher	*(struct)
)	O
;	O
if	O
(	O
status	enum(int,int,int,int)
==	O
ENDED_BY_MODE_CHANGE	int
)	O
{	O
bool	enum(int,int)
saved_auto_bump	enum(int,int)
;	O
saved_auto_bump	enum(int,int)
=	O
reader	*(struct)
->	O
auto_bump	enum(int,int)
;	O
reader	*(struct)
->	O
auto_bump	enum(int,int)
=	O
false	int
;	O
reset_reader	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)))->(void)
(	O
reader	*(struct)
)	O
;	O
reader	*(struct)
->	O
auto_bump	enum(int,int)
=	O
saved_auto_bump	enum(int,int)
;	O
}	O
else	O
reset_reader	(*(struct(enum(int,int),int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int,int,int,int),enum(int,int),double,double,enum(int,int),int,double,*(char),int,double,double,enum(int,int),enum(int,int),double)))->(void)
(	O
reader	*(struct)
)	O
;	O
end_polyline_and_flush	(*(struct))->(void)
(	O
multigrapher	*(struct)
)	O
;	O
}	O
while	O
(	O
status	enum(int,int,int,int)
!=	O
ENDED_BY_EOF	int
)	O
;	O
}	O
