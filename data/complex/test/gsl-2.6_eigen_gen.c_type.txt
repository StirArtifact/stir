static	O
void	O
gen_schur_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
inline	O
int	O
gen_qzstep	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
inline	O
void	O
gen_qzstep_d	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
void	O
gen_tri_split_top	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
inline	O
void	O
gen_tri_chase_zero	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
size_t	long
q	*(struct(long,*(long)))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
inline	O
void	O
gen_tri_zero_H	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
inline	O
size_t	long
gen_search_small_elements	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(int),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
int	O
*	O
flag	*(int)
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
int	O
gen_schur_standardize1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
double	O
*	O
alphar	*(double)
,	O
double	O
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
int	O
gen_schur_standardize2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),*(struct(array(double))),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_complex	struct(array(double))
*	O
alpha1	*(struct(array(double)))
,	O
gsl_complex	struct(array(double))
*	O
alpha2	*(struct(array(double)))
,	O
double	O
*	O
beta1	*(double)
,	O
double	O
*	O
beta2	*(double)
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
int	O
gen_compute_eigenvals	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),*(struct(array(double))),*(double),*(double))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_complex	struct(array(double))
*	O
alpha1	*(struct(array(double)))
,	O
gsl_complex	struct(array(double))
*	O
alpha2	*(struct(array(double)))
,	O
double	O
*	O
beta1	*(double)
,	O
double	O
*	O
beta2	*(double)
)	O
;	O
static	O
void	O
gen_store_eigval1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
double	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
const	O
double	O
b	*(struct(long,*(long double)))
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
void	O
gen_store_eigval2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),double,*(struct(array(double))),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
gsl_complex	struct(array(double))
*	O
alpha1	*(struct(array(double)))
,	O
const	O
double	O
beta1	*(double)
,	O
const	O
gsl_complex	struct(array(double))
*	O
alpha2	*(struct(array(double)))
,	O
const	O
double	O
beta2	*(double)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
static	O
inline	O
size_t	long
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
)	O
;	O
inline	O
static	O
double	O
normF	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
;	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
gsl_eigen_gen_alloc	(long)->(*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
(	O
const	O
size_t	long
n	long
)	O
{	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"matrix dimension must be positive integer"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
=	O
(	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
)	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
)	O
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workspace"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
=	O
n	long
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
max_iterations	long
=	O
30	int
*	O
n	long
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_evals	long
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_iter	long
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
atol	(*(char))->(long)
=	O
0.0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
btol	double
=	O
0.0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
=	O
0.0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
=	O
0.0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
=	O
0.0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
n	long
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
)	O
{	O
gsl_eigen_gen_free	(*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for additional workspace"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
void	O
gsl_eigen_gen_free	(*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
RETURN_IF_NULL	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
free	(*(void))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
void	O
gsl_eigen_gen_params	(int,int,int,*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
const	O
int	O
compute_s	int
,	O
const	O
int	O
compute_t	int
,	O
const	O
int	O
balance	int
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
=	O
compute_s	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
=	O
compute_t	int
;	O
}	O
int	O
gsl_eigen_gen	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size1	long
;	O
if	O
(	O
N	int
!=	O
A	*(float)
->	O
size2	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square to compute eigenvalues"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
N	int
!=	O
B	*(float)
->	O
size1	long
)	O
||	O
(	O
N	int
!=	O
B	*(float)
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"B matrix dimensions must match A"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
alpha	long double
->	O
size	long
!=	O
N	int
||	O
beta	long double
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"eigenvalue vector must match matrix size"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix size does not match workspace"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
double	O
anorm	double
,	O
bnorm	double
;	O
gsl_linalg_hesstri_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
A	*(float)
,	O
B	*(float)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
A	*(float)
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
B	*(float)
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_evals	long
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_iter	long
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
=	O
0.0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
!=	O
0	int
||	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
!=	O
0	int
||	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
||	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
;	O
anorm	double
=	O
normF	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
A	*(float)
)	O
;	O
bnorm	double
=	O
normF	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
B	*(float)
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
atol	(*(char))->(long)
=	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
GSL_DBL_EPSILON	int
*	O
anorm	double
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
btol	double
=	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
GSL_DBL_EPSILON	int
*	O
bnorm	double
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
anorm	double
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
bnorm	double
)	O
;	O
gen_schur_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
A	*(float)
,	O
B	*(float)
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_evals	long
!=	O
N	int
)	O
return	O
GSL_EMAXITER	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_eigen_gen_QZ	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
if	O
(	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
&&	O
(	O
A	*(float)
->	O
size1	long
!=	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
||	O
A	*(float)
->	O
size1	long
!=	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Q matrix has wrong dimensions"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
&&	O
(	O
A	*(float)
->	O
size1	long
!=	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
||	O
A	*(float)
->	O
size1	long
!=	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Z matrix has wrong dimensions"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
int	O
s	*(float)
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
s	*(float)
=	O
gsl_eigen_gen	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
A	*(float)
,	O
B	*(float)
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
NULL	O
;	O
return	O
s	*(float)
;	O
}	O
}	O
static	O
void	O
gen_schur_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
N	int
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
size_t	long
q	*(struct(long,*(long)))
;	O
gsl_complex	struct(array(double))
z1	struct(array(double))
,	O
z2	struct(array(double))
;	O
double	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
b	*(struct(long,*(long double)))
;	O
int	O
s	*(float)
;	O
int	O
flag	*(int)
;	O
N	int
=	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
;	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
while	O
(	O
(	O
N	int
>	O
1	int
)	O
&&	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_iter	long
)	O
++	O
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
max_iterations	long
)	O
{	O
q	*(struct(long,*(long)))
=	O
gen_search_small_elements	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(int),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
flag	*(int)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
flag	*(int)
==	O
0	int
)	O
{	O
s	*(float)
=	O
gen_qzstep	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
s	*(float)
==	O
GSL_CONTINUE	int
)	O
{	O
s	*(float)
=	O
gen_schur_standardize2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),*(struct(array(double))),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
z1	struct(array(double))
,	O
&	O
z2	struct(array(double))
,	O
&	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
b	*(struct(long,*(long double)))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
s	*(float)
!=	O
GSL_SUCCESS	int
)	O
{	O
continue	O
;	O
}	O
gen_store_eigval2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),double,*(struct(array(double))),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
z1	struct(array(double))
,	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
z2	struct(array(double))
,	O
b	*(struct(long,*(long double)))
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
N	int
=	O
0	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
flag	*(int)
==	O
2	int
)	O
{	O
if	O
(	O
q	*(struct(long,*(long)))
==	O
0	int
)	O
{	O
gen_tri_split_top	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
q	*(struct(long,*(long)))
!=	O
N	int
-	O
1	int
)	O
gen_tri_chase_zero	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
q	*(struct(long,*(long)))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
gen_tri_zero_H	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
q	*(struct(long,*(long)))
==	O
(	O
N	int
-	O
1	int
)	O
)	O
{	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
q	*(struct(long,*(long)))
,	O
q	*(struct(long,*(long)))
,	O
1	int
,	O
1	int
)	O
;	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
q	*(struct(long,*(long)))
,	O
q	*(struct(long,*(long)))
,	O
1	int
,	O
1	int
)	O
;	O
gen_schur_standardize1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
b	*(struct(long,*(long double)))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
gen_store_eigval1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
b	*(struct(long,*(long double)))
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
--	O
N	int
;	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
}	O
else	O
if	O
(	O
q	*(struct(long,*(long)))
==	O
(	O
N	int
-	O
2	int
)	O
)	O
{	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
q	*(struct(long,*(long)))
,	O
q	*(struct(long,*(long)))
,	O
2	int
,	O
2	int
)	O
;	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
q	*(struct(long,*(long)))
,	O
q	*(struct(long,*(long)))
,	O
2	int
,	O
2	int
)	O
;	O
s	*(float)
=	O
gen_schur_standardize2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),*(struct(array(double))),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
z1	struct(array(double))
,	O
&	O
z2	struct(array(double))
,	O
&	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
b	*(struct(long,*(long double)))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
s	*(float)
!=	O
GSL_SUCCESS	int
)	O
{	O
gen_schur_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
else	O
{	O
gen_store_eigval2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),double,*(struct(array(double))),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
z1	struct(array(double))
,	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
z2	struct(array(double))
,	O
b	*(struct(long,*(long double)))
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
N	int
-=	O
2	int
;	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
}	O
else	O
if	O
(	O
q	*(struct(long,*(long)))
==	O
1	int
)	O
{	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
)	O
;	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
)	O
;	O
gen_schur_standardize1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
b	*(struct(long,*(long double)))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
gen_store_eigval1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
b	*(struct(long,*(long double)))
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
--	O
N	int
;	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
1	int
,	O
N	int
,	O
N	int
)	O
;	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
1	int
,	O
N	int
,	O
N	int
)	O
;	O
}	O
else	O
if	O
(	O
q	*(struct(long,*(long)))
==	O
2	int
)	O
{	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
2	int
,	O
2	int
)	O
;	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
2	int
,	O
2	int
)	O
;	O
s	*(float)
=	O
gen_schur_standardize2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),*(struct(array(double))),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
z1	struct(array(double))
,	O
&	O
z2	struct(array(double))
,	O
&	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
b	*(struct(long,*(long double)))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
s	*(float)
!=	O
GSL_SUCCESS	int
)	O
{	O
gen_schur_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
else	O
{	O
gen_store_eigval2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),double,*(struct(array(double))),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
z1	struct(array(double))
,	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
z2	struct(array(double))
,	O
b	*(struct(long,*(long double)))
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
N	int
-=	O
2	int
;	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
2	int
,	O
2	int
,	O
N	int
,	O
N	int
)	O
;	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
2	int
,	O
2	int
,	O
N	int
,	O
N	int
)	O
;	O
}	O
else	O
{	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
q	*(struct(long,*(long)))
,	O
q	*(struct(long,*(long)))
,	O
N	int
-	O
q	*(struct(long,*(long)))
,	O
N	int
-	O
q	*(struct(long,*(long)))
)	O
;	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
q	*(struct(long,*(long)))
,	O
q	*(struct(long,*(long)))
,	O
N	int
-	O
q	*(struct(long,*(long)))
,	O
N	int
-	O
q	*(struct(long,*(long)))
)	O
;	O
gen_schur_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
q	*(struct(long,*(long)))
,	O
q	*(struct(long,*(long)))
)	O
;	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
,	O
q	*(struct(long,*(long)))
,	O
q	*(struct(long,*(long)))
)	O
;	O
gen_schur_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
N	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
N	int
==	O
1	int
)	O
{	O
gen_schur_standardize1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
&	O
b	*(struct(long,*(long double)))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
gen_store_eigval1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
&	O
h	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
b	*(struct(long,*(long double)))
,	O
alpha	long double
,	O
beta	long double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
}	O
static	O
inline	O
int	O
gen_qzstep	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
double	O
wr1	*(double)
,	O
wr2	*(double)
,	O
wi	*(double)
;	O
double	O
scale1	*(double)
,	O
scale2	*(double)
,	O
scale	double
;	O
double	O
cs	double
,	O
sn	double
;	O
double	O
temp	double
,	O
temp2	double
;	O
size_t	long
j	long
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
size_t	long
top	long
=	O
0	int
;	O
size_t	long
rows	long
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_iter	long
%	O
10	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
GSL_DBL_MIN	int
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
max_iterations	long
)	O
*	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
1	int
)	O
)	O
<	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
)	O
{	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
+=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
1	int
)	O
/	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
;	O
}	O
else	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
+=	O
1.0	int
/	O
(	O
GSL_DBL_MIN	int
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
max_iterations	long
)	O
;	O
if	O
(	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
<	O
GSL_DBL_EPSILON	int
)	O
&&	O
(	O
GSL_DBL_MIN	int
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
max_iterations	long
)	O
*	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
)	O
<	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
)	O
{	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
=	O
GEN_ESHIFT_COEFF	O
*	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
;	O
}	O
scale1	*(double)
=	O
1.0	int
;	O
wr1	*(double)
=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
;	O
}	O
else	O
{	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
gsl_schur_gen_eigvals	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(double),*(double),*(double))->(int)
(	O
&	O
vh	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vr	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
wr1	*(double)
,	O
&	O
wr2	*(double)
,	O
&	O
wi	*(double)
,	O
&	O
scale1	*(double)
,	O
&	O
scale2	*(double)
)	O
;	O
if	O
(	O
wi	*(double)
!=	O
0.0	int
)	O
{	O
if	O
(	O
N	int
==	O
2	int
)	O
{	O
return	O
(	O
GSL_CONTINUE	int
)	O
;	O
}	O
else	O
{	O
gen_qzstep_d	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
temp	double
=	O
GSL_MIN	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
,	O
1.0	int
)	O
*	O
(	O
0.5	int
/	O
GSL_DBL_MIN	int
)	O
;	O
if	O
(	O
scale1	*(double)
>	O
temp	double
)	O
scale	double
=	O
temp	double
/	O
scale1	*(double)
;	O
else	O
scale	double
=	O
1.0	int
;	O
temp	double
=	O
GSL_MIN	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
,	O
1.0	int
)	O
*	O
(	O
0.5	int
/	O
GSL_DBL_MIN	int
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
wr1	*(double)
)	O
>	O
temp	double
)	O
scale	double
=	O
GSL_MIN	O
(	O
scale	double
,	O
temp	double
/	O
fabs	(double)->(double)
(	O
wr1	*(double)
)	O
)	O
;	O
scale1	*(double)
*=	O
scale	double
;	O
wr1	*(double)
*=	O
scale	double
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
)	O
{	O
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
}	O
temp	double
=	O
scale1	*(double)
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
)	O
-	O
wr1	*(double)
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
)	O
;	O
temp2	double
=	O
scale1	*(double)
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
1	int
,	O
0	int
)	O
;	O
gsl_linalg_givens	(double,double,*(double),*(double))->(void)
(	O
temp	double
,	O
temp2	double
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
-	O
1	int
;	O
++	O
j	long
)	O
{	O
if	O
(	O
j	long
>	O
0	int
)	O
{	O
temp	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
-	O
1	int
)	O
;	O
temp2	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
)	O
;	O
gsl_linalg_givens	(double,double,*(double),*(double))->(void)
(	O
temp	double
,	O
temp2	double
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
temp	double
=	O
cs	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
-	O
1	int
)	O
+	O
sn	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
-	O
1	int
,	O
temp	double
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
,	O
0.0	int
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
j	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
,	O
N	int
-	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
,	O
N	int
-	O
j	long
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
j	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
,	O
N	int
-	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
,	O
N	int
-	O
j	long
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
temp	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
;	O
temp2	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
)	O
;	O
gsl_linalg_givens	(double,double,*(double),*(double))->(void)
(	O
temp	double
,	O
temp2	double
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
rows	long
=	O
GSL_MIN	O
(	O
j	long
+	O
3	int
,	O
N	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
0	int
,	O
top	long
+	O
rows	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
,	O
0	int
,	O
top	long
+	O
rows	long
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
0	int
,	O
rows	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
0	int
,	O
rows	long
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
rows	long
=	O
GSL_MIN	O
(	O
j	long
+	O
2	int
,	O
N	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
0	int
,	O
top	long
+	O
rows	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
,	O
0	int
,	O
top	long
+	O
rows	long
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
0	int
,	O
rows	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
0	int
,	O
rows	long
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
inline	O
void	O
gen_qzstep_d	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
;	O
size_t	long
j	long
;	O
double	O
dat	array(long double)
[	O
3	int
]	O
;	O
double	O
tau	*(double)
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
;	O
double	O
tmp	double
;	O
size_t	long
q	*(struct(long,*(long)))
,	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
size_t	long
top	long
=	O
0	int
;	O
double	O
scale	double
;	O
double	O
AB11	double
,	O
AB22	double
,	O
ABNN	double
,	O
ABMM	double
,	O
AMNBNN	double
,	O
ANMBMM	double
,	O
A21B11	double
,	O
A12B22	double
,	O
A32B22	double
,	O
B12B22	double
,	O
BMNBNN	double
;	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_view_array	(*(double),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
dat	array(long double)
,	O
2	int
)	O
;	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_view_array	(*(double),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
dat	array(long double)
,	O
3	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
)	O
{	O
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
}	O
ABMM	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
;	O
ABNN	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
)	O
;	O
AB11	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
)	O
)	O
;	O
AB22	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
1	int
,	O
1	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
1	int
,	O
1	int
)	O
)	O
;	O
AMNBNN	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
1	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
)	O
;	O
ANMBMM	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
)	O
)	O
;	O
BMNBNN	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
1	int
)	O
/	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
;	O
A21B11	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
1	int
,	O
0	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
)	O
)	O
;	O
A12B22	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
1	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
1	int
,	O
1	int
)	O
)	O
;	O
A32B22	double
=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
ascale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
2	int
,	O
1	int
)	O
)	O
/	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
bscale	double
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
1	int
,	O
1	int
)	O
)	O
;	O
B12B22	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
1	int
)	O
/	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
1	int
,	O
1	int
)	O
;	O
dat	array(long double)
[	O
0	int
]	O
=	O
(	O
ABMM	double
-	O
AB11	double
)	O
*	O
(	O
ABNN	double
-	O
AB11	double
)	O
-	O
(	O
AMNBNN	double
*	O
ANMBMM	double
)	O
+	O
(	O
ANMBMM	double
*	O
BMNBNN	double
*	O
AB11	double
)	O
+	O
(	O
A12B22	double
-	O
(	O
AB11	double
*	O
B12B22	double
)	O
)	O
*	O
A21B11	double
;	O
dat	array(long double)
[	O
1	int
]	O
=	O
(	O
(	O
AB22	double
-	O
AB11	double
)	O
-	O
(	O
A21B11	double
*	O
B12B22	double
)	O
-	O
(	O
ABMM	double
-	O
AB11	double
)	O
-	O
(	O
ABNN	double
-	O
AB11	double
)	O
+	O
(	O
ANMBMM	double
*	O
BMNBNN	double
)	O
)	O
*	O
A21B11	double
;	O
dat	array(long double)
[	O
2	int
]	O
=	O
A32B22	double
*	O
A21B11	double
;	O
scale	double
=	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
0	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
1	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
2	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array(long double)
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
1	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
2	int
]	O
/=	O
scale	double
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
-	O
2	int
;	O
++	O
j	long
)	O
{	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
GSL_MIN	O
(	O
j	long
+	O
4	int
,	O
N	int
)	O
;	O
tau	*(double)
=	O
gsl_linalg_householder_transform	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
if	O
(	O
tau	*(double)
!=	O
0.0	int
)	O
{	O
q	*(struct(long,*(long)))
=	O
(	O
size_t	long
)	O
GSL_MAX	O
(	O
0	int
,	O
(	O
int	O
)	O
j	long
-	O
1	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
top	long
+	O
q	*(struct(long,*(long)))
,	O
3	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
q	*(struct(long,*(long)))
)	O
;	O
gsl_linalg_householder_hm	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
q	*(struct(long,*(long)))
,	O
3	int
,	O
N	int
-	O
q	*(struct(long,*(long)))
)	O
;	O
gsl_linalg_householder_hm	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
,	O
3	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
)	O
;	O
gsl_linalg_householder_hm	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
,	O
3	int
,	O
N	int
-	O
j	long
)	O
;	O
gsl_linalg_householder_hm	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
j	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
}	O
dat	array(long double)
[	O
0	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
2	int
,	O
j	long
+	O
2	int
)	O
;	O
dat	array(long double)
[	O
1	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
2	int
,	O
j	long
)	O
;	O
dat	array(long double)
[	O
2	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
2	int
,	O
j	long
+	O
1	int
)	O
;	O
scale	double
=	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
0	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
1	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
2	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array(long double)
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
1	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
2	int
]	O
/=	O
scale	double
;	O
}	O
tau	*(double)
=	O
gsl_linalg_householder_transform	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
if	O
(	O
tau	*(double)
!=	O
0.0	int
)	O
{	O
tmp	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
2	int
)	O
/	O
tmp	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
2	int
,	O
1.0	int
/	O
tmp	double
)	O
;	O
tau	*(double)
*=	O
tmp	double
*	O
tmp	double
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
j	long
,	O
top	long
+	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
j	long
,	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
+	O
3	int
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
j	long
,	O
j	long
+	O
3	int
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
j	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
,	O
3	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v3	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
}	O
dat	array(long double)
[	O
0	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
;	O
dat	array(long double)
[	O
1	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
)	O
;	O
scale	double
=	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
0	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array(long double)
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
1	int
]	O
/=	O
scale	double
;	O
}	O
tau	*(double)
=	O
gsl_linalg_householder_transform	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
if	O
(	O
tau	*(double)
!=	O
0.0	int
)	O
{	O
tmp	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
1.0	int
/	O
tmp	double
)	O
;	O
tau	*(double)
*=	O
tmp	double
*	O
tmp	double
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
j	long
,	O
top	long
+	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
j	long
,	O
r	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
+	O
3	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
j	long
,	O
j	long
+	O
3	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
j	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
}	O
dat	array(long double)
[	O
0	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
)	O
;	O
dat	array(long double)
[	O
1	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
2	int
,	O
j	long
)	O
;	O
if	O
(	O
j	long
<	O
N	int
-	O
3	int
)	O
dat	array(long double)
[	O
2	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
3	int
,	O
j	long
)	O
;	O
scale	double
=	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
0	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
1	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
2	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array(long double)
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
1	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
2	int
]	O
/=	O
scale	double
;	O
}	O
}	O
scale	double
=	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
0	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array(long double)
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
1	int
]	O
/=	O
scale	double
;	O
}	O
tau	*(double)
=	O
gsl_linalg_householder_transform	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
N	int
-	O
2	int
,	O
top	long
+	O
N	int
-	O
3	int
,	O
2	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
N	int
+	O
3	int
)	O
;	O
gsl_linalg_householder_hm	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
3	int
,	O
2	int
,	O
3	int
)	O
;	O
gsl_linalg_householder_hm	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
N	int
-	O
2	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
2	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
N	int
+	O
2	int
)	O
;	O
gsl_linalg_householder_hm	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
N	int
-	O
2	int
,	O
2	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_hm	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
dat	array(long double)
[	O
0	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
;	O
dat	array(long double)
[	O
1	int
]	O
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
;	O
scale	double
=	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
0	int
]	O
)	O
+	O
fabs	(double)->(double)
(	O
dat	array(long double)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
scale	double
!=	O
0.0	int
)	O
{	O
dat	array(long double)
[	O
0	int
]	O
/=	O
scale	double
;	O
dat	array(long double)
[	O
1	int
]	O
/=	O
scale	double
;	O
}	O
tau	*(double)
=	O
gsl_linalg_householder_transform	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
tmp	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
1.0	int
/	O
tmp	double
)	O
;	O
tau	*(double)
*=	O
tmp	double
*	O
tmp	double
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
top	long
+	O
N	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
N	int
-	O
2	int
,	O
N	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
top	long
+	O
N	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
else	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
N	int
-	O
2	int
,	O
N	int
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
top	long
+	O
N	int
-	O
2	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
,	O
2	int
)	O
;	O
gsl_linalg_householder_mh	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
tau	*(double)
,	O
&	O
v2	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
}	O
static	O
void	O
gen_tri_split_top	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
;	O
size_t	long
j	long
,	O
top	long
=	O
0	int
;	O
double	O
cs	double
,	O
sn	double
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
j	long
=	O
0	int
;	O
gsl_linalg_givens	(double,double,*(double),*(double))->(void)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
)	O
,	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
)	O
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
top	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_row	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_row	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
,	O
0.0	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
top	long
+	O
1	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
1	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
1	int
,	O
N	int
-	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
1	int
,	O
N	int
-	O
1	int
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
}	O
static	O
inline	O
void	O
gen_tri_chase_zero	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
size_t	long
q	*(struct(long,*(long)))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
;	O
size_t	long
j	long
,	O
top	long
=	O
0	int
;	O
double	O
cs	double
,	O
sn	double
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
for	O
(	O
j	long
=	O
q	*(struct(long,*(long)))
;	O
j	long
<	O
N	int
-	O
1	int
;	O
++	O
j	long
)	O
{	O
gsl_linalg_givens	(double,double,*(double),*(double))->(void)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
+	O
1	int
)	O
,	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
+	O
1	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
-	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
j	long
+	O
1	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
-	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
+	O
1	int
,	O
N	int
-	O
j	long
-	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
,	O
N	int
-	O
j	long
-	O
1	int
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
,	O
0.0	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
top	long
+	O
j	long
-	O
1	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
+	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
,	O
top	long
+	O
j	long
-	O
1	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
j	long
+	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
j	long
-	O
1	int
,	O
N	int
-	O
j	long
+	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
,	O
N	int
-	O
j	long
+	O
1	int
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
gsl_linalg_givens	(double,double,*(double),*(double))->(void)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
)	O
,	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
)	O
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
0	int
,	O
top	long
+	O
j	long
+	O
2	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
-	O
1	int
,	O
0	int
,	O
top	long
+	O
j	long
+	O
2	int
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
0	int
,	O
j	long
+	O
2	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
-	O
1	int
,	O
0	int
,	O
j	long
+	O
2	int
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
+	O
1	int
,	O
j	long
-	O
1	int
,	O
0.0	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
,	O
0	int
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
-	O
1	int
,	O
0	int
,	O
top	long
+	O
j	long
+	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
0	int
,	O
j	long
+	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
-	O
1	int
,	O
0	int
,	O
j	long
+	O
1	int
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
j	long
-	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
}	O
}	O
static	O
inline	O
void	O
gen_tri_zero_H	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
;	O
size_t	long
top	long
=	O
0	int
;	O
double	O
cs	double
,	O
sn	double
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
gsl_linalg_givens	(double,double,*(double),*(double))->(void)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
1	int
)	O
,	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
)	O
,	O
&	O
cs	double
,	O
&	O
sn	double
)	O
;	O
sn	double
=	O
-	O
sn	double
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
N	int
-	O
1	int
,	O
0	int
,	O
top	long
+	O
N	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
N	int
-	O
2	int
,	O
0	int
,	O
top	long
+	O
N	int
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
N	int
-	O
2	int
,	O
0.0	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
N	int
-	O
1	int
,	O
0	int
,	O
top	long
+	O
N	int
-	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
N	int
-	O
2	int
,	O
0	int
,	O
top	long
+	O
N	int
-	O
1	int
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
1	int
,	O
0	int
,	O
N	int
-	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
N	int
-	O
2	int
,	O
0	int
,	O
N	int
-	O
1	int
)	O
;	O
}	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
N	int
-	O
1	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
N	int
-	O
2	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cs	double
,	O
sn	double
)	O
;	O
}	O
}	O
static	O
inline	O
size_t	long
gen_search_small_elements	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(int),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
int	O
*	O
flag	*(int)
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
const	O
size_t	long
N	int
=	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
;	O
int	O
k	long
;	O
size_t	long
i	long
;	O
int	O
pass1	int
=	O
0	int
;	O
int	O
pass2	int
=	O
0	int
;	O
for	O
(	O
k	long
=	O
(	O
int	O
)	O
N	int
-	O
1	int
;	O
k	long
>=	O
0	int
;	O
--	O
k	long
)	O
{	O
i	long
=	O
(	O
size_t	long
)	O
k	long
;	O
if	O
(	O
i	long
!=	O
0	int
&&	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
i	long
-	O
1	int
)	O
)	O
<=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
atol	(*(char))->(long)
)	O
{	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
i	long
-	O
1	int
,	O
0.0	int
)	O
;	O
pass1	int
=	O
1	int
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
i	long
)	O
)	O
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
btol	double
)	O
{	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
i	long
,	O
0.0	int
)	O
;	O
pass2	int
=	O
1	int
;	O
}	O
if	O
(	O
pass1	int
&&	O
!	O
pass2	int
)	O
{	O
*	O
flag	*(int)
=	O
1	int
;	O
return	O
(	O
i	long
)	O
;	O
}	O
else	O
if	O
(	O
!	O
pass1	int
&&	O
pass2	int
)	O
{	O
*	O
flag	*(int)
=	O
2	int
;	O
return	O
(	O
i	long
)	O
;	O
}	O
else	O
if	O
(	O
pass1	int
&&	O
pass2	int
)	O
{	O
*	O
flag	*(int)
=	O
3	int
;	O
return	O
(	O
i	long
)	O
;	O
}	O
}	O
*	O
flag	*(int)
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
gen_schur_standardize1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
double	O
*	O
alphar	*(double)
,	O
double	O
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
top	long
=	O
0	int
;	O
if	O
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
B	*(float)
,	O
0	int
,	O
0	int
)	O
<	O
0.0	int
)	O
{	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
A	*(float)
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
top	long
;	O
++	O
i	long
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
)	O
)	O
;	O
}	O
else	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
B	*(float)
,	O
0	int
,	O
0	int
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
B	*(float)
,	O
0	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
top	long
;	O
++	O
i	long
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
)	O
)	O
;	O
}	O
else	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
A	*(float)
,	O
0	int
,	O
0	int
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
0	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
;	O
++	O
i	long
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
)	O
)	O
;	O
}	O
}	O
*	O
alphar	*(double)
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
0	int
,	O
0	int
)	O
;	O
*	O
beta	long double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
B	*(float)
,	O
0	int
,	O
0	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
gen_schur_standardize2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),*(struct(array(double))),*(double),*(double),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_complex	struct(array(double))
*	O
alpha1	*(struct(array(double)))
,	O
gsl_complex	struct(array(double))
*	O
alpha2	*(struct(array(double)))
,	O
double	O
*	O
beta1	*(double)
,	O
double	O
*	O
beta2	*(double)
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
double	O
datB	array(double)
[	O
4	int
]	O
,	O
datV	array(double)
[	O
4	int
]	O
,	O
datS	array(double)
[	O
2	int
]	O
,	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
[	O
2	int
]	O
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_view_array	(*(double),long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
datB	array(double)
,	O
2	int
,	O
2	int
)	O
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
vv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_view_array	(*(double),long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
datV	array(double)
,	O
2	int
,	O
2	int
)	O
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
sv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_view_array	(*(double),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
datS	array(double)
,	O
2	int
)	O
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
wv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_view_array	(*(double),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
2	int
)	O
;	O
double	O
B11	double
,	O
B22	double
;	O
size_t	long
top	long
=	O
0	int
;	O
double	O
det	double
;	O
double	O
cr	double
,	O
sr	double
,	O
cl	double
,	O
sl	double
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
int	O
s	*(float)
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
needtop	int
)	O
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
A	*(float)
)	O
;	O
gsl_matrix_memcpy	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
&	O
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
B	*(float)
)	O
;	O
gsl_linalg_SV_decomp	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
&	O
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
vv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
sv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
wv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
det	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
vv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
vv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
1	int
)	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
vv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
1	int
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
vv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
det	double
<	O
0.0	int
)	O
{	O
datS	array(double)
[	O
1	int
]	O
=	O
-	O
datS	array(double)
[	O
1	int
]	O
;	O
}	O
cr	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
vv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
)	O
;	O
sr	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
vv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
0	int
)	O
;	O
det	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
1	int
)	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
1	int
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
det	double
<	O
0.0	int
)	O
datS	array(double)
[	O
1	int
]	O
=	O
-	O
datS	array(double)
[	O
1	int
]	O
;	O
cl	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
,	O
0	int
)	O
;	O
sl	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
&	O
uv	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
,	O
0	int
)	O
;	O
B11	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
sv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
)	O
;	O
B22	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
sv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
1	int
)	O
;	O
if	O
(	O
B11	double
<	O
0.0	int
)	O
{	O
B11	double
=	O
-	O
B11	double
;	O
B22	double
=	O
-	O
B22	double
;	O
cr	double
=	O
-	O
cr	double
;	O
sr	double
=	O
-	O
sr	double
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
,	O
top	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
1	int
,	O
top	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cl	double
,	O
sl	double
)	O
;	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
,	O
0	int
,	O
top	long
+	O
2	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
1	int
,	O
0	int
,	O
top	long
+	O
2	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cr	double
,	O
sr	double
)	O
;	O
}	O
else	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_row	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
A	*(float)
,	O
0	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_row	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
A	*(float)
,	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cl	double
,	O
sl	double
)	O
;	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
A	*(float)
,	O
0	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
A	*(float)
,	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cr	double
,	O
sr	double
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
if	O
(	O
top	long
!=	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
2	int
)	O
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
,	O
top	long
+	O
2	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
2	int
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subrow	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
1	int
,	O
top	long
+	O
2	int
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
size	long
-	O
top	long
-	O
2	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cl	double
,	O
sl	double
)	O
;	O
}	O
if	O
(	O
top	long
!=	O
0	int
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
,	O
0	int
,	O
top	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
1	int
,	O
0	int
,	O
top	long
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cr	double
,	O
sr	double
)	O
;	O
}	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Q	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cl	double
,	O
sl	double
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
)	O
;	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
1	int
)	O
;	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
yv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
cr	double
,	O
sr	double
)	O
;	O
}	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
B	*(float)
,	O
0	int
,	O
0	int
,	O
B11	double
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
B	*(float)
,	O
0	int
,	O
1	int
,	O
0.0	int
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
B	*(float)
,	O
1	int
,	O
0	int
,	O
0.0	int
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
B	*(float)
,	O
1	int
,	O
1	int
,	O
B22	double
)	O
;	O
if	O
(	O
B22	double
<	O
0.0	int
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_s	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
top	long
+	O
2	int
;	O
++	O
i	long
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
+	O
1	int
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
+	O
1	int
)	O
)	O
;	O
}	O
else	O
{	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
A	*(float)
,	O
0	int
,	O
1	int
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
0	int
,	O
1	int
)	O
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
A	*(float)
,	O
1	int
,	O
1	int
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
1	int
,	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
compute_t	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
top	long
+	O
2	int
;	O
++	O
i	long
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
+	O
1	int
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
R	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
top	long
+	O
1	int
)	O
)	O
;	O
}	O
else	O
{	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
B	*(float)
,	O
0	int
,	O
1	int
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
B	*(float)
,	O
0	int
,	O
1	int
)	O
)	O
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
B	*(float)
,	O
1	int
,	O
1	int
,	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
B	*(float)
,	O
1	int
,	O
1	int
)	O
)	O
;	O
}	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
Z	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
top	long
+	O
1	int
)	O
;	O
gsl_vector_scale	(*(struct(long,long,*(double),*(struct(long,*`)),int)),double)->(int)
(	O
&	O
xv	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
-	O
1.0	int
)	O
;	O
}	O
}	O
s	*(float)
=	O
gen_compute_eigenvals	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),*(struct(array(double))),*(double),*(double))->(int)
(	O
A	*(float)
,	O
B	*(float)
,	O
alpha1	*(struct(array(double)))
,	O
alpha2	*(struct(array(double)))
,	O
beta1	*(double)
,	O
beta2	*(double)
)	O
;	O
return	O
s	*(float)
;	O
}	O
static	O
int	O
gen_compute_eigenvals	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),*(struct(array(double))),*(double),*(double))->(int)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_complex	struct(array(double))
*	O
alpha1	*(struct(array(double)))
,	O
gsl_complex	struct(array(double))
*	O
alpha2	*(struct(array(double)))
,	O
double	O
*	O
beta1	*(double)
,	O
double	O
*	O
beta2	*(double)
)	O
{	O
double	O
wr1	*(double)
,	O
wr2	*(double)
,	O
wi	*(double)
,	O
scale1	*(double)
,	O
scale2	*(double)
;	O
double	O
s1inv	double
;	O
double	O
A11	double
,	O
A12	double
,	O
A21	double
,	O
A22	double
;	O
double	O
B11	double
,	O
B22	double
;	O
double	O
c11r	double
,	O
c11i	double
,	O
c12	double
,	O
c21	double
,	O
c22r	double
,	O
c22i	double
;	O
double	O
cz	double
,	O
cq	double
;	O
double	O
szr	double
,	O
szi	double
,	O
sqr	double
,	O
sqi	double
;	O
double	O
a1r	double
,	O
a1i	double
,	O
a2r	double
,	O
a2i	double
,	O
b1r	double
,	O
b1i	double
,	O
b1a	double
,	O
b2r	double
,	O
b2i	double
,	O
b2a	double
;	O
double	O
alphar	*(double)
,	O
alphai	double
;	O
double	O
t1	double
,	O
an	double
,	O
bn	double
,	O
tempr	double
,	O
tempi	double
,	O
wabs	double
;	O
gsl_schur_gen_eigvals	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(double),*(double),*(double))->(int)
(	O
A	*(float)
,	O
B	*(float)
,	O
&	O
wr1	*(double)
,	O
&	O
wr2	*(double)
,	O
&	O
wi	*(double)
,	O
&	O
scale1	*(double)
,	O
&	O
scale2	*(double)
)	O
;	O
if	O
(	O
wi	*(double)
==	O
0.0	int
)	O
return	O
GSL_CONTINUE	int
;	O
s1inv	double
=	O
1.0	int
/	O
scale1	*(double)
;	O
A11	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
0	int
,	O
0	int
)	O
;	O
A12	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
0	int
,	O
1	int
)	O
;	O
A21	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
1	int
,	O
0	int
)	O
;	O
A22	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
1	int
,	O
1	int
)	O
;	O
B11	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
B	*(float)
,	O
0	int
,	O
0	int
)	O
;	O
B22	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
B	*(float)
,	O
1	int
,	O
1	int
)	O
;	O
c11r	double
=	O
scale1	*(double)
*	O
A11	double
-	O
wr1	*(double)
*	O
B11	double
;	O
c11i	double
=	O
-	O
wi	*(double)
*	O
B11	double
;	O
c12	double
=	O
scale1	*(double)
*	O
A12	double
;	O
c21	double
=	O
scale1	*(double)
*	O
A21	double
;	O
c22r	double
=	O
scale1	*(double)
*	O
A22	double
-	O
wr1	*(double)
*	O
B22	double
;	O
c22i	double
=	O
-	O
wi	*(double)
*	O
B22	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
c11r	double
)	O
+	O
fabs	(double)->(double)
(	O
c11i	double
)	O
+	O
fabs	(double)->(double)
(	O
c12	double
)	O
>	O
fabs	(double)->(double)
(	O
c21	double
)	O
+	O
fabs	(double)->(double)
(	O
c22r	double
)	O
+	O
fabs	(double)->(double)
(	O
c22i	double
)	O
)	O
{	O
t1	double
=	O
gsl_hypot3	(double,double,double)->(double)
(	O
c12	double
,	O
c11r	double
,	O
c11i	double
)	O
;	O
if	O
(	O
t1	double
!=	O
0.0	int
)	O
{	O
cz	double
=	O
c12	double
/	O
t1	double
;	O
szr	double
=	O
-	O
c11r	double
/	O
t1	double
;	O
szi	double
=	O
-	O
c11i	double
/	O
t1	double
;	O
}	O
else	O
{	O
cz	double
=	O
0.0	int
;	O
szr	double
=	O
1.0	int
;	O
szi	double
=	O
0.0	int
;	O
}	O
}	O
else	O
{	O
cz	double
=	O
hypot	(double,double)->(double)
(	O
c22r	double
,	O
c22i	double
)	O
;	O
if	O
(	O
cz	double
<=	O
GSL_DBL_MIN	int
)	O
{	O
cz	double
=	O
0.0	int
;	O
szr	double
=	O
1.0	int
;	O
szi	double
=	O
0.0	int
;	O
}	O
else	O
{	O
tempr	double
=	O
c22r	double
/	O
cz	double
;	O
tempi	double
=	O
c22i	double
/	O
cz	double
;	O
t1	double
=	O
hypot	(double,double)->(double)
(	O
cz	double
,	O
c21	double
)	O
;	O
cz	double
/=	O
t1	double
;	O
szr	double
=	O
-	O
c21	double
*	O
tempr	double
/	O
t1	double
;	O
szi	double
=	O
c21	double
*	O
tempi	double
/	O
t1	double
;	O
}	O
}	O
an	double
=	O
fabs	(double)->(double)
(	O
A11	double
)	O
+	O
fabs	(double)->(double)
(	O
A12	double
)	O
+	O
fabs	(double)->(double)
(	O
A21	double
)	O
+	O
fabs	(double)->(double)
(	O
A22	double
)	O
;	O
bn	double
=	O
fabs	(double)->(double)
(	O
B11	double
)	O
+	O
fabs	(double)->(double)
(	O
B22	double
)	O
;	O
wabs	double
=	O
fabs	(double)->(double)
(	O
wr1	*(double)
)	O
+	O
fabs	(double)->(double)
(	O
wi	*(double)
)	O
;	O
if	O
(	O
scale1	*(double)
*	O
an	double
>	O
wabs	double
*	O
bn	double
)	O
{	O
cq	double
=	O
cz	double
*	O
B11	double
;	O
if	O
(	O
cq	double
<=	O
GSL_DBL_MIN	int
)	O
{	O
cq	double
=	O
0.0	int
;	O
sqr	double
=	O
1.0	int
;	O
sqi	double
=	O
0.0	int
;	O
}	O
else	O
{	O
sqr	double
=	O
szr	double
*	O
B22	double
;	O
sqi	double
=	O
-	O
szi	double
*	O
B22	double
;	O
}	O
}	O
else	O
{	O
a1r	double
=	O
cz	double
*	O
A11	double
+	O
szr	double
*	O
A12	double
;	O
a1i	double
=	O
szi	double
*	O
A12	double
;	O
a2r	double
=	O
cz	double
*	O
A21	double
+	O
szr	double
*	O
A22	double
;	O
a2i	double
=	O
szi	double
*	O
A22	double
;	O
cq	double
=	O
hypot	(double,double)->(double)
(	O
a1r	double
,	O
a1i	double
)	O
;	O
if	O
(	O
cq	double
<=	O
GSL_DBL_MIN	int
)	O
{	O
cq	double
=	O
0.0	int
;	O
sqr	double
=	O
1.0	int
;	O
sqi	double
=	O
0.0	int
;	O
}	O
else	O
{	O
tempr	double
=	O
a1r	double
/	O
cq	double
;	O
tempi	double
=	O
a1i	double
/	O
cq	double
;	O
sqr	double
=	O
tempr	double
*	O
a2r	double
+	O
tempi	double
*	O
a2i	double
;	O
sqi	double
=	O
tempi	double
*	O
a2r	double
-	O
tempr	double
*	O
a2i	double
;	O
}	O
}	O
t1	double
=	O
gsl_hypot3	(double,double,double)->(double)
(	O
cq	double
,	O
sqr	double
,	O
sqi	double
)	O
;	O
cq	double
/=	O
t1	double
;	O
sqr	double
/=	O
t1	double
;	O
sqi	double
/=	O
t1	double
;	O
tempr	double
=	O
sqr	double
*	O
szr	double
-	O
sqi	double
*	O
szi	double
;	O
tempi	double
=	O
sqr	double
*	O
szi	double
+	O
sqi	double
*	O
szr	double
;	O
b1r	double
=	O
cq	double
*	O
cz	double
*	O
B11	double
+	O
tempr	double
*	O
B22	double
;	O
b1i	double
=	O
tempi	double
*	O
B22	double
;	O
b1a	double
=	O
hypot	(double,double)->(double)
(	O
b1r	double
,	O
b1i	double
)	O
;	O
b2r	double
=	O
cq	double
*	O
cz	double
*	O
B22	double
+	O
tempr	double
*	O
B11	double
;	O
b2i	double
=	O
-	O
tempi	double
*	O
B11	double
;	O
b2a	double
=	O
hypot	(double,double)->(double)
(	O
b2r	double
,	O
b2i	double
)	O
;	O
*	O
beta1	*(double)
=	O
b1a	double
;	O
*	O
beta2	*(double)
=	O
b2a	double
;	O
alphar	*(double)
=	O
(	O
wr1	*(double)
*	O
b1a	double
)	O
*	O
s1inv	double
;	O
alphai	double
=	O
(	O
wi	*(double)
*	O
b1a	double
)	O
*	O
s1inv	double
;	O
GSL_SET_COMPLEX	O
(	O
alpha1	*(struct(array(double)))
,	O
alphar	*(double)
,	O
alphai	double
)	O
;	O
alphar	*(double)
=	O
(	O
wr1	*(double)
*	O
b2a	double
)	O
*	O
s1inv	double
;	O
alphai	double
=	O
-	O
(	O
wi	*(double)
*	O
b2a	double
)	O
*	O
s1inv	double
;	O
GSL_SET_COMPLEX	O
(	O
alpha2	*(struct(array(double)))
,	O
alphar	*(double)
,	O
alphai	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
void	O
gen_store_eigval1	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
double	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
const	O
double	O
b	*(struct(long,*(long double)))
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
gsl_complex	struct(array(double))
z	struct(array(long double))
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z	struct(array(long double))
,	O
a	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
0.0	int
)	O
;	O
gsl_vector_complex_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,struct(array(double)))->(void)
(	O
alpha	long double
,	O
top	long
,	O
z	struct(array(long double))
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
beta	long double
,	O
top	long
,	O
b	*(struct(long,*(long double)))
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_evals	long
+=	O
1	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_iter	long
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
=	O
0.0	int
;	O
}	O
static	O
void	O
gen_store_eigval2	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))),double,*(struct(array(double))),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(struct(long,long,*`,*`,int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),int,int,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
gsl_complex	struct(array(double))
*	O
alpha1	*(struct(array(double)))
,	O
const	O
double	O
beta1	*(double)
,	O
const	O
gsl_complex	struct(array(double))
*	O
alpha2	*(struct(array(double)))
,	O
const	O
double	O
beta2	*(double)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
alpha	long double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
beta	long double
,	O
gsl_eigen_gen_workspace	struct(long,*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,long,double,int,double,double,double,double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),int,int,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
top	long
=	O
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
H	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
gsl_vector_complex_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,struct(array(double)))->(void)
(	O
alpha	long double
,	O
top	long
,	O
*	O
alpha1	*(struct(array(double)))
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
beta	long double
,	O
top	long
,	O
beta1	*(double)
)	O
;	O
gsl_vector_complex_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,struct(array(double)))->(void)
(	O
alpha	long double
,	O
top	long
+	O
1	int
,	O
*	O
alpha2	*(struct(array(double)))
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
beta	long double
,	O
top	long
+	O
1	int
,	O
beta2	*(double)
)	O
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_evals	long
+=	O
2	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n_iter	long
=	O
0	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
eshift	double
=	O
0.0	int
;	O
}	O
static	O
inline	O
size_t	long
gen_get_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
)	O
{	O
size_t	long
diff	long
;	O
double	O
ratio	double
;	O
size_t	long
top	long
;	O
diff	long
=	O
(	O
size_t	long
)	O
(	O
B	*(float)
->	O
data	*(long double)
-	O
A	*(float)
->	O
data	*(long double)
)	O
;	O
ratio	double
=	O
(	O
double	O
)	O
diff	long
/	O
(	O
(	O
double	O
)	O
(	O
A	*(float)
->	O
tda	long
+	O
1	int
)	O
)	O
;	O
top	long
=	O
(	O
size_t	long
)	O
floor	(double)->(double)
(	O
ratio	double
)	O
;	O
return	O
top	long
;	O
}	O
inline	O
static	O
double	O
normF	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
{	O
size_t	long
i	long
,	O
j	long
,	O
M	int
=	O
A	*(float)
->	O
size1	long
,	O
N	int
=	O
A	*(float)
->	O
size2	long
;	O
double	O
sum	double
=	O
0.0	int
,	O
scale	double
=	O
0.0	int
,	O
ssq	double
=	O
1.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
M	int
;	O
i	long
++	O
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
;	O
j	long
++	O
)	O
{	O
double	O
Aij	double
=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
A	*(float)
,	O
i	long
,	O
j	long
)	O
;	O
if	O
(	O
Aij	double
!=	O
0.0	int
)	O
{	O
double	O
ax	double
=	O
fabs	(double)->(double)
(	O
Aij	double
)	O
;	O
if	O
(	O
scale	double
<	O
ax	double
)	O
{	O
ssq	double
=	O
1.0	int
+	O
ssq	double
*	O
(	O
scale	double
/	O
ax	double
)	O
*	O
(	O
scale	double
/	O
ax	double
)	O
;	O
scale	double
=	O
ax	double
;	O
}	O
else	O
{	O
ssq	double
+=	O
(	O
ax	double
/	O
scale	double
)	O
*	O
(	O
ax	double
/	O
scale	double
)	O
;	O
}	O
}	O
}	O
}	O
sum	double
=	O
scale	double
*	O
sqrt	(double)->(double)
(	O
ssq	double
)	O
;	O
return	O
sum	double
;	O
}	O
