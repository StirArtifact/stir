enum	O
{	O
BILLION	int
=	O
1000	int
*	O
1000	int
*	O
1000	int
}	O
;	O
int	O
nanosleep	(*(struct(long,long)),*(struct(long,long)))->(int)
(	O
const	O
struct	O
timespec	struct(long,long)
*	O
requested_delay	*(struct(long,long))
,	O
struct	O
timespec	struct(long,long)
*	O
remaining_delay	*(struct(long,long))
)	O
{	O
if	O
(	O
requested_delay	*(struct(long,long))
->	O
tv_nsec	long
<	O
0	int
||	O
BILLION	int
<=	O
requested_delay	*(struct(long,long))
->	O
tv_nsec	long
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
{	O
verify	O
(	O
TYPE_MAXIMUM	O
(	O
time_t	long
)	O
/	O
24	int
/	O
24	int
/	O
60	int
/	O
60	int
)	O
;	O
const	O
time_t	long
limit	long
=	O
24	int
*	O
24	int
*	O
60	int
*	O
60	int
;	O
time_t	long
seconds	long
=	O
requested_delay	*(struct(long,long))
->	O
tv_sec	long
;	O
struct	O
timespec	struct(long,long)
intermediate	struct(long,long)
;	O
intermediate	struct(long,long)
.	O
tv_nsec	long
=	O
requested_delay	*(struct(long,long))
->	O
tv_nsec	long
;	O
while	O
(	O
limit	long
<	O
seconds	long
)	O
{	O
int	O
result	int
;	O
intermediate	struct(long,long)
.	O
tv_sec	long
=	O
limit	long
;	O
result	int
=	O
nanosleep	(*(struct(long,long)),*(struct(long,long)))->(int)
(	O
&	O
intermediate	struct(long,long)
,	O
remaining_delay	*(struct(long,long))
)	O
;	O
seconds	long
-=	O
limit	long
;	O
if	O
(	O
result	int
)	O
{	O
if	O
(	O
remaining_delay	*(struct(long,long))
)	O
remaining_delay	*(struct(long,long))
->	O
tv_sec	long
+=	O
seconds	long
;	O
return	O
result	int
;	O
}	O
intermediate	struct(long,long)
.	O
tv_nsec	long
=	O
0	int
;	O
}	O
intermediate	struct(long,long)
.	O
tv_sec	long
=	O
seconds	long
;	O
return	O
nanosleep	(*(struct(long,long)),*(struct(long,long)))->(int)
(	O
&	O
intermediate	struct(long,long)
,	O
remaining_delay	*(struct(long,long))
)	O
;	O
}	O
}	O
