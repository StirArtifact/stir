struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
{	O
char	O
*	O
keyword	short
;	O
unsigned	O
char	O
first	*(char)
;	O
char	O
*	O
whole_word_chars_left	*(char)
;	O
char	O
*	O
whole_word_chars_right	*(char)
;	O
int	O
line_start	int
;	O
int	O
color	*(int)
;	O
}	O
;	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
{	O
char	O
*	O
left	*(char)
;	O
unsigned	O
char	O
first_left	char
;	O
char	O
*	O
right	*(char)
;	O
unsigned	O
char	O
first_right	char
;	O
char	O
line_start_left	char
;	O
char	O
line_start_right	char
;	O
int	O
between_delimiters	int
;	O
char	O
*	O
whole_word_chars_left	*(char)
;	O
char	O
*	O
whole_word_chars_right	*(char)
;	O
char	O
*	O
keyword_first_chars	*(char)
;	O
int	O
spelling	int
;	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
*	O
*	O
keyword	short
;	O
}	O
;	O
struct	O
_syntax_marker	struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct`))))))
{	O
long	O
offset	long
;	O
struct	O
syntax_rule	struct(short,char,char,char,char)
rule	struct(short,char,char,char,char)
;	O
struct	O
_syntax_marker	struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
;	O
int	O
option_syntax_highlighting	int
=	O
1	int
;	O
int	O
option_auto_syntax	int
=	O
1	int
;	O
char	O
*	O
option_syntax_type	*(char)
=	O
NULL	O
;	O
static	O
gint	int
mc_defines_destroy	(*(void),*(void),*(void))->(int)
(	O
gpointer	*(void)
key	*(void)
,	O
gpointer	*(void)
value	*(void)
,	O
gpointer	*(void)
data	*(void)
)	O
{	O
char	O
*	O
*	O
values	*(*(char))
=	O
value	*(void)
;	O
(	O
void	O
)	O
data	*(void)
;	O
g_free	(*(void))->(void)
(	O
key	*(void)
)	O
;	O
while	O
(	O
*	O
values	*(*(char))
)	O
g_free	(*(void))->(void)
(	O
*	O
values	*(*(char))
++	O
)	O
;	O
g_free	(*(void))->(void)
(	O
value	*(void)
)	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
inline	O
void	O
destroy_defines	(*(*(struct)))->(void)
(	O
GTree	struct
*	O
*	O
defines	*(struct)
)	O
{	O
g_tree_traverse	(*(struct),*((*(void),*(void),*(void))->(int)),enum(int,int,int,int),*(void))->(void)
(	O
*	O
defines	*(struct)
,	O
mc_defines_destroy	(*(void),*(void),*(void))->(int)
,	O
G_POST_ORDER	int
,	O
NULL	O
)	O
;	O
g_tree_destroy	(*(struct))->(void)
(	O
*	O
defines	*(struct)
)	O
;	O
*	O
defines	*(struct)
=	O
0	int
;	O
}	O
static	O
void	O
subst_defines	(*(struct),*(*(char)),*(*(char)))->(void)
(	O
GTree	struct
*	O
defines	*(struct)
,	O
char	O
*	O
*	O
argv	*(*(*(char)))
,	O
char	O
*	O
*	O
argv_end	*(*(char))
)	O
{	O
char	O
*	O
*	O
t	long
,	O
*	O
*	O
p	*(void)
;	O
int	O
argc	*(int)
;	O
while	O
(	O
*	O
argv	*(*(*(char)))
&&	O
argv	*(*(*(char)))
<	O
argv_end	*(*(char))
)	O
{	O
if	O
(	O
(	O
t	long
=	O
g_tree_lookup	(*(struct),*(void))->(*(void))
(	O
defines	*(struct)
,	O
*	O
argv	*(*(*(char)))
)	O
)	O
)	O
{	O
int	O
count	int
=	O
0	int
;	O
argc	*(int)
=	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
&	O
argv	*(*(*(char)))
[	O
1	int
]	O
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
argc	*(int)
++	O
;	O
for	O
(	O
p	*(void)
=	O
t	long
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
count	int
++	O
;	O
p	*(void)
=	O
&	O
argv	*(*(*(char)))
[	O
count	int
+	O
argc	*(int)
]	O
;	O
if	O
(	O
p	*(void)
>=	O
argv_end	*(*(char))
)	O
break	O
;	O
while	O
(	O
argc	*(int)
>=	O
0	int
)	O
*	O
p	*(void)
--	O
=	O
argv	*(*(*(char)))
[	O
argc	*(int)
--	O
+	O
1	int
]	O
;	O
for	O
(	O
p	*(void)
=	O
argv	*(*(*(char)))
;	O
*	O
t	long
;	O
*	O
p	*(void)
++	O
=	O
*	O
t	long
++	O
)	O
;	O
}	O
argv	*(*(*(char)))
++	O
;	O
}	O
}	O
static	O
long	O
compare_word_to_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,*(char),*(char),*(char),int)->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
i	array(int)
,	O
const	O
char	O
*	O
text	*(char)
,	O
const	O
char	O
*	O
whole_left	*(char)
,	O
const	O
char	O
*	O
whole_right	*(char)
,	O
int	O
line_start	int
)	O
{	O
const	O
unsigned	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
;	O
int	O
c	int
,	O
d	double
,	O
j	int
;	O
if	O
(	O
!	O
*	O
text	*(char)
)	O
return	O
-	O
1	int
;	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
-	O
1	int
)	O
;	O
if	O
(	O
line_start	int
)	O
if	O
(	O
c	int
!=	O
'\n'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
whole_left	*(char)
)	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
whole_left	*(char)
,	O
c	int
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
p	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
text	*(char)
,	O
q	*(char)
=	O
p	*(void)
+	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
<	O
q	*(char)
;	O
p	*(void)
++	O
,	O
i	array(int)
++	O
)	O
{	O
switch	O
(	O
*	O
p	*(void)
)	O
{	O
case	O
SYNTAX_TOKEN_STAR	char
:	O
if	O
(	O
++	O
p	*(void)
>	O
q	*(char)
)	O
return	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
;	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
if	O
(	O
whole_right	*(char)
)	O
if	O
(	O
!	O
strchr	(*(char),int)->(*(char))
(	O
whole_right	*(char)
,	O
c	int
)	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
*	O
p	*(void)
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
return	O
-	O
1	int
;	O
i	array(int)
++	O
;	O
}	O
break	O
;	O
case	O
SYNTAX_TOKEN_PLUS	char
:	O
if	O
(	O
++	O
p	*(void)
>	O
q	*(char)
)	O
return	O
-	O
1	int
;	O
j	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
;	O
if	O
(	O
c	int
==	O
*	O
p	*(void)
)	O
{	O
j	int
=	O
i	array(int)
;	O
if	O
(	O
*	O
p	*(void)
==	O
*	O
text	*(char)
&&	O
!	O
p	*(void)
[	O
1	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
&&	O
strchr	(*(char),int)->(*(char))
(	O
(	O
char	O
*	O
)	O
p	*(void)
+	O
1	int
,	O
c	int
)	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\t'	O
||	O
c	int
==	O
' '	O
)	O
{	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
{	O
i	array(int)
--	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
j	int
)	O
return	O
-	O
1	int
;	O
i	array(int)
=	O
j	int
;	O
break	O
;	O
}	O
if	O
(	O
whole_right	*(char)
)	O
if	O
(	O
!	O
strchr	(*(char),int)->(*(char))
(	O
whole_right	*(char)
,	O
c	int
)	O
)	O
{	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
{	O
i	array(int)
--	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
j	int
)	O
return	O
-	O
1	int
;	O
i	array(int)
=	O
j	int
;	O
break	O
;	O
}	O
i	array(int)
++	O
;	O
}	O
break	O
;	O
case	O
SYNTAX_TOKEN_BRACKET	char
:	O
if	O
(	O
++	O
p	*(void)
>	O
q	*(char)
)	O
return	O
-	O
1	int
;	O
c	int
=	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
i	array(int)
++	O
)	O
{	O
d	double
=	O
c	int
;	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
p	*(void)
[	O
j	int
]	O
!=	O
SYNTAX_TOKEN_BRACKET	char
&&	O
p	*(void)
[	O
j	int
]	O
;	O
j	int
++	O
)	O
if	O
(	O
c	int
==	O
p	*(void)
[	O
j	int
]	O
)	O
goto	O
found_char2	O
;	O
break	O
;	O
found_char2	O
:	O
;	O
}	O
i	array(int)
--	O
;	O
while	O
(	O
*	O
p	*(void)
!=	O
SYNTAX_TOKEN_BRACKET	char
&&	O
p	*(void)
<=	O
q	*(char)
)	O
p	*(void)
++	O
;	O
if	O
(	O
p	*(void)
>	O
q	*(char)
)	O
return	O
-	O
1	int
;	O
if	O
(	O
p	*(void)
[	O
1	int
]	O
==	O
d	double
)	O
i	array(int)
--	O
;	O
break	O
;	O
case	O
SYNTAX_TOKEN_BRACE	char
:	O
if	O
(	O
++	O
p	*(void)
>	O
q	*(char)
)	O
return	O
-	O
1	int
;	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
;	O
for	O
(	O
;	O
*	O
p	*(void)
!=	O
SYNTAX_TOKEN_BRACE	char
&&	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
if	O
(	O
c	int
==	O
*	O
p	*(void)
)	O
goto	O
found_char3	O
;	O
return	O
-	O
1	int
;	O
found_char3	O
:	O
while	O
(	O
*	O
p	*(void)
!=	O
SYNTAX_TOKEN_BRACE	char
&&	O
p	*(void)
<	O
q	*(char)
)	O
p	*(void)
++	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
*	O
p	*(void)
!=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
)	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
whole_right	*(char)
)	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
whole_right	*(char)
,	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
i	array(int)
;	O
}	O
static	O
inline	O
const	O
char	O
*	O
xx_strchr	(*(char),int)->(*(char))
(	O
const	O
unsigned	O
char	O
*	O
s	*(char)
,	O
int	O
c	int
)	O
{	O
while	O
(	O
*	O
s	*(char)
>=	O
'\005'	O
&&	O
*	O
s	*(char)
!=	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
{	O
s	*(char)
++	O
;	O
}	O
return	O
(	O
const	O
char	O
*	O
)	O
s	*(char)
;	O
}	O
static	O
inline	O
struct	O
syntax_rule	struct(short,char,char,char,char)
apply_rules_going_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,struct(short,char,char,char,char))->(struct(short,char,char,char,char))
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
i	array(int)
,	O
struct	O
syntax_rule	struct(short,char,char,char,char)
rule	struct(short,char,char,char,char)
)	O
{	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
*	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
;	O
int	O
contextchanged	int
=	O
0	int
,	O
c	int
;	O
int	O
found_right	int
=	O
0	int
,	O
found_left	int
=	O
0	int
,	O
keyword_foundleft	int
=	O
0	int
,	O
keyword_foundright	int
=	O
0	int
;	O
int	O
is_end	int
;	O
long	O
end	*(struct)
=	O
0	int
;	O
struct	O
syntax_rule	struct(short,char,char,char,char)
_rule	struct(short,char,char,char,char)
=	O
rule	struct(short,char,char,char,char)
;	O
if	O
(	O
!	O
(	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
)	O
)	O
return	O
rule	struct(short,char,char,char,char)
;	O
is_end	int
=	O
(	O
rule	struct(short,char,char,char,char)
.	O
end	*(struct)
==	O
(	O
unsigned	O
char	O
)	O
i	array(int)
)	O
;	O
if	O
(	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
)	O
{	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
-	O
1	int
)	O
==	O
'\n'	O
)	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
=	O
0	int
;	O
if	O
(	O
is_end	int
)	O
{	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
=	O
0	int
;	O
keyword_foundleft	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
&&	O
!	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
)	O
{	O
long	O
e	*(struct)
;	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
]	O
;	O
if	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
first_right	char
==	O
c	int
&&	O
!	O
(	O
rule	struct(short,char,char,char,char)
.	O
border	char
&	O
RULE_ON_RIGHT_BORDER	int
)	O
&&	O
(	O
e	*(struct)
=	O
compare_word_to_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,*(char),*(char),*(char),int)->(long)
(	O
edit	*(struct)
,	O
i	array(int)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
right	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
whole_word_chars_left	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
whole_word_chars_right	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
line_start_right	char
)	O
)	O
>	O
0	int
)	O
{	O
_rule	struct(short,char,char,char,char)
.	O
end	*(struct)
=	O
e	*(struct)
;	O
found_right	int
=	O
1	int
;	O
_rule	struct(short,char,char,char,char)
.	O
border	char
=	O
RULE_ON_RIGHT_BORDER	int
;	O
if	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
between_delimiters	int
)	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
=	O
0	int
;	O
}	O
else	O
if	O
(	O
is_end	int
&&	O
rule	struct(short,char,char,char,char)
.	O
border	char
&	O
RULE_ON_RIGHT_BORDER	int
)	O
{	O
found_left	int
=	O
1	int
;	O
_rule	struct(short,char,char,char,char)
.	O
border	char
=	O
0	int
;	O
if	O
(	O
!	O
keyword_foundleft	int
)	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
=	O
0	int
;	O
}	O
else	O
if	O
(	O
is_end	int
&&	O
rule	struct(short,char,char,char,char)
.	O
border	char
&	O
RULE_ON_LEFT_BORDER	int
)	O
{	O
found_left	int
=	O
1	int
;	O
_rule	struct(short,char,char,char,char)
.	O
border	char
=	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
]	O
)	O
->	O
keyword_first_chars	*(char)
;	O
if	O
(	O
p	*(void)
)	O
while	O
(	O
*	O
(	O
p	*(void)
=	O
xx_strchr	(*(char),int)->(*(char))
(	O
(	O
unsigned	O
char	O
*	O
)	O
p	*(void)
+	O
1	int
,	O
c	int
)	O
)	O
)	O
{	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
*	O
k	int
;	O
int	O
count	int
;	O
long	O
e	*(struct)
;	O
count	int
=	O
p	*(void)
-	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
keyword_first_chars	*(char)
;	O
k	int
=	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
keyword	short
[	O
count	int
]	O
;	O
e	*(struct)
=	O
compare_word_to_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,*(char),*(char),*(char),int)->(long)
(	O
edit	*(struct)
,	O
i	array(int)
,	O
k	int
->	O
keyword	short
,	O
k	int
->	O
whole_word_chars_left	*(char)
,	O
k	int
->	O
whole_word_chars_right	*(char)
,	O
k	int
->	O
line_start	int
)	O
;	O
if	O
(	O
e	*(struct)
>	O
0	int
)	O
{	O
end	*(struct)
=	O
e	*(struct)
;	O
_rule	struct(short,char,char,char,char)
.	O
end	*(struct)
=	O
e	*(struct)
;	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
=	O
count	int
;	O
keyword_foundright	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
)	O
{	O
if	O
(	O
!	O
found_left	int
&&	O
is_end	int
)	O
{	O
if	O
(	O
rule	struct(short,char,char,char,char)
.	O
border	char
&	O
RULE_ON_RIGHT_BORDER	int
)	O
{	O
_rule	struct(short,char,char,char,char)
.	O
border	char
=	O
0	int
;	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
=	O
0	int
;	O
contextchanged	int
=	O
1	int
;	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
=	O
0	int
;	O
}	O
else	O
if	O
(	O
rule	struct(short,char,char,char,char)
.	O
border	char
&	O
RULE_ON_LEFT_BORDER	int
)	O
{	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
_rule	struct(short,char,char,char,char)
.	O
_context	char
]	O
;	O
_rule	struct(short,char,char,char,char)
.	O
border	char
=	O
0	int
;	O
if	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
between_delimiters	int
)	O
{	O
long	O
e	*(struct)
;	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
=	O
_rule	struct(short,char,char,char,char)
.	O
_context	char
;	O
contextchanged	int
=	O
1	int
;	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
=	O
0	int
;	O
if	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
first_right	char
==	O
c	int
&&	O
(	O
e	*(struct)
=	O
compare_word_to_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,*(char),*(char),*(char),int)->(long)
(	O
edit	*(struct)
,	O
i	array(int)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
right	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
whole_word_chars_left	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
whole_word_chars_right	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
line_start_right	char
)	O
)	O
>=	O
end	*(struct)
)	O
{	O
_rule	struct(short,char,char,char,char)
.	O
end	*(struct)
=	O
e	*(struct)
;	O
found_right	int
=	O
1	int
;	O
_rule	struct(short,char,char,char,char)
.	O
border	char
=	O
RULE_ON_RIGHT_BORDER	int
;	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
=	O
0	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
found_right	int
)	O
{	O
int	O
count	int
;	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
*	O
*	O
rules	*(*(struct))
=	O
edit	*(struct)
->	O
rules	*(*(struct))
;	O
for	O
(	O
count	int
=	O
1	int
;	O
rules	*(*(struct))
[	O
count	int
]	O
;	O
count	int
++	O
)	O
{	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
rules	*(*(struct))
[	O
count	int
]	O
;	O
if	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
first_left	char
==	O
c	int
)	O
{	O
long	O
e	*(struct)
;	O
e	*(struct)
=	O
compare_word_to_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,*(char),*(char),*(char),int)->(long)
(	O
edit	*(struct)
,	O
i	array(int)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
left	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
whole_word_chars_left	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
whole_word_chars_right	*(char)
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
line_start_left	char
)	O
;	O
if	O
(	O
e	*(struct)
>=	O
end	*(struct)
&&	O
(	O
!	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
||	O
keyword_foundright	int
)	O
)	O
{	O
_rule	struct(short,char,char,char,char)
.	O
end	*(struct)
=	O
e	*(struct)
;	O
found_right	int
=	O
1	int
;	O
_rule	struct(short,char,char,char,char)
.	O
border	char
=	O
RULE_ON_LEFT_BORDER	int
;	O
_rule	struct(short,char,char,char,char)
.	O
_context	char
=	O
count	int
;	O
if	O
(	O
!	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
between_delimiters	int
)	O
if	O
(	O
!	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
)	O
{	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
=	O
count	int
;	O
contextchanged	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
contextchanged	int
&&	O
!	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
_rule	struct(short,char,char,char,char)
.	O
context	*(char)
]	O
)	O
->	O
keyword_first_chars	*(char)
;	O
while	O
(	O
*	O
(	O
p	*(void)
=	O
xx_strchr	(*(char),int)->(*(char))
(	O
(	O
unsigned	O
char	O
*	O
)	O
p	*(void)
+	O
1	int
,	O
c	int
)	O
)	O
)	O
{	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
*	O
k	int
;	O
int	O
count	int
;	O
long	O
e	*(struct)
;	O
count	int
=	O
p	*(void)
-	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
keyword_first_chars	*(char)
;	O
k	int
=	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
->	O
keyword	short
[	O
count	int
]	O
;	O
e	*(struct)
=	O
compare_word_to_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,*(char),*(char),*(char),int)->(long)
(	O
edit	*(struct)
,	O
i	array(int)
,	O
k	int
->	O
keyword	short
,	O
k	int
->	O
whole_word_chars_left	*(char)
,	O
k	int
->	O
whole_word_chars_right	*(char)
,	O
k	int
->	O
line_start	int
)	O
;	O
if	O
(	O
e	*(struct)
>	O
0	int
)	O
{	O
_rule	struct(short,char,char,char,char)
.	O
end	*(struct)
=	O
e	*(struct)
;	O
_rule	struct(short,char,char,char,char)
.	O
keyword	short
=	O
count	int
;	O
break	O
;	O
}	O
}	O
}	O
return	O
_rule	struct(short,char,char,char,char)
;	O
}	O
static	O
struct	O
syntax_rule	struct(short,char,char,char,char)
edit_get_rule	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long)->(struct(short,char,char,char,char))
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
byte_index	long
)	O
{	O
long	O
i	array(int)
;	O
if	O
(	O
byte_index	long
>	O
edit	*(struct)
->	O
last_get_rule	long
)	O
{	O
for	O
(	O
i	array(int)
=	O
edit	*(struct)
->	O
last_get_rule	long
+	O
1	int
;	O
i	array(int)
<=	O
byte_index	long
;	O
i	array(int)
++	O
)	O
{	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
=	O
apply_rules_going_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,struct(short,char,char,char,char))->(struct(short,char,char,char,char))
(	O
edit	*(struct)
,	O
i	array(int)
,	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
)	O
;	O
if	O
(	O
i	array(int)
>	O
(	O
edit	*(struct)
->	O
syntax_marker	*(struct)
?	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
offset	long
+	O
SYNTAX_MARKER_DENSITY	int
:	O
SYNTAX_MARKER_DENSITY	int
)	O
)	O
{	O
struct	O
_syntax_marker	struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct`))))))
*	O
s	*(char)
;	O
s	*(char)
=	O
edit	*(struct)
->	O
syntax_marker	*(struct)
;	O
edit	*(struct)
->	O
syntax_marker	*(struct)
=	O
g_malloc0	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
_syntax_marker	struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct`))))))
)	O
)	O
;	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
s	*(char)
;	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
offset	long
=	O
i	array(int)
;	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
rule	struct(short,char,char,char,char)
=	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
;	O
}	O
}	O
}	O
else	O
if	O
(	O
byte_index	long
<	O
edit	*(struct)
->	O
last_get_rule	long
)	O
{	O
struct	O
_syntax_marker	struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct`))))))
*	O
s	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
syntax_marker	*(struct)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
,	O
0	int
,	O
sizeof	O
(	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
)	O
)	O
;	O
for	O
(	O
i	array(int)
=	O
-	O
1	int
;	O
i	array(int)
<=	O
byte_index	long
;	O
i	array(int)
++	O
)	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
=	O
apply_rules_going_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,struct(short,char,char,char,char))->(struct(short,char,char,char,char))
(	O
edit	*(struct)
,	O
i	array(int)
,	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
byte_index	long
>=	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
offset	long
)	O
{	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
=	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
rule	struct(short,char,char,char,char)
;	O
for	O
(	O
i	array(int)
=	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
offset	long
+	O
1	int
;	O
i	array(int)
<=	O
byte_index	long
;	O
i	array(int)
++	O
)	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
=	O
apply_rules_going_right	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long,struct(short,char,char,char,char))->(struct(short,char,char,char,char))
(	O
edit	*(struct)
,	O
i	array(int)
,	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
)	O
;	O
break	O
;	O
}	O
s	*(char)
=	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
syntax_marker	*(struct)
)	O
;	O
edit	*(struct)
->	O
syntax_marker	*(struct)
=	O
s	*(char)
;	O
}	O
}	O
edit	*(struct)
->	O
last_get_rule	long
=	O
byte_index	long
;	O
return	O
edit	*(struct)
->	O
rule	struct(short,char,char,char,char)
;	O
}	O
static	O
void	O
translate_rule_to_color	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),struct(short,char,char,char,char),*(int))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
struct	O
syntax_rule	struct(short,char,char,char,char)
rule	struct(short,char,char,char,char)
,	O
int	O
*	O
color	*(int)
)	O
{	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
*	O
k	int
;	O
k	int
=	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
rule	struct(short,char,char,char,char)
.	O
context	*(char)
]	O
->	O
keyword	short
[	O
rule	struct(short,char,char,char,char)
.	O
keyword	short
]	O
;	O
*	O
color	*(int)
=	O
k	int
->	O
color	*(int)
;	O
}	O
void	O
edit_get_syntax_color	(*(struct),long,*(int))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
byte_index	long
,	O
int	O
*	O
color	*(int)
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
&&	O
byte_index	long
<	O
edit	*(struct)
->	O
last_byte	long
&&	O
option_syntax_highlighting	int
&&	O
use_colors	int
)	O
{	O
translate_rule_to_color	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),struct(short,char,char,char,char),*(int))->(void)
(	O
edit	*(struct)
,	O
edit_get_rule	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long)->(struct(short,char,char,char,char))
(	O
edit	*(struct)
,	O
byte_index	long
)	O
,	O
color	*(int)
)	O
;	O
}	O
else	O
{	O
*	O
color	*(int)
=	O
use_colors	int
?	O
EDITOR_NORMAL_COLOR_INDEX	int
:	O
0	int
;	O
}	O
}	O
static	O
int	O
read_one_line	(*(*(char)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
char	O
*	O
*	O
line	int
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
GString	struct
*	O
p	*(void)
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
""	*(char)
)	O
;	O
int	O
c	int
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
0	int
;	O
}	O
break	O
;	O
}	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
++	O
;	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
==	O
'\n'	O
)	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
++	O
;	O
else	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
g_string_append_c	(*(struct(*(char),long,long)),char)->(*(struct(*(char),long,long)))
(	O
p	*(void)
,	O
c	int
)	O
;	O
}	O
if	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
!=	O
0	int
)	O
{	O
*	O
line	int
=	O
p	*(void)
->	O
str	*(char)
;	O
g_string_free	(*(struct(*(char),long,long)),int)->(*(char))
(	O
p	*(void)
,	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
g_string_free	(*(struct(*(char),long,long)),int)->(*(char))
(	O
p	*(void)
,	O
TRUE	O
)	O
;	O
}	O
return	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
;	O
}	O
static	O
char	O
*	O
convert	(*(char))->(*(char))
(	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
,	O
*	O
p	*(void)
;	O
p	*(void)
=	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
s	*(char)
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
'\\'	O
:	O
s	*(char)
++	O
;	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
' '	O
:	O
*	O
p	*(void)
=	O
' '	O
;	O
s	*(char)
--	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
p	*(void)
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
p	*(void)
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
p	*(void)
=	O
'\t'	O
;	O
break	O
;	O
case	O
's'	O
:	O
*	O
p	*(void)
=	O
' '	O
;	O
break	O
;	O
case	O
'*'	O
:	O
*	O
p	*(void)
=	O
'*'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
p	*(void)
=	O
'\\'	O
;	O
break	O
;	O
case	O
'['	O
:	O
case	O
']'	O
:	O
*	O
p	*(void)
=	O
SYNTAX_TOKEN_BRACKET	char
;	O
break	O
;	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
*	O
p	*(void)
=	O
SYNTAX_TOKEN_BRACE	char
;	O
break	O
;	O
case	O
0	int
:	O
*	O
p	*(void)
=	O
*	O
s	*(char)
;	O
return	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
;	O
default	O
:	O
*	O
p	*(void)
=	O
*	O
s	*(char)
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'*'	O
:	O
*	O
p	*(void)
=	O
SYNTAX_TOKEN_STAR	char
;	O
break	O
;	O
case	O
'+'	O
:	O
*	O
p	*(void)
=	O
SYNTAX_TOKEN_PLUS	char
;	O
break	O
;	O
default	O
:	O
*	O
p	*(void)
=	O
*	O
s	*(char)
;	O
break	O
;	O
}	O
s	*(char)
++	O
;	O
p	*(void)
++	O
;	O
}	O
*	O
p	*(void)
=	O
'\0'	O
;	O
return	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
;	O
}	O
static	O
int	O
get_args	(*(char),*(*(char)),int)->(int)
(	O
char	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
char	O
*	O
*	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
args_size	int
)	O
{	O
int	O
argc	*(int)
=	O
0	int
;	O
while	O
(	O
argc	*(int)
<	O
args_size	int
)	O
{	O
char	O
*	O
p	*(void)
=	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
while	O
(	O
*	O
p	*(void)
&&	O
whiteness	O
(	O
*	O
p	*(void)
)	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
!	O
*	O
p	*(void)
)	O
break	O
;	O
for	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
p	*(void)
+	O
1	int
;	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
&&	O
!	O
whiteness	O
(	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
++	O
)	O
;	O
if	O
(	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
++	O
=	O
'\0'	O
;	O
args	array(struct(int,int,*(void),*(void)))
[	O
argc	*(int)
++	O
]	O
=	O
convert	(*(char))->(*(char))
(	O
p	*(void)
)	O
;	O
}	O
args	array(struct(int,int,*(void),*(void)))
[	O
argc	*(int)
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
return	O
argc	*(int)
;	O
}	O
static	O
int	O
this_try_alloc_color_pair	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
fg	*(char)
,	O
const	O
char	O
*	O
bg	*(char)
)	O
{	O
char	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
[	O
80	int
]	O
,	O
b	*(void)
[	O
80	int
]	O
,	O
*	O
p	*(void)
;	O
if	O
(	O
bg	*(char)
)	O
if	O
(	O
!	O
*	O
bg	*(char)
)	O
bg	*(char)
=	O
0	int
;	O
if	O
(	O
fg	*(char)
)	O
if	O
(	O
!	O
*	O
fg	*(char)
)	O
fg	*(char)
=	O
0	int
;	O
if	O
(	O
fg	*(char)
)	O
{	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fg	*(char)
,	O
sizeof	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
'/'	O
)	O
;	O
if	O
(	O
p	*(void)
)	O
*	O
p	*(void)
=	O
'\0'	O
;	O
fg	*(char)
=	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
if	O
(	O
bg	*(char)
)	O
{	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
b	*(void)
,	O
bg	*(char)
,	O
sizeof	O
(	O
b	*(void)
)	O
)	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
b	*(void)
,	O
'/'	O
)	O
;	O
if	O
(	O
p	*(void)
)	O
*	O
p	*(void)
=	O
'\0'	O
;	O
bg	*(char)
=	O
b	*(void)
;	O
}	O
return	O
try_alloc_color_pair	(*(char),*(char))->(int)
(	O
fg	*(char)
,	O
bg	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
error_file_name	*(char)
=	O
0	int
;	O
static	O
FILE	struct
*	O
open_include_file	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
syntax_g_free	O
(	O
error_file_name	*(char)
)	O
;	O
error_file_name	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
*	O
filename	*(char)
==	O
PATH_SEP	char
)	O
return	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
error_file_name	*(char)
)	O
;	O
error_file_name	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
home_dir	*(char)
,	O
PATH_SEP_STR	*(char)
EDIT_DIR	O
PATH_SEP_STR	*(char)
,	O
filename	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
error_file_name	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
g_free	(*(void))->(void)
(	O
error_file_name	*(char)
)	O
;	O
error_file_name	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
mc_home	*(char)
,	O
PATH_SEP_STR	*(char)
"syntax"	*(char)
PATH_SEP_STR	*(char)
,	O
filename	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
return	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
error_file_name	*(char)
,	O
"r"	*(char)
)	O
;	O
}	O
static	O
int	O
edit_read_syntax_rules	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),int)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
char	O
*	O
*	O
args	array(struct(int,int,*(void),*(void)))
,	O
int	O
args_size	int
)	O
{	O
FILE	struct
*	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
=	O
0	int
;	O
char	O
*	O
fg	*(char)
,	O
*	O
bg	*(char)
;	O
char	O
last_fg	array(char)
[	O
32	int
]	O
=	O
""	*(char)
,	O
last_bg	array(char)
[	O
32	int
]	O
=	O
""	*(char)
;	O
char	O
whole_right	*(char)
[	O
512	int
]	O
;	O
char	O
whole_left	*(char)
[	O
512	int
]	O
;	O
char	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
0	int
;	O
int	O
save_line	int
=	O
0	int
,	O
line	int
=	O
0	int
;	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
*	O
*	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
,	O
*	O
c	int
=	O
0	int
;	O
int	O
num_words	int
=	O
-	O
1	int
,	O
num_contexts	int
=	O
-	O
1	int
;	O
int	O
result	long
=	O
0	int
;	O
int	O
argc	*(int)
;	O
int	O
i	array(int)
,	O
j	int
;	O
int	O
alloc_contexts	int
=	O
MAX_CONTEXTS	int
,	O
alloc_words_per_context	int
=	O
MAX_WORDS_PER_CONTEXT	int
,	O
max_alloc_words_per_context	int
=	O
MAX_WORDS_PER_CONTEXT	int
;	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
=	O
0	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
whole_left	*(char)
,	O
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_01234567890"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
whole_right	*(char)
,	O
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_01234567890"	*(char)
)	O
;	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
edit	*(struct)
->	O
rules	*(*(struct))
=	O
g_malloc0	(long)->(*(void))
(	O
alloc_contexts	int
*	O
sizeof	O
(	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
*	O
)	O
)	O
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
defines	*(struct)
)	O
edit	*(struct)
->	O
defines	*(struct)
=	O
g_tree_new	(*((*(void),*(void))->(int)))->(*(struct))
(	O
(	O
GCompareFunc	*((*(void),*(void))->(int))
)	O
strcmp	(*(char),*(char))->(int)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
*	O
a	*(void)
;	O
line	int
++	O
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
0	int
;	O
if	O
(	O
!	O
read_one_line	(*(*(char)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
;	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
=	O
0	int
;	O
line	int
=	O
save_line	int
+	O
1	int
;	O
syntax_g_free	O
(	O
error_file_name	*(char)
)	O
;	O
syntax_g_free	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
if	O
(	O
!	O
read_one_line	(*(*(char)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
break	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
argc	*(int)
=	O
get_args	(*(char),*(*(char)),int)->(int)
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
args	array(struct(int,int,*(void),*(void)))
,	O
args_size	int
)	O
;	O
a	*(void)
=	O
args	array(struct(int,int,*(void),*(void)))
+	O
1	int
;	O
if	O
(	O
!	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
)	O
{	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"include"	*(char)
)	O
)	O
{	O
if	O
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
||	O
argc	*(int)
!=	O
2	int
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
=	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
open_include_file	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
syntax_g_free	O
(	O
error_file_name	*(char)
)	O
;	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
save_line	int
=	O
line	int
;	O
line	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"wholechars"	*(char)
)	O
)	O
{	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"left"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
whole_left	*(char)
,	O
*	O
a	*(void)
,	O
sizeof	O
(	O
whole_left	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"right"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
whole_right	*(char)
,	O
*	O
a	*(void)
,	O
sizeof	O
(	O
whole_right	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
whole_left	*(char)
,	O
*	O
a	*(void)
,	O
sizeof	O
(	O
whole_left	*(char)
)	O
)	O
;	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
whole_right	*(char)
,	O
*	O
a	*(void)
,	O
sizeof	O
(	O
whole_right	*(char)
)	O
)	O
;	O
}	O
a	*(void)
++	O
;	O
check_not_a	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"context"	*(char)
)	O
)	O
{	O
check_a	O
;	O
if	O
(	O
num_contexts	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"default"	*(char)
)	O
)	O
{	O
break_a	O
;	O
}	O
a	*(void)
++	O
;	O
c	int
=	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
[	O
0	int
]	O
=	O
g_malloc0	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
)	O
)	O
;	O
c	int
->	O
left	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
" "	*(char)
)	O
;	O
c	int
->	O
right	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
" "	*(char)
)	O
;	O
num_contexts	int
=	O
0	int
;	O
}	O
else	O
{	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
[	O
num_contexts	int
-	O
1	int
]	O
->	O
keyword	short
[	O
num_words	int
]	O
=	O
NULL	O
;	O
c	int
=	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
[	O
num_contexts	int
]	O
=	O
g_malloc0	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
)	O
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"exclusive"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
c	int
->	O
between_delimiters	int
=	O
1	int
;	O
}	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"whole"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
c	int
->	O
whole_word_chars_left	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
whole_left	*(char)
)	O
;	O
c	int
->	O
whole_word_chars_right	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
whole_right	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"wholeleft"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
c	int
->	O
whole_word_chars_left	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
whole_left	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"wholeright"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
c	int
->	O
whole_word_chars_right	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
whole_right	*(char)
)	O
;	O
}	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"linestart"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
c	int
->	O
line_start_left	char
=	O
1	int
;	O
}	O
check_a	O
;	O
c	int
->	O
left	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
*	O
a	*(void)
++	O
)	O
;	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"linestart"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
c	int
->	O
line_start_right	char
=	O
1	int
;	O
}	O
check_a	O
;	O
c	int
->	O
right	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
*	O
a	*(void)
++	O
)	O
;	O
c	int
->	O
first_left	char
=	O
*	O
c	int
->	O
left	*(char)
;	O
c	int
->	O
first_right	char
=	O
*	O
c	int
->	O
right	*(char)
;	O
}	O
c	int
->	O
keyword	short
=	O
g_malloc	(long)->(*(void))
(	O
alloc_words_per_context	int
*	O
sizeof	O
(	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
*	O
)	O
)	O
;	O
num_words	int
=	O
1	int
;	O
c	int
->	O
keyword	short
[	O
0	int
]	O
=	O
g_malloc0	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
)	O
)	O
;	O
subst_defines	(*(struct),*(*(char)),*(*(char)))->(void)
(	O
edit	*(struct)
->	O
defines	*(struct)
,	O
a	*(void)
,	O
&	O
args	array(struct(int,int,*(void),*(void)))
[	O
1024	int
]	O
)	O
;	O
fg	*(char)
=	O
*	O
a	*(void)
;	O
if	O
(	O
*	O
a	*(void)
)	O
a	*(void)
++	O
;	O
bg	*(char)
=	O
*	O
a	*(void)
;	O
if	O
(	O
*	O
a	*(void)
)	O
a	*(void)
++	O
;	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
last_fg	array(char)
,	O
fg	*(char)
?	O
fg	*(char)
:	O
""	*(char)
,	O
sizeof	O
(	O
last_fg	array(char)
)	O
)	O
;	O
g_strlcpy	(*(char),*(char),long)->(long)
(	O
last_bg	array(char)
,	O
bg	*(char)
?	O
bg	*(char)
:	O
""	*(char)
,	O
sizeof	O
(	O
last_bg	array(char)
)	O
)	O
;	O
c	int
->	O
keyword	short
[	O
0	int
]	O
->	O
color	*(int)
=	O
this_try_alloc_color_pair	(*(char),*(char))->(int)
(	O
fg	*(char)
,	O
bg	*(char)
)	O
;	O
c	int
->	O
keyword	short
[	O
0	int
]	O
->	O
keyword	short
=	O
g_strdup	(*(char))->(*(char))
(	O
" "	*(char)
)	O
;	O
check_not_a	O
;	O
alloc_words_per_context	int
=	O
MAX_WORDS_PER_CONTEXT	int
;	O
if	O
(	O
++	O
num_contexts	int
>=	O
alloc_contexts	int
)	O
{	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
*	O
*	O
tmp	*(*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct`)))))
;	O
alloc_contexts	int
+=	O
128	int
;	O
tmp	*(*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct`)))))
=	O
g_realloc	(*(void),long)->(*(void))
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
,	O
alloc_contexts	int
*	O
sizeof	O
(	O
struct	O
context_rule	struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*(char),char,*(char),*(char),int,int))))
*	O
)	O
)	O
;	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
tmp	*(*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct`)))))
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"spellcheck"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
c	int
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
c	int
->	O
spelling	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"keyword"	*(char)
)	O
)	O
{	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
*	O
k	int
;	O
if	O
(	O
num_words	int
==	O
-	O
1	int
)	O
break_a	O
;	O
check_a	O
;	O
k	int
=	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
[	O
num_contexts	int
-	O
1	int
]	O
->	O
keyword	short
[	O
num_words	int
]	O
=	O
g_malloc0	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
)	O
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"whole"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
k	int
->	O
whole_word_chars_left	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
whole_left	*(char)
)	O
;	O
k	int
->	O
whole_word_chars_right	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
whole_right	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"wholeleft"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
k	int
->	O
whole_word_chars_left	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
whole_left	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"wholeright"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
k	int
->	O
whole_word_chars_right	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
whole_right	*(char)
)	O
;	O
}	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"linestart"	*(char)
)	O
)	O
{	O
a	*(void)
++	O
;	O
k	int
->	O
line_start	int
=	O
1	int
;	O
}	O
check_a	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
a	*(void)
,	O
"whole"	*(char)
)	O
)	O
{	O
break_a	O
;	O
}	O
k	int
->	O
keyword	short
=	O
g_strdup	(*(char))->(*(char))
(	O
*	O
a	*(void)
++	O
)	O
;	O
k	int
->	O
first	*(char)
=	O
*	O
k	int
->	O
keyword	short
;	O
subst_defines	(*(struct),*(*(char)),*(*(char)))->(void)
(	O
edit	*(struct)
->	O
defines	*(struct)
,	O
a	*(void)
,	O
&	O
args	array(struct(int,int,*(void),*(void)))
[	O
1024	int
]	O
)	O
;	O
fg	*(char)
=	O
*	O
a	*(void)
;	O
if	O
(	O
*	O
a	*(void)
)	O
a	*(void)
++	O
;	O
bg	*(char)
=	O
*	O
a	*(void)
;	O
if	O
(	O
*	O
a	*(void)
)	O
a	*(void)
++	O
;	O
if	O
(	O
!	O
fg	*(char)
)	O
fg	*(char)
=	O
last_fg	array(char)
;	O
if	O
(	O
!	O
bg	*(char)
)	O
bg	*(char)
=	O
last_bg	array(char)
;	O
k	int
->	O
color	*(int)
=	O
this_try_alloc_color_pair	(*(char),*(char))->(int)
(	O
fg	*(char)
,	O
bg	*(char)
)	O
;	O
check_not_a	O
;	O
if	O
(	O
++	O
num_words	int
>=	O
alloc_words_per_context	int
)	O
{	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
*	O
*	O
tmp	*(*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct`)))))
;	O
alloc_words_per_context	int
+=	O
1024	int
;	O
if	O
(	O
alloc_words_per_context	int
>	O
max_alloc_words_per_context	int
)	O
max_alloc_words_per_context	int
=	O
alloc_words_per_context	int
;	O
tmp	*(*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct`)))))
=	O
g_realloc	(*(void),long)->(*(void))
(	O
c	int
->	O
keyword	short
,	O
alloc_words_per_context	int
*	O
sizeof	O
(	O
struct	O
key_word	struct(*(char),char,*(char),*(char),int,int)
*	O
)	O
)	O
;	O
c	int
->	O
keyword	short
=	O
tmp	*(*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct`)))))
;	O
}	O
}	O
else	O
if	O
(	O
*	O
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
)	O
==	O
'#'	O
)	O
{	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"file"	*(char)
)	O
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"define"	*(char)
)	O
)	O
{	O
char	O
*	O
key	*(void)
=	O
*	O
a	*(void)
++	O
;	O
char	O
*	O
*	O
argv	*(*(*(char)))
;	O
if	O
(	O
argc	*(int)
<	O
3	int
)	O
break_a	O
;	O
if	O
(	O
(	O
argv	*(*(*(char)))
=	O
g_tree_lookup	(*(struct),*(void))->(*(void))
(	O
edit	*(struct)
->	O
defines	*(struct)
,	O
key	*(void)
)	O
)	O
)	O
{	O
mc_defines_destroy	(*(void),*(void),*(void))->(int)
(	O
NULL	O
,	O
argv	*(*(*(char)))
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
key	*(void)
=	O
g_strdup	(*(char))->(*(char))
(	O
key	*(void)
)	O
;	O
}	O
argv	*(*(*(char)))
=	O
g_new	O
(	O
char	O
*	O
,	O
argc	*(int)
-	O
1	int
)	O
;	O
g_tree_insert	(*(struct),*(void),*(void))->(void)
(	O
edit	*(struct)
->	O
defines	*(struct)
,	O
key	*(void)
,	O
argv	*(*(*(char)))
)	O
;	O
while	O
(	O
*	O
a	*(void)
)	O
{	O
*	O
argv	*(*(*(char)))
++	O
=	O
g_strdup	(*(char))->(*(char))
(	O
*	O
a	*(void)
++	O
)	O
;	O
}	O
;	O
*	O
argv	*(*(*(char)))
=	O
NULL	O
;	O
}	O
else	O
{	O
break_a	O
;	O
}	O
free_args	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
syntax_g_free	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
}	O
free_args	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
syntax_g_free	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
if	O
(	O
num_contexts	int
>	O
0	int
)	O
{	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
[	O
num_contexts	int
-	O
1	int
]	O
->	O
keyword	short
[	O
num_words	int
]	O
=	O
NULL	O
;	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
[	O
num_contexts	int
]	O
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
0	int
]	O
)	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
if	O
(	O
num_contexts	int
==	O
-	O
1	int
)	O
{	O
return	O
line	int
;	O
}	O
{	O
char	O
*	O
first_chars	*(char)
,	O
*	O
p	*(void)
;	O
first_chars	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
max_alloc_words_per_context	int
+	O
2	int
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
;	O
i	array(int)
++	O
)	O
{	O
c	int
=	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
;	O
p	*(void)
=	O
first_chars	*(char)
;	O
*	O
p	*(void)
++	O
=	O
(	O
char	O
)	O
1	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
c	int
->	O
keyword	short
[	O
j	int
]	O
;	O
j	int
++	O
)	O
*	O
p	*(void)
++	O
=	O
c	int
->	O
keyword	short
[	O
j	int
]	O
->	O
first	*(char)
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
c	int
->	O
keyword_first_chars	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
first_chars	*(char)
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
first_chars	*(char)
)	O
;	O
}	O
return	O
result	long
;	O
}	O
void	O
edit_free_syntax_rules	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
i	array(int)
,	O
j	int
;	O
if	O
(	O
!	O
edit	*(struct)
)	O
return	O
;	O
if	O
(	O
edit	*(struct)
->	O
defines	*(struct)
)	O
destroy_defines	(*(*(struct)))->(void)
(	O
&	O
edit	*(struct)
->	O
defines	*(struct)
)	O
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
rules	*(*(struct))
)	O
return	O
;	O
edit_get_rule	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long)->(struct(short,char,char,char,char))
(	O
edit	*(struct)
,	O
-	O
1	int
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
syntax_type	*(char)
)	O
;	O
edit	*(struct)
->	O
syntax_type	*(char)
=	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
keyword	short
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
keyword	short
[	O
j	int
]	O
;	O
j	int
++	O
)	O
{	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
keyword	short
[	O
j	int
]	O
->	O
keyword	short
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
keyword	short
[	O
j	int
]	O
->	O
whole_word_chars_left	*(char)
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
keyword	short
[	O
j	int
]	O
->	O
whole_word_chars_right	*(char)
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
keyword	short
[	O
j	int
]	O
)	O
;	O
}	O
}	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
left	*(char)
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
right	*(char)
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
whole_word_chars_left	*(char)
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
whole_word_chars_right	*(char)
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
keyword	short
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
->	O
keyword_first_chars	*(char)
)	O
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
i	array(int)
]	O
)	O
;	O
}	O
while	O
(	O
edit	*(struct)
->	O
syntax_marker	*(struct)
)	O
{	O
struct	O
_syntax_marker	struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct(long,struct(short,char,char,char,char),*(struct`))))))
*	O
s	*(char)
=	O
edit	*(struct)
->	O
syntax_marker	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
syntax_marker	*(struct)
)	O
;	O
edit	*(struct)
->	O
syntax_marker	*(struct)
=	O
s	*(char)
;	O
}	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
rules	*(*(struct))
)	O
;	O
}	O
static	O
int	O
edit_read_syntax_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(*(*(char))),*(char),*(char),*(char),*(char))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
char	O
*	O
*	O
*	O
pnames	*(*(*(char)))
,	O
const	O
char	O
*	O
syntax_file	*(char)
,	O
const	O
char	O
*	O
editor_file	*(char)
,	O
const	O
char	O
*	O
first_line	*(char)
,	O
const	O
char	O
*	O
type	enum(int,int,int,int)
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
=	O
NULL	O
;	O
regex_t	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
;	O
regmatch_t	struct(int,int)
pmatch	array(struct(int,int))
[	O
1	int
]	O
;	O
char	O
*	O
args	array(struct(int,int,*(void),*(void)))
[	O
1024	int
]	O
,	O
*	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
0	int
;	O
int	O
line	int
=	O
0	int
;	O
int	O
result	long
=	O
0	int
;	O
int	O
count	int
=	O
0	int
;	O
char	O
*	O
lib_file	*(char)
;	O
int	O
found	int
=	O
0	int
;	O
char	O
*	O
*	O
tmpnames	*(*(char))
=	O
NULL	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
syntax_file	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
lib_file	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
mc_home	*(char)
,	O
"syntax"	*(char)
PATH_SEP_STR	*(char)
"Syntax"	*(char)
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
lib_file	*(char)
,	O
"r"	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
lib_file	*(char)
)	O
;	O
if	O
(	O
!	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
return	O
-	O
1	int
;	O
}	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
line	int
++	O
;	O
syntax_g_free	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
if	O
(	O
!	O
read_one_line	(*(*(char)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
break	O
;	O
(	O
void	O
)	O
get_args	(*(char),*(*(char)),int)->(int)
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
args	array(struct(int,int,*(void),*(void)))
,	O
1023	int
)	O
;	O
if	O
(	O
!	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
found	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"include"	*(char)
)	O
)	O
{	O
if	O
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
)	O
continue	O
;	O
if	O
(	O
!	O
args	array(struct(int,int,*(void),*(void)))
[	O
1	int
]	O
||	O
!	O
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
=	O
open_include_file	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
1	int
]	O
)	O
)	O
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
goto	O
found_type	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
0	int
]	O
,	O
"file"	*(char)
)	O
)	O
{	O
continue	O
;	O
}	O
found	int
=	O
1	int
;	O
if	O
(	O
!	O
args	array(struct(int,int,*(void),*(void)))
[	O
1	int
]	O
||	O
!	O
args	array(struct(int,int,*(void),*(void)))
[	O
2	int
]	O
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
if	O
(	O
pnames	*(*(*(char)))
&&	O
*	O
pnames	*(*(*(char)))
)	O
{	O
if	O
(	O
count	int
%	O
NENTRIES	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
tmpnames	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
g_realloc	(*(void),long)->(*(void))
(	O
*	O
pnames	*(*(*(char)))
,	O
(	O
count	int
+	O
NENTRIES	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
pnames	*(*(*(char)))
=	O
tmpnames	*(*(char))
;	O
else	O
abort	()->(void)
(	O
)	O
;	O
}	O
(	O
*	O
pnames	*(*(*(char)))
)	O
[	O
count	int
++	O
]	O
=	O
g_strdup	(*(char))->(*(char))
(	O
args	array(struct(int,int,*(void),*(void)))
[	O
2	int
]	O
)	O
;	O
(	O
*	O
pnames	*(*(*(char)))
)	O
[	O
count	int
]	O
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
type	enum(int,int,int,int)
,	O
args	array(struct(int,int,*(void),*(void)))
[	O
2	int
]	O
)	O
)	O
goto	O
found_type	O
;	O
}	O
else	O
if	O
(	O
editor_file	*(char)
&&	O
edit	*(struct)
)	O
{	O
int	O
q	*(char)
;	O
if	O
(	O
regcomp	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
&	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
,	O
args	array(struct(int,int,*(void),*(void)))
[	O
1	int
]	O
,	O
REG_EXTENDED	int
)	O
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
q	*(char)
=	O
!	O
regexec	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long,array(struct(int,int)),int)->(int)
(	O
&	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
,	O
editor_file	*(char)
,	O
1	int
,	O
pmatch	array(struct(int,int))
,	O
0	int
)	O
;	O
regfree	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
&	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
)	O
;	O
if	O
(	O
!	O
q	*(char)
&&	O
args	array(struct(int,int,*(void),*(void)))
[	O
3	int
]	O
)	O
{	O
if	O
(	O
regcomp	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
&	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
,	O
args	array(struct(int,int,*(void),*(void)))
[	O
3	int
]	O
,	O
REG_EXTENDED	int
)	O
)	O
{	O
result	long
=	O
line	int
;	O
break	O
;	O
}	O
q	*(char)
=	O
!	O
regexec	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long,array(struct(int,int)),int)->(int)
(	O
&	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
,	O
first_line	*(char)
,	O
1	int
,	O
pmatch	array(struct(int,int))
,	O
0	int
)	O
;	O
regfree	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
&	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
)	O
;	O
}	O
if	O
(	O
q	*(char)
)	O
{	O
int	O
line_error	int
;	O
char	O
*	O
syntax_type	*(char)
;	O
found_type	O
:	O
syntax_type	*(char)
=	O
args	array(struct(int,int,*(void),*(void)))
[	O
2	int
]	O
;	O
line_error	int
=	O
edit_read_syntax_rules	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(*(char)),int)->(int)
(	O
edit	*(struct)
,	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
?	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
:	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
args	array(struct(int,int,*(void),*(void)))
,	O
1023	int
)	O
;	O
if	O
(	O
line_error	int
)	O
{	O
if	O
(	O
!	O
error_file_name	*(char)
)	O
result	long
=	O
line	int
+	O
line_error	int
;	O
else	O
result	long
=	O
line_error	int
;	O
}	O
else	O
{	O
syntax_g_free	O
(	O
edit	*(struct)
->	O
syntax_type	*(char)
)	O
;	O
edit	*(struct)
->	O
syntax_type	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
syntax_type	*(char)
)	O
;	O
if	O
(	O
!	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
&&	O
!	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
1	int
]	O
)	O
if	O
(	O
!	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
0	int
]	O
->	O
keyword	short
[	O
1	int
]	O
&&	O
!	O
edit	*(struct)
->	O
rules	*(*(struct))
[	O
0	int
]	O
->	O
spelling	int
)	O
{	O
edit_free_syntax_rules	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
)	O
;	O
g	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),int,int,int))
=	O
NULL	O
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
}	O
}	O
syntax_g_free	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
result	long
;	O
}	O
static	O
char	O
*	O
get_first_editor_line	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(*(char))
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
i	array(int)
;	O
static	O
char	O
s	*(char)
[	O
256	int
]	O
;	O
s	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
edit	*(struct)
)	O
return	O
s	*(char)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
255	int
;	O
i	array(int)
++	O
)	O
{	O
s	*(char)
[	O
i	array(int)
]	O
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
;	O
if	O
(	O
s	*(char)
[	O
i	array(int)
]	O
==	O
'\n'	O
)	O
{	O
s	*(char)
[	O
i	array(int)
]	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
}	O
s	*(char)
[	O
255	int
]	O
=	O
'\0'	O
;	O
return	O
s	*(char)
;	O
}	O
void	O
edit_load_syntax	(*(struct),*(*(*(char))),*(char))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
char	O
*	O
*	O
*	O
pnames	*(*(*(char)))
,	O
const	O
char	O
*	O
type	enum(int,int,int,int)
)	O
{	O
int	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
;	O
char	O
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
if	O
(	O
option_auto_syntax	int
)	O
type	enum(int,int,int,int)
=	O
NULL	O
;	O
edit_free_syntax_rules	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
!	O
use_colors	int
)	O
return	O
;	O
if	O
(	O
!	O
option_syntax_highlighting	int
&&	O
(	O
!	O
pnames	*(*(*(char)))
||	O
!	O
*	O
pnames	*(*(*(char)))
)	O
)	O
return	O
;	O
if	O
(	O
edit	*(struct)
)	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
filename	*(char)
)	O
return	O
;	O
if	O
(	O
!	O
*	O
edit	*(struct)
->	O
filename	*(char)
&&	O
!	O
type	enum(int,int,int,int)
)	O
return	O
;	O
}	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
SYNTAX_FILE	O
)	O
;	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
=	O
edit_read_syntax_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(*(*(char))),*(char),*(char),*(char),*(char))->(int)
(	O
edit	*(struct)
,	O
pnames	*(*(*(char)))
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
edit	*(struct)
?	O
edit	*(struct)
->	O
filename	*(char)
:	O
0	int
,	O
get_first_editor_line	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct(long,struct`,*`)),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(*(char))
(	O
edit	*(struct)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
==	O
-	O
1	int
)	O
{	O
edit_free_syntax_rules	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
message	*(char)
(	O
D_ERROR	int
,	O
_	O
(	O
" Load syntax file "	*(char)
)	O
,	O
_	O
(	O
" Cannot open file %s \n %s "	*(char)
)	O
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
)	O
{	O
edit_free_syntax_rules	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
message	*(char)
(	O
D_ERROR	int
,	O
_	O
(	O
" Load syntax file "	*(char)
)	O
,	O
_	O
(	O
" Error in file %s on line %d "	*(char)
)	O
,	O
error_file_name	*(char)
?	O
error_file_name	*(char)
:	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
r	*(struct(*(char),char,*(char),char,char,char,int,*(char),*(char),*(char),int,*(*(struct(*`,char,*`,*`,int,int)))))
)	O
;	O
syntax_g_free	O
(	O
error_file_name	*(char)
)	O
;	O
}	O
else	O
{	O
}	O
g_free	(*(void))->(void)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
