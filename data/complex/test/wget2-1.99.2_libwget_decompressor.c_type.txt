typedef	O
int	O
wget_decompressor_decompress_fn	(*(struct),*(char),long)->(int)
(	O
wget_decompressor	struct
*	O
dc	*(struct)
,	O
char	O
*	O
src	*(char)
,	O
size_t	long
srclen	long
)	O
;	O
typedef	O
void	O
wget_decompressor_exit_fn	(*(struct))->(void)
(	O
wget_decompressor	struct
*	O
dc	*(struct)
)	O
;	O
struct	O
wget_decompressor_st	struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long),*((*(void),*(char),long)->(int)),*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),int)->(int)),*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int)),*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))))->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))
{	O
z_stream	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
z_strm	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
;	O
wget_decompressor_sink_fn	(*(void),*(char),long)->(int)
*	O
sink	*((*(void),*(char),long)->(int))
;	O
wget_decompressor_error_handler	(*(struct),int)->(int)
*	O
error_handler	*((*(struct),int)->(int))
;	O
wget_decompressor_decompress_fn	(*(struct),*(char),long)->(int)
*	O
decompress	*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int))
;	O
wget_decompressor_exit_fn	(*(struct))->(void)
*	O
exit	(int)->(void)
;	O
void	O
*	O
context	*(void)
;	O
wget_content_encoding	enum(int,int,int,int,int,int,int,int,int,int)
encoding	*(char)
;	O
}	O
;	O
static	O
int	O
gzip_init	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z_stream	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
*	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
0	int
,	O
sizeof	O
(	O
*	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
)	O
;	O
if	O
(	O
inflateInit2	O
(	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
15	int
+	O
32	int
)	O
!=	O
Z_OK	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to init gzip decompression\n"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
gzip_decompress	(*(struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct`),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int)
(	O
wget_decompressor	struct
*	O
dc	*(struct)
,	O
char	O
*	O
src	*(char)
,	O
size_t	long
srclen	long
)	O
{	O
z_stream	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
*	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
char	O
dst	*(char)
[	O
10240	int
]	O
;	O
int	O
status	int
;	O
if	O
(	O
!	O
srclen	long
)	O
{	O
if	O
(	O
dc	*(struct)
->	O
sink	*((*(void),*(char),long)->(int))
)	O
dc	*(struct)
->	O
sink	*((*(void),*(char),long)->(int))
(	O
dc	*(struct)
->	O
context	*(void)
,	O
""	*(char)
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
=	O
&	O
dc	*(struct)
->	O
z_strm	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
;	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
next_in	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
src	*(char)
;	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_in	int
=	O
(	O
unsigned	O
int	O
)	O
srclen	long
;	O
do	O
{	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
next_out	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
dst	*(char)
;	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
=	O
sizeof	O
(	O
dst	*(char)
)	O
;	O
status	int
=	O
inflate	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int)->(int)
(	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
Z_SYNC_FLUSH	int
)	O
;	O
if	O
(	O
(	O
status	int
==	O
Z_OK	int
||	O
status	int
==	O
Z_STREAM_END	int
)	O
&&	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
<	O
sizeof	O
(	O
dst	*(char)
)	O
)	O
{	O
if	O
(	O
dc	*(struct)
->	O
sink	*((*(void),*(char),long)->(int))
)	O
dc	*(struct)
->	O
sink	*((*(void),*(char),long)->(int))
(	O
dc	*(struct)
->	O
context	*(void)
,	O
dst	*(char)
,	O
sizeof	O
(	O
dst	*(char)
)	O
-	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
)	O
;	O
}	O
}	O
while	O
(	O
status	int
==	O
Z_OK	int
&&	O
!	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_out	int
)	O
;	O
if	O
(	O
status	int
==	O
Z_OK	int
||	O
status	int
==	O
Z_STREAM_END	int
)	O
return	O
0	int
;	O
error_printf	O
(	O
_	O
(	O
"Failed to uncompress gzip stream (%d)\n"	*(char)
)	O
,	O
status	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
gzip_exit	(*(struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct`),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
wget_decompressor	struct
*	O
dc	*(struct)
)	O
{	O
int	O
status	int
;	O
if	O
(	O
(	O
status	int
=	O
inflateEnd	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
&	O
dc	*(struct)
->	O
z_strm	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
)	O
)	O
!=	O
Z_OK	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to close gzip stream (%d)\n"	*(char)
)	O
,	O
status	int
)	O
;	O
}	O
}	O
static	O
int	O
deflate_init	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z_stream	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
*	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
0	int
,	O
sizeof	O
(	O
*	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
)	O
;	O
if	O
(	O
inflateInit	O
(	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
!=	O
Z_OK	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to init deflate decompression\n"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
identity	(*(struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct`),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int)
(	O
wget_decompressor	struct
*	O
dc	*(struct)
,	O
char	O
*	O
src	*(char)
,	O
size_t	long
srclen	long
)	O
{	O
if	O
(	O
dc	*(struct)
->	O
sink	*((*(void),*(char),long)->(int))
)	O
dc	*(struct)
->	O
sink	*((*(void),*(char),long)->(int))
(	O
dc	*(struct)
->	O
context	*(void)
,	O
src	*(char)
,	O
srclen	long
)	O
;	O
return	O
0	int
;	O
}	O
wget_decompressor	struct
*	O
wget_decompress_open	(enum(int,int,int,int,int,int,int,int,int,int),*((*(void),*(char),long)->(int)),*(void))->(*(struct))
(	O
wget_content_encoding	enum(int,int,int,int,int,int,int,int,int,int)
encoding	*(char)
,	O
wget_decompressor_sink_fn	(*(void),*(char),long)->(int)
*	O
sink	*((*(void),*(char),long)->(int))
,	O
void	O
*	O
context	*(void)
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
wget_decompressor	struct
*	O
dc	*(struct)
=	O
wget_calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
wget_decompressor	struct
)	O
)	O
;	O
if	O
(	O
!	O
dc	*(struct)
)	O
return	O
NULL	O
;	O
if	O
(	O
encoding	*(char)
==	O
wget_content_encoding_gzip	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
gzip_init	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
&	O
dc	*(struct)
->	O
z_strm	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
)	O
)	O
==	O
0	int
)	O
{	O
dc	*(struct)
->	O
decompress	*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int))
=	O
gzip_decompress	(*(struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct`),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int)
;	O
dc	*(struct)
->	O
exit	(int)->(void)
=	O
gzip_exit	(*(struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct`),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))))->(void)
;	O
}	O
}	O
else	O
if	O
(	O
encoding	*(char)
==	O
wget_content_encoding_deflate	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
deflate_init	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
&	O
dc	*(struct)
->	O
z_strm	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
)	O
)	O
==	O
0	int
)	O
{	O
dc	*(struct)
->	O
decompress	*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int))
=	O
gzip_decompress	(*(struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct`),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int)
;	O
dc	*(struct)
->	O
exit	(int)->(void)
=	O
gzip_exit	(*(struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct`),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))))->(void)
;	O
}	O
}	O
else	O
if	O
(	O
encoding	*(char)
==	O
wget_content_encoding_bzip2	int
)	O
{	O
}	O
else	O
if	O
(	O
encoding	*(char)
==	O
wget_content_encoding_lzma	int
)	O
{	O
}	O
else	O
if	O
(	O
encoding	*(char)
==	O
wget_content_encoding_brotli	int
)	O
{	O
}	O
else	O
if	O
(	O
encoding	*(char)
==	O
wget_content_encoding_zstd	int
)	O
{	O
}	O
if	O
(	O
!	O
dc	*(struct)
->	O
decompress	*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int))
)	O
{	O
debug_printf	O
(	O
"Falling back to Content-Encoding 'identity'\n"	*(char)
)	O
;	O
dc	*(struct)
->	O
decompress	*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int))
=	O
identity	(*(struct(struct(*(char),int,long,*(char),int,long,*(char),*(struct`),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int)
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
xfree	O
(	O
dc	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
dc	*(struct)
->	O
encoding	*(char)
=	O
encoding	*(char)
;	O
dc	*(struct)
->	O
sink	*((*(void),*(char),long)->(int))
=	O
sink	*((*(void),*(char),long)->(int))
;	O
dc	*(struct)
->	O
context	*(void)
=	O
context	*(void)
;	O
return	O
dc	*(struct)
;	O
}	O
void	O
wget_decompress_close	(*(struct))->(void)
(	O
wget_decompressor	struct
*	O
dc	*(struct)
)	O
{	O
if	O
(	O
dc	*(struct)
)	O
{	O
if	O
(	O
dc	*(struct)
->	O
exit	(int)->(void)
)	O
dc	*(struct)
->	O
exit	(int)->(void)
(	O
dc	*(struct)
)	O
;	O
xfree	O
(	O
dc	*(struct)
)	O
;	O
}	O
}	O
int	O
wget_decompress	(*(struct),*(char),long)->(int)
(	O
wget_decompressor	struct
*	O
dc	*(struct)
,	O
char	O
*	O
src	*(char)
,	O
size_t	long
srclen	long
)	O
{	O
if	O
(	O
dc	*(struct)
)	O
{	O
int	O
rc	int
=	O
dc	*(struct)
->	O
decompress	*((*(struct(struct(*`,int,long,*`,int,long,*`,*`,*`,*`,*`,int,long,long),*((*`,*`,long)->(int)),*((*`,int)->(int)),*((*`,*`,long)->(int)),*((*`)->(void)),*(void),enum(int,int,int,int,int,int,int,int,int,int))),*(char),long)->(int))
(	O
dc	*(struct)
,	O
src	*(char)
,	O
srclen	long
)	O
;	O
if	O
(	O
rc	int
&&	O
dc	*(struct)
->	O
error_handler	*((*(struct),int)->(int))
)	O
dc	*(struct)
->	O
error_handler	*((*(struct),int)->(int))
(	O
dc	*(struct)
,	O
rc	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
wget_decompress_set_error_handler	(*(struct),*((*(struct),int)->(int)))->(void)
(	O
wget_decompressor	struct
*	O
dc	*(struct)
,	O
wget_decompressor_error_handler	(*(struct),int)->(int)
*	O
error_handler	*((*(struct),int)->(int))
)	O
{	O
if	O
(	O
dc	*(struct)
)	O
dc	*(struct)
->	O
error_handler	*((*(struct),int)->(int))
=	O
error_handler	*((*(struct),int)->(int))
;	O
}	O
void	O
*	O
wget_decompress_get_context	(*(struct))->(*(void))
(	O
wget_decompressor	struct
*	O
dc	*(struct)
)	O
{	O
return	O
dc	*(struct)
?	O
dc	*(struct)
->	O
context	*(void)
:	O
NULL	O
;	O
}	O
static	O
char	O
_encoding_names	array(array(char))
[	O
wget_content_encoding_max	int
]	O
[	O
9	int
]	O
=	O
{	O
[	O
wget_content_encoding_identity	int
]	O
=	O
"identity"	*(char)
,	O
[	O
wget_content_encoding_gzip	int
]	O
=	O
"gzip"	*(char)
,	O
[	O
wget_content_encoding_deflate	int
]	O
=	O
"deflate"	*(char)
,	O
[	O
wget_content_encoding_xz	int
]	O
=	O
"xz"	*(char)
,	O
[	O
wget_content_encoding_lzma	int
]	O
=	O
"lzma"	*(char)
,	O
[	O
wget_content_encoding_bzip2	int
]	O
=	O
"bzip2"	*(char)
,	O
[	O
wget_content_encoding_brotli	int
]	O
=	O
"br"	*(char)
,	O
[	O
wget_content_encoding_zstd	int
]	O
=	O
"zstd"	*(char)
,	O
}	O
;	O
wget_content_encoding	enum(int,int,int,int,int,int,int,int,int,int)
wget_content_encoding_by_name	(*(char))->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
name	*(char)
)	O
{	O
for	O
(	O
wget_content_encoding	enum(int,int,int,int,int,int,int,int,int,int)
it	enum(int,int,int,int,int,int,int,int,int,int)
=	O
0	int
;	O
it	enum(int,int,int,int,int,int,int,int,int,int)
<	O
wget_content_encoding_max	int
;	O
it	enum(int,int,int,int,int,int,int,int,int,int)
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
_encoding_names	array(array(char))
[	O
it	enum(int,int,int,int,int,int,int,int,int,int)
]	O
,	O
name	*(char)
)	O
)	O
return	O
it	enum(int,int,int,int,int,int,int,int,int,int)
;	O
}	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
"none"	*(char)
,	O
name	*(char)
)	O
)	O
return	O
wget_content_encoding_identity	int
;	O
}	O
return	O
wget_content_encoding_unknown	int
;	O
}	O
const	O
char	O
*	O
wget_content_encoding_to_name	(enum(int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
wget_content_encoding	enum(int,int,int,int,int,int,int,int,int,int)
type	*(char)
)	O
{	O
if	O
(	O
type	*(char)
>=	O
0	int
&&	O
type	*(char)
<	O
wget_content_encoding_max	int
)	O
return	O
_encoding_names	array(array(char))
[	O
type	*(char)
]	O
;	O
return	O
NULL	O
;	O
}	O
