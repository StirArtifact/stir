int	O
iconveh_open	(*(char),*(char),*(struct(*(void),*(void),*(void))))->(int)
(	O
const	O
char	O
*	O
to_codeset	*(char)
,	O
const	O
char	O
*	O
from_codeset	*(char)
,	O
iconveh_t	struct(*(void),*(void),*(void))
*	O
cdp	*(struct(*(void),*(void),*(void)))
)	O
{	O
iconv_t	*(void)
cd	*(void)
;	O
iconv_t	*(void)
cd1	*(void)
;	O
iconv_t	*(void)
cd2	*(void)
;	O
cd	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
to_codeset	*(char)
,	O
from_codeset	*(char)
)	O
;	O
if	O
(	O
STRCASEEQ	O
(	O
from_codeset	*(char)
,	O
"UTF-8"	*(char)
,	O
'U'	O
,	O
'T'	O
,	O
'F'	O
,	O
'-'	O
,	O
'8'	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
)	O
cd1	*(void)
=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
;	O
else	O
{	O
cd1	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
"UTF-8"	*(char)
,	O
from_codeset	*(char)
)	O
;	O
if	O
(	O
cd1	*(void)
==	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
cd	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	(*(void))->(int)
(	O
cd	*(void)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
STRCASEEQ	O
(	O
to_codeset	*(char)
,	O
"UTF-8"	*(char)
,	O
'U'	O
,	O
'T'	O
,	O
'F'	O
,	O
'-'	O
,	O
'8'	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
||	O
c_strcasecmp	(*(char),*(char))->(int)
(	O
to_codeset	*(char)
,	O
"UTF-8//TRANSLIT"	*(char)
)	O
==	O
0	int
)	O
cd2	*(void)
=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
;	O
else	O
{	O
cd2	*(void)
=	O
iconv_open	(*(char),*(char))->(*(void))
(	O
to_codeset	*(char)
,	O
"UTF-8"	*(char)
)	O
;	O
if	O
(	O
cd2	*(void)
==	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
cd1	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	(*(void))->(int)
(	O
cd1	*(void)
)	O
;	O
if	O
(	O
cd	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	(*(void))->(int)
(	O
cd	*(void)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
cdp	*(struct(*(void),*(void),*(void)))
->	O
cd	*(void)
=	O
cd	*(void)
;	O
cdp	*(struct(*(void),*(void),*(void)))
->	O
cd1	*(void)
=	O
cd1	*(void)
;	O
cdp	*(struct(*(void),*(void),*(void)))
->	O
cd2	*(void)
=	O
cd2	*(void)
;	O
return	O
0	int
;	O
}	O
int	O
iconveh_close	(*(struct(*(void),*(void),*(void))))->(int)
(	O
const	O
iconveh_t	struct(*(void),*(void),*(void))
*	O
cd	*(void)
)	O
{	O
if	O
(	O
cd	*(void)
->	O
cd2	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
&&	O
iconv_close	(*(void))->(int)
(	O
cd	*(void)
->	O
cd2	*(void)
)	O
<	O
0	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
cd	*(void)
->	O
cd1	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	(*(void))->(int)
(	O
cd	*(void)
->	O
cd1	*(void)
)	O
;	O
if	O
(	O
cd	*(void)
->	O
cd	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	(*(void))->(int)
(	O
cd	*(void)
->	O
cd	*(void)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
cd	*(void)
->	O
cd1	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
&&	O
iconv_close	(*(void))->(int)
(	O
cd	*(void)
->	O
cd1	*(void)
)	O
<	O
0	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
cd	*(void)
->	O
cd	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
iconv_close	(*(void))->(int)
(	O
cd	*(void)
->	O
cd	*(void)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
cd	*(void)
->	O
cd	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
&&	O
iconv_close	(*(void))->(int)
(	O
cd	*(void)
->	O
cd	*(void)
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
iconv_carefully_1	(*(void),*(*(char)),*(long),*(*(char)),*(long),*(bool))->(long)
(	O
iconv_t	*(void)
cd	*(void)
,	O
const	O
char	O
*	O
*	O
inbuf	*(*(char))
,	O
size_t	long
*	O
inbytesleft	*(long)
,	O
char	O
*	O
*	O
outbuf	*(*(char))
,	O
size_t	long
*	O
outbytesleft	*(long)
,	O
bool	bool
*	O
incremented	*(bool)
)	O
{	O
const	O
char	O
*	O
inptr_before	*(char)
=	O
*	O
inbuf	*(*(char))
;	O
const	O
char	O
*	O
inptr	*(char)
=	O
inptr_before	*(char)
;	O
const	O
char	O
*	O
inptr_end	*(char)
=	O
inptr_before	*(char)
+	O
*	O
inbytesleft	*(long)
;	O
char	O
*	O
outptr	*(char)
=	O
*	O
outbuf	*(*(char))
;	O
size_t	long
outsize	long
=	O
*	O
outbytesleft	*(long)
;	O
size_t	long
res	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
size_t	long
insize	long
;	O
for	O
(	O
insize	long
=	O
1	int
;	O
inptr_before	*(char)
+	O
insize	long
<=	O
inptr_end	*(char)
;	O
insize	long
++	O
)	O
{	O
inptr	*(char)
=	O
inptr_before	*(char)
;	O
res	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd	*(void)
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	*(char)
,	O
&	O
insize	long
,	O
&	O
outptr	*(char)
,	O
&	O
outsize	long
)	O
;	O
if	O
(	O
!	O
(	O
res	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
EINVAL	int
)	O
)	O
break	O
;	O
if	O
(	O
inptr	*(char)
>	O
inptr_before	*(char)
)	O
{	O
res	long
=	O
0	int
;	O
break	O
;	O
}	O
}	O
*	O
inbuf	*(*(char))
=	O
inptr	*(char)
;	O
*	O
inbytesleft	*(long)
=	O
inptr_end	*(char)
-	O
inptr	*(char)
;	O
if	O
(	O
res	long
!=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
*	O
outbuf	*(*(char))
=	O
outptr	*(char)
;	O
*	O
outbytesleft	*(long)
=	O
outsize	long
;	O
}	O
*	O
incremented	*(bool)
=	O
false	int
;	O
return	O
res	long
;	O
}	O
static	O
size_t	long
utf8conv_carefully	(bool,*(*(char)),*(long),*(*(char)),*(long),*(bool))->(long)
(	O
bool	bool
one_character_only	bool
,	O
const	O
char	O
*	O
*	O
inbuf	*(*(char))
,	O
size_t	long
*	O
inbytesleft	*(long)
,	O
char	O
*	O
*	O
outbuf	*(*(char))
,	O
size_t	long
*	O
outbytesleft	*(long)
,	O
bool	bool
*	O
incremented	*(bool)
)	O
{	O
const	O
char	O
*	O
inptr	*(char)
=	O
*	O
inbuf	*(*(char))
;	O
size_t	long
insize	long
=	O
*	O
inbytesleft	*(long)
;	O
char	O
*	O
outptr	*(char)
=	O
*	O
outbuf	*(*(char))
;	O
size_t	long
outsize	long
=	O
*	O
outbytesleft	*(long)
;	O
size_t	long
res	long
;	O
res	long
=	O
0	int
;	O
do	O
{	O
ucs4_t	int
uc	int
;	O
int	O
n	long
;	O
int	O
m	int
;	O
n	long
=	O
u8_mbtoucr	(*(int),*(char),long)->(int)
(	O
&	O
uc	int
,	O
(	O
const	O
uint8_t	char
*	O
)	O
inptr	*(char)
,	O
insize	long
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
errno	O
=	O
(	O
n	long
==	O
-	O
2	int
?	O
EINVAL	int
:	O
EILSEQ	int
)	O
;	O
n	long
=	O
u8_mbtouc	(*(int),*(char),long)->(int)
(	O
&	O
uc	int
,	O
(	O
const	O
uint8_t	char
*	O
)	O
inptr	*(char)
,	O
insize	long
)	O
;	O
inptr	*(char)
+=	O
n	long
;	O
insize	long
-=	O
n	long
;	O
res	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
*	O
incremented	*(bool)
=	O
true	int
;	O
break	O
;	O
}	O
if	O
(	O
outsize	long
==	O
0	int
)	O
{	O
errno	O
=	O
E2BIG	int
;	O
res	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
*	O
incremented	*(bool)
=	O
false	int
;	O
break	O
;	O
}	O
m	int
=	O
u8_uctomb	(*(char),int,int)->(int)
(	O
(	O
uint8_t	char
*	O
)	O
outptr	*(char)
,	O
uc	int
,	O
outsize	long
)	O
;	O
if	O
(	O
m	int
==	O
-	O
2	int
)	O
{	O
errno	O
=	O
E2BIG	int
;	O
res	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
*	O
incremented	*(bool)
=	O
false	int
;	O
break	O
;	O
}	O
inptr	*(char)
+=	O
n	long
;	O
insize	long
-=	O
n	long
;	O
if	O
(	O
m	int
==	O
-	O
1	int
)	O
{	O
errno	O
=	O
EILSEQ	int
;	O
res	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
*	O
incremented	*(bool)
=	O
true	int
;	O
break	O
;	O
}	O
outptr	*(char)
+=	O
m	int
;	O
outsize	long
-=	O
m	int
;	O
}	O
while	O
(	O
!	O
one_character_only	bool
&&	O
insize	long
>	O
0	int
)	O
;	O
*	O
inbuf	*(*(char))
=	O
inptr	*(char)
;	O
*	O
inbytesleft	*(long)
=	O
insize	long
;	O
*	O
outbuf	*(*(char))
=	O
outptr	*(char)
;	O
*	O
outbytesleft	*(long)
=	O
outsize	long
;	O
return	O
res	long
;	O
}	O
static	O
int	O
mem_cd_iconveh_internal	(*(char),long,*(void),*(void),*(void),enum(int,int,int),long,*(long),*(*(char)),*(long))->(int)
(	O
const	O
char	O
*	O
src	*(char)
,	O
size_t	long
srclen	long
,	O
iconv_t	*(void)
cd	*(void)
,	O
iconv_t	*(void)
cd1	*(void)
,	O
iconv_t	*(void)
cd2	*(void)
,	O
enum	O
iconv_ilseq_handler	enum(int,int,int)
handler	enum(int,int,int)
,	O
size_t	long
extra_alloc	long
,	O
size_t	long
*	O
offsets	*(long)
,	O
char	O
*	O
*	O
resultp	*(*(char))
,	O
size_t	long
*	O
lengthp	*(long)
)	O
{	O
union	O
{	O
unsigned	O
int	O
align	int
;	O
char	O
buf	array(char)
[	O
tmpbufsize	int
]	O
;	O
}	O
tmp	union(int,array(char))
;	O
char	O
*	O
initial_result	*(char)
;	O
char	O
*	O
result	*(char)
;	O
size_t	long
allocated	long
;	O
size_t	long
length	long
;	O
size_t	long
last_length	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
*	O
resultp	*(*(char))
!=	O
NULL	O
&&	O
*	O
lengthp	*(long)
>=	O
sizeof	O
(	O
tmpbuf	O
)	O
)	O
{	O
initial_result	*(char)
=	O
*	O
resultp	*(*(char))
;	O
allocated	long
=	O
*	O
lengthp	*(long)
;	O
}	O
else	O
{	O
initial_result	*(char)
=	O
tmpbuf	O
;	O
allocated	long
=	O
sizeof	O
(	O
tmpbuf	O
)	O
;	O
}	O
result	*(char)
=	O
initial_result	*(char)
;	O
if	O
(	O
cd	*(void)
==	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
goto	O
indirectly	O
;	O
if	O
(	O
offsets	*(long)
!=	O
NULL	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
srclen	long
;	O
i	long
++	O
)	O
offsets	*(long)
[	O
i	long
]	O
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
last_length	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
}	O
length	long
=	O
0	int
;	O
{	O
const	O
char	O
*	O
inptr	*(char)
=	O
src	*(char)
;	O
size_t	long
insize	long
=	O
srclen	long
;	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd	*(void)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
insize	long
>	O
0	int
)	O
{	O
char	O
*	O
outptr	*(char)
=	O
result	*(char)
+	O
length	long
;	O
size_t	long
outsize	long
=	O
allocated	long
-	O
extra_alloc	long
-	O
length	long
;	O
bool	bool
incremented	*(bool)
;	O
size_t	long
res	long
;	O
bool	bool
grow	bool
;	O
if	O
(	O
offsets	*(long)
!=	O
NULL	O
)	O
{	O
if	O
(	O
length	long
!=	O
last_length	long
)	O
{	O
offsets	*(long)
[	O
inptr	*(char)
-	O
src	*(char)
]	O
=	O
length	long
;	O
last_length	long
=	O
length	long
;	O
}	O
res	long
=	O
iconv_carefully_1	(*(void),*(*(char)),*(long),*(*(char)),*(long),*(bool))->(long)
(	O
cd	*(void)
,	O
&	O
inptr	*(char)
,	O
&	O
insize	long
,	O
&	O
outptr	*(char)
,	O
&	O
outsize	long
,	O
&	O
incremented	*(bool)
)	O
;	O
}	O
else	O
res	long
=	O
iconv_carefully	O
(	O
cd	*(void)
,	O
&	O
inptr	*(char)
,	O
&	O
insize	long
,	O
&	O
outptr	*(char)
,	O
&	O
outsize	long
,	O
&	O
incremented	*(bool)
)	O
;	O
length	long
=	O
outptr	*(char)
-	O
result	*(char)
;	O
grow	bool
=	O
(	O
length	long
+	O
extra_alloc	long
>	O
allocated	long
/	O
2	int
)	O
;	O
if	O
(	O
res	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
E2BIG	int
)	O
grow	bool
=	O
true	int
;	O
else	O
if	O
(	O
errno	O
==	O
EINVAL	int
)	O
break	O
;	O
else	O
if	O
(	O
errno	O
==	O
EILSEQ	int
&&	O
handler	enum(int,int,int)
!=	O
iconveh_error	int
)	O
{	O
if	O
(	O
cd2	*(void)
==	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
length	long
+	O
1	int
+	O
extra_alloc	long
>	O
allocated	long
)	O
{	O
char	O
*	O
memory	*(char)
;	O
allocated	long
=	O
2	int
*	O
allocated	long
;	O
if	O
(	O
length	long
+	O
1	int
+	O
extra_alloc	long
>	O
allocated	long
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
allocated	long
)	O
;	O
else	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
result	*(char)
,	O
allocated	long
)	O
;	O
if	O
(	O
memory	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
ENOMEM	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
memory	*(char)
,	O
initial_result	*(char)
,	O
length	long
)	O
;	O
result	*(char)
=	O
memory	*(char)
;	O
grow	bool
=	O
false	int
;	O
}	O
if	O
(	O
!	O
incremented	*(bool)
)	O
{	O
if	O
(	O
insize	long
==	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
inptr	*(char)
++	O
;	O
insize	long
--	O
;	O
}	O
result	*(char)
[	O
length	long
]	O
=	O
'?'	O
;	O
length	long
++	O
;	O
}	O
else	O
goto	O
indirectly	O
;	O
}	O
else	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
insize	long
==	O
0	int
)	O
break	O
;	O
if	O
(	O
grow	bool
)	O
{	O
char	O
*	O
memory	*(char)
;	O
allocated	long
=	O
2	int
*	O
allocated	long
;	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
allocated	long
)	O
;	O
else	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
result	*(char)
,	O
allocated	long
)	O
;	O
if	O
(	O
memory	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
ENOMEM	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
memory	*(char)
,	O
initial_result	*(char)
,	O
length	long
)	O
;	O
result	*(char)
=	O
memory	*(char)
;	O
}	O
}	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
outptr	*(char)
=	O
result	*(char)
+	O
length	long
;	O
size_t	long
outsize	long
=	O
allocated	long
-	O
extra_alloc	long
-	O
length	long
;	O
size_t	long
res	long
;	O
res	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd	*(void)
,	O
NULL	O
,	O
NULL	O
,	O
&	O
outptr	*(char)
,	O
&	O
outsize	long
)	O
;	O
length	long
=	O
outptr	*(char)
-	O
result	*(char)
;	O
if	O
(	O
res	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
E2BIG	int
)	O
{	O
char	O
*	O
memory	*(char)
;	O
allocated	long
=	O
2	int
*	O
allocated	long
;	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
allocated	long
)	O
;	O
else	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
result	*(char)
,	O
allocated	long
)	O
;	O
if	O
(	O
memory	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
ENOMEM	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
memory	*(char)
,	O
initial_result	*(char)
,	O
length	long
)	O
;	O
result	*(char)
=	O
memory	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
break	O
;	O
}	O
goto	O
done	O
;	O
indirectly	O
:	O
if	O
(	O
offsets	*(long)
!=	O
NULL	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
srclen	long
;	O
i	long
++	O
)	O
offsets	*(long)
[	O
i	long
]	O
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
last_length	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
}	O
length	long
=	O
0	int
;	O
{	O
const	O
bool	bool
slowly	bool
=	O
(	O
offsets	*(long)
!=	O
NULL	O
||	O
handler	enum(int,int,int)
==	O
iconveh_error	int
)	O
;	O
char	O
utf8buf	array(char)
[	O
utf8bufsize	int
+	O
1	int
]	O
;	O
size_t	long
utf8len	long
=	O
0	int
;	O
const	O
char	O
*	O
in1ptr	*(char)
=	O
src	*(char)
;	O
size_t	long
in1size	long
=	O
srclen	long
;	O
bool	bool
do_final_flush1	bool
=	O
true	int
;	O
bool	bool
do_final_flush2	bool
=	O
true	int
;	O
if	O
(	O
cd1	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd1	*(void)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
cd2	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd2	*(void)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
in1size	long
>	O
0	int
||	O
do_final_flush1	bool
||	O
utf8len	long
>	O
0	int
||	O
do_final_flush2	bool
)	O
{	O
char	O
*	O
out1ptr	*(char)
=	O
utf8buf	array(char)
+	O
utf8len	long
;	O
size_t	long
out1size	long
=	O
utf8bufsize	int
-	O
utf8len	long
;	O
bool	bool
incremented1	bool
;	O
size_t	long
res1	long
;	O
int	O
errno1	int
;	O
if	O
(	O
in1size	long
>	O
0	int
)	O
{	O
if	O
(	O
offsets	*(long)
!=	O
NULL	O
&&	O
length	long
!=	O
last_length	long
)	O
{	O
offsets	*(long)
[	O
in1ptr	*(char)
-	O
src	*(char)
]	O
=	O
length	long
;	O
last_length	long
=	O
length	long
;	O
}	O
if	O
(	O
cd1	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
slowly	bool
)	O
res1	long
=	O
iconv_carefully_1	(*(void),*(*(char)),*(long),*(*(char)),*(long),*(bool))->(long)
(	O
cd1	*(void)
,	O
&	O
in1ptr	*(char)
,	O
&	O
in1size	long
,	O
&	O
out1ptr	*(char)
,	O
&	O
out1size	long
,	O
&	O
incremented1	bool
)	O
;	O
else	O
res1	long
=	O
iconv_carefully	O
(	O
cd1	*(void)
,	O
&	O
in1ptr	*(char)
,	O
&	O
in1size	long
,	O
&	O
out1ptr	*(char)
,	O
&	O
out1size	long
,	O
&	O
incremented1	bool
)	O
;	O
}	O
else	O
{	O
res1	long
=	O
utf8conv_carefully	(bool,*(*(char)),*(long),*(*(char)),*(long),*(bool))->(long)
(	O
slowly	bool
,	O
&	O
in1ptr	*(char)
,	O
&	O
in1size	long
,	O
&	O
out1ptr	*(char)
,	O
&	O
out1size	long
,	O
&	O
incremented1	bool
)	O
;	O
}	O
}	O
else	O
if	O
(	O
do_final_flush1	bool
)	O
{	O
if	O
(	O
cd1	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
res1	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd1	*(void)
,	O
NULL	O
,	O
NULL	O
,	O
&	O
out1ptr	*(char)
,	O
&	O
out1size	long
)	O
;	O
else	O
res1	long
=	O
0	int
;	O
do_final_flush1	bool
=	O
false	int
;	O
incremented1	bool
=	O
true	int
;	O
}	O
else	O
{	O
res1	long
=	O
0	int
;	O
incremented1	bool
=	O
true	int
;	O
}	O
if	O
(	O
res1	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
&&	O
!	O
(	O
errno	O
==	O
E2BIG	int
||	O
errno	O
==	O
EINVAL	int
||	O
errno	O
==	O
EILSEQ	int
)	O
)	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
res1	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
EILSEQ	int
&&	O
handler	enum(int,int,int)
!=	O
iconveh_error	int
)	O
{	O
if	O
(	O
!	O
incremented1	bool
)	O
{	O
if	O
(	O
in1size	long
==	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
in1ptr	*(char)
++	O
;	O
in1size	long
--	O
;	O
}	O
*	O
out1ptr	*(char)
++	O
=	O
'?'	O
;	O
res1	long
=	O
0	int
;	O
}	O
errno1	int
=	O
errno	O
;	O
utf8len	long
=	O
out1ptr	*(char)
-	O
utf8buf	array(char)
;	O
if	O
(	O
offsets	*(long)
!=	O
NULL	O
||	O
in1size	long
==	O
0	int
||	O
utf8len	long
>	O
utf8bufsize	int
/	O
2	int
||	O
(	O
res1	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
&&	O
errno1	int
==	O
E2BIG	int
)	O
)	O
{	O
const	O
char	O
*	O
in2ptr	*(char)
=	O
utf8buf	array(char)
;	O
size_t	long
in2size	long
=	O
utf8len	long
;	O
while	O
(	O
in2size	long
>	O
0	int
||	O
(	O
in1size	long
==	O
0	int
&&	O
!	O
do_final_flush1	bool
&&	O
do_final_flush2	bool
)	O
)	O
{	O
char	O
*	O
out2ptr	*(char)
=	O
result	*(char)
+	O
length	long
;	O
size_t	long
out2size	long
=	O
allocated	long
-	O
extra_alloc	long
-	O
length	long
;	O
bool	bool
incremented2	bool
;	O
size_t	long
res2	long
;	O
bool	bool
grow	bool
;	O
if	O
(	O
in2size	long
>	O
0	int
)	O
{	O
if	O
(	O
cd2	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
res2	long
=	O
iconv_carefully	O
(	O
cd2	*(void)
,	O
&	O
in2ptr	*(char)
,	O
&	O
in2size	long
,	O
&	O
out2ptr	*(char)
,	O
&	O
out2size	long
,	O
&	O
incremented2	bool
)	O
;	O
else	O
res2	long
=	O
utf8conv_carefully	(bool,*(*(char)),*(long),*(*(char)),*(long),*(bool))->(long)
(	O
false	int
,	O
&	O
in2ptr	*(char)
,	O
&	O
in2size	long
,	O
&	O
out2ptr	*(char)
,	O
&	O
out2size	long
,	O
&	O
incremented2	bool
)	O
;	O
}	O
else	O
{	O
if	O
(	O
cd2	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
res2	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd2	*(void)
,	O
NULL	O
,	O
NULL	O
,	O
&	O
out2ptr	*(char)
,	O
&	O
out2size	long
)	O
;	O
else	O
res2	long
=	O
0	int
;	O
do_final_flush2	bool
=	O
false	int
;	O
incremented2	bool
=	O
true	int
;	O
}	O
length	long
=	O
out2ptr	*(char)
-	O
result	*(char)
;	O
grow	bool
=	O
(	O
length	long
+	O
extra_alloc	long
>	O
allocated	long
/	O
2	int
)	O
;	O
if	O
(	O
res2	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
E2BIG	int
)	O
grow	bool
=	O
true	int
;	O
else	O
if	O
(	O
errno	O
==	O
EINVAL	int
)	O
break	O
;	O
else	O
if	O
(	O
errno	O
==	O
EILSEQ	int
&&	O
handler	enum(int,int,int)
!=	O
iconveh_error	int
)	O
{	O
char	O
scratchbuf	array(char)
[	O
10	int
]	O
;	O
size_t	long
scratchlen	long
;	O
ucs4_t	int
uc	int
;	O
const	O
char	O
*	O
inptr	*(char)
;	O
size_t	long
insize	long
;	O
size_t	long
res	long
;	O
if	O
(	O
incremented2	bool
)	O
{	O
if	O
(	O
u8_prev	(*(int),*(char),*(char))->(*(char))
(	O
&	O
uc	int
,	O
(	O
const	O
uint8_t	char
*	O
)	O
in2ptr	*(char)
,	O
(	O
const	O
uint8_t	char
*	O
)	O
utf8buf	array(char)
)	O
==	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
int	O
n	long
;	O
if	O
(	O
in2size	long
==	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
n	long
=	O
u8_mbtouc_unsafe	(*(int),*(char),long)->(int)
(	O
&	O
uc	int
,	O
(	O
const	O
uint8_t	char
*	O
)	O
in2ptr	*(char)
,	O
in2size	long
)	O
;	O
in2ptr	*(char)
+=	O
n	long
;	O
in2size	long
-=	O
n	long
;	O
}	O
if	O
(	O
handler	enum(int,int,int)
==	O
iconveh_escape_sequence	int
)	O
{	O
static	O
char	O
hex	array(char)
[	O
16	int
]	O
=	O
"0123456789ABCDEF"	*(char)
;	O
scratchlen	long
=	O
0	int
;	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
'\\'	O
;	O
if	O
(	O
uc	int
<	O
0x10000	int
)	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
'u'	O
;	O
else	O
{	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
'U'	O
;	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
hex	array(char)
[	O
(	O
uc	int
>>	O
28	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
hex	array(char)
[	O
(	O
uc	int
>>	O
24	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
hex	array(char)
[	O
(	O
uc	int
>>	O
20	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
hex	array(char)
[	O
(	O
uc	int
>>	O
16	int
)	O
&	O
15	int
]	O
;	O
}	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
hex	array(char)
[	O
(	O
uc	int
>>	O
12	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
hex	array(char)
[	O
(	O
uc	int
>>	O
8	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
hex	array(char)
[	O
(	O
uc	int
>>	O
4	int
)	O
&	O
15	int
]	O
;	O
scratchbuf	array(char)
[	O
scratchlen	long
++	O
]	O
=	O
hex	array(char)
[	O
uc	int
&	O
15	int
]	O
;	O
}	O
else	O
{	O
scratchbuf	array(char)
[	O
0	int
]	O
=	O
'?'	O
;	O
scratchlen	long
=	O
1	int
;	O
}	O
inptr	*(char)
=	O
scratchbuf	array(char)
;	O
insize	long
=	O
scratchlen	long
;	O
if	O
(	O
cd2	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
res	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd2	*(void)
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	*(char)
,	O
&	O
insize	long
,	O
&	O
out2ptr	*(char)
,	O
&	O
out2size	long
)	O
;	O
else	O
{	O
if	O
(	O
out2size	long
>=	O
insize	long
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
out2ptr	*(char)
,	O
inptr	*(char)
,	O
insize	long
)	O
;	O
out2ptr	*(char)
+=	O
insize	long
;	O
out2size	long
-=	O
insize	long
;	O
inptr	*(char)
+=	O
insize	long
;	O
insize	long
=	O
0	int
;	O
res	long
=	O
0	int
;	O
}	O
else	O
{	O
errno	O
=	O
E2BIG	int
;	O
res	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
}	O
}	O
length	long
=	O
out2ptr	*(char)
-	O
result	*(char)
;	O
if	O
(	O
res	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
==	O
E2BIG	int
)	O
{	O
char	O
*	O
memory	*(char)
;	O
allocated	long
=	O
2	int
*	O
allocated	long
;	O
if	O
(	O
length	long
+	O
1	int
+	O
extra_alloc	long
>	O
allocated	long
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
allocated	long
)	O
;	O
else	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
result	*(char)
,	O
allocated	long
)	O
;	O
if	O
(	O
memory	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
ENOMEM	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
memory	*(char)
,	O
initial_result	*(char)
,	O
length	long
)	O
;	O
result	*(char)
=	O
memory	*(char)
;	O
grow	bool
=	O
false	int
;	O
out2ptr	*(char)
=	O
result	*(char)
+	O
length	long
;	O
out2size	long
=	O
allocated	long
-	O
extra_alloc	long
-	O
length	long
;	O
if	O
(	O
cd2	*(void)
!=	O
(	O
iconv_t	*(void)
)	O
(	O
-	O
1	int
)	O
)	O
res	long
=	O
iconv	(*(void),*(*(char)),*(long),*(*(char)),*(long))->(long)
(	O
cd2	*(void)
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	*(char)
,	O
&	O
insize	long
,	O
&	O
out2ptr	*(char)
,	O
&	O
out2size	long
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
out2size	long
>=	O
insize	long
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
out2ptr	*(char)
,	O
inptr	*(char)
,	O
insize	long
)	O
;	O
out2ptr	*(char)
+=	O
insize	long
;	O
out2size	long
-=	O
insize	long
;	O
inptr	*(char)
+=	O
insize	long
;	O
insize	long
=	O
0	int
;	O
res	long
=	O
0	int
;	O
}	O
length	long
=	O
out2ptr	*(char)
-	O
result	*(char)
;	O
}	O
if	O
(	O
res	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
(	O
in2size	long
>	O
0	int
||	O
(	O
in1size	long
==	O
0	int
&&	O
!	O
do_final_flush1	bool
&&	O
do_final_flush2	bool
)	O
)	O
)	O
break	O
;	O
if	O
(	O
grow	bool
)	O
{	O
char	O
*	O
memory	*(char)
;	O
allocated	long
=	O
2	int
*	O
allocated	long
;	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
allocated	long
)	O
;	O
else	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
result	*(char)
,	O
allocated	long
)	O
;	O
if	O
(	O
memory	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
ENOMEM	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
result	*(char)
==	O
initial_result	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
memory	*(char)
,	O
initial_result	*(char)
,	O
length	long
)	O
;	O
result	*(char)
=	O
memory	*(char)
;	O
}	O
}	O
if	O
(	O
in2size	long
>	O
0	int
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
utf8buf	array(char)
,	O
in2ptr	*(char)
,	O
in2size	long
)	O
;	O
utf8len	long
=	O
in2size	long
;	O
}	O
if	O
(	O
res1	long
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
errno1	int
==	O
EINVAL	int
)	O
in1size	long
=	O
0	int
;	O
else	O
if	O
(	O
errno1	int
==	O
EILSEQ	int
)	O
{	O
if	O
(	O
result	*(char)
!=	O
initial_result	*(char)
)	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
errno1	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
}	O
done	O
:	O
if	O
(	O
result	*(char)
==	O
tmpbuf	O
)	O
{	O
size_t	long
memsize	long
=	O
length	long
+	O
extra_alloc	long
;	O
if	O
(	O
*	O
resultp	*(*(char))
!=	O
NULL	O
&&	O
*	O
lengthp	*(long)
>=	O
memsize	long
)	O
result	*(char)
=	O
*	O
resultp	*(*(char))
;	O
else	O
{	O
char	O
*	O
memory	*(char)
;	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
memsize	long
>	O
0	int
?	O
memsize	long
:	O
1	int
)	O
;	O
if	O
(	O
memory	*(char)
!=	O
NULL	O
)	O
result	*(char)
=	O
memory	*(char)
;	O
else	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
result	*(char)
,	O
tmpbuf	O
,	O
length	long
)	O
;	O
}	O
else	O
if	O
(	O
result	*(char)
!=	O
*	O
resultp	*(*(char))
&&	O
length	long
+	O
extra_alloc	long
<	O
allocated	long
)	O
{	O
size_t	long
memsize	long
=	O
length	long
+	O
extra_alloc	long
;	O
char	O
*	O
memory	*(char)
;	O
memory	*(char)
=	O
(	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
result	*(char)
,	O
memsize	long
>	O
0	int
?	O
memsize	long
:	O
1	int
)	O
;	O
if	O
(	O
memory	*(char)
!=	O
NULL	O
)	O
result	*(char)
=	O
memory	*(char)
;	O
}	O
*	O
resultp	*(*(char))
=	O
result	*(char)
;	O
*	O
lengthp	*(long)
=	O
length	long
;	O
return	O
0	int
;	O
}	O
int	O
mem_cd_iconveh	(*(char),long,*(struct(*(void),*(void),*(void))),enum(int,int,int),*(long),*(*(char)),*(long))->(int)
(	O
const	O
char	O
*	O
src	*(char)
,	O
size_t	long
srclen	long
,	O
const	O
iconveh_t	struct(*(void),*(void),*(void))
*	O
cd	*(void)
,	O
enum	O
iconv_ilseq_handler	enum(int,int,int)
handler	enum(int,int,int)
,	O
size_t	long
*	O
offsets	*(long)
,	O
char	O
*	O
*	O
resultp	*(*(char))
,	O
size_t	long
*	O
lengthp	*(long)
)	O
{	O
return	O
mem_cd_iconveh_internal	(*(char),long,*(void),*(void),*(void),enum(int,int,int),long,*(long),*(*(char)),*(long))->(int)
(	O
src	*(char)
,	O
srclen	long
,	O
cd	*(void)
->	O
cd	*(void)
,	O
cd	*(void)
->	O
cd1	*(void)
,	O
cd	*(void)
->	O
cd2	*(void)
,	O
handler	enum(int,int,int)
,	O
0	int
,	O
offsets	*(long)
,	O
resultp	*(*(char))
,	O
lengthp	*(long)
)	O
;	O
}	O
char	O
*	O
str_cd_iconveh	(*(char),*(struct(*(void),*(void),*(void))),enum(int,int,int))->(*(char))
(	O
const	O
char	O
*	O
src	*(char)
,	O
const	O
iconveh_t	struct(*(void),*(void),*(void))
*	O
cd	*(void)
,	O
enum	O
iconv_ilseq_handler	enum(int,int,int)
handler	enum(int,int,int)
)	O
{	O
char	O
*	O
result	*(char)
=	O
NULL	O
;	O
size_t	long
length	long
=	O
0	int
;	O
int	O
retval	int
=	O
mem_cd_iconveh_internal	(*(char),long,*(void),*(void),*(void),enum(int,int,int),long,*(long),*(*(char)),*(long))->(int)
(	O
src	*(char)
,	O
strlen	(*(char))->(long)
(	O
src	*(char)
)	O
,	O
cd	*(void)
->	O
cd	*(void)
,	O
cd	*(void)
->	O
cd1	*(void)
,	O
cd	*(void)
->	O
cd2	*(void)
,	O
handler	enum(int,int,int)
,	O
1	int
,	O
NULL	O
,	O
&	O
result	*(char)
,	O
&	O
length	long
)	O
;	O
if	O
(	O
retval	int
<	O
0	int
)	O
{	O
if	O
(	O
result	*(char)
!=	O
NULL	O
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
return	O
NULL	O
;	O
}	O
result	*(char)
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
result	*(char)
;	O
}	O
int	O
mem_iconveh	(*(char),long,*(char),*(char),enum(int,int,int),*(long),*(*(char)),*(long))->(int)
(	O
const	O
char	O
*	O
src	*(char)
,	O
size_t	long
srclen	long
,	O
const	O
char	O
*	O
from_codeset	*(char)
,	O
const	O
char	O
*	O
to_codeset	*(char)
,	O
enum	O
iconv_ilseq_handler	enum(int,int,int)
handler	enum(int,int,int)
,	O
size_t	long
*	O
offsets	*(long)
,	O
char	O
*	O
*	O
resultp	*(*(char))
,	O
size_t	long
*	O
lengthp	*(long)
)	O
{	O
if	O
(	O
srclen	long
==	O
0	int
)	O
{	O
*	O
lengthp	*(long)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
offsets	*(long)
==	O
NULL	O
&&	O
c_strcasecmp	(*(char),*(char))->(int)
(	O
from_codeset	*(char)
,	O
to_codeset	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
result	*(char)
;	O
if	O
(	O
*	O
resultp	*(*(char))
!=	O
NULL	O
&&	O
*	O
lengthp	*(long)
>=	O
srclen	long
)	O
result	*(char)
=	O
*	O
resultp	*(*(char))
;	O
else	O
{	O
result	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
srclen	long
)	O
;	O
if	O
(	O
result	*(char)
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
result	*(char)
,	O
src	*(char)
,	O
srclen	long
)	O
;	O
*	O
resultp	*(*(char))
=	O
result	*(char)
;	O
*	O
lengthp	*(long)
=	O
srclen	long
;	O
return	O
0	int
;	O
}	O
else	O
{	O
iconveh_t	struct(*(void),*(void),*(void))
cd	*(void)
;	O
char	O
*	O
result	*(char)
;	O
size_t	long
length	long
;	O
int	O
retval	int
;	O
if	O
(	O
iconveh_open	(*(char),*(char),*(struct(*(void),*(void),*(void))))->(int)
(	O
to_codeset	*(char)
,	O
from_codeset	*(char)
,	O
&	O
cd	*(void)
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
result	*(char)
=	O
*	O
resultp	*(*(char))
;	O
length	long
=	O
*	O
lengthp	*(long)
;	O
retval	int
=	O
mem_cd_iconveh	(*(char),long,*(struct(*(void),*(void),*(void))),enum(int,int,int),*(long),*(*(char)),*(long))->(int)
(	O
src	*(char)
,	O
srclen	long
,	O
&	O
cd	*(void)
,	O
handler	enum(int,int,int)
,	O
offsets	*(long)
,	O
&	O
result	*(char)
,	O
&	O
length	long
)	O
;	O
if	O
(	O
retval	int
<	O
0	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
iconveh_close	(*(struct(*(void),*(void),*(void))))->(int)
(	O
&	O
cd	*(void)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
else	O
{	O
if	O
(	O
iconveh_close	(*(struct(*(void),*(void),*(void))))->(int)
(	O
&	O
cd	*(void)
)	O
<	O
0	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
if	O
(	O
result	*(char)
!=	O
*	O
resultp	*(*(char))
&&	O
result	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
resultp	*(*(char))
=	O
result	*(char)
;	O
*	O
lengthp	*(long)
=	O
length	long
;	O
}	O
return	O
retval	int
;	O
}	O
}	O
char	O
*	O
str_iconveh	(*(char),*(char),*(char),enum(int,int,int))->(*(char))
(	O
const	O
char	O
*	O
src	*(char)
,	O
const	O
char	O
*	O
from_codeset	*(char)
,	O
const	O
char	O
*	O
to_codeset	*(char)
,	O
enum	O
iconv_ilseq_handler	enum(int,int,int)
handler	enum(int,int,int)
)	O
{	O
if	O
(	O
*	O
src	*(char)
==	O
'\0'	O
||	O
c_strcasecmp	(*(char),*(char))->(int)
(	O
from_codeset	*(char)
,	O
to_codeset	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
result	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
src	*(char)
)	O
;	O
if	O
(	O
result	*(char)
==	O
NULL	O
)	O
errno	O
=	O
ENOMEM	int
;	O
return	O
result	*(char)
;	O
}	O
else	O
{	O
iconveh_t	struct(*(void),*(void),*(void))
cd	*(void)
;	O
char	O
*	O
result	*(char)
;	O
if	O
(	O
iconveh_open	(*(char),*(char),*(struct(*(void),*(void),*(void))))->(int)
(	O
to_codeset	*(char)
,	O
from_codeset	*(char)
,	O
&	O
cd	*(void)
)	O
<	O
0	int
)	O
return	O
NULL	O
;	O
result	*(char)
=	O
str_cd_iconveh	(*(char),*(struct(*(void),*(void),*(void))),enum(int,int,int))->(*(char))
(	O
src	*(char)
,	O
&	O
cd	*(void)
,	O
handler	enum(int,int,int)
)	O
;	O
if	O
(	O
result	*(char)
==	O
NULL	O
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
iconveh_close	(*(struct(*(void),*(void),*(void))))->(int)
(	O
&	O
cd	*(void)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
else	O
{	O
if	O
(	O
iconveh_close	(*(struct(*(void),*(void),*(void))))->(int)
(	O
&	O
cd	*(void)
)	O
<	O
0	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
result	*(char)
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
NULL	O
;	O
}	O
}	O
return	O
result	*(char)
;	O
}	O
}	O
