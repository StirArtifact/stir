int	O
bt_scan	(*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),int,*(char),int,*(char),int,*(()->(int)),*(long),*(int),int)->(int)
(	O
HAND	struct(*(struct),long,long,int,int)
*	O
han	*(struct(*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long,long,int,int))
,	O
int	O
operation	int
,	O
unsigned	O
char	O
*	O
kstr1	*(char)
,	O
int	O
len1	int
,	O
unsigned	O
char	O
*	O
kstr2	*(char)
,	O
int	O
len2	int
,	O
int_function	*(()->(int))
func	*(()->(int))
,	O
long	O
*	O
long_tab	*(long)
,	O
int	O
*	O
respkt	*(int)
,	O
int	O
blk_limit	int
)	O
{	O
L_bt_scan	O
:	O
{	O
int	O
pkt	*(int)
[	O
pkt_size	int
]	O
;	O
int	O
opkt	*(int)
[	O
pkt_size	int
]	O
;	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
0	int
;	O
unsigned	O
char	O
vstr	*(char)
[	O
0x100	int
]	O
;	O
int	O
accmode	int
=	O
(	O
operation	int
)	O
==	O
(	O
count_scan	int
)	O
?	O
accread	O
:	O
accwrite	O
;	O
int	O
result	int
=	O
success	int
;	O
if	O
(	O
key_error_P	(*(char),int,int,*(char))->(int)
(	O
kstr1	*(char)
,	O
len1	int
,	O
-	O
2	int
,	O
"bt_scan_1"	*(char)
)	O
)	O
return	O
keyerr	O
;	O
else	O
if	O
(	O
key_error_P	(*(char),int,int,*(char))->(int)
(	O
kstr2	*(char)
,	O
len2	int
,	O
-	O
1	int
,	O
"bt_scan_2"	*(char)
)	O
)	O
return	O
keyerr	O
;	O
else	O
if	O
(	O
han_error_P	(*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),*(char))->(int)
(	O
han	*(struct(*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long,long,int,int))
,	O
"bt_scan"	*(char)
)	O
)	O
return	O
argerr	O
;	O
else	O
if	O
(	O
(	O
(	O
operation	int
)	O
==	O
(	O
modify_scan	int
)	O
)	O
&&	O
(	O
!	O
(	O
func	*(()->(int))
)	O
)	O
)	O
{	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
">>>>ERROR<<<< %s: MODIFY-SCAN requires func be specified\n"	*(char)
,	O
"bt_scan"	*(char)
)	O
)	O
;	O
return	O
argerr	O
;	O
}	O
else	O
{	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
chain_find_ent	(*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),int,*(char),int,*(int))->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
han	*(struct(*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long,long,int,int))
,	O
accmode	int
,	O
kstr1	*(char)
,	O
len1	int
,	O
pkt	*(int)
)	O
;	O
if	O
(	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
&&	O
(	O
blk_find_pos	(*(char),*(char),int,*(int))->(int)
(	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
kstr2	*(char)
,	O
len2	int
,	O
opkt	*(int)
)	O
)	O
)	O
{	O
if	O
(	O
(	O
operation	int
)	O
==	O
(	O
count_scan	int
)	O
)	O
{	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
=	O
allocate_ent	()->(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))
(	O
)	O
;	O
ent_copy	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))->(void)
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accmode	int
)	O
;	O
result	int
=	O
chain_scan	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(int),*(int),*(char),*(()->(int)),*(long),*(char),*(int),int)->(int)
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
operation	int
,	O
pkt	*(int)
,	O
opkt	*(int)
,	O
kstr1	*(char)
,	O
func	*(()->(int))
,	O
long_tab	*(long)
,	O
vstr	*(char)
,	O
respkt	*(int)
,	O
han_wcb	O
(	O
han	*(struct(*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long,long,int,int))
)	O
)	O
;	O
recycle_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))->(void)
(	O
nent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
}	O
else	O
{	O
result	int
=	O
chain_scan	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(int),*(int),*(char),*(()->(int)),*(long),*(char),*(int),int)->(int)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
operation	int
,	O
pkt	*(int)
,	O
opkt	*(int)
,	O
kstr1	*(char)
,	O
func	*(()->(int))
,	O
long_tab	*(long)
,	O
vstr	*(char)
,	O
respkt	*(int)
,	O
han_wcb	O
(	O
han	*(struct(*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long,long,int,int))
)	O
)	O
;	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accmode	int
)	O
;	O
if	O
(	O
(	O
result	int
)	O
>	O
0	int
)	O
{	O
result	int
=	O
bt_put	(*(struct(*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long,long,int,int)),*(char),int,*(char),int)->(int)
(	O
han	*(struct(*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long)),long,long,int,int))
,	O
kstr1	*(char)
,	O
pkt_skey_len	O
(	O
respkt	*(int)
)	O
,	O
vstr	*(char)
,	O
result	int
)	O
;	O
if	O
(	O
(	O
result	int
)	O
==	O
(	O
success	int
)	O
)	O
{	O
pkt_set_skey_count	O
(	O
respkt	*(int)
,	O
(	O
pkt_skey_count	O
(	O
respkt	*(int)
)	O
)	O
+	O
1	int
)	O
;	O
pkt_set_skey_len	O
(	O
respkt	*(int)
,	O
increment_string	(*(char),int,int)->(int)
(	O
kstr1	*(char)
,	O
pkt_skey_len	O
(	O
respkt	*(int)
)	O
,	O
0x100	int
)	O
)	O
;	O
result	int
=	O
notpres	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
(	O
result	int
)	O
==	O
(	O
notpres	O
)	O
)	O
&&	O
(	O
0	int
!=	O
(	O
blk_limit	int
)	O
)	O
)	O
{	O
len1	int
=	O
pkt_skey_len	O
(	O
respkt	*(int)
)	O
;	O
blk_limit	int
=	O
(	O
blk_limit	int
)	O
-	O
1	int
;	O
goto	O
L_bt_scan	O
;	O
}	O
else	O
return	O
result	int
;	O
}	O
else	O
{	O
if	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
release_ent	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int)->(void)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
accmode	int
)	O
;	O
rem_fct	long
=	O
0x1L	int
+	O
(	O
rem_fct	long
)	O
;	O
return	O
unkerr	O
;	O
}	O
}	O
}	O
}	O
int	O
increment_string	(*(char),int,int)->(int)
(	O
unsigned	O
char	O
*	O
str	*(char)
,	O
int	O
len	int
,	O
int	O
maxlen	int
)	O
{	O
if	O
(	O
(	O
len	int
)	O
<	O
(	O
maxlen	int
)	O
)	O
{	O
str	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
return	O
(	O
len	int
)	O
+	O
1	int
;	O
}	O
else	O
{	O
int	O
oldval	int
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	*(char)
)	O
)	O
[	O
(	O
len	int
)	O
-	O
1	int
]	O
)	O
;	O
str	*(char)
[	O
(	O
len	int
)	O
-	O
1	int
]	O
=	O
1	int
+	O
(	O
oldval	int
)	O
;	O
return	O
len	int
;	O
}	O
}	O
int	O
chain_scan	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),int,*(int),*(int),*(char),*(()->(int)),*(long),*(char),*(int),int)->(int)
(	O
ENTRY	struct(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct(*`,long,long,int,int)),*(struct(*`,long,long,int,int)),*(struct(*`,int,union`)),*(struct(*`,int,union`)),int,*(long),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)),long)))
*	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
int	O
operation	int
,	O
int	O
*	O
pkt	*(int)
,	O
int	O
*	O
opkt	*(int)
,	O
unsigned	O
char	O
*	O
key_str	*(char)
,	O
int_function	*(()->(int))
func	*(()->(int))
,	O
long	O
*	O
long_tab	*(long)
,	O
unsigned	O
char	O
*	O
vstr	*(char)
,	O
int	O
*	O
respkt	*(int)
,	O
int	O
wcb	int
)	O
{	O
{	O
unsigned	O
char	O
*	O
blk	*(char)
=	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
int	O
result	int
=	O
success	int
;	O
if	O
(	O
(	O
(	O
operation	int
)	O
==	O
(	O
rem_scan	O
)	O
)	O
&&	O
(	O
!	O
(	O
func	*(()->(int))
)	O
)	O
&&	O
(	O
(	O
pkt_match_pos	O
(	O
opkt	*(int)
)	O
)	O
>	O
(	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
)	O
&&	O
(	O
(	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
==	O
(	O
blk_data_start	int
)	O
)	O
&&	O
(	O
at_split_key_pos_P	(*(char),int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
opkt	*(int)
)	O
)	O
)	O
)	O
{	O
{	O
int	O
key_len	int
=	O
recon_this_key	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
opkt	*(int)
)	O
,	O
key_str	*(char)
,	O
0	int
,	O
0x100	int
)	O
;	O
subbytes_move	O
(	O
key_str	*(char)
,	O
0	int
,	O
key_len	int
,	O
blk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
set_field_len	O
(	O
blk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
key_len	int
)	O
;	O
blk_set_end	O
(	O
blk	*(char)
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
+	O
(	O
key_len	int
)	O
)	O
;	O
}	O
pkt_set_skey_count	O
(	O
respkt	*(int)
,	O
(	O
pkt_skey_count	O
(	O
respkt	*(int)
)	O
)	O
+	O
1	int
)	O
;	O
rem_ct	long
=	O
0x1L	int
+	O
(	O
rem_ct	long
)	O
;	O
ent_set_dty	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
!	O
0	int
)	O
;	O
pkt_set_match_pos	O
(	O
opkt	*(int)
,	O
blk_data_start	int
)	O
;	O
}	O
else	O
{	O
int	O
oldct	int
=	O
pkt_skey_count	O
(	O
respkt	*(int)
)	O
;	O
unsigned	O
char	O
ckstr	*(char)
[	O
0x100	int
]	O
;	O
int	O
clen	int
=	O
0	int
;	O
if	O
(	O
func	*(()->(int))
)	O
clen	int
=	O
recon_this_key	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
ckstr	*(char)
,	O
0	int
,	O
0x100	int
)	O
;	O
pkt_set_match_type	O
(	O
pkt	*(int)
,	O
match	O
)	O
;	O
result	int
=	O
scan_loop	(*(char),int,*(int),*(int),*(()->(int)),*(long),*(int),*(char),int,*(char),int)->(int)
(	O
ent_blk	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
,	O
operation	int
,	O
pkt	*(int)
,	O
opkt	*(int)
,	O
func	*(()->(int))
,	O
long_tab	*(long)
,	O
respkt	*(int)
,	O
ckstr	*(char)
,	O
clen	int
,	O
vstr	*(char)
,	O
seg_bsiz	O
(	O
ent_seg	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
)	O
;	O
if	O
(	O
(	O
(	O
operation	int
)	O
!=	O
(	O
count_scan	int
)	O
)	O
&&	O
(	O
(	O
pkt_skey_count	O
(	O
respkt	*(int)
)	O
)	O
>	O
(	O
oldct	int
)	O
)	O
)	O
ent_set_dty	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
,	O
!	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
(	O
operation	int
)	O
==	O
(	O
rem_scan	O
)	O
)	O
&&	O
(	O
blk_empty_P	O
(	O
blk	*(char)
)	O
)	O
&&	O
(	O
!	O
(	O
end_of_chain_P	O
(	O
blk	*(char)
)	O
)	O
)	O
)	O
{	O
del_delete_bck	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))->(int)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
}	O
else	O
if	O
(	O
ent_dty_P	O
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
)	O
if	O
(	O
(	O
(	O
(	O
operation	int
)	O
==	O
(	O
rem_scan	O
)	O
)	O
&&	O
(	O
(	O
(	O
wcb_sar	int
)	O
&	O
(	O
wcb	int
)	O
)	O
||	O
(	O
(	O
blk_level	O
(	O
blk	*(char)
)	O
)	O
>	O
(	O
leaf	int
)	O
)	O
)	O
)	O
||	O
(	O
(	O
(	O
operation	int
)	O
==	O
(	O
modify_scan	int
)	O
)	O
&&	O
(	O
(	O
wcb_sap	int
)	O
&	O
(	O
wcb	int
)	O
)	O
)	O
)	O
ents_ent_write	(*(struct(*(struct(*`,long,*`,int,int,int,int,int,int,*`)),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*`,*`,*`,*`,*`,int,*`,*`,*`,long)))))->(int)
(	O
ent	*(struct(*(struct(*(struct`),long,*(char),int,int,int,int,int,int,*(struct`))),long,*(char),int,int,int,int,int,int,*(struct(int,int,long,*(char),*(struct`),*(struct`),*(struct`),*(struct`),int,*(long),*(struct`),*(struct`),long))))
)	O
;	O
if	O
(	O
(	O
result	int
)	O
!=	O
(	O
success	int
)	O
)	O
{	O
pkt_set_skey_len	O
(	O
respkt	*(int)
,	O
recon_this_key	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
key_str	*(char)
,	O
0	int
,	O
0x100	int
)	O
)	O
;	O
return	O
result	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
pkt_match_type	O
(	O
opkt	*(int)
)	O
)	O
==	O
(	O
pastend	O
)	O
)	O
&&	O
(	O
!	O
(	O
end_of_chain_P	O
(	O
blk	*(char)
)	O
)	O
)	O
)	O
{	O
pkt_set_skey_len	O
(	O
respkt	*(int)
,	O
recon_this_key	(*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
key_str	*(char)
,	O
0	int
,	O
0x100	int
)	O
)	O
;	O
return	O
notpres	O
;	O
}	O
else	O
{	O
pkt_set_skey_len	O
(	O
respkt	*(int)
,	O
0	int
)	O
;	O
return	O
success	int
;	O
}	O
}	O
}	O
int	O
scan_loop	(*(char),int,*(int),*(int),*(()->(int)),*(long),*(int),*(char),int,*(char),int)->(int)
(	O
unsigned	O
char	O
*	O
blk	*(char)
,	O
int	O
operation	int
,	O
int	O
*	O
pkt	*(int)
,	O
int	O
*	O
opkt	*(int)
,	O
int_function	*(()->(int))
func	*(()->(int))
,	O
long	O
*	O
long_tab	*(long)
,	O
int	O
*	O
respkt	*(int)
,	O
unsigned	O
char	O
*	O
ckstr	*(char)
,	O
int	O
clen	int
,	O
unsigned	O
char	O
*	O
vstr	*(char)
,	O
int	O
blksize	int
)	O
{	O
L_scan_loop	O
:	O
if	O
(	O
(	O
pkt_match_pos	O
(	O
opkt	*(int)
)	O
)	O
>	O
(	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
)	O
{	O
int	O
old_bend	int
=	O
blk_end	O
(	O
blk	*(char)
)	O
;	O
int	O
next_pos	int
=	O
next_cnvpair	O
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
;	O
int	O
result	int
=	O
success	int
;	O
if	O
(	O
func	*(()->(int))
)	O
{	O
int	O
vpos	int
=	O
next_field	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
)	O
;	O
int	O
vlen	int
=	O
field_len	O
(	O
blk	*(char)
,	O
vpos	int
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
(	O
vpos	int
)	O
+	O
1	int
,	O
(	O
vpos	int
)	O
+	O
(	O
vlen	int
)	O
+	O
1	int
,	O
vstr	*(char)
,	O
0	int
)	O
;	O
result	int
=	O
func	*(()->(int))
(	O
ckstr	*(char)
,	O
clen	int
,	O
vstr	*(char)
,	O
vlen	int
,	O
long_tab	*(long)
)	O
;	O
}	O
if	O
(	O
(	O
result	int
)	O
>=	O
(	O
success	int
)	O
)	O
{	O
if	O
(	O
(	O
operation	int
)	O
==	O
(	O
rem_scan	O
)	O
)	O
{	O
blk_remove_key_and_val	(*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
blksize	int
)	O
;	O
pkt_set_skey_count	O
(	O
respkt	*(int)
,	O
(	O
pkt_skey_count	O
(	O
respkt	*(int)
)	O
)	O
+	O
1	int
)	O
;	O
rem_ct	long
=	O
0x1L	int
+	O
(	O
rem_ct	long
)	O
;	O
if	O
(	O
(	O
pkt_match_pos	O
(	O
opkt	*(int)
)	O
)	O
==	O
(	O
next_pos	int
)	O
)	O
{	O
pkt_set_match_pos	O
(	O
opkt	*(int)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
)	O
;	O
}	O
else	O
pkt_set_match_pos	O
(	O
opkt	*(int)
,	O
(	O
pkt_match_pos	O
(	O
opkt	*(int)
)	O
)	O
-	O
(	O
(	O
old_bend	int
)	O
-	O
(	O
blk_end	O
(	O
blk	*(char)
)	O
)	O
)	O
)	O
;	O
next_pos	int
=	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
;	O
}	O
else	O
if	O
(	O
(	O
operation	int
)	O
==	O
(	O
count_scan	int
)	O
)	O
{	O
pkt_set_skey_count	O
(	O
respkt	*(int)
,	O
(	O
pkt_skey_count	O
(	O
respkt	*(int)
)	O
)	O
+	O
1	int
)	O
;	O
pkt_set_match_pos	O
(	O
pkt	*(int)
,	O
next_pos	int
)	O
;	O
}	O
else	O
if	O
(	O
blk_change_existing_value	(*(char),int,*(char),int,*(char),int,int)->(int)
(	O
blk	*(char)
,	O
pkt_match_pos	O
(	O
pkt	*(int)
)	O
,	O
ckstr	*(char)
,	O
clen	int
,	O
vstr	*(char)
,	O
result	int
,	O
blksize	int
)	O
)	O
{	O
pkt_set_skey_count	O
(	O
respkt	*(int)
,	O
(	O
pkt_skey_count	O
(	O
respkt	*(int)
)	O
)	O
+	O
1	int
)	O
;	O
next_pos	int
=	O
(	O
next_pos	int
)	O
-	O
(	O
(	O
old_bend	int
)	O
-	O
(	O
blk_end	O
(	O
blk	*(char)
)	O
)	O
)	O
;	O
pkt_set_match_pos	O
(	O
opkt	*(int)
,	O
(	O
pkt_match_pos	O
(	O
opkt	*(int)
)	O
)	O
-	O
(	O
(	O
old_bend	int
)	O
-	O
(	O
blk_end	O
(	O
blk	*(char)
)	O
)	O
)	O
)	O
;	O
pkt_set_match_pos	O
(	O
pkt	*(int)
,	O
next_pos	int
)	O
;	O
result	int
=	O
success	int
;	O
}	O
else	O
dprintf	(int,*(char))->(int)
(	O
(	O
diagout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: hit modify special case\n"	*(char)
,	O
"scan_loop"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
result	int
)	O
==	O
(	O
notpres	O
)	O
)	O
pkt_set_match_pos	O
(	O
pkt	*(int)
,	O
next_pos	int
)	O
;	O
if	O
(	O
(	O
(	O
result	int
)	O
==	O
(	O
success	int
)	O
)	O
||	O
(	O
(	O
result	int
)	O
==	O
(	O
notpres	O
)	O
)	O
)	O
{	O
if	O
(	O
func	*(()->(int))
)	O
{	O
clen	int
=	O
(	O
field_len	O
(	O
blk	*(char)
,	O
next_pos	int
)	O
)	O
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
next_pos	int
)	O
)	O
)	O
;	O
subbytes_move	O
(	O
blk	*(char)
,	O
(	O
next_pos	int
)	O
+	O
2	int
,	O
(	O
next_pos	int
)	O
+	O
2	int
+	O
(	O
field_len	O
(	O
blk	*(char)
,	O
1	int
+	O
(	O
next_pos	int
)	O
)	O
)	O
,	O
ckstr	*(char)
,	O
field_len	O
(	O
blk	*(char)
,	O
next_pos	int
)	O
)	O
;	O
}	O
goto	O
L_scan_loop	O
;	O
}	O
else	O
return	O
result	int
;	O
}	O
else	O
return	O
success	int
;	O
}	O
