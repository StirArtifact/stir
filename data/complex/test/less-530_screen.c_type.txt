static	O
char	O
*	O
sc_pad	*(char)
,	O
*	O
sc_home	*(char)
,	O
*	O
sc_addline	*(char)
,	O
*	O
sc_lower_left	*(char)
,	O
*	O
sc_return	*(char)
,	O
*	O
sc_move	*(char)
,	O
*	O
sc_clear	*(char)
,	O
*	O
sc_eol_clear	*(char)
,	O
*	O
sc_eos_clear	*(char)
,	O
*	O
sc_s_in	*(char)
,	O
*	O
sc_s_out	*(char)
,	O
*	O
sc_u_in	*(char)
,	O
*	O
sc_u_out	*(char)
,	O
*	O
sc_b_in	*(char)
,	O
*	O
sc_b_out	*(char)
,	O
*	O
sc_bl_in	*(char)
,	O
*	O
sc_bl_out	*(char)
,	O
*	O
sc_visual_bell	*(char)
,	O
*	O
sc_backspace	*(char)
,	O
*	O
sc_s_keypad	*(char)
,	O
*	O
sc_e_keypad	*(char)
,	O
*	O
sc_init	*(char)
,	O
*	O
sc_deinit	*(char)
;	O
static	O
int	O
init_done	int
=	O
0	int
;	O
public	O
int	O
auto_wrap	int
;	O
public	O
int	O
ignaw	int
;	O
public	O
int	O
erase_char	int
;	O
public	O
int	O
erase2_char	int
;	O
public	O
int	O
kill_char	int
;	O
public	O
int	O
werase_char	int
;	O
public	O
int	O
sc_width	int
,	O
sc_height	int
;	O
public	O
int	O
bo_s_width	int
,	O
bo_e_width	int
;	O
public	O
int	O
ul_s_width	int
,	O
ul_e_width	int
;	O
public	O
int	O
so_s_width	int
,	O
so_e_width	int
;	O
public	O
int	O
bl_s_width	int
,	O
bl_e_width	int
;	O
public	O
int	O
above_mem	int
,	O
below_mem	int
;	O
public	O
int	O
can_goto_line	int
;	O
public	O
int	O
clear_bg	int
;	O
public	O
int	O
missing_cap	int
=	O
0	int
;	O
public	O
char	O
*	O
kent	*(char)
=	O
NULL	O
;	O
static	O
int	O
attrmode	int
=	O
AT_NORMAL	O
;	O
extern	O
int	O
binattr	int
;	O
extern	O
int	O
line_count	int
;	O
static	O
char	O
*	O
cheaper	()->(*(char))
(	O
)	O
;	O
static	O
void	O
tmodes	()->(void)
(	O
)	O
;	O
extern	O
int	O
quiet	int
;	O
extern	O
int	O
no_back_scroll	int
;	O
extern	O
int	O
swindow	int
;	O
extern	O
int	O
no_init	int
;	O
extern	O
int	O
no_keypad	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
wscroll	int
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
tty	int
;	O
extern	O
int	O
top_scroll	int
;	O
extern	O
int	O
quit_if_one_screen	int
;	O
extern	O
int	O
oldbot	int
;	O
extern	O
int	O
hilite_search	int
;	O
extern	O
char	O
*	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
)	O
;	O
extern	O
char	O
*	O
tgoto	(*(char),int,int)->(*(char))
(	O
)	O
;	O
public	O
void	O
raw_mode	(int)->(void)
(	O
on	int
)	O
int	O
on	int
;	O
{	O
static	O
int	O
curr_on	int
=	O
0	int
;	O
if	O
(	O
on	int
==	O
curr_on	int
)	O
return	O
;	O
erase2_char	int
=	O
'\b'	O
;	O
{	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
s	*(char)
;	O
static	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
save_term	struct(int,int,int,int,char,array(char),int,int)
;	O
static	O
int	O
saved_term	int
=	O
0	int
;	O
if	O
(	O
on	int
)	O
{	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
tty	int
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
saved_term	int
)	O
{	O
save_term	struct(int,int,int,int,char,array(char),int,int)
=	O
s	*(char)
;	O
saved_term	int
=	O
1	int
;	O
}	O
switch	O
(	O
cfgetospeed	(*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
&	O
s	*(char)
)	O
)	O
{	O
case	O
B0	int
:	O
ospeed	short
=	O
0	int
;	O
break	O
;	O
case	O
B50	int
:	O
ospeed	short
=	O
1	int
;	O
break	O
;	O
case	O
B75	int
:	O
ospeed	short
=	O
2	int
;	O
break	O
;	O
case	O
B110	int
:	O
ospeed	short
=	O
3	int
;	O
break	O
;	O
case	O
B134	int
:	O
ospeed	short
=	O
4	int
;	O
break	O
;	O
case	O
B150	int
:	O
ospeed	short
=	O
5	int
;	O
break	O
;	O
case	O
B200	int
:	O
ospeed	short
=	O
6	int
;	O
break	O
;	O
case	O
B300	int
:	O
ospeed	short
=	O
7	int
;	O
break	O
;	O
case	O
B600	int
:	O
ospeed	short
=	O
8	int
;	O
break	O
;	O
case	O
B1200	int
:	O
ospeed	short
=	O
9	int
;	O
break	O
;	O
case	O
B1800	int
:	O
ospeed	short
=	O
10	int
;	O
break	O
;	O
case	O
B2400	int
:	O
ospeed	short
=	O
11	int
;	O
break	O
;	O
case	O
B4800	int
:	O
ospeed	short
=	O
12	int
;	O
break	O
;	O
case	O
B9600	int
:	O
ospeed	short
=	O
13	int
;	O
break	O
;	O
case	O
EXTA	O
:	O
ospeed	short
=	O
14	int
;	O
break	O
;	O
case	O
EXTB	O
:	O
ospeed	short
=	O
15	int
;	O
break	O
;	O
case	O
B57600	int
:	O
ospeed	short
=	O
16	int
;	O
break	O
;	O
case	O
B115200	int
:	O
ospeed	short
=	O
17	int
;	O
break	O
;	O
default	O
:	O
;	O
}	O
erase_char	int
=	O
s	*(char)
.	O
c_cc	array(char)
[	O
VERASE	int
]	O
;	O
kill_char	int
=	O
s	*(char)
.	O
c_cc	array(char)
[	O
VKILL	int
]	O
;	O
werase_char	int
=	O
s	*(char)
.	O
c_cc	array(char)
[	O
VWERASE	int
]	O
;	O
s	*(char)
.	O
c_lflag	short
&=	O
~	O
(	O
0	int
|	O
ICANON	int
|	O
ECHO	int
|	O
ECHOE	int
|	O
ECHOK	int
|	O
ECHONL	int
)	O
;	O
s	*(char)
.	O
c_oflag	short
|=	O
(	O
0	int
|	O
TAB3	int
|	O
OPOST	int
|	O
ONLCR	int
)	O
;	O
s	*(char)
.	O
c_oflag	short
&=	O
~	O
(	O
0	int
|	O
OCRNL	int
|	O
ONOCR	int
|	O
ONLRET	int
)	O
;	O
s	*(char)
.	O
c_cc	array(char)
[	O
VMIN	int
]	O
=	O
1	int
;	O
s	*(char)
.	O
c_cc	array(char)
[	O
VTIME	int
]	O
=	O
0	int
;	O
s	*(char)
.	O
c_cc	array(char)
[	O
VLNEXT	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
s	*(char)
=	O
save_term	struct(int,int,int,int,char,array(char),int,int)
;	O
}	O
fsync	(int)->(int)
(	O
tty	int
)	O
;	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
tty	int
,	O
TCSADRAIN	int
,	O
&	O
s	*(char)
)	O
;	O
}	O
curr_on	int
=	O
on	int
;	O
}	O
static	O
int	O
hardcopy	int
;	O
static	O
char	O
*	O
ltget_env	(*(char))->(*(char))
(	O
capname	*(char)
)	O
char	O
*	O
capname	*(char)
;	O
{	O
char	O
name	*(char)
[	O
16	int
]	O
;	O
char	O
*	O
s	*(char)
;	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LESS_TERMCAP_DEBUG"	*(char)
)	O
;	O
if	O
(	O
s	*(char)
!=	O
NULL	O
&&	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
struct	O
env	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
{	O
struct	O
env	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
next	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
value	*(char)
;	O
}	O
;	O
static	O
struct	O
env	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
envs	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
NULL	O
;	O
struct	O
env	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
envs	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
p	*(char)
!=	O
NULL	O
;	O
p	*(char)
=	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(char)
->	O
name	*(char)
,	O
capname	*(char)
)	O
==	O
0	int
)	O
return	O
p	*(char)
->	O
value	*(char)
;	O
p	*(char)
=	O
(	O
struct	O
env	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
struct	O
env	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
)	O
)	O
;	O
p	*(char)
->	O
name	*(char)
=	O
save	(*(char))->(*(char))
(	O
capname	*(char)
)	O
;	O
p	*(char)
->	O
value	*(char)
=	O
(	O
char	O
*	O
)	O
ecalloc	(int,int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
capname	*(char)
)	O
+	O
3	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(char)
->	O
value	*(char)
,	O
"<%s>"	*(char)
,	O
capname	*(char)
)	O
;	O
p	*(char)
->	O
next	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
envs	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
envs	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
p	*(char)
;	O
return	O
p	*(char)
->	O
value	*(char)
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
"LESS_TERMCAP_"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
capname	*(char)
)	O
;	O
return	O
(	O
lgetenv	(*(char))->(*(char))
(	O
name	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
ltgetflag	(*(char))->(int)
(	O
capname	*(char)
)	O
char	O
*	O
capname	*(char)
;	O
{	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
(	O
s	*(char)
=	O
ltget_env	(*(char))->(*(char))
(	O
capname	*(char)
)	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
&&	O
*	O
s	*(char)
!=	O
'0'	O
)	O
;	O
if	O
(	O
hardcopy	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
tgetflag	(*(char))->(int)
(	O
capname	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
ltgetnum	(*(char))->(int)
(	O
capname	*(char)
)	O
char	O
*	O
capname	*(char)
;	O
{	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
(	O
s	*(char)
=	O
ltget_env	(*(char))->(*(char))
(	O
capname	*(char)
)	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
atoi	(*(char))->(int)
(	O
s	*(char)
)	O
)	O
;	O
if	O
(	O
hardcopy	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
return	O
(	O
tgetnum	(*(char))->(int)
(	O
capname	*(char)
)	O
)	O
;	O
}	O
static	O
char	O
*	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
capname	*(char)
,	O
pp	*(*(char))
)	O
char	O
*	O
capname	*(char)
;	O
char	O
*	O
*	O
pp	*(*(char))
;	O
{	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
(	O
s	*(char)
=	O
ltget_env	(*(char))->(*(char))
(	O
capname	*(char)
)	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
s	*(char)
)	O
;	O
if	O
(	O
hardcopy	int
)	O
return	O
(	O
NULL	O
)	O
;	O
return	O
(	O
tgetstr	(*(char),*(*(char)))->(*(char))
(	O
capname	*(char)
,	O
pp	*(*(char))
)	O
)	O
;	O
}	O
public	O
void	O
scrsize	()->(void)
(	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
int	O
sys_height	int
;	O
int	O
sys_width	int
;	O
int	O
n	int
;	O
sys_width	int
=	O
sys_height	int
=	O
0	int
;	O
{	O
struct	O
winsize	struct(short,short,short,short)
w	struct(short,short,short,short)
;	O
if	O
(	O
ioctl	(int,long)->(int)
(	O
2	int
,	O
TIOCGWINSZ	int
,	O
&	O
w	struct(short,short,short,short)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
w	struct(short,short,short,short)
.	O
ws_row	short
>	O
0	int
)	O
sys_height	int
=	O
w	struct(short,short,short,short)
.	O
ws_row	short
;	O
if	O
(	O
w	struct(short,short,short,short)
.	O
ws_col	short
>	O
0	int
)	O
sys_width	int
=	O
w	struct(short,short,short,short)
.	O
ws_col	short
;	O
}	O
}	O
if	O
(	O
sys_height	int
>	O
0	int
)	O
sc_height	int
=	O
sys_height	int
;	O
else	O
if	O
(	O
(	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"LINES"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
sc_height	int
=	O
atoi	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
else	O
if	O
(	O
(	O
n	int
=	O
ltgetnum	(*(char))->(int)
(	O
"li"	*(char)
)	O
)	O
>	O
0	int
)	O
sc_height	int
=	O
n	int
;	O
if	O
(	O
sc_height	int
<=	O
0	int
)	O
sc_height	int
=	O
DEF_SC_HEIGHT	int
;	O
if	O
(	O
sys_width	int
>	O
0	int
)	O
sc_width	int
=	O
sys_width	int
;	O
else	O
if	O
(	O
(	O
s	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"COLUMNS"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
sc_width	int
=	O
atoi	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
else	O
if	O
(	O
(	O
n	int
=	O
ltgetnum	(*(char))->(int)
(	O
"co"	*(char)
)	O
)	O
>	O
0	int
)	O
sc_width	int
=	O
n	int
;	O
if	O
(	O
sc_width	int
<=	O
0	int
)	O
sc_width	int
=	O
DEF_SC_WIDTH	int
;	O
}	O
public	O
char	O
*	O
special_key_str	(int)->(*(char))
(	O
key	int
)	O
int	O
key	int
;	O
{	O
static	O
char	O
tbuf	array(char)
[	O
40	int
]	O
;	O
char	O
*	O
s	*(char)
;	O
char	O
*	O
sp	*(*(char))
=	O
tbuf	array(char)
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
SK_RIGHT_ARROW	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kr"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
break	O
;	O
case	O
SK_LEFT_ARROW	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kl"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
break	O
;	O
case	O
SK_UP_ARROW	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ku"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
break	O
;	O
case	O
SK_DOWN_ARROW	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kd"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
break	O
;	O
case	O
SK_PAGE_UP	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kP"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
break	O
;	O
case	O
SK_PAGE_DOWN	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kN"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
break	O
;	O
case	O
SK_HOME	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kh"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
break	O
;	O
case	O
SK_END	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"@7"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
break	O
;	O
case	O
SK_DELETE	int
:	O
s	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"kD"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
{	O
tbuf	array(char)
[	O
0	int
]	O
=	O
'\177'	O
;	O
tbuf	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
s	*(char)
=	O
tbuf	array(char)
;	O
}	O
break	O
;	O
case	O
SK_CONTROL_K	int
:	O
tbuf	array(char)
[	O
0	int
]	O
=	O
CONTROL	O
(	O
'K'	O
)	O
;	O
tbuf	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
s	*(char)
=	O
tbuf	array(char)
;	O
break	O
;	O
default	O
:	O
return	O
(	O
NULL	O
)	O
;	O
}	O
return	O
(	O
s	*(char)
)	O
;	O
}	O
public	O
void	O
get_term	()->(void)
(	O
)	O
{	O
char	O
*	O
sp	*(*(char))
;	O
char	O
*	O
t1	*(char)
,	O
*	O
t2	*(char)
;	O
char	O
*	O
term	*(char)
;	O
char	O
termbuf	array(char)
[	O
TERMBUF_SIZE	int
]	O
;	O
static	O
char	O
sbuf	array(char)
[	O
TERMSBUF_SIZE	int
]	O
;	O
if	O
(	O
(	O
term	*(char)
=	O
lgetenv	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
)	O
==	O
NULL	O
)	O
term	*(char)
=	O
DEFAULT_TERM	*(char)
;	O
hardcopy	int
=	O
0	int
;	O
if	O
(	O
tgetent	(*(char),*(char))->(int)
(	O
termbuf	array(char)
,	O
term	*(char)
)	O
!=	O
TGETENT_OK	int
)	O
hardcopy	int
=	O
1	int
;	O
if	O
(	O
ltgetflag	(*(char))->(int)
(	O
"hc"	*(char)
)	O
)	O
hardcopy	int
=	O
1	int
;	O
scrsize	()->(void)
(	O
)	O
;	O
pos_init	()->(void)
(	O
)	O
;	O
auto_wrap	int
=	O
ltgetflag	(*(char))->(int)
(	O
"am"	*(char)
)	O
;	O
ignaw	int
=	O
ltgetflag	(*(char))->(int)
(	O
"xn"	*(char)
)	O
;	O
above_mem	int
=	O
ltgetflag	(*(char))->(int)
(	O
"da"	*(char)
)	O
;	O
below_mem	int
=	O
ltgetflag	(*(char))->(int)
(	O
"db"	*(char)
)	O
;	O
clear_bg	int
=	O
ltgetflag	(*(char))->(int)
(	O
"ut"	*(char)
)	O
;	O
if	O
(	O
(	O
so_s_width	int
=	O
ltgetnum	(*(char))->(int)
(	O
"sg"	*(char)
)	O
)	O
<	O
0	int
)	O
so_s_width	int
=	O
0	int
;	O
so_e_width	int
=	O
so_s_width	int
;	O
bo_s_width	int
=	O
bo_e_width	int
=	O
so_s_width	int
;	O
ul_s_width	int
=	O
ul_e_width	int
=	O
so_s_width	int
;	O
bl_s_width	int
=	O
bl_e_width	int
=	O
so_s_width	int
;	O
if	O
(	O
so_s_width	int
>	O
0	int
||	O
so_e_width	int
>	O
0	int
)	O
hilite_search	int
=	O
0	int
;	O
sp	*(*(char))
=	O
sbuf	array(char)
;	O
sc_pad	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"pc"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_pad	*(char)
!=	O
NULL	O
)	O
PC	char
=	O
*	O
sc_pad	*(char)
;	O
sc_s_keypad	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ks"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_s_keypad	*(char)
==	O
NULL	O
)	O
sc_s_keypad	*(char)
=	O
""	*(char)
;	O
sc_e_keypad	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ke"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_e_keypad	*(char)
==	O
NULL	O
)	O
sc_e_keypad	*(char)
=	O
""	*(char)
;	O
kent	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"@8"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
sc_init	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ti"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_init	*(char)
==	O
NULL	O
)	O
sc_init	*(char)
=	O
""	*(char)
;	O
sc_deinit	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"te"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_deinit	*(char)
==	O
NULL	O
)	O
sc_deinit	*(char)
=	O
""	*(char)
;	O
sc_eol_clear	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ce"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_eol_clear	*(char)
==	O
NULL	O
||	O
*	O
sc_eol_clear	*(char)
==	O
'\0'	O
)	O
{	O
missing_cap	int
=	O
1	int
;	O
sc_eol_clear	*(char)
=	O
""	*(char)
;	O
}	O
sc_eos_clear	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"cd"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
below_mem	int
&&	O
(	O
sc_eos_clear	*(char)
==	O
NULL	O
||	O
*	O
sc_eos_clear	*(char)
==	O
'\0'	O
)	O
)	O
{	O
missing_cap	int
=	O
1	int
;	O
sc_eos_clear	*(char)
=	O
""	*(char)
;	O
}	O
sc_clear	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"cl"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_clear	*(char)
==	O
NULL	O
||	O
*	O
sc_clear	*(char)
==	O
'\0'	O
)	O
{	O
missing_cap	int
=	O
1	int
;	O
sc_clear	*(char)
=	O
"\n\n"	*(char)
;	O
}	O
sc_move	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"cm"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_move	*(char)
==	O
NULL	O
||	O
*	O
sc_move	*(char)
==	O
'\0'	O
)	O
{	O
sc_move	*(char)
=	O
""	*(char)
;	O
can_goto_line	int
=	O
0	int
;	O
}	O
else	O
can_goto_line	int
=	O
1	int
;	O
tmodes	()->(void)
(	O
"so"	*(char)
,	O
"se"	*(char)
,	O
&	O
sc_s_in	*(char)
,	O
&	O
sc_s_out	*(char)
,	O
""	*(char)
,	O
""	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
tmodes	()->(void)
(	O
"us"	*(char)
,	O
"ue"	*(char)
,	O
&	O
sc_u_in	*(char)
,	O
&	O
sc_u_out	*(char)
,	O
sc_s_in	*(char)
,	O
sc_s_out	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
tmodes	()->(void)
(	O
"md"	*(char)
,	O
"me"	*(char)
,	O
&	O
sc_b_in	*(char)
,	O
&	O
sc_b_out	*(char)
,	O
sc_s_in	*(char)
,	O
sc_s_out	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
tmodes	()->(void)
(	O
"mb"	*(char)
,	O
"me"	*(char)
,	O
&	O
sc_bl_in	*(char)
,	O
&	O
sc_bl_out	*(char)
,	O
sc_s_in	*(char)
,	O
sc_s_out	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
sc_visual_bell	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"vb"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_visual_bell	*(char)
==	O
NULL	O
)	O
sc_visual_bell	*(char)
=	O
""	*(char)
;	O
if	O
(	O
ltgetflag	(*(char))->(int)
(	O
"bs"	*(char)
)	O
)	O
sc_backspace	*(char)
=	O
"\b"	*(char)
;	O
else	O
{	O
sc_backspace	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"bc"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_backspace	*(char)
==	O
NULL	O
||	O
*	O
sc_backspace	*(char)
==	O
'\0'	O
)	O
sc_backspace	*(char)
=	O
"\b"	*(char)
;	O
}	O
t1	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ho"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
t1	*(char)
==	O
NULL	O
)	O
t1	*(char)
=	O
""	*(char)
;	O
if	O
(	O
*	O
sc_move	*(char)
==	O
'\0'	O
)	O
t2	*(char)
=	O
""	*(char)
;	O
else	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
sp	*(*(char))
,	O
tgoto	(*(char),int,int)->(*(char))
(	O
sc_move	*(char)
,	O
0	int
,	O
0	int
)	O
)	O
;	O
t2	*(char)
=	O
sp	*(*(char))
;	O
sp	*(*(char))
+=	O
strlen	(*(char))->(long)
(	O
sp	*(*(char))
)	O
+	O
1	int
;	O
}	O
sc_home	*(char)
=	O
cheaper	()->(*(char))
(	O
t1	*(char)
,	O
t2	*(char)
,	O
"|\b^"	*(char)
)	O
;	O
t1	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"ll"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
t1	*(char)
==	O
NULL	O
)	O
t1	*(char)
=	O
""	*(char)
;	O
if	O
(	O
*	O
sc_move	*(char)
==	O
'\0'	O
)	O
t2	*(char)
=	O
""	*(char)
;	O
else	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
sp	*(*(char))
,	O
tgoto	(*(char),int,int)->(*(char))
(	O
sc_move	*(char)
,	O
0	int
,	O
sc_height	int
-	O
1	int
)	O
)	O
;	O
t2	*(char)
=	O
sp	*(*(char))
;	O
sp	*(*(char))
+=	O
strlen	(*(char))->(long)
(	O
sp	*(*(char))
)	O
+	O
1	int
;	O
}	O
sc_lower_left	*(char)
=	O
cheaper	()->(*(char))
(	O
t1	*(char)
,	O
t2	*(char)
,	O
"\r"	*(char)
)	O
;	O
sc_return	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"cr"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
sc_return	*(char)
==	O
NULL	O
)	O
sc_return	*(char)
=	O
"\r"	*(char)
;	O
t1	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"al"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
t1	*(char)
==	O
NULL	O
)	O
t1	*(char)
=	O
""	*(char)
;	O
t2	*(char)
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"sr"	*(char)
,	O
&	O
sp	*(*(char))
)	O
;	O
if	O
(	O
t2	*(char)
==	O
NULL	O
)	O
t2	*(char)
=	O
""	*(char)
;	O
if	O
(	O
above_mem	int
)	O
sc_addline	*(char)
=	O
t1	*(char)
;	O
else	O
sc_addline	*(char)
=	O
cheaper	()->(*(char))
(	O
t1	*(char)
,	O
t2	*(char)
,	O
""	*(char)
)	O
;	O
if	O
(	O
*	O
sc_addline	*(char)
==	O
'\0'	O
)	O
{	O
no_back_scroll	int
=	O
1	int
;	O
}	O
}	O
static	O
int	O
costcount	int
;	O
static	O
int	O
inc_costcount	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
costcount	int
++	O
;	O
return	O
(	O
c	int
)	O
;	O
}	O
static	O
int	O
cost	(*(char))->(int)
(	O
t	*(char)
)	O
char	O
*	O
t	*(char)
;	O
{	O
costcount	int
=	O
0	int
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
t	*(char)
,	O
sc_height	int
,	O
inc_costcount	(int)->(int)
)	O
;	O
return	O
(	O
costcount	int
)	O
;	O
}	O
static	O
char	O
*	O
cheaper	()->(*(char))
(	O
t1	*(char)
,	O
t2	*(char)
,	O
def	*(char)
)	O
char	O
*	O
t1	*(char)
,	O
*	O
t2	*(char)
;	O
char	O
*	O
def	*(char)
;	O
{	O
if	O
(	O
*	O
t1	*(char)
==	O
'\0'	O
&&	O
*	O
t2	*(char)
==	O
'\0'	O
)	O
{	O
missing_cap	int
=	O
1	int
;	O
return	O
(	O
def	*(char)
)	O
;	O
}	O
if	O
(	O
*	O
t1	*(char)
==	O
'\0'	O
)	O
return	O
(	O
t2	*(char)
)	O
;	O
if	O
(	O
*	O
t2	*(char)
==	O
'\0'	O
)	O
return	O
(	O
t1	*(char)
)	O
;	O
if	O
(	O
cost	(*(char))->(int)
(	O
t1	*(char)
)	O
<	O
cost	(*(char))->(int)
(	O
t2	*(char)
)	O
)	O
return	O
(	O
t1	*(char)
)	O
;	O
return	O
(	O
t2	*(char)
)	O
;	O
}	O
static	O
void	O
tmodes	()->(void)
(	O
incap	*(char)
,	O
outcap	*(char)
,	O
instr	*(*(char))
,	O
outstr	*(*(char))
,	O
def_instr	*(char)
,	O
def_outstr	*(char)
,	O
spp	*(*(char))
)	O
char	O
*	O
incap	*(char)
;	O
char	O
*	O
outcap	*(char)
;	O
char	O
*	O
*	O
instr	*(*(char))
;	O
char	O
*	O
*	O
outstr	*(*(char))
;	O
char	O
*	O
def_instr	*(char)
;	O
char	O
*	O
def_outstr	*(char)
;	O
char	O
*	O
*	O
spp	*(*(char))
;	O
{	O
*	O
instr	*(*(char))
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
incap	*(char)
,	O
spp	*(*(char))
)	O
;	O
if	O
(	O
*	O
instr	*(*(char))
==	O
NULL	O
)	O
{	O
*	O
instr	*(*(char))
=	O
def_instr	*(char)
;	O
*	O
outstr	*(*(char))
=	O
def_outstr	*(char)
;	O
return	O
;	O
}	O
*	O
outstr	*(*(char))
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
outcap	*(char)
,	O
spp	*(*(char))
)	O
;	O
if	O
(	O
*	O
outstr	*(*(char))
==	O
NULL	O
)	O
*	O
outstr	*(*(char))
=	O
ltgetstr	(*(char),*(*(char)))->(*(char))
(	O
"me"	*(char)
,	O
spp	*(*(char))
)	O
;	O
if	O
(	O
*	O
outstr	*(*(char))
==	O
NULL	O
)	O
*	O
outstr	*(*(char))
=	O
""	*(char)
;	O
}	O
public	O
void	O
init	()->(void)
(	O
)	O
{	O
if	O
(	O
quit_if_one_screen	int
&&	O
line_count	int
>=	O
sc_height	int
)	O
quit_if_one_screen	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
no_init	int
&&	O
!	O
quit_if_one_screen	int
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_init	*(char)
,	O
sc_height	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
!	O
no_keypad	int
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_s_keypad	*(char)
,	O
sc_height	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
top_scroll	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
sc_height	int
;	O
i	int
++	O
)	O
putchr	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
else	O
line_left	()->(void)
(	O
)	O
;	O
init_done	int
=	O
1	int
;	O
}	O
public	O
void	O
deinit	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
init_done	int
)	O
return	O
;	O
if	O
(	O
!	O
no_keypad	int
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_e_keypad	*(char)
,	O
sc_height	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
!	O
no_init	int
&&	O
!	O
quit_if_one_screen	int
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_deinit	*(char)
,	O
sc_height	int
,	O
putchr	(int)->(int)
)	O
;	O
init_done	int
=	O
0	int
;	O
}	O
public	O
void	O
home	()->(void)
(	O
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_home	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
public	O
void	O
add_line	()->(void)
(	O
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_addline	*(char)
,	O
sc_height	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
public	O
void	O
lower_left	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
init_done	int
)	O
return	O
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_lower_left	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
public	O
void	O
line_left	()->(void)
(	O
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_return	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
public	O
void	O
check_winch	()->(void)
(	O
)	O
{	O
}	O
public	O
void	O
goto_line	(int)->(void)
(	O
sindex	int
)	O
int	O
sindex	int
;	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
tgoto	(*(char),int,int)->(*(char))
(	O
sc_move	*(char)
,	O
0	int
,	O
sindex	int
)	O
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
public	O
void	O
vbell	()->(void)
(	O
)	O
{	O
if	O
(	O
*	O
sc_visual_bell	*(char)
==	O
'\0'	O
)	O
return	O
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_visual_bell	*(char)
,	O
sc_height	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
static	O
void	O
beep	()->(void)
(	O
)	O
{	O
putchr	(int)->(int)
(	O
CONTROL	O
(	O
'G'	O
)	O
)	O
;	O
}	O
public	O
void	O
bell	()->(void)
(	O
)	O
{	O
if	O
(	O
quiet	int
==	O
VERY_QUIET	int
)	O
vbell	()->(void)
(	O
)	O
;	O
else	O
beep	()->(void)
(	O
)	O
;	O
}	O
public	O
void	O
clear	()->(void)
(	O
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_clear	*(char)
,	O
sc_height	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
public	O
void	O
clear_eol	()->(void)
(	O
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_eol_clear	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
static	O
void	O
clear_eol_bot	()->(void)
(	O
)	O
{	O
if	O
(	O
below_mem	int
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_eos_clear	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
else	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_eol_clear	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
public	O
void	O
clear_bot	()->(void)
(	O
)	O
{	O
if	O
(	O
oldbot	int
)	O
lower_left	()->(void)
(	O
)	O
;	O
else	O
line_left	()->(void)
(	O
)	O
;	O
if	O
(	O
attrmode	int
==	O
AT_NORMAL	O
)	O
clear_eol_bot	()->(void)
(	O
)	O
;	O
else	O
{	O
int	O
saved_attrmode	int
=	O
attrmode	int
;	O
at_exit	()->(void)
(	O
)	O
;	O
clear_eol_bot	()->(void)
(	O
)	O
;	O
at_enter	(int)->(void)
(	O
saved_attrmode	int
)	O
;	O
}	O
}	O
public	O
void	O
at_enter	(int)->(void)
(	O
attr	int
)	O
int	O
attr	int
;	O
{	O
attr	int
=	O
apply_at_specials	(int)->(int)
(	O
attr	int
)	O
;	O
if	O
(	O
attr	int
&	O
AT_UNDERLINE	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_u_in	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
attr	int
&	O
AT_BOLD	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_b_in	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
attr	int
&	O
AT_BLINK	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_bl_in	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
attr	int
&	O
AT_STANDOUT	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_s_in	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
attrmode	int
=	O
attr	int
;	O
}	O
public	O
void	O
at_exit	()->(void)
(	O
)	O
{	O
if	O
(	O
attrmode	int
&	O
AT_STANDOUT	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_s_out	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
attrmode	int
&	O
AT_BLINK	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_bl_out	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
attrmode	int
&	O
AT_BOLD	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_b_out	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
if	O
(	O
attrmode	int
&	O
AT_UNDERLINE	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_u_out	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
attrmode	int
=	O
AT_NORMAL	O
;	O
}	O
public	O
void	O
at_switch	(int)->(void)
(	O
attr	int
)	O
int	O
attr	int
;	O
{	O
int	O
new_attrmode	int
=	O
apply_at_specials	(int)->(int)
(	O
attr	int
)	O
;	O
int	O
ignore_modes	int
=	O
AT_ANSI	O
;	O
if	O
(	O
(	O
new_attrmode	int
&	O
~	O
ignore_modes	int
)	O
!=	O
(	O
attrmode	int
&	O
~	O
ignore_modes	int
)	O
)	O
{	O
at_exit	()->(void)
(	O
)	O
;	O
at_enter	(int)->(void)
(	O
attr	int
)	O
;	O
}	O
}	O
public	O
int	O
is_at_equiv	(int,int)->(int)
(	O
attr1	int
,	O
attr2	int
)	O
int	O
attr1	int
;	O
int	O
attr2	int
;	O
{	O
attr1	int
=	O
apply_at_specials	(int)->(int)
(	O
attr1	int
)	O
;	O
attr2	int
=	O
apply_at_specials	(int)->(int)
(	O
attr2	int
)	O
;	O
return	O
(	O
attr1	int
==	O
attr2	int
)	O
;	O
}	O
public	O
int	O
apply_at_specials	(int)->(int)
(	O
attr	int
)	O
int	O
attr	int
;	O
{	O
if	O
(	O
attr	int
&	O
AT_BINARY	O
)	O
attr	int
|=	O
binattr	int
;	O
if	O
(	O
attr	int
&	O
AT_HILITE	O
)	O
attr	int
|=	O
AT_STANDOUT	O
;	O
attr	int
&=	O
~	O
(	O
AT_BINARY	O
|	O
AT_HILITE	O
)	O
;	O
return	O
attr	int
;	O
}	O
public	O
void	O
putbs	()->(void)
(	O
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
sc_backspace	*(char)
,	O
1	int
,	O
putchr	(int)->(int)
)	O
;	O
}	O
