static	O
char	O
*	O
codeset	array(*(char))
[	O
]	O
=	O
{	O
"212222"	*(char)
,	O
"222122"	*(char)
,	O
"222221"	*(char)
,	O
"121223"	*(char)
,	O
"121322"	*(char)
,	O
"131222"	*(char)
,	O
"122213"	*(char)
,	O
"122312"	*(char)
,	O
"132212"	*(char)
,	O
"221213"	*(char)
,	O
"221312"	*(char)
,	O
"231212"	*(char)
,	O
"112232"	*(char)
,	O
"122132"	*(char)
,	O
"122231"	*(char)
,	O
"113222"	*(char)
,	O
"123122"	*(char)
,	O
"123221"	*(char)
,	O
"223211"	*(char)
,	O
"221132"	*(char)
,	O
"221231"	*(char)
,	O
"213212"	*(char)
,	O
"223112"	*(char)
,	O
"312131"	*(char)
,	O
"311222"	*(char)
,	O
"321122"	*(char)
,	O
"321221"	*(char)
,	O
"312212"	*(char)
,	O
"322112"	*(char)
,	O
"322211"	*(char)
,	O
"212123"	*(char)
,	O
"212321"	*(char)
,	O
"232121"	*(char)
,	O
"111323"	*(char)
,	O
"131123"	*(char)
,	O
"131321"	*(char)
,	O
"112313"	*(char)
,	O
"132113"	*(char)
,	O
"132311"	*(char)
,	O
"211313"	*(char)
,	O
"231113"	*(char)
,	O
"231311"	*(char)
,	O
"112133"	*(char)
,	O
"112331"	*(char)
,	O
"132131"	*(char)
,	O
"113123"	*(char)
,	O
"113321"	*(char)
,	O
"133121"	*(char)
,	O
"313121"	*(char)
,	O
"211331"	*(char)
,	O
"231131"	*(char)
,	O
"213113"	*(char)
,	O
"213311"	*(char)
,	O
"213131"	*(char)
,	O
"311123"	*(char)
,	O
"311321"	*(char)
,	O
"331121"	*(char)
,	O
"312113"	*(char)
,	O
"312311"	*(char)
,	O
"332111"	*(char)
,	O
"314111"	*(char)
,	O
"221411"	*(char)
,	O
"431111"	*(char)
,	O
"111224"	*(char)
,	O
"111422"	*(char)
,	O
"121124"	*(char)
,	O
"121421"	*(char)
,	O
"141122"	*(char)
,	O
"141221"	*(char)
,	O
"112214"	*(char)
,	O
"112412"	*(char)
,	O
"122114"	*(char)
,	O
"122411"	*(char)
,	O
"142112"	*(char)
,	O
"142211"	*(char)
,	O
"241211"	*(char)
,	O
"221114"	*(char)
,	O
"413111"	*(char)
,	O
"241112"	*(char)
,	O
"134111"	*(char)
,	O
"111242"	*(char)
,	O
"121142"	*(char)
,	O
"121241"	*(char)
,	O
"114212"	*(char)
,	O
"124112"	*(char)
,	O
"124211"	*(char)
,	O
"411212"	*(char)
,	O
"421112"	*(char)
,	O
"421211"	*(char)
,	O
"212141"	*(char)
,	O
"214121"	*(char)
,	O
"412121"	*(char)
,	O
"111143"	*(char)
,	O
"111341"	*(char)
,	O
"131141"	*(char)
,	O
"114113"	*(char)
,	O
"114311"	*(char)
,	O
"411113"	*(char)
,	O
"411311"	*(char)
,	O
"113141"	*(char)
,	O
"114131"	*(char)
,	O
"311141"	*(char)
,	O
"411131"	*(char)
,	O
"b1a4a2"	*(char)
,	O
"b1a2a4"	*(char)
,	O
"b1a2c2"	*(char)
,	O
"b3c1a1b"	*(char)
}	O
;	O
int	O
Barcode_128b_verify	(*(char))->(int)
(	O
char	O
*	O
text	*(char)
)	O
{	O
if	O
(	O
text	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
while	O
(	O
*	O
text	*(char)
&&	O
*	O
text	*(char)
>=	O
32	int
&&	O
!	O
(	O
*	O
text	*(char)
&	O
0x80	int
)	O
)	O
text	*(char)
++	O
;	O
if	O
(	O
*	O
text	*(char)
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_128b_encode	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)))->(int)
(	O
struct	O
Barcode_Item	struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)
*	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
)	O
{	O
static	O
char	O
*	O
text	*(char)
;	O
static	O
char	O
*	O
partial	*(char)
;	O
static	O
char	O
*	O
textinfo	*(char)
;	O
char	O
*	O
textptr	*(char)
;	O
int	O
i	int
,	O
code	int
,	O
textpos	int
,	O
checksum	int
=	O
0	int
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
)	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
"code 128-B"	*(char)
)	O
;	O
text	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
;	O
if	O
(	O
!	O
text	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
partial	*(char)
=	O
malloc	(long)->(*(void))
(	O
(	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
4	int
)	O
*	O
6	int
+	O
2	int
)	O
;	O
if	O
(	O
!	O
partial	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
return	O
-	O
1	int
;	O
}	O
textinfo	*(char)
=	O
malloc	(long)->(*(void))
(	O
10	int
*	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
2	int
)	O
;	O
if	O
(	O
!	O
textinfo	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
"0"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
START_B	int
]	O
)	O
;	O
checksum	int
+=	O
START_B	int
;	O
textptr	*(char)
=	O
textinfo	*(char)
;	O
textpos	int
=	O
SYMBOL_WID	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
text	*(char)
[	O
i	int
]	O
<	O
32	int
||	O
(	O
text	*(char)
[	O
i	int
]	O
&	O
0x80	int
)	O
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
textinfo	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
code	int
=	O
text	*(char)
[	O
i	int
]	O
-	O
32	int
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
code	int
]	O
)	O
;	O
checksum	int
+=	O
code	int
*	O
(	O
i	int
+	O
1	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
textptr	*(char)
,	O
"%i:12:%c "	*(char)
,	O
textpos	int
,	O
text	*(char)
[	O
i	int
]	O
)	O
;	O
textptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
textptr	*(char)
)	O
;	O
textpos	int
+=	O
SYMBOL_WID	int
;	O
}	O
checksum	int
%=	O
103	int
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
checksum	int
]	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
STOP	int
]	O
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
partial	*(char)
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
textinfo	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_128c_verify	(*(char))->(int)
(	O
char	O
*	O
text	*(char)
)	O
{	O
if	O
(	O
text	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
%	O
2	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
;	O
*	O
text	*(char)
;	O
text	*(char)
++	O
)	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
text	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_128c_encode	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)))->(int)
(	O
struct	O
Barcode_Item	struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)
*	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
)	O
{	O
static	O
char	O
*	O
text	*(char)
;	O
static	O
char	O
*	O
partial	*(char)
;	O
static	O
char	O
*	O
textinfo	*(char)
;	O
char	O
*	O
textptr	*(char)
;	O
int	O
i	int
,	O
code	int
,	O
textpos	int
,	O
checksum	int
=	O
0	int
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
)	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
"code 128-C"	*(char)
)	O
;	O
text	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
;	O
if	O
(	O
!	O
text	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
partial	*(char)
=	O
malloc	(long)->(*(void))
(	O
(	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
3	int
)	O
*	O
6	int
+	O
2	int
)	O
;	O
if	O
(	O
!	O
partial	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
return	O
-	O
1	int
;	O
}	O
textinfo	*(char)
=	O
malloc	(long)->(*(void))
(	O
12	int
*	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
2	int
)	O
;	O
if	O
(	O
!	O
textinfo	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
"0"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
START_C	int
]	O
)	O
;	O
checksum	int
+=	O
START_C	int
;	O
textptr	*(char)
=	O
textinfo	*(char)
;	O
textpos	int
=	O
SYMBOL_WID	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	*(char)
[	O
i	int
]	O
;	O
i	int
+=	O
2	int
)	O
{	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
text	*(char)
[	O
i	int
]	O
)	O
||	O
!	O
isdigit	(int)->(int)
(	O
text	*(char)
[	O
i	int
+	O
1	int
]	O
)	O
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
textinfo	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
code	int
=	O
(	O
text	*(char)
[	O
i	int
]	O
-	O
'0'	O
)	O
*	O
10	int
+	O
text	*(char)
[	O
i	int
+	O
1	int
]	O
-	O
'0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
code	int
]	O
)	O
;	O
checksum	int
+=	O
code	int
*	O
(	O
i	int
/	O
2	int
+	O
1	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
textptr	*(char)
,	O
"%g:9:%c %g:9:%c "	*(char)
,	O
(	O
double	O
)	O
textpos	int
,	O
text	*(char)
[	O
i	int
]	O
,	O
textpos	int
+	O
(	O
double	O
)	O
SYMBOL_WID	int
/	O
2	int
,	O
text	*(char)
[	O
i	int
+	O
1	int
]	O
)	O
;	O
textptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
textptr	*(char)
)	O
;	O
textpos	int
+=	O
SYMBOL_WID	int
;	O
}	O
checksum	int
%=	O
103	int
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
checksum	int
]	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
STOP	int
]	O
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
partial	*(char)
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
textinfo	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_128_verify	(*(char))->(int)
(	O
unsigned	O
char	O
*	O
text	*(char)
)	O
{	O
if	O
(	O
text	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
while	O
(	O
*	O
text	*(char)
&&	O
(	O
*	O
text	*(char)
<=	O
0x80	int
||	O
(	O
*	O
text	*(char)
>=	O
0xc1	int
&&	O
*	O
text	*(char)
<=	O
0xc4	int
)	O
)	O
)	O
text	*(char)
++	O
;	O
if	O
(	O
*	O
text	*(char)
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
Barcode_a_or_b	(*(char))->(int)
(	O
char	O
*	O
text	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
text	*(char)
;	O
text	*(char)
++	O
)	O
{	O
if	O
(	O
NEED_CODE_A	O
(	O
*	O
text	*(char)
)	O
)	O
return	O
'A'	O
;	O
if	O
(	O
NEED_CODE_B	O
(	O
*	O
text	*(char)
)	O
)	O
return	O
'B'	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
Barcode_encode_as	(int,int)->(int)
(	O
int	O
code	int
,	O
int	O
value	int
)	O
{	O
if	O
(	O
value	int
==	O
0xC1	int
)	O
return	O
FUNC_1	int
;	O
if	O
(	O
value	int
==	O
0xC2	int
)	O
return	O
FUNC_2	int
;	O
if	O
(	O
value	int
==	O
0xC3	int
)	O
return	O
FUNC_3	int
;	O
if	O
(	O
value	int
==	O
0xC4	int
)	O
{	O
if	O
(	O
code	int
==	O
'A'	O
)	O
return	O
CODE_A	int
;	O
return	O
CODE_B	int
;	O
}	O
if	O
(	O
value	int
>=	O
0x20	int
&&	O
value	int
<=	O
0x5F	int
)	O
return	O
value	int
-	O
0x20	int
;	O
if	O
(	O
value	int
==	O
0x80	int
)	O
return	O
64	int
;	O
if	O
(	O
value	int
<	O
0x20	int
)	O
return	O
value	int
+	O
64	int
;	O
if	O
(	O
value	int
>=	O
0x60	int
)	O
return	O
value	int
-	O
0x20	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
*	O
Barcode_128_make_array	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)),*(int))->(*(int))
(	O
struct	O
Barcode_Item	struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)
*	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
,	O
int	O
*	O
lptr	*(int)
)	O
{	O
int	O
len	int
,	O
*	O
codes	*(int)
;	O
char	O
*	O
s	*(char)
;	O
int	O
i	int
=	O
0	int
,	O
j	int
,	O
code	int
,	O
checksum	int
;	O
len	int
=	O
2	int
*	O
strlen	(*(char))->(long)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
)	O
+	O
5	int
;	O
codes	*(int)
=	O
malloc	(long)->(*(void))
(	O
len	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
s	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
;	O
if	O
(	O
s	*(char)
[	O
2	int
]	O
==	O
'\0'	O
&&	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
0	int
]	O
)	O
&&	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
code	int
=	O
'C'	O
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
0	int
]	O
)	O
&&	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
1	int
]	O
)	O
&&	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
2	int
]	O
)	O
&&	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
3	int
]	O
)	O
)	O
{	O
code	int
=	O
'C'	O
;	O
}	O
else	O
{	O
code	int
=	O
Barcode_a_or_b	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
code	int
)	O
code	int
=	O
'B'	O
;	O
}	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
START_A	int
+	O
code	int
-	O
'A'	O
;	O
for	O
(	O
s	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
;	O
*	O
s	*(char)
;	O
)	O
{	O
switch	O
(	O
code	int
)	O
{	O
case	O
'C'	O
:	O
if	O
(	O
s	*(char)
[	O
0	int
]	O
==	O
0xC1	int
)	O
{	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
FUNC_1	int
;	O
s	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
0	int
]	O
)	O
&&	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
(	O
s	*(char)
[	O
0	int
]	O
-	O
'0'	O
)	O
*	O
10	int
+	O
s	*(char)
[	O
1	int
]	O
-	O
'0'	O
;	O
s	*(char)
+=	O
2	int
;	O
}	O
else	O
{	O
code	int
=	O
Barcode_a_or_b	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
code	int
)	O
code	int
=	O
'B'	O
;	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
(	O
code	int
==	O
'A'	O
)	O
?	O
CODE_A	int
:	O
CODE_B	int
;	O
}	O
break	O
;	O
case	O
'B'	O
:	O
case	O
'A'	O
:	O
for	O
(	O
j	int
=	O
0	int
;	O
isdigit	(int)->(int)
(	O
s	*(char)
[	O
j	int
]	O
)	O
;	O
j	int
++	O
)	O
;	O
if	O
(	O
j	int
>=	O
4	int
)	O
{	O
if	O
(	O
j	int
&	O
1	int
)	O
{	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
*	O
(	O
s	*(char)
++	O
)	O
-	O
' '	O
;	O
}	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
CODE_C	int
;	O
code	int
=	O
'C'	O
;	O
}	O
else	O
if	O
(	O
code	int
==	O
'A'	O
&&	O
NEED_CODE_B	O
(	O
*	O
s	*(char)
)	O
)	O
{	O
j	int
=	O
Barcode_a_or_b	(*(char))->(int)
(	O
s	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
j	int
==	O
'B'	O
)	O
{	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
CODE_B	int
;	O
code	int
=	O
'B'	O
;	O
}	O
else	O
{	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
SHIFT	int
;	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
Barcode_encode_as	(int,int)->(int)
(	O
'B'	O
,	O
*	O
s	*(char)
)	O
;	O
s	*(char)
++	O
;	O
}	O
}	O
else	O
if	O
(	O
code	int
==	O
'B'	O
&&	O
NEED_CODE_A	O
(	O
*	O
s	*(char)
)	O
)	O
{	O
j	int
=	O
Barcode_a_or_b	(*(char))->(int)
(	O
s	*(char)
+	O
1	int
)	O
;	O
if	O
(	O
j	int
==	O
'A'	O
)	O
{	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
CODE_A	int
;	O
code	int
=	O
'A'	O
;	O
}	O
else	O
{	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
SHIFT	int
;	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
Barcode_encode_as	(int,int)->(int)
(	O
'A'	O
,	O
*	O
s	*(char)
)	O
;	O
s	*(char)
++	O
;	O
}	O
}	O
else	O
{	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
Barcode_encode_as	(int,int)->(int)
(	O
code	int
,	O
*	O
s	*(char)
)	O
;	O
s	*(char)
++	O
;	O
}	O
break	O
;	O
}	O
}	O
checksum	int
=	O
codes	*(int)
[	O
0	int
]	O
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
checksum	int
+=	O
j	int
*	O
codes	*(int)
[	O
j	int
]	O
;	O
checksum	int
%=	O
103	int
;	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
checksum	int
;	O
codes	*(int)
[	O
i	int
++	O
]	O
=	O
STOP	int
;	O
if	O
(	O
i	int
>	O
len	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"impossible: length is > allocated len\n"	*(char)
)	O
;	O
}	O
*	O
lptr	*(int)
=	O
i	int
;	O
return	O
codes	*(int)
;	O
}	O
int	O
Barcode_128_encode	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)))->(int)
(	O
struct	O
Barcode_Item	struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)
*	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
)	O
{	O
static	O
char	O
*	O
text	*(char)
;	O
static	O
char	O
*	O
partial	*(char)
;	O
static	O
char	O
*	O
textinfo	*(char)
;	O
char	O
*	O
textptr	*(char)
;	O
int	O
*	O
codes	*(int)
;	O
int	O
i	int
,	O
c	int
,	O
len	int
;	O
double	O
textpos	int
,	O
size	double
,	O
step	double
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
)	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
"code 128"	*(char)
)	O
;	O
text	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
;	O
if	O
(	O
!	O
text	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
codes	*(int)
=	O
Barcode_128_make_array	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)),*(int))->(*(int))
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
,	O
&	O
len	int
)	O
;	O
if	O
(	O
!	O
codes	*(int)
)	O
return	O
-	O
1	int
;	O
partial	*(char)
=	O
malloc	(long)->(*(void))
(	O
6	int
*	O
len	int
+	O
4	int
)	O
;	O
if	O
(	O
!	O
partial	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
codes	*(int)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
textptr	*(char)
=	O
textinfo	*(char)
=	O
malloc	(long)->(*(void))
(	O
13	int
*	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
2	int
)	O
;	O
if	O
(	O
!	O
textinfo	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
codes	*(int)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
"0"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
codes	*(int)
[	O
i	int
]	O
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
partial	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
isalpha	(int)->(int)
(	O
partial	*(char)
[	O
i	int
]	O
)	O
)	O
partial	*(char)
[	O
i	int
]	O
+=	O
'1'	O
-	O
'a'	O
;	O
size	double
=	O
(	O
int	O
)	O
(	O
180.0	int
*	O
(	O
len	int
-	O
3	int
)	O
/	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
+	O
.5	int
)	O
/	O
10.0	int
;	O
if	O
(	O
size	double
>	O
12.0	int
)	O
size	double
=	O
12.0	int
;	O
step	double
=	O
(	O
int	O
)	O
(	O
10	int
*	O
(	O
size	double
/	O
18.0	int
*	O
SYMBOL_WID	int
)	O
+	O
.5	int
)	O
/	O
10.0	int
;	O
textpos	int
=	O
SYMBOL_WID	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
i	int
++	O
)	O
{	O
c	int
=	O
text	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
c	int
<	O
32	int
||	O
c	int
==	O
0x80	int
)	O
c	int
=	O
'_'	O
;	O
if	O
(	O
c	int
>	O
0xc0	int
)	O
c	int
=	O
' '	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
textptr	*(char)
,	O
"%g:%g:%c "	*(char)
,	O
textpos	int
,	O
size	double
,	O
c	int
)	O
;	O
textptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
textptr	*(char)
)	O
;	O
textpos	int
+=	O
step	double
;	O
}	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
partial	*(char)
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
textinfo	*(char)
;	O
free	(*(void))->(void)
(	O
codes	*(int)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_128raw_verify	(*(char))->(int)
(	O
char	O
*	O
text	*(char)
)	O
{	O
int	O
n	long
;	O
unsigned	O
val	int
;	O
if	O
(	O
!	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
while	O
(	O
*	O
text	*(char)
)	O
{	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
text	*(char)
,	O
"%u%n"	*(char)
,	O
&	O
val	int
,	O
&	O
n	long
)	O
<	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
val	int
>	O
105	int
)	O
return	O
-	O
1	int
;	O
text	*(char)
+=	O
n	long
;	O
}	O
return	O
0	int
;	O
}	O
int	O
Barcode_128raw_encode	(*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)))->(int)
(	O
struct	O
Barcode_Item	struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int)
*	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
)	O
{	O
static	O
char	O
*	O
text	*(char)
;	O
static	O
char	O
*	O
partial	*(char)
;	O
static	O
char	O
*	O
textinfo	*(char)
;	O
char	O
*	O
textptr	*(char)
;	O
int	O
i	int
,	O
n	long
,	O
count	int
,	O
code	int
,	O
textpos	int
,	O
checksum	int
=	O
0	int
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
)	O
;	O
if	O
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
free	(*(void))->(void)
(	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
)	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
encoding	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
"128raw"	*(char)
)	O
;	O
text	*(char)
=	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
ascii	*(char)
;	O
if	O
(	O
!	O
text	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
partial	*(char)
=	O
malloc	(long)->(*(void))
(	O
(	O
3	int
+	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
/	O
2	int
)	O
*	O
6	int
+	O
2	int
)	O
;	O
if	O
(	O
!	O
partial	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
return	O
-	O
1	int
;	O
}	O
textinfo	*(char)
=	O
malloc	(long)->(*(void))
(	O
12	int
*	O
(	O
1	int
+	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
/	O
2	int
)	O
+	O
2	int
)	O
;	O
if	O
(	O
!	O
textinfo	*(char)
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
errno	O
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
"0"	*(char)
)	O
;	O
textptr	*(char)
=	O
textinfo	*(char)
;	O
textpos	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
count	int
=	O
0	int
;	O
i	int
<	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
count	int
++	O
)	O
{	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
text	*(char)
+	O
i	int
,	O
"%u%n"	*(char)
,	O
&	O
code	int
,	O
&	O
n	long
)	O
<	O
1	int
)	O
{	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
error	int
=	O
EINVAL	int
;	O
free	(*(void))->(void)
(	O
partial	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
textinfo	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
code	int
]	O
)	O
;	O
if	O
(	O
!	O
count	int
)	O
checksum	int
+=	O
code	int
;	O
else	O
checksum	int
+=	O
code	int
*	O
count	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
textptr	*(char)
,	O
"%g:9:%c %g:9:%c "	*(char)
,	O
(	O
double	O
)	O
textpos	int
,	O
code	int
>=	O
100	int
?	O
'A'	O
:	O
code	int
/	O
10	int
+	O
'0'	O
,	O
textpos	int
+	O
(	O
double	O
)	O
SYMBOL_WID	int
/	O
2	int
,	O
code	int
%	O
10	int
+	O
'0'	O
)	O
;	O
textptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
textptr	*(char)
)	O
;	O
textpos	int
+=	O
SYMBOL_WID	int
;	O
i	int
+=	O
n	long
;	O
}	O
checksum	int
%=	O
103	int
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
checksum	int
]	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
partial	*(char)
,	O
codeset	array(*(char))
[	O
STOP	int
]	O
)	O
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
partial	*(char)
=	O
partial	*(char)
;	O
bc	*(struct(int,*(char),*(char),*(char),*(char),int,int,int,int,int,double,int))
->	O
textinfo	*(char)
=	O
textinfo	*(char)
;	O
return	O
0	int
;	O
}	O
