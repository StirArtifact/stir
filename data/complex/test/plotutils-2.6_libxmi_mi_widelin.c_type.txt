static	O
void	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
int	O
y	int
,	O
unsigned	O
int	O
overall_height	int
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
left	*(struct(int,int,int,int,int,int,int))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
right	*(struct(int,int,int,int,int,int,int))
,	O
int	O
left_count	int
,	O
int	O
right_count	int
)	O
;	O
static	O
void	O
miFillRectPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,int,int)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
int	O
x	int
,	O
int	O
y	int
,	O
unsigned	O
int	O
w	int
,	O
unsigned	O
int	O
h	int
)	O
;	O
static	O
void	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
double	O
xorg	double
,	O
double	O
yorg	double
,	O
bool	enum(int,int)
isInt	enum(int,int)
)	O
;	O
static	O
void	O
miLineJoin	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
pLeft	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
pRight	*(struct(double,double,int,int,int,int,double))
)	O
;	O
static	O
void	O
miLineProjectingCap	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),enum(int,int),enum(int,int))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
face	*(struct(double,double,int,int,int,int,double))
,	O
bool	enum(int,int)
isLeft	enum(int,int)
,	O
bool	enum(int,int)
isInt	enum(int,int)
)	O
;	O
static	O
void	O
miWideDashSegment	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(int),*(int),*(int),int,int,int,int,enum(int,int),enum(int,int),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
*	O
pDashNum	*(int)
,	O
int	O
*	O
pDashIndex	*(int)
,	O
int	O
*	O
pDashOffset	*(int)
,	O
int	O
x1	int
,	O
int	O
y1	(double)->(double)
,	O
int	O
x2	int
,	O
int	O
y2	int
,	O
bool	enum(int,int)
projectLeft	enum(int,int)
,	O
bool	enum(int,int)
projectRight	enum(int,int)
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
;	O
static	O
void	O
miWideSegment	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),int,int,int,int,enum(int,int),enum(int,int),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
x1	int
,	O
int	O
y1	(double)->(double)
,	O
int	O
x2	int
,	O
int	O
y2	int
,	O
bool	enum(int,int)
projectLeft	enum(int,int)
,	O
bool	enum(int,int)
projectRight	enum(int,int)
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
;	O
static	O
int	O
miLineArcD	(*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),double,double,*(struct(int,int)),*(int),*(struct(int,int,int,int,int,int,int)),int,enum(int,int),*(struct(int,int,int,int,int,int,int)),int,enum(int,int))->(int)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
double	O
xorg	double
,	O
double	O
yorg	double
,	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
widths	*(int)
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
int	O
edgey1	int
,	O
bool	enum(int,int)
edgeleft1	enum(int,int)
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
int	O
edgey2	int
,	O
bool	enum(int,int)
edgeleft2	enum(int,int)
)	O
;	O
static	O
int	O
miLineArcI	(*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),int,int,*(struct(int,int)),*(int))->(int)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
xorg	double
,	O
int	O
yorg	double
,	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
widths	*(int)
)	O
;	O
static	O
int	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
double	O
x0	double
,	O
double	O
y0	(double)->(double)
,	O
double	O
k	double
,	O
int	O
dx	int
,	O
int	O
dy	int
,	O
int	O
xi	int
,	O
int	O
yi	int
,	O
bool	enum(int,int)
left	*(struct(int,int,int,int,int,int,int))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int,int))
)	O
;	O
static	O
int	O
miPolyBuildPoly	(*(struct(double,double)),*(struct(int,int,double)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),*(int),*(int),*(int))->(int)
(	O
const	O
PolyVertex	struct(double,double)
*	O
vertices	*(struct(double,double))
,	O
const	O
PolySlope	struct(int,int,double)
*	O
slopes	*(struct(int,int,double))
,	O
int	O
count	int
,	O
int	O
xi	int
,	O
int	O
yi	int
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
left	*(struct(int,int,int,int,int,int,int))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
right	*(struct(int,int,int,int,int,int,int))
,	O
int	O
*	O
pnleft	*(int)
,	O
int	O
*	O
pnright	*(int)
,	O
unsigned	O
int	O
*	O
h	int
)	O
;	O
static	O
int	O
miRoundCapClip	(*(struct(double,double,int,int,int,int,double)),enum(int,int),*(struct(int,int,int,int,int,int,int)),*(enum(int,int)))->(int)
(	O
const	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
face	*(struct(double,double,int,int,int,int,double))
,	O
bool	enum(int,int)
isInt	enum(int,int)
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int,int))
,	O
bool	enum(int,int)
*	O
leftEdge	*(enum(int,int))
)	O
;	O
static	O
int	O
miRoundJoinFace	(*(struct(double,double,int,int,int,int,double)),*(struct(int,int,int,int,int,int,int)),*(enum(int,int)))->(int)
(	O
const	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
face	*(struct(double,double,int,int,int,int,double))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int,int))
,	O
bool	enum(int,int)
*	O
leftEdge	*(enum(int,int))
)	O
;	O
static	O
void	O
miRoundJoinClip	(*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),*(int),*(int),*(enum(int,int)),*(enum(int,int)))->(void)
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
pLeft	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
pRight	*(struct(double,double,int,int,int,int,double))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
int	O
*	O
y1	(double)->(double)
,	O
int	O
*	O
y2	int
,	O
bool	enum(int,int)
*	O
left1	*(enum(int,int))
,	O
bool	enum(int,int)
*	O
left2	*(enum(int,int))
)	O
;	O
static	O
void	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
int	O
y	int
,	O
unsigned	O
int	O
overall_height	int
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
left	*(struct(int,int,int,int,int,int,int))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
right	*(struct(int,int,int,int,int,int,int))
,	O
int	O
left_count	int
,	O
int	O
right_count	int
)	O
{	O
int	O
left_x	int
=	O
0	int
,	O
left_e	int
=	O
0	int
;	O
int	O
left_stepx	int
=	O
0	int
;	O
int	O
left_signdx	int
=	O
0	int
;	O
int	O
left_dy	int
=	O
0	int
,	O
left_dx	int
=	O
0	int
;	O
int	O
right_x	int
=	O
0	int
,	O
right_e	int
=	O
0	int
;	O
int	O
right_stepx	int
=	O
0	int
;	O
int	O
right_signdx	int
=	O
0	int
;	O
int	O
right_dy	int
=	O
0	int
,	O
right_dx	int
=	O
0	int
;	O
unsigned	O
int	O
left_height	int
=	O
0	int
,	O
right_height	int
=	O
0	int
;	O
miPoint	struct(int,int)
*	O
ppt	*(struct(int,int))
;	O
miPoint	struct(int,int)
*	O
pptInit	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
NULL	O
;	O
unsigned	O
int	O
*	O
pwidth	*(int)
;	O
unsigned	O
int	O
*	O
pwidthInit	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
NULL	O
;	O
pptInit	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
overall_height	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
pwidthInit	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
overall_height	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
ppt	*(struct(int,int))
=	O
pptInit	*(struct(int,int))
;	O
pwidth	*(int)
=	O
pwidthInit	*(int)
;	O
while	O
(	O
(	O
left_count	int
||	O
left_height	int
)	O
&&	O
(	O
right_count	int
||	O
right_height	int
)	O
)	O
{	O
unsigned	O
int	O
height	int
;	O
MIPOLYRELOADLEFT	O
MIPOLYRELOADRIGHT	O
height	int
=	O
UMIN	O
(	O
left_height	int
,	O
right_height	int
)	O
;	O
left_height	int
-=	O
height	int
;	O
right_height	int
-=	O
height	int
;	O
while	O
(	O
height	int
--	O
)	O
{	O
if	O
(	O
right_x	int
>=	O
left_x	int
)	O
{	O
ppt	*(struct(int,int))
->	O
x	int
=	O
left_x	int
;	O
ppt	*(struct(int,int))
->	O
y	int
=	O
y	int
;	O
ppt	*(struct(int,int))
++	O
;	O
*	O
pwidth	*(int)
++	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
right_x	int
-	O
left_x	int
+	O
1	int
)	O
;	O
}	O
y	int
++	O
;	O
MIPOLYSTEPLEFT	O
MIPOLYSTEPRIGHT	O
}	O
}	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
ppt	*(struct(int,int))
-	O
pptInit	*(struct(int,int))
,	O
pptInit	*(struct(int,int))
,	O
pwidthInit	*(int)
)	O
}	O
static	O
void	O
miFillRectPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,int,int)->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
int	O
x	int
,	O
int	O
y	int
,	O
unsigned	O
int	O
w	int
,	O
unsigned	O
int	O
h	int
)	O
{	O
miPoint	struct(int,int)
*	O
ppt	*(struct(int,int))
,	O
*	O
pptInit	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
pwidth	*(int)
,	O
*	O
pwidthInit	*(int)
;	O
pptInit	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
h	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
pwidthInit	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
h	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
ppt	*(struct(int,int))
=	O
pptInit	*(struct(int,int))
;	O
pwidth	*(int)
=	O
pwidthInit	*(int)
;	O
while	O
(	O
h	int
--	O
)	O
{	O
*	O
pwidth	*(int)
++	O
=	O
w	int
;	O
ppt	*(struct(int,int))
->	O
x	int
=	O
x	int
;	O
ppt	*(struct(int,int))
->	O
y	int
=	O
y	int
;	O
ppt	*(struct(int,int))
++	O
;	O
y	int
++	O
;	O
}	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
ppt	*(struct(int,int))
-	O
pptInit	*(struct(int,int))
,	O
pptInit	*(struct(int,int))
,	O
pwidthInit	*(int)
)	O
}	O
static	O
int	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
double	O
x0	double
,	O
double	O
y0	(double)->(double)
,	O
double	O
k	double
,	O
int	O
dx	int
,	O
int	O
dy	int
,	O
int	O
xi	int
,	O
int	O
yi	int
,	O
bool	enum(int,int)
left	*(struct(int,int,int,int,int,int,int))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int,int))
)	O
{	O
int	O
x	int
,	O
y	int
,	O
e	int
;	O
int	O
xady	int
;	O
if	O
(	O
dy	int
<	O
0	int
)	O
{	O
dy	int
=	O
-	O
dy	int
;	O
dx	int
=	O
-	O
dx	int
;	O
k	double
=	O
-	O
k	double
;	O
}	O
y	int
=	O
ICEIL	O
(	O
y0	(double)->(double)
)	O
;	O
xady	int
=	O
ICEIL	O
(	O
k	double
)	O
+	O
y	int
*	O
dx	int
;	O
if	O
(	O
xady	int
<=	O
0	int
)	O
x	int
=	O
-	O
(	O
-	O
xady	int
/	O
dy	int
)	O
-	O
1	int
;	O
else	O
x	int
=	O
(	O
xady	int
-	O
1	int
)	O
/	O
dy	int
;	O
e	int
=	O
xady	int
-	O
x	int
*	O
dy	int
;	O
if	O
(	O
dx	int
>=	O
0	int
)	O
{	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
signdx	int
=	O
1	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
stepx	int
=	O
dx	int
/	O
dy	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
dx	int
=	O
dx	int
%	O
dy	int
;	O
}	O
else	O
{	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
signdx	int
=	O
-	O
1	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
stepx	int
=	O
-	O
(	O
-	O
dx	int
/	O
dy	int
)	O
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
dx	int
=	O
-	O
dx	int
%	O
dy	int
;	O
e	int
=	O
dy	int
-	O
e	int
+	O
1	int
;	O
}	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
dy	int
=	O
dy	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
x	int
=	O
x	int
+	O
(	O
left	*(struct(int,int,int,int,int,int,int))
==	O
true	int
?	O
1	int
:	O
0	int
)	O
+	O
xi	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
e	int
=	O
e	int
-	O
dy	int
;	O
return	O
y	int
+	O
yi	int
;	O
}	O
static	O
int	O
miPolyBuildPoly	(*(struct(double,double)),*(struct(int,int,double)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),*(int),*(int),*(int))->(int)
(	O
const	O
PolyVertex	struct(double,double)
*	O
vertices	*(struct(double,double))
,	O
const	O
PolySlope	struct(int,int,double)
*	O
slopes	*(struct(int,int,double))
,	O
int	O
count	int
,	O
int	O
xi	int
,	O
int	O
yi	int
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
left	*(struct(int,int,int,int,int,int,int))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
right	*(struct(int,int,int,int,int,int,int))
,	O
int	O
*	O
pnleft	*(int)
,	O
int	O
*	O
pnright	*(int)
,	O
unsigned	O
int	O
*	O
h	int
)	O
{	O
int	O
top	int
,	O
bottom	int
;	O
double	O
miny	double
,	O
maxy	double
;	O
int	O
i	int
;	O
int	O
j	int
;	O
int	O
clockwise	int
;	O
int	O
slopeoff	int
;	O
int	O
s	int
;	O
int	O
nright	int
,	O
nleft	int
;	O
int	O
y	int
,	O
lasty	int
=	O
0	int
,	O
bottomy	int
,	O
topy	int
=	O
0	int
;	O
maxy	double
=	O
miny	double
=	O
vertices	*(struct(double,double))
[	O
0	int
]	O
.	O
y	int
;	O
bottom	int
=	O
top	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
vertices	*(struct(double,double))
[	O
i	int
]	O
.	O
y	int
<	O
miny	double
)	O
{	O
top	int
=	O
i	int
;	O
miny	double
=	O
vertices	*(struct(double,double))
[	O
i	int
]	O
.	O
y	int
;	O
}	O
if	O
(	O
vertices	*(struct(double,double))
[	O
i	int
]	O
.	O
y	int
>=	O
maxy	double
)	O
{	O
bottom	int
=	O
i	int
;	O
maxy	double
=	O
vertices	*(struct(double,double))
[	O
i	int
]	O
.	O
y	int
;	O
}	O
}	O
bottomy	int
=	O
ICEIL	O
(	O
maxy	double
)	O
+	O
yi	int
;	O
i	int
=	O
top	int
;	O
j	int
=	O
StepAround	O
(	O
top	int
,	O
-	O
1	int
,	O
count	int
)	O
;	O
clockwise	int
=	O
1	int
;	O
slopeoff	int
=	O
0	int
;	O
if	O
(	O
slopes	*(struct(int,int,double))
[	O
j	int
]	O
.	O
dy	int
*	O
slopes	*(struct(int,int,double))
[	O
i	int
]	O
.	O
dx	int
>	O
slopes	*(struct(int,int,double))
[	O
i	int
]	O
.	O
dy	int
*	O
slopes	*(struct(int,int,double))
[	O
j	int
]	O
.	O
dx	int
)	O
{	O
clockwise	int
=	O
-	O
1	int
;	O
slopeoff	int
=	O
-	O
1	int
;	O
}	O
i	int
=	O
top	int
;	O
s	int
=	O
StepAround	O
(	O
top	int
,	O
slopeoff	int
,	O
count	int
)	O
;	O
nright	int
=	O
0	int
;	O
while	O
(	O
i	int
!=	O
bottom	int
)	O
{	O
if	O
(	O
slopes	*(struct(int,int,double))
[	O
s	int
]	O
.	O
dy	int
!=	O
0	int
)	O
{	O
y	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
vertices	*(struct(double,double))
[	O
i	int
]	O
.	O
x	int
,	O
vertices	*(struct(double,double))
[	O
i	int
]	O
.	O
y	int
,	O
slopes	*(struct(int,int,double))
[	O
s	int
]	O
.	O
k	double
,	O
slopes	*(struct(int,int,double))
[	O
s	int
]	O
.	O
dx	int
,	O
slopes	*(struct(int,int,double))
[	O
s	int
]	O
.	O
dy	int
,	O
xi	int
,	O
yi	int
,	O
false	int
,	O
&	O
right	*(struct(int,int,int,int,int,int,int))
[	O
nright	int
]	O
)	O
;	O
if	O
(	O
nright	int
!=	O
0	int
)	O
right	*(struct(int,int,int,int,int,int,int))
[	O
nright	int
-	O
1	int
]	O
.	O
height	int
=	O
y	int
-	O
lasty	int
;	O
else	O
topy	int
=	O
y	int
;	O
nright	int
++	O
;	O
lasty	int
=	O
y	int
;	O
}	O
i	int
=	O
StepAround	O
(	O
i	int
,	O
clockwise	int
,	O
count	int
)	O
;	O
s	int
=	O
StepAround	O
(	O
s	int
,	O
clockwise	int
,	O
count	int
)	O
;	O
}	O
if	O
(	O
nright	int
!=	O
0	int
)	O
right	*(struct(int,int,int,int,int,int,int))
[	O
nright	int
-	O
1	int
]	O
.	O
height	int
=	O
bottomy	int
-	O
lasty	int
;	O
if	O
(	O
slopeoff	int
==	O
0	int
)	O
slopeoff	int
=	O
-	O
1	int
;	O
else	O
slopeoff	int
=	O
0	int
;	O
i	int
=	O
top	int
;	O
s	int
=	O
StepAround	O
(	O
top	int
,	O
slopeoff	int
,	O
count	int
)	O
;	O
nleft	int
=	O
0	int
;	O
while	O
(	O
i	int
!=	O
bottom	int
)	O
{	O
if	O
(	O
slopes	*(struct(int,int,double))
[	O
s	int
]	O
.	O
dy	int
!=	O
0	int
)	O
{	O
y	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
vertices	*(struct(double,double))
[	O
i	int
]	O
.	O
x	int
,	O
vertices	*(struct(double,double))
[	O
i	int
]	O
.	O
y	int
,	O
slopes	*(struct(int,int,double))
[	O
s	int
]	O
.	O
k	double
,	O
slopes	*(struct(int,int,double))
[	O
s	int
]	O
.	O
dx	int
,	O
slopes	*(struct(int,int,double))
[	O
s	int
]	O
.	O
dy	int
,	O
xi	int
,	O
yi	int
,	O
true	int
,	O
&	O
left	*(struct(int,int,int,int,int,int,int))
[	O
nleft	int
]	O
)	O
;	O
if	O
(	O
nleft	int
!=	O
0	int
)	O
left	*(struct(int,int,int,int,int,int,int))
[	O
nleft	int
-	O
1	int
]	O
.	O
height	int
=	O
y	int
-	O
lasty	int
;	O
nleft	int
++	O
;	O
lasty	int
=	O
y	int
;	O
}	O
i	int
=	O
StepAround	O
(	O
i	int
,	O
-	O
clockwise	int
,	O
count	int
)	O
;	O
s	int
=	O
StepAround	O
(	O
s	int
,	O
-	O
clockwise	int
,	O
count	int
)	O
;	O
}	O
if	O
(	O
nleft	int
!=	O
0	int
)	O
left	*(struct(int,int,int,int,int,int,int))
[	O
nleft	int
-	O
1	int
]	O
.	O
height	int
=	O
bottomy	int
-	O
lasty	int
;	O
*	O
pnleft	*(int)
=	O
nleft	int
;	O
*	O
pnright	*(int)
=	O
nright	int
;	O
*	O
h	int
=	O
bottomy	int
-	O
topy	int
;	O
return	O
topy	int
;	O
}	O
static	O
void	O
miLineJoin	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
pLeft	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
pRight	*(struct(double,double,int,int,int,int,double))
)	O
{	O
double	O
mx	double
=	O
0.0	int
,	O
my	double
=	O
0.0	int
;	O
int	O
denom	int
=	O
0	int
;	O
PolyVertex	struct(double,double)
vertices	*(struct(double,double))
[	O
4	int
]	O
;	O
PolySlope	struct(int,int,double)
slopes	*(struct(int,int,double))
[	O
4	int
]	O
;	O
int	O
edgecount	int
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
left	*(struct(int,int,int,int,int,int,int))
[	O
4	int
]	O
,	O
right	*(struct(int,int,int,int,int,int,int))
[	O
4	int
]	O
;	O
int	O
nleft	int
,	O
nright	int
;	O
int	O
y	int
;	O
unsigned	O
int	O
height	int
;	O
bool	enum(int,int)
swapslopes	enum(int,int)
;	O
int	O
joinStyle	int
=	O
(	O
int	O
)	O
pGC	*(struct)
->	O
joinStyle	int
;	O
int	O
lw	int
=	O
(	O
int	O
)	O
(	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
if	O
(	O
joinStyle	int
==	O
(	O
int	O
)	O
MI_JOIN_ROUND	int
)	O
{	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
pLeft	*(struct(double,double,int,int,int,int,double))
,	O
pRight	*(struct(double,double,int,int,int,int,double))
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
return	O
;	O
}	O
denom	int
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
*	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
+	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
*	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
if	O
(	O
denom	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
denom	int
>	O
0	int
)	O
{	O
swapslopes	enum(int,int)
=	O
false	int
;	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
}	O
else	O
{	O
swapslopes	enum(int,int)
=	O
true	int
;	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
=	O
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
=	O
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
}	O
vertices	*(struct(double,double))
[	O
0	int
]	O
.	O
x	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
vertices	*(struct(double,double))
[	O
0	int
]	O
.	O
y	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
slopes	*(struct(int,int,double))
[	O
0	int
]	O
.	O
dx	int
=	O
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
0	int
]	O
.	O
dy	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
0	int
]	O
.	O
k	double
=	O
0	int
;	O
vertices	*(struct(double,double))
[	O
1	int
]	O
.	O
x	int
=	O
0	int
;	O
vertices	*(struct(double,double))
[	O
1	int
]	O
.	O
y	int
=	O
0	int
;	O
slopes	*(struct(int,int,double))
[	O
1	int
]	O
.	O
dx	int
=	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
1	int
]	O
.	O
dy	int
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
1	int
]	O
.	O
k	double
=	O
0	int
;	O
vertices	*(struct(double,double))
[	O
2	int
]	O
.	O
x	int
=	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
vertices	*(struct(double,double))
[	O
2	int
]	O
.	O
y	int
=	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
if	O
(	O
joinStyle	int
==	O
(	O
int	O
)	O
MI_JOIN_MITER	int
)	O
{	O
double	O
miterlimit	double
=	O
pGC	*(struct)
->	O
miterLimit	double
;	O
my	double
=	O
(	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
*	O
(	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
*	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
*	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
)	O
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
*	O
(	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
*	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
*	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
)	O
)	O
/	O
(	O
double	O
)	O
denom	int
;	O
if	O
(	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
!=	O
0	int
)	O
mx	double
=	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
+	O
(	O
my	double
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
)	O
*	O
(	O
double	O
)	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
/	O
(	O
double	O
)	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
else	O
mx	double
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
+	O
(	O
my	double
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
)	O
*	O
(	O
double	O
)	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
/	O
(	O
double	O
)	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
if	O
(	O
(	O
mx	double
*	O
mx	double
+	O
my	double
*	O
my	double
)	O
*	O
4	int
>	O
miterlimit	double
*	O
miterlimit	double
*	O
lw	int
*	O
lw	int
)	O
joinStyle	int
=	O
(	O
int	O
)	O
MI_JOIN_BEVEL	int
;	O
}	O
switch	O
(	O
(	O
int	O
)	O
joinStyle	int
)	O
{	O
double	O
scale	double
,	O
dx	int
,	O
dy	int
,	O
adx	double
,	O
ady	double
;	O
case	O
(	O
int	O
)	O
MI_JOIN_MITER	int
:	O
default	O
:	O
edgecount	int
=	O
4	int
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dx	int
=	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dy	int
=	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
k	double
=	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
k	double
;	O
if	O
(	O
swapslopes	enum(int,int)
)	O
{	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dx	int
=	O
-	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dy	int
=	O
-	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
k	double
=	O
-	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
k	double
;	O
}	O
vertices	*(struct(double,double))
[	O
3	int
]	O
.	O
x	int
=	O
mx	double
;	O
vertices	*(struct(double,double))
[	O
3	int
]	O
.	O
y	int
=	O
my	double
;	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dx	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dy	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
k	double
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
k	double
;	O
if	O
(	O
swapslopes	enum(int,int)
)	O
{	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dx	int
=	O
-	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dy	int
=	O
-	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
k	double
=	O
-	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
k	double
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_JOIN_BEVEL	int
:	O
{	O
PolyVertex	struct(double,double)
midpoint	struct(double,double)
;	O
edgecount	int
=	O
3	int
;	O
midpoint	struct(double,double)
.	O
x	int
=	O
0.5	int
*	O
(	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
+	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
)	O
;	O
midpoint	struct(double,double)
.	O
y	int
=	O
0.5	int
*	O
(	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
+	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
)	O
;	O
dx	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
dy	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
adx	double
=	O
dx	int
;	O
ady	double
=	O
dy	int
;	O
if	O
(	O
adx	double
<	O
0	int
)	O
adx	double
=	O
-	O
adx	double
;	O
if	O
(	O
ady	double
<	O
0	int
)	O
ady	double
=	O
-	O
ady	double
;	O
scale	double
=	O
ady	double
;	O
if	O
(	O
adx	double
>	O
ady	double
)	O
scale	double
=	O
adx	double
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dx	int
=	O
(	O
int	O
)	O
(	O
(	O
dx	int
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dy	int
=	O
(	O
int	O
)	O
(	O
(	O
dy	int
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
k	double
=	O
midpoint	struct(double,double)
.	O
x	int
*	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dy	int
-	O
midpoint	struct(double,double)
.	O
y	int
*	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dx	int
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_JOIN_TRIANGULAR	int
:	O
{	O
PolyVertex	struct(double,double)
midpoint	struct(double,double)
,	O
newpoint	struct(double,double)
;	O
double	O
mid2	double
,	O
mid	double
,	O
dx2	double
,	O
dy2	double
,	O
dx3	double
,	O
dy3	double
;	O
edgecount	int
=	O
4	int
;	O
midpoint	struct(double,double)
.	O
x	int
=	O
0.5	int
*	O
(	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
+	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
)	O
;	O
midpoint	struct(double,double)
.	O
y	int
=	O
0.5	int
*	O
(	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
+	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
)	O
;	O
mid2	double
=	O
midpoint	struct(double,double)
.	O
x	int
*	O
midpoint	struct(double,double)
.	O
x	int
+	O
midpoint	struct(double,double)
.	O
y	int
*	O
midpoint	struct(double,double)
.	O
y	int
;	O
mid	double
=	O
sqrt	(double)->(double)
(	O
mid2	double
)	O
;	O
newpoint	struct(double,double)
.	O
x	int
=	O
0.5	int
*	O
lw	int
*	O
midpoint	struct(double,double)
.	O
x	int
/	O
mid	double
;	O
newpoint	struct(double,double)
.	O
y	int
=	O
0.5	int
*	O
lw	int
*	O
midpoint	struct(double,double)
.	O
y	int
/	O
mid	double
;	O
vertices	*(struct(double,double))
[	O
3	int
]	O
=	O
newpoint	struct(double,double)
;	O
dx2	double
=	O
vertices	*(struct(double,double))
[	O
3	int
]	O
.	O
x	int
-	O
vertices	*(struct(double,double))
[	O
2	int
]	O
.	O
x	int
;	O
dy2	double
=	O
vertices	*(struct(double,double))
[	O
3	int
]	O
.	O
y	int
-	O
vertices	*(struct(double,double))
[	O
2	int
]	O
.	O
y	int
;	O
dx3	double
=	O
vertices	*(struct(double,double))
[	O
0	int
]	O
.	O
x	int
-	O
vertices	*(struct(double,double))
[	O
3	int
]	O
.	O
x	int
;	O
dy3	double
=	O
vertices	*(struct(double,double))
[	O
0	int
]	O
.	O
y	int
-	O
vertices	*(struct(double,double))
[	O
3	int
]	O
.	O
y	int
;	O
dx	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
dy	int
=	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
adx	double
=	O
dx	int
;	O
ady	double
=	O
dy	int
;	O
if	O
(	O
adx	double
<	O
0	int
)	O
adx	double
=	O
-	O
adx	double
;	O
if	O
(	O
ady	double
<	O
0	int
)	O
ady	double
=	O
-	O
ady	double
;	O
scale	double
=	O
ady	double
;	O
if	O
(	O
adx	double
>	O
ady	double
)	O
scale	double
=	O
adx	double
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dx	int
=	O
(	O
int	O
)	O
(	O
(	O
dx2	double
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dy	int
=	O
(	O
int	O
)	O
(	O
(	O
dy2	double
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
k	double
=	O
newpoint	struct(double,double)
.	O
x	int
*	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dy	int
-	O
newpoint	struct(double,double)
.	O
y	int
*	O
slopes	*(struct(int,int,double))
[	O
2	int
]	O
.	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dx	int
=	O
(	O
int	O
)	O
(	O
(	O
dx3	double
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dy	int
=	O
(	O
int	O
)	O
(	O
(	O
dy3	double
*	O
65536	int
)	O
/	O
scale	double
)	O
;	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
k	double
=	O
newpoint	struct(double,double)
.	O
x	int
*	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dy	int
-	O
newpoint	struct(double,double)
.	O
y	int
*	O
slopes	*(struct(int,int,double))
[	O
3	int
]	O
.	O
dx	int
;	O
}	O
break	O
;	O
}	O
y	int
=	O
miPolyBuildPoly	(*(struct(double,double)),*(struct(int,int,double)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),*(int),*(int),*(int))->(int)
(	O
vertices	*(struct(double,double))
,	O
slopes	*(struct(int,int,double))
,	O
edgecount	int
,	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
x	int
,	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
y	int
,	O
left	*(struct(int,int,int,int,int,int,int))
,	O
right	*(struct(int,int,int,int,int,int,int))
,	O
&	O
nleft	int
,	O
&	O
nright	int
,	O
&	O
height	int
)	O
;	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
y	int
,	O
height	int
,	O
left	*(struct(int,int,int,int,int,int,int))
,	O
right	*(struct(int,int,int,int,int,int,int))
,	O
nleft	int
,	O
nright	int
)	O
;	O
}	O
static	O
void	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
double	O
xorg	double
,	O
double	O
yorg	double
,	O
bool	enum(int,int)
isInt	enum(int,int)
)	O
{	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
widths	*(int)
;	O
int	O
xorgi	int
=	O
0	int
,	O
yorgi	int
=	O
0	int
;	O
int	O
n	int
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
edge1	*(struct(int,int,int,int,int,int,int))
,	O
edge2	*(struct(int,int,int,int,int,int,int))
;	O
int	O
edgey1	int
,	O
edgey2	int
;	O
bool	enum(int,int)
edgeleft1	enum(int,int)
,	O
edgeleft2	enum(int,int)
;	O
if	O
(	O
isInt	enum(int,int)
)	O
{	O
xorgi	int
=	O
leftFace	*(struct(double,double,int,int,int,int,double))
?	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
x	int
:	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
x	int
;	O
yorgi	int
=	O
leftFace	*(struct(double,double,int,int,int,int,double))
?	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
y	int
:	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
y	int
;	O
}	O
edgey1	int
=	O
INT_MAX	O
;	O
edgey2	int
=	O
INT_MAX	O
;	O
edge1	*(struct(int,int,int,int,int,int,int))
.	O
x	int
=	O
0	int
;	O
edge1	*(struct(int,int,int,int,int,int,int))
.	O
dy	int
=	O
-	O
1	int
;	O
edge2	*(struct(int,int,int,int,int,int,int))
.	O
x	int
=	O
0	int
;	O
edge2	*(struct(int,int,int,int,int,int,int))
.	O
dy	int
=	O
-	O
1	int
;	O
edgeleft1	enum(int,int)
=	O
false	int
;	O
edgeleft2	enum(int,int)
=	O
false	int
;	O
if	O
(	O
(	O
pGC	*(struct)
->	O
lineStyle	int
!=	O
(	O
int	O
)	O
MI_LINE_SOLID	int
||	O
pGC	*(struct)
->	O
lineWidth	int
>	O
2	int
)	O
&&	O
(	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
&&	O
pGC	*(struct)
->	O
joinStyle	int
!=	O
(	O
int	O
)	O
MI_JOIN_ROUND	int
)	O
||	O
(	O
pGC	*(struct)
->	O
joinStyle	int
==	O
(	O
int	O
)	O
MI_JOIN_ROUND	int
&&	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_BUTT	int
)	O
)	O
)	O
{	O
if	O
(	O
isInt	enum(int,int)
)	O
{	O
xorg	double
=	O
(	O
double	O
)	O
xorgi	int
;	O
yorg	double
=	O
(	O
double	O
)	O
yorgi	int
;	O
}	O
if	O
(	O
leftFace	*(struct(double,double,int,int,int,int,double))
&&	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
miRoundJoinClip	(*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),*(int),*(int),*(enum(int,int)),*(enum(int,int)))->(void)
(	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
&	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
&	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
&	O
edgey1	int
,	O
&	O
edgey2	int
,	O
&	O
edgeleft1	enum(int,int)
,	O
&	O
edgeleft2	enum(int,int)
)	O
;	O
else	O
if	O
(	O
leftFace	*(struct(double,double,int,int,int,int,double))
)	O
edgey1	int
=	O
miRoundCapClip	(*(struct(double,double,int,int,int,int,double)),enum(int,int),*(struct(int,int,int,int,int,int,int)),*(enum(int,int)))->(int)
(	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
isInt	enum(int,int)
,	O
&	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
&	O
edgeleft1	enum(int,int)
)	O
;	O
else	O
if	O
(	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
edgey2	int
=	O
miRoundCapClip	(*(struct(double,double,int,int,int,int,double)),enum(int,int),*(struct(int,int,int,int,int,int,int)),*(enum(int,int)))->(int)
(	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
isInt	enum(int,int)
,	O
&	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
&	O
edgeleft2	enum(int,int)
)	O
;	O
isInt	enum(int,int)
=	O
false	int
;	O
}	O
points	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
widths	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
if	O
(	O
isInt	enum(int,int)
)	O
n	int
=	O
miLineArcI	(*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),int,int,*(struct(int,int)),*(int))->(int)
(	O
pGC	*(struct)
,	O
xorgi	int
,	O
yorgi	int
,	O
points	*(struct(int,int))
,	O
widths	*(int)
)	O
;	O
else	O
n	int
=	O
miLineArcD	(*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),double,double,*(struct(int,int)),*(int),*(struct(int,int,int,int,int,int,int)),int,enum(int,int),*(struct(int,int,int,int,int,int,int)),int,enum(int,int))->(int)
(	O
pGC	*(struct)
,	O
xorg	double
,	O
yorg	double
,	O
points	*(struct(int,int))
,	O
widths	*(int)
,	O
&	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
edgey1	int
,	O
edgeleft1	enum(int,int)
,	O
&	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
edgey2	int
,	O
edgeleft2	enum(int,int)
)	O
;	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
n	int
,	O
points	*(struct(int,int))
,	O
widths	*(int)
)	O
}	O
static	O
int	O
miLineArcI	(*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),int,int,*(struct(int,int)),*(int))->(int)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
xorg	double
,	O
int	O
yorg	double
,	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
widths	*(int)
)	O
{	O
miPoint	struct(int,int)
*	O
tpts	*(struct(int,int))
,	O
*	O
bpts	*(struct(int,int))
;	O
unsigned	O
int	O
*	O
twids	*(int)
,	O
*	O
bwids	*(int)
;	O
int	O
x	int
,	O
y	int
,	O
e	int
,	O
ex	int
;	O
int	O
slw	int
;	O
tpts	*(struct(int,int))
=	O
points	*(struct(int,int))
;	O
twids	*(int)
=	O
widths	*(int)
;	O
slw	int
=	O
(	O
int	O
)	O
(	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
if	O
(	O
slw	int
==	O
1	int
)	O
{	O
tpts	*(struct(int,int))
->	O
x	int
=	O
xorg	double
;	O
tpts	*(struct(int,int))
->	O
y	int
=	O
yorg	double
;	O
*	O
twids	*(int)
=	O
1	int
;	O
return	O
1	int
;	O
}	O
bpts	*(struct(int,int))
=	O
tpts	*(struct(int,int))
+	O
slw	int
;	O
bwids	*(int)
=	O
twids	*(int)
+	O
slw	int
;	O
y	int
=	O
(	O
slw	int
>>	O
1	int
)	O
+	O
1	int
;	O
if	O
(	O
slw	int
&	O
1	int
)	O
e	int
=	O
-	O
(	O
(	O
y	int
<<	O
2	int
)	O
+	O
3	int
)	O
;	O
else	O
e	int
=	O
-	O
(	O
y	int
<<	O
3	int
)	O
;	O
ex	int
=	O
-	O
4	int
;	O
x	int
=	O
0	int
;	O
while	O
(	O
y	int
)	O
{	O
e	int
+=	O
(	O
y	int
<<	O
3	int
)	O
-	O
4	int
;	O
while	O
(	O
e	int
>=	O
0	int
)	O
{	O
x	int
++	O
;	O
e	int
+=	O
(	O
ex	int
=	O
-	O
(	O
(	O
x	int
<<	O
3	int
)	O
+	O
4	int
)	O
)	O
;	O
}	O
y	int
--	O
;	O
slw	int
=	O
(	O
x	int
<<	O
1	int
)	O
+	O
1	int
;	O
if	O
(	O
(	O
e	int
==	O
ex	int
)	O
&&	O
(	O
slw	int
>	O
1	int
)	O
)	O
slw	int
--	O
;	O
tpts	*(struct(int,int))
->	O
x	int
=	O
xorg	double
-	O
x	int
;	O
tpts	*(struct(int,int))
->	O
y	int
=	O
yorg	double
-	O
y	int
;	O
tpts	*(struct(int,int))
++	O
;	O
*	O
twids	*(int)
++	O
=	O
slw	int
;	O
if	O
(	O
(	O
y	int
!=	O
0	int
)	O
&&	O
(	O
(	O
slw	int
>	O
1	int
)	O
||	O
(	O
e	int
!=	O
ex	int
)	O
)	O
)	O
{	O
bpts	*(struct(int,int))
--	O
;	O
bpts	*(struct(int,int))
->	O
x	int
=	O
xorg	double
-	O
x	int
;	O
bpts	*(struct(int,int))
->	O
y	int
=	O
yorg	double
+	O
y	int
;	O
*	O
--	O
bwids	*(int)
=	O
slw	int
;	O
}	O
}	O
return	O
(	O
int	O
)	O
(	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
}	O
static	O
int	O
miLineArcD	(*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),double,double,*(struct(int,int)),*(int),*(struct(int,int,int,int,int,int,int)),int,enum(int,int),*(struct(int,int,int,int,int,int,int)),int,enum(int,int))->(int)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
double	O
xorg	double
,	O
double	O
yorg	double
,	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
,	O
unsigned	O
int	O
*	O
widths	*(int)
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
int	O
edgey1	int
,	O
bool	enum(int,int)
edgeleft1	enum(int,int)
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
int	O
edgey2	int
,	O
bool	enum(int,int)
edgeleft2	enum(int,int)
)	O
{	O
miPoint	struct(int,int)
*	O
pts	array(struct(int,int))
;	O
unsigned	O
int	O
*	O
wids	*(int)
;	O
double	O
radius	double
,	O
x0	double
,	O
y0	(double)->(double)
,	O
el	double
,	O
er	double
,	O
yk	double
,	O
xlk	double
,	O
xrk	double
,	O
k	double
;	O
int	O
xbase	int
,	O
ybase	int
,	O
y	int
,	O
boty	int
,	O
xl	int
,	O
xr	int
,	O
xcl	int
,	O
xcr	int
;	O
int	O
ymin	int
,	O
ymax	int
;	O
bool	enum(int,int)
edge1IsMin	enum(int,int)
,	O
edge2IsMin	enum(int,int)
;	O
int	O
ymin1	int
,	O
ymin2	int
;	O
pts	array(struct(int,int))
=	O
points	*(struct(int,int))
;	O
wids	*(int)
=	O
widths	*(int)
;	O
xbase	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
xorg	double
)	O
)	O
;	O
x0	double
=	O
xorg	double
-	O
xbase	int
;	O
ybase	int
=	O
ICEIL	O
(	O
yorg	double
)	O
;	O
y0	(double)->(double)
=	O
yorg	double
-	O
ybase	int
;	O
xlk	double
=	O
x0	double
+	O
x0	double
+	O
1.0	int
;	O
xrk	double
=	O
x0	double
+	O
x0	double
-	O
1.0	int
;	O
yk	double
=	O
y0	(double)->(double)
+	O
y0	(double)->(double)
-	O
1.0	int
;	O
radius	double
=	O
0.5	int
*	O
(	O
(	O
double	O
)	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
y	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
radius	double
-	O
y0	(double)->(double)
+	O
1.0	int
)	O
)	O
;	O
ybase	int
-=	O
y	int
;	O
ymin	int
=	O
ybase	int
;	O
ymax	int
=	O
INT_MAX	O
;	O
edge1IsMin	enum(int,int)
=	O
false	int
;	O
ymin1	int
=	O
edgey1	int
;	O
if	O
(	O
edge1	*(struct(int,int,int,int,int,int,int))
->	O
dy	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
edge1	*(struct(int,int,int,int,int,int,int))
->	O
dy	int
)	O
{	O
if	O
(	O
edgeleft1	enum(int,int)
)	O
edge1IsMin	enum(int,int)
=	O
true	int
;	O
else	O
ymax	int
=	O
edgey1	int
;	O
edgey1	int
=	O
INT_MAX	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
edge1	*(struct(int,int,int,int,int,int,int))
->	O
signdx	int
<	O
0	int
)	O
==	O
edgeleft1	enum(int,int)
)	O
edge1IsMin	enum(int,int)
=	O
true	int
;	O
}	O
}	O
edge2IsMin	enum(int,int)
=	O
false	int
;	O
ymin2	int
=	O
edgey2	int
;	O
if	O
(	O
edge2	*(struct(int,int,int,int,int,int,int))
->	O
dy	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
edge2	*(struct(int,int,int,int,int,int,int))
->	O
dy	int
)	O
{	O
if	O
(	O
edgeleft2	enum(int,int)
)	O
edge2IsMin	enum(int,int)
=	O
true	int
;	O
else	O
ymax	int
=	O
edgey2	int
;	O
edgey2	int
=	O
INT_MAX	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
edge2	*(struct(int,int,int,int,int,int,int))
->	O
signdx	int
<	O
0	int
)	O
==	O
edgeleft2	enum(int,int)
)	O
edge2IsMin	enum(int,int)
=	O
true	int
;	O
}	O
}	O
if	O
(	O
edge1IsMin	enum(int,int)
)	O
{	O
ymin	int
=	O
ymin1	int
;	O
if	O
(	O
edge2IsMin	enum(int,int)
&&	O
ymin1	int
>	O
ymin2	int
)	O
ymin	int
=	O
ymin2	int
;	O
}	O
else	O
if	O
(	O
edge2IsMin	enum(int,int)
)	O
ymin	int
=	O
ymin2	int
;	O
el	double
=	O
radius	double
*	O
radius	double
-	O
(	O
(	O
y	int
+	O
y0	(double)->(double)
)	O
*	O
(	O
y	int
+	O
y0	(double)->(double)
)	O
)	O
-	O
(	O
x0	double
*	O
x0	double
)	O
;	O
er	double
=	O
el	double
+	O
xrk	double
;	O
xl	int
=	O
1	int
;	O
xr	int
=	O
0	int
;	O
if	O
(	O
x0	double
<	O
0.5	int
)	O
{	O
xl	int
=	O
0	int
;	O
el	double
-=	O
xlk	double
;	O
}	O
boty	int
=	O
(	O
y0	(double)->(double)
<	O
-	O
0.5	int
)	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
ybase	int
+	O
y	int
-	O
boty	int
>	O
ymax	int
)	O
boty	int
=	O
ymax	int
-	O
ybase	int
-	O
y	int
;	O
while	O
(	O
y	int
>	O
boty	int
)	O
{	O
k	double
=	O
(	O
y	int
<<	O
1	int
)	O
+	O
yk	double
;	O
er	double
+=	O
k	double
;	O
while	O
(	O
er	double
>	O
0.0	int
)	O
{	O
xr	int
++	O
;	O
er	double
+=	O
xrk	double
-	O
(	O
xr	int
<<	O
1	int
)	O
;	O
}	O
el	double
+=	O
k	double
;	O
while	O
(	O
el	double
>=	O
0.0	int
)	O
{	O
xl	int
--	O
;	O
el	double
+=	O
(	O
xl	int
<<	O
1	int
)	O
-	O
xlk	double
;	O
}	O
y	int
--	O
;	O
ybase	int
++	O
;	O
if	O
(	O
ybase	int
<	O
ymin	int
)	O
continue	O
;	O
xcl	int
=	O
xl	int
+	O
xbase	int
;	O
xcr	int
=	O
xr	int
+	O
xbase	int
;	O
CLIPSTEPEDGE	O
(	O
edgey1	int
,	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
edgeleft1	enum(int,int)
)	O
;	O
CLIPSTEPEDGE	O
(	O
edgey2	int
,	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
edgeleft2	enum(int,int)
)	O
;	O
if	O
(	O
xcr	int
>=	O
xcl	int
)	O
{	O
pts	array(struct(int,int))
->	O
x	int
=	O
xcl	int
;	O
pts	array(struct(int,int))
->	O
y	int
=	O
ybase	int
;	O
pts	array(struct(int,int))
++	O
;	O
*	O
wids	*(int)
++	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
xcr	int
-	O
xcl	int
+	O
1	int
)	O
;	O
}	O
}	O
er	double
=	O
xrk	double
-	O
(	O
xr	int
<<	O
1	int
)	O
-	O
er	double
;	O
el	double
=	O
(	O
xl	int
<<	O
1	int
)	O
-	O
xlk	double
-	O
el	double
;	O
boty	int
=	O
(	O
int	O
)	O
(	O
floor	(double)->(double)
(	O
-	O
y0	(double)->(double)
-	O
radius	double
+	O
1.0	int
)	O
)	O
;	O
if	O
(	O
ybase	int
+	O
y	int
-	O
boty	int
>	O
ymax	int
)	O
boty	int
=	O
ymax	int
-	O
ybase	int
-	O
y	int
;	O
while	O
(	O
y	int
>	O
boty	int
)	O
{	O
k	double
=	O
(	O
y	int
<<	O
1	int
)	O
+	O
yk	double
;	O
er	double
-=	O
k	double
;	O
while	O
(	O
(	O
er	double
>=	O
0.0	int
)	O
&&	O
(	O
xr	int
>=	O
0	int
)	O
)	O
{	O
xr	int
--	O
;	O
er	double
+=	O
xrk	double
-	O
(	O
xr	int
<<	O
1	int
)	O
;	O
}	O
el	double
-=	O
k	double
;	O
while	O
(	O
(	O
el	double
>	O
0.0	int
)	O
&&	O
(	O
xl	int
<=	O
0	int
)	O
)	O
{	O
xl	int
++	O
;	O
el	double
+=	O
(	O
xl	int
<<	O
1	int
)	O
-	O
xlk	double
;	O
}	O
y	int
--	O
;	O
ybase	int
++	O
;	O
if	O
(	O
ybase	int
<	O
ymin	int
)	O
continue	O
;	O
xcl	int
=	O
xl	int
+	O
xbase	int
;	O
xcr	int
=	O
xr	int
+	O
xbase	int
;	O
CLIPSTEPEDGE	O
(	O
edgey1	int
,	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
edgeleft1	enum(int,int)
)	O
;	O
CLIPSTEPEDGE	O
(	O
edgey2	int
,	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
edgeleft2	enum(int,int)
)	O
;	O
if	O
(	O
xcr	int
>=	O
xcl	int
)	O
{	O
pts	array(struct(int,int))
->	O
x	int
=	O
xcl	int
;	O
pts	array(struct(int,int))
->	O
y	int
=	O
ybase	int
;	O
pts	array(struct(int,int))
++	O
;	O
*	O
wids	*(int)
++	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
xcr	int
-	O
xcl	int
+	O
1	int
)	O
;	O
}	O
}	O
return	O
(	O
pts	array(struct(int,int))
-	O
points	*(struct(int,int))
)	O
;	O
}	O
static	O
void	O
miRoundJoinClip	(*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),*(int),*(int),*(enum(int,int)),*(enum(int,int)))->(void)
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
pLeft	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
pRight	*(struct(double,double,int,int,int,int,double))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
int	O
*	O
y1	(double)->(double)
,	O
int	O
*	O
y2	int
,	O
bool	enum(int,int)
*	O
left1	*(enum(int,int))
,	O
bool	enum(int,int)
*	O
left2	*(enum(int,int))
)	O
{	O
int	O
denom	int
;	O
denom	int
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
*	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
+	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
*	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
if	O
(	O
denom	int
>=	O
0	int
)	O
{	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
-	O
pLeft	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
}	O
else	O
{	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
-	O
pRight	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
}	O
*	O
y1	(double)->(double)
=	O
miRoundJoinFace	(*(struct(double,double,int,int,int,int,double)),*(struct(int,int,int,int,int,int,int)),*(enum(int,int)))->(int)
(	O
pLeft	*(struct(double,double,int,int,int,int,double))
,	O
edge1	*(struct(int,int,int,int,int,int,int))
,	O
left1	*(enum(int,int))
)	O
;	O
*	O
y2	int
=	O
miRoundJoinFace	(*(struct(double,double,int,int,int,int,double)),*(struct(int,int,int,int,int,int,int)),*(enum(int,int)))->(int)
(	O
pRight	*(struct(double,double,int,int,int,int,double))
,	O
edge2	*(struct(int,int,int,int,int,int,int))
,	O
left2	*(enum(int,int))
)	O
;	O
}	O
static	O
int	O
miRoundJoinFace	(*(struct(double,double,int,int,int,int,double)),*(struct(int,int,int,int,int,int,int)),*(enum(int,int)))->(int)
(	O
const	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
face	*(struct(double,double,int,int,int,int,double))
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int,int))
,	O
bool	enum(int,int)
*	O
leftEdge	*(enum(int,int))
)	O
{	O
int	O
y	int
;	O
int	O
dx	int
,	O
dy	int
;	O
double	O
xa	double
,	O
ya	double
;	O
bool	enum(int,int)
left	*(struct(int,int,int,int,int,int,int))
;	O
dx	int
=	O
-	O
face	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
dy	int
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
xa	double
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
ya	double
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
left	*(struct(int,int,int,int,int,int,int))
=	O
true	int
;	O
if	O
(	O
ya	double
>	O
0	int
)	O
{	O
ya	double
=	O
0.0	int
;	O
xa	double
=	O
0.0	int
;	O
}	O
if	O
(	O
dy	int
<	O
0	int
||	O
(	O
dy	int
==	O
0	int
&&	O
dx	int
>	O
0	int
)	O
)	O
{	O
dx	int
=	O
-	O
dx	int
;	O
dy	int
=	O
-	O
dy	int
;	O
left	*(struct(int,int,int,int,int,int,int))
=	O
(	O
left	*(struct(int,int,int,int,int,int,int))
?	O
false	int
:	O
true	int
)	O
;	O
}	O
if	O
(	O
dx	int
==	O
0	int
&&	O
dy	int
==	O
0	int
)	O
dy	int
=	O
1	int
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
y	int
=	O
ICEIL	O
(	O
face	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
)	O
+	O
face	*(struct(double,double,int,int,int,int,double))
->	O
y	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
x	int
=	O
INT_MIN	O
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
stepx	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
signdx	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
e	int
=	O
-	O
1	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
dy	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
dx	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
0	int
;	O
}	O
else	O
{	O
y	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
dx	int
,	O
dy	int
,	O
face	*(struct(double,double,int,int,int,int,double))
->	O
x	int
,	O
face	*(struct(double,double,int,int,int,int,double))
->	O
y	int
,	O
(	O
left	*(struct(int,int,int,int,int,int,int))
?	O
false	int
:	O
true	int
)	O
,	O
edge	*(struct(int,int,int,int,int,int,int))
)	O
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
UINT_MAX	O
;	O
}	O
*	O
leftEdge	*(enum(int,int))
=	O
(	O
left	*(struct(int,int,int,int,int,int,int))
?	O
false	int
:	O
true	int
)	O
;	O
return	O
y	int
;	O
}	O
static	O
int	O
miRoundCapClip	(*(struct(double,double,int,int,int,int,double)),enum(int,int),*(struct(int,int,int,int,int,int,int)),*(enum(int,int)))->(int)
(	O
const	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
face	*(struct(double,double,int,int,int,int,double))
,	O
bool	enum(int,int)
isInt	enum(int,int)
,	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
edge	*(struct(int,int,int,int,int,int,int))
,	O
bool	enum(int,int)
*	O
leftEdge	*(enum(int,int))
)	O
{	O
int	O
y	int
;	O
int	O
dx	int
,	O
dy	int
;	O
double	O
xa	double
,	O
ya	double
,	O
k	double
;	O
bool	enum(int,int)
left	*(struct(int,int,int,int,int,int,int))
;	O
dx	int
=	O
-	O
face	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
dy	int
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
xa	double
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
ya	double
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
k	double
=	O
0.0	int
;	O
if	O
(	O
!	O
isInt	enum(int,int)
)	O
k	double
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
k	double
;	O
left	*(struct(int,int,int,int,int,int,int))
=	O
true	int
;	O
if	O
(	O
dy	int
<	O
0	int
||	O
(	O
dy	int
==	O
0	int
&&	O
dx	int
>	O
0	int
)	O
)	O
{	O
dx	int
=	O
-	O
dx	int
;	O
dy	int
=	O
-	O
dy	int
;	O
xa	double
=	O
-	O
xa	double
;	O
ya	double
=	O
-	O
ya	double
;	O
left	*(struct(int,int,int,int,int,int,int))
=	O
(	O
left	*(struct(int,int,int,int,int,int,int))
?	O
false	int
:	O
true	int
)	O
;	O
}	O
if	O
(	O
dx	int
==	O
0	int
&&	O
dy	int
==	O
0	int
)	O
dy	int
=	O
1	int
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
y	int
=	O
ICEIL	O
(	O
face	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
)	O
+	O
face	*(struct(double,double,int,int,int,int,double))
->	O
y	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
x	int
=	O
INT_MIN	O
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
stepx	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
signdx	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
e	int
=	O
-	O
1	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
dy	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
dx	int
=	O
0	int
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
0	int
;	O
}	O
else	O
{	O
y	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
face	*(struct(double,double,int,int,int,int,double))
->	O
x	int
,	O
face	*(struct(double,double,int,int,int,int,double))
->	O
y	int
,	O
(	O
left	*(struct(int,int,int,int,int,int,int))
?	O
false	int
:	O
true	int
)	O
,	O
edge	*(struct(int,int,int,int,int,int,int))
)	O
;	O
edge	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
UINT_MAX	O
;	O
}	O
*	O
leftEdge	*(enum(int,int))
=	O
(	O
left	*(struct(int,int,int,int,int,int,int))
?	O
false	int
:	O
true	int
)	O
;	O
return	O
y	int
;	O
}	O
static	O
void	O
miLineProjectingCap	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),enum(int,int),enum(int,int))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
face	*(struct(double,double,int,int,int,int,double))
,	O
bool	enum(int,int)
isLeft	enum(int,int)
,	O
bool	enum(int,int)
isInt	enum(int,int)
)	O
{	O
int	O
dx	int
,	O
dy	int
;	O
int	O
topy	int
,	O
bottomy	int
;	O
int	O
xorgi	int
=	O
0	int
,	O
yorgi	int
=	O
0	int
;	O
int	O
lw	int
=	O
(	O
int	O
)	O
(	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
lefts	array(struct(int,int,int,int,int,int,int))
[	O
2	int
]	O
,	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
2	int
]	O
;	O
if	O
(	O
isInt	enum(int,int)
)	O
{	O
xorgi	int
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
x	int
;	O
yorgi	int
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
y	int
;	O
}	O
dx	int
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
;	O
dy	int
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
lw	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
x	int
=	O
xorgi	int
;	O
if	O
(	O
isLeft	enum(int,int)
)	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
x	int
-=	O
(	O
lw	int
>>	O
1	int
)	O
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
stepx	int
=	O
0	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
signdx	int
=	O
1	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
e	int
=	O
-	O
lw	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
dx	int
=	O
0	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
dy	int
=	O
lw	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
lw	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
x	int
=	O
xorgi	int
;	O
if	O
(	O
!	O
isLeft	enum(int,int)
)	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
x	int
+=	O
(	O
(	O
lw	int
+	O
1	int
)	O
>>	O
1	int
)	O
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
stepx	int
=	O
0	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
signdx	int
=	O
1	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
e	int
=	O
-	O
lw	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
dx	int
=	O
0	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
dy	int
=	O
lw	int
;	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
yorgi	int
-	O
(	O
lw	int
>>	O
1	int
)	O
,	O
(	O
unsigned	O
int	O
)	O
lw	int
,	O
lefts	array(struct(int,int,int,int,int,int,int))
,	O
rights	array(struct(int,int,int,int,int,int,int))
,	O
1	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
topy	int
=	O
yorgi	int
;	O
bottomy	int
=	O
yorgi	int
+	O
dy	int
;	O
if	O
(	O
isLeft	enum(int,int)
)	O
topy	int
-=	O
(	O
lw	int
>>	O
1	int
)	O
;	O
else	O
bottomy	int
+=	O
(	O
lw	int
>>	O
1	int
)	O
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
topy	int
)	O
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
x	int
=	O
xorgi	int
-	O
(	O
lw	int
>>	O
1	int
)	O
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
stepx	int
=	O
0	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
signdx	int
=	O
1	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
e	int
=	O
-	O
dy	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
dx	int
=	O
dx	int
;	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
dy	int
=	O
dy	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
topy	int
)	O
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
x	int
=	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
x	int
+	O
(	O
lw	int
-	O
1	int
)	O
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
stepx	int
=	O
0	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
signdx	int
=	O
1	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
e	int
=	O
-	O
dy	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
dx	int
=	O
dx	int
;	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
.	O
dy	int
=	O
dy	int
;	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
topy	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
topy	int
)	O
,	O
lefts	array(struct(int,int,int,int,int,int,int))
,	O
rights	array(struct(int,int,int,int,int,int,int))
,	O
1	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
int	O
lefty	int
,	O
righty	int
;	O
int	O
finaly	int
;	O
double	O
xa	double
,	O
ya	double
;	O
double	O
xap	double
,	O
yap	double
;	O
double	O
maxy	double
;	O
double	O
projectXoff	double
,	O
projectYoff	double
;	O
double	O
k	double
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
left	*(struct(int,int,int,int,int,int,int))
,	O
*	O
right	*(struct(int,int,int,int,int,int,int))
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
top	int
,	O
*	O
bottom	int
;	O
k	double
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
k	double
;	O
xa	double
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
ya	double
=	O
face	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
projectXoff	double
=	O
-	O
ya	double
;	O
projectYoff	double
=	O
xa	double
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
right	*(struct(int,int,int,int,int,int,int))
=	O
&	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
left	*(struct(int,int,int,int,int,int,int))
=	O
&	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
top	int
=	O
&	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
bottom	int
=	O
&	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
}	O
else	O
{	O
right	*(struct(int,int,int,int,int,int,int))
=	O
&	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
left	*(struct(int,int,int,int,int,int,int))
=	O
&	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
top	int
=	O
&	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
bottom	int
=	O
&	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
}	O
if	O
(	O
isLeft	enum(int,int)
)	O
{	O
righty	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
xorgi	int
,	O
yorgi	int
,	O
false	int
,	O
right	*(struct(int,int,int,int,int,int,int))
)	O
;	O
xa	double
=	O
-	O
xa	double
;	O
ya	double
=	O
-	O
ya	double
;	O
k	double
=	O
-	O
k	double
;	O
lefty	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
-	O
projectXoff	double
,	O
ya	double
-	O
projectYoff	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
xorgi	int
,	O
yorgi	int
,	O
true	int
,	O
left	*(struct(int,int,int,int,int,int,int))
)	O
;	O
if	O
(	O
dx	int
>	O
0	int
)	O
{	O
ya	double
=	O
-	O
ya	double
;	O
xa	double
=	O
-	O
xa	double
;	O
}	O
xap	double
=	O
xa	double
-	O
projectXoff	double
;	O
yap	double
=	O
ya	double
-	O
projectYoff	double
;	O
topy	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xap	double
,	O
yap	double
,	O
xap	double
*	O
dx	int
+	O
yap	double
*	O
dy	int
,	O
-	O
dy	int
,	O
dx	int
,	O
xorgi	int
,	O
yorgi	int
,	O
(	O
dx	int
>	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
top	int
)	O
;	O
bottomy	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
-	O
dy	int
,	O
dx	int
,	O
xorgi	int
,	O
yorgi	int
,	O
(	O
dx	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
bottom	int
)	O
;	O
maxy	double
=	O
-	O
ya	double
;	O
}	O
else	O
{	O
righty	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
-	O
projectXoff	double
,	O
ya	double
-	O
projectYoff	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
xorgi	int
,	O
yorgi	int
,	O
false	int
,	O
right	*(struct(int,int,int,int,int,int,int))
)	O
;	O
xa	double
=	O
-	O
xa	double
;	O
ya	double
=	O
-	O
ya	double
;	O
k	double
=	O
-	O
k	double
;	O
lefty	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
xorgi	int
,	O
yorgi	int
,	O
true	int
,	O
left	*(struct(int,int,int,int,int,int,int))
)	O
;	O
if	O
(	O
dx	int
>	O
0	int
)	O
{	O
ya	double
=	O
-	O
ya	double
;	O
xa	double
=	O
-	O
xa	double
;	O
}	O
xap	double
=	O
xa	double
-	O
projectXoff	double
;	O
yap	double
=	O
ya	double
-	O
projectYoff	double
;	O
topy	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
-	O
dy	int
,	O
dx	int
,	O
xorgi	int
,	O
xorgi	int
,	O
(	O
dx	int
>	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
top	int
)	O
;	O
bottomy	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xap	double
,	O
yap	double
,	O
xap	double
*	O
dx	int
+	O
yap	double
*	O
dy	int
,	O
-	O
dy	int
,	O
dx	int
,	O
xorgi	int
,	O
xorgi	int
,	O
(	O
dx	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
bottom	int
)	O
;	O
maxy	double
=	O
-	O
ya	double
+	O
projectYoff	double
;	O
}	O
finaly	int
=	O
ICEIL	O
(	O
maxy	double
)	O
+	O
yorgi	int
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
left	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
lefty	int
)	O
;	O
right	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
righty	int
)	O
;	O
top	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
righty	int
-	O
topy	int
)	O
;	O
}	O
else	O
{	O
right	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
righty	int
)	O
;	O
left	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
lefty	int
)	O
;	O
top	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
lefty	int
-	O
topy	int
)	O
;	O
}	O
bottom	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
bottomy	int
)	O
;	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
topy	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
bottom	int
->	O
height	int
+	O
bottomy	int
-	O
topy	int
)	O
,	O
lefts	array(struct(int,int,int,int,int,int,int))
,	O
rights	array(struct(int,int,int,int,int,int,int))
,	O
2	int
,	O
2	int
)	O
;	O
}	O
}	O
void	O
miWideDash	O
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
miCoordMode	enum(int,int)
mode	enum(int,int)
,	O
int	O
npt	int
,	O
const	O
miPoint	struct(int,int)
*	O
pPts	*(struct(int,int))
)	O
{	O
int	O
x1	int
,	O
y1	(double)->(double)
,	O
x2	int
,	O
y2	int
;	O
int	O
dashNum	int
;	O
int	O
dashIndex	int
;	O
int	O
dashOffset	int
;	O
int	O
startPaintType	int
,	O
endPaintType	int
=	O
0	int
,	O
prevEndPaintType	int
=	O
0	int
;	O
int	O
firstPaintType	int
=	O
0	int
;	O
int	O
numPixels	int
;	O
bool	enum(int,int)
selfJoin	enum(int,int)
;	O
bool	enum(int,int)
first	enum(int,int)
;	O
bool	enum(int,int)
somethingDrawn	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
projectLeft	enum(int,int)
,	O
projectRight	enum(int,int)
;	O
LineFace	struct(double,double,int,int,int,int,double)
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
prevRightFace	struct(double,double,int,int,int,int,double)
;	O
LineFace	struct(double,double,int,int,int,int,double)
firstFace	struct(double,double,int,int,int,int,double)
;	O
miPixel	int
pixel	int
;	O
if	O
(	O
npt	int
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
pGC	*(struct)
->	O
lineWidth	int
==	O
0	int
)	O
{	O
miZeroDash	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
,	O
mode	enum(int,int)
,	O
npt	int
,	O
pPts	*(struct(int,int))
)	O
;	O
return	O
;	O
}	O
x2	int
=	O
pPts	*(struct(int,int))
->	O
x	int
;	O
y2	int
=	O
pPts	*(struct(int,int))
->	O
y	int
;	O
first	enum(int,int)
=	O
true	int
;	O
selfJoin	enum(int,int)
=	O
false	int
;	O
if	O
(	O
mode	enum(int,int)
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
int	O
nptTmp	int
;	O
const	O
miPoint	struct(int,int)
*	O
pPtsTmp	*(struct(int,int))
;	O
x1	int
=	O
x2	int
;	O
y1	(double)->(double)
=	O
y2	int
;	O
nptTmp	int
=	O
npt	int
;	O
pPtsTmp	*(struct(int,int))
=	O
pPts	*(struct(int,int))
+	O
1	int
;	O
while	O
(	O
--	O
nptTmp	int
)	O
{	O
x1	int
+=	O
pPtsTmp	*(struct(int,int))
->	O
x	int
;	O
y1	(double)->(double)
+=	O
pPtsTmp	*(struct(int,int))
->	O
y	int
;	O
++	O
pPtsTmp	*(struct(int,int))
;	O
}	O
if	O
(	O
x2	int
==	O
x1	int
&&	O
y2	int
==	O
y1	(double)->(double)
)	O
selfJoin	enum(int,int)
=	O
true	int
;	O
}	O
else	O
if	O
(	O
x2	int
==	O
pPts	*(struct(int,int))
[	O
npt	int
-	O
1	int
]	O
.	O
x	int
&&	O
y2	int
==	O
pPts	*(struct(int,int))
[	O
npt	int
-	O
1	int
]	O
.	O
y	int
)	O
selfJoin	enum(int,int)
=	O
true	int
;	O
projectLeft	enum(int,int)
=	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
&&	O
!	O
selfJoin	enum(int,int)
)	O
?	O
true	int
:	O
false	int
;	O
projectRight	enum(int,int)
=	O
false	int
;	O
dashNum	int
=	O
0	int
;	O
dashIndex	int
=	O
0	int
;	O
dashOffset	int
=	O
0	int
;	O
miStepDash	O
(	O
pGC	*(struct)
->	O
dashOffset	int
,	O
&	O
dashNum	int
,	O
&	O
dashIndex	int
,	O
pGC	*(struct)
->	O
dash	*(int)
,	O
pGC	*(struct)
->	O
numInDashList	int
,	O
&	O
dashOffset	int
)	O
;	O
numPixels	int
=	O
pGC	*(struct)
->	O
numPixels	int
;	O
while	O
(	O
--	O
npt	int
)	O
{	O
x1	int
=	O
x2	int
;	O
y1	(double)->(double)
=	O
y2	int
;	O
++	O
pPts	*(struct(int,int))
;	O
x2	int
=	O
pPts	*(struct(int,int))
->	O
x	int
;	O
y2	int
=	O
pPts	*(struct(int,int))
->	O
y	int
;	O
if	O
(	O
mode	enum(int,int)
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
x2	int
+=	O
x1	int
;	O
y2	int
+=	O
y1	(double)->(double)
;	O
}	O
if	O
(	O
x1	int
!=	O
x2	int
||	O
y1	(double)->(double)
!=	O
y2	int
)	O
{	O
int	O
prevDashNum	int
,	O
lastPaintedDashNum	int
;	O
if	O
(	O
npt	int
==	O
1	int
&&	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
&&	O
(	O
!	O
selfJoin	enum(int,int)
||	O
(	O
firstPaintType	int
==	O
0	int
)	O
)	O
)	O
projectRight	enum(int,int)
=	O
true	int
;	O
prevDashNum	int
=	O
dashNum	int
;	O
miWideDashSegment	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(int),*(int),*(int),int,int,int,int,enum(int,int),enum(int,int),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
,	O
&	O
dashNum	int
,	O
&	O
dashIndex	int
,	O
&	O
dashOffset	int
,	O
x1	int
,	O
y1	(double)->(double)
,	O
x2	int
,	O
y2	int
,	O
projectLeft	enum(int,int)
,	O
projectRight	enum(int,int)
,	O
&	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
&	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
;	O
startPaintType	int
=	O
(	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
)	O
;	O
lastPaintedDashNum	int
=	O
(	O
dashOffset	int
!=	O
0	int
?	O
dashNum	int
:	O
dashNum	int
-	O
1	int
)	O
;	O
endPaintType	int
=	O
(	O
(	O
lastPaintedDashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
)	O
;	O
if	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
(	O
startPaintType	int
!=	O
0	int
)	O
)	O
{	O
pixel	int
=	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
startPaintType	int
]	O
;	O
if	O
(	O
first	enum(int,int)
||	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
&&	O
prevEndPaintType	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
first	enum(int,int)
&&	O
selfJoin	enum(int,int)
)	O
{	O
firstFace	struct(double,double,int,int,int,int,double)
=	O
leftFace	*(struct(double,double,int,int,int,int,double))
;	O
firstPaintType	int
=	O
startPaintType	int
;	O
}	O
else	O
if	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
&	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
else	O
miLineJoin	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
&	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
&	O
prevRightFace	struct(double,double,int,int,int,int,double)
)	O
;	O
}	O
somethingDrawn	enum(int,int)
=	O
true	int
;	O
first	enum(int,int)
=	O
false	int
;	O
prevRightFace	struct(double,double,int,int,int,int,double)
=	O
rightFace	*(struct(double,double,int,int,int,int,double))
;	O
prevEndPaintType	int
=	O
endPaintType	int
;	O
projectLeft	enum(int,int)
=	O
false	int
;	O
}	O
if	O
(	O
npt	int
==	O
1	int
&&	O
somethingDrawn	enum(int,int)
)	O
{	O
if	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
(	O
endPaintType	int
!=	O
0	int
)	O
)	O
{	O
pixel	int
=	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
endPaintType	int
]	O
;	O
if	O
(	O
selfJoin	enum(int,int)
&&	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
(	O
firstPaintType	int
!=	O
0	int
)	O
)	O
)	O
miLineJoin	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
&	O
firstFace	struct(double,double,int,int,int,int,double)
,	O
&	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
;	O
else	O
{	O
if	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
&	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
selfJoin	enum(int,int)
&&	O
(	O
firstPaintType	int
!=	O
0	int
)	O
)	O
{	O
pixel	int
=	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
firstPaintType	int
]	O
;	O
if	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
)	O
miLineProjectingCap	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),enum(int,int),enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
&	O
firstFace	struct(double,double,int,int,int,int,double)
,	O
true	int
,	O
true	int
)	O
;	O
else	O
if	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
&	O
firstFace	struct(double,double,int,int,int,int,double)
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
somethingDrawn	enum(int,int)
&&	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
!	O
(	O
dashNum	int
&	O
1	int
)	O
)	O
)	O
{	O
unsigned	O
int	O
w1	int
;	O
pixel	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
0	int
]	O
:	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
;	O
switch	O
(	O
(	O
int	O
)	O
pGC	*(struct)
->	O
capStyle	int
)	O
{	O
case	O
(	O
int	O
)	O
MI_CAP_ROUND	int
:	O
case	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
:	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
x2	int
,	O
(	O
double	O
)	O
y2	int
,	O
false	int
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
:	O
w1	int
=	O
pGC	*(struct)
->	O
lineWidth	int
;	O
miFillRectPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
(	O
int	O
)	O
(	O
x2	int
-	O
(	O
w1	int
>>	O
1	int
)	O
)	O
,	O
(	O
int	O
)	O
(	O
y2	int
-	O
(	O
w1	int
>>	O
1	int
)	O
)	O
,	O
w1	int
,	O
w1	int
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_CAP_BUTT	int
:	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
miWideDashSegment	(*(struct(*(*(struct`)),int,int)),*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(int),*(int),*(int),int,int,int,int,enum(int,int),enum(int,int),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
*	O
pDashNum	*(int)
,	O
int	O
*	O
pDashIndex	*(int)
,	O
int	O
*	O
pDashOffset	*(int)
,	O
int	O
x1	int
,	O
int	O
y1	(double)->(double)
,	O
int	O
x2	int
,	O
int	O
y2	int
,	O
bool	enum(int,int)
projectLeft	enum(int,int)
,	O
bool	enum(int,int)
projectRight	enum(int,int)
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
{	O
int	O
dashNum	int
,	O
dashIndex	int
,	O
dashRemain	int
;	O
unsigned	O
int	O
*	O
pDash	*(int)
;	O
double	O
L	double
,	O
l	double
;	O
double	O
k	double
;	O
PolyVertex	struct(double,double)
vertices	*(struct(double,double))
[	O
4	int
]	O
;	O
PolyVertex	struct(double,double)
saveRight	struct(double,double)
,	O
saveBottom	struct(double,double)
;	O
PolySlope	struct(int,int,double)
slopes	*(struct(int,int,double))
[	O
4	int
]	O
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
left	*(struct(int,int,int,int,int,int,int))
[	O
2	int
]	O
,	O
right	*(struct(int,int,int,int,int,int,int))
[	O
2	int
]	O
;	O
LineFace	struct(double,double,int,int,int,int,double)
lcapFace	struct(double,double,int,int,int,int,double)
,	O
rcapFace	struct(double,double,int,int,int,int,double)
;	O
int	O
nleft	int
,	O
nright	int
;	O
unsigned	O
int	O
h	int
;	O
int	O
y	int
;	O
int	O
dy	int
,	O
dx	int
;	O
double	O
LRemain	double
;	O
double	O
r	double
;	O
double	O
rdx	double
,	O
rdy	double
;	O
double	O
dashDx	double
,	O
dashDy	double
;	O
double	O
saveK	double
=	O
0.0	int
;	O
bool	enum(int,int)
first	enum(int,int)
=	O
true	int
;	O
double	O
lcenterx	double
,	O
lcentery	double
,	O
rcenterx	double
=	O
0.0	int
,	O
rcentery	double
=	O
0.0	int
;	O
miPixel	int
pixel	int
;	O
int	O
numPixels	int
,	O
paintType	int
;	O
dx	int
=	O
x2	int
-	O
x1	int
;	O
dy	int
=	O
y2	int
-	O
y1	(double)->(double)
;	O
dashNum	int
=	O
*	O
pDashNum	*(int)
;	O
dashIndex	int
=	O
*	O
pDashIndex	*(int)
;	O
pDash	*(int)
=	O
pGC	*(struct)
->	O
dash	*(int)
;	O
dashRemain	int
=	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
dashIndex	int
]	O
)	O
-	O
*	O
pDashOffset	*(int)
;	O
numPixels	int
=	O
pGC	*(struct)
->	O
numPixels	int
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
pixel	int
=	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
paintType	int
]	O
;	O
l	double
=	O
0.5	int
*	O
(	O
(	O
double	O
)	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
L	double
=	O
dy	int
;	O
rdx	double
=	O
0	int
;	O
rdy	double
=	O
l	double
;	O
if	O
(	O
dy	int
<	O
0	int
)	O
{	O
L	double
=	O
-	O
dy	int
;	O
rdy	double
=	O
-	O
l	double
;	O
}	O
}	O
else	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
L	double
=	O
dx	int
;	O
rdx	double
=	O
l	double
;	O
rdy	double
=	O
0	int
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
L	double
=	O
-	O
dx	int
;	O
rdx	double
=	O
-	O
l	double
;	O
}	O
}	O
else	O
{	O
L	double
=	O
hypot	(double,double)->(double)
(	O
(	O
double	O
)	O
dx	int
,	O
(	O
double	O
)	O
dy	int
)	O
;	O
r	double
=	O
l	double
/	O
L	double
;	O
rdx	double
=	O
r	double
*	O
dx	int
;	O
rdy	double
=	O
r	double
*	O
dy	int
;	O
}	O
k	double
=	O
l	double
*	O
L	double
;	O
slopes	*(struct(int,int,double))
[	O
V_TOP	int
]	O
.	O
dx	int
=	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
V_TOP	int
]	O
.	O
dy	int
=	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
V_TOP	int
]	O
.	O
k	double
=	O
k	double
;	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
dx	int
=	O
-	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
dy	int
=	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
0	int
;	O
slopes	*(struct(int,int,double))
[	O
V_BOTTOM	int
]	O
.	O
dx	int
=	O
-	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
V_BOTTOM	int
]	O
.	O
dy	int
=	O
-	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
V_BOTTOM	int
]	O
.	O
k	double
=	O
k	double
;	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
dx	int
=	O
dy	int
;	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
dy	int
=	O
-	O
dx	int
;	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
0	int
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
=	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
x	int
=	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
=	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
y	int
=	O
-	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
x	int
=	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
=	O
-	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
y	int
=	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
=	O
rdx	double
;	O
if	O
(	O
projectLeft	enum(int,int)
)	O
{	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
x	int
-=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
y	int
-=	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
-=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
-=	O
rdy	double
;	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
rdx	double
*	O
dx	int
+	O
rdy	double
*	O
dy	int
;	O
}	O
lcenterx	double
=	O
x1	int
;	O
lcentery	double
=	O
y1	(double)->(double)
;	O
if	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
{	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
dx	int
=	O
dx	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
dy	int
=	O
dy	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
x	int
=	O
x1	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
y	int
=	O
y1	(double)->(double)
;	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
dx	int
=	O
-	O
dx	int
;	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
dy	int
=	O
-	O
dy	int
;	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
x	int
=	O
x1	int
;	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
y	int
=	O
y1	(double)->(double)
;	O
}	O
LRemain	double
=	O
L	double
;	O
while	O
(	O
LRemain	double
>	O
dashRemain	int
)	O
{	O
dashDx	double
=	O
(	O
dashRemain	int
*	O
dx	int
)	O
/	O
L	double
;	O
dashDy	double
=	O
(	O
dashRemain	int
*	O
dy	int
)	O
/	O
L	double
;	O
rcenterx	double
=	O
lcenterx	double
+	O
dashDx	double
;	O
rcentery	double
=	O
lcentery	double
+	O
dashDy	double
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
+=	O
dashDx	double
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
+=	O
dashDy	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
x	int
+=	O
dashDx	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
y	int
+=	O
dashDy	double
;	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
*	O
dx	int
+	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
*	O
dy	int
;	O
if	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
!	O
(	O
paintType	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
&&	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
)	O
{	O
saveRight	struct(double,double)
=	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
;	O
saveBottom	struct(double,double)
=	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
;	O
saveK	double
=	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
;	O
if	O
(	O
!	O
first	enum(int,int)
)	O
{	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
x	int
-=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
y	int
-=	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
-=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
-=	O
rdy	double
;	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
*	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
dy	int
-	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
*	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
dx	int
;	O
}	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
+=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
+=	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
x	int
+=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
y	int
+=	O
rdy	double
;	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
*	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
dy	int
-	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
*	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
dx	int
;	O
}	O
y	int
=	O
miPolyBuildPoly	(*(struct(double,double)),*(struct(int,int,double)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),*(int),*(int),*(int))->(int)
(	O
vertices	*(struct(double,double))
,	O
slopes	*(struct(int,int,double))
,	O
4	int
,	O
x1	int
,	O
y1	(double)->(double)
,	O
left	*(struct(int,int,int,int,int,int,int))
,	O
right	*(struct(int,int,int,int,int,int,int))
,	O
&	O
nleft	int
,	O
&	O
nright	int
,	O
&	O
h	int
)	O
;	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
y	int
,	O
h	int
,	O
left	*(struct(int,int,int,int,int,int,int))
,	O
right	*(struct(int,int,int,int,int,int,int))
,	O
nleft	int
,	O
nright	int
)	O
;	O
if	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
pGC	*(struct)
->	O
capStyle	int
)	O
{	O
case	O
(	O
int	O
)	O
MI_CAP_BUTT	int
:	O
default	O
:	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
:	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
=	O
saveBottom	struct(double,double)
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
=	O
saveRight	struct(double,double)
;	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
saveK	double
;	O
break	O
;	O
case	O
(	O
int	O
)	O
MI_CAP_ROUND	int
:	O
case	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
:	O
if	O
(	O
!	O
first	enum(int,int)
)	O
{	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
xa	double
=	O
-	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
ya	double
=	O
-	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
k	double
=	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
;	O
}	O
else	O
{	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
xa	double
=	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
x	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
ya	double
=	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
y	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
k	double
=	O
-	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
;	O
}	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
&	O
lcapFace	struct(double,double,int,int,int,int,double)
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
lcenterx	double
,	O
lcentery	double
,	O
false	int
)	O
;	O
}	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
xa	double
=	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
x	int
;	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
ya	double
=	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
y	int
;	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
k	double
=	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
;	O
}	O
else	O
{	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
xa	double
=	O
-	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
;	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
ya	double
=	O
-	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
;	O
rcapFace	struct(double,double,int,int,int,int,double)
.	O
k	double
=	O
-	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
;	O
}	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
&	O
rcapFace	struct(double,double,int,int,int,int,double)
,	O
rcenterx	double
,	O
rcentery	double
,	O
false	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
LRemain	double
-=	O
dashRemain	int
;	O
++	O
dashNum	int
;	O
++	O
dashIndex	int
;	O
if	O
(	O
dashIndex	int
==	O
pGC	*(struct)
->	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
dashRemain	int
=	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
dashIndex	int
]	O
)	O
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
pixel	int
=	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
paintType	int
]	O
;	O
lcenterx	double
=	O
rcenterx	double
;	O
lcentery	double
=	O
rcentery	double
;	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
=	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
=	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
;	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
-	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
;	O
first	enum(int,int)
=	O
false	int
;	O
}	O
if	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
||	O
!	O
(	O
paintType	int
==	O
0	int
)	O
)	O
{	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
x	int
-=	O
dx	int
;	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
y	int
-=	O
dy	int
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
-=	O
dx	int
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
-=	O
dy	int
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
=	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
=	O
-	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
x	int
=	O
-	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
y	int
=	O
rdx	double
;	O
if	O
(	O
projectRight	enum(int,int)
)	O
{	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
+=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
+=	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
x	int
+=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_BOTTOM	int
]	O
.	O
y	int
+=	O
rdy	double
;	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
x	int
*	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
dy	int
-	O
vertices	*(struct(double,double))
[	O
V_RIGHT	int
]	O
.	O
y	int
*	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
dx	int
;	O
}	O
else	O
slopes	*(struct(int,int,double))
[	O
V_RIGHT	int
]	O
.	O
k	double
=	O
0	int
;	O
if	O
(	O
!	O
first	enum(int,int)
&&	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
&&	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
)	O
{	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
x	int
-=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
y	int
-=	O
rdy	double
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
-=	O
rdx	double
;	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
-=	O
rdy	double
;	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
=	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
*	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
dy	int
-	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
*	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
dx	int
;	O
}	O
else	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
+=	O
dx	int
*	O
dx	int
+	O
dy	int
*	O
dy	int
;	O
y	int
=	O
miPolyBuildPoly	(*(struct(double,double)),*(struct(int,int,double)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),*(int),*(int),*(int))->(int)
(	O
vertices	*(struct(double,double))
,	O
slopes	*(struct(int,int,double))
,	O
4	int
,	O
x2	int
,	O
y2	int
,	O
left	*(struct(int,int,int,int,int,int,int))
,	O
right	*(struct(int,int,int,int,int,int,int))
,	O
&	O
nleft	int
,	O
&	O
nright	int
,	O
&	O
h	int
)	O
;	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
y	int
,	O
h	int
,	O
left	*(struct(int,int,int,int,int,int,int))
,	O
right	*(struct(int,int,int,int,int,int,int))
,	O
nleft	int
,	O
nright	int
)	O
;	O
if	O
(	O
!	O
first	enum(int,int)
&&	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_ON_OFF_DASH	int
&&	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
)	O
{	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
x	int
=	O
x2	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
y	int
=	O
y2	int
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
xa	double
=	O
-	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
x	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
ya	double
=	O
-	O
vertices	*(struct(double,double))
[	O
V_LEFT	int
]	O
.	O
y	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
k	double
=	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
;	O
}	O
else	O
{	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
xa	double
=	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
x	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
ya	double
=	O
vertices	*(struct(double,double))
[	O
V_TOP	int
]	O
.	O
y	int
;	O
lcapFace	struct(double,double,int,int,int,int,double)
.	O
k	double
=	O
-	O
slopes	*(struct(int,int,double))
[	O
V_LEFT	int
]	O
.	O
k	double
;	O
}	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
pGC	*(struct)
,	O
&	O
lcapFace	struct(double,double,int,int,int,int,double)
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
rcenterx	double
,	O
rcentery	double
,	O
false	int
)	O
;	O
}	O
}	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
x	int
=	O
x1	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
y	int
=	O
y1	(double)->(double)
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
=	O
dx	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
=	O
dy	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
rdy	double
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
-	O
rdx	double
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
=	O
k	double
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
x	int
=	O
x2	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
y	int
=	O
y2	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
=	O
-	O
dx	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
=	O
-	O
dy	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
-	O
rdy	double
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
rdx	double
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
=	O
k	double
;	O
dashRemain	int
=	O
(	O
int	O
)	O
(	O
(	O
(	O
double	O
)	O
dashRemain	int
)	O
-	O
LRemain	double
)	O
;	O
if	O
(	O
dashRemain	int
==	O
0	int
)	O
{	O
dashNum	int
++	O
;	O
dashIndex	int
++	O
;	O
if	O
(	O
dashIndex	int
==	O
pGC	*(struct)
->	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
dashRemain	int
=	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
dashIndex	int
]	O
)	O
;	O
}	O
*	O
pDashNum	*(int)
=	O
dashNum	int
;	O
*	O
pDashIndex	*(int)
=	O
dashIndex	int
;	O
*	O
pDashOffset	*(int)
=	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
dashIndex	int
]	O
)	O
-	O
dashRemain	int
;	O
}	O
void	O
miStepDash	O
(	O
int	O
dist	int
,	O
int	O
*	O
pDashNum	*(int)
,	O
int	O
*	O
pDashIndex	*(int)
,	O
const	O
unsigned	O
int	O
*	O
pDash	*(int)
,	O
int	O
numInDashList	int
,	O
int	O
*	O
pDashOffset	*(int)
)	O
{	O
int	O
dashNum	int
,	O
dashIndex	int
,	O
dashOffset	int
;	O
int	O
totallen	int
;	O
int	O
i	int
;	O
dashNum	int
=	O
*	O
pDashNum	*(int)
;	O
dashIndex	int
=	O
*	O
pDashIndex	*(int)
;	O
dashOffset	int
=	O
*	O
pDashOffset	*(int)
;	O
if	O
(	O
dashOffset	int
+	O
dist	int
<	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
dashIndex	int
]	O
)	O
)	O
{	O
*	O
pDashOffset	*(int)
=	O
dashOffset	int
+	O
dist	int
;	O
return	O
;	O
}	O
dist	int
-=	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
dashIndex	int
]	O
)	O
-	O
dashOffset	int
;	O
dashNum	int
++	O
;	O
dashIndex	int
++	O
;	O
if	O
(	O
dashIndex	int
==	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
totallen	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numInDashList	int
;	O
i	int
++	O
)	O
totallen	int
+=	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
totallen	int
<=	O
dist	int
)	O
dist	int
=	O
dist	int
%	O
totallen	int
;	O
while	O
(	O
dist	int
>=	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
dashIndex	int
]	O
)	O
)	O
{	O
dist	int
-=	O
(	O
int	O
)	O
(	O
pDash	*(int)
[	O
dashIndex	int
]	O
)	O
;	O
dashNum	int
++	O
;	O
dashIndex	int
++	O
;	O
if	O
(	O
dashIndex	int
==	O
numInDashList	int
)	O
dashIndex	int
=	O
0	int
;	O
}	O
*	O
pDashNum	*(int)
=	O
dashNum	int
;	O
*	O
pDashIndex	*(int)
=	O
dashIndex	int
;	O
*	O
pDashOffset	*(int)
=	O
dist	int
;	O
}	O
void	O
miWideLine	O
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
miCoordMode	enum(int,int)
mode	enum(int,int)
,	O
int	O
npt	int
,	O
const	O
miPoint	struct(int,int)
*	O
pPts	*(struct(int,int))
)	O
{	O
int	O
x1	int
,	O
y1	(double)->(double)
,	O
x2	int
,	O
y2	int
;	O
bool	enum(int,int)
projectLeft	enum(int,int)
,	O
projectRight	enum(int,int)
;	O
LineFace	struct(double,double,int,int,int,int,double)
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
prevRightFace	struct(double,double,int,int,int,int,double)
;	O
LineFace	struct(double,double,int,int,int,int,double)
firstFace	struct(double,double,int,int,int,int,double)
;	O
int	O
first	enum(int,int)
;	O
bool	enum(int,int)
somethingDrawn	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
selfJoin	enum(int,int)
;	O
if	O
(	O
npt	int
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
pGC	*(struct)
->	O
lineWidth	int
==	O
0	int
)	O
{	O
miZeroLine	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
,	O
mode	enum(int,int)
,	O
npt	int
,	O
pPts	*(struct(int,int))
)	O
;	O
return	O
;	O
}	O
x2	int
=	O
pPts	*(struct(int,int))
->	O
x	int
;	O
y2	int
=	O
pPts	*(struct(int,int))
->	O
y	int
;	O
first	enum(int,int)
=	O
true	int
;	O
selfJoin	enum(int,int)
=	O
false	int
;	O
if	O
(	O
npt	int
>	O
1	int
)	O
{	O
if	O
(	O
mode	enum(int,int)
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
int	O
nptTmp	int
;	O
const	O
miPoint	struct(int,int)
*	O
pPtsTmp	*(struct(int,int))
;	O
x1	int
=	O
x2	int
;	O
y1	(double)->(double)
=	O
y2	int
;	O
nptTmp	int
=	O
npt	int
;	O
pPtsTmp	*(struct(int,int))
=	O
pPts	*(struct(int,int))
+	O
1	int
;	O
while	O
(	O
--	O
nptTmp	int
)	O
{	O
x1	int
+=	O
pPtsTmp	*(struct(int,int))
->	O
x	int
;	O
y1	(double)->(double)
+=	O
pPtsTmp	*(struct(int,int))
->	O
y	int
;	O
++	O
pPtsTmp	*(struct(int,int))
;	O
}	O
if	O
(	O
x2	int
==	O
x1	int
&&	O
y2	int
==	O
y1	(double)->(double)
)	O
selfJoin	enum(int,int)
=	O
true	int
;	O
}	O
else	O
if	O
(	O
x2	int
==	O
pPts	*(struct(int,int))
[	O
npt	int
-	O
1	int
]	O
.	O
x	int
&&	O
y2	int
==	O
pPts	*(struct(int,int))
[	O
npt	int
-	O
1	int
]	O
.	O
y	int
)	O
selfJoin	enum(int,int)
=	O
true	int
;	O
}	O
projectLeft	enum(int,int)
=	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
&&	O
!	O
selfJoin	enum(int,int)
)	O
?	O
true	int
:	O
false	int
;	O
projectRight	enum(int,int)
=	O
false	int
;	O
while	O
(	O
--	O
npt	int
)	O
{	O
x1	int
=	O
x2	int
;	O
y1	(double)->(double)
=	O
y2	int
;	O
++	O
pPts	*(struct(int,int))
;	O
x2	int
=	O
pPts	*(struct(int,int))
->	O
x	int
;	O
y2	int
=	O
pPts	*(struct(int,int))
->	O
y	int
;	O
if	O
(	O
mode	enum(int,int)
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
x2	int
+=	O
x1	int
;	O
y2	int
+=	O
y1	(double)->(double)
;	O
}	O
if	O
(	O
x1	int
!=	O
x2	int
||	O
y1	(double)->(double)
!=	O
y2	int
)	O
{	O
somethingDrawn	enum(int,int)
=	O
true	int
;	O
if	O
(	O
npt	int
==	O
1	int
&&	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
&&	O
!	O
selfJoin	enum(int,int)
)	O
projectRight	enum(int,int)
=	O
true	int
;	O
miWideSegment	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),int,int,int,int,enum(int,int),enum(int,int),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
,	O
pGC	*(struct)
,	O
x1	int
,	O
y1	(double)->(double)
,	O
x2	int
,	O
y2	int
,	O
projectLeft	enum(int,int)
,	O
projectRight	enum(int,int)
,	O
&	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
&	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
;	O
if	O
(	O
first	enum(int,int)
)	O
{	O
if	O
(	O
selfJoin	enum(int,int)
)	O
firstFace	struct(double,double,int,int,int,int,double)
=	O
leftFace	*(struct(double,double,int,int,int,int,double))
;	O
else	O
if	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
,	O
pGC	*(struct)
,	O
&	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
else	O
miLineJoin	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
,	O
pGC	*(struct)
,	O
&	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
&	O
prevRightFace	struct(double,double,int,int,int,int,double)
)	O
;	O
prevRightFace	struct(double,double,int,int,int,int,double)
=	O
rightFace	*(struct(double,double,int,int,int,int,double))
;	O
first	enum(int,int)
=	O
false	int
;	O
projectLeft	enum(int,int)
=	O
false	int
;	O
}	O
if	O
(	O
npt	int
==	O
1	int
&&	O
somethingDrawn	enum(int,int)
)	O
{	O
if	O
(	O
selfJoin	enum(int,int)
)	O
miLineJoin	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
,	O
pGC	*(struct)
,	O
&	O
firstFace	struct(double,double,int,int,int,int,double)
,	O
&	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
;	O
else	O
if	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
,	O
pGC	*(struct)
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
&	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
somethingDrawn	enum(int,int)
)	O
{	O
projectLeft	enum(int,int)
=	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_PROJECTING	int
)	O
?	O
true	int
:	O
false	int
;	O
miWideSegment	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),int,int,int,int,enum(int,int),enum(int,int),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
,	O
pGC	*(struct)
,	O
x2	int
,	O
y2	int
,	O
x2	int
,	O
y2	int
,	O
projectLeft	enum(int,int)
,	O
projectLeft	enum(int,int)
,	O
&	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
&	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
;	O
if	O
(	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_ROUND	int
||	O
pGC	*(struct)
->	O
capStyle	int
==	O
(	O
int	O
)	O
MI_CAP_TRIANGULAR	int
)	O
{	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
,	O
pGC	*(struct)
,	O
&	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
.	O
dx	int
=	O
-	O
1	int
;	O
miLineArc	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)),double,double,enum(int,int))->(void)
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(int)
[	O
1	int
]	O
,	O
pGC	*(struct)
,	O
(	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
)	O
NULL	O
,	O
&	O
rightFace	*(struct(double,double,int,int,int,int,double))
,	O
(	O
double	O
)	O
0.0	int
,	O
(	O
double	O
)	O
0.0	int
,	O
true	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
miWideSegment	(*(struct(*(*(struct`)),int,int)),int,*(struct(int,*(int),int,array(int),array(int),array(int),*(int),int,int,int,int,int,int,double,int,int)),int,int,int,int,enum(int,int),enum(int,int),*(struct(double,double,int,int,int,int,double)),*(struct(double,double,int,int,int,int,double)))->(void)
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
miPixel	int
pixel	int
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
x1	int
,	O
int	O
y1	(double)->(double)
,	O
int	O
x2	int
,	O
int	O
y2	int
,	O
bool	enum(int,int)
projectLeft	enum(int,int)
,	O
bool	enum(int,int)
projectRight	enum(int,int)
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
leftFace	*(struct(double,double,int,int,int,int,double))
,	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
rightFace	*(struct(double,double,int,int,int,int,double))
)	O
{	O
int	O
dx	int
,	O
dy	int
;	O
int	O
x	int
,	O
y	int
;	O
int	O
signdx	int
;	O
int	O
lw	int
=	O
(	O
int	O
)	O
(	O
pGC	*(struct)
->	O
lineWidth	int
)	O
;	O
if	O
(	O
y2	int
<	O
y1	(double)->(double)
||	O
(	O
y2	int
==	O
y1	(double)->(double)
&&	O
x2	int
<	O
x1	int
)	O
)	O
{	O
int	O
tx	int
,	O
ty	int
;	O
bool	enum(int,int)
tbool	enum(int,int)
;	O
LineFace	struct(double,double,int,int,int,int,double)
*	O
tface	*(struct(double,double,int,int,int,int,double))
;	O
tx	int
=	O
x1	int
;	O
x1	int
=	O
x2	int
;	O
x2	int
=	O
tx	int
;	O
ty	int
=	O
y1	(double)->(double)
;	O
y1	(double)->(double)
=	O
y2	int
;	O
y2	int
=	O
ty	int
;	O
tbool	enum(int,int)
=	O
projectLeft	enum(int,int)
;	O
projectLeft	enum(int,int)
=	O
projectRight	enum(int,int)
;	O
projectRight	enum(int,int)
=	O
tbool	enum(int,int)
;	O
tface	*(struct(double,double,int,int,int,int,double))
=	O
leftFace	*(struct(double,double,int,int,int,int,double))
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
=	O
rightFace	*(struct(double,double,int,int,int,int,double))
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
=	O
tface	*(struct(double,double,int,int,int,int,double))
;	O
}	O
dy	int
=	O
y2	int
-	O
y1	(double)->(double)
;	O
signdx	int
=	O
1	int
;	O
dx	int
=	O
x2	int
-	O
x1	int
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
signdx	int
=	O
-	O
1	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
x	int
=	O
x1	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
y	int
=	O
y1	(double)->(double)
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
=	O
dx	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
=	O
dy	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
x	int
=	O
x2	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
y	int
=	O
y2	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
dx	int
=	O
-	O
dx	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
dy	int
=	O
-	O
dy	int
;	O
if	O
(	O
dy	int
==	O
0	int
)	O
{	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
0	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
0.5	int
*	O
(	O
double	O
)	O
lw	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
=	O
-	O
0.5	int
*	O
(	O
double	O
)	O
(	O
lw	int
*	O
dx	int
)	O
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
0	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
-	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
=	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
;	O
x	int
=	O
x1	int
;	O
if	O
(	O
projectLeft	enum(int,int)
)	O
x	int
-=	O
(	O
lw	int
>>	O
1	int
)	O
;	O
y	int
=	O
y1	(double)->(double)
-	O
(	O
lw	int
>>	O
1	int
)	O
;	O
dx	int
=	O
x2	int
-	O
x	int
;	O
if	O
(	O
projectRight	enum(int,int)
)	O
dx	int
+=	O
(	O
(	O
lw	int
+	O
1	int
)	O
>>	O
1	int
)	O
;	O
dy	int
=	O
lw	int
;	O
miFillRectPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
x	int
,	O
y	int
,	O
(	O
unsigned	O
int	O
)	O
dx	int
,	O
(	O
unsigned	O
int	O
)	O
dy	int
)	O
;	O
}	O
else	O
if	O
(	O
dx	int
==	O
0	int
)	O
{	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
0.5	int
*	O
(	O
double	O
)	O
lw	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
0	int
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
=	O
0.5	int
*	O
(	O
double	O
)	O
(	O
lw	int
*	O
dy	int
)	O
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
-	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
0	int
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
=	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
;	O
y	int
=	O
y1	(double)->(double)
;	O
if	O
(	O
projectLeft	enum(int,int)
)	O
y	int
-=	O
lw	int
>>	O
1	int
;	O
x	int
=	O
x1	int
-	O
(	O
lw	int
>>	O
1	int
)	O
;	O
dy	int
=	O
y2	int
-	O
y	int
;	O
if	O
(	O
projectRight	enum(int,int)
)	O
dy	int
+=	O
(	O
(	O
lw	int
+	O
1	int
)	O
>>	O
1	int
)	O
;	O
dx	int
=	O
lw	int
;	O
miFillRectPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
x	int
,	O
y	int
,	O
(	O
unsigned	O
int	O
)	O
dx	int
,	O
(	O
unsigned	O
int	O
)	O
dy	int
)	O
;	O
}	O
else	O
{	O
double	O
l	double
,	O
L	double
,	O
r	double
;	O
double	O
xa	double
,	O
ya	double
;	O
double	O
projectXoff	double
=	O
0.0	int
,	O
projectYoff	double
=	O
0.0	int
;	O
double	O
k	double
;	O
double	O
maxy	double
;	O
int	O
finaly	int
;	O
int	O
lefty	int
,	O
righty	int
,	O
topy	int
,	O
bottomy	int
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
lefts	array(struct(int,int,int,int,int,int,int))
[	O
2	int
]	O
,	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
2	int
]	O
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
left	*(struct(int,int,int,int,int,int,int))
,	O
*	O
right	*(struct(int,int,int,int,int,int,int))
;	O
PolyEdge	struct(int,int,int,int,int,int,int)
*	O
top	int
,	O
*	O
bottom	int
;	O
l	double
=	O
0.5	int
*	O
(	O
(	O
double	O
)	O
lw	int
)	O
;	O
L	double
=	O
hypot	(double,double)->(double)
(	O
(	O
double	O
)	O
dx	int
,	O
(	O
double	O
)	O
dy	int
)	O
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
right	*(struct(int,int,int,int,int,int,int))
=	O
&	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
left	*(struct(int,int,int,int,int,int,int))
=	O
&	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
top	int
=	O
&	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
bottom	int
=	O
&	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
}	O
else	O
{	O
right	*(struct(int,int,int,int,int,int,int))
=	O
&	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
left	*(struct(int,int,int,int,int,int,int))
=	O
&	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
top	int
=	O
&	O
lefts	array(struct(int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
bottom	int
=	O
&	O
rights	array(struct(int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
}	O
r	double
=	O
l	double
/	O
L	double
;	O
ya	double
=	O
-	O
r	double
*	O
dx	int
;	O
xa	double
=	O
r	double
*	O
dy	int
;	O
if	O
(	O
projectLeft	enum(int,int)
|	O
projectRight	enum(int,int)
)	O
{	O
projectXoff	double
=	O
-	O
ya	double
;	O
projectYoff	double
=	O
xa	double
;	O
}	O
k	double
=	O
l	double
*	O
L	double
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
xa	double
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
ya	double
;	O
leftFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
=	O
k	double
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
xa	double
=	O
-	O
xa	double
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
ya	double
=	O
-	O
ya	double
;	O
rightFace	*(struct(double,double,int,int,int,int,double))
->	O
k	double
=	O
k	double
;	O
if	O
(	O
projectLeft	enum(int,int)
)	O
righty	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
-	O
projectXoff	double
,	O
ya	double
-	O
projectYoff	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
x1	int
,	O
y1	(double)->(double)
,	O
false	int
,	O
right	*(struct(int,int,int,int,int,int,int))
)	O
;	O
else	O
righty	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
x1	int
,	O
y1	(double)->(double)
,	O
false	int
,	O
right	*(struct(int,int,int,int,int,int,int))
)	O
;	O
ya	double
=	O
-	O
ya	double
;	O
xa	double
=	O
-	O
xa	double
;	O
k	double
=	O
-	O
k	double
;	O
if	O
(	O
projectLeft	enum(int,int)
)	O
lefty	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
-	O
projectXoff	double
,	O
ya	double
-	O
projectYoff	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
x1	int
,	O
y1	(double)->(double)
,	O
true	int
,	O
left	*(struct(int,int,int,int,int,int,int))
)	O
;	O
else	O
lefty	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
k	double
,	O
dx	int
,	O
dy	int
,	O
x1	int
,	O
y1	(double)->(double)
,	O
true	int
,	O
left	*(struct(int,int,int,int,int,int,int))
)	O
;	O
if	O
(	O
signdx	int
>	O
0	int
)	O
{	O
ya	double
=	O
-	O
ya	double
;	O
xa	double
=	O
-	O
xa	double
;	O
}	O
if	O
(	O
projectLeft	enum(int,int)
)	O
{	O
double	O
xap	double
=	O
xa	double
-	O
projectXoff	double
;	O
double	O
yap	double
=	O
ya	double
-	O
projectYoff	double
;	O
topy	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xap	double
,	O
yap	double
,	O
xap	double
*	O
dx	int
+	O
yap	double
*	O
dy	int
,	O
-	O
dy	int
,	O
dx	int
,	O
x1	int
,	O
y1	(double)->(double)
,	O
(	O
dx	int
>	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
top	int
)	O
;	O
}	O
else	O
topy	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
-	O
dy	int
,	O
dx	int
,	O
x1	int
,	O
y1	(double)->(double)
,	O
(	O
dx	int
>	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
top	int
)	O
;	O
if	O
(	O
projectRight	enum(int,int)
)	O
{	O
double	O
xap	double
=	O
xa	double
+	O
projectXoff	double
;	O
double	O
yap	double
=	O
ya	double
+	O
projectYoff	double
;	O
bottomy	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xap	double
,	O
yap	double
,	O
xap	double
*	O
dx	int
+	O
yap	double
*	O
dy	int
,	O
-	O
dy	int
,	O
dx	int
,	O
x2	int
,	O
y2	int
,	O
(	O
dx	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
bottom	int
)	O
;	O
maxy	double
=	O
-	O
ya	double
+	O
projectYoff	double
;	O
}	O
else	O
{	O
bottomy	int
=	O
miPolyBuildEdge	(double,double,double,int,int,int,int,enum(int,int),*(struct(int,int,int,int,int,int,int)))->(int)
(	O
xa	double
,	O
ya	double
,	O
0.0	int
,	O
-	O
dy	int
,	O
dx	int
,	O
x2	int
,	O
y2	int
,	O
(	O
dx	int
<	O
0	int
?	O
true	int
:	O
false	int
)	O
,	O
bottom	int
)	O
;	O
maxy	double
=	O
-	O
ya	double
;	O
}	O
finaly	int
=	O
ICEIL	O
(	O
maxy	double
)	O
+	O
y2	int
;	O
if	O
(	O
dx	int
<	O
0	int
)	O
{	O
left	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
lefty	int
)	O
;	O
right	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
righty	int
)	O
;	O
top	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
righty	int
-	O
topy	int
)	O
;	O
}	O
else	O
{	O
right	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bottomy	int
-	O
righty	int
)	O
;	O
left	*(struct(int,int,int,int,int,int,int))
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
lefty	int
)	O
;	O
top	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
lefty	int
-	O
topy	int
)	O
;	O
}	O
bottom	int
->	O
height	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
finaly	int
-	O
bottomy	int
)	O
;	O
miFillPolyHelper	(*(struct(*(*(struct`)),int,int)),int,int,int,*(struct(int,int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int)),int,int)->(void)
(	O
paintedSet	*(struct)
,	O
pixel	int
,	O
topy	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
bottom	int
->	O
height	int
+	O
bottomy	int
-	O
topy	int
)	O
,	O
lefts	array(struct(int,int,int,int,int,int,int))
,	O
rights	array(struct(int,int,int,int,int,int,int))
,	O
2	int
,	O
2	int
)	O
;	O
}	O
}	O
