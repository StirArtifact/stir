static	O
void	O
argv_free	(*(void))->(void)
(	O
void	O
*	O
p	*(char)
)	O
{	O
mu_argv_free	()->(int)
(	O
(	O
char	O
*	O
*	O
)	O
p	*(char)
)	O
;	O
}	O
static	O
SCM	(*(int))->((*(void),*(struct))->(int))
make_filter_port	(int,int,int,int,*(char))->(int)
(	O
SCM	(*(int))->((*(void),*(struct))->(int))
port	int
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
name	*(char)
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
args	int
,	O
int	O
filter_mode	int
,	O
char	O
const	O
*	O
func_name	*(char)
)	O
{	O
char	O
*	O
fltname	*(char)
;	O
mu_stream_t	*(struct)
filter	*(struct)
;	O
mu_stream_t	*(struct)
instr	*(struct)
;	O
size_t	long
argc	int
=	O
0	int
;	O
char	O
*	O
*	O
argv	*(*(char))
=	O
NULL	O
;	O
int	O
rc	int
;	O
int	O
flags	int
=	O
0	int
;	O
char	O
*	O
port_mode	*(char)
;	O
SCM_ASSERT	()->(int)
(	O
scm_port_p	()->(int)
(	O
port	int
)	O
,	O
port	int
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
name	*(char)
)	O
,	O
name	*(char)
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_VALIDATE_REST_ARGUMENT	()->(int)
(	O
args	int
)	O
;	O
port_mode	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
scm_port_mode	()->(int)
(	O
port	int
)	O
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
port_mode	*(char)
,	O
'r'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_READ	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
port_mode	*(char)
,	O
'w'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_WRITE	int
;	O
free	(*(void))->(void)
(	O
port_mode	*(char)
)	O
;	O
if	O
(	O
!	O
flags	int
||	O
(	O
(	O
flags	int
&	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
==	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
)	O
scm_out_of_range	()->(int)
(	O
FUNC_NAME	O
,	O
port	int
)	O
;	O
scm_dynwind_begin	()->(int)
(	O
0	int
)	O
;	O
fltname	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
name	*(char)
)	O
;	O
scm_dynwind_free	()->(int)
(	O
fltname	*(char)
)	O
;	O
rc	int
=	O
mu_scm_port_stream_create	(*(*(struct)),int)->(int)
(	O
&	O
instr	*(struct)
,	O
port	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	(*(char),int,*(char),int)->(void)
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to convert transport port ~A"	*(char)
,	O
scm_list_1	()->(int)
(	O
port	int
)	O
)	O
;	O
}	O
if	O
(	O
!	O
scm_is_null	()->(int)
(	O
args	int
)	O
)	O
{	O
size_t	long
n	int
;	O
argc	int
=	O
scm_to_size_t	()->(int)
(	O
scm_length	()->(int)
(	O
args	int
)	O
)	O
+	O
1	int
;	O
argv	*(*(char))
=	O
calloc	(long,long)->(*(void))
(	O
argc	int
+	O
1	int
,	O
sizeof	O
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
argv	*(*(char))
)	O
mu_scm_error	(*(char),int,*(char),int)->(void)
(	O
FUNC_NAME	O
,	O
ENOMEM	int
,	O
"Cannot allocate memory"	*(char)
,	O
SCM_BOOL_F	O
)	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
strdup	(*(char))->(*(char))
(	O
fltname	*(char)
)	O
;	O
n	int
=	O
1	int
;	O
for	O
(	O
;	O
!	O
scm_is_null	()->(int)
(	O
args	int
)	O
;	O
args	int
=	O
SCM_CDR	()->(int)
(	O
args	int
)	O
)	O
{	O
SCM	(*(int))->((*(void),*(struct))->(int))
arg	*(char)
=	O
SCM_CAR	O
(	O
args	int
)	O
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
arg	*(char)
)	O
,	O
arg	*(char)
,	O
SCM_ARGn	O
,	O
FUNC_NAME	O
)	O
;	O
argv	*(*(char))
[	O
n	int
]	O
=	O
scm_to_locale_string	()->(int)
(	O
arg	*(char)
)	O
;	O
n	int
++	O
;	O
}	O
argv	*(*(char))
[	O
n	int
]	O
=	O
NULL	O
;	O
scm_dynwind_unwind_handler	()->(int)
(	O
argv_free	(*(void))->(void)
,	O
argv	*(*(char))
,	O
SCM_F_WIND_EXPLICITLY	O
)	O
;	O
}	O
rc	int
=	O
mu_filter_create_args	(*(*(struct)),*(struct),*(char),int,*(*(char)),int,int)->(int)
(	O
&	O
filter	*(struct)
,	O
instr	*(struct)
,	O
fltname	*(char)
,	O
argc	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	*(*(char))
,	O
filter_mode	int
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	(*(char),int,*(char),int)->(void)
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to create filter ~A"	*(char)
,	O
scm_list_1	()->(int)
(	O
name	*(char)
)	O
)	O
;	O
}	O
scm_dynwind_end	()->(int)
(	O
)	O
;	O
return	O
mu_port_make_from_stream	(*(struct),long)->(int)
(	O
filter	*(struct)
,	O
flags	int
==	O
MU_STREAM_READ	int
?	O
SCM_RDNG	O
:	O
SCM_WRTNG	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_mu_encoder_port	O
,	O
"mu-encoder-port"	*(char)
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	(*(int))->((*(void),*(struct))->(int))
port	int
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
name	*(char)
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
args	int
)	O
,	O
"Create encoding port using Mailutils filter @var{name} with optional arguments\n"	*(char)
"@var{args}. The @var{port} argument must be a port opened either for\n"	*(char)
"writing or for reading, but not both. The returned port will have the same\n"	*(char)
"mode as @var{port}."	*(char)
"\n\n"	*(char)
"If @var{port} is open for reading, data will be read from it, passed through the\n"	*(char)
"filter and returned. If it is open for writing, data written to the returned\n"	*(char)
"port will be passed through filter and its output will be written to @var{port}.\n"	*(char)
)	O
{	O
return	O
make_filter_port	(int,int,int,int,*(char))->(int)
(	O
port	int
,	O
name	*(char)
,	O
args	int
,	O
MU_FILTER_ENCODE	int
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_mu_decoder_port	O
,	O
"mu-decoder-port"	*(char)
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	(*(int))->((*(void),*(struct))->(int))
port	int
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
name	*(char)
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
args	int
)	O
,	O
"Create a decoding port using Mailutils filter @var{name} with optional arguments\n"	*(char)
"@var{args}. The @var{port} argument must be a port opened either for\n"	*(char)
"writing or for reading, but not both. The returned port will have the same\n"	*(char)
"mode as @var{port}."	*(char)
"\n\n"	*(char)
"If @var{port} is open for reading, data will be read from it, passed through the\n"	*(char)
"filter and returned. If it is open for writing, data written to the returned\n"	*(char)
"port will be passed through filter and its output will be written to @var{port}.\n"	*(char)
)	O
{	O
return	O
make_filter_port	(int,int,int,int,*(char))->(int)
(	O
port	int
,	O
name	*(char)
,	O
args	int
,	O
MU_FILTER_DECODE	int
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_mu_header_decode	O
,	O
"mu-header-decode"	*(char)
,	O
1	int
,	O
1	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void),*(struct))->(int))
hdr	*(struct)
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
charset	*(char)
)	O
,	O
"Decode the header value @var{hdr}, encoded as per RFC 2047.\n"	*(char)
"Optional @var{charset} defaults to @samp{utf-8}.\n"	*(char)
)	O
{	O
char	O
*	O
c_hdr	*(char)
,	O
*	O
c_charset	*(char)
,	O
*	O
c_res	*(char)
;	O
int	O
rc	int
;	O
SCM	(*(int))->((*(void),*(struct))->(int))
res	*(int)
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
hdr	*(struct)
)	O
,	O
hdr	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	()->(int)
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	()->(int)
(	O
charset	*(char)
)	O
)	O
c_charset	*(char)
=	O
"utf-8"	*(char)
;	O
else	O
{	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
charset	*(char)
)	O
,	O
charset	*(char)
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_charset	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
charset	*(char)
)	O
;	O
scm_dynwind_free	()->(int)
(	O
c_charset	*(char)
)	O
;	O
}	O
c_hdr	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
hdr	*(struct)
)	O
;	O
scm_dynwind_free	()->(int)
(	O
c_hdr	*(char)
)	O
;	O
rc	int
=	O
mu_rfc2047_decode	(*(char),*(char),*(*(char)))->(int)
(	O
c_charset	*(char)
,	O
c_hdr	*(char)
,	O
&	O
c_res	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	(*(char),int,*(char),int)->(void)
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't convert header value"	*(char)
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	()->(int)
(	O
)	O
;	O
res	*(int)
=	O
scm_from_locale_string	()->(int)
(	O
c_res	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
c_res	*(char)
)	O
;	O
return	O
res	*(int)
;	O
}	O
SCM_DEFINE_PUBLIC	()->(int)
(	O
scm_mu_header_encode	O
,	O
"mu-header-encode"	*(char)
,	O
1	int
,	O
2	int
,	O
0	int
,	O
(	O
SCM	(*(int))->((*(void),*(struct))->(int))
hdr	*(struct)
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
encoding	*(char)
,	O
SCM	(*(int))->((*(void),*(struct))->(int))
charset	*(char)
)	O
,	O
"Encode the string @var{hdr} as per RFC 2047.\n"	*(char)
"Both @var{encoding} and @var{charset} are optional.\n"	*(char)
"Allowed values for @var{encoding} are @samp{base64} and @samp{quoted-printable}.\n"	*(char)
"Default is selected depending on number of printable characters in @var{hdr}.\n"	*(char)
"Optional @var{charset} defaults to @samp{utf-8}.\n"	*(char)
)	O
{	O
char	O
*	O
c_hdr	*(char)
,	O
*	O
c_charset	*(char)
,	O
*	O
c_encoding	*(char)
,	O
*	O
c_res	*(char)
;	O
int	O
rc	int
;	O
SCM	(*(int))->((*(void),*(struct))->(int))
res	*(int)
;	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
hdr	*(struct)
)	O
,	O
hdr	*(struct)
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	()->(int)
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	()->(int)
(	O
encoding	*(char)
)	O
)	O
c_encoding	*(char)
=	O
NULL	O
;	O
else	O
{	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
encoding	*(char)
)	O
,	O
encoding	*(char)
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_encoding	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
encoding	*(char)
)	O
;	O
scm_dynwind_free	()->(int)
(	O
c_encoding	*(char)
)	O
;	O
}	O
if	O
(	O
SCM_UNBNDP	()->(int)
(	O
charset	*(char)
)	O
)	O
c_charset	*(char)
=	O
"utf-8"	*(char)
;	O
else	O
{	O
SCM_ASSERT	()->(int)
(	O
scm_is_string	()->(int)
(	O
charset	*(char)
)	O
,	O
charset	*(char)
,	O
SCM_ARG3	O
,	O
FUNC_NAME	O
)	O
;	O
c_charset	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
charset	*(char)
)	O
;	O
scm_dynwind_free	()->(int)
(	O
c_charset	*(char)
)	O
;	O
}	O
c_hdr	*(char)
=	O
scm_to_locale_string	()->(int)
(	O
hdr	*(struct)
)	O
;	O
scm_dynwind_free	()->(int)
(	O
c_hdr	*(char)
)	O
;	O
if	O
(	O
!	O
c_encoding	*(char)
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
c_hdr	*(char)
)	O
;	O
size_t	long
i	long
,	O
enc	long
;	O
enc	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
mu_isprint	O
(	O
c_hdr	*(char)
[	O
i	long
]	O
)	O
)	O
enc	long
++	O
;	O
c_encoding	*(char)
=	O
(	O
enc	long
>	O
len	long
/	O
2	int
)	O
?	O
"base64"	*(char)
:	O
"quoted-printable"	*(char)
;	O
}	O
rc	int
=	O
mu_rfc2047_encode	(*(char),*(char),*(char),*(*(char)))->(int)
(	O
c_charset	*(char)
,	O
c_encoding	*(char)
,	O
c_hdr	*(char)
,	O
&	O
c_res	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	(*(char),int,*(char),int)->(void)
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't encode header value"	*(char)
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	()->(int)
(	O
)	O
;	O
res	*(int)
=	O
scm_from_locale_string	()->(int)
(	O
c_res	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
c_res	*(char)
)	O
;	O
return	O
res	*(int)
;	O
}	O
void	O
mu_scm_filter_init	()->(void)
(	O
void	O
)	O
{	O
}	O
