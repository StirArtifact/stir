thread_t	O
reader_thread	int
=	O
MACH_PORT_NULL	O
;	O
static	O
file_t	O
ioport	int
=	O
MACH_PORT_NULL	O
;	O
unsigned	O
int	O
tioc_caps	int
;	O
thread_t	O
writer_thread	int
=	O
MACH_PORT_NULL	O
;	O
static	O
int	O
output_stopped	int
;	O
static	O
pthread_cond_t	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
hurdio_writer_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
;	O
size_t	long
npending_output	long
;	O
int	O
assert_dtr	int
;	O
static	O
pthread_cond_t	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
hurdio_assert_dtr_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
;	O
static	O
error_t	int
hurdio_desert_dtr	()->(int)
(	O
)	O
;	O
static	O
void	O
*	O
hurdio_reader_loop	(*(void))->(*(void))
(	O
void	O
*	O
arg	*(void)
)	O
;	O
static	O
void	O
*	O
hurdio_writer_loop	(*(void))->(*(void))
(	O
void	O
*	O
arg	*(void)
)	O
;	O
static	O
error_t	int
hurdio_set_bits	(*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
*	O
state	*(struct(int,int,int,int,char,array(char),int,int))
)	O
;	O
static	O
error_t	int
hurdio_init	()->(int)
(	O
void	O
)	O
{	O
pthread_t	long
thread	long
;	O
error_t	int
err	int
;	O
pthread_cond_init	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)),*(union(array(char),int)))->(int)
(	O
&	O
hurdio_writer_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
NULL	O
)	O
;	O
pthread_cond_init	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)),*(union(array(char),int)))->(int)
(	O
&	O
hurdio_assert_dtr_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
NULL	O
)	O
;	O
err	int
=	O
pthread_create	(*(long),*(union(array(char),long)),*((*(void))->(*(void))),*(void))->(int)
(	O
&	O
thread	long
,	O
NULL	O
,	O
hurdio_reader_loop	(*(void))->(*(void))
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
pthread_detach	(long)->(int)
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	int
;	O
perror	(*(char))->(void)
(	O
"pthread_create"	*(char)
)	O
;	O
}	O
err	int
=	O
pthread_create	(*(long),*(union(array(char),long)),*((*(void))->(*(void))),*(void))->(int)
(	O
&	O
thread	long
,	O
NULL	O
,	O
hurdio_writer_loop	(*(void))->(*(void))
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
pthread_detach	(long)->(int)
(	O
thread	long
)	O
;	O
else	O
{	O
errno	O
=	O
err	int
;	O
perror	(*(char))->(void)
(	O
"pthread_create"	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_fini	()->(int)
(	O
void	O
)	O
{	O
hurdio_desert_dtr	()->(int)
(	O
)	O
;	O
writer_thread	int
=	O
MACH_PORT_NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_gwinsz	(*(struct))->(int)
(	O
struct	O
winsize	O
*	O
size	*(struct)
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_GWINSZ	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocgwinsz	()->(int)
(	O
ioport	int
,	O
size	*(struct)
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
{	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_GWINSZ	int
;	O
err	int
=	O
EOPNOTSUPP	int
;	O
}	O
return	O
err	int
;	O
}	O
return	O
EOPNOTSUPP	int
;	O
}	O
static	O
void	O
wait_for_dtr	()->(void)
(	O
void	O
)	O
{	O
while	O
(	O
!	O
assert_dtr	int
)	O
pthread_hurd_cond_wait_np	()->(int)
(	O
&	O
hurdio_assert_dtr_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
&	O
global_lock	O
)	O
;	O
assert_dtr	int
=	O
0	int
;	O
if	O
(	O
tty_arg	O
==	O
0	int
)	O
ioport	int
=	O
termctl	O
->	O
underlying	O
;	O
else	O
{	O
ioport	int
=	O
file_name_lookup	()->(int)
(	O
tty_arg	O
,	O
O_READ	O
|	O
O_WRITE	O
,	O
0	int
)	O
;	O
if	O
(	O
ioport	int
==	O
MACH_PORT_NULL	O
)	O
{	O
report_carrier_error	()->(int)
(	O
errno	O
)	O
;	O
return	O
;	O
}	O
}	O
error_t	int
err	int
;	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
state	*(struct(int,int,int,int,char,array(char),int,int))
=	O
termstate	O
;	O
tioc_caps	int
=	O
~	O
0	int
;	O
err	int
=	O
hurdio_set_bits	(*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
&	O
state	*(struct(int,int,int,int,char,array(char),int,int))
)	O
;	O
if	O
(	O
err	int
)	O
report_carrier_error	()->(int)
(	O
err	int
)	O
;	O
else	O
{	O
termstate	O
=	O
state	*(struct(int,int,int,int,char,array(char),int,int))
;	O
report_carrier_on	()->(int)
(	O
)	O
;	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
hurdio_writer_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
;	O
}	O
}	O
static	O
void	O
*	O
hurdio_reader_loop	(*(void))->(*(void))
(	O
void	O
*	O
arg	*(void)
)	O
{	O
char	O
buffer	array(char)
[	O
BUFFER_SIZE	int
]	O
;	O
char	O
*	O
data	*(char)
;	O
size_t	long
datalen	long
;	O
error_t	int
err	int
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	O
)	O
;	O
reader_thread	int
=	O
mach_thread_self	()->(int)
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
ioport	int
==	O
MACH_PORT_NULL	O
)	O
wait_for_dtr	()->(void)
(	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	O
)	O
;	O
data	*(char)
=	O
buffer	array(char)
;	O
datalen	long
=	O
BUFFER_SIZE	int
;	O
err	int
=	O
io_read	()->(int)
(	O
ioport	int
,	O
&	O
data	*(char)
,	O
&	O
datalen	long
,	O
-	O
1	int
,	O
BUFFER_SIZE	int
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
err	int
||	O
!	O
datalen	long
)	O
hurdio_desert_dtr	()->(int)
(	O
)	O
;	O
else	O
{	O
if	O
(	O
termstate	O
.	O
c_cflag	int
&	O
CREAD	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
datalen	long
;	O
i	int
++	O
)	O
if	O
(	O
input_character	()->(int)
(	O
data	*(char)
[	O
i	int
]	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
data	*(char)
!=	O
buffer	array(char)
)	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
(	O
vm_address_t	O
)	O
data	*(char)
,	O
datalen	long
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
*	O
hurdio_writer_loop	(*(void))->(*(void))
(	O
void	O
*	O
arg	*(void)
)	O
{	O
char	O
*	O
bufp	*(char)
;	O
char	O
pending_output	array(char)
[	O
BUFFER_SIZE	int
]	O
;	O
size_t	long
amount	long
;	O
error_t	int
err	int
;	O
int	O
size	*(struct)
;	O
int	O
npending_output_copy	int
;	O
mach_port_t	O
ioport_copy	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	O
)	O
;	O
writer_thread	int
=	O
mach_thread_self	()->(int)
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
writer_thread	int
!=	O
MACH_PORT_NULL	O
&&	O
(	O
ioport	int
==	O
MACH_PORT_NULL	O
||	O
!	O
qsize	()->(int)
(	O
outputq	O
)	O
||	O
output_stopped	int
)	O
)	O
pthread_hurd_cond_wait_np	()->(int)
(	O
&	O
hurdio_writer_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
,	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
writer_thread	int
==	O
MACH_PORT_NULL	O
)	O
return	O
0	int
;	O
size	*(struct)
=	O
qsize	()->(int)
(	O
outputq	O
)	O
;	O
if	O
(	O
size	*(struct)
+	O
npending_output	long
>	O
BUFFER_SIZE	int
)	O
size	*(struct)
=	O
BUFFER_SIZE	int
-	O
npending_output	long
;	O
bufp	*(char)
=	O
pending_output	array(char)
+	O
npending_output	long
;	O
npending_output	long
+=	O
size	*(struct)
;	O
npending_output_copy	int
=	O
npending_output	long
;	O
ioport_copy	O
=	O
ioport	int
;	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ioport_copy	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
1	int
)	O
;	O
while	O
(	O
size	*(struct)
--	O
)	O
*	O
bufp	*(char)
++	O
=	O
dequeue	()->(int)
(	O
outputq	O
)	O
;	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	O
)	O
;	O
err	int
=	O
io_write	()->(int)
(	O
ioport_copy	O
,	O
pending_output	array(char)
,	O
npending_output_copy	int
,	O
-	O
1	int
,	O
&	O
amount	long
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long)))->(int)
(	O
&	O
global_lock	O
)	O
;	O
mach_port_mod_refs	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ioport_copy	O
,	O
MACH_PORT_RIGHT_SEND	O
,	O
-	O
1	int
)	O
;	O
if	O
(	O
err	int
)	O
hurdio_desert_dtr	()->(int)
(	O
)	O
;	O
else	O
{	O
if	O
(	O
amount	long
>=	O
npending_output	long
)	O
{	O
npending_output	long
=	O
0	int
;	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
outputq	O
->	O
wait	O
)	O
;	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
select_alert	O
)	O
;	O
}	O
else	O
{	O
npending_output	long
-=	O
amount	long
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
pending_output	array(char)
,	O
pending_output	array(char)
+	O
amount	long
,	O
npending_output	long
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_start_output	()->(int)
(	O
)	O
{	O
if	O
(	O
output_stopped	int
&&	O
!	O
(	O
termflags	O
&	O
USER_OUTPUT_SUSP	O
)	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_START	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocstart	()->(int)
(	O
ioport	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_START	int
;	O
}	O
output_stopped	int
=	O
0	int
;	O
}	O
pthread_cond_broadcast	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
hurdio_writer_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_set_break	()->(int)
(	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_SBRK	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocsbrk	()->(int)
(	O
ioport	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_SBRK	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_clear_break	()->(int)
(	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_CBRK	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tioccbrk	()->(int)
(	O
ioport	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_CBRK	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_abandon_physical_output	()->(int)
(	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_FLUSH	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocflush	()->(int)
(	O
ioport	int
,	O
O_WRITE	O
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_FLUSH	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
npending_output	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_suspend_physical_output	()->(int)
(	O
)	O
{	O
if	O
(	O
!	O
output_stopped	int
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_STOP	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocstop	()->(int)
(	O
ioport	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_STOP	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
output_stopped	int
=	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_notice_input_flushed	()->(int)
(	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_FLUSH	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocflush	()->(int)
(	O
ioport	int
,	O
O_READ	O
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_FLUSH	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
hurdio_pending_output_size	()->(int)
(	O
)	O
{	O
int	O
queue_size	int
=	O
0	int
;	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_OUTQ	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocoutq	()->(int)
(	O
ioport	int
,	O
&	O
queue_size	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_OUTQ	int
;	O
else	O
if	O
(	O
err	int
)	O
queue_size	int
=	O
0	int
;	O
}	O
return	O
queue_size	int
+	O
npending_output	long
;	O
}	O
static	O
error_t	int
hurdio_desert_dtr	()->(int)
(	O
)	O
{	O
if	O
(	O
writer_thread	int
!=	O
MACH_PORT_NULL	O
)	O
hurd_thread_cancel	()->(int)
(	O
writer_thread	int
)	O
;	O
if	O
(	O
reader_thread	int
!=	O
MACH_PORT_NULL	O
)	O
hurd_thread_cancel	()->(int)
(	O
reader_thread	int
)	O
;	O
if	O
(	O
ioport	int
!=	O
MACH_PORT_NULL	O
&&	O
tty_arg	O
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ioport	int
)	O
;	O
ioport	int
=	O
MACH_PORT_NULL	O
;	O
}	O
assert_dtr	int
=	O
0	int
;	O
report_carrier_off	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_assert_dtr	()->(int)
(	O
)	O
{	O
if	O
(	O
ioport	int
==	O
MACH_PORT_NULL	O
)	O
{	O
assert_dtr	int
=	O
1	int
;	O
pthread_cond_signal	(*(union(struct(union(long long,struct`),union(long long,struct`),array(int),array(int),int,int,array(int)),array(char),long long)))->(int)
(	O
&	O
hurdio_assert_dtr_condition	union(struct(union(long long,struct(int,int)),union(long long,struct(int,int)),array(int),array(int),int,int,array(int)),array(char),long long)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_set_bits	(*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
*	O
state	*(struct(int,int,int,int,char,array(char),int,int))
)	O
{	O
error_t	int
err	int
;	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
ttystat	struct(int,int,int,int,char,array(char),int,int)
;	O
struct	O
hurd_termios	struct(int,int,int)
{	O
modes_t	O
modes	int
;	O
ccs_t	O
ccs	int
;	O
speeds_t	O
speeds	int
;	O
}	O
*	O
hurd_ttystat	*(struct(int,int,int))
=	O
(	O
struct	O
hurd_termios	struct(int,int,int)
*	O
)	O
&	O
ttystat	struct(int,int,int,int,char,array(char),int,int)
;	O
if	O
(	O
!	O
(	O
state	*(struct(int,int,int,int,char,array(char),int,int))
->	O
c_cflag	int
&	O
CIGNORE	O
)	O
&&	O
ioport	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
if	O
(	O
!	O
(	O
tioc_caps	int
&	O
TIOC_CAP_GETA	int
)	O
)	O
return	O
0	int
;	O
err	int
=	O
tioctl_tiocgeta	()->(int)
(	O
ioport	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
modes	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
ccs	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
speeds	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
{	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_GETA	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_SETA	int
)	O
{	O
if	O
(	O
state	*(struct(int,int,int,int,char,array(char),int,int))
->	O
__ispeed	O
)	O
hurd_ttystat	*(struct(int,int,int))
->	O
speeds	int
[	O
0	int
]	O
=	O
state	*(struct(int,int,int,int,char,array(char),int,int))
->	O
__ispeed	O
;	O
if	O
(	O
state	*(struct(int,int,int,int,char,array(char),int,int))
->	O
__ospeed	O
)	O
hurd_ttystat	*(struct(int,int,int))
->	O
speeds	int
[	O
1	int
]	O
=	O
state	*(struct(int,int,int,int,char,array(char),int,int))
->	O
__ospeed	O
;	O
cfmakeraw	(*(struct(int,int,int,int,char,array(char),int,int)))->(void)
(	O
&	O
ttystat	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
ttystat	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cflag	int
=	O
state	*(struct(int,int,int,int,char,array(char),int,int))
->	O
c_cflag	int
&	O
~	O
HUPCL	int
;	O
err	int
=	O
tioctl_tiocseta	()->(int)
(	O
ioport	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
modes	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
ccs	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
speeds	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_SETA	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
err	int
=	O
tioctl_tiocgeta	()->(int)
(	O
ioport	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
modes	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
ccs	int
,	O
hurd_ttystat	*(struct(int,int,int))
->	O
speeds	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_GETA	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
*	O
state	*(struct(int,int,int,int,char,array(char),int,int))
=	O
ttystat	struct(int,int,int,int,char,array(char),int,int)
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
hurdio_mdmctl	(int,int)->(int)
(	O
int	O
how	int
,	O
int	O
bits	int
)	O
{	O
error_t	int
err	int
;	O
int	O
oldbits	int
,	O
newbits	int
;	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_MODS	int
)	O
{	O
if	O
(	O
(	O
how	int
==	O
MDMCTL_BIS	O
)	O
||	O
(	O
how	int
==	O
MDMCTL_BIC	O
)	O
)	O
{	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_MODG	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocmodg	()->(int)
(	O
ioport	int
,	O
&	O
oldbits	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
{	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_MODG	int
;	O
return	O
EOPNOTSUPP	int
;	O
}	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
else	O
return	O
EOPNOTSUPP	int
;	O
}	O
if	O
(	O
how	int
==	O
MDMCTL_BIS	O
)	O
newbits	int
=	O
(	O
oldbits	int
|	O
bits	int
)	O
;	O
else	O
if	O
(	O
how	int
==	O
MDMCTL_BIC	O
)	O
newbits	int
=	O
(	O
oldbits	int
&=	O
~	O
bits	int
)	O
;	O
else	O
newbits	int
=	O
bits	int
;	O
err	int
=	O
tioctl_tiocmods	()->(int)
(	O
ioport	int
,	O
newbits	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_MODS	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
hurdio_mdmstate	()->(int)
(	O
)	O
{	O
int	O
oldbits	int
;	O
if	O
(	O
tioc_caps	int
&	O
TIOC_CAP_MODG	int
)	O
{	O
error_t	int
err	int
=	O
tioctl_tiocmodg	()->(int)
(	O
ioport	int
,	O
&	O
oldbits	int
)	O
;	O
if	O
(	O
err	int
&&	O
(	O
err	int
==	O
EMIG_BAD_ID	O
||	O
err	int
==	O
EOPNOTSUPP	int
)	O
)	O
tioc_caps	int
&=	O
~	O
TIOC_CAP_MODG	int
;	O
else	O
if	O
(	O
err	int
)	O
return	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
const	O
struct	O
bottomhalf	O
hurdio_bottom	struct
=	O
{	O
TERM_ON_HURDIO	O
,	O
hurdio_init	()->(int)
,	O
hurdio_fini	()->(int)
,	O
hurdio_gwinsz	(*(struct))->(int)
,	O
hurdio_start_output	()->(int)
,	O
hurdio_set_break	()->(int)
,	O
hurdio_clear_break	()->(int)
,	O
hurdio_abandon_physical_output	()->(int)
,	O
hurdio_suspend_physical_output	()->(int)
,	O
hurdio_pending_output_size	()->(int)
,	O
hurdio_notice_input_flushed	()->(int)
,	O
hurdio_assert_dtr	()->(int)
,	O
hurdio_desert_dtr	()->(int)
,	O
hurdio_set_bits	(*(struct(int,int,int,int,char,array(char),int,int)))->(int)
,	O
hurdio_mdmctl	(int,int)->(int)
,	O
hurdio_mdmstate	()->(int)
,	O
}	O
;	O
