static	O
const	O
char	O
cright_years_z	array(char)
[	O
]	O
=	O
"1994-2015"	*(char)
;	O
static	O
inline	O
unsigned	O
char	O
to_uchar	(char)->(char)
(	O
char	O
ch	char
)	O
{	O
return	O
ch	char
;	O
}	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
)	O
;	O
static	O
char	O
explain_text_fmt	array(char)
[	O
sizeof	O
(	O
explain_fmt_fmt_z	array(char)
)	O
]	O
;	O
static	O
int	O
const	O
explain_1_len	int
=	O
sizeof	O
(	O
explain_1_z	array(char)
)	O
-	O
1	int
;	O
static	O
int	O
const	O
explain_2_len	int
=	O
sizeof	O
(	O
explain_2_z	array(char)
)	O
-	O
1	int
;	O
typedef	O
enum	O
{	O
QUOT_ID_LNAME	int
,	O
QUOT_ID_RNAME	int
,	O
QUOT_ID_PATH	int
}	O
quot_id_t	enum(int,int,int)
;	O
typedef	O
struct	O
{	O
char	O
const	O
*	O
cmpr_name	*(char)
;	O
char	O
const	O
*	O
cmpr_cmd_fmt	*(char)
;	O
char	O
const	O
*	O
cmpr_title	*(char)
;	O
char	O
const	O
*	O
cmpr_mode	*(char)
;	O
char	O
const	O
*	O
cmpr_unpack	*(char)
;	O
char	O
const	O
*	O
cmpr_unnote	*(char)
;	O
unsigned	O
long	O
cmpr_level	long
;	O
}	O
compact_state_t	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
;	O
compact_state_t	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
gzip_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
=	O
{	O
.	O
cmpr_name	*(char)
=	O
"gzip"	*(char)
,	O
.	O
cmpr_cmd_fmt	*(char)
=	O
"gzip -c -%u %s"	*(char)
,	O
.	O
cmpr_title	*(char)
=	O
"gzipped"	*(char)
,	O
.	O
cmpr_mode	*(char)
=	O
"gzi"	*(char)
,	O
.	O
cmpr_unpack	*(char)
=	O
"gzip -dc ${lock_dir}/gzi > %s && \\\n"	*(char)
,	O
.	O
cmpr_unnote	*(char)
=	O
"gunzipping file %s"	*(char)
}	O
;	O
compact_state_t	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
xz_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
=	O
{	O
.	O
cmpr_name	*(char)
=	O
"xz"	*(char)
,	O
.	O
cmpr_cmd_fmt	*(char)
=	O
"xz -zc -%u %s"	*(char)
,	O
.	O
cmpr_title	*(char)
=	O
"xz-compressed"	*(char)
,	O
.	O
cmpr_mode	*(char)
=	O
"xzi"	*(char)
,	O
.	O
cmpr_unpack	*(char)
=	O
"xz -dc ${lock_dir}/xzi > %s && \\\n"	*(char)
,	O
.	O
cmpr_unnote	*(char)
=	O
"xz-decompressing file %s"	*(char)
}	O
;	O
compact_state_t	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
bzip2_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
=	O
{	O
.	O
cmpr_name	*(char)
=	O
"bzip2"	*(char)
,	O
.	O
cmpr_cmd_fmt	*(char)
=	O
"bzip2 -zkc -%u %s"	*(char)
,	O
.	O
cmpr_title	*(char)
=	O
"bzipped"	*(char)
,	O
.	O
cmpr_mode	*(char)
=	O
"bzi"	*(char)
,	O
.	O
cmpr_unpack	*(char)
=	O
"bzip2 -dkc ${lock_dir}/bzi > %s && \\\n"	*(char)
,	O
.	O
cmpr_unnote	*(char)
=	O
"bunzipping file %s"	*(char)
}	O
;	O
compact_state_t	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
*	O
const	O
compaction	array(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long)))
[	O
]	O
=	O
{	O
&	O
gzip_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
,	O
&	O
xz_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
,	O
&	O
bzip2_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
}	O
;	O
compact_state_t	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
*	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
=	O
NULL	O
;	O
static	O
int	O
const	O
compact_ct	int
=	O
sizeof	O
(	O
compaction	array(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long)))
)	O
/	O
sizeof	O
(	O
compaction	array(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long)))
[	O
0	int
]	O
)	O
;	O
static	O
int	O
line_prefix	int
=	O
'\0'	O
;	O
static	O
size_t	long
here_delimiter_length	long
=	O
0	int
;	O
typedef	O
enum	O
{	O
fail	int
=	O
~	O
1	int
,	O
doue_true	int
=	O
true	int
,	O
doue_false	int
=	O
false	int
}	O
do_uue_t	enum(int,int,int)
;	O
do_uue_t	enum(int,int,int)
uuencode_file	enum(int,int,int)
=	O
fail	int
;	O
int	O
opt_idx	int
=	O
0	int
;	O
static	O
FILE	struct
*	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
static	O
off_t	long
archive_type_position	long
=	O
0	int
;	O
static	O
off_t	long
first_file_position	long
=	O
0	int
;	O
static	O
char	O
*	O
output_filename	*(char)
=	O
NULL	O
;	O
static	O
int	O
part_number	int
=	O
0	int
;	O
static	O
unsigned	O
char	O
byte_is_binary	array(char)
[	O
256	int
]	O
;	O
static	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
static	O
int	O
sharpid	int
=	O
0	int
;	O
static	O
int	O
translate_script	int
=	O
0	int
;	O
static	O
int	O
mkdir_alloc_ct	int
=	O
0	int
;	O
static	O
int	O
mkdir_already_ct	int
=	O
0	int
;	O
static	O
char	O
*	O
*	O
mkdir_already	*(*(char))
;	O
static	O
void	O
open_output	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
close_output	(int)->(void)
(	O
int	O
next_part_no	int
)	O
;	O
typedef	O
int	O
(	O
*	O
walker_t	*((*(char),*(char))->(int))
)	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
init_shar_msg	()->(void)
(	O
void	O
)	O
{	O
int	O
ix	int
;	O
struct	O
quoting_options	O
*	O
alwaysq	*(struct)
,	O
*	O
doubleq	*(struct)
;	O
if	O
(	O
translate_script	int
)	O
{	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
SHAR_MSG_CT	int
;	O
ix	int
++	O
)	O
shar_msg_table	array(*(char))
[	O
ix	int
]	O
=	O
gettext	(*(char))->(*(char))
(	O
shar_msg_table	array(*(char))
[	O
ix	int
]	O
)	O
;	O
}	O
alwaysq	*(struct)
=	O
clone_quoting_options	(*(struct))->(*(struct))
(	O
NULL	O
)	O
;	O
set_quoting_style	(*(struct),enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
alwaysq	*(struct)
,	O
shell_always_quoting_style	int
)	O
;	O
doubleq	*(struct)
=	O
clone_quoting_options	(*(struct))->(*(struct))
(	O
NULL	O
)	O
;	O
set_quoting_style	(*(struct),enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
doubleq	*(struct)
,	O
c_quoting_style	int
)	O
;	O
set_char_quoting	(*(struct),char,int)->(int)
(	O
doubleq	*(struct)
,	O
'"'	O
,	O
1	int
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
SHAR_MSG_CT	int
;	O
ix	int
++	O
)	O
{	O
char	O
const	O
*	O
pz	*(char)
=	O
shar_msg_table	array(*(char))
[	O
ix	int
]	O
;	O
switch	O
(	O
shar_msg_xform	array(enum(int,int,int))
[	O
ix	int
]	O
)	O
{	O
case	O
XFORM_PLAIN	int
:	O
continue	O
;	O
case	O
XFORM_APOSTROPHE	int
:	O
pz	*(char)
=	O
quotearg_alloc	(*(char),long,*(struct))->(*(char))
(	O
pz	*(char)
,	O
shar_msg_size	array(long)
[	O
ix	int
]	O
,	O
alwaysq	*(struct)
)	O
;	O
break	O
;	O
case	O
XFORM_DBL_QUOTE	int
:	O
pz	*(char)
=	O
quotearg_alloc	(*(char),long,*(struct))->(*(char))
(	O
pz	*(char)
,	O
shar_msg_size	array(long)
[	O
ix	int
]	O
,	O
doubleq	*(struct)
)	O
;	O
break	O
;	O
}	O
shar_msg_table	array(*(char))
[	O
ix	int
]	O
=	O
pz	*(char)
;	O
}	O
free	(*(void))->(void)
(	O
alwaysq	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
doubleq	*(struct)
)	O
;	O
}	O
static	O
char	O
const	O
*	O
format_report	(*(char),*(char))->(*(char))
(	O
char	O
const	O
*	O
fmt	*(char)
,	O
char	O
const	O
*	O
what	*(char)
)	O
{	O
if	O
(	O
fmt	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
{	O
size_t	long
sz	long
=	O
strlen	(*(char))->(long)
(	O
fmt	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
what	*(char)
)	O
+	O
2	int
;	O
char	O
*	O
res	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
int	O
len	long
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
res	*(char)
,	O
sz	long
,	O
fmt	*(char)
,	O
what	*(char)
)	O
;	O
if	O
(	O
(	O
unsigned	O
)	O
len	long
<	O
sz	long
)	O
return	O
res	*(char)
;	O
if	O
(	O
len	long
<	O
0	int
)	O
die	(int,*(char))->(void)
(	O
SHAR_EXIT_BUG	int
,	O
_	O
(	O
"printf formatting error:  %s\n"	*(char)
)	O
,	O
fmt	*(char)
)	O
;	O
res	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
return	O
res	*(char)
;	O
}	O
}	O
static	O
void	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
const	O
char	O
*	O
test	*(char)
,	O
const	O
char	O
*	O
ok_fmt	*(char)
,	O
const	O
char	O
*	O
bad_fmt	*(char)
,	O
const	O
char	O
*	O
what	*(char)
,	O
int	O
die_on_failure	int
)	O
{	O
char	O
const	O
*	O
good_quot	*(char)
;	O
char	O
const	O
*	O
bad_quot	*(char)
;	O
char	O
const	O
*	O
die_str	*(char)
;	O
good_quot	*(char)
=	O
format_report	(*(char),*(char))->(*(char))
(	O
ok_fmt	*(char)
,	O
what	*(char)
)	O
;	O
bad_quot	*(char)
=	O
format_report	(*(char),*(char))->(*(char))
(	O
bad_fmt	*(char)
,	O
what	*(char)
)	O
;	O
die_str	*(char)
=	O
die_on_failure	int
?	O
show_status_dies_z	array(char)
:	O
""	*(char)
;	O
if	O
(	O
good_quot	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
bad_quot	*(char)
!=	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
show_all_status_z	array(char)
,	O
test	*(char)
,	O
good_quot	*(char)
,	O
bad_quot	*(char)
,	O
die_str	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
show_good_status_z	array(char)
,	O
test	*(char)
,	O
good_quot	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
bad_quot	*(char)
!=	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
show_bad_status_z	array(char)
,	O
test	*(char)
,	O
bad_quot	*(char)
,	O
die_str	*(char)
)	O
;	O
else	O
die	(int,*(char))->(void)
(	O
SHAR_EXIT_BUG	int
,	O
_	O
(	O
"sharutils bug - no status"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
echo_text	(*(char),*(char),bool)->(void)
(	O
const	O
char	O
*	O
format_pz	*(char)
,	O
const	O
char	O
*	O
arg_pz	*(char)
,	O
bool	bool
cascade	bool
)	O
{	O
static	O
char	O
const	O
continue_z	array(char)
[	O
]	O
=	O
" &&\n"	*(char)
;	O
size_t	long
sz	long
=	O
strlen	(*(char))->(long)
(	O
format_pz	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
arg_pz	*(char)
)	O
+	O
sizeof	O
(	O
continue_z	array(char)
)	O
;	O
char	O
*	O
bf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
unsigned	O
int	O
len	long
=	O
(	O
unsigned	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
bf	*(char)
,	O
sz	long
,	O
format_pz	*(char)
,	O
arg_pz	*(char)
)	O
;	O
if	O
(	O
cascade	bool
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bf	*(char)
+	O
len	long
,	O
continue_z	array(char)
,	O
sizeof	O
(	O
continue_z	array(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
echo_string_z	array(char)
,	O
bf	*(char)
)	O
;	O
}	O
static	O
int	O
walkdown	(*((*(char),*(char))->(int)),*(char),*(char))->(int)
(	O
walker_t	*((*(char),*(char))->(int))
routine	*((*(char),*(char))->(int))
,	O
const	O
char	O
*	O
local_name	*(char)
,	O
const	O
char	O
*	O
restore_name	*(char)
)	O
{	O
DIR	struct
*	O
directory	*(struct)
;	O
int	O
status	int
;	O
char	O
*	O
local_name_copy	*(char)
;	O
size_t	long
local_name_length	long
;	O
size_t	long
sizeof_local_name	long
;	O
char	O
*	O
restore_name_copy	*(char)
;	O
int	O
restore_offset	int
;	O
size_t	long
restore_name_length	long
;	O
size_t	long
sizeof_restore_name	long
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
local_name	*(char)
,	O
&	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
local_name	*(char)
)	O
;	O
return	O
SHAR_EXIT_FILE_NOT_FOUND	int
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
return	O
(	O
*	O
routine	*((*(char),*(char))->(int))
)	O
(	O
local_name	*(char)
,	O
restore_name	*(char)
)	O
;	O
if	O
(	O
directory	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
local_name	*(char)
)	O
,	O
!	O
directory	*(struct)
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
local_name	*(char)
)	O
;	O
return	O
SHAR_EXIT_CANNOT_OPENDIR	int
;	O
}	O
status	int
=	O
0	int
;	O
local_name_length	long
=	O
strlen	(*(char))->(long)
(	O
local_name	*(char)
)	O
+	O
1	int
;	O
sizeof_local_name	long
=	O
local_name_length	long
+	O
32	int
;	O
local_name_copy	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof_local_name	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
local_name_copy	*(char)
,	O
local_name	*(char)
,	O
local_name_length	long
-	O
1	int
)	O
;	O
local_name_copy	*(char)
[	O
local_name_length	long
-	O
1	int
]	O
=	O
'/'	O
;	O
local_name_copy	*(char)
[	O
local_name_length	long
]	O
=	O
NUL	char
;	O
restore_name_length	long
=	O
strlen	(*(char))->(long)
(	O
restore_name	*(char)
)	O
+	O
1	int
;	O
sizeof_restore_name	long
=	O
restore_name_length	long
+	O
32	int
;	O
restore_name_copy	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof_restore_name	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
restore_name_copy	*(char)
,	O
restore_name	*(char)
,	O
restore_name_length	long
-	O
1	int
)	O
;	O
restore_name_copy	*(char)
[	O
restore_name_length	long
-	O
1	int
]	O
=	O
'/'	O
;	O
restore_name_copy	*(char)
[	O
restore_name_length	long
]	O
=	O
NUL	char
;	O
if	O
(	O
(	O
restore_name_copy	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
&&	O
(	O
restore_name_copy	*(char)
[	O
1	int
]	O
==	O
'/'	O
)	O
)	O
restore_offset	int
=	O
2	int
;	O
else	O
restore_offset	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
entry	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
directory	*(struct)
)	O
;	O
const	O
char	O
*	O
pzN	*(char)
;	O
int	O
space_need	int
;	O
if	O
(	O
entry	*(struct(long,long,short,char,array(char)))
==	O
NULL	O
)	O
break	O
;	O
pzN	*(char)
=	O
entry	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
;	O
if	O
(	O
*	O
pzN	*(char)
==	O
'.'	O
)	O
{	O
if	O
(	O
pzN	*(char)
[	O
1	int
]	O
==	O
NUL	char
)	O
continue	O
;	O
if	O
(	O
(	O
pzN	*(char)
[	O
1	int
]	O
==	O
'.'	O
)	O
&&	O
(	O
pzN	*(char)
[	O
2	int
]	O
==	O
NUL	char
)	O
)	O
continue	O
;	O
}	O
space_need	int
=	O
1	int
+	O
NAMLEN	O
(	O
entry	*(struct(long,long,short,char,array(char)))
)	O
;	O
if	O
(	O
local_name_length	long
+	O
space_need	int
>	O
sizeof_local_name	long
)	O
{	O
sizeof_local_name	long
=	O
local_name_length	long
+	O
space_need	int
+	O
16	int
;	O
local_name_copy	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
local_name_copy	*(char)
,	O
sizeof_local_name	long
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
local_name_copy	*(char)
+	O
local_name_length	long
,	O
pzN	*(char)
)	O
;	O
if	O
(	O
restore_name_length	long
+	O
space_need	int
>	O
sizeof_restore_name	long
)	O
{	O
sizeof_restore_name	long
=	O
restore_name_length	long
+	O
space_need	int
+	O
16	int
;	O
restore_name_copy	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
restore_name_copy	*(char)
,	O
sizeof_restore_name	long
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
restore_name_copy	*(char)
+	O
restore_name_length	long
,	O
pzN	*(char)
)	O
;	O
status	int
=	O
walkdown	(*((*(char),*(char))->(int)),*(char),*(char))->(int)
(	O
routine	*((*(char),*(char))->(int))
,	O
local_name_copy	*(char)
,	O
restore_name_copy	*(char)
+	O
restore_offset	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
local_name_copy	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
restore_name_copy	*(char)
)	O
;	O
if	O
(	O
closedir	(*(struct))->(int)
(	O
directory	*(struct)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
local_name	*(char)
)	O
;	O
return	O
SHAR_EXIT_CANNOT_OPENDIR	int
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
walktree	(*((*(char),*(char))->(int)),*(char))->(int)
(	O
walker_t	*((*(char),*(char))->(int))
routine	*((*(char),*(char))->(int))
,	O
const	O
char	O
*	O
local_name	*(char)
)	O
{	O
const	O
char	O
*	O
restore_name	*(char)
;	O
char	O
*	O
local_name_copy	*(char)
;	O
{	O
int	O
len	long
=	O
strlen	(*(char))->(long)
(	O
local_name	*(char)
)	O
;	O
char	O
*	O
cursor	*(char)
;	O
local_name_copy	*(char)
=	O
(	O
char	O
*	O
)	O
alloca	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
local_name_copy	*(char)
,	O
local_name	*(char)
,	O
len	long
+	O
1	int
)	O
;	O
cursor	*(char)
=	O
local_name_copy	*(char)
+	O
len	long
-	O
1	int
;	O
while	O
(	O
*	O
cursor	*(char)
==	O
'/'	O
&&	O
cursor	*(char)
>	O
local_name_copy	*(char)
)	O
*	O
(	O
cursor	*(char)
--	O
)	O
=	O
NUL	char
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
BASENAME	O
)	O
)	O
restore_name	*(char)
=	O
base_name	(*(char))->(*(char))
(	O
local_name_copy	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
local_name_copy	*(char)
,	O
"./"	*(char)
,	O
2	int
)	O
)	O
restore_name	*(char)
=	O
local_name_copy	*(char)
+	O
2	int
;	O
else	O
restore_name	*(char)
=	O
local_name_copy	*(char)
;	O
return	O
walkdown	(*((*(char),*(char))->(int)),*(char),*(char))->(int)
(	O
routine	*((*(char),*(char))->(int))
,	O
local_name_copy	*(char)
,	O
restore_name	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
mode_string	(int)->(*(char))
(	O
unsigned	O
mode	int
)	O
{	O
static	O
char	O
const	O
modes	int
[	O
]	O
=	O
"-rwxrwxrwx"	*(char)
;	O
static	O
char	O
result	array(char)
[	O
12	int
]	O
;	O
int	O
ix	int
=	O
1	int
;	O
int	O
msk	int
=	O
0400	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
result	array(char)
,	O
"----------"	*(char)
)	O
;	O
do	O
{	O
if	O
(	O
mode	int
&	O
msk	int
)	O
result	array(char)
[	O
ix	int
]	O
=	O
modes	int
[	O
ix	int
]	O
;	O
ix	int
++	O
;	O
msk	int
>>=	O
1	int
;	O
}	O
while	O
(	O
msk	int
!=	O
0	int
)	O
;	O
if	O
(	O
mode	int
&	O
04000	int
)	O
result	array(char)
[	O
3	int
]	O
=	O
's'	O
;	O
if	O
(	O
mode	int
&	O
02000	int
)	O
result	array(char)
[	O
6	int
]	O
=	O
's'	O
;	O
return	O
result	array(char)
;	O
}	O
static	O
void	O
generate_configure	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_MD5_DIGEST	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
md5check_z	array(char)
,	O
SM_not_verifying_sums	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
clobber_check_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_I18N	O
)	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
i18n_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
VANILLA_OPERATION	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dev_tty_nocheck_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dev_tty_check_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
echo_checks_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_TIMESTAMP	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
timestamp_z	array(char)
,	O
SM_time_not_set	O
)	O
;	O
}	O
if	O
(	O
(	O
!	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
)	O
||	O
(	O
part_number	int
==	O
1	int
)	O
)	O
{	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
ck_lockdir_z	array(char)
,	O
NULL	O
,	O
SM_lock_dir_exists	O
,	O
lock_dir_z	array(char)
,	O
1	int
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
VANILLA_OPERATION	O
)	O
)	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
make_lock_dir_z	array(char)
,	O
NULL	O
,	O
SM_no_lock_dir	O
,	O
lock_dir_z	array(char)
,	O
1	int
)	O
;	O
else	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
make_lock_dir_z	array(char)
,	O
SM_x_lock_dir_created	O
,	O
SM_x_no_lock_dir	O
,	O
lock_dir_z	array(char)
,	O
1	int
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
seq_check_z	array(char)
,	O
SM_unpack_part_1	O
,	O
part_number	int
,	O
SM_unpack_next_part	O
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
query_answers_z	array(char)
,	O
SM_ans_yes	O
,	O
SM_yes_means	O
,	O
SM_ans_no	O
,	O
SM_no_means	O
,	O
SM_ans_all	O
,	O
SM_all_means	O
,	O
SM_ans_none	O
,	O
SM_none_means	O
,	O
SM_ans_help	O
,	O
SM_help_means	O
,	O
SM_ans_quit	O
,	O
SM_quit_means	O
)	O
;	O
}	O
}	O
static	O
void	O
generate_mkdir	(*(char))->(void)
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
const	O
char	O
*	O
quoted_path	*(char)
;	O
{	O
int	O
ct	int
=	O
mkdir_already_ct	int
;	O
char	O
*	O
*	O
pp	*(*(char))
=	O
mkdir_already	*(*(char))
;	O
while	O
(	O
--	O
ct	int
>	O
0	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
(	O
pp	*(*(char))
++	O
)	O
,	O
path	*(char)
)	O
==	O
0	int
)	O
return	O
;	O
}	O
}	O
if	O
(	O
++	O
mkdir_already_ct	int
>	O
mkdir_alloc_ct	int
)	O
{	O
mkdir_alloc_ct	int
+=	O
16	int
+	O
(	O
mkdir_alloc_ct	int
/	O
2	int
)	O
;	O
if	O
(	O
mkdir_alloc_ct	int
<	O
0	int
)	O
die	(int,*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"Too many directories for mkdir generation"	*(char)
)	O
)	O
;	O
if	O
(	O
mkdir_already	*(*(char))
!=	O
NULL	O
)	O
mkdir_already	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
mkdir_already	*(*(char))
,	O
mkdir_alloc_ct	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
else	O
mkdir_already	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
mkdir_alloc_ct	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
}	O
mkdir_already	*(*(char))
[	O
mkdir_already_ct	int
-	O
1	int
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
path	*(char)
)	O
;	O
quoted_path	*(char)
=	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
QUOT_ID_PATH	int
,	O
shell_always_quoting_style	int
,	O
path	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
dir_check_z	array(char)
,	O
quoted_path	*(char)
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
dir_create_z	array(char)
,	O
quoted_path	*(char)
)	O
;	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
aok_check_z	array(char)
,	O
SM_x_dir_created	O
,	O
SM_x_no_dir	O
,	O
path	*(char)
,	O
1	int
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  mkdir %s || exit 1\n"	*(char)
,	O
quoted_path	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"fi\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
clear_mkdir_already	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
*	O
pp	*(*(char))
=	O
mkdir_already	*(*(char))
;	O
int	O
ct	int
=	O
mkdir_already_ct	int
;	O
mkdir_already_ct	int
=	O
0	int
;	O
while	O
(	O
--	O
ct	int
>=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
*	O
pp	*(*(char))
)	O
;	O
*	O
(	O
pp	*(*(char))
++	O
)	O
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
generate_mkdir_script	(*(char))->(void)
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
char	O
*	O
cursor	*(char)
;	O
for	O
(	O
cursor	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
path	*(char)
,	O
'/'	O
)	O
;	O
cursor	*(char)
;	O
cursor	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cursor	*(char)
+	O
1	int
,	O
'/'	O
)	O
)	O
{	O
if	O
(	O
cursor	*(char)
==	O
path	*(char)
||	O
*	O
(	O
cursor	*(char)
-	O
1	int
)	O
==	O
'/'	O
)	O
continue	O
;	O
if	O
(	O
cursor	*(char)
[	O
-	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
cursor	*(char)
==	O
path	*(char)
+	O
1	int
||	O
cursor	*(char)
[	O
-	O
2	int
]	O
==	O
'/'	O
)	O
)	O
continue	O
;	O
*	O
cursor	*(char)
=	O
0	int
;	O
generate_mkdir	(*(char))->(void)
(	O
path	*(char)
)	O
;	O
*	O
cursor	*(char)
=	O
'/'	O
;	O
}	O
}	O
static	O
int	O
check_accessibility	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
local_name	*(char)
,	O
const	O
char	O
*	O
restore_name	*(char)
)	O
{	O
if	O
(	O
access	(*(char),int)->(int)
(	O
local_name	*(char)
,	O
4	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot access %s"	*(char)
)	O
,	O
local_name	*(char)
)	O
;	O
return	O
SHAR_EXIT_FILE_NOT_FOUND	int
;	O
}	O
return	O
SHAR_EXIT_SUCCESS	int
;	O
}	O
static	O
int	O
generate_one_header_line	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
local_name	*(char)
,	O
const	O
char	O
*	O
restore_name	*(char)
)	O
{	O
char	O
buf	array(char)
[	O
INT_BUFSIZE_BOUND	O
(	O
off_t	long
)	O
]	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"# %6s %s %s\n"	*(char)
,	O
offtostr	(long,*(char))->(*(char))
(	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
,	O
buf	array(char)
)	O
,	O
mode_string	(int)->(*(char))
(	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
,	O
restore_name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_caution_notes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
{	O
char	O
const	O
*	O
msg	*(char)
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
msg	*(char)
=	O
exist_keep_z	array(char)
;	O
else	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
msg	*(char)
=	O
exist_ask_z	array(char)
;	O
else	O
msg	*(char)
=	O
exist_kill_z	array(char)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
exist_note_z	array(char)
,	O
msg	*(char)
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
)	O
{	O
int	O
len	long
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
explain_text_fmt	array(char)
,	O
sizeof	O
(	O
explain_text_fmt	array(char)
)	O
,	O
explain_fmt_fmt_z	array(char)
,	O
explain_1_len	int
,	O
explain_2_len	int
)	O
;	O
if	O
(	O
(	O
unsigned	O
)	O
len	long
>=	O
sizeof	O
(	O
explain_text_fmt	array(char)
)	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
explain_text_fmt	array(char)
,	O
"#%-256s\n#%-256s\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"#\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
archive_type_position	long
=	O
ftello	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
explain_text_fmt	array(char)
,	O
""	*(char)
,	O
""	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
print_header_stamp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
{	O
char	O
const	O
*	O
pz	*(char)
=	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
:	O
""	*(char)
;	O
char	O
const	O
*	O
ch	char
=	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
", a shell"	*(char)
:	O
"a shell"	*(char)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
file_leader_z	array(char)
,	O
pz	*(char)
,	O
ch	char
,	O
PACKAGE	*(char)
,	O
VERSION	*(char)
,	O
sharpid	int
)	O
;	O
}	O
{	O
static	O
char	O
ftime_fmt	array(char)
[	O
]	O
=	O
"%Y-%m-%d %H:%M %Z"	*(char)
;	O
char	O
buffer	array(int)
[	O
sizeof	O
(	O
ftime_fmt	array(char)
)	O
+	O
64	int
]	O
;	O
time_t	long
now	long
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
local_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
;	O
time	struct(long,long)
(	O
&	O
now	long
)	O
;	O
local_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
now	long
)	O
;	O
{	O
size_t	long
l	long
=	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buffer	array(int)
,	O
sizeof	O
(	O
buffer	array(int)
)	O
-	O
1	int
,	O
ftime_fmt	array(char)
,	O
local_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
)	O
;	O
if	O
(	O
l	long
==	O
0	int
)	O
{	O
ftime_fmt	array(char)
[	O
sizeof	O
(	O
ftime_fmt	array(char)
)	O
-	O
2	int
]	O
=	O
'z'	O
;	O
l	long
=	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buffer	array(int)
,	O
sizeof	O
(	O
buffer	array(int)
)	O
-	O
1	int
,	O
ftime_fmt	array(char)
,	O
local_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
)	O
;	O
}	O
if	O
(	O
l	long
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
made_on_comment_z	array(char)
,	O
buffer	array(int)
,	O
OPT_ARG	O
(	O
SUBMITTER	O
)	O
)	O
;	O
}	O
}	O
{	O
char	O
*	O
c_dir	*(char)
=	O
xgetcwd	()->(*(char))
(	O
)	O
;	O
if	O
(	O
c_dir	*(char)
!=	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
source_dir_comment_z	array(char)
,	O
c_dir	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
c_dir	*(char)
)	O
;	O
}	O
else	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot get current directory name"	*(char)
)	O
)	O
;	O
}	O
}	O
static	O
void	O
generate_full_header	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
const	O
*	O
argv	*(*(char))
)	O
{	O
int	O
counter	int
;	O
for	O
(	O
counter	int
=	O
0	int
;	O
counter	int
<	O
argc	int
;	O
counter	int
++	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
argv	*(*(char))
[	O
counter	int
]	O
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
walktree	(*((*(char),*(char))->(int)),*(char))->(int)
(	O
check_accessibility	(*(char),*(char))->(int)
,	O
argv	*(*(char))
[	O
counter	int
]	O
)	O
)	O
exit	(int)->(void)
(	O
SHAR_EXIT_FAILED	int
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
NET_HEADERS	O
)	O
)	O
{	O
static	O
char	O
const	O
by	array(char)
[	O
]	O
=	O
"Submitted-by: %s\nArchive-name: %s%s%02d\n\n"	*(char)
;	O
bool	bool
has_slash	bool
=	O
(	O
strchr	(*(char),int)->(*(char))
(	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
'/'	O
)	O
!=	O
NULL	O
)	O
;	O
int	O
part	int
=	O
(	O
part_number	int
>	O
0	int
)	O
?	O
part_number	int
:	O
1	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
by	array(char)
,	O
OPT_ARG	O
(	O
SUBMITTER	O
)	O
,	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
has_slash	bool
?	O
""	*(char)
:	O
"/part"	*(char)
,	O
part	int
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
CUT_MARK	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cut_mark_line_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_header_stamp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_caution_notes	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
contents_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
counter	int
=	O
0	int
;	O
counter	int
<	O
argc	int
;	O
counter	int
++	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
argv	*(*(char))
[	O
counter	int
]	O
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
continue	O
;	O
(	O
void	O
)	O
walktree	(*((*(char),*(char))->(int)),*(char))->(int)
(	O
generate_one_header_line	(*(char),*(char))->(int)
,	O
argv	*(*(char))
[	O
counter	int
]	O
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"#\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
generate_configure	()->(void)
(	O
)	O
;	O
}	O
void	O
change_files	(*(char),*(long))->(void)
(	O
const	O
char	O
*	O
restore_name	*(char)
,	O
off_t	long
*	O
remaining_size	*(long)
)	O
{	O
DEBUG_PRINT	O
(	O
"New file, remaining %s, "	*(char)
,	O
*	O
remaining_size	*(long)
)	O
;	O
DEBUG_PRINT	O
(	O
"Limit still %s\n"	*(char)
,	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" :\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
"test $? -ne 0"	*(char)
,	O
SM_restore_failed	O
,	O
NULL	O
,	O
restore_name	*(char)
,	O
0	int
)	O
;	O
{	O
size_t	long
sz	long
=	O
strlen	(*(char))->(long)
(	O
SM_end_of_part	O
)	O
+	O
2	int
*	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
bf	*(char)
,	O
sz	long
,	O
SM_end_of_part	O
,	O
part_number	int
,	O
part_number	int
+	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
echo_string_z	array(char)
,	O
bf	*(char)
)	O
;	O
}	O
close_output	(int)->(void)
(	O
part_number	int
+	O
1	int
)	O
;	O
clear_mkdir_already	()->(void)
(	O
)	O
;	O
open_output	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Starting file %s\n"	*(char)
)	O
,	O
output_filename	*(char)
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
NET_HEADERS	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Submitted-by: %s\n"	*(char)
,	O
OPT_ARG	O
(	O
SUBMITTER	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Archive-name: %s%s%02d\n\n"	*(char)
,	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
strchr	(*(char),int)->(*(char))
(	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
'/'	O
)	O
?	O
""	*(char)
:	O
"/part"	*(char)
,	O
part_number	int
?	O
part_number	int
:	O
1	int
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
CUT_MARK	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cut_mark_line_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
{	O
static	O
const	O
char	O
part_z	array(char)
[	O
]	O
=	O
"part %02d of %s "	*(char)
;	O
char	O
const	O
*	O
nm	*(char)
=	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
:	O
"a multipart"	*(char)
;	O
off_t	long
len	long
=	O
sizeof	O
(	O
part_z	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
nm	*(char)
)	O
+	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
len	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
bf	*(char)
,	O
len	long
,	O
part_z	array(char)
,	O
part_number	int
,	O
nm	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
file_leader_z	array(char)
,	O
bf	*(char)
,	O
""	*(char)
,	O
PACKAGE	*(char)
,	O
VERSION	*(char)
,	O
sharpid	int
)	O
;	O
}	O
generate_configure	()->(void)
(	O
)	O
;	O
first_file_position	long
=	O
ftello	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
read_byte_size	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
char	O
*	O
wc	*(char)
,	O
size_t	long
wc_sz	long
,	O
FILE	struct
*	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
char	O
*	O
pz	*(char)
=	O
wc	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
ch	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ch	char
==	O
EOF	O
)	O
goto	O
bogus_number	O
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
ch	char
)	O
)	O
{	O
*	O
(	O
pz	*(char)
++	O
)	O
=	O
ch	char
;	O
break	O
;	O
}	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
ch	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
ch	char
)	O
)	O
break	O
;	O
*	O
(	O
pz	*(char)
++	O
)	O
=	O
ch	char
;	O
if	O
(	O
pz	*(char)
>=	O
wc	*(char)
+	O
wc_sz	long
)	O
goto	O
bogus_number	O
;	O
}	O
*	O
pz	*(char)
=	O
NUL	char
;	O
return	O
;	O
bogus_number	O
:	O
wc	*(char)
[	O
0	int
]	O
=	O
'0'	O
;	O
wc	*(char)
[	O
1	int
]	O
=	O
NUL	char
;	O
}	O
static	O
void	O
emit_char_ct_validation	(*(char),*(char),*(char),int)->(void)
(	O
char	O
const	O
*	O
local_name	*(char)
,	O
char	O
const	O
*	O
quoted_name	*(char)
,	O
char	O
const	O
*	O
restore_name	*(char)
,	O
int	O
did_md5	int
)	O
{	O
char	O
wc	*(char)
[	O
1	int
+	O
LOG10_MAX_INT	int
*	O
2	int
]	O
;	O
char	O
*	O
command	*(char)
;	O
static	O
char	O
const	O
cct_cmd	array(char)
[	O
]	O
=	O
"LC_ALL=C wc -c < %s"	*(char)
;	O
command	*(char)
=	O
alloca	O
(	O
sizeof	O
(	O
cct_cmd	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
quoted_name	*(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
command	*(char)
,	O
cct_cmd	array(char)
,	O
quoted_name	*(char)
)	O
;	O
{	O
FILE	struct
*	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
command	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
die	(int,*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"Could not popen command"	*(char)
)	O
,	O
command	*(char)
)	O
;	O
read_byte_size	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
wc	*(char)
,	O
sizeof	O
(	O
wc	*(char)
)	O
,	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
did_md5	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
otherwise_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
{	O
size_t	long
sz	long
=	O
strlen	(*(char))->(long)
(	O
SM_bad_size	O
)	O
+	O
strlen	(*(char))->(long)
(	O
restore_name	*(char)
)	O
+	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
bf	*(char)
,	O
sz	long
,	O
SM_bad_size	O
,	O
restore_name	*(char)
,	O
wc	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ck_chct_z	array(char)
,	O
restore_name	*(char)
,	O
wc	*(char)
,	O
bf	*(char)
)	O
;	O
}	O
}	O
static	O
do_uue_t	enum(int,int,int)
file_needs_encoding	(*(char))->(enum(int,int,int))
(	O
char	O
const	O
*	O
fname	*(char)
)	O
{	O
FILE	struct
*	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
line_length	int
;	O
if	O
(	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
!=	O
NULL	O
)	O
return	O
true	int
;	O
switch	O
(	O
WHICH_OPT_MIXED_UUENCODE	O
)	O
{	O
case	O
VALUE_OPT_TEXT_FILES	char
:	O
return	O
false	int
;	O
case	O
VALUE_OPT_UUENCODE	char
:	O
return	O
true	int
;	O
default	O
:	O
break	O
;	O
}	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fname	*(char)
,	O
freadonly_mode	array(char)
)	O
;	O
if	O
(	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot open file %s"	*(char)
)	O
,	O
fname	*(char)
)	O
;	O
return	O
fail	int
;	O
}	O
line_length	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
ch	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
retest_char	O
:	O
switch	O
(	O
ch	char
)	O
{	O
case	O
EOF	O
:	O
goto	O
loop_done	O
;	O
case	O
'\n'	O
:	O
line_length	int
=	O
0	int
;	O
break	O
;	O
case	O
'F'	O
:	O
case	O
'f'	O
:	O
if	O
(	O
line_length	int
>	O
0	int
)	O
{	O
line_length	int
++	O
;	O
break	O
;	O
}	O
{	O
static	O
char	O
const	O
from	array(char)
[	O
]	O
=	O
"rom "	*(char)
;	O
char	O
const	O
*	O
p	*(void)
=	O
from	array(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
line_length	int
++	O
;	O
ch	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ch	char
!=	O
*	O
p	*(void)
)	O
goto	O
retest_char	O
;	O
if	O
(	O
*	O
++	O
p	*(void)
==	O
NUL	char
)	O
{	O
line_length	int
=	O
MAXIMUM_NON_BINARY_LINE	int
;	O
goto	O
loop_done	O
;	O
}	O
}	O
}	O
default	O
:	O
if	O
(	O
BYTE_IS_BINARY	O
(	O
ch	char
)	O
)	O
{	O
line_length	int
=	O
MAXIMUM_NON_BINARY_LINE	int
;	O
goto	O
loop_done	O
;	O
}	O
line_length	int
++	O
;	O
}	O
if	O
(	O
line_length	int
>=	O
MAXIMUM_NON_BINARY_LINE	int
)	O
break	O
;	O
}	O
loop_done	O
:	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
(	O
line_length	int
!=	O
0	int
)	O
?	O
true	int
:	O
false	int
;	O
}	O
static	O
void	O
encode_file_to_pipe	(int,*(char),*(char),*(char))->(void)
(	O
int	O
out_fd	int
,	O
const	O
char	O
*	O
local_name	*(char)
,	O
const	O
char	O
*	O
q_local_name	*(char)
,	O
const	O
char	O
*	O
restore_name	*(char)
)	O
{	O
FILE	struct
*	O
in_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FILE	struct
*	O
out_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
cmdline	*(char)
=	O
alloca	O
(	O
strlen	(*(char))->(long)
(	O
q_local_name	*(char)
)	O
+	O
64	int
)	O
;	O
char	O
const	O
*	O
open_txt	*(char)
=	O
cmdline	*(char)
;	O
char	O
const	O
*	O
open_fmt	*(char)
=	O
"popen"	*(char)
;	O
if	O
(	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
!=	O
NULL	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
cmdline	*(char)
,	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
->	O
cmpr_cmd_fmt	*(char)
,	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
->	O
cmpr_level	long
,	O
q_local_name	*(char)
)	O
;	O
in_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
cmdline	*(char)
,	O
freadonly_mode	array(char)
)	O
;	O
}	O
else	O
{	O
in_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
local_name	*(char)
,	O
freadonly_mode	array(char)
)	O
;	O
open_fmt	*(char)
=	O
"fopen"	*(char)
;	O
open_txt	*(char)
=	O
local_name	*(char)
;	O
}	O
if	O
(	O
in_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
fserr	(int,*(char),*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
open_fmt	*(char)
,	O
open_txt	*(char)
)	O
;	O
out_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
out_fd	int
,	O
fwriteonly_mode	array(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
out_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
mode_fmt_z	array(char)
,	O
restore_name	*(char)
)	O
;	O
copy_file_encoded	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
in_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
out_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
out_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"end\n"	*(char)
)	O
;	O
if	O
(	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
!=	O
NULL	O
)	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
FILE	struct
*	O
open_encoded_file	(*(char),*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
char	O
const	O
*	O
local_name	*(char)
,	O
char	O
const	O
*	O
q_local_name	*(char)
,	O
const	O
char	O
*	O
restore_name	*(char)
)	O
{	O
int	O
pipex	array(int)
[	O
2	int
]	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
pipex	array(int)
)	O
<	O
0	int
)	O
fserr	(int,*(char),*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"call"	*(char)
)	O
,	O
"pipe(2)"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
switch	O
(	O
fork	()->(int)
(	O
)	O
)	O
{	O
case	O
0	int
:	O
close	*((*(void))->(int))
(	O
pipex	array(int)
[	O
0	int
]	O
)	O
;	O
encode_file_to_pipe	(int,*(char),*(char),*(char))->(void)
(	O
pipex	array(int)
[	O
1	int
]	O
,	O
local_name	*(char)
,	O
q_local_name	*(char)
,	O
restore_name	*(char)
)	O
;	O
case	O
-	O
1	int
:	O
fserr	(int,*(char),*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"call"	*(char)
)	O
,	O
"fork"	*(char)
)	O
;	O
return	O
NULL	O
;	O
default	O
:	O
break	O
;	O
}	O
close	*((*(void))->(int))
(	O
pipex	array(int)
[	O
1	int
]	O
)	O
;	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pipex	array(int)
[	O
0	int
]	O
,	O
freadonly_mode	array(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
fserr	(int,*(char),*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
"fdopen"	*(char)
,	O
_	O
(	O
"pipe fd"	*(char)
)	O
)	O
;	O
return	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
}	O
static	O
FILE	struct
*	O
open_shar_input	(*(char),*(char),*(char),*(char),*(*(char)),*(*(char)),*(int))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
local_name	*(char)
,	O
const	O
char	O
*	O
q_local_name	*(char)
,	O
const	O
char	O
*	O
restore_name	*(char)
,	O
const	O
char	O
*	O
q_restore_name	*(char)
,	O
const	O
char	O
*	O
*	O
file_type_p	*(*(char))
,	O
const	O
char	O
*	O
*	O
file_type_remote_p	*(*(char))
,	O
int	O
*	O
pipe_p	*(int)
)	O
{	O
FILE	struct
*	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
uuencode_file	enum(int,int,int)
=	O
file_needs_encoding	(*(char))->(enum(int,int,int))
(	O
local_name	*(char)
)	O
;	O
if	O
(	O
uuencode_file	enum(int,int,int)
==	O
fail	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
uuencode_file	enum(int,int,int)
)	O
{	O
*	O
file_type_p	*(*(char))
=	O
_	O
(	O
"text"	*(char)
)	O
;	O
*	O
file_type_remote_p	*(*(char))
=	O
SM_type_text	O
;	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
local_name	*(char)
,	O
freadonly_mode	array(char)
)	O
;	O
if	O
(	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
fserr	(int,*(char),*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
"fopen"	*(char)
,	O
local_name	*(char)
)	O
;	O
*	O
pipe_p	*(int)
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
!=	O
NULL	O
)	O
*	O
file_type_p	*(*(char))
=	O
*	O
file_type_remote_p	*(*(char))
=	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
->	O
cmpr_title	*(char)
;	O
else	O
{	O
*	O
file_type_p	*(*(char))
=	O
_	O
(	O
"text"	*(char)
)	O
;	O
*	O
file_type_remote_p	*(*(char))
=	O
_	O
(	O
"(text)"	*(char)
)	O
;	O
}	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
open_encoded_file	(*(char),*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
local_name	*(char)
,	O
q_local_name	*(char)
,	O
restore_name	*(char)
)	O
;	O
*	O
pipe_p	*(int)
=	O
1	int
;	O
}	O
return	O
infp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
static	O
void	O
split_shar_ed_file	(*(char),*(long),*(int))->(void)
(	O
char	O
const	O
*	O
restore	*(char)
,	O
off_t	long
*	O
size_left	*(long)
,	O
int	O
*	O
split_flag	*(int)
)	O
{	O
DEBUG_PRINT	O
(	O
"New file, remaining %s, "	*(char)
,	O
(	O
*	O
size_left	*(long)
)	O
)	O
;	O
DEBUG_PRINT	O
(	O
"Limit still %s\n"	*(char)
,	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" :\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
"test $? -ne 0"	*(char)
,	O
SM_restore_failed	O
,	O
NULL	O
,	O
restore	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"fi\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
{	O
size_t	long
sz	long
=	O
strlen	(*(char))->(long)
(	O
SM_end_of_part	O
)	O
+	O
2	int
*	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
bf	*(char)
,	O
sz	long
,	O
SM_end_of_part	O
,	O
part_number	int
,	O
part_number	int
+	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
echo_string_z	array(char)
,	O
bf	*(char)
)	O
;	O
}	O
else	O
{	O
char	O
const	O
*	O
nm	*(char)
=	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
:	O
SM_word_archive	O
;	O
size_t	long
sz1	long
=	O
strlen	(*(char))->(long)
(	O
SM_s_end_of_part	O
)	O
+	O
strlen	(*(char))->(long)
(	O
nm	*(char)
)	O
+	O
LOG10_MAX_INT	int
;	O
size_t	long
sz2	long
=	O
strlen	(*(char))->(long)
(	O
SM_contin_in_part	O
)	O
+	O
strlen	(*(char))->(long)
(	O
restore	*(char)
)	O
+	O
LOG10_MAX_INT	int
;	O
char	O
*	O
bf	*(char)
;	O
if	O
(	O
sz1	long
<	O
sz2	long
)	O
sz1	long
=	O
sz2	long
;	O
bf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz1	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
bf	*(char)
,	O
sz1	long
,	O
SM_s_end_of_part	O
,	O
nm	*(char)
,	O
part_number	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
echo_string_z	array(char)
,	O
bf	*(char)
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
bf	*(char)
,	O
sz1	long
,	O
SM_contin_in_part	O
,	O
restore	*(char)
,	O
(	O
long	O
)	O
part_number	int
+	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
echo_string_z	array(char)
,	O
bf	*(char)
)	O
;	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
split_file_z	array(char)
,	O
sizeof	O
(	O
split_file_z	array(char)
)	O
-	O
1	int
,	O
1	int
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
part_number	int
==	O
1	int
)	O
{	O
fseeko	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
archive_type_position	long
,	O
SEEK_SET	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
explain_text_fmt	array(char)
,	O
explain_1_z	array(char)
,	O
explain_2_z	array(char)
)	O
;	O
fseeko	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
SEEK_END	int
)	O
;	O
}	O
close_output	(int)->(void)
(	O
part_number	int
+	O
1	int
)	O
;	O
open_output	()->(void)
(	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
NET_HEADERS	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Submitted-by: %s\n"	*(char)
,	O
OPT_ARG	O
(	O
SUBMITTER	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Archive-name: %s%s%02d\n\n"	*(char)
,	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
strchr	(*(char),int)->(*(char))
(	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
,	O
'/'	O
)	O
?	O
""	*(char)
:	O
"/part"	*(char)
,	O
part_number	int
?	O
part_number	int
:	O
1	int
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
CUT_MARK	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
cut_mark_line_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
continue_archive_z	array(char)
,	O
base_name	(*(char))->(*(char))
(	O
output_filename	*(char)
)	O
,	O
part_number	int
,	O
HAVE_OPT	O
(	O
ARCHIVE_NAME	O
)	O
?	O
OPT_ARG	O
(	O
ARCHIVE_NAME	O
)	O
:	O
"a multipart archive"	*(char)
,	O
restore	*(char)
,	O
sharpid	int
)	O
;	O
generate_configure	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
split_continue_quietly_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
split_continue_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
SM_still_skipping	O
,	O
restore	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
otherwise_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Continuing file %s\n"	*(char)
)	O
,	O
output_filename	*(char)
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
echo_text	(*(char),*(char),bool)->(void)
(	O
SM_continuing	O
,	O
restore	*(char)
,	O
false	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
split_resume_z	array(char)
,	O
line_prefix	int
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
,	O
uuencode_file	enum(int,int,int)
?	O
"${lock_dir}/uue"	*(char)
:	O
restore	*(char)
)	O
;	O
(	O
*	O
size_left	*(long)
)	O
=	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
-	O
ftello	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
split_flag	*(int)
=	O
1	int
;	O
}	O
static	O
void	O
process_shar_input	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(long),*(int),*(char),*(char))->(void)
(	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
off_t	long
*	O
size_left	*(long)
,	O
int	O
*	O
split_flag	*(int)
,	O
char	O
const	O
*	O
restore	*(char)
,	O
char	O
const	O
*	O
q_restore	*(char)
)	O
{	O
char	O
*	O
inbf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
BUFSIZ	int
)	O
;	O
if	O
(	O
uuencode_file	enum(int,int,int)
&&	O
(	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
!=	O
NULL	O
)	O
)	O
{	O
char	O
*	O
p	*(void)
=	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
inbf	*(char)
,	O
BUFSIZ	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
char	O
*	O
e	*(char)
;	O
if	O
(	O
(	O
p	*(void)
==	O
NULL	O
)	O
||	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
mode_fmt_z	array(char)
,	O
6	int
)	O
!=	O
0	int
)	O
)	O
return	O
;	O
e	*(char)
=	O
p	*(void)
+	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
to_uchar	(char)->(char)
(	O
e	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
&&	O
(	O
e	*(char)
>	O
p	*(void)
)	O
)	O
e	*(char)
--	O
;	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
to_uchar	(char)->(char)
(	O
e	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
&&	O
(	O
e	*(char)
>	O
p	*(void)
)	O
)	O
e	*(char)
--	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
p	*(void)
,	O
e	*(char)
-	O
p	*(void)
,	O
1	int
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"_sh%05d/%s\n"	*(char)
,	O
(	O
int	O
)	O
sharpid	int
,	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
->	O
cmpr_mode	*(char)
)	O
;	O
}	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
inbf	*(char)
,	O
BUFSIZ	int
,	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
FORCE_PREFIX	O
)	O
&&	O
ISASCII	int
(	O
inbf	*(char)
[	O
0	int
]	O
)	O
&&	O
IS_GRAPH	O
(	O
inbf	*(char)
[	O
0	int
]	O
)	O
&&	O
inbf	*(char)
[	O
0	int
]	O
!=	O
line_prefix	int
&&	O
inbf	*(char)
[	O
0	int
]	O
!=	O
'~'	O
&&	O
inbf	*(char)
[	O
0	int
]	O
!=	O
'.'	O
&&	O
(	O
inbf	*(char)
[	O
0	int
]	O
!=	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
[	O
0	int
]	O
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
inbf	*(char)
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
,	O
here_delimiter_length	long
)	O
)	O
&&	O
(	O
inbf	*(char)
[	O
0	int
]	O
!=	O
'e'	O
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
inbf	*(char)
,	O
"exit 0"	*(char)
,	O
6	int
)	O
)	O
&&	O
(	O
inbf	*(char)
[	O
0	int
]	O
!=	O
'F'	O
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
inbf	*(char)
,	O
"From"	*(char)
,	O
4	int
)	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
inbf	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c%s"	*(char)
,	O
line_prefix	int
,	O
inbf	*(char)
)	O
;	O
(	O
*	O
size_left	*(long)
)	O
--	O
;	O
}	O
if	O
(	O
*	O
inbf	*(char)
&&	O
inbf	*(char)
[	O
strlen	(*(char))->(long)
(	O
inbf	*(char)
)	O
-	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
(	O
*	O
size_left	*(long)
)	O
--	O
;	O
}	O
(	O
*	O
size_left	*(long)
)	O
-=	O
CRLF_STRLEN	O
(	O
inbf	*(char)
)	O
;	O
if	O
(	O
WHICH_OPT_WHOLE_SIZE_LIMIT	O
!=	O
VALUE_OPT_SPLIT_SIZE_LIMIT	char
)	O
continue	O
;	O
if	O
(	O
(	O
int	O
)	O
(	O
*	O
size_left	*(long)
)	O
>=	O
0	int
)	O
continue	O
;	O
split_shar_ed_file	(*(char),*(long),*(int))->(void)
(	O
restore	*(char)
,	O
size_left	*(long)
,	O
split_flag	*(int)
)	O
;	O
}	O
}	O
static	O
void	O
print_query_user	(*(char))->(void)
(	O
char	O
const	O
*	O
rname	*(char)
)	O
{	O
size_t	long
rname_len	long
=	O
strlen	(*(char))->(long)
(	O
rname	*(char)
)	O
;	O
size_t	long
sz	long
=	O
strlen	(*(char))->(long)
(	O
SM_overwriting	O
)	O
+	O
rname_len	long
;	O
char	O
*	O
str_a	*(char)
,	O
*	O
str_b	*(char)
;	O
str_a	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
str_a	*(char)
,	O
sz	long
,	O
SM_overwriting	O
,	O
rname	*(char)
)	O
;	O
sz	long
=	O
strlen	(*(char))->(long)
(	O
SM_overwrite	O
)	O
+	O
rname_len	long
;	O
str_b	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
str_b	*(char)
,	O
sz	long
,	O
SM_overwrite	O
,	O
rname	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
query_user_z	array(char)
,	O
str_a	*(char)
,	O
str_b	*(char)
)	O
;	O
sz	long
=	O
strlen	(*(char))->(long)
(	O
SM_skipping	O
)	O
+	O
rname_len	long
;	O
str_b	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
str_b	*(char)
,	O
sz	long
,	O
SM_skipping	O
,	O
rname	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
query_check_z	array(char)
,	O
SM_extract_aborted	O
,	O
str_b	*(char)
,	O
str_b	*(char)
)	O
;	O
}	O
static	O
int	O
start_sharing_file	(*(*(char)),*(*(char)),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),*(long),*(int))->(int)
(	O
char	O
const	O
*	O
*	O
lnameq_p	*(*(char))
,	O
char	O
const	O
*	O
*	O
rnameq_p	*(*(char))
,	O
FILE	struct
*	O
*	O
fpp	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
,	O
off_t	long
*	O
size_left_p	*(long)
,	O
int	O
*	O
pipe_p	*(int)
)	O
{	O
char	O
const	O
*	O
lname	*(char)
=	O
*	O
lnameq_p	*(*(char))
;	O
char	O
const	O
*	O
rname	*(char)
=	O
*	O
rnameq_p	*(*(char))
;	O
char	O
const	O
*	O
file_type	*(char)
;	O
char	O
const	O
*	O
file_type_remote	*(char)
;	O
if	O
(	O
!	O
S_ISREG	O
(	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: Not a regular file"	*(char)
)	O
,	O
lname	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
access	(*(char),int)->(int)
(	O
lname	*(char)
,	O
R_OK	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Cannot access %s"	*(char)
)	O
,	O
lname	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
*	O
lnameq_p	*(*(char))
=	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
QUOT_ID_LNAME	int
,	O
shell_always_quoting_style	int
,	O
lname	*(char)
)	O
;	O
*	O
rnameq_p	*(*(char))
=	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
QUOT_ID_RNAME	int
,	O
shell_always_quoting_style	int
,	O
rname	*(char)
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
)	O
{	O
off_t	long
current_size	long
=	O
ftello	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
off_t	long
encoded_size	long
=	O
1024	int
+	O
(	O
uuencode_file	enum(int,int,int)
?	O
(	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
/	O
3	int
)	O
:	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
*	O
size_left_p	*(long)
=	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
-	O
current_size	long
;	O
DEBUG_PRINT	O
(	O
"In shar: remaining size %s\n"	*(char)
,	O
*	O
size_left_p	*(long)
)	O
;	O
if	O
(	O
(	O
WHICH_OPT_WHOLE_SIZE_LIMIT	O
!=	O
VALUE_OPT_SPLIT_SIZE_LIMIT	char
)	O
&&	O
(	O
current_size	long
>	O
first_file_position	long
)	O
&&	O
(	O
encoded_size	long
>	O
*	O
size_left_p	*(long)
)	O
)	O
{	O
change_files	(*(char),*(long))->(void)
(	O
*	O
rnameq_p	*(*(char))
,	O
size_left_p	*(long)
)	O
;	O
current_size	long
=	O
ftello	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
*	O
size_left_p	*(long)
=	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
-	O
current_size	long
;	O
}	O
}	O
else	O
*	O
size_left_p	*(long)
=	O
~	O
0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
break_line_z	array(char)
,	O
rname	*(char)
)	O
;	O
generate_mkdir_script	(*(char))->(void)
(	O
rname	*(char)
)	O
;	O
if	O
(	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
==	O
0	int
)	O
{	O
file_type	*(char)
=	O
_	O
(	O
"empty"	*(char)
)	O
;	O
file_type_remote	*(char)
=	O
SM_is_empty	O
;	O
*	O
fpp	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
=	O
NULL	O
;	O
}	O
else	O
{	O
*	O
fpp	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
=	O
open_shar_input	(*(char),*(char),*(char),*(char),*(*(char)),*(*(char)),*(int))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
lname	*(char)
,	O
*	O
lnameq_p	*(*(char))
,	O
rname	*(char)
,	O
*	O
rnameq_p	*(*(char))
,	O
&	O
file_type	*(char)
,	O
&	O
file_type_remote	*(char)
,	O
pipe_p	*(int)
)	O
;	O
if	O
(	O
*	O
fpp	*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
==	O
NULL	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pre_exist_z	array(char)
,	O
*	O
rnameq_p	*(*(char))
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
print_query_user	(*(char))->(void)
(	O
rname	*(char)
)	O
;	O
else	O
echo_text	(*(char),*(char),bool)->(void)
(	O
SM_skip_exist	O
,	O
rname	*(char)
,	O
false	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
otherwise_z	array(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET	O
)	O
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Saving %s (%s)"	*(char)
)	O
,	O
lname	*(char)
,	O
file_type	*(char)
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
{	O
size_t	long
sz	long
=	O
strlen	(*(char))->(long)
(	O
SM_x_extracting	O
)	O
+	O
strlen	(*(char))->(long)
(	O
rname	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
file_type_remote	*(char)
)	O
;	O
char	O
*	O
bf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
sz	long
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
bf	*(char)
,	O
sz	long
,	O
SM_x_extracting	O
,	O
rname	*(char)
,	O
file_type_remote	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
echo_string_z	array(char)
,	O
bf	*(char)
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
finish_sharing_file	(*(char),*(char),*(char),*(char))->(void)
(	O
const	O
char	O
*	O
lname	*(char)
,	O
const	O
char	O
*	O
lname_q	*(char)
,	O
const	O
char	O
*	O
rname	*(char)
,	O
const	O
char	O
*	O
rname_q	*(char)
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_TIMESTAMP	O
)	O
)	O
{	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
;	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
shar_touch_z	array(char)
,	O
(	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_year	int
+	O
1900	int
)	O
/	O
100	int
,	O
(	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_year	int
+	O
1900	int
)	O
%	O
100	int
,	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mon	int
+	O
1	int
,	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mday	int
,	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_hour	int
,	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_min	int
,	O
restore_time	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_sec	int
,	O
rname_q	*(char)
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
VANILLA_OPERATION	O
)	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
":\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
"test $? -ne 0"	*(char)
,	O
SM_restore_failed	O
,	O
NULL	O
,	O
rname	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
char	O
md5buffer	array(char)
[	O
16	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
int	O
did_md5	int
=	O
0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
SM_restore_mode	O
,	O
(	O
unsigned	O
)	O
(	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
0777	int
)	O
,	O
rname_q	*(char)
)	O
;	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
"test $? -ne 0"	*(char)
,	O
SM_restore_failed	O
,	O
NULL	O
,	O
rname	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_MD5_DIGEST	O
)	O
&&	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
lname	*(char)
,	O
freadonly_mode	array(char)
)	O
)	O
!=	O
NULL	O
&&	O
md5_stream	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(void))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
md5buffer	array(char)
)	O
==	O
0	int
)	O
{	O
size_t	long
cnt	long
;	O
did_md5	int
=	O
1	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
md5test_z	array(char)
,	O
rname_q	*(char)
,	O
SM_md5_check_failed	O
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
for	O
(	O
cnt	long
=	O
0	int
;	O
cnt	long
<	O
16	int
;	O
++	O
cnt	long
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%02x"	*(char)
,	O
md5buffer	array(char)
[	O
cnt	long
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %c%s\n%s\n"	*(char)
,	O
' '	O
,	O
rname	*(char)
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
}	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHARACTER_COUNT	O
)	O
)	O
emit_char_ct_validation	(*(char),*(char),*(char),int)->(void)
(	O
lname	*(char)
,	O
lname_q	*(char)
,	O
rname_q	*(char)
,	O
did_md5	int
)	O
;	O
if	O
(	O
did_md5	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"  fi\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_CHECK_EXISTING	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"fi\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
int	O
shar	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
lname	*(char)
,	O
const	O
char	O
*	O
rname	*(char)
)	O
{	O
FILE	struct
*	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
off_t	long
size_left	*(long)
;	O
int	O
split_flag	*(int)
=	O
0	int
;	O
char	O
const	O
*	O
lname_q	*(char)
=	O
lname	*(char)
;	O
char	O
const	O
*	O
rname_q	*(char)
=	O
rname	*(char)
;	O
int	O
pipe_p	*(int)
;	O
scribble_free	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
start_sharing_file	(*(*(char)),*(*(char)),*(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))),*(long),*(int))->(int)
(	O
&	O
lname_q	*(char)
,	O
&	O
rname_q	*(char)
,	O
&	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
size_left	*(long)
,	O
&	O
pipe_p	*(int)
)	O
)	O
return	O
SHAR_EXIT_FAILED	int
;	O
if	O
(	O
struct_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" > %s &&\n"	*(char)
,	O
rname_q	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
uuencode_file	enum(int,int,int)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  sed 's/^%c//' << '%s' "	*(char)
,	O
line_prefix	int
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
NO_PIPING	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"> ${lock_dir}/uue &&\n"	*(char)
)	O
;	O
else	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"| uudecode &&\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  sed 's/^%c//' << '%s' > %s &&\n"	*(char)
,	O
line_prefix	int
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
,	O
rname_q	*(char)
)	O
;	O
}	O
process_shar_input	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(long),*(int),*(char),*(char))->(void)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
size_left	*(long)
,	O
&	O
split_flag	*(int)
,	O
rname	*(char)
,	O
rname_q	*(char)
)	O
;	O
if	O
(	O
!	O
pipe_p	*(int)
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
wait	(*(int))->(int)
(	O
NULL	O
)	O
>=	O
0	int
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
if	O
(	O
split_flag	*(int)
&&	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
echo_text	(*(char),*(char),bool)->(void)
(	O
SM_file_complete	O
,	O
rname	*(char)
,	O
true	int
)	O
;	O
if	O
(	O
uuencode_file	enum(int,int,int)
&&	O
HAVE_OPT	O
(	O
NO_PIPING	O
)	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
echo_text	(*(char),*(char),bool)->(void)
(	O
SM_uudec_file	O
,	O
rname	*(char)
,	O
true	int
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
shar_decode_z	array(char)
,	O
sizeof	O
(	O
shar_decode_z	array(char)
)	O
-	O
1	int
,	O
1	int
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
QUIET_UNSHAR	O
)	O
)	O
echo_text	(*(char),*(char),bool)->(void)
(	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
->	O
cmpr_unnote	*(char)
,	O
rname	*(char)
,	O
true	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
->	O
cmpr_unpack	*(char)
,	O
rname_q	*(char)
)	O
;	O
}	O
}	O
finish_sharing_file	(*(char),*(char),*(char),*(char))->(void)
(	O
lname	*(char)
,	O
lname_q	*(char)
,	O
rname	*(char)
,	O
rname_q	*(char)
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
static	O
void	O
parse_output_base_name	(*(char))->(void)
(	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
char	O
*	O
bad_fmt	*(char)
=	O
_	O
(	O
"Invalid format for output file names (%s): %s"	*(char)
)	O
;	O
int	O
c	char
;	O
int	O
hadarg	int
=	O
0	int
;	O
char	O
const	O
*	O
p	*(void)
;	O
int	O
base_name_len	int
=	O
128	int
;	O
for	O
(	O
p	*(void)
=	O
arg	*(char)
;	O
(	O
c	char
=	O
*	O
p	*(void)
++	O
)	O
!=	O
0	int
;	O
)	O
{	O
base_name_len	int
++	O
;	O
if	O
(	O
c	char
!=	O
'%'	O
)	O
continue	O
;	O
c	char
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
c	char
==	O
'%'	O
)	O
continue	O
;	O
if	O
(	O
hadarg	int
)	O
usage_message	(*(char))->(void)
(	O
bad_fmt	*(char)
,	O
_	O
(	O
"more than one format element"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
while	O
(	O
c	char
!=	O
0	int
&&	O
strchr	(*(char),int)->(*(char))
(	O
"#0+- 'I"	*(char)
,	O
c	char
)	O
!=	O
0	int
)	O
c	char
=	O
*	O
p	*(void)
++	O
;	O
if	O
(	O
c	char
==	O
0	int
)	O
usage_message	(*(char))->(void)
(	O
bad_fmt	*(char)
,	O
_	O
(	O
"no conversion character"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
if	O
(	O
c	char
>=	O
'0'	O
&&	O
c	char
<=	O
'9'	O
)	O
{	O
long	O
v	union(array(char),int,int,long,long,*(void))
;	O
char	O
const	O
*	O
skp	*(char)
;	O
errno	O
=	O
0	int
;	O
v	union(array(char),int,int,long,long,*(void))
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
(	O
void	O
*	O
)	O
(	O
p	*(void)
-	O
1	int
)	O
,	O
(	O
void	O
*	O
)	O
&	O
skp	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
(	O
v	union(array(char),int,int,long,long,*(void))
==	O
0	int
)	O
||	O
(	O
v	union(array(char),int,int,long,long,*(void))
>	O
16	int
)	O
||	O
(	O
errno	O
!=	O
0	int
)	O
)	O
usage_message	(*(char))->(void)
(	O
bad_fmt	*(char)
,	O
_	O
(	O
"format is too wide"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
p	*(void)
=	O
skp	*(char)
;	O
c	char
=	O
*	O
p	*(void)
++	O
;	O
base_name_len	int
+=	O
v	union(array(char),int,int,long,long,*(void))
;	O
}	O
if	O
(	O
c	char
==	O
'.'	O
)	O
{	O
c	char
=	O
*	O
p	*(void)
++	O
;	O
while	O
(	O
c	char
!=	O
0	int
&&	O
c	char
>=	O
'0'	O
&&	O
c	char
<=	O
'9'	O
)	O
c	char
=	O
*	O
p	*(void)
++	O
;	O
}	O
if	O
(	O
c	char
==	O
0	int
||	O
strchr	(*(char),int)->(*(char))
(	O
"diouxX"	*(char)
,	O
c	char
)	O
==	O
0	int
)	O
usage_message	(*(char))->(void)
(	O
bad_fmt	*(char)
,	O
_	O
(	O
"invalid conversion character"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
hadarg	int
=	O
1	int
;	O
}	O
output_filename	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
base_name_len	int
)	O
;	O
if	O
(	O
!	O
hadarg	int
)	O
{	O
static	O
char	O
const	O
sfx	array(char)
[	O
]	O
=	O
".%02d"	*(char)
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
;	O
char	O
*	O
fmt	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
sizeof	O
(	O
sfx	array(char)
)	O
)	O
;	O
bool	bool
svd	bool
=	O
initialization_done	bool
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
fmt	*(char)
,	O
arg	*(char)
,	O
len	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
fmt	*(char)
+	O
len	long
,	O
sfx	array(char)
,	O
sizeof	O
(	O
sfx	array(char)
)	O
)	O
;	O
initialization_done	bool
=	O
false	int
;	O
SET_OPT_OUTPUT_PREFIX	O
(	O
fmt	*(char)
)	O
;	O
initialization_done	bool
=	O
svd	bool
;	O
}	O
}	O
static	O
void	O
open_output	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
OUTPUT_PREFIX	O
)	O
)	O
{	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
return	O
;	O
}	O
if	O
(	O
output_filename	*(char)
==	O
NULL	O
)	O
parse_output_base_name	(*(char))->(void)
(	O
OPT_ARG	O
(	O
OUTPUT_PREFIX	O
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
output_filename	*(char)
,	O
OPT_ARG	O
(	O
OUTPUT_PREFIX	O
)	O
,	O
++	O
part_number	int
)	O
;	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
output_filename	*(char)
,	O
fwriteonly_mode	array(char)
)	O
;	O
if	O
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
fserr	(int,*(char),*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"Opening"	*(char)
)	O
,	O
output_filename	*(char)
)	O
;	O
}	O
static	O
void	O
close_output	(int)->(void)
(	O
int	O
part	int
)	O
{	O
if	O
(	O
part	int
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"echo %d > ${lock_dir}/seq\n"	*(char)
,	O
part	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"exit 0\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
fserr	(int,*(char),*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
_	O
(	O
"Closing"	*(char)
)	O
,	O
output_filename	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
trim	(*(char))->(*(char))
(	O
char	O
*	O
pz	*(char)
)	O
{	O
char	O
*	O
res	*(char)
;	O
while	O
(	O
isspace	(int)->(int)
(	O
to_uchar	(char)->(char)
(	O
*	O
pz	*(char)
)	O
)	O
)	O
pz	*(char)
++	O
;	O
switch	O
(	O
*	O
pz	*(char)
)	O
{	O
case	O
NUL	char
:	O
case	O
'#'	O
:	O
return	O
NULL	O
;	O
}	O
res	*(char)
=	O
pz	*(char)
;	O
pz	*(char)
+=	O
strlen	(*(char))->(long)
(	O
pz	*(char)
)	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
to_uchar	(char)->(char)
(	O
pz	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
)	O
pz	*(char)
--	O
;	O
*	O
pz	*(char)
=	O
NUL	char
;	O
return	O
res	*(char)
;	O
}	O
static	O
void	O
set_submitter	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
buffer	array(int)
;	O
char	O
*	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
=	O
getuser	(int)->(*(char))
(	O
getuid	()->(int)
(	O
)	O
)	O
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
)	O
;	O
if	O
(	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
==	O
NULL	O
)	O
fserr	(int,*(char),*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
"getpwuid"	*(char)
,	O
"getuid()"	*(char)
)	O
;	O
buffer	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
2	int
+	O
HOST_NAME_MAX	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buffer	array(int)
,	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
,	O
len	long
)	O
;	O
buffer	array(int)
[	O
len	long
++	O
]	O
=	O
'@'	O
;	O
gethostname	(*(char),long)->(int)
(	O
buffer	array(int)
+	O
len	long
,	O
HOST_NAME_MAX	int
)	O
;	O
SET_OPT_SUBMITTER	O
(	O
buffer	array(int)
)	O
;	O
}	O
static	O
void	O
configure_shar	(*(int),*(*(*(char))))->(void)
(	O
int	O
*	O
argc_p	*(int)
,	O
char	O
*	O
*	O
*	O
argv_p	*(*(*(char)))
)	O
{	O
line_prefix	int
=	O
(	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
[	O
0	int
]	O
==	O
DEFAULT_LINE_PREFIX_1	char
?	O
DEFAULT_LINE_PREFIX_2	char
:	O
DEFAULT_LINE_PREFIX_1	char
)	O
;	O
here_delimiter_length	long
=	O
strlen	(*(char))->(long)
(	O
OPT_ARG	O
(	O
HERE_DELIMITER	O
)	O
)	O
;	O
gzip_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
.	O
cmpr_level	long
=	O
xz_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
.	O
cmpr_level	long
=	O
bzip2_compaction	struct(*(char),*(char),*(char),*(char),*(char),*(char),long)
.	O
cmpr_level	long
=	O
DESC	O
(	O
LEVEL_OF_COMPRESSION	O
)	O
.	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
SUBMITTER	O
)	O
)	O
set_submitter	()->(void)
(	O
)	O
;	O
open_output	()->(void)
(	O
)	O
;	O
if	O
(	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
&&	O
isatty	(int)->(int)
(	O
STDERR_FILENO	int
)	O
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"/dev/null"	*(char)
,	O
fwriteonly_mode	array(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
error	(int,int,*(char))->(void)
(	O
SHAR_EXIT_FAILED	int
,	O
errno	O
,	O
_	O
(	O
"reopening stderr to /dev/null"	*(char)
)	O
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
byte_is_binary	array(char)
,	O
1	int
,	O
sizeof	O
(	O
byte_is_binary	array(char)
)	O
)	O
;	O
byte_is_binary	array(char)
[	O
'\b'	O
]	O
=	O
0	int
;	O
byte_is_binary	array(char)
[	O
'\t'	O
]	O
=	O
0	int
;	O
byte_is_binary	array(char)
[	O
'\f'	O
]	O
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
byte_is_binary	array(char)
+	O
0x20	int
,	O
0	int
,	O
0x7F	int
-	O
0x20	int
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
INPUT_FILE_LIST	O
)	O
)	O
{	O
char	O
*	O
*	O
list	*(*(char))
;	O
int	O
max_argc	int
=	O
32	int
;	O
char	O
*	O
get_buf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
BUFSIZ	int
)	O
;	O
*	O
argc_p	*(int)
=	O
0	int
;	O
list	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
max_argc	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
*	O
pz	*(char)
=	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
get_buf	*(char)
,	O
BUFSIZ	int
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
pz	*(char)
==	O
NULL	O
)	O
break	O
;	O
pz	*(char)
=	O
trim	(*(char))->(*(char))
(	O
pz	*(char)
)	O
;	O
if	O
(	O
pz	*(char)
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
*	O
argc_p	*(int)
==	O
max_argc	int
)	O
{	O
max_argc	int
+=	O
max_argc	int
/	O
2	int
;	O
list	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
list	*(*(char))
,	O
max_argc	int
*	O
sizeof	O
(	O
*	O
list	*(*(char))
)	O
)	O
;	O
}	O
list	*(*(char))
[	O
(	O
*	O
argc_p	*(int)
)	O
++	O
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
pz	*(char)
)	O
;	O
}	O
*	O
argv_p	*(*(*(char)))
=	O
list	*(*(char))
;	O
opt_idx	int
=	O
0	int
;	O
}	O
scribble_free	()->(void)
(	O
)	O
;	O
if	O
(	O
opt_idx	int
>=	O
*	O
argc_p	*(int)
)	O
usage_message	(*(char))->(void)
(	O
_	O
(	O
"No input files"	*(char)
)	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
)	O
{	O
if	O
(	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
<	O
4096	int
)	O
OPT_VALUE_WHOLE_SIZE_LIMIT	O
*=	O
1024	int
;	O
if	O
(	O
WHICH_OPT_WHOLE_SIZE_LIMIT	O
==	O
VALUE_OPT_SPLIT_SIZE_LIMIT	char
)	O
SET_OPT_NO_PIPING	O
;	O
}	O
generate_full_header	(int,*(*(char)))->(void)
(	O
*	O
argc_p	*(int)
-	O
opt_idx	int
,	O
&	O
(	O
*	O
argv_p	*(*(*(char)))
)	O
[	O
opt_idx	int
]	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
QUERY_USER	O
)	O
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
NET_HEADERS	O
)	O
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"PLEASE avoid -X shars on Usenet or public networks"	*(char)
)	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"shar_wish=\n"	*(char)
,	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
first_file_position	long
=	O
ftello	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
check_intermixing	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
(	O
void	O
)	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
(	O
void	O
)	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
;	O
if	O
(	O
initialization_done	bool
&&	O
!	O
HAVE_OPT	O
(	O
INTERMIX_TYPE	O
)	O
)	O
usage_message	(*(char))->(void)
(	O
_	O
(	O
"The '%s' option may not be intermixed with file names\nunless the --intermix-type option has been specified."	*(char)
)	O
,	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
->	O
pz_Name	*(char)
)	O
;	O
}	O
void	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
(	O
void	O
)	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
(	O
void	O
)	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
;	O
if	O
(	O
initialization_done	bool
)	O
usage_message	(*(char))->(void)
(	O
_	O
(	O
"The '%s' option must appear before any file names"	*(char)
)	O
,	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
->	O
pz_Name	*(char)
)	O
;	O
}	O
void	O
set_compaction	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
char	O
const	O
*	O
c_type	*(char)
=	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
;	O
int	O
ix	int
=	O
0	int
;	O
(	O
void	O
)	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
(	O
void	O
)	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
;	O
check_intermixing	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
c_type	*(char)
,	O
"none"	*(char)
)	O
==	O
0	int
)	O
{	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
=	O
NULL	O
;	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
c_type	*(char)
,	O
compaction	array(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long)))
[	O
ix	int
]	O
->	O
cmpr_name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
++	O
ix	int
>=	O
compact_ct	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid compaction type:  %s\nthe known types are:\n"	*(char)
)	O
,	O
c_type	*(char)
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
compact_ct	int
;	O
ix	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\t%s\n"	*(char)
,	O
compaction	array(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long)))
[	O
ix	int
]	O
->	O
cmpr_name	*(char)
)	O
;	O
USAGE	O
(	O
SHAR_EXIT_OPTION_ERROR	int
)	O
;	O
}	O
}	O
cmpr_state	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long))
=	O
compaction	array(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),long)))
[	O
ix	int
]	O
;	O
}	O
static	O
void	O
initialize	(*(int),*(*(*(char))))->(void)
(	O
int	O
*	O
argcp	*(int)
,	O
char	O
*	O
*	O
*	O
argvp	*(*(*(char)))
)	O
{	O
sharpid	int
=	O
(	O
int	O
)	O
getpid	()->(int)
(	O
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
scribble_init	()->(void)
(	O
)	O
;	O
opt_idx	int
=	O
optionProcess	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int,*(*(char)))->(int)
(	O
&	O
sharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
*	O
argcp	*(int)
,	O
*	O
argvp	*(*(*(char)))
)	O
;	O
if	O
(	O
opt_idx	int
==	O
*	O
argcp	*(int)
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
INPUT_FILE_LIST	O
)	O
)	O
SET_OPT_INPUT_FILE_LIST	O
(	O
"-"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
INPUT_FILE_LIST	O
)	O
&&	O
(	O
opt_idx	int
!=	O
*	O
argcp	*(int)
)	O
)	O
usage_message	(*(char))->(void)
(	O
_	O
(	O
"files on command line and --input-file-list specified"	*(char)
)	O
)	O
;	O
}	O
init_shar_msg	()->(void)
(	O
)	O
;	O
configure_shar	(*(int),*(*(*(char))))->(void)
(	O
argcp	*(int)
,	O
argvp	*(*(*(char)))
)	O
;	O
initialization_done	bool
=	O
true	int
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
shar_exit_code_t	enum(int,int,int,int,int,int,int,int,int)
status	int
=	O
SHAR_EXIT_SUCCESS	int
;	O
initialize	(*(int),*(*(*(char))))->(void)
(	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
while	O
(	O
opt_idx	int
<	O
argc	int
)	O
{	O
char	O
*	O
arg	*(char)
=	O
argv	*(*(char))
[	O
opt_idx	int
++	O
]	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
arg	*(char)
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
INTERMIX_TYPE	O
)	O
&&	O
(	O
*	O
arg	*(char)
==	O
'-'	O
)	O
)	O
{	O
while	O
(	O
*	O
++	O
arg	*(char)
==	O
'-'	O
)	O
;	O
optionLoadLine	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(char))->(void)
(	O
&	O
sharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
arg	*(char)
)	O
;	O
}	O
else	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
arg	*(char)
)	O
;	O
continue	O
;	O
}	O
{	O
shar_exit_code_t	enum(int,int,int,int,int,int,int,int,int)
s	enum(int,int,int,int,int,int,int,int,int)
=	O
walktree	(*((*(char),*(char))->(int)),*(char))->(int)
(	O
shar	(*(char),*(char))->(int)
,	O
arg	*(char)
)	O
;	O
if	O
(	O
status	int
==	O
SHAR_EXIT_SUCCESS	int
)	O
status	int
=	O
s	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
WHOLE_SIZE_LIMIT	O
)	O
&&	O
part_number	int
>	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
echo_string_z	array(char)
,	O
SM_you_are_done	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
QUIET	O
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Created %d files\n"	*(char)
)	O
,	O
part_number	int
)	O
;	O
}	O
echo_status	(*(char),*(char),*(char),*(char),int)->(void)
(	O
"rm -fr ${lock_dir}"	*(char)
,	O
SM_x_rem_lock_dir	O
,	O
SM_x_no_rem_lock_dir	O
,	O
"${lock_dir}"	*(char)
,	O
1	int
)	O
;	O
close_output	(int)->(void)
(	O
0	int
)	O
;	O
scribble_deinit	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
