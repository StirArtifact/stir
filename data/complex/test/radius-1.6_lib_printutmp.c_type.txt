int	O
grad_printutmp_ip_nodomain	int
;	O
int	O
grad_printutmp_use_naslist	int
=	O
1	int
;	O
char	O
*	O
grad_printutmp_date_format	*(char)
=	O
"%a %H:%M"	*(char)
;	O
char	O
*	O
grad_printutmp_empty_string	*(char)
=	O
""	*(char)
;	O
static	O
grad_slist_t	*(struct)
slist	*(struct)
;	O
typedef	O
struct	O
format_key	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
format_key_t	struct
;	O
struct	O
format_key	struct(*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),*(char),*(char))
{	O
format_key_t	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
value	*(char)
;	O
}	O
;	O
typedef	O
int	O
(	O
*	O
radutent_fh_t	*((int,int,*(struct(*(struct`),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))
)	O
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
;	O
struct	O
format_data	struct(*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int))),int,*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char))),union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int))
{	O
format_data_t	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
int	O
type	int
;	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
union	O
{	O
struct	O
{	O
radutent_fh_t	*((int,int,*(struct(*(struct`),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
int	O
width	int
;	O
char	O
*	O
header	*(char)
;	O
}	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
;	O
char	O
*	O
string	*(*(char))
;	O
int	O
tabstop	int
;	O
int	O
nl	int
;	O
}	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
;	O
}	O
;	O
static	O
void	O
format_key_free	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
format_key_t	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
while	O
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
grad_free	(*(void))->(void)
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
name	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
value	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
}	O
static	O
char	O
*	O
format_key_lookup	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char))->(*(char))
(	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
char	O
*	O
name	*(char)
)	O
{	O
for	O
(	O
;	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
value	*(char)
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
form_free	(*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))))->(void)
(	O
format_data_t	struct
*	O
form	*(struct)
)	O
{	O
format_data_t	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
while	O
(	O
form	*(struct)
)	O
{	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
form	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
format_key_free	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(void)
(	O
form	*(struct)
->	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
switch	O
(	O
form	*(struct)
->	O
type	int
)	O
{	O
case	O
FDATA_STRING	int
:	O
grad_free	(*(void))->(void)
(	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
string	*(*(char))
)	O
;	O
break	O
;	O
case	O
FDATA_FH	int
:	O
grad_free	(*(void))->(void)
(	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
header	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
grad_free	(*(void))->(void)
(	O
form	*(struct)
)	O
;	O
form	*(struct)
=	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
}	O
static	O
int	O
key_align	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
char	O
*	O
p	*(struct)
=	O
format_key_lookup	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char))->(*(char))
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
"right"	*(char)
)	O
;	O
return	O
p	*(struct)
?	O
ALIGN_RIGHT	int
:	O
ALIGN_LEFT	int
;	O
}	O
static	O
char	O
*	O
key_date_format	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(*(char))
(	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
char	O
*	O
p	*(struct)
=	O
format_key_lookup	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char))->(*(char))
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
"format"	*(char)
)	O
;	O
return	O
p	*(struct)
?	O
p	*(struct)
:	O
grad_printutmp_date_format	*(char)
;	O
}	O
static	O
char	O
*	O
key_empty	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(*(char))
(	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
char	O
*	O
p	*(struct)
=	O
format_key_lookup	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char))->(*(char))
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
"empty"	*(char)
)	O
;	O
return	O
p	*(struct)
?	O
p	*(struct)
:	O
grad_printutmp_empty_string	*(char)
;	O
}	O
static	O
int	O
key_nodomain	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
char	O
*	O
p	*(struct)
=	O
format_key_lookup	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(char))->(*(char))
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
"nodomain"	*(char)
)	O
;	O
return	O
p	*(struct)
?	O
1	int
:	O
grad_printutmp_ip_nodomain	int
;	O
}	O
static	O
int	O
output_string	(*(char),int,int)->(int)
(	O
char	O
*	O
string	*(*(char))
,	O
int	O
width	int
,	O
int	O
align	int
)	O
{	O
if	O
(	O
width	int
==	O
0	int
)	O
width	int
=	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
string	*(*(char))
)	O
;	O
else	O
if	O
(	O
align	int
==	O
ALIGN_LEFT	int
)	O
width	int
=	O
printf	(*(char))->(int)
(	O
"%-*.*s"	*(char)
,	O
width	int
,	O
width	int
,	O
string	*(*(char))
)	O
;	O
else	O
width	int
=	O
printf	(*(char))->(int)
(	O
"%*.*s"	*(char)
,	O
width	int
,	O
width	int
,	O
string	*(*(char))
)	O
;	O
return	O
width	int
;	O
}	O
static	O
int	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
char	O
*	O
string	*(*(char))
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
if	O
(	O
strlen	(*(char))->(long)
(	O
string	*(*(char))
)	O
==	O
0	int
)	O
string	*(*(char))
=	O
key_empty	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(*(char))
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
return	O
output_string	(*(char),int,int)->(int)
(	O
string	*(*(char))
,	O
width	int
,	O
key_align	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
)	O
;	O
}	O
static	O
int	O
output_tab	(int,int)->(int)
(	O
int	O
column	int
,	O
int	O
tabstop	int
)	O
{	O
int	O
goal	int
=	O
(	O
(	O
(	O
column	int
+	O
TAB_SIZE	int
-	O
1	int
)	O
/	O
TAB_SIZE	int
)	O
+	O
tabstop	int
)	O
*	O
TAB_SIZE	int
;	O
for	O
(	O
;	O
column	int
<	O
goal	int
;	O
column	int
++	O
)	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
return	O
column	int
;	O
}	O
static	O
char	O
*	O
get_hostname	(int,int,*(char),long)->(*(char))
(	O
grad_uint32_t	int
ipaddr	int
,	O
int	O
nodomain	int
,	O
char	O
*	O
buf	*(char)
,	O
size_t	long
size	int
)	O
{	O
if	O
(	O
ipaddr	int
==	O
0	int
||	O
ipaddr	int
==	O
(	O
grad_uint32_t	int
)	O
-	O
1	int
||	O
ipaddr	int
==	O
(	O
grad_uint32_t	int
)	O
-	O
2	int
)	O
return	O
""	*(char)
;	O
if	O
(	O
nodomain	int
)	O
{	O
char	O
*	O
s	*(*(char))
,	O
*	O
p	*(struct)
;	O
s	*(*(char))
=	O
grad_ip_gethostname	(int,*(char),long)->(*(char))
(	O
ntohl	(int)->(int)
(	O
ipaddr	int
)	O
,	O
buf	*(char)
,	O
size	int
)	O
;	O
for	O
(	O
p	*(struct)
=	O
s	*(*(char))
;	O
*	O
p	*(struct)
&&	O
(	O
isdigit	(int)->(int)
(	O
*	O
p	*(struct)
)	O
||	O
*	O
p	*(struct)
==	O
'.'	O
)	O
;	O
p	*(struct)
++	O
)	O
;	O
if	O
(	O
*	O
p	*(struct)
==	O
0	int
)	O
return	O
s	*(*(char))
;	O
if	O
(	O
(	O
p	*(struct)
=	O
strchr	(*(char),int)->(*(char))
(	O
s	*(*(char))
,	O
'.'	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
p	*(struct)
=	O
0	int
;	O
return	O
s	*(*(char))
;	O
}	O
return	O
grad_ip_gethostname	(int,*(char),long)->(*(char))
(	O
ntohl	(int)->(int)
(	O
ipaddr	int
)	O
,	O
buf	*(char)
,	O
size	int
)	O
;	O
}	O
static	O
int	O
output_hostname	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
grad_uint32_t	int
ip	*(struct)
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
char	O
buf	*(char)
[	O
80	int
]	O
;	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
get_hostname	(int,int,*(char),long)->(*(char))
(	O
ip	*(struct)
,	O
key_nodomain	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
,	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
)	O
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
output_time	(long,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
time_t	long
t	long
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
{	O
int	O
d	*(char)
,	O
h	int
,	O
m	int
,	O
s	*(*(char))
;	O
d	*(char)
=	O
t	long
/	O
86400	int
;	O
t	long
%=	O
86400	int
;	O
s	*(*(char))
=	O
t	long
%	O
60	int
;	O
m	int
=	O
t	long
/	O
60	int
;	O
if	O
(	O
m	int
>	O
59	int
)	O
{	O
h	int
=	O
m	int
/	O
60	int
;	O
m	int
-=	O
h	int
*	O
60	int
;	O
}	O
else	O
h	int
=	O
0	int
;	O
if	O
(	O
d	*(char)
)	O
width	int
=	O
printf	(*(char))->(int)
(	O
"%d+%02d:%02d"	*(char)
,	O
d	*(char)
,	O
h	int
,	O
m	int
)	O
;	O
else	O
width	int
=	O
printf	(*(char))->(int)
(	O
"%02d:%02d"	*(char)
,	O
h	int
,	O
m	int
)	O
;	O
return	O
width	int
;	O
}	O
static	O
int	O
login_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
login	array(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
orig_login_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
orig_login	array(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
gecos_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
pw	*(char)
,	O
*	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
char	O
*	O
s	*(*(char))
;	O
char	O
buffer	*(char)
[	O
512	int
]	O
;	O
if	O
(	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
grad_getpwnam_r	(*(char),*(struct(*(char),*(char),int,int,*(char),*(char),*(char))),*(char),int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
login	array(char)
,	O
&	O
pw	*(char)
,	O
buffer	*(char)
,	O
sizeof	O
buffer	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
s	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gecos	*(char)
,	O
','	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
s	*(*(char))
=	O
0	int
;	O
s	*(*(char))
=	O
pwd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gecos	*(char)
;	O
}	O
else	O
s	*(*(char))
=	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
orig_login	array(char)
;	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
s	*(*(char))
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
nas_port_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
char	O
buf	*(char)
[	O
6	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%0*d"	*(char)
,	O
width	int
-	O
1	int
,	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
nas_port	int
)	O
;	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
buf	*(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
session_id_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
session_id	array(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
nas_address_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
if	O
(	O
grad_printutmp_use_naslist	int
)	O
{	O
grad_nas_t	struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))
*	O
nas	*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void)))
;	O
nas	*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void)))
=	O
grad_nas_lookup_ip	(int)->(*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void))))
(	O
ntohl	(int)->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
nas_address	int
)	O
)	O
;	O
if	O
(	O
!	O
nas	*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void)))
)	O
return	O
output_hostname	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
nas_address	int
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
nas	*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void)))
->	O
shortname	array(char)
[	O
0	int
]	O
?	O
nas	*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void)))
->	O
shortname	array(char)
:	O
nas	*(struct(struct(int,int),array(char),array(char),array(char),*(struct),*(void)))
->	O
longname	array(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
return	O
output_hostname	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
nas_address	int
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
framed_address_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
return	O
output_hostname	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
framed_address	int
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
protocol_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
=	O
grad_value_lookup	(int,*(char))->(*(struct(*(char),*(struct(*`,int,int,int,int,*`)),int)))
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
proto	int
,	O
"Framed-Protocol"	*(char)
)	O
;	O
char	O
buf	*(char)
[	O
80	int
]	O
;	O
char	O
*	O
s	*(*(char))
;	O
if	O
(	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
)	O
s	*(*(char))
=	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
->	O
name	*(char)
;	O
else	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%u"	*(char)
,	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
proto	int
)	O
;	O
s	*(*(char))
=	O
buf	*(char)
;	O
}	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
s	*(*(char))
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
time_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
char	O
buf	*(char)
[	O
80	int
]	O
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
key_date_format	(*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(*(char))
(	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
,	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
time	struct(long,long)
)	O
)	O
;	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
buf	*(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
duration_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
return	O
output_time	(long,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
type	int
==	O
P_IDLE	int
)	O
?	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
duration	long
:	O
time	struct(long,long)
(	O
NULL	O
)	O
-	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
time	struct(long,long)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
delay_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
return	O
output_time	(long,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
delay	long
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
port_type_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
=	O
grad_value_lookup	(int,*(char))->(*(struct(*(char),*(struct(*`,int,int,int,int,*`)),int)))
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
porttype	int
,	O
"NAS-Port-Type"	*(char)
)	O
;	O
char	O
buf	*(char)
[	O
80	int
]	O
;	O
char	O
*	O
s	*(*(char))
;	O
if	O
(	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
)	O
s	*(*(char))
=	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
->	O
name	*(char)
;	O
else	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
"%u"	*(char)
,	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
porttype	int
)	O
;	O
s	*(*(char))
=	O
buf	*(char)
;	O
}	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
s	*(*(char))
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
clid_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
caller_id	array(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
realm_address_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
{	O
if	O
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
realm_address	int
==	O
0	int
)	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
""	*(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
else	O
{	O
grad_realm_t	struct(array(char),*(struct),*(struct(int,int,int,long,*(struct))))
*	O
rp	*(struct(array(char),*(struct),*(struct(int,int,int,long,*(struct`)))))
=	O
grad_realm_lookup_ip	(int)->(*(struct(array(char),*(struct),*(struct(int,int,int,long,*`)))))
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
realm_address	int
)	O
;	O
if	O
(	O
rp	*(struct(array(char),*(struct),*(struct(int,int,int,long,*(struct`)))))
)	O
return	O
output_string_key	(*(char),int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
rp	*(struct(array(char),*(struct),*(struct(int,int,int,long,*(struct`)))))
->	O
realm	array(char)
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
return	O
output_hostname	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))))->(int)
(	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
->	O
realm_address	int
,	O
width	int
,	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
;	O
}	O
static	O
struct	O
{	O
char	O
*	O
name	*(char)
;	O
radutent_fh_t	*((int,int,*(struct(*(struct`),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
}	O
handlers	array(struct(*(char),*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))))
[	O
]	O
=	O
{	O
{	O
"login"	*(char)
,	O
login_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"orig-login"	*(char)
,	O
orig_login_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"gecos"	*(char)
,	O
gecos_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"nas-port"	*(char)
,	O
nas_port_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"session-id"	*(char)
,	O
session_id_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"nas-address"	*(char)
,	O
nas_address_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"framed-address"	*(char)
,	O
framed_address_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"protocol"	*(char)
,	O
protocol_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"time"	*(char)
,	O
time_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"duration"	*(char)
,	O
duration_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"delay"	*(char)
,	O
delay_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"port-type"	*(char)
,	O
port_type_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"clid"	*(char)
,	O
clid_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
"realm"	*(char)
,	O
realm_address_fh	(int,int,*(struct(*(struct(*`,*`,*`)),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
radutent_fh_t	*((int,int,*(struct(*(struct`),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))
_lookup	(*(char))->(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)))
(	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
handlers	array(struct(*(char),*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
handlers	array(struct(*(char),*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))))
[	O
i	int
]	O
.	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
handlers	array(struct(*(char),*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))))
[	O
i	int
]	O
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
parse_string0	(*(char),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))),*(()->(int)),*(void))->(*(char))
(	O
char	O
*	O
fmt	*(char)
,	O
format_data_t	struct
*	O
form	*(struct)
,	O
int	O
(	O
*	O
cond	*(()->(int))
)	O
(	O
)	O
,	O
void	O
*	O
closure	*(void)
)	O
{	O
char	O
*	O
p	*(struct)
;	O
for	O
(	O
p	*(struct)
=	O
fmt	*(char)
;	O
*	O
p	*(struct)
&&	O
(	O
*	O
cond	*(()->(int))
)	O
(	O
closure	*(void)
,	O
p	*(struct)
)	O
==	O
0	int
;	O
p	*(struct)
++	O
)	O
{	O
if	O
(	O
*	O
p	*(struct)
==	O
'\\'	O
)	O
{	O
int	O
c	*(void)
;	O
switch	O
(	O
*	O
++	O
p	*(struct)
)	O
{	O
case	O
'a'	O
:	O
c	*(void)
=	O
'\a'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
c	*(void)
=	O
'\b'	O
;	O
break	O
;	O
case	O
'e'	O
:	O
c	*(void)
=	O
'\033'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
c	*(void)
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
c	*(void)
=	O
'\n'	O
;	O
break	O
;	O
case	O
't'	O
:	O
c	*(void)
=	O
'\t'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
c	*(void)
=	O
'\r'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
c	*(void)
=	O
'\v'	O
;	O
break	O
;	O
default	O
:	O
c	*(void)
=	O
*	O
p	*(struct)
;	O
}	O
grad_slist_append_char	(*(struct),char)->(void)
(	O
slist	*(struct)
,	O
c	*(void)
)	O
;	O
}	O
else	O
grad_slist_append_char	(*(struct),char)->(void)
(	O
slist	*(struct)
,	O
*	O
p	*(struct)
)	O
;	O
}	O
form	*(struct)
->	O
type	int
=	O
FDATA_STRING	int
;	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
string	*(*(char))
=	O
grad_estrdup	(*(char))->(*(char))
(	O
grad_slist_finish	(*(struct))->(*(void))
(	O
slist	*(struct)
)	O
)	O
;	O
return	O
p	*(struct)
;	O
}	O
static	O
int	O
_is_closing_quote	(*(void),*(char))->(int)
(	O
void	O
*	O
closure	*(void)
,	O
char	O
*	O
p	*(struct)
)	O
{	O
return	O
*	O
(	O
char	O
*	O
)	O
closure	*(void)
==	O
*	O
p	*(struct)
;	O
}	O
static	O
int	O
parse_quote	(*(*(char)),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))))->(int)
(	O
char	O
*	O
*	O
fmtp	*(*(char))
,	O
format_data_t	struct
*	O
form	*(struct)
)	O
{	O
char	O
*	O
p	*(struct)
;	O
p	*(struct)
=	O
parse_string0	(*(char),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))),*(()->(int)),*(void))->(*(char))
(	O
*	O
fmtp	*(*(char))
+	O
1	int
,	O
form	*(struct)
,	O
_is_closing_quote	(*(void),*(char))->(int)
,	O
*	O
fmtp	*(*(char))
)	O
;	O
if	O
(	O
!	O
*	O
p	*(struct)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"missing closing quote in string started near `%s'"	*(char)
)	O
,	O
*	O
fmtp	*(*(char))
)	O
;	O
return	O
1	int
;	O
}	O
*	O
fmtp	*(*(char))
=	O
p	*(struct)
+	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_is_delim	(*(void),*(char))->(int)
(	O
void	O
*	O
closure	*(void)
,	O
char	O
*	O
p	*(struct)
)	O
{	O
return	O
*	O
p	*(struct)
==	O
'('	O
;	O
}	O
static	O
int	O
parse_string	(*(*(char)),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))))->(int)
(	O
char	O
*	O
*	O
fmtp	*(*(char))
,	O
format_data_t	struct
*	O
form	*(struct)
)	O
{	O
char	O
*	O
p	*(struct)
;	O
p	*(struct)
=	O
parse_string0	(*(char),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))),*(()->(int)),*(void))->(*(char))
(	O
*	O
fmtp	*(*(char))
,	O
form	*(struct)
,	O
_is_delim	(*(void),*(char))->(int)
,	O
NULL	O
)	O
;	O
*	O
fmtp	*(*(char))
=	O
p	*(struct)
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
get_token	(*(*(char)))->(*(char))
(	O
char	O
*	O
*	O
fmtp	*(*(char))
)	O
{	O
char	O
*	O
p	*(struct)
;	O
while	O
(	O
*	O
*	O
fmtp	*(*(char))
&&	O
isspace	(int)->(int)
(	O
*	O
*	O
fmtp	*(*(char))
)	O
)	O
++	O
*	O
fmtp	*(*(char))
;	O
p	*(struct)
=	O
*	O
fmtp	*(*(char))
;	O
if	O
(	O
*	O
p	*(struct)
==	O
')'	O
)	O
{	O
grad_slist_append_char	(*(struct),char)->(void)
(	O
slist	*(struct)
,	O
*	O
p	*(struct)
)	O
;	O
++	O
*	O
fmtp	*(*(char))
;	O
}	O
else	O
{	O
while	O
(	O
*	O
*	O
fmtp	*(*(char))
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
*	O
fmtp	*(*(char))
)	O
&&	O
*	O
*	O
fmtp	*(*(char))
!=	O
')'	O
)	O
++	O
*	O
fmtp	*(*(char))
;	O
grad_slist_append	(*(struct),*(void),long)->(void)
(	O
slist	*(struct)
,	O
p	*(struct)
,	O
*	O
fmtp	*(*(char))
-	O
p	*(struct)
)	O
;	O
}	O
grad_slist_append_char	(*(struct),char)->(void)
(	O
slist	*(struct)
,	O
0	int
)	O
;	O
return	O
grad_slist_finish	(*(struct))->(*(void))
(	O
slist	*(struct)
)	O
;	O
}	O
static	O
int	O
parse_form	(*(*(char)),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))))->(int)
(	O
char	O
*	O
*	O
fmtp	*(*(char))
,	O
format_data_t	struct
*	O
form	*(struct)
)	O
{	O
char	O
*	O
formname	*(char)
,	O
*	O
p	*(struct)
;	O
format_key_t	struct
*	O
key_head	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
*	O
key_tail	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
++	O
*	O
fmtp	*(*(char))
;	O
formname	*(char)
=	O
get_token	(*(*(char)))->(*(char))
(	O
fmtp	*(*(char))
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
formname	*(char)
,	O
"newline"	*(char)
)	O
==	O
0	int
)	O
{	O
form	*(struct)
->	O
type	int
=	O
FDATA_NEWLINE	int
;	O
p	*(struct)
=	O
get_token	(*(*(char)))->(*(char))
(	O
fmtp	*(*(char))
)	O
;	O
if	O
(	O
p	*(struct)
[	O
0	int
]	O
!=	O
')'	O
)	O
{	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
nl	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
p	*(struct)
,	O
NULL	O
,	O
0	int
)	O
;	O
p	*(struct)
=	O
get_token	(*(*(char)))->(*(char))
(	O
fmtp	*(*(char))
)	O
;	O
}	O
else	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
nl	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
formname	*(char)
,	O
"tab"	*(char)
)	O
==	O
0	int
)	O
{	O
form	*(struct)
->	O
type	int
=	O
FDATA_TAB	int
;	O
p	*(struct)
=	O
get_token	(*(*(char)))->(*(char))
(	O
fmtp	*(*(char))
)	O
;	O
if	O
(	O
p	*(struct)
[	O
0	int
]	O
!=	O
')'	O
)	O
{	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
tabstop	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
p	*(struct)
,	O
NULL	O
,	O
0	int
)	O
;	O
p	*(struct)
=	O
get_token	(*(*(char)))->(*(char))
(	O
fmtp	*(*(char))
)	O
;	O
}	O
else	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
tabstop	int
=	O
1	int
;	O
}	O
else	O
{	O
radutent_fh_t	*((int,int,*(struct(*(struct`),*(char),*(char))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int))
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
;	O
int	O
arg	int
;	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
=	O
_lookup	(*(char))->(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)))
(	O
formname	*(char)
)	O
;	O
if	O
(	O
!	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"error in format spec: unknown format %s"	*(char)
)	O
,	O
formname	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
form	*(struct)
->	O
type	int
=	O
FDATA_FH	int
;	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
;	O
arg	int
=	O
0	int
;	O
while	O
(	O
(	O
p	*(struct)
=	O
get_token	(*(*(char)))->(*(char))
(	O
fmtp	*(*(char))
)	O
)	O
!=	O
NULL	O
&&	O
!	O
(	O
p	*(struct)
[	O
0	int
]	O
==	O
':'	O
||	O
p	*(struct)
[	O
0	int
]	O
==	O
')'	O
)	O
)	O
{	O
arg	int
++	O
;	O
switch	O
(	O
arg	int
)	O
{	O
case	O
1	int
:	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
width	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
p	*(struct)
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
header	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
p	*(struct)
)	O
;	O
break	O
;	O
default	O
:	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"wrong number of arguments to form %s"	*(char)
)	O
,	O
formname	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
key_head	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
NULL	O
;	O
while	O
(	O
p	*(struct)
&&	O
p	*(struct)
[	O
0	int
]	O
==	O
':'	O
)	O
{	O
format_key_t	struct
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
)	O
;	O
if	O
(	O
!	O
key_head	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
)	O
key_head	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
else	O
key_tail	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
key_tail	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
name	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
p	*(struct)
+	O
1	int
)	O
;	O
p	*(struct)
=	O
get_token	(*(*(char)))->(*(char))
(	O
fmtp	*(*(char))
)	O
;	O
if	O
(	O
p	*(struct)
[	O
0	int
]	O
==	O
')'	O
||	O
p	*(struct)
[	O
0	int
]	O
==	O
':'	O
)	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
value	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
"t"	*(char)
)	O
;	O
else	O
{	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
->	O
value	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
p	*(struct)
)	O
;	O
p	*(struct)
=	O
get_token	(*(*(char)))->(*(char))
(	O
fmtp	*(*(char))
)	O
;	O
}	O
}	O
form	*(struct)
->	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
=	O
key_head	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
;	O
}	O
if	O
(	O
p	*(struct)
[	O
0	int
]	O
!=	O
')'	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"form `%s' not closed"	*(char)
)	O
,	O
formname	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
format_data_t	struct
*	O
grad_utent_compile_form	(*(char))->(*(struct))
(	O
char	O
*	O
fmt	*(char)
)	O
{	O
format_data_t	struct
*	O
form_head	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
=	O
NULL	O
,	O
*	O
form_tail	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
;	O
slist	*(struct)
=	O
grad_slist_create	()->(*(struct))
(	O
)	O
;	O
while	O
(	O
*	O
fmt	*(char)
)	O
{	O
int	O
rc	int
;	O
format_data_t	struct
*	O
form	*(struct)
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
form	*(struct)
)	O
)	O
;	O
if	O
(	O
!	O
form_head	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
)	O
form_head	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
=	O
form	*(struct)
;	O
else	O
form_tail	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
form	*(struct)
;	O
form_tail	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
=	O
form	*(struct)
;	O
if	O
(	O
*	O
fmt	*(char)
==	O
'('	O
)	O
rc	int
=	O
parse_form	(*(*(char)),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))))->(int)
(	O
&	O
fmt	*(char)
,	O
form	*(struct)
)	O
;	O
else	O
if	O
(	O
*	O
fmt	*(char)
==	O
'"'	O
||	O
*	O
fmt	*(char)
==	O
'\''	O
)	O
rc	int
=	O
parse_quote	(*(*(char)),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))))->(int)
(	O
&	O
fmt	*(char)
,	O
form	*(struct)
)	O
;	O
else	O
rc	int
=	O
parse_string	(*(*(char)),*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))))->(int)
(	O
&	O
fmt	*(char)
,	O
form	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
form_free	(*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))))->(void)
(	O
form_head	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
)	O
;	O
form_head	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
grad_slist_free	(*(*(struct)))->(void)
(	O
&	O
slist	*(struct)
)	O
;	O
return	O
form_head	*(struct(*(struct(*(struct`),int,*(struct`),union(struct`,*`,int,int))),int,*(struct(*(struct`),*(char),*(char))),union(struct(*((int,int,*`,*`)->(int)),int,*(char)),*(char),int,int)))
;	O
}	O
int	O
grad_utent_print	(*(struct(*(struct(*`,int,*`,union`)),int,*(struct(*`,*`,*`)),union(struct(*`,int,*`),*(char),int,int))),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))),int)->(int)
(	O
format_data_t	struct
*	O
form	*(struct)
,	O
struct	O
radutmp	struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))
*	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
,	O
int	O
newline	int
)	O
{	O
int	O
i	int
;	O
int	O
outbytes	int
=	O
0	int
;	O
for	O
(	O
;	O
form	*(struct)
;	O
form	*(struct)
=	O
form	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
switch	O
(	O
form	*(struct)
->	O
type	int
)	O
{	O
case	O
FDATA_FH	int
:	O
outbytes	int
+=	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
(	O
outbytes	int
,	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
width	int
,	O
form	*(struct)
->	O
key	*(struct(*(struct(*(struct`),*(char),*(char))),*(char),*(char)))
,	O
up	*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char)))
)	O
;	O
break	O
;	O
case	O
FDATA_STRING	int
:	O
outbytes	int
+=	O
output_string	(*(char),int,int)->(int)
(	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
string	*(*(char))
,	O
0	int
,	O
ALIGN_LEFT	int
)	O
;	O
break	O
;	O
case	O
FDATA_TAB	int
:	O
outbytes	int
+=	O
output_tab	(int,int)->(int)
(	O
outbytes	int
,	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
tabstop	int
)	O
;	O
break	O
;	O
case	O
FDATA_NEWLINE	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
nl	int
;	O
i	int
++	O
)	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
newline	int
)	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
return	O
outbytes	int
;	O
}	O
void	O
grad_utent_print_header	(*(struct))->(void)
(	O
format_data_t	struct
*	O
form	*(struct)
)	O
{	O
int	O
i	int
,	O
outbytes	int
=	O
0	int
;	O
format_data_t	struct
*	O
p	*(struct)
;	O
for	O
(	O
p	*(struct)
=	O
form	*(struct)
;	O
p	*(struct)
;	O
p	*(struct)
=	O
p	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
if	O
(	O
p	*(struct)
->	O
type	int
==	O
FDATA_NEWLINE	int
)	O
return	O
;	O
for	O
(	O
;	O
form	*(struct)
;	O
form	*(struct)
=	O
form	*(struct)
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
switch	O
(	O
form	*(struct)
->	O
type	int
)	O
{	O
case	O
FDATA_FH	int
:	O
if	O
(	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
header	*(char)
)	O
outbytes	int
+=	O
output_string	(*(char),int,int)->(int)
(	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
header	*(char)
,	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
width	int
,	O
ALIGN_LEFT	int
)	O
;	O
else	O
outbytes	int
+=	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
fh	struct(*((int,int,*(struct(*`,*`,*`)),*(struct(array(char),array(char),int,array(char),int,int,int,long,long,int,int,long,array(char),int,array(char))))->(int)),int,*(char))
.	O
width	int
;	O
break	O
;	O
case	O
FDATA_STRING	int
:	O
outbytes	int
+=	O
output_string	(*(char),int,int)->(int)
(	O
""	*(char)
,	O
strlen	(*(char))->(long)
(	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
string	*(*(char))
)	O
,	O
ALIGN_LEFT	int
)	O
;	O
break	O
;	O
case	O
FDATA_TAB	int
:	O
outbytes	int
+=	O
output_tab	(int,int)->(int)
(	O
outbytes	int
,	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
tabstop	int
)	O
;	O
break	O
;	O
case	O
FDATA_NEWLINE	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
form	*(struct)
->	O
v	union(struct(*((int,int,*(struct`),*(struct`))->(int)),int,*(char)),*(char),int,int)
.	O
nl	int
;	O
i	int
++	O
)	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
