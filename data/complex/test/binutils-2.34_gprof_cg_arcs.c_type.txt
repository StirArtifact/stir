static	O
int	O
cmp_topo	O
(	O
const	O
PTR	O
,	O
const	O
PTR	O
)	O
;	O
static	O
void	O
propagate_time	O
(	O
Sym	O
*	O
)	O
;	O
static	O
void	O
cycle_time	O
(	O
void	O
)	O
;	O
static	O
void	O
cycle_link	O
(	O
void	O
)	O
;	O
static	O
void	O
inherit_flags	O
(	O
Sym	O
*	O
)	O
;	O
static	O
void	O
propagate_flags	O
(	O
Sym	O
*	O
*	O
)	O
;	O
static	O
int	O
cmp_total	O
(	O
const	O
PTR	O
,	O
const	O
PTR	O
)	O
;	O
Sym	O
*	O
cycle_header	O
;	O
unsigned	O
int	O
num_cycles	O
;	O
Arc	O
*	O
*	O
arcs	O
;	O
unsigned	O
int	O
numarcs	O
;	O
Arc	O
*	O
arc_lookup	O
(	O
Sym	O
*	O
parent	O
,	O
Sym	O
*	O
child	O
)	O
{	O
Arc	O
*	O
arc	O
;	O
if	O
(	O
!	O
parent	O
||	O
!	O
child	O
)	O
{	O
printf	(*(char))->(int)
(	O
"[arc_lookup] parent == 0 || child == 0\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
DBG	O
(	O
LOOKUPDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[arc_lookup] parent %s child %s\n"	*(char)
,	O
parent	O
->	O
name	*(char)
,	O
child	O
->	O
name	*(char)
)	O
)	O
;	O
for	O
(	O
arc	O
=	O
parent	O
->	O
cg	O
.	O
children	O
;	O
arc	O
;	O
arc	O
=	O
arc	O
->	O
next_child	O
)	O
{	O
DBG	O
(	O
LOOKUPDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[arc_lookup]\t parent %s child %s\n"	*(char)
,	O
arc	O
->	O
parent	O
->	O
name	*(char)
,	O
arc	O
->	O
child	O
->	O
name	*(char)
)	O
)	O
;	O
if	O
(	O
child	O
->	O
addr	*(void)
>=	O
arc	O
->	O
child	O
->	O
addr	*(void)
&&	O
child	O
->	O
end_addr	O
<=	O
arc	O
->	O
child	O
->	O
end_addr	O
)	O
{	O
return	O
arc	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
arc_add	O
(	O
Sym	O
*	O
parent	O
,	O
Sym	O
*	O
child	O
,	O
unsigned	O
long	O
count	int
)	O
{	O
static	O
unsigned	O
int	O
maxarcs	O
=	O
0	int
;	O
Arc	O
*	O
arc	O
,	O
*	O
*	O
newarcs	O
;	O
DBG	O
(	O
TALLYDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[arc_add] %lu arcs from %s to %s\n"	*(char)
,	O
count	int
,	O
parent	O
->	O
name	*(char)
,	O
child	O
->	O
name	*(char)
)	O
)	O
;	O
arc	O
=	O
arc_lookup	O
(	O
parent	O
,	O
child	O
)	O
;	O
if	O
(	O
arc	O
)	O
{	O
DBG	O
(	O
TALLYDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[tally] hit %lu += %lu\n"	*(char)
,	O
arc	O
->	O
count	int
,	O
count	int
)	O
)	O
;	O
arc	O
->	O
count	int
+=	O
count	int
;	O
return	O
;	O
}	O
arc	O
=	O
(	O
Arc	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
(	O
*	O
arc	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
arc	O
,	O
0	int
,	O
sizeof	O
(	O
*	O
arc	O
)	O
)	O
;	O
arc	O
->	O
parent	O
=	O
parent	O
;	O
arc	O
->	O
child	O
=	O
child	O
;	O
arc	O
->	O
count	int
=	O
count	int
;	O
if	O
(	O
parent	O
!=	O
child	O
)	O
{	O
if	O
(	O
numarcs	O
==	O
maxarcs	O
)	O
{	O
if	O
(	O
maxarcs	O
==	O
0	int
)	O
maxarcs	O
=	O
1	int
;	O
maxarcs	O
*=	O
2	int
;	O
newarcs	O
=	O
(	O
Arc	O
*	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
(	O
Arc	O
*	O
)	O
*	O
maxarcs	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
newarcs	O
,	O
arcs	O
,	O
numarcs	O
*	O
sizeof	O
(	O
Arc	O
*	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
arcs	O
)	O
;	O
arcs	O
=	O
newarcs	O
;	O
}	O
arcs	O
[	O
numarcs	O
++	O
]	O
=	O
arc	O
;	O
}	O
arc	O
->	O
next_child	O
=	O
parent	O
->	O
cg	O
.	O
children	O
;	O
parent	O
->	O
cg	O
.	O
children	O
=	O
arc	O
;	O
arc	O
->	O
next_parent	O
=	O
child	O
->	O
cg	O
.	O
parents	O
;	O
child	O
->	O
cg	O
.	O
parents	O
=	O
arc	O
;	O
}	O
static	O
int	O
cmp_topo	O
(	O
const	O
PTR	O
lp	O
,	O
const	O
PTR	O
rp	O
)	O
{	O
const	O
Sym	O
*	O
left	O
=	O
*	O
(	O
const	O
Sym	O
*	O
*	O
)	O
lp	O
;	O
const	O
Sym	O
*	O
right	O
=	O
*	O
(	O
const	O
Sym	O
*	O
*	O
)	O
rp	O
;	O
return	O
left	O
->	O
cg	O
.	O
top_order	O
-	O
right	O
->	O
cg	O
.	O
top_order	O
;	O
}	O
static	O
void	O
propagate_time	O
(	O
Sym	O
*	O
parent	O
)	O
{	O
Arc	O
*	O
arc	O
;	O
Sym	O
*	O
child	O
;	O
double	O
share	O
,	O
prop_share	O
;	O
if	O
(	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
==	O
0.0	int
)	O
{	O
return	O
;	O
}	O
for	O
(	O
arc	O
=	O
parent	O
->	O
cg	O
.	O
children	O
;	O
arc	O
;	O
arc	O
=	O
arc	O
->	O
next_child	O
)	O
{	O
child	O
=	O
arc	O
->	O
child	O
;	O
if	O
(	O
arc	O
->	O
count	int
==	O
0	int
||	O
child	O
==	O
parent	O
||	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
child	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
!=	O
child	O
)	O
{	O
if	O
(	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
num	O
==	O
child	O
->	O
cg	O
.	O
cyc	O
.	O
num	O
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
parent	O
->	O
cg	O
.	O
top_order	O
<=	O
child	O
->	O
cg	O
.	O
top_order	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"[propagate] toporder botches\n"	*(char)
)	O
;	O
}	O
child	O
=	O
child	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
;	O
}	O
else	O
{	O
if	O
(	O
parent	O
->	O
cg	O
.	O
top_order	O
<=	O
child	O
->	O
cg	O
.	O
top_order	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"[propagate] toporder botches\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
child	O
->	O
ncalls	O
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
arc	O
->	O
time	struct(long,long)
=	O
child	O
->	O
hist	O
.	O
time	struct(long,long)
*	O
(	O
(	O
(	O
double	O
)	O
arc	O
->	O
count	int
)	O
/	O
(	O
(	O
double	O
)	O
child	O
->	O
ncalls	O
)	O
)	O
;	O
arc	O
->	O
child_time	O
=	O
child	O
->	O
cg	O
.	O
child_time	O
*	O
(	O
(	O
(	O
double	O
)	O
arc	O
->	O
count	int
)	O
/	O
(	O
(	O
double	O
)	O
child	O
->	O
ncalls	O
)	O
)	O
;	O
share	O
=	O
arc	O
->	O
time	struct(long,long)
+	O
arc	O
->	O
child_time	O
;	O
parent	O
->	O
cg	O
.	O
child_time	O
+=	O
share	O
;	O
prop_share	O
=	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
*	O
share	O
;	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
child	O
+=	O
prop_share	O
;	O
arc	O
->	O
time	struct(long,long)
*=	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
;	O
arc	O
->	O
child_time	O
*=	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
;	O
if	O
(	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
!=	O
parent	O
)	O
{	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
->	O
cg	O
.	O
child_time	O
+=	O
share	O
;	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
->	O
cg	O
.	O
prop	O
.	O
child	O
+=	O
prop_share	O
;	O
}	O
DBG	O
(	O
PROPDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[prop_time] child \t"	*(char)
)	O
;	O
print_name	O
(	O
child	O
)	O
;	O
printf	(*(char))->(int)
(	O
" with %f %f %lu/%lu\n"	*(char)
,	O
child	O
->	O
hist	O
.	O
time	struct(long,long)
,	O
child	O
->	O
cg	O
.	O
child_time	O
,	O
arc	O
->	O
count	int
,	O
child	O
->	O
ncalls	O
)	O
;	O
printf	(*(char))->(int)
(	O
"[prop_time] parent\t"	*(char)
)	O
;	O
print_name	O
(	O
parent	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n[prop_time] share %f\n"	*(char)
,	O
share	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
cycle_time	O
(	O
void	O
)	O
{	O
Sym	O
*	O
member	O
,	O
*	O
cyc	O
;	O
for	O
(	O
cyc	O
=	O
&	O
cycle_header	O
[	O
1	int
]	O
;	O
cyc	O
<=	O
&	O
cycle_header	O
[	O
num_cycles	O
]	O
;	O
++	O
cyc	O
)	O
{	O
for	O
(	O
member	O
=	O
cyc	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
member	O
;	O
member	O
=	O
member	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
member	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
==	O
0.0	int
)	O
{	O
continue	O
;	O
}	O
cyc	O
->	O
hist	O
.	O
time	struct(long,long)
+=	O
member	O
->	O
hist	O
.	O
time	struct(long,long)
;	O
}	O
cyc	O
->	O
cg	O
.	O
prop	O
.	O
self	O
=	O
cyc	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
*	O
cyc	O
->	O
hist	O
.	O
time	struct(long,long)
;	O
}	O
}	O
static	O
void	O
cycle_link	O
(	O
void	O
)	O
{	O
Sym	O
*	O
sym	*(struct)
,	O
*	O
cyc	O
,	O
*	O
member	O
;	O
Arc	O
*	O
arc	O
;	O
int	O
num	O
;	O
num_cycles	O
=	O
0	int
;	O
for	O
(	O
sym	*(struct)
=	O
symtab	O
.	O
base	int
;	O
sym	*(struct)
<	O
symtab	O
.	O
limit	O
;	O
++	O
sym	*(struct)
)	O
{	O
if	O
(	O
sym	*(struct)
->	O
cg	O
.	O
cyc	O
.	O
head	O
==	O
sym	*(struct)
&&	O
sym	*(struct)
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
++	O
num_cycles	O
;	O
}	O
}	O
cycle_header	O
=	O
(	O
Sym	O
*	O
)	O
xmalloc	O
(	O
(	O
num_cycles	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
Sym	O
)	O
)	O
;	O
num	O
=	O
0	int
;	O
cyc	O
=	O
cycle_header	O
;	O
for	O
(	O
sym	*(struct)
=	O
symtab	O
.	O
base	int
;	O
sym	*(struct)
<	O
symtab	O
.	O
limit	O
;	O
++	O
sym	*(struct)
)	O
{	O
if	O
(	O
!	O
(	O
sym	*(struct)
->	O
cg	O
.	O
cyc	O
.	O
head	O
==	O
sym	*(struct)
&&	O
sym	*(struct)
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
!=	O
0	int
)	O
)	O
{	O
continue	O
;	O
}	O
++	O
num	O
;	O
++	O
cyc	O
;	O
sym_init	O
(	O
cyc	O
)	O
;	O
cyc	O
->	O
cg	O
.	O
print_flag	O
=	O
TRUE	int
;	O
cyc	O
->	O
cg	O
.	O
top_order	O
=	O
DFN_NAN	O
;	O
cyc	O
->	O
cg	O
.	O
cyc	O
.	O
num	O
=	O
num	O
;	O
cyc	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
=	O
cyc	O
;	O
cyc	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
sym	*(struct)
;	O
DBG	O
(	O
CYCLEDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[cycle_link] "	*(char)
)	O
;	O
print_name	O
(	O
sym	*(struct)
)	O
;	O
printf	(*(char))->(int)
(	O
" is the head of cycle %d\n"	*(char)
,	O
num	O
)	O
)	O
;	O
for	O
(	O
member	O
=	O
sym	*(struct)
;	O
member	O
;	O
member	O
=	O
member	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
member	O
->	O
cg	O
.	O
cyc	O
.	O
num	O
=	O
num	O
;	O
member	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
=	O
cyc	O
;	O
}	O
for	O
(	O
member	O
=	O
sym	*(struct)
;	O
member	O
;	O
member	O
=	O
member	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
for	O
(	O
arc	O
=	O
member	O
->	O
cg	O
.	O
parents	O
;	O
arc	O
;	O
arc	O
=	O
arc	O
->	O
next_parent	O
)	O
{	O
if	O
(	O
arc	O
->	O
parent	O
==	O
member	O
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
arc	O
->	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
num	O
==	O
num	O
)	O
{	O
cyc	O
->	O
cg	O
.	O
self_calls	O
+=	O
arc	O
->	O
count	int
;	O
}	O
else	O
{	O
cyc	O
->	O
ncalls	O
+=	O
arc	O
->	O
count	int
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
inherit_flags	O
(	O
Sym	O
*	O
child	O
)	O
{	O
Sym	O
*	O
head	O
,	O
*	O
parent	O
,	O
*	O
member	O
;	O
Arc	O
*	O
arc	O
;	O
head	O
=	O
child	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
;	O
if	O
(	O
child	O
==	O
head	O
)	O
{	O
child	O
->	O
cg	O
.	O
print_flag	O
=	O
FALSE	O
;	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
=	O
0.0	int
;	O
for	O
(	O
arc	O
=	O
child	O
->	O
cg	O
.	O
parents	O
;	O
arc	O
;	O
arc	O
=	O
arc	O
->	O
next_parent	O
)	O
{	O
parent	O
=	O
arc	O
->	O
parent	O
;	O
if	O
(	O
child	O
==	O
parent	O
)	O
{	O
continue	O
;	O
}	O
child	O
->	O
cg	O
.	O
print_flag	O
|=	O
parent	O
->	O
cg	O
.	O
print_flag	O
;	O
if	O
(	O
child	O
->	O
ncalls	O
!=	O
0	int
)	O
{	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
+=	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
*	O
(	O
(	O
(	O
double	O
)	O
arc	O
->	O
count	int
)	O
/	O
(	O
(	O
double	O
)	O
child	O
->	O
ncalls	O
)	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
head	O
->	O
cg	O
.	O
print_flag	O
=	O
FALSE	O
;	O
head	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
=	O
0.0	int
;	O
for	O
(	O
member	O
=	O
head	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
member	O
;	O
member	O
=	O
member	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
for	O
(	O
arc	O
=	O
member	O
->	O
cg	O
.	O
parents	O
;	O
arc	O
;	O
arc	O
=	O
arc	O
->	O
next_parent	O
)	O
{	O
if	O
(	O
arc	O
->	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
==	O
head	O
)	O
{	O
continue	O
;	O
}	O
parent	O
=	O
arc	O
->	O
parent	O
;	O
head	O
->	O
cg	O
.	O
print_flag	O
|=	O
parent	O
->	O
cg	O
.	O
print_flag	O
;	O
if	O
(	O
head	O
->	O
ncalls	O
!=	O
0	int
)	O
{	O
head	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
+=	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
*	O
(	O
(	O
(	O
double	O
)	O
arc	O
->	O
count	int
)	O
/	O
(	O
(	O
double	O
)	O
head	O
->	O
ncalls	O
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
member	O
=	O
head	O
;	O
member	O
;	O
member	O
=	O
member	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
member	O
->	O
cg	O
.	O
print_flag	O
=	O
head	O
->	O
cg	O
.	O
print_flag	O
;	O
member	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
=	O
head	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
;	O
}	O
}	O
}	O
static	O
void	O
propagate_flags	O
(	O
Sym	O
*	O
*	O
symbols	O
)	O
{	O
int	O
sym_index	O
;	O
Sym	O
*	O
old_head	O
,	O
*	O
child	O
;	O
old_head	O
=	O
0	int
;	O
for	O
(	O
sym_index	O
=	O
symtab	O
.	O
len	long
-	O
1	int
;	O
sym_index	O
>=	O
0	int
;	O
--	O
sym_index	O
)	O
{	O
child	O
=	O
symbols	O
[	O
sym_index	O
]	O
;	O
if	O
(	O
child	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
!=	O
old_head	O
)	O
{	O
old_head	O
=	O
child	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
;	O
inherit_flags	O
(	O
child	O
)	O
;	O
}	O
DBG	O
(	O
PROPDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[prop_flags] "	*(char)
)	O
;	O
print_name	O
(	O
child	O
)	O
;	O
printf	(*(char))->(int)
(	O
"inherits print-flag %d and prop-fract %f\n"	*(char)
,	O
child	O
->	O
cg	O
.	O
print_flag	O
,	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
)	O
)	O
;	O
if	O
(	O
!	O
child	O
->	O
cg	O
.	O
print_flag	O
)	O
{	O
if	O
(	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_GRAPH	O
]	O
,	O
child	O
->	O
addr	*(void)
)	O
||	O
(	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_GRAPH	O
]	O
.	O
len	long
==	O
0	int
&&	O
!	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
EXCL_GRAPH	O
]	O
,	O
child	O
->	O
addr	*(void)
)	O
)	O
)	O
{	O
child	O
->	O
cg	O
.	O
print_flag	O
=	O
TRUE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_GRAPH	O
]	O
,	O
child	O
->	O
addr	*(void)
)	O
&&	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
EXCL_GRAPH	O
]	O
,	O
child	O
->	O
addr	*(void)
)	O
)	O
{	O
child	O
->	O
cg	O
.	O
print_flag	O
=	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
==	O
0.0	int
)	O
{	O
if	O
(	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_TIME	O
]	O
,	O
child	O
->	O
addr	*(void)
)	O
||	O
(	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_TIME	O
]	O
.	O
len	long
==	O
0	int
&&	O
!	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
EXCL_TIME	O
]	O
,	O
child	O
->	O
addr	*(void)
)	O
)	O
)	O
{	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
=	O
1.0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_TIME	O
]	O
,	O
child	O
->	O
addr	*(void)
)	O
&&	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
EXCL_TIME	O
]	O
,	O
child	O
->	O
addr	*(void)
)	O
)	O
{	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
=	O
0.0	int
;	O
}	O
}	O
child	O
->	O
cg	O
.	O
prop	O
.	O
self	O
=	O
child	O
->	O
hist	O
.	O
time	struct(long,long)
*	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
;	O
print_time	O
+=	O
child	O
->	O
cg	O
.	O
prop	O
.	O
self	O
;	O
DBG	O
(	O
PROPDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[prop_flags] "	*(char)
)	O
;	O
print_name	O
(	O
child	O
)	O
;	O
printf	(*(char))->(int)
(	O
" ends up with printflag %d and prop-fract %f\n"	*(char)
,	O
child	O
->	O
cg	O
.	O
print_flag	O
,	O
child	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
)	O
;	O
printf	(*(char))->(int)
(	O
"[prop_flags] time %f propself %f print_time %f\n"	*(char)
,	O
child	O
->	O
hist	O
.	O
time	struct(long,long)
,	O
child	O
->	O
cg	O
.	O
prop	O
.	O
self	O
,	O
print_time	O
)	O
)	O
;	O
}	O
}	O
static	O
int	O
cmp_total	O
(	O
const	O
PTR	O
lp	O
,	O
const	O
PTR	O
rp	O
)	O
{	O
const	O
Sym	O
*	O
left	O
=	O
*	O
(	O
const	O
Sym	O
*	O
*	O
)	O
lp	O
;	O
const	O
Sym	O
*	O
right	O
=	O
*	O
(	O
const	O
Sym	O
*	O
*	O
)	O
rp	O
;	O
double	O
diff	O
;	O
diff	O
=	O
(	O
left	O
->	O
cg	O
.	O
prop	O
.	O
self	O
+	O
left	O
->	O
cg	O
.	O
prop	O
.	O
child	O
)	O
-	O
(	O
right	O
->	O
cg	O
.	O
prop	O
.	O
self	O
+	O
right	O
->	O
cg	O
.	O
prop	O
.	O
child	O
)	O
;	O
if	O
(	O
diff	O
<	O
0.0	int
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
diff	O
>	O
0.0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
left	O
->	O
name	*(char)
&&	O
left	O
->	O
cg	O
.	O
cyc	O
.	O
num	O
!=	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
right	O
->	O
name	*(char)
&&	O
right	O
->	O
cg	O
.	O
cyc	O
.	O
num	O
!=	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
left	O
->	O
name	*(char)
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
right	O
->	O
name	*(char)
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
left	O
->	O
name	*(char)
[	O
0	int
]	O
!=	O
'_'	O
&&	O
right	O
->	O
name	*(char)
[	O
0	int
]	O
==	O
'_'	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
left	O
->	O
name	*(char)
[	O
0	int
]	O
==	O
'_'	O
&&	O
right	O
->	O
name	*(char)
[	O
0	int
]	O
!=	O
'_'	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
left	O
->	O
ncalls	O
>	O
right	O
->	O
ncalls	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
left	O
->	O
ncalls	O
<	O
right	O
->	O
ncalls	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
left	O
->	O
name	*(char)
,	O
right	O
->	O
name	*(char)
)	O
;	O
}	O
Sym	O
*	O
*	O
cg_assemble	O
(	O
void	O
)	O
{	O
Sym	O
*	O
parent	O
,	O
*	O
*	O
time_sorted_syms	O
,	O
*	O
*	O
top_sorted_syms	O
;	O
unsigned	O
int	O
sym_index	O
;	O
Arc	O
*	O
arc	O
;	O
for	O
(	O
parent	O
=	O
symtab	O
.	O
base	int
;	O
parent	O
<	O
symtab	O
.	O
limit	O
;	O
parent	O
++	O
)	O
{	O
parent	O
->	O
cg	O
.	O
child_time	O
=	O
0.0	int
;	O
arc	O
=	O
arc_lookup	O
(	O
parent	O
,	O
parent	O
)	O
;	O
if	O
(	O
arc	O
&&	O
parent	O
==	O
arc	O
->	O
child	O
)	O
{	O
parent	O
->	O
ncalls	O
-=	O
arc	O
->	O
count	int
;	O
parent	O
->	O
cg	O
.	O
self_calls	O
=	O
arc	O
->	O
count	int
;	O
}	O
else	O
{	O
parent	O
->	O
cg	O
.	O
self_calls	O
=	O
0	int
;	O
}	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
fract	O
=	O
0.0	int
;	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
self	O
=	O
0.0	int
;	O
parent	O
->	O
cg	O
.	O
prop	O
.	O
child	O
=	O
0.0	int
;	O
parent	O
->	O
cg	O
.	O
print_flag	O
=	O
FALSE	O
;	O
parent	O
->	O
cg	O
.	O
top_order	O
=	O
DFN_NAN	O
;	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
num	O
=	O
0	int
;	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
head	O
=	O
parent	O
;	O
parent	O
->	O
cg	O
.	O
cyc	O
.	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
0	int
;	O
if	O
(	O
ignore_direct_calls	O
)	O
find_call	O
(	O
parent	O
,	O
parent	O
->	O
addr	*(void)
,	O
(	O
parent	O
+	O
1	int
)	O
->	O
addr	*(void)
)	O
;	O
}	O
for	O
(	O
parent	O
=	O
symtab	O
.	O
base	int
;	O
parent	O
<	O
symtab	O
.	O
limit	O
;	O
parent	O
++	O
)	O
{	O
if	O
(	O
parent	O
->	O
cg	O
.	O
top_order	O
==	O
DFN_NAN	O
)	O
cg_dfn	O
(	O
parent	O
)	O
;	O
}	O
cycle_link	O
(	O
)	O
;	O
top_sorted_syms	O
=	O
(	O
Sym	O
*	O
*	O
)	O
xmalloc	O
(	O
symtab	O
.	O
len	long
*	O
sizeof	O
(	O
Sym	O
*	O
)	O
)	O
;	O
for	O
(	O
sym_index	O
=	O
0	int
;	O
sym_index	O
<	O
symtab	O
.	O
len	long
;	O
++	O
sym_index	O
)	O
top_sorted_syms	O
[	O
sym_index	O
]	O
=	O
&	O
symtab	O
.	O
base	int
[	O
sym_index	O
]	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
top_sorted_syms	O
,	O
symtab	O
.	O
len	long
,	O
sizeof	O
(	O
Sym	O
*	O
)	O
,	O
cmp_topo	O
)	O
;	O
DBG	O
(	O
DFNDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[cg_assemble] topological sort listing\n"	*(char)
)	O
;	O
for	O
(	O
sym_index	O
=	O
0	int
;	O
sym_index	O
<	O
symtab	O
.	O
len	long
;	O
++	O
sym_index	O
)	O
{	O
printf	(*(char))->(int)
(	O
"[cg_assemble] "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%d:"	*(char)
,	O
top_sorted_syms	O
[	O
sym_index	O
]	O
->	O
cg	O
.	O
top_order	O
)	O
;	O
print_name	O
(	O
top_sorted_syms	O
[	O
sym_index	O
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
)	O
;	O
propagate_flags	O
(	O
top_sorted_syms	O
)	O
;	O
cycle_time	O
(	O
)	O
;	O
for	O
(	O
sym_index	O
=	O
0	int
;	O
sym_index	O
<	O
symtab	O
.	O
len	long
;	O
++	O
sym_index	O
)	O
propagate_time	O
(	O
top_sorted_syms	O
[	O
sym_index	O
]	O
)	O
;	O
free	(*(void))->(void)
(	O
top_sorted_syms	O
)	O
;	O
time_sorted_syms	O
=	O
(	O
Sym	O
*	O
*	O
)	O
xmalloc	O
(	O
(	O
symtab	O
.	O
len	long
+	O
num_cycles	O
)	O
*	O
sizeof	O
(	O
Sym	O
*	O
)	O
)	O
;	O
for	O
(	O
sym_index	O
=	O
0	int
;	O
sym_index	O
<	O
symtab	O
.	O
len	long
;	O
sym_index	O
++	O
)	O
time_sorted_syms	O
[	O
sym_index	O
]	O
=	O
&	O
symtab	O
.	O
base	int
[	O
sym_index	O
]	O
;	O
for	O
(	O
sym_index	O
=	O
1	int
;	O
sym_index	O
<=	O
num_cycles	O
;	O
sym_index	O
++	O
)	O
time_sorted_syms	O
[	O
symtab	O
.	O
len	long
+	O
sym_index	O
-	O
1	int
]	O
=	O
&	O
cycle_header	O
[	O
sym_index	O
]	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
time_sorted_syms	O
,	O
symtab	O
.	O
len	long
+	O
num_cycles	O
,	O
sizeof	O
(	O
Sym	O
*	O
)	O
,	O
cmp_total	O
)	O
;	O
for	O
(	O
sym_index	O
=	O
0	int
;	O
sym_index	O
<	O
symtab	O
.	O
len	long
+	O
num_cycles	O
;	O
sym_index	O
++	O
)	O
time_sorted_syms	O
[	O
sym_index	O
]	O
->	O
cg	O
.	O
index	(*(char),int)->(*(char))
=	O
sym_index	O
+	O
1	int
;	O
return	O
time_sorted_syms	O
;	O
}	O
