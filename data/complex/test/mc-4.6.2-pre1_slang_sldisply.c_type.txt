int	O
SLtt_Screen_Cols	int
=	O
80	int
;	O
int	O
SLtt_Screen_Rows	int
=	O
24	int
;	O
int	O
SLtt_Term_Cannot_Insert	int
;	O
int	O
SLtt_Term_Cannot_Scroll	int
;	O
int	O
SLtt_Use_Ansi_Colors	int
;	O
int	O
SLtt_Blink_Mode	int
=	O
0	int
;	O
int	O
SLtt_Use_Blink_For_ACS	int
=	O
0	int
;	O
int	O
SLtt_Newline_Ok	int
=	O
0	int
;	O
int	O
SLtt_Has_Alt_Charset	int
=	O
0	int
;	O
int	O
SLtt_Force_Keypad_Init	int
=	O
0	int
;	O
void	O
(	O
*	O
_pSLtt_color_changed_hook	*(()->(void))
)	O
(	O
void	O
)	O
;	O
static	O
int	O
Bce_Color_Offset	int
=	O
0	int
;	O
static	O
int	O
Can_Background_Color_Erase	int
=	O
1	int
;	O
int	O
SLtt_Has_Status_Line	int
=	O
-	O
1	int
;	O
int	O
SLang_TT_Write_FD	int
=	O
-	O
1	int
;	O
static	O
int	O
Automatic_Margins	int
;	O
static	O
int	O
Worthless_Highlight	int
;	O
static	O
int	O
Has_HP_Glitch	int
;	O
static	O
char	O
*	O
Reset_Color_String	*(char)
;	O
static	O
int	O
Is_Color_Terminal	int
=	O
0	int
;	O
static	O
int	O
Linux_Console	int
;	O
static	O
int	O
QANSI_Console	int
;	O
static	O
int	O
Mouse_Mode	int
=	O
-	O
1	int
;	O
typedef	O
struct	O
{	O
SLtt_Char_Type	long
fgbg	long
;	O
SLtt_Char_Type	long
mono	long
;	O
}	O
Brush_Info_Type	struct(long,long)
;	O
static	O
Brush_Info_Type	struct(long,long)
Brush_Table	array(struct(long,long))
[	O
JMAX_COLORS	int
]	O
;	O
static	O
int	O
Is_Bg_BGR	int
=	O
0	int
;	O
static	O
SLCONST	O
int	O
RGB_to_BGR	array(int)
[	O
]	O
=	O
{	O
0	int
,	O
4	int
,	O
2	int
,	O
6	int
,	O
1	int
,	O
5	int
,	O
3	int
,	O
7	int
}	O
;	O
static	O
char	O
*	O
Color_Fg_Str	*(char)
=	O
"\033[3%dm"	*(char)
;	O
static	O
char	O
*	O
Color_Bg_Str	*(char)
=	O
"\033[4%dm"	*(char)
;	O
static	O
char	O
*	O
Default_Color_Fg_Str	*(char)
=	O
"\033[39m"	*(char)
;	O
static	O
char	O
*	O
Default_Color_Bg_Str	*(char)
=	O
"\033[49m"	*(char)
;	O
static	O
int	O
Max_Terminfo_Colors	int
=	O
8	int
;	O
char	O
*	O
SLtt_Graphics_Char_Pairs	*(char)
;	O
static	O
char	O
*	O
UnderLine_Vid_Str	*(char)
;	O
static	O
char	O
*	O
Blink_Vid_Str	*(char)
;	O
static	O
char	O
*	O
Bold_Vid_Str	*(char)
;	O
static	O
char	O
*	O
Ins_Mode_Str	*(char)
;	O
static	O
char	O
*	O
Eins_Mode_Str	*(char)
;	O
static	O
char	O
*	O
Scroll_R_Str	*(char)
;	O
static	O
char	O
*	O
Cls_Str	*(char)
;	O
static	O
char	O
*	O
Rev_Vid_Str	*(char)
;	O
static	O
char	O
*	O
Norm_Vid_Str	*(char)
;	O
static	O
char	O
*	O
Del_Eol_Str	*(char)
;	O
static	O
char	O
*	O
Del_Bol_Str	*(char)
;	O
static	O
char	O
*	O
Del_Char_Str	*(char)
;	O
static	O
char	O
*	O
Del_N_Lines_Str	*(char)
;	O
static	O
char	O
*	O
Add_N_Lines_Str	*(char)
;	O
static	O
char	O
*	O
Rev_Scroll_Str	*(char)
;	O
static	O
char	O
*	O
Curs_Up_Str	*(char)
;	O
static	O
char	O
*	O
Curs_F_Str	*(char)
;	O
static	O
char	O
*	O
Cursor_Visible_Str	*(char)
;	O
static	O
char	O
*	O
Cursor_Invisible_Str	*(char)
;	O
static	O
char	O
*	O
Start_Alt_Chars_Str	*(char)
;	O
static	O
char	O
*	O
End_Alt_Chars_Str	*(char)
;	O
static	O
char	O
*	O
Enable_Alt_Char_Set	*(char)
;	O
static	O
char	O
*	O
Term_Init_Str	*(char)
;	O
static	O
char	O
*	O
Keypad_Init_Str	*(char)
;	O
static	O
char	O
*	O
Term_Reset_Str	*(char)
;	O
static	O
char	O
*	O
Keypad_Reset_Str	*(char)
;	O
static	O
char	O
*	O
Disable_Status_line_Str	*(char)
;	O
static	O
char	O
*	O
Return_From_Status_Line_Str	*(char)
;	O
static	O
char	O
*	O
Goto_Status_Line_Str	*(char)
;	O
static	O
int	O
Num_Status_Line_Columns	int
;	O
static	O
char	O
*	O
Curs_Pos_Str	*(char)
;	O
static	O
int	O
Scroll_r1	int
=	O
0	int
,	O
Scroll_r2	int
=	O
23	int
;	O
static	O
int	O
Cursor_r	int
,	O
Cursor_c	int
;	O
static	O
SLtt_Char_Type	long
Current_Fgbg	long
=	O
0xFFFFFFFFU	int
;	O
static	O
int	O
Cursor_Set	int
;	O
static	O
unsigned	O
char	O
Output_Buffer	array(char)
[	O
MAX_OUTPUT_BUFFER_SIZE	int
]	O
;	O
static	O
unsigned	O
char	O
*	O
Output_Bufferp	*(char)
=	O
Output_Buffer	array(char)
;	O
unsigned	O
long	O
SLtt_Num_Chars_Output	long
;	O
int	O
_pSLusleep	(long)->(int)
(	O
unsigned	O
long	O
usecs	long
)	O
{	O
struct	O
timeval	struct(long,long)
tv	*(struct(long,long))
;	O
tv	*(struct(long,long))
.	O
tv_sec	long
=	O
usecs	long
/	O
1000000	int
;	O
tv	*(struct(long,long))
.	O
tv_usec	long
=	O
usecs	long
%	O
1000000	int
;	O
return	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	*(struct(long,long))
)	O
;	O
}	O
int	O
SLtt_flush_output	()->(int)
(	O
void	O
)	O
{	O
int	O
nwrite	int
=	O
0	int
;	O
unsigned	O
int	O
total	int
;	O
int	O
n	int
=	O
(	O
int	O
)	O
(	O
Output_Bufferp	*(char)
-	O
Output_Buffer	array(char)
)	O
;	O
SLtt_Num_Chars_Output	long
+=	O
n	int
;	O
total	int
=	O
0	int
;	O
while	O
(	O
n	int
>	O
0	int
)	O
{	O
nwrite	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
SLang_TT_Write_FD	int
,	O
(	O
char	O
*	O
)	O
Output_Buffer	array(char)
+	O
total	int
,	O
n	int
)	O
;	O
if	O
(	O
nwrite	int
==	O
-	O
1	int
)	O
{	O
nwrite	int
=	O
0	int
;	O
if	O
(	O
errno	O
==	O
EAGAIN	int
)	O
{	O
_pSLusleep	(long)->(int)
(	O
100000	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
_pSLusleep	(long)->(int)
(	O
100000	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
break	O
;	O
}	O
n	int
-=	O
nwrite	int
;	O
total	int
+=	O
nwrite	int
;	O
}	O
Output_Bufferp	*(char)
=	O
Output_Buffer	array(char)
;	O
return	O
n	int
;	O
}	O
int	O
SLtt_Baud_Rate	int
;	O
static	O
void	O
tt_write	(*(char),int)->(void)
(	O
char	O
*	O
str	*(char)
,	O
unsigned	O
int	O
n	int
)	O
{	O
static	O
unsigned	O
long	O
last_time	long
;	O
static	O
int	O
total	int
;	O
unsigned	O
long	O
now	long
;	O
unsigned	O
int	O
ndiff	int
;	O
if	O
(	O
(	O
str	*(char)
==	O
NULL	O
)	O
||	O
(	O
n	int
==	O
0	int
)	O
)	O
return	O
;	O
total	int
+=	O
n	int
;	O
while	O
(	O
1	int
)	O
{	O
ndiff	int
=	O
MAX_OUTPUT_BUFFER_SIZE	int
-	O
(	O
int	O
)	O
(	O
Output_Bufferp	*(char)
-	O
Output_Buffer	array(char)
)	O
;	O
if	O
(	O
ndiff	int
<	O
n	int
)	O
{	O
SLMEMCPY	O
(	O
(	O
char	O
*	O
)	O
Output_Bufferp	*(char)
,	O
str	*(char)
,	O
ndiff	int
)	O
;	O
Output_Bufferp	*(char)
+=	O
ndiff	int
;	O
SLtt_flush_output	()->(int)
(	O
)	O
;	O
n	int
-=	O
ndiff	int
;	O
str	*(char)
+=	O
ndiff	int
;	O
}	O
else	O
{	O
SLMEMCPY	O
(	O
(	O
char	O
*	O
)	O
Output_Bufferp	*(char)
,	O
str	*(char)
,	O
n	int
)	O
;	O
Output_Bufferp	*(char)
+=	O
n	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
(	O
SLtt_Baud_Rate	int
>	O
150	int
)	O
&&	O
(	O
SLtt_Baud_Rate	int
<=	O
9600	int
)	O
)	O
&&	O
(	O
10	int
*	O
total	int
>	O
SLtt_Baud_Rate	int
)	O
)	O
{	O
total	int
=	O
0	int
;	O
if	O
(	O
(	O
now	long
=	O
(	O
unsigned	O
long	O
)	O
time	struct(long,long)
(	O
NULL	O
)	O
)	O
-	O
last_time	long
<=	O
1	int
)	O
{	O
SLtt_flush_output	()->(int)
(	O
)	O
;	O
sleep	(int)->(int)
(	O
(	O
unsigned	O
)	O
1	int
)	O
;	O
}	O
last_time	long
=	O
now	long
;	O
}	O
}	O
static	O
void	O
tt_write_string	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
str	*(char)
!=	O
NULL	O
)	O
tt_write	(*(char),int)->(void)
(	O
str	*(char)
,	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
)	O
;	O
}	O
void	O
SLtt_write_string	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
str	*(char)
)	O
;	O
Cursor_Set	int
=	O
0	int
;	O
}	O
void	O
SLtt_putchar	(char)->(void)
(	O
char	O
ch	int
)	O
{	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
if	O
(	O
Cursor_Set	int
==	O
1	int
)	O
{	O
if	O
(	O
ch	int
>=	O
' '	O
)	O
Cursor_c	int
++	O
;	O
else	O
if	O
(	O
ch	int
==	O
'\b'	O
)	O
Cursor_c	int
--	O
;	O
else	O
if	O
(	O
ch	int
==	O
'\r'	O
)	O
Cursor_c	int
=	O
0	int
;	O
else	O
Cursor_Set	int
=	O
0	int
;	O
if	O
(	O
(	O
Cursor_c	int
+	O
1	int
==	O
SLtt_Screen_Cols	int
)	O
&&	O
Automatic_Margins	int
)	O
Cursor_Set	int
=	O
0	int
;	O
}	O
if	O
(	O
Output_Bufferp	*(char)
<	O
Output_Buffer	array(char)
+	O
MAX_OUTPUT_BUFFER_SIZE	int
)	O
{	O
*	O
Output_Bufferp	*(char)
++	O
=	O
(	O
unsigned	O
char	O
)	O
ch	int
;	O
}	O
else	O
tt_write	(*(char),int)->(void)
(	O
&	O
ch	int
,	O
1	int
)	O
;	O
}	O
static	O
unsigned	O
int	O
tt_sprintf	(*(char),int,*(char),int,int)->(int)
(	O
char	O
*	O
buf	*(char)
,	O
unsigned	O
int	O
buflen	int
,	O
char	O
*	O
fmt	*(char)
,	O
int	O
x	double
,	O
int	O
y	double
)	O
{	O
char	O
*	O
fmt_max	*(char)
;	O
unsigned	O
char	O
*	O
b	*(char)
,	O
*	O
bmax	*(char)
,	O
ch	int
;	O
int	O
offset	long
;	O
int	O
z	int
,	O
z1	int
,	O
parse_level	int
;	O
int	O
zero_pad	int
;	O
int	O
field_width	int
;	O
int	O
variables	array(int)
[	O
26	int
]	O
;	O
int	O
stack	array(int)
[	O
64	int
]	O
;	O
unsigned	O
int	O
stack_len	int
;	O
int	O
parms	array(int)
[	O
10	int
]	O
;	O
if	O
(	O
fmt	*(char)
==	O
NULL	O
)	O
{	O
*	O
buf	*(char)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
stack	array(int)
[	O
0	int
]	O
=	O
y	double
;	O
stack	array(int)
[	O
1	int
]	O
=	O
x	double
;	O
stack_len	int
=	O
2	int
;	O
parms	array(int)
[	O
1	int
]	O
=	O
x	double
;	O
parms	array(int)
[	O
2	int
]	O
=	O
y	double
;	O
offset	long
=	O
0	int
;	O
zero_pad	int
=	O
0	int
;	O
field_width	int
=	O
0	int
;	O
b	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
buf	*(char)
;	O
bmax	*(char)
=	O
b	*(char)
+	O
buflen	int
;	O
fmt_max	*(char)
=	O
fmt	*(char)
+	O
strlen	(*(char))->(long)
(	O
fmt	*(char)
)	O
;	O
while	O
(	O
(	O
fmt	*(char)
<	O
fmt_max	*(char)
)	O
&&	O
(	O
b	*(char)
<	O
bmax	*(char)
)	O
)	O
{	O
ch	int
=	O
*	O
fmt	*(char)
++	O
;	O
if	O
(	O
ch	int
!=	O
'%'	O
)	O
{	O
*	O
b	*(char)
++	O
=	O
ch	int
;	O
continue	O
;	O
}	O
if	O
(	O
fmt	*(char)
==	O
fmt_max	*(char)
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	*(char)
++	O
;	O
switch	O
(	O
ch	int
)	O
{	O
default	O
:	O
*	O
b	*(char)
++	O
=	O
ch	int
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
fmt	*(char)
==	O
fmt_max	*(char)
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	*(char)
++	O
;	O
if	O
(	O
(	O
ch	int
>=	O
'0'	O
)	O
&&	O
(	O
ch	int
<=	O
'9'	O
)	O
)	O
stack	array(int)
[	O
stack_len	int
++	O
]	O
=	O
parms	array(int)
[	O
ch	int
-	O
'0'	O
]	O
;	O
break	O
;	O
case	O
'\''	O
:	O
if	O
(	O
fmt	*(char)
==	O
fmt_max	*(char)
)	O
break	O
;	O
stack	array(int)
[	O
stack_len	int
++	O
]	O
=	O
*	O
fmt	*(char)
++	O
;	O
if	O
(	O
fmt	*(char)
<	O
fmt_max	*(char)
)	O
fmt	*(char)
++	O
;	O
break	O
;	O
case	O
'{'	O
:	O
z	int
=	O
0	int
;	O
while	O
(	O
(	O
fmt	*(char)
<	O
fmt_max	*(char)
)	O
&&	O
(	O
(	O
ch	int
=	O
*	O
fmt	*(char)
)	O
<=	O
'9'	O
)	O
&&	O
(	O
ch	int
>=	O
'0'	O
)	O
)	O
{	O
z	int
=	O
z	int
*	O
10	int
+	O
(	O
ch	int
-	O
'0'	O
)	O
;	O
fmt	*(char)
++	O
;	O
}	O
stack	array(int)
[	O
stack_len	int
++	O
]	O
=	O
z	int
;	O
if	O
(	O
(	O
ch	int
==	O
'}'	O
)	O
&&	O
(	O
fmt	*(char)
<	O
fmt_max	*(char)
)	O
)	O
fmt	*(char)
++	O
;	O
break	O
;	O
case	O
'0'	O
:	O
if	O
(	O
fmt	*(char)
==	O
fmt_max	*(char)
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	*(char)
;	O
if	O
(	O
(	O
ch	int
!=	O
'2'	O
)	O
&&	O
(	O
ch	int
!=	O
'3'	O
)	O
)	O
break	O
;	O
zero_pad	int
=	O
1	int
;	O
fmt	*(char)
++	O
;	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
if	O
(	O
fmt	*(char)
==	O
fmt_max	*(char)
)	O
break	O
;	O
if	O
(	O
*	O
fmt	*(char)
==	O
'x'	O
)	O
{	O
char	O
x_fmt_buf	array(char)
[	O
4	int
]	O
;	O
char	O
*	O
x_fmt_buf_ptr	*(char)
;	O
x_fmt_buf_ptr	*(char)
=	O
x_fmt_buf	array(char)
;	O
if	O
(	O
zero_pad	int
)	O
*	O
x_fmt_buf_ptr	*(char)
++	O
=	O
'0'	O
;	O
*	O
x_fmt_buf_ptr	*(char)
++	O
=	O
ch	int
;	O
*	O
x_fmt_buf_ptr	*(char)
++	O
=	O
'X'	O
;	O
*	O
x_fmt_buf_ptr	*(char)
=	O
0	int
;	O
z	int
=	O
STACK_POP	O
;	O
z	int
+=	O
offset	long
;	O
sprintf	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
b	*(char)
,	O
x_fmt_buf	array(char)
,	O
z	int
)	O
;	O
b	*(char)
+=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
b	*(char)
)	O
;	O
zero_pad	int
=	O
0	int
;	O
break	O
;	O
}	O
field_width	int
=	O
(	O
ch	int
-	O
'0'	O
)	O
;	O
case	O
'd'	O
:	O
z	int
=	O
STACK_POP	O
;	O
z	int
+=	O
offset	long
;	O
if	O
(	O
z	int
>=	O
100	int
)	O
{	O
*	O
b	*(char)
++	O
=	O
z	int
/	O
100	int
+	O
'0'	O
;	O
z	int
=	O
z	int
%	O
100	int
;	O
zero_pad	int
=	O
1	int
;	O
field_width	int
=	O
2	int
;	O
}	O
else	O
if	O
(	O
zero_pad	int
&&	O
(	O
field_width	int
==	O
3	int
)	O
)	O
*	O
b	*(char)
++	O
=	O
'0'	O
;	O
if	O
(	O
b	*(char)
==	O
bmax	*(char)
)	O
break	O
;	O
if	O
(	O
z	int
>=	O
10	int
)	O
{	O
*	O
b	*(char)
++	O
=	O
z	int
/	O
10	int
+	O
'0'	O
;	O
z	int
=	O
z	int
%	O
10	int
;	O
}	O
else	O
if	O
(	O
zero_pad	int
&&	O
(	O
field_width	int
>=	O
2	int
)	O
)	O
*	O
b	*(char)
++	O
=	O
'0'	O
;	O
if	O
(	O
b	*(char)
==	O
bmax	*(char)
)	O
break	O
;	O
*	O
b	*(char)
++	O
=	O
z	int
+	O
'0'	O
;	O
field_width	int
=	O
zero_pad	int
=	O
0	int
;	O
break	O
;	O
case	O
'x'	O
:	O
z	int
=	O
STACK_POP	O
;	O
z	int
+=	O
offset	long
;	O
if	O
(	O
b	*(char)
+	O
16	int
>=	O
bmax	*(char)
)	O
break	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
b	*(char)
,	O
"%X"	*(char)
,	O
z	int
)	O
;	O
b	*(char)
+=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
b	*(char)
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
offset	long
=	O
1	int
;	O
break	O
;	O
case	O
'+'	O
:	O
if	O
(	O
stack_len	int
>	O
2	int
)	O
{	O
z	int
=	O
STACK_POP	O
;	O
stack	array(int)
[	O
stack_len	int
-	O
1	int
]	O
+=	O
z	int
;	O
}	O
else	O
if	O
(	O
fmt	*(char)
<	O
fmt_max	*(char)
)	O
{	O
ch	int
=	O
*	O
fmt	*(char)
++	O
;	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
ch	int
==	O
128	int
)	O
ch	int
=	O
0	int
;	O
ch	int
=	O
ch	int
+	O
(	O
unsigned	O
char	O
)	O
STACK_POP	O
;	O
if	O
(	O
ch	int
==	O
'\n'	O
)	O
ch	int
++	O
;	O
*	O
b	*(char)
++	O
=	O
ch	int
;	O
}	O
break	O
;	O
case	O
'-'	O
:	O
case	O
'*'	O
:	O
case	O
'/'	O
:	O
case	O
'm'	O
:	O
case	O
'&'	O
:	O
case	O
'|'	O
:	O
case	O
'^'	O
:	O
case	O
'='	O
:	O
case	O
'>'	O
:	O
case	O
'<'	O
:	O
case	O
'A'	O
:	O
case	O
'O'	O
:	O
z1	int
=	O
STACK_POP	O
;	O
z	int
=	O
STACK_POP	O
;	O
switch	O
(	O
ch	int
)	O
{	O
case	O
'-'	O
:	O
z	int
=	O
(	O
z	int
-	O
z1	int
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
z	int
=	O
(	O
z	int
*	O
z1	int
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
z	int
=	O
(	O
z	int
/	O
z1	int
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
z	int
=	O
(	O
z	int
%	O
z1	int
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
z	int
=	O
(	O
z	int
&	O
z1	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
z	int
=	O
(	O
z	int
|	O
z1	int
)	O
;	O
break	O
;	O
case	O
'^'	O
:	O
z	int
=	O
(	O
z	int
^	O
z1	int
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
z	int
=	O
(	O
z	int
==	O
z1	int
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
z	int
=	O
(	O
z	int
>	O
z1	int
)	O
;	O
break	O
;	O
case	O
'<'	O
:	O
z	int
=	O
(	O
z	int
<	O
z1	int
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
z	int
=	O
(	O
z	int
&&	O
z1	int
)	O
;	O
break	O
;	O
case	O
'O'	O
:	O
z	int
=	O
(	O
z	int
||	O
z1	int
)	O
;	O
break	O
;	O
}	O
stack	array(int)
[	O
stack_len	int
++	O
]	O
=	O
z	int
;	O
break	O
;	O
case	O
'!'	O
:	O
z	int
=	O
STACK_POP	O
;	O
stack	array(int)
[	O
stack_len	int
++	O
]	O
=	O
!	O
z	int
;	O
break	O
;	O
case	O
'~'	O
:	O
z	int
=	O
STACK_POP	O
;	O
stack	array(int)
[	O
stack_len	int
++	O
]	O
=	O
~	O
z	int
;	O
break	O
;	O
case	O
'r'	O
:	O
z	int
=	O
stack	array(int)
[	O
0	int
]	O
;	O
stack	array(int)
[	O
0	int
]	O
=	O
stack	array(int)
[	O
1	int
]	O
;	O
stack	array(int)
[	O
1	int
]	O
=	O
z	int
;	O
break	O
;	O
case	O
'.'	O
:	O
case	O
'c'	O
:	O
ch	int
=	O
(	O
unsigned	O
char	O
)	O
STACK_POP	O
;	O
if	O
(	O
ch	int
==	O
'\n'	O
)	O
ch	int
++	O
;	O
*	O
b	*(char)
++	O
=	O
ch	int
;	O
break	O
;	O
case	O
'g'	O
:	O
if	O
(	O
fmt	*(char)
==	O
fmt_max	*(char)
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	*(char)
++	O
;	O
if	O
(	O
(	O
ch	int
>=	O
'a'	O
)	O
&&	O
(	O
ch	int
<=	O
'z'	O
)	O
)	O
stack	array(int)
[	O
stack_len	int
++	O
]	O
=	O
variables	array(int)
[	O
ch	int
-	O
'a'	O
]	O
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
fmt	*(char)
==	O
fmt_max	*(char)
)	O
break	O
;	O
ch	int
=	O
*	O
fmt	*(char)
++	O
;	O
if	O
(	O
(	O
ch	int
>=	O
'a'	O
)	O
&&	O
(	O
ch	int
<=	O
'z'	O
)	O
)	O
variables	array(int)
[	O
ch	int
-	O
'a'	O
]	O
=	O
STACK_POP	O
;	O
break	O
;	O
case	O
'?'	O
:	O
case	O
';'	O
:	O
break	O
;	O
case	O
't'	O
:	O
z	int
=	O
STACK_POP	O
;	O
if	O
(	O
z	int
!=	O
0	int
)	O
break	O
;	O
case	O
'e'	O
:	O
parse_level	int
=	O
0	int
;	O
while	O
(	O
fmt	*(char)
<	O
fmt_max	*(char)
)	O
{	O
unsigned	O
char	O
ch1	char
;	O
ch1	char
=	O
*	O
fmt	*(char)
++	O
;	O
if	O
(	O
(	O
ch1	char
!=	O
'%'	O
)	O
||	O
(	O
fmt	*(char)
==	O
fmt_max	*(char)
)	O
)	O
continue	O
;	O
ch1	char
=	O
*	O
fmt	*(char)
++	O
;	O
if	O
(	O
ch1	char
==	O
'?'	O
)	O
parse_level	int
++	O
;	O
else	O
if	O
(	O
ch1	char
==	O
'e'	O
)	O
{	O
if	O
(	O
(	O
ch	int
!=	O
'e'	O
)	O
&&	O
(	O
parse_level	int
==	O
0	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
ch1	char
==	O
';'	O
)	O
{	O
if	O
(	O
parse_level	int
==	O
0	int
)	O
break	O
;	O
parse_level	int
--	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
b	*(char)
>=	O
bmax	*(char)
)	O
b	*(char)
=	O
bmax	*(char)
-	O
1	int
;	O
*	O
b	*(char)
=	O
0	int
;	O
return	O
(	O
unsigned	O
int	O
)	O
(	O
b	*(char)
-	O
(	O
unsigned	O
char	O
*	O
)	O
buf	*(char)
)	O
;	O
}	O
static	O
void	O
tt_printf	(*(char),int,int)->(void)
(	O
char	O
*	O
fmt	*(char)
,	O
int	O
x	double
,	O
int	O
y	double
)	O
{	O
char	O
buf	*(char)
[	O
1024	int
]	O
;	O
unsigned	O
int	O
n	int
;	O
if	O
(	O
fmt	*(char)
==	O
NULL	O
)	O
return	O
;	O
n	int
=	O
tt_sprintf	(*(char),int,*(char),int,int)->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fmt	*(char)
,	O
x	double
,	O
y	double
)	O
;	O
tt_write	(*(char),int)->(void)
(	O
buf	*(char)
,	O
n	int
)	O
;	O
}	O
void	O
SLtt_set_scroll_region	(int,int)->(void)
(	O
int	O
r1	int
,	O
int	O
r2	int
)	O
{	O
Scroll_r1	int
=	O
r1	int
;	O
Scroll_r2	int
=	O
r2	int
;	O
tt_printf	(*(char),int,int)->(void)
(	O
Scroll_R_Str	*(char)
,	O
Scroll_r1	int
,	O
Scroll_r2	int
)	O
;	O
Cursor_Set	int
=	O
0	int
;	O
}	O
void	O
SLtt_reset_scroll_region	()->(void)
(	O
void	O
)	O
{	O
SLtt_set_scroll_region	(int,int)->(void)
(	O
0	int
,	O
SLtt_Screen_Rows	int
-	O
1	int
)	O
;	O
}	O
int	O
SLtt_set_cursor_visibility	(int)->(int)
(	O
int	O
show	int
)	O
{	O
if	O
(	O
(	O
Cursor_Visible_Str	*(char)
==	O
NULL	O
)	O
||	O
(	O
Cursor_Invisible_Str	*(char)
==	O
NULL	O
)	O
)	O
return	O
-	O
1	int
;	O
tt_write_string	(*(char))->(void)
(	O
show	int
?	O
Cursor_Visible_Str	*(char)
:	O
Cursor_Invisible_Str	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_goto_rc	(int,int)->(void)
(	O
int	O
r	*(struct)
,	O
int	O
c	int
)	O
{	O
char	O
*	O
s	*(char)
=	O
NULL	O
;	O
int	O
n	int
;	O
char	O
buf	*(char)
[	O
6	int
]	O
;	O
if	O
(	O
(	O
c	int
<	O
0	int
)	O
||	O
(	O
r	*(struct)
<	O
0	int
)	O
)	O
{	O
Cursor_Set	int
=	O
0	int
;	O
return	O
;	O
}	O
r	*(struct)
+=	O
Scroll_r1	int
;	O
if	O
(	O
(	O
Cursor_Set	int
>	O
0	int
)	O
||	O
(	O
(	O
Cursor_Set	int
<	O
0	int
)	O
&&	O
!	O
Automatic_Margins	int
)	O
)	O
{	O
n	int
=	O
r	*(struct)
-	O
Cursor_r	int
;	O
if	O
(	O
(	O
n	int
==	O
-	O
1	int
)	O
&&	O
(	O
Cursor_Set	int
>	O
0	int
)	O
&&	O
(	O
Cursor_c	int
==	O
c	int
)	O
&&	O
(	O
Curs_Up_Str	*(char)
!=	O
NULL	O
)	O
)	O
{	O
s	*(char)
=	O
Curs_Up_Str	*(char)
;	O
}	O
else	O
if	O
(	O
(	O
n	int
>=	O
0	int
)	O
&&	O
(	O
n	int
<=	O
4	int
)	O
)	O
{	O
if	O
(	O
(	O
n	int
==	O
0	int
)	O
&&	O
(	O
Cursor_Set	int
==	O
1	int
)	O
&&	O
(	O
(	O
c	int
>	O
1	int
)	O
||	O
(	O
c	int
==	O
Cursor_c	int
)	O
)	O
)	O
{	O
if	O
(	O
Cursor_c	int
==	O
c	int
)	O
return	O
;	O
if	O
(	O
Cursor_c	int
==	O
c	int
+	O
1	int
)	O
{	O
if	O
(	O
!	O
QANSI_Console	int
)	O
{	O
s	*(char)
=	O
buf	*(char)
;	O
*	O
s	*(char)
++	O
=	O
'\b'	O
;	O
*	O
s	*(char)
=	O
0	int
;	O
s	*(char)
=	O
buf	*(char)
;	O
}	O
else	O
{	O
s	*(char)
=	O
NULL	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
0	int
)	O
&&	O
(	O
!	O
QANSI_Console	int
)	O
)	O
{	O
s	*(char)
=	O
buf	*(char)
;	O
if	O
(	O
(	O
Cursor_Set	int
!=	O
1	int
)	O
||	O
(	O
Cursor_c	int
!=	O
0	int
)	O
)	O
*	O
s	*(char)
++	O
=	O
'\r'	O
;	O
while	O
(	O
n	int
--	O
)	O
*	O
s	*(char)
++	O
=	O
'\n'	O
;	O
*	O
s	*(char)
=	O
0	int
;	O
s	*(char)
=	O
buf	*(char)
;	O
}	O
else	O
if	O
(	O
(	O
SLtt_Newline_Ok	int
&&	O
(	O
Cursor_Set	int
==	O
1	int
)	O
&&	O
(	O
Cursor_c	int
>=	O
c	int
)	O
&&	O
(	O
c	int
+	O
3	int
>	O
Cursor_c	int
)	O
)	O
&&	O
(	O
!	O
QANSI_Console	int
)	O
)	O
{	O
s	*(char)
=	O
buf	*(char)
;	O
while	O
(	O
n	int
--	O
)	O
*	O
s	*(char)
++	O
=	O
'\n'	O
;	O
n	int
=	O
Cursor_c	int
-	O
c	int
;	O
while	O
(	O
n	int
--	O
)	O
*	O
s	*(char)
++	O
=	O
'\b'	O
;	O
*	O
s	*(char)
=	O
0	int
;	O
s	*(char)
=	O
buf	*(char)
;	O
}	O
}	O
}	O
if	O
(	O
s	*(char)
!=	O
NULL	O
)	O
tt_write_string	(*(char))->(void)
(	O
s	*(char)
)	O
;	O
else	O
tt_printf	(*(char),int,int)->(void)
(	O
Curs_Pos_Str	*(char)
,	O
r	*(struct)
,	O
c	int
)	O
;	O
Cursor_c	int
=	O
c	int
;	O
Cursor_r	int
=	O
r	*(struct)
;	O
Cursor_Set	int
=	O
1	int
;	O
}	O
void	O
SLtt_begin_insert	()->(void)
(	O
void	O
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
Ins_Mode_Str	*(char)
)	O
;	O
}	O
void	O
SLtt_end_insert	()->(void)
(	O
void	O
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
Eins_Mode_Str	*(char)
)	O
;	O
}	O
void	O
SLtt_delete_char	()->(void)
(	O
void	O
)	O
{	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Del_Char_Str	*(char)
)	O
;	O
}	O
void	O
SLtt_erase_line	()->(void)
(	O
void	O
)	O
{	O
tt_write	(*(char),int)->(void)
(	O
"\r"	*(char)
,	O
1	int
)	O
;	O
Cursor_Set	int
=	O
1	int
;	O
Cursor_c	int
=	O
0	int
;	O
SLtt_del_eol	()->(void)
(	O
)	O
;	O
tt_write	(*(char),int)->(void)
(	O
"\r"	*(char)
,	O
1	int
)	O
;	O
Cursor_Set	int
=	O
1	int
;	O
Cursor_c	int
=	O
0	int
;	O
}	O
static	O
void	O
delete_line_in_scroll_region	()->(void)
(	O
void	O
)	O
{	O
SLtt_goto_rc	(int,int)->(void)
(	O
Cursor_r	int
-	O
Scroll_r1	int
,	O
0	int
)	O
;	O
SLtt_del_eol	()->(void)
(	O
)	O
;	O
}	O
void	O
SLtt_delete_nlines	(int)->(void)
(	O
int	O
nn	int
)	O
{	O
int	O
r1	int
,	O
curs	int
;	O
unsigned	O
int	O
n	int
;	O
if	O
(	O
nn	int
<=	O
0	int
)	O
return	O
;	O
n	int
=	O
(	O
unsigned	O
int	O
)	O
nn	int
;	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
if	O
(	O
Scroll_r1	int
==	O
Scroll_r2	int
)	O
{	O
delete_line_in_scroll_region	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
Del_N_Lines_Str	*(char)
!=	O
NULL	O
)	O
tt_printf	(*(char),int,int)->(void)
(	O
Del_N_Lines_Str	*(char)
,	O
n	int
,	O
0	int
)	O
;	O
else	O
{	O
char	O
buf	*(char)
[	O
80	int
]	O
;	O
unsigned	O
int	O
dn	int
=	O
n	int
;	O
if	O
(	O
dn	int
>	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
dn	int
=	O
sizeof	O
(	O
buf	*(char)
)	O
;	O
SLMEMSET	O
(	O
buf	*(char)
,	O
'\n'	O
,	O
dn	int
)	O
;	O
while	O
(	O
n	int
>	O
dn	int
)	O
{	O
tt_write	(*(char),int)->(void)
(	O
buf	*(char)
,	O
dn	int
)	O
;	O
n	int
-=	O
dn	int
;	O
}	O
tt_write	(*(char),int)->(void)
(	O
buf	*(char)
,	O
n	int
)	O
;	O
r1	int
=	O
Scroll_r1	int
;	O
curs	int
=	O
Cursor_r	int
;	O
SLtt_set_scroll_region	(int,int)->(void)
(	O
curs	int
,	O
Scroll_r2	int
)	O
;	O
SLtt_goto_rc	(int,int)->(void)
(	O
Scroll_r2	int
-	O
Scroll_r1	int
,	O
0	int
)	O
;	O
SLMEMSET	O
(	O
buf	*(char)
,	O
'\n'	O
,	O
(	O
unsigned	O
int	O
)	O
n	int
)	O
;	O
tt_write	(*(char),int)->(void)
(	O
buf	*(char)
,	O
(	O
unsigned	O
int	O
)	O
n	int
)	O
;	O
SLtt_set_scroll_region	(int,int)->(void)
(	O
r1	int
,	O
Scroll_r2	int
)	O
;	O
SLtt_goto_rc	(int,int)->(void)
(	O
curs	int
,	O
0	int
)	O
;	O
}	O
}	O
void	O
SLtt_cls	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
(	O
SLtt_Use_Ansi_Colors	int
==	O
0	int
)	O
&&	O
Is_Color_Terminal	int
)	O
{	O
if	O
(	O
Reset_Color_String	*(char)
!=	O
NULL	O
)	O
tt_write_string	(*(char))->(void)
(	O
Reset_Color_String	*(char)
)	O
;	O
else	O
tt_write	(*(char),int)->(void)
(	O
"\033[0m\033[m"	*(char)
,	O
7	int
)	O
;	O
}	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
SLtt_reset_scroll_region	()->(void)
(	O
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Cls_Str	*(char)
)	O
;	O
}	O
void	O
SLtt_reverse_index	(int)->(void)
(	O
int	O
n	int
)	O
{	O
if	O
(	O
!	O
n	int
)	O
return	O
;	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
if	O
(	O
Scroll_r1	int
==	O
Scroll_r2	int
)	O
{	O
delete_line_in_scroll_region	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
Add_N_Lines_Str	*(char)
!=	O
NULL	O
)	O
tt_printf	(*(char),int,int)->(void)
(	O
Add_N_Lines_Str	*(char)
,	O
n	int
,	O
0	int
)	O
;	O
else	O
{	O
while	O
(	O
n	int
--	O
)	O
tt_write_string	(*(char))->(void)
(	O
Rev_Scroll_Str	*(char)
)	O
;	O
}	O
}	O
int	O
SLtt_Ignore_Beep	int
=	O
1	int
;	O
static	O
char	O
*	O
Visible_Bell_Str	*(char)
;	O
void	O
SLtt_beep	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
SLtt_Ignore_Beep	int
&	O
0x1	int
)	O
SLtt_putchar	(char)->(void)
(	O
'\007'	O
)	O
;	O
if	O
(	O
SLtt_Ignore_Beep	int
&	O
0x2	int
)	O
{	O
if	O
(	O
Visible_Bell_Str	*(char)
!=	O
NULL	O
)	O
tt_write_string	(*(char))->(void)
(	O
Visible_Bell_Str	*(char)
)	O
;	O
else	O
if	O
(	O
Linux_Console	int
)	O
{	O
tt_write	(*(char),int)->(void)
(	O
"\033[?5h"	*(char)
,	O
5	int
)	O
;	O
SLtt_flush_output	()->(int)
(	O
)	O
;	O
_pSLusleep	(long)->(int)
(	O
50000	int
)	O
;	O
tt_write	(*(char),int)->(void)
(	O
"\033[?5l"	*(char)
,	O
5	int
)	O
;	O
}	O
}	O
SLtt_flush_output	()->(int)
(	O
)	O
;	O
}	O
static	O
void	O
write_string_with_care	(*(char))->(void)
(	O
char	O
*	O
)	O
;	O
static	O
void	O
del_eol	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
(	O
Del_Eol_Str	*(char)
!=	O
NULL	O
)	O
&&	O
(	O
Can_Background_Color_Erase	int
||	O
(	O
(	O
Current_Fgbg	long
&	O
~	O
0xFF	int
)	O
==	O
0	int
)	O
)	O
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
Del_Eol_Str	*(char)
)	O
;	O
return	O
;	O
}	O
while	O
(	O
Cursor_c	int
<	O
SLtt_Screen_Cols	int
)	O
{	O
write_string_with_care	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
Cursor_c	int
++	O
;	O
}	O
Cursor_c	int
=	O
SLtt_Screen_Cols	int
-	O
1	int
;	O
Cursor_Set	int
=	O
0	int
;	O
}	O
void	O
SLtt_del_eol	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
Current_Fgbg	long
!=	O
0xFFFFFFFFU	int
)	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
del_eol	()->(void)
(	O
)	O
;	O
}	O
typedef	O
SLCONST	O
struct	O
{	O
char	O
*	O
name	*(char)
;	O
SLtt_Char_Type	long
color	short
;	O
}	O
Color_Def_Type	struct(*(char),long)
;	O
static	O
Color_Def_Type	struct(*(char),long)
Color_Defs	array(struct(*(char),long))
[	O
MAX_COLOR_NAMES	int
]	O
=	O
{	O
{	O
"black"	*(char)
,	O
SLSMG_COLOR_BLACK	int
}	O
,	O
{	O
"red"	*(char)
,	O
SLSMG_COLOR_RED	int
}	O
,	O
{	O
"green"	*(char)
,	O
SLSMG_COLOR_GREEN	int
}	O
,	O
{	O
"brown"	*(char)
,	O
SLSMG_COLOR_BROWN	int
}	O
,	O
{	O
"blue"	*(char)
,	O
SLSMG_COLOR_BLUE	int
}	O
,	O
{	O
"magenta"	*(char)
,	O
SLSMG_COLOR_MAGENTA	int
}	O
,	O
{	O
"cyan"	*(char)
,	O
SLSMG_COLOR_CYAN	int
}	O
,	O
{	O
"lightgray"	*(char)
,	O
SLSMG_COLOR_LGRAY	int
}	O
,	O
{	O
"gray"	*(char)
,	O
SLSMG_COLOR_GRAY	int
}	O
,	O
{	O
"brightred"	*(char)
,	O
SLSMG_COLOR_BRIGHT_RED	int
}	O
,	O
{	O
"brightgreen"	*(char)
,	O
SLSMG_COLOR_BRIGHT_GREEN	int
}	O
,	O
{	O
"yellow"	*(char)
,	O
SLSMG_COLOR_BRIGHT_BROWN	int
}	O
,	O
{	O
"brightblue"	*(char)
,	O
SLSMG_COLOR_BRIGHT_BLUE	int
}	O
,	O
{	O
"brightmagenta"	*(char)
,	O
SLSMG_COLOR_BRIGHT_CYAN	int
}	O
,	O
{	O
"brightcyan"	*(char)
,	O
SLSMG_COLOR_BRIGHT_MAGENTA	int
}	O
,	O
{	O
"white"	*(char)
,	O
SLSMG_COLOR_BRIGHT_WHITE	int
}	O
,	O
{	O
"default"	*(char)
,	O
SLSMG_COLOR_DEFAULT	int
}	O
}	O
;	O
static	O
int	O
Brushes_Initialized	int
=	O
0	int
;	O
static	O
int	O
initialize_brushes	()->(int)
(	O
void	O
)	O
{	O
int	O
fg	int
,	O
bg	int
;	O
Brush_Info_Type	struct(long,long)
*	O
b	*(char)
,	O
*	O
bmax	*(char)
;	O
b	*(char)
=	O
Brush_Table	array(struct(long,long))
;	O
bmax	*(char)
=	O
b	*(char)
+	O
JMAX_COLORS	int
;	O
bg	int
=	O
0	int
;	O
while	O
(	O
b	*(char)
<	O
bmax	*(char)
)	O
{	O
fg	int
=	O
7	int
;	O
while	O
(	O
b	*(char)
<	O
bmax	*(char)
)	O
{	O
if	O
(	O
fg	int
!=	O
bg	int
)	O
{	O
b	*(char)
->	O
fgbg	long
=	O
MAKE_COLOR	O
(	O
fg	int
,	O
bg	int
)	O
;	O
b	*(char)
->	O
mono	long
=	O
SLTT_REV_MASK	int
;	O
b	*(char)
++	O
;	O
}	O
if	O
(	O
fg	int
==	O
0	int
)	O
break	O
;	O
fg	int
--	O
;	O
}	O
bg	int
++	O
;	O
if	O
(	O
bg	int
==	O
8	int
)	O
bg	int
=	O
0	int
;	O
}	O
Brush_Table	array(struct(long,long))
[	O
0	int
]	O
.	O
mono	long
=	O
0	int
;	O
Brushes_Initialized	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
Brush_Info_Type	struct(long,long)
*	O
get_brush_info	(int)->(*(struct(long,long)))
(	O
unsigned	O
int	O
color	short
)	O
{	O
if	O
(	O
Brushes_Initialized	int
==	O
0	int
)	O
initialize_brushes	()->(int)
(	O
)	O
;	O
color	short
&=	O
SLSMG_COLOR_MASK	int
;	O
if	O
(	O
color	short
>=	O
JMAX_COLORS	int
)	O
color	short
=	O
0	int
;	O
return	O
Brush_Table	array(struct(long,long))
+	O
color	short
;	O
}	O
static	O
SLtt_Char_Type	long
get_brush_attr	(int)->(long)
(	O
unsigned	O
int	O
color	short
)	O
{	O
Brush_Info_Type	struct(long,long)
*	O
b	*(char)
;	O
if	O
(	O
NULL	O
==	O
(	O
b	*(char)
=	O
get_brush_info	(int)->(*(struct(long,long)))
(	O
color	short
)	O
)	O
)	O
return	O
(	O
SLtt_Char_Type	long
)	O
-	O
1	int
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
return	O
b	*(char)
->	O
fgbg	long
;	O
return	O
b	*(char)
->	O
mono	long
;	O
}	O
static	O
SLtt_Char_Type	long
get_brush_fgbg	(int)->(long)
(	O
unsigned	O
int	O
color	short
)	O
{	O
return	O
get_brush_info	(int)->(*(struct(long,long)))
(	O
color	short
)	O
->	O
fgbg	long
;	O
}	O
int	O
SLtt_set_mono	(int,*(char),long)->(int)
(	O
int	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
,	O
char	O
*	O
what	*(char)
,	O
SLtt_Char_Type	long
mask	long
)	O
{	O
Brush_Info_Type	struct(long,long)
*	O
b	*(char)
;	O
(	O
void	O
)	O
what	*(char)
;	O
if	O
(	O
NULL	O
==	O
(	O
b	*(char)
=	O
get_brush_info	(int)->(*(struct(long,long)))
(	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
)	O
)	O
)	O
return	O
-	O
1	int
;	O
b	*(char)
->	O
mono	long
=	O
mask	long
&	O
ATTR_MASK	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
check_color_for_digit_form	(*(char))->(*(char))
(	O
char	O
*	O
color	short
)	O
{	O
unsigned	O
int	O
i	array(int)
,	O
ich	int
;	O
unsigned	O
char	O
*	O
s	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
color	short
;	O
i	array(int)
=	O
0	int
;	O
while	O
(	O
(	O
ich	int
=	O
(	O
unsigned	O
int	O
)	O
*	O
s	*(char)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
ich	int
<	O
'0'	O
)	O
||	O
(	O
ich	int
>	O
'9'	O
)	O
)	O
return	O
color	short
;	O
i	array(int)
=	O
i	array(int)
*	O
10	int
+	O
(	O
ich	int
-	O
'0'	O
)	O
;	O
s	*(char)
++	O
;	O
}	O
if	O
(	O
i	array(int)
<	O
MAX_COLOR_NAMES	int
)	O
color	short
=	O
Color_Defs	array(struct(*(char),long))
[	O
i	array(int)
]	O
.	O
name	*(char)
;	O
return	O
color	short
;	O
}	O
static	O
int	O
get_default_colors	(*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
*	O
fgp	*(*(char))
,	O
char	O
*	O
*	O
bgp	*(*(char))
)	O
{	O
static	O
char	O
fg_buf	array(char)
[	O
16	int
]	O
,	O
bg_buf	array(char)
[	O
16	int
]	O
,	O
*	O
bg	int
,	O
*	O
fg	int
;	O
static	O
int	O
already_parsed	int
;	O
char	O
*	O
p	*(char)
,	O
*	O
pmax	*(char)
;	O
if	O
(	O
already_parsed	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
already_parsed	int
)	O
{	O
*	O
fgp	*(*(char))
=	O
fg	int
;	O
*	O
bgp	*(*(char))
=	O
bg	int
;	O
return	O
0	int
;	O
}	O
already_parsed	int
=	O
-	O
1	int
;	O
bg	int
=	O
getenv	(*(char))->(*(char))
(	O
"COLORFGBG"	*(char)
)	O
;	O
if	O
(	O
bg	int
==	O
NULL	O
)	O
{	O
bg	int
=	O
getenv	(*(char))->(*(char))
(	O
"DEFAULT_COLORS"	*(char)
)	O
;	O
if	O
(	O
bg	int
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
}	O
p	*(char)
=	O
fg_buf	array(char)
;	O
pmax	*(char)
=	O
p	*(char)
+	O
(	O
sizeof	O
(	O
fg_buf	array(char)
)	O
-	O
1	int
)	O
;	O
while	O
(	O
(	O
*	O
bg	int
!=	O
0	int
)	O
&&	O
(	O
*	O
bg	int
!=	O
';'	O
)	O
)	O
{	O
if	O
(	O
p	*(char)
<	O
pmax	*(char)
)	O
*	O
p	*(char)
++	O
=	O
*	O
bg	int
;	O
bg	int
++	O
;	O
}	O
*	O
p	*(char)
=	O
0	int
;	O
if	O
(	O
*	O
bg	int
)	O
bg	int
++	O
;	O
p	*(char)
=	O
bg_buf	array(char)
;	O
pmax	*(char)
=	O
p	*(char)
+	O
(	O
sizeof	O
(	O
bg_buf	array(char)
)	O
-	O
1	int
)	O
;	O
while	O
(	O
(	O
*	O
bg	int
!=	O
0	int
)	O
&&	O
(	O
*	O
bg	int
!=	O
';'	O
)	O
)	O
{	O
if	O
(	O
p	*(char)
<	O
pmax	*(char)
)	O
*	O
p	*(char)
++	O
=	O
*	O
bg	int
;	O
bg	int
++	O
;	O
}	O
*	O
p	*(char)
=	O
0	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
fg_buf	array(char)
,	O
"default"	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
bg_buf	array(char)
,	O
"default"	*(char)
)	O
)	O
{	O
*	O
fgp	*(*(char))
=	O
*	O
bgp	*(*(char))
=	O
fg	int
=	O
bg	int
=	O
"default"	*(char)
;	O
}	O
else	O
{	O
*	O
fgp	*(*(char))
=	O
fg	int
=	O
check_color_for_digit_form	(*(char))->(*(char))
(	O
fg_buf	array(char)
)	O
;	O
*	O
bgp	*(*(char))
=	O
bg	int
=	O
check_color_for_digit_form	(*(char))->(*(char))
(	O
bg_buf	array(char)
)	O
;	O
}	O
already_parsed	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
Color_0_Modified	int
=	O
0	int
;	O
int	O
SLtt_set_color_object	(int,long)->(int)
(	O
int	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
,	O
SLtt_Char_Type	long
attr	long
)	O
{	O
Brush_Info_Type	struct(long,long)
*	O
b	*(char)
;	O
if	O
(	O
NULL	O
==	O
(	O
b	*(char)
=	O
get_brush_info	(int)->(*(struct(long,long)))
(	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
)	O
)	O
)	O
return	O
-	O
1	int
;	O
b	*(char)
->	O
fgbg	long
=	O
attr	long
;	O
if	O
(	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
==	O
0	int
)	O
Color_0_Modified	int
=	O
1	int
;	O
if	O
(	O
_pSLtt_color_changed_hook	*(()->(void))
!=	O
NULL	O
)	O
(	O
*	O
_pSLtt_color_changed_hook	*(()->(void))
)	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
SLtt_Char_Type	long
SLtt_get_color_object	(int)->(long)
(	O
int	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
)	O
{	O
return	O
get_brush_fgbg	(int)->(long)
(	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
)	O
;	O
}	O
int	O
SLtt_add_color_attribute	(int,long)->(int)
(	O
int	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
,	O
SLtt_Char_Type	long
attr	long
)	O
{	O
Brush_Info_Type	struct(long,long)
*	O
b	*(char)
;	O
if	O
(	O
NULL	O
==	O
(	O
b	*(char)
=	O
get_brush_info	(int)->(*(struct(long,long)))
(	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
)	O
)	O
)	O
return	O
-	O
1	int
;	O
b	*(char)
->	O
fgbg	long
|=	O
(	O
attr	long
&	O
ATTR_MASK	int
)	O
;	O
if	O
(	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
==	O
0	int
)	O
Color_0_Modified	int
=	O
1	int
;	O
if	O
(	O
_pSLtt_color_changed_hook	*(()->(void))
!=	O
NULL	O
)	O
(	O
*	O
_pSLtt_color_changed_hook	*(()->(void))
)	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
SLtt_Char_Type	long
fb_to_fgbg	(long,long)->(long)
(	O
SLtt_Char_Type	long
f	float
,	O
SLtt_Char_Type	long
b	*(char)
)	O
{	O
SLtt_Char_Type	long
attr	long
;	O
if	O
(	O
Max_Terminfo_Colors	int
!=	O
8	int
)	O
{	O
if	O
(	O
f	float
!=	O
SLSMG_COLOR_DEFAULT	int
)	O
f	float
%=	O
Max_Terminfo_Colors	int
;	O
if	O
(	O
b	*(char)
!=	O
SLSMG_COLOR_DEFAULT	int
)	O
b	*(char)
%=	O
Max_Terminfo_Colors	int
;	O
return	O
(	O
(	O
f	float
<<	O
8	int
)	O
|	O
(	O
b	*(char)
<<	O
16	int
)	O
)	O
;	O
}	O
attr	long
=	O
0	int
;	O
if	O
(	O
f	float
!=	O
SLSMG_COLOR_DEFAULT	int
)	O
{	O
if	O
(	O
f	float
&	O
0x8	int
)	O
attr	long
=	O
SLTT_BOLD_MASK	int
;	O
f	float
&=	O
0x7	int
;	O
}	O
if	O
(	O
b	*(char)
!=	O
SLSMG_COLOR_DEFAULT	int
)	O
{	O
if	O
(	O
b	*(char)
&	O
0x8	int
)	O
attr	long
|=	O
SLTT_BLINK_MASK	int
;	O
b	*(char)
&=	O
0x7	int
;	O
}	O
return	O
(	O
(	O
f	float
<<	O
8	int
)	O
|	O
(	O
b	*(char)
<<	O
16	int
)	O
|	O
attr	long
)	O
;	O
}	O
static	O
int	O
parse_color_digit_name	(*(char),*(long))->(int)
(	O
char	O
*	O
color	short
,	O
SLtt_Char_Type	long
*	O
f	float
)	O
{	O
unsigned	O
int	O
i	array(int)
;	O
unsigned	O
char	O
ch	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
color	short
,	O
"color"	*(char)
,	O
5	int
)	O
)	O
return	O
-	O
1	int
;	O
color	short
+=	O
5	int
;	O
if	O
(	O
*	O
color	short
==	O
0	int
)	O
return	O
-	O
1	int
;	O
i	array(int)
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
j	int
;	O
ch	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
color	short
++	O
;	O
if	O
(	O
ch	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
ch	int
>	O
'9'	O
)	O
||	O
(	O
ch	int
<	O
'0'	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
i	array(int)
>	O
0xFFFFFFFFU	int
/	O
10	int
)	O
return	O
-	O
1	int
;	O
j	int
=	O
(	O
i	array(int)
*=	O
10	int
)	O
;	O
i	array(int)
+=	O
(	O
ch	int
-	O
'0'	O
)	O
;	O
if	O
(	O
i	array(int)
<	O
j	int
)	O
return	O
-	O
1	int
;	O
}	O
*	O
f	float
=	O
(	O
SLtt_Char_Type	long
)	O
i	array(int)
;	O
return	O
0	int
;	O
}	O
static	O
int	O
make_color_fgbg	(*(char),*(char),*(long))->(int)
(	O
char	O
*	O
fg	int
,	O
char	O
*	O
bg	int
,	O
SLtt_Char_Type	long
*	O
fgbg	long
)	O
{	O
SLtt_Char_Type	long
f	float
=	O
0xFFFFFFFFU	int
,	O
b	*(char)
=	O
0xFFFFFFFFU	int
;	O
char	O
*	O
dfg	*(char)
,	O
*	O
dbg	*(char)
;	O
unsigned	O
int	O
i	array(int)
;	O
if	O
(	O
(	O
fg	int
!=	O
NULL	O
)	O
&&	O
(	O
*	O
fg	int
==	O
0	int
)	O
)	O
fg	int
=	O
NULL	O
;	O
if	O
(	O
(	O
bg	int
!=	O
NULL	O
)	O
&&	O
(	O
*	O
bg	int
==	O
0	int
)	O
)	O
bg	int
=	O
NULL	O
;	O
if	O
(	O
(	O
fg	int
==	O
NULL	O
)	O
||	O
(	O
bg	int
==	O
NULL	O
)	O
)	O
{	O
if	O
(	O
-	O
1	int
==	O
get_default_colors	(*(*(char)),*(*(char)))->(int)
(	O
&	O
dfg	*(char)
,	O
&	O
dbg	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fg	int
==	O
NULL	O
)	O
fg	int
=	O
dfg	*(char)
;	O
if	O
(	O
bg	int
==	O
NULL	O
)	O
bg	int
=	O
dbg	*(char)
;	O
}	O
if	O
(	O
-	O
1	int
==	O
parse_color_digit_name	(*(char),*(long))->(int)
(	O
fg	int
,	O
&	O
f	float
)	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
MAX_COLOR_NAMES	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
fg	int
,	O
Color_Defs	array(struct(*(char),long))
[	O
i	array(int)
]	O
.	O
name	*(char)
)	O
)	O
continue	O
;	O
f	float
=	O
Color_Defs	array(struct(*(char),long))
[	O
i	array(int)
]	O
.	O
color	short
;	O
break	O
;	O
}	O
}	O
if	O
(	O
-	O
1	int
==	O
parse_color_digit_name	(*(char),*(long))->(int)
(	O
bg	int
,	O
&	O
b	*(char)
)	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
MAX_COLOR_NAMES	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
bg	int
,	O
Color_Defs	array(struct(*(char),long))
[	O
i	array(int)
]	O
.	O
name	*(char)
)	O
)	O
continue	O
;	O
b	*(char)
=	O
Color_Defs	array(struct(*(char),long))
[	O
i	array(int)
]	O
.	O
color	short
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
f	float
==	O
0xFFFFFFFFU	int
)	O
||	O
(	O
b	*(char)
==	O
0xFFFFFFFFU	int
)	O
)	O
return	O
-	O
1	int
;	O
*	O
fgbg	long
=	O
fb_to_fgbg	(long,long)->(long)
(	O
f	float
,	O
b	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
SLtt_set_color	(int,*(char),*(char),*(char))->(int)
(	O
int	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
,	O
char	O
*	O
what	*(char)
,	O
char	O
*	O
fg	int
,	O
char	O
*	O
bg	int
)	O
{	O
SLtt_Char_Type	long
fgbg	long
;	O
(	O
void	O
)	O
what	*(char)
;	O
if	O
(	O
-	O
1	int
==	O
make_color_fgbg	(*(char),*(char),*(long))->(int)
(	O
fg	int
,	O
bg	int
,	O
&	O
fgbg	long
)	O
)	O
return	O
-	O
1	int
;	O
return	O
SLtt_set_color_object	(int,long)->(int)
(	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
,	O
fgbg	long
)	O
;	O
}	O
int	O
SLtt_set_color_fgbg	(int,long,long)->(int)
(	O
int	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
,	O
SLtt_Char_Type	long
f	float
,	O
SLtt_Char_Type	long
b	*(char)
)	O
{	O
return	O
SLtt_set_color_object	(int,long)->(int)
(	O
obj	struct(int,union(double,float,long long,long long,long,long,*(void),*(char),int,int,*(struct(int,*(void),int)),*(struct(*(char),*(struct`),char)),*(struct),*(struct(int,int,*(void),int,int,array(int),*((*`,*`)->(*`)),int,*(struct`),int,*((*`)->(void)),*(void))),short,short,char,char,int))
,	O
fb_to_fgbg	(long,long)->(long)
(	O
f	float
,	O
b	*(char)
)	O
)	O
;	O
}	O
void	O
SLtt_set_alt_char_set	(int)->(void)
(	O
int	O
i	array(int)
)	O
{	O
static	O
int	O
last_i	int
;	O
if	O
(	O
SLtt_Has_Alt_Charset	int
==	O
0	int
)	O
return	O
;	O
i	array(int)
=	O
(	O
i	array(int)
!=	O
0	int
)	O
;	O
if	O
(	O
i	array(int)
==	O
last_i	int
)	O
return	O
;	O
tt_write_string	(*(char))->(void)
(	O
i	array(int)
?	O
Start_Alt_Chars_Str	*(char)
:	O
End_Alt_Chars_Str	*(char)
)	O
;	O
last_i	int
=	O
i	array(int)
;	O
}	O
static	O
void	O
write_attributes	(long)->(void)
(	O
SLtt_Char_Type	long
fgbg	long
)	O
{	O
int	O
bg0	int
,	O
fg0	int
;	O
int	O
unknown_attributes	int
;	O
if	O
(	O
Worthless_Highlight	int
)	O
return	O
;	O
if	O
(	O
fgbg	long
==	O
Current_Fgbg	long
)	O
return	O
;	O
unknown_attributes	int
=	O
0	int
;	O
if	O
(	O
(	O
fgbg	long
&	O
ATTR_MASK	int
)	O
!=	O
(	O
Current_Fgbg	long
&	O
ATTR_MASK	int
)	O
)	O
{	O
if	O
(	O
Current_Fgbg	long
&	O
ATTR_MASK	int
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
Norm_Vid_Str	*(char)
)	O
;	O
if	O
(	O
fgbg	long
&	O
SLTT_ALTC_MASK	int
)	O
Current_Fgbg	long
&=	O
~	O
SLTT_ALTC_MASK	int
;	O
SLtt_set_alt_char_set	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
fgbg	long
&	O
SLTT_ALTC_MASK	int
)	O
!=	O
(	O
Current_Fgbg	long
&	O
SLTT_ALTC_MASK	int
)	O
)	O
{	O
SLtt_set_alt_char_set	(int)->(void)
(	O
(	O
int	O
)	O
(	O
fgbg	long
&	O
SLTT_ALTC_MASK	int
)	O
)	O
;	O
}	O
if	O
(	O
fgbg	long
&	O
SLTT_ULINE_MASK	int
)	O
tt_write_string	(*(char))->(void)
(	O
UnderLine_Vid_Str	*(char)
)	O
;	O
if	O
(	O
fgbg	long
&	O
SLTT_BOLD_MASK	int
)	O
SLtt_bold_video	()->(void)
(	O
)	O
;	O
if	O
(	O
fgbg	long
&	O
SLTT_REV_MASK	int
)	O
tt_write_string	(*(char))->(void)
(	O
Rev_Vid_Str	*(char)
)	O
;	O
if	O
(	O
fgbg	long
&	O
SLTT_BLINK_MASK	int
)	O
{	O
if	O
(	O
SLtt_Blink_Mode	int
)	O
tt_write_string	(*(char))->(void)
(	O
Blink_Vid_Str	*(char)
)	O
;	O
}	O
unknown_attributes	int
=	O
1	int
;	O
}	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
{	O
fg0	int
=	O
(	O
int	O
)	O
GET_FG	O
(	O
fgbg	long
)	O
;	O
bg0	int
=	O
(	O
int	O
)	O
GET_BG	O
(	O
fgbg	long
)	O
;	O
if	O
(	O
unknown_attributes	int
||	O
(	O
fg0	int
!=	O
(	O
int	O
)	O
GET_FG	O
(	O
Current_Fgbg	long
)	O
)	O
)	O
{	O
if	O
(	O
fg0	int
==	O
SLSMG_COLOR_DEFAULT	int
)	O
tt_write_string	(*(char))->(void)
(	O
Default_Color_Fg_Str	*(char)
)	O
;	O
else	O
tt_printf	(*(char),int,int)->(void)
(	O
Color_Fg_Str	*(char)
,	O
COLOR_ARG	O
(	O
fg0	int
,	O
Is_Bg_BGR	int
)	O
,	O
0	int
)	O
;	O
}	O
if	O
(	O
unknown_attributes	int
||	O
(	O
bg0	int
!=	O
(	O
int	O
)	O
GET_BG	O
(	O
Current_Fgbg	long
)	O
)	O
)	O
{	O
if	O
(	O
bg0	int
==	O
SLSMG_COLOR_DEFAULT	int
)	O
tt_write_string	(*(char))->(void)
(	O
Default_Color_Bg_Str	*(char)
)	O
;	O
else	O
tt_printf	(*(char),int,int)->(void)
(	O
Color_Bg_Str	*(char)
,	O
COLOR_ARG	O
(	O
bg0	int
,	O
Is_Bg_BGR	int
)	O
,	O
0	int
)	O
;	O
}	O
}	O
Current_Fgbg	long
=	O
fgbg	long
;	O
}	O
static	O
int	O
Video_Initialized	int
;	O
void	O
SLtt_reverse_video	(int)->(void)
(	O
int	O
color	short
)	O
{	O
SLtt_Char_Type	long
fgbg	long
;	O
if	O
(	O
Worthless_Highlight	int
)	O
return	O
;	O
if	O
(	O
Video_Initialized	int
==	O
0	int
)	O
{	O
if	O
(	O
color	short
==	O
JNORMAL_COLOR	int
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
Norm_Vid_Str	*(char)
)	O
;	O
}	O
else	O
tt_write_string	(*(char))->(void)
(	O
Rev_Vid_Str	*(char)
)	O
;	O
Current_Fgbg	long
=	O
0xFFFFFFFFU	int
;	O
return	O
;	O
}	O
fgbg	long
=	O
get_brush_attr	(int)->(long)
(	O
color	short
)	O
;	O
if	O
(	O
fgbg	long
==	O
Current_Fgbg	long
)	O
return	O
;	O
write_attributes	(long)->(void)
(	O
fgbg	long
)	O
;	O
}	O
void	O
SLtt_normal_video	()->(void)
(	O
void	O
)	O
{	O
SLtt_reverse_video	(int)->(void)
(	O
JNORMAL_COLOR	int
)	O
;	O
}	O
void	O
SLtt_narrow_width	()->(void)
(	O
void	O
)	O
{	O
tt_write	(*(char),int)->(void)
(	O
"\033[?3l"	*(char)
,	O
5	int
)	O
;	O
}	O
void	O
SLtt_wide_width	()->(void)
(	O
void	O
)	O
{	O
tt_write	(*(char),int)->(void)
(	O
"\033[?3h"	*(char)
,	O
5	int
)	O
;	O
}	O
static	O
int	O
bce_color_eqs	(*(struct(int,array(int),short)),*(struct(int,array(int),short)))->(int)
(	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
a	*(char)
,	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
b	*(char)
)	O
{	O
SLsmg_Color_Type	short
ca	short
,	O
cb	short
;	O
Brush_Info_Type	struct(long,long)
*	O
ba	*(struct(long,long))
,	O
*	O
bb	*(struct(long,long))
;	O
ca	short
=	O
COLOR_OF	O
(	O
a	*(char)
)	O
;	O
cb	short
=	O
COLOR_OF	O
(	O
b	*(char)
)	O
;	O
if	O
(	O
ca	short
==	O
cb	short
)	O
return	O
1	int
;	O
ba	*(struct(long,long))
=	O
get_brush_info	(int)->(*(struct(long,long)))
(	O
ca	short
)	O
;	O
bb	*(struct(long,long))
=	O
get_brush_info	(int)->(*(struct(long,long)))
(	O
cb	short
)	O
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
==	O
0	int
)	O
return	O
ba	*(struct(long,long))
->	O
mono	long
==	O
bb	*(struct(long,long))
->	O
mono	long
;	O
if	O
(	O
Bce_Color_Offset	int
==	O
0	int
)	O
return	O
ba	*(struct(long,long))
->	O
fgbg	long
==	O
bb	*(struct(long,long))
->	O
fgbg	long
;	O
if	O
(	O
(	O
ca	short
==	O
0	int
)	O
||	O
(	O
cb	short
==	O
0	int
)	O
)	O
return	O
0	int
;	O
return	O
get_brush_fgbg	(int)->(long)
(	O
ca	short
-	O
1	int
)	O
==	O
get_brush_fgbg	(int)->(long)
(	O
cb	short
-	O
1	int
)	O
;	O
}	O
static	O
void	O
write_string_with_care	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
unsigned	O
int	O
len	int
;	O
if	O
(	O
str	*(char)
==	O
NULL	O
)	O
return	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
if	O
(	O
Automatic_Margins	int
&&	O
(	O
Cursor_r	int
+	O
1	int
==	O
SLtt_Screen_Rows	int
)	O
)	O
{	O
if	O
(	O
_pSLtt_UTF8_Mode	int
==	O
0	int
)	O
{	O
if	O
(	O
len	int
+	O
(	O
unsigned	O
int	O
)	O
Cursor_c	int
>=	O
(	O
unsigned	O
int	O
)	O
SLtt_Screen_Cols	int
)	O
{	O
if	O
(	O
SLtt_Screen_Cols	int
>	O
Cursor_c	int
)	O
len	int
=	O
SLtt_Screen_Cols	int
-	O
Cursor_c	int
-	O
1	int
;	O
else	O
len	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
nchars	int
=	O
SLutf8_strlen	(*(char),int)->(int)
(	O
(	O
SLuchar_Type	char
*	O
)	O
str	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
nchars	int
+	O
(	O
unsigned	O
int	O
)	O
Cursor_c	int
>=	O
(	O
unsigned	O
int	O
)	O
SLtt_Screen_Cols	int
)	O
{	O
if	O
(	O
SLtt_Screen_Cols	int
>	O
Cursor_c	int
)	O
{	O
char	O
*	O
p	*(char)
;	O
nchars	int
=	O
SLtt_Screen_Cols	int
-	O
Cursor_c	int
-	O
1	int
;	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
SLutf8_skip_chars	(*(char),*(char),int,*(int),int)->(*(char))
(	O
(	O
SLuchar_Type	char
*	O
)	O
str	*(char)
,	O
(	O
SLuchar_Type	char
*	O
)	O
(	O
str	*(char)
+	O
len	int
)	O
,	O
nchars	int
,	O
NULL	O
,	O
1	int
)	O
;	O
len	int
=	O
p	*(char)
-	O
str	*(char)
;	O
}	O
else	O
len	int
=	O
0	int
;	O
}	O
}	O
}	O
tt_write	(*(char),int)->(void)
(	O
str	*(char)
,	O
len	int
)	O
;	O
}	O
static	O
void	O
send_attr_str	(*(struct(int,array(int),short)),*(struct(int,array(int),short)))->(void)
(	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
s	*(char)
,	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
smax	*(struct(int,array(int),short))
)	O
{	O
unsigned	O
char	O
out	*(char)
[	O
1	int
+	O
SLUTF8_MAX_MBLEN	int
*	O
SLSMG_MAX_CHARS_PER_CELL	int
*	O
SLTT_MAX_SCREEN_COLS	int
]	O
;	O
unsigned	O
char	O
*	O
p	*(char)
,	O
*	O
pmax	*(char)
;	O
register	O
SLtt_Char_Type	long
attr	long
;	O
SLsmg_Color_Type	short
color	short
,	O
last_color	short
=	O
(	O
SLsmg_Color_Type	short
)	O
-	O
1	int
;	O
int	O
dcursor_c	int
;	O
p	*(char)
=	O
out	*(char)
;	O
pmax	*(char)
=	O
p	*(char)
+	O
(	O
sizeof	O
(	O
out	*(char)
)	O
-	O
1	int
)	O
;	O
dcursor_c	int
=	O
0	int
;	O
while	O
(	O
s	*(char)
<	O
smax	*(struct(int,array(int),short))
)	O
{	O
SLwchar_Type	int
wch	int
;	O
unsigned	O
int	O
nchars	int
;	O
if	O
(	O
0	int
==	O
(	O
nchars	int
=	O
s	*(char)
->	O
nchars	int
)	O
)	O
{	O
s	*(char)
++	O
;	O
if	O
(	O
_pSLtt_UTF8_Mode	int
==	O
0	int
)	O
*	O
p	*(char)
++	O
=	O
' '	O
;	O
dcursor_c	int
++	O
;	O
continue	O
;	O
}	O
color	short
=	O
s	*(char)
->	O
color	short
;	O
if	O
(	O
Bce_Color_Offset	int
&&	O
(	O
color	short
>=	O
Bce_Color_Offset	int
)	O
)	O
color	short
-=	O
Bce_Color_Offset	int
;	O
wch	int
=	O
s	*(char)
->	O
wchars	array(int)
[	O
0	int
]	O
;	O
if	O
(	O
color	short
!=	O
last_color	short
)	O
{	O
attr	long
=	O
get_brush_attr	(int)->(long)
(	O
color	short
)	O
;	O
if	O
(	O
color	short
&	O
SLSMG_ACS_MASK	int
)	O
{	O
if	O
(	O
SLtt_Use_Blink_For_ACS	int
)	O
{	O
if	O
(	O
SLtt_Blink_Mode	int
)	O
attr	long
|=	O
SLTT_BLINK_MASK	int
;	O
}	O
else	O
attr	long
|=	O
SLTT_ALTC_MASK	int
;	O
}	O
if	O
(	O
attr	long
!=	O
Current_Fgbg	long
)	O
{	O
if	O
(	O
(	O
wch	int
!=	O
' '	O
)	O
||	O
(	O
nchars	int
>	O
1	int
)	O
||	O
(	O
attr	long
!=	O
Current_Fgbg	long
)	O
)	O
{	O
if	O
(	O
p	*(char)
!=	O
out	*(char)
)	O
{	O
*	O
p	*(char)
=	O
0	int
;	O
write_string_with_care	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
out	*(char)
)	O
;	O
p	*(char)
=	O
out	*(char)
;	O
Cursor_c	int
+=	O
dcursor_c	int
;	O
dcursor_c	int
=	O
0	int
;	O
}	O
write_attributes	(long)->(void)
(	O
attr	long
)	O
;	O
last_color	short
=	O
color	short
;	O
}	O
}	O
}	O
if	O
(	O
(	O
wch	int
<	O
0x80	int
)	O
&&	O
(	O
nchars	int
==	O
1	int
)	O
)	O
*	O
p	*(char)
++	O
=	O
(	O
unsigned	O
char	O
)	O
wch	int
;	O
else	O
if	O
(	O
_pSLtt_UTF8_Mode	int
==	O
0	int
)	O
{	O
if	O
(	O
wch	int
>	O
255	int
)	O
wch	int
=	O
'?'	O
;	O
else	O
if	O
(	O
wch	int
<	O
(	O
SLwchar_Type	int
)	O
SLsmg_Display_Eight_Bit	int
)	O
wch	int
=	O
'?'	O
;	O
*	O
p	*(char)
++	O
=	O
(	O
unsigned	O
char	O
)	O
wch	int
;	O
}	O
else	O
{	O
unsigned	O
int	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
nchars	int
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
NULL	O
==	O
(	O
p	*(char)
=	O
SLutf8_encode	(int,*(char),int)->(*(char))
(	O
s	*(char)
->	O
wchars	array(int)
[	O
i	array(int)
]	O
,	O
p	*(char)
,	O
pmax	*(char)
-	O
p	*(char)
)	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** send_attr_str: buffer too small\n"	*(char)
)	O
;	O
return	O
;	O
}	O
}	O
}	O
dcursor_c	int
++	O
;	O
s	*(char)
++	O
;	O
}	O
*	O
p	*(char)
=	O
0	int
;	O
if	O
(	O
p	*(char)
!=	O
out	*(char)
)	O
write_string_with_care	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
out	*(char)
)	O
;	O
Cursor_c	int
+=	O
dcursor_c	int
;	O
}	O
static	O
void	O
forward_cursor	(int,int)->(void)
(	O
unsigned	O
int	O
n	int
,	O
int	O
row	int
)	O
{	O
char	O
buf	*(char)
[	O
1024	int
]	O
;	O
if	O
(	O
n	int
<=	O
4	int
)	O
{	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
SLMEMSET	O
(	O
buf	*(char)
,	O
' '	O
,	O
n	int
)	O
;	O
buf	*(char)
[	O
n	int
]	O
=	O
0	int
;	O
write_string_with_care	(*(char))->(void)
(	O
buf	*(char)
)	O
;	O
Cursor_c	int
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
Curs_F_Str	*(char)
!=	O
NULL	O
)	O
{	O
Cursor_c	int
+=	O
n	int
;	O
n	int
=	O
tt_sprintf	(*(char),int,*(char),int,int)->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
Curs_F_Str	*(char)
,	O
(	O
int	O
)	O
n	int
,	O
0	int
)	O
;	O
tt_write	(*(char),int)->(void)
(	O
buf	*(char)
,	O
n	int
)	O
;	O
}	O
else	O
SLtt_goto_rc	(int,int)->(void)
(	O
row	int
,	O
(	O
int	O
)	O
(	O
Cursor_c	int
+	O
n	int
)	O
)	O
;	O
}	O
void	O
SLtt_smart_puts	(*(struct(int,array(int),short)),*(struct(int,array(int),short)),int,int)->(void)
(	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
neww	*(struct(int,array(int),short))
,	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
oldd	*(struct(int,array(int),short))
,	O
int	O
len	int
,	O
int	O
row	int
)	O
{	O
register	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
p	*(char)
,	O
*	O
q	*(struct(int,array(int),short))
,	O
*	O
qmax	*(struct(int,array(int),short))
,	O
*	O
pmax	*(char)
,	O
*	O
buf	*(char)
;	O
SLsmg_Char_Type	struct(int,array(int),short)
buffer	*(char)
[	O
SLTT_MAX_SCREEN_COLS	int
+	O
1	int
]	O
;	O
unsigned	O
int	O
n_spaces	int
;	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
space_match	*(struct(int,array(int),short))
,	O
*	O
last_buffered_match	*(struct(int,array(int),short))
;	O
int	O
handle_hp_glitch	int
=	O
0	int
;	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
space_char	*(struct(int,array(int),short))
;	O
SLsmg_Char_Type	struct(int,array(int),short)
space_char_buf	struct(int,array(int),short)
;	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
insert_hack_prev	*(struct(int,array(int),short))
=	O
NULL	O
;	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
insert_hack_char	*(struct(int,array(int),short))
=	O
NULL	O
;	O
if	O
(	O
(	O
row	int
+	O
1	int
==	O
SLtt_Screen_Rows	int
)	O
&&	O
(	O
len	int
==	O
SLtt_Screen_Cols	int
)	O
&&	O
(	O
len	int
>	O
1	int
)	O
&&	O
(	O
SLtt_Term_Cannot_Insert	int
==	O
0	int
)	O
&&	O
Automatic_Margins	int
)	O
{	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
a	*(char)
,	O
*	O
b	*(char)
;	O
insert_hack_char	*(struct(int,array(int),short))
=	O
&	O
neww	*(struct(int,array(int),short))
[	O
len	int
-	O
1	int
]	O
;	O
a	*(char)
=	O
oldd	*(struct(int,array(int),short))
+	O
(	O
len	int
-	O
1	int
)	O
;	O
b	*(char)
=	O
neww	*(struct(int,array(int),short))
+	O
(	O
len	int
-	O
1	int
)	O
;	O
if	O
(	O
CHAR_EQS	O
(	O
a	*(char)
,	O
b	*(char)
)	O
)	O
insert_hack_char	*(struct(int,array(int),short))
=	O
NULL	O
;	O
else	O
insert_hack_prev	*(struct(int,array(int),short))
=	O
&	O
neww	*(struct(int,array(int),short))
[	O
len	int
-	O
2	int
]	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
&	O
space_char_buf	struct(int,array(int),short)
,	O
0	int
,	O
sizeof	O
(	O
SLsmg_Char_Type	struct(int,array(int),short)
)	O
)	O
;	O
space_char	*(struct(int,array(int),short))
=	O
&	O
space_char_buf	struct(int,array(int),short)
;	O
space_char	*(struct(int,array(int),short))
->	O
nchars	int
=	O
1	int
;	O
space_char	*(struct(int,array(int),short))
->	O
wchars	array(int)
[	O
0	int
]	O
=	O
' '	O
;	O
if	O
(	O
len	int
>	O
SLTT_MAX_SCREEN_COLS	int
)	O
len	int
=	O
SLTT_MAX_SCREEN_COLS	int
;	O
q	*(struct(int,array(int),short))
=	O
oldd	*(struct(int,array(int),short))
;	O
p	*(char)
=	O
neww	*(struct(int,array(int),short))
;	O
qmax	*(struct(int,array(int),short))
=	O
oldd	*(struct(int,array(int),short))
+	O
len	int
;	O
pmax	*(char)
=	O
p	*(char)
+	O
len	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
q	*(struct(int,array(int),short))
==	O
qmax	*(struct(int,array(int),short))
)	O
return	O
;	O
if	O
(	O
!	O
CHAR_EQS	O
(	O
q	*(struct(int,array(int),short))
,	O
p	*(char)
)	O
)	O
break	O
;	O
q	*(struct(int,array(int),short))
++	O
;	O
p	*(char)
++	O
;	O
}	O
if	O
(	O
Has_HP_Glitch	int
)	O
{	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
qq	*(struct(int,array(int),short))
=	O
q	*(struct(int,array(int),short))
;	O
SLtt_goto_rc	(int,int)->(void)
(	O
row	int
,	O
(	O
int	O
)	O
(	O
p	*(char)
-	O
neww	*(struct(int,array(int),short))
)	O
)	O
;	O
while	O
(	O
qq	*(struct(int,array(int),short))
<	O
qmax	*(struct(int,array(int),short))
)	O
{	O
if	O
(	O
qq	*(struct(int,array(int),short))
->	O
color	short
)	O
{	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
SLtt_del_eol	()->(void)
(	O
)	O
;	O
qmax	*(struct(int,array(int),short))
=	O
q	*(struct(int,array(int),short))
;	O
handle_hp_glitch	int
=	O
1	int
;	O
break	O
;	O
}	O
qq	*(struct(int,array(int),short))
++	O
;	O
}	O
}	O
if	O
(	O
CHAR_EQS_SPACE	O
(	O
pmax	*(char)
-	O
1	int
)	O
)	O
{	O
if	O
(	O
(	O
Can_Background_Color_Erase	int
)	O
&&	O
SLtt_Use_Ansi_Colors	int
)	O
space_char	*(struct(int,array(int),short))
=	O
pmax	*(char)
-	O
1	int
;	O
while	O
(	O
pmax	*(char)
>	O
p	*(char)
)	O
{	O
pmax	*(char)
--	O
;	O
if	O
(	O
!	O
CHAR_EQS	O
(	O
pmax	*(char)
,	O
space_char	*(struct(int,array(int),short))
)	O
)	O
{	O
pmax	*(char)
++	O
;	O
break	O
;	O
}	O
}	O
}	O
while	O
(	O
qmax	*(struct(int,array(int),short))
>	O
q	*(struct(int,array(int),short))
)	O
{	O
qmax	*(struct(int,array(int),short))
--	O
;	O
if	O
(	O
!	O
CHAR_EQS	O
(	O
qmax	*(struct(int,array(int),short))
,	O
space_char	*(struct(int,array(int),short))
)	O
)	O
{	O
qmax	*(struct(int,array(int),short))
++	O
;	O
break	O
;	O
}	O
}	O
last_buffered_match	*(struct(int,array(int),short))
=	O
buf	*(char)
=	O
buffer	*(char)
;	O
if	O
(	O
handle_hp_glitch	int
)	O
{	O
while	O
(	O
p	*(char)
<	O
pmax	*(char)
)	O
{	O
*	O
buf	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
}	O
}	O
if	O
(	O
Has_HP_Glitch	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
Del_Bol_Str	*(char)
!=	O
NULL	O
)	O
&&	O
(	O
CHAR_EQS_SPACE	O
(	O
neww	*(struct(int,array(int),short))
)	O
)	O
)	O
{	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
p1	*(struct(int,array(int),short))
;	O
SLsmg_Color_Type	short
blank_color	short
=	O
0	int
;	O
p1	*(struct(int,array(int),short))
=	O
neww	*(struct(int,array(int),short))
;	O
if	O
(	O
(	O
Can_Background_Color_Erase	int
)	O
&&	O
SLtt_Use_Ansi_Colors	int
)	O
{	O
SLsmg_Char_Type	struct(int,array(int),short)
*	O
blank	*(struct(int,array(int),short))
=	O
p1	*(struct(int,array(int),short))
;	O
blank_color	short
=	O
COLOR_OF	O
(	O
blank	*(struct(int,array(int),short))
)	O
;	O
while	O
(	O
(	O
p1	*(struct(int,array(int),short))
<	O
pmax	*(char)
)	O
&&	O
(	O
CHAR_EQS	O
(	O
p1	*(struct(int,array(int),short))
,	O
blank	*(struct(int,array(int),short))
)	O
)	O
)	O
p1	*(struct(int,array(int),short))
++	O
;	O
}	O
else	O
{	O
while	O
(	O
(	O
p1	*(struct(int,array(int),short))
<	O
pmax	*(char)
)	O
&&	O
(	O
CHAR_EQS_SPACE	O
(	O
p1	*(struct(int,array(int),short))
)	O
)	O
)	O
p1	*(struct(int,array(int),short))
++	O
;	O
}	O
if	O
(	O
(	O
p1	*(struct(int,array(int),short))
>	O
neww	*(struct(int,array(int),short))
+	O
13	int
)	O
&&	O
(	O
p1	*(struct(int,array(int),short))
>=	O
p	*(char)
)	O
&&	O
(	O
(	O
p1	*(struct(int,array(int),short))
!=	O
pmax	*(char)
)	O
||	O
(	O
pmax	*(char)
<	O
neww	*(struct(int,array(int),short))
+	O
len	int
)	O
)	O
)	O
{	O
int	O
ofs	int
=	O
(	O
int	O
)	O
(	O
p1	*(struct(int,array(int),short))
-	O
neww	*(struct(int,array(int),short))
)	O
;	O
q	*(struct(int,array(int),short))
=	O
oldd	*(struct(int,array(int),short))
+	O
ofs	int
;	O
p	*(char)
=	O
p1	*(struct(int,array(int),short))
;	O
SLtt_goto_rc	(int,int)->(void)
(	O
row	int
,	O
ofs	int
-	O
1	int
)	O
;	O
SLtt_reverse_video	(int)->(void)
(	O
blank_color	short
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Del_Bol_Str	*(char)
)	O
;	O
tt_write	(*(char),int)->(void)
(	O
" "	*(char)
,	O
1	int
)	O
;	O
Cursor_c	int
+=	O
1	int
;	O
}	O
else	O
SLtt_goto_rc	(int,int)->(void)
(	O
row	int
,	O
(	O
int	O
)	O
(	O
p	*(char)
-	O
neww	*(struct(int,array(int),short))
)	O
)	O
;	O
}	O
else	O
SLtt_goto_rc	(int,int)->(void)
(	O
row	int
,	O
(	O
int	O
)	O
(	O
p	*(char)
-	O
neww	*(struct(int,array(int),short))
)	O
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
n_spaces	int
=	O
0	int
;	O
while	O
(	O
p	*(char)
<	O
pmax	*(char)
)	O
{	O
if	O
(	O
CHAR_EQS_SPACE	O
(	O
q	*(struct(int,array(int),short))
)	O
&&	O
CHAR_EQS_SPACE	O
(	O
p	*(char)
)	O
)	O
{	O
space_match	*(struct(int,array(int),short))
=	O
p	*(char)
;	O
p	*(char)
++	O
;	O
q	*(struct(int,array(int),short))
++	O
;	O
while	O
(	O
(	O
p	*(char)
<	O
pmax	*(char)
)	O
&&	O
CHAR_EQS_SPACE	O
(	O
q	*(struct(int,array(int),short))
)	O
&&	O
CHAR_EQS_SPACE	O
(	O
p	*(char)
)	O
)	O
{	O
p	*(char)
++	O
;	O
q	*(struct(int,array(int),short))
++	O
;	O
}	O
n_spaces	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
p	*(char)
-	O
space_match	*(struct(int,array(int),short))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
CHAR_EQS	O
(	O
q	*(struct(int,array(int),short))
,	O
p	*(char)
)	O
)	O
{	O
if	O
(	O
p	*(char)
->	O
nchars	int
||	O
q	*(struct(int,array(int),short))
->	O
nchars	int
)	O
break	O
;	O
}	O
*	O
buf	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
q	*(struct(int,array(int),short))
++	O
;	O
}	O
if	O
(	O
buf	*(char)
!=	O
buffer	*(char)
)	O
send_attr_str	(*(struct(int,array(int),short)),*(struct(int,array(int),short)))->(void)
(	O
buffer	*(char)
,	O
buf	*(char)
)	O
;	O
buf	*(char)
=	O
buffer	*(char)
;	O
if	O
(	O
n_spaces	int
&&	O
(	O
(	O
p	*(char)
<	O
pmax	*(char)
)	O
||	O
(	O
!	O
CHAR_EQS_SPACE	O
(	O
space_char	*(struct(int,array(int),short))
)	O
)	O
)	O
)	O
{	O
forward_cursor	(int,int)->(void)
(	O
n_spaces	int
,	O
row	int
)	O
;	O
}	O
while	O
(	O
(	O
p	*(char)
<	O
pmax	*(char)
)	O
&&	O
CHAR_EQS	O
(	O
p	*(char)
,	O
q	*(struct(int,array(int),short))
)	O
)	O
{	O
*	O
buf	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
q	*(struct(int,array(int),short))
++	O
;	O
}	O
last_buffered_match	*(struct(int,array(int),short))
=	O
buf	*(char)
;	O
if	O
(	O
p	*(char)
>=	O
pmax	*(char)
)	O
break	O
;	O
if	O
(	O
(	O
int	O
)	O
(	O
buf	*(char)
-	O
buffer	*(char)
)	O
>=	O
5	int
)	O
{	O
forward_cursor	(int,int)->(void)
(	O
(	O
unsigned	O
int	O
)	O
(	O
buf	*(char)
-	O
buffer	*(char)
)	O
,	O
row	int
)	O
;	O
last_buffered_match	*(struct(int,array(int),short))
=	O
buf	*(char)
=	O
buffer	*(char)
;	O
}	O
}	O
if	O
(	O
buf	*(char)
!=	O
buffer	*(char)
)	O
{	O
if	O
(	O
q	*(struct(int,array(int),short))
<	O
qmax	*(struct(int,array(int),short))
)	O
{	O
if	O
(	O
(	O
buf	*(char)
==	O
last_buffered_match	*(struct(int,array(int),short))
)	O
&&	O
(	O
(	O
int	O
)	O
(	O
buf	*(char)
-	O
buffer	*(char)
)	O
>=	O
5	int
)	O
)	O
{	O
forward_cursor	(int,int)->(void)
(	O
(	O
unsigned	O
int	O
)	O
(	O
buf	*(char)
-	O
buffer	*(char)
)	O
,	O
row	int
)	O
;	O
}	O
else	O
{	O
send_attr_str	(*(struct(int,array(int),short)),*(struct(int,array(int),short)))->(void)
(	O
buffer	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
}	O
}	O
if	O
(	O
q	*(struct(int,array(int),short))
<	O
qmax	*(struct(int,array(int),short))
)	O
{	O
SLtt_reverse_video	(int)->(void)
(	O
COLOR_OF	O
(	O
space_char	*(struct(int,array(int),short))
)	O
)	O
;	O
del_eol	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
insert_hack_char	*(struct(int,array(int),short))
!=	O
NULL	O
)	O
{	O
SLtt_goto_rc	(int,int)->(void)
(	O
SLtt_Screen_Rows	int
-	O
1	int
,	O
SLtt_Screen_Cols	int
-	O
2	int
)	O
;	O
send_attr_str	(*(struct(int,array(int),short)),*(struct(int,array(int),short)))->(void)
(	O
insert_hack_char	*(struct(int,array(int),short))
,	O
insert_hack_char	*(struct(int,array(int),short))
+	O
1	int
)	O
;	O
SLtt_goto_rc	(int,int)->(void)
(	O
SLtt_Screen_Rows	int
-	O
1	int
,	O
SLtt_Screen_Cols	int
-	O
2	int
)	O
;	O
SLtt_begin_insert	()->(void)
(	O
)	O
;	O
send_attr_str	(*(struct(int,array(int),short)),*(struct(int,array(int),short)))->(void)
(	O
insert_hack_prev	*(struct(int,array(int),short))
,	O
insert_hack_prev	*(struct(int,array(int),short))
+	O
1	int
)	O
;	O
SLtt_end_insert	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
Automatic_Margins	int
&&	O
(	O
Cursor_c	int
+	O
1	int
>=	O
SLtt_Screen_Cols	int
)	O
)	O
Cursor_Set	int
=	O
0	int
;	O
}	O
static	O
void	O
get_color_info	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
fg	int
,	O
*	O
bg	int
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
==	O
0	int
)	O
SLtt_Use_Ansi_Colors	int
=	O
(	O
NULL	O
!=	O
getenv	(*(char))->(*(char))
(	O
"COLORTERM"	*(char)
)	O
)	O
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
Is_Color_Terminal	int
=	O
1	int
;	O
if	O
(	O
Can_Background_Color_Erase	int
==	O
0	int
)	O
Can_Background_Color_Erase	int
=	O
(	O
NULL	O
!=	O
getenv	(*(char))->(*(char))
(	O
"COLORTERM_BCE"	*(char)
)	O
)	O
;	O
if	O
(	O
-	O
1	int
==	O
get_default_colors	(*(*(char)),*(*(char)))->(int)
(	O
&	O
fg	int
,	O
&	O
bg	int
)	O
)	O
return	O
;	O
if	O
(	O
Color_0_Modified	int
)	O
return	O
;	O
SLtt_set_color	(int,*(char),*(char),*(char))->(int)
(	O
0	int
,	O
NULL	O
,	O
fg	int
,	O
bg	int
)	O
;	O
SLtt_set_color	(int,*(char),*(char),*(char))->(int)
(	O
1	int
,	O
NULL	O
,	O
bg	int
,	O
fg	int
)	O
;	O
}	O
static	O
int	O
Termcap_Initalized	int
=	O
0	int
;	O
static	O
SLterminfo_Type	struct
*	O
Terminfo	*(struct)
;	O
static	O
char	O
*	O
fixup_tgetstr	(*(char))->(*(char))
(	O
char	O
*	O
what	*(char)
)	O
{	O
register	O
char	O
*	O
w	*(int)
,	O
*	O
w1	*(char)
;	O
char	O
*	O
wsave	*(char)
;	O
if	O
(	O
what	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
*	O
what	*(char)
==	O
'@'	O
)	O
return	O
NULL	O
;	O
while	O
(	O
(	O
*	O
what	*(char)
==	O
'.'	O
)	O
||	O
(	O
(	O
*	O
what	*(char)
>=	O
'0'	O
)	O
&&	O
(	O
*	O
what	*(char)
<=	O
'9'	O
)	O
)	O
)	O
what	*(char)
++	O
;	O
if	O
(	O
*	O
what	*(char)
==	O
'*'	O
)	O
what	*(char)
++	O
;	O
w	*(int)
=	O
what	*(char)
;	O
while	O
(	O
*	O
w	*(int)
)	O
if	O
(	O
(	O
*	O
w	*(int)
++	O
==	O
'$'	O
)	O
&&	O
(	O
*	O
w	*(int)
==	O
'<'	O
)	O
)	O
{	O
w1	*(char)
=	O
w	*(int)
-	O
1	int
;	O
while	O
(	O
*	O
w	*(int)
&&	O
(	O
*	O
w	*(int)
!=	O
'>'	O
)	O
)	O
w	*(int)
++	O
;	O
if	O
(	O
*	O
w	*(int)
==	O
0	int
)	O
break	O
;	O
w	*(int)
++	O
;	O
wsave	*(char)
=	O
w1	*(char)
;	O
while	O
(	O
(	O
*	O
w1	*(char)
++	O
=	O
*	O
w	*(int)
++	O
)	O
!=	O
0	int
)	O
;	O
w	*(int)
=	O
wsave	*(char)
;	O
}	O
if	O
(	O
*	O
what	*(char)
==	O
0	int
)	O
what	*(char)
=	O
NULL	O
;	O
return	O
what	*(char)
;	O
}	O
char	O
*	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
char	O
*	O
cap	*(char)
)	O
{	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
Termcap_Initalized	int
==	O
0	int
)	O
return	O
NULL	O
;	O
s	*(char)
=	O
_pSLtt_tigetstr	(*(struct),*(char))->(*(char))
(	O
Terminfo	*(struct)
,	O
cap	*(char)
)	O
;	O
if	O
(	O
0	int
==	O
strcmp	(*(char),*(char))->(int)
(	O
cap	*(char)
,	O
"ac"	*(char)
)	O
)	O
return	O
s	*(char)
;	O
s	*(char)
=	O
fixup_tgetstr	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
return	O
s	*(char)
;	O
}	O
int	O
SLtt_tgetnum	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
Termcap_Initalized	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
_pSLtt_tigetnum	(*(struct),*(char))->(int)
(	O
Terminfo	*(struct)
,	O
s	*(char)
)	O
;	O
}	O
int	O
SLtt_tgetflag	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
Termcap_Initalized	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
_pSLtt_tigetflag	(*(struct),*(char))->(int)
(	O
Terminfo	*(struct)
,	O
s	*(char)
)	O
;	O
}	O
static	O
int	O
Vt100_Like	int
=	O
0	int
;	O
void	O
SLtt_get_terminfo	()->(void)
(	O
void	O
)	O
{	O
char	O
*	O
term	*(char)
;	O
int	O
status	int
;	O
term	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
;	O
if	O
(	O
term	*(char)
==	O
NULL	O
)	O
SLang_exit_error	(*(char))->(void)
(	O
"TERM environment variable needs set."	*(char)
)	O
;	O
if	O
(	O
0	int
==	O
(	O
status	int
=	O
SLtt_initialize	(*(char))->(int)
(	O
term	*(char)
)	O
)	O
)	O
return	O
;	O
if	O
(	O
status	int
==	O
-	O
1	int
)	O
{	O
SLang_exit_error	(*(char))->(void)
(	O
"Unknown terminal: %s\nCheck the TERM environment variable.\nAlso make sure that the terminal is defined in the terminfo database.\nAlternatively, set the TERMCAP environment variable to the desired\ntermcap entry."	*(char)
,	O
term	*(char)
)	O
;	O
}	O
if	O
(	O
status	int
==	O
-	O
2	int
)	O
{	O
SLang_exit_error	(*(char))->(void)
(	O
"Your terminal lacks the ability to clear the screen or position the cursor.\n"	*(char)
)	O
;	O
}	O
}	O
int	O
SLtt_initialize	(*(char))->(int)
(	O
char	O
*	O
term	*(char)
)	O
{	O
char	O
*	O
t	long
,	O
ch	int
;	O
int	O
is_xterm	int
;	O
int	O
almost_vtxxx	int
;	O
if	O
(	O
_pSLtt_UTF8_Mode	int
==	O
-	O
1	int
)	O
_pSLtt_UTF8_Mode	int
=	O
_pSLutf8_mode	int
;	O
if	O
(	O
SLang_TT_Write_FD	int
==	O
-	O
1	int
)	O
{	O
SLang_TT_Write_FD	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
term	*(char)
==	O
NULL	O
)	O
{	O
term	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
;	O
if	O
(	O
term	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
_pSLsecure_issetugid	()->(int)
(	O
)	O
&&	O
(	O
(	O
term	*(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	(*(char),int)->(*(char))
(	O
term	*(char)
,	O
'/'	O
)	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
Linux_Console	int
=	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"linux"	*(char)
,	O
5	int
)	O
||	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"con"	*(char)
,	O
3	int
)	O
)	O
;	O
QANSI_Console	int
=	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"qansi-m"	*(char)
,	O
7	int
)	O
;	O
t	long
=	O
term	*(char)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
t	long
,	O
"vt52"	*(char)
)	O
&&	O
(	O
*	O
t	long
++	O
==	O
'v'	O
)	O
&&	O
(	O
*	O
t	long
++	O
==	O
't'	O
)	O
&&	O
(	O
ch	int
=	O
*	O
t	long
,	O
(	O
ch	int
>=	O
'1'	O
)	O
&&	O
(	O
ch	int
<=	O
'9'	O
)	O
)	O
)	O
Vt100_Like	int
=	O
1	int
;	O
is_xterm	int
=	O
(	O
(	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"xterm"	*(char)
,	O
5	int
)	O
)	O
||	O
(	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"rxvt"	*(char)
,	O
4	int
)	O
)	O
||	O
(	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"Eterm"	*(char)
,	O
5	int
)	O
)	O
)	O
;	O
almost_vtxxx	int
=	O
(	O
Vt100_Like	int
||	O
Linux_Console	int
||	O
is_xterm	int
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
term	*(char)
,	O
"screen"	*(char)
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
Terminfo	*(struct)
=	O
_pSLtt_tigetent	(*(char))->(*(struct))
(	O
term	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
almost_vtxxx	int
)	O
{	O
int	O
vt102	int
=	O
1	int
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
term	*(char)
,	O
"vt100"	*(char)
)	O
)	O
vt102	int
=	O
0	int
;	O
get_color_info	()->(void)
(	O
)	O
;	O
SLtt_set_term_vtxxx	(*(int))->(void)
(	O
&	O
vt102	int
)	O
;	O
(	O
void	O
)	O
SLtt_get_screen_size	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
Termcap_Initalized	int
=	O
1	int
;	O
Cls_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"cl"	*(char)
)	O
;	O
Curs_Pos_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"cm"	*(char)
)	O
;	O
if	O
(	O
(	O
NULL	O
==	O
(	O
Ins_Mode_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"im"	*(char)
)	O
)	O
)	O
||	O
(	O
NULL	O
==	O
(	O
Eins_Mode_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ei"	*(char)
)	O
)	O
)	O
||	O
(	O
NULL	O
==	O
(	O
Del_Char_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"dc"	*(char)
)	O
)	O
)	O
)	O
SLtt_Term_Cannot_Insert	int
=	O
1	int
;	O
Visible_Bell_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"vb"	*(char)
)	O
;	O
Curs_Up_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"up"	*(char)
)	O
;	O
Rev_Scroll_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"sr"	*(char)
)	O
;	O
Del_N_Lines_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"DL"	*(char)
)	O
;	O
Add_N_Lines_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"AL"	*(char)
)	O
;	O
Term_Init_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ti"	*(char)
)	O
;	O
Term_Reset_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"te"	*(char)
)	O
;	O
if	O
(	O
(	O
almost_vtxxx	int
==	O
0	int
)	O
||	O
SLtt_Force_Keypad_Init	int
)	O
{	O
Keypad_Init_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ks"	*(char)
)	O
;	O
Keypad_Reset_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ke"	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
Vt100_Like	int
&&	O
(	O
term	*(char)
[	O
2	int
]	O
!=	O
'1'	O
)	O
)	O
||	O
Linux_Console	int
||	O
is_xterm	int
)	O
{	O
if	O
(	O
Del_N_Lines_Str	*(char)
==	O
NULL	O
)	O
Del_N_Lines_Str	*(char)
=	O
"\033[%dM"	*(char)
;	O
if	O
(	O
Add_N_Lines_Str	*(char)
==	O
NULL	O
)	O
Add_N_Lines_Str	*(char)
=	O
"\033[%dL"	*(char)
;	O
}	O
Scroll_R_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"cs"	*(char)
)	O
;	O
SLtt_get_screen_size	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
Scroll_R_Str	*(char)
==	O
NULL	O
)	O
||	O
(	O
(	O
(	O
NULL	O
==	O
Del_N_Lines_Str	*(char)
)	O
||	O
(	O
NULL	O
==	O
Add_N_Lines_Str	*(char)
)	O
)	O
&&	O
(	O
NULL	O
==	O
Rev_Scroll_Str	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
is_xterm	int
||	O
Linux_Console	int
)	O
{	O
SLtt_set_term_vtxxx	(*(int))->(void)
(	O
NULL	O
)	O
;	O
}	O
else	O
SLtt_Term_Cannot_Scroll	int
=	O
1	int
;	O
}	O
Del_Eol_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ce"	*(char)
)	O
;	O
Del_Bol_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"cb"	*(char)
)	O
;	O
if	O
(	O
is_xterm	int
&&	O
(	O
Del_Bol_Str	*(char)
==	O
NULL	O
)	O
)	O
Del_Bol_Str	*(char)
=	O
"\033[1K"	*(char)
;	O
if	O
(	O
is_xterm	int
&&	O
(	O
Del_Eol_Str	*(char)
==	O
NULL	O
)	O
)	O
Del_Eol_Str	*(char)
=	O
"\033[K"	*(char)
;	O
Rev_Vid_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"mr"	*(char)
)	O
;	O
if	O
(	O
Rev_Vid_Str	*(char)
==	O
NULL	O
)	O
Rev_Vid_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"so"	*(char)
)	O
;	O
Bold_Vid_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"md"	*(char)
)	O
;	O
if	O
(	O
(	O
NULL	O
==	O
(	O
Blink_Vid_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"mb"	*(char)
)	O
)	O
)	O
&&	O
is_xterm	int
)	O
Blink_Vid_Str	*(char)
=	O
"\033[5m"	*(char)
;	O
UnderLine_Vid_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"us"	*(char)
)	O
;	O
Start_Alt_Chars_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"as"	*(char)
)	O
;	O
End_Alt_Chars_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ae"	*(char)
)	O
;	O
Enable_Alt_Char_Set	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"eA"	*(char)
)	O
;	O
SLtt_Graphics_Char_Pairs	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ac"	*(char)
)	O
;	O
if	O
(	O
NULL	O
==	O
SLtt_Graphics_Char_Pairs	*(char)
)	O
{	O
if	O
(	O
Vt100_Like	int
)	O
{	O
Start_Alt_Chars_Str	*(char)
=	O
"\016"	*(char)
;	O
End_Alt_Chars_Str	*(char)
=	O
"\017"	*(char)
;	O
Enable_Alt_Char_Set	*(char)
=	O
"\033)0"	*(char)
;	O
}	O
}	O
if	O
(	O
is_xterm	int
||	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"aixterm"	*(char)
,	O
7	int
)	O
)	O
{	O
Start_Alt_Chars_Str	*(char)
=	O
"\033(0"	*(char)
;	O
End_Alt_Chars_Str	*(char)
=	O
"\033(B"	*(char)
;	O
Enable_Alt_Char_Set	*(char)
=	O
""	*(char)
;	O
}	O
if	O
(	O
(	O
SLtt_Graphics_Char_Pairs	*(char)
==	O
NULL	O
)	O
&&	O
(	O
(	O
Start_Alt_Chars_Str	*(char)
==	O
NULL	O
)	O
||	O
(	O
End_Alt_Chars_Str	*(char)
==	O
NULL	O
)	O
)	O
)	O
{	O
SLtt_Has_Alt_Charset	int
=	O
0	int
;	O
Enable_Alt_Char_Set	*(char)
=	O
NULL	O
;	O
}	O
else	O
SLtt_Has_Alt_Charset	int
=	O
1	int
;	O
if	O
(	O
(	O
SLtt_Has_Status_Line	int
==	O
-	O
1	int
)	O
&&	O
(	O
0	int
!=	O
(	O
SLtt_Has_Status_Line	int
=	O
TGETFLAG	O
(	O
"hs"	*(char)
)	O
)	O
)	O
)	O
{	O
Disable_Status_line_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ds"	*(char)
)	O
;	O
Return_From_Status_Line_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"fs"	*(char)
)	O
;	O
Goto_Status_Line_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ts"	*(char)
)	O
;	O
Num_Status_Line_Columns	int
=	O
SLtt_tgetnum	(*(char))->(int)
(	O
"ws"	*(char)
)	O
;	O
if	O
(	O
Num_Status_Line_Columns	int
<	O
0	int
)	O
Num_Status_Line_Columns	int
=	O
0	int
;	O
}	O
if	O
(	O
NULL	O
==	O
(	O
Norm_Vid_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"me"	*(char)
)	O
)	O
)	O
{	O
Norm_Vid_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"se"	*(char)
)	O
;	O
}	O
Cursor_Invisible_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"vi"	*(char)
)	O
;	O
Cursor_Visible_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"ve"	*(char)
)	O
;	O
Curs_F_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"RI"	*(char)
)	O
;	O
Automatic_Margins	int
=	O
TGETFLAG	O
(	O
"am"	*(char)
)	O
;	O
Has_HP_Glitch	int
=	O
TGETFLAG	O
(	O
"xs"	*(char)
)	O
;	O
if	O
(	O
Worthless_Highlight	int
==	O
0	int
)	O
{	O
Worthless_Highlight	int
=	O
(	O
SLtt_tgetnum	(*(char))->(int)
(	O
"sg"	*(char)
)	O
>	O
0	int
)	O
;	O
}	O
if	O
(	O
Worthless_Highlight	int
)	O
SLtt_Has_Alt_Charset	int
=	O
0	int
;	O
Reset_Color_String	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"op"	*(char)
)	O
;	O
Color_Fg_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"AF"	*(char)
)	O
;	O
if	O
(	O
Color_Fg_Str	*(char)
==	O
NULL	O
)	O
{	O
Color_Fg_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"Sf"	*(char)
)	O
;	O
}	O
Color_Bg_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"AB"	*(char)
)	O
;	O
if	O
(	O
Color_Bg_Str	*(char)
==	O
NULL	O
)	O
{	O
Color_Bg_Str	*(char)
=	O
SLtt_tgetstr	(*(char))->(*(char))
(	O
"Sb"	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
Max_Terminfo_Colors	int
=	O
SLtt_tgetnum	(*(char))->(int)
(	O
"Co"	*(char)
)	O
)	O
<	O
0	int
)	O
Max_Terminfo_Colors	int
=	O
8	int
;	O
if	O
(	O
(	O
Color_Bg_Str	*(char)
!=	O
NULL	O
)	O
&&	O
(	O
Color_Fg_Str	*(char)
!=	O
NULL	O
)	O
)	O
SLtt_Use_Ansi_Colors	int
=	O
1	int
;	O
else	O
{	O
Color_Fg_Str	*(char)
=	O
"\033[3%dm"	*(char)
;	O
Color_Bg_Str	*(char)
=	O
"\033[4%dm"	*(char)
;	O
Max_Terminfo_Colors	int
=	O
8	int
;	O
}	O
Can_Background_Color_Erase	int
=	O
TGETFLAG	O
(	O
"ut"	*(char)
)	O
;	O
if	O
(	O
Can_Background_Color_Erase	int
==	O
0	int
)	O
{	O
Can_Background_Color_Erase	int
=	O
(	O
Linux_Console	int
)	O
;	O
}	O
get_color_info	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
Cls_Str	*(char)
==	O
NULL	O
)	O
||	O
(	O
Curs_Pos_Str	*(char)
==	O
NULL	O
)	O
)	O
return	O
-	O
2	int
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_enable_cursor_keys	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
Vt100_Like	int
)	O
tt_write_string	(*(char))->(void)
(	O
"\033=\033[?1l"	*(char)
)	O
;	O
}	O
void	O
SLtt_set_term_vtxxx	(*(int))->(void)
(	O
int	O
*	O
vt100	*(int)
)	O
{	O
Norm_Vid_Str	*(char)
=	O
"\033[m"	*(char)
;	O
Scroll_R_Str	*(char)
=	O
"\033[%i%d;%dr"	*(char)
;	O
Cls_Str	*(char)
=	O
"\033[2J\033[H"	*(char)
;	O
Rev_Vid_Str	*(char)
=	O
"\033[7m"	*(char)
;	O
Bold_Vid_Str	*(char)
=	O
"\033[1m"	*(char)
;	O
Blink_Vid_Str	*(char)
=	O
"\033[5m"	*(char)
;	O
UnderLine_Vid_Str	*(char)
=	O
"\033[4m"	*(char)
;	O
Del_Eol_Str	*(char)
=	O
"\033[K"	*(char)
;	O
Del_Bol_Str	*(char)
=	O
"\033[1K"	*(char)
;	O
Rev_Scroll_Str	*(char)
=	O
"\033M"	*(char)
;	O
Curs_F_Str	*(char)
=	O
"\033[%dC"	*(char)
;	O
Curs_Pos_Str	*(char)
=	O
"\033[%i%d;%dH"	*(char)
;	O
if	O
(	O
(	O
vt100	*(int)
==	O
NULL	O
)	O
||	O
(	O
*	O
vt100	*(int)
==	O
0	int
)	O
)	O
{	O
Ins_Mode_Str	*(char)
=	O
"\033[4h"	*(char)
;	O
Eins_Mode_Str	*(char)
=	O
"\033[4l"	*(char)
;	O
Del_Char_Str	*(char)
=	O
"\033[P"	*(char)
;	O
Del_N_Lines_Str	*(char)
=	O
"\033[%dM"	*(char)
;	O
Add_N_Lines_Str	*(char)
=	O
"\033[%dL"	*(char)
;	O
SLtt_Term_Cannot_Insert	int
=	O
0	int
;	O
}	O
else	O
{	O
Del_N_Lines_Str	*(char)
=	O
NULL	O
;	O
Add_N_Lines_Str	*(char)
=	O
NULL	O
;	O
SLtt_Term_Cannot_Insert	int
=	O
1	int
;	O
}	O
SLtt_Term_Cannot_Scroll	int
=	O
0	int
;	O
}	O
int	O
SLtt_init_video	()->(int)
(	O
void	O
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
Term_Init_Str	*(char)
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Keypad_Init_Str	*(char)
)	O
;	O
SLtt_reset_scroll_region	()->(void)
(	O
)	O
;	O
SLtt_end_insert	()->(void)
(	O
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Enable_Alt_Char_Set	*(char)
)	O
;	O
Video_Initialized	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
SLtt_reset_video	()->(int)
(	O
void	O
)	O
{	O
SLtt_goto_rc	(int,int)->(void)
(	O
SLtt_Screen_Rows	int
-	O
1	int
,	O
0	int
)	O
;	O
Cursor_Set	int
=	O
0	int
;	O
SLtt_normal_video	()->(void)
(	O
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Norm_Vid_Str	*(char)
)	O
;	O
Current_Fgbg	long
=	O
0xFFFFFFFFU	int
;	O
SLtt_set_alt_char_set	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
{	O
if	O
(	O
Reset_Color_String	*(char)
==	O
NULL	O
)	O
{	O
SLtt_Char_Type	long
attr	long
;	O
if	O
(	O
-	O
1	int
!=	O
make_color_fgbg	(*(char),*(char),*(long))->(int)
(	O
NULL	O
,	O
NULL	O
,	O
&	O
attr	long
)	O
)	O
write_attributes	(long)->(void)
(	O
attr	long
)	O
;	O
else	O
tt_write_string	(*(char))->(void)
(	O
"\033[0m\033[m"	*(char)
)	O
;	O
}	O
else	O
tt_write_string	(*(char))->(void)
(	O
Reset_Color_String	*(char)
)	O
;	O
Current_Fgbg	long
=	O
0xFFFFFFFFU	int
;	O
}	O
SLtt_erase_line	()->(void)
(	O
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Keypad_Reset_Str	*(char)
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Term_Reset_Str	*(char)
)	O
;	O
if	O
(	O
Mouse_Mode	int
==	O
1	int
)	O
SLtt_set_mouse_mode	(int,int)->(int)
(	O
0	int
,	O
1	int
)	O
;	O
SLtt_flush_output	()->(int)
(	O
)	O
;	O
Video_Initialized	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_bold_video	()->(void)
(	O
void	O
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
Bold_Vid_Str	*(char)
)	O
;	O
}	O
int	O
SLtt_set_mouse_mode	(int,int)->(int)
(	O
int	O
mode	int
,	O
int	O
force	int
)	O
{	O
char	O
*	O
term	*(char)
;	O
if	O
(	O
force	int
==	O
0	int
)	O
{	O
if	O
(	O
NULL	O
==	O
(	O
term	*(char)
=	O
(	O
char	O
*	O
)	O
getenv	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
"xterm"	*(char)
,	O
term	*(char)
,	O
5	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
Mouse_Mode	int
=	O
(	O
mode	int
!=	O
0	int
)	O
;	O
if	O
(	O
mode	int
)	O
tt_write_string	(*(char))->(void)
(	O
"\033[?9h"	*(char)
)	O
;	O
else	O
tt_write_string	(*(char))->(void)
(	O
"\033[?9l"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_disable_status_line	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
SLtt_Has_Status_Line	int
>	O
0	int
)	O
{	O
tt_write_string	(*(char))->(void)
(	O
Disable_Status_line_Str	*(char)
)	O
;	O
SLtt_flush_output	()->(int)
(	O
)	O
;	O
}	O
}	O
int	O
SLtt_write_to_status_line	(*(char),int)->(int)
(	O
char	O
*	O
s	*(char)
,	O
int	O
col	int
)	O
{	O
if	O
(	O
(	O
SLtt_Has_Status_Line	int
<=	O
0	int
)	O
||	O
(	O
Goto_Status_Line_Str	*(char)
==	O
NULL	O
)	O
||	O
(	O
Return_From_Status_Line_Str	*(char)
==	O
NULL	O
)	O
)	O
return	O
-	O
1	int
;	O
tt_printf	(*(char),int,int)->(void)
(	O
Goto_Status_Line_Str	*(char)
,	O
col	int
,	O
0	int
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
s	*(char)
)	O
;	O
tt_write_string	(*(char))->(void)
(	O
Return_From_Status_Line_Str	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
void	O
SLtt_get_screen_size	()->(void)
(	O
void	O
)	O
{	O
int	O
r	*(struct)
=	O
0	int
,	O
c	int
=	O
0	int
;	O
struct	O
winsize	struct(short,short,short,short)
wind_struct	struct(short,short,short,short)
;	O
do	O
{	O
if	O
(	O
(	O
ioctl	(int,long)->(int)
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
&	O
wind_struct	struct(short,short,short,short)
)	O
==	O
0	int
)	O
||	O
(	O
ioctl	(int,long)->(int)
(	O
0	int
,	O
TIOCGWINSZ	int
,	O
&	O
wind_struct	struct(short,short,short,short)
)	O
==	O
0	int
)	O
||	O
(	O
ioctl	(int,long)->(int)
(	O
2	int
,	O
TIOCGWINSZ	int
,	O
&	O
wind_struct	struct(short,short,short,short)
)	O
==	O
0	int
)	O
)	O
{	O
c	int
=	O
(	O
int	O
)	O
wind_struct	struct(short,short,short,short)
.	O
ws_col	short
;	O
r	*(struct)
=	O
(	O
int	O
)	O
wind_struct	struct(short,short,short,short)
.	O
ws_row	short
;	O
break	O
;	O
}	O
}	O
while	O
(	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
r	*(struct)
<=	O
0	int
)	O
{	O
char	O
*	O
s	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LINES"	*(char)
)	O
;	O
if	O
(	O
s	*(char)
!=	O
NULL	O
)	O
r	*(struct)
=	O
atoi	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
}	O
if	O
(	O
c	int
<=	O
0	int
)	O
{	O
char	O
*	O
s	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"COLUMNS"	*(char)
)	O
;	O
if	O
(	O
s	*(char)
!=	O
NULL	O
)	O
c	int
=	O
atoi	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
r	*(struct)
<=	O
0	int
)	O
||	O
(	O
r	*(struct)
>	O
SLTT_MAX_SCREEN_ROWS	int
)	O
)	O
r	*(struct)
=	O
24	int
;	O
if	O
(	O
(	O
c	int
<=	O
0	int
)	O
||	O
(	O
c	int
>	O
SLTT_MAX_SCREEN_COLS	int
)	O
)	O
c	int
=	O
80	int
;	O
SLtt_Screen_Rows	int
=	O
r	*(struct)
;	O
SLtt_Screen_Cols	int
=	O
c	int
;	O
}	O
int	O
_pSLtt_get_bce_color_offset	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
(	O
SLtt_Use_Ansi_Colors	int
==	O
0	int
)	O
||	O
Can_Background_Color_Erase	int
||	O
SLtt_Use_Blink_For_ACS	int
)	O
Bce_Color_Offset	int
=	O
0	int
;	O
else	O
{	O
SLtt_Char_Type	long
fgbg	long
=	O
get_brush_fgbg	(int)->(long)
(	O
0	int
)	O
;	O
if	O
(	O
GET_BG	O
(	O
fgbg	long
)	O
==	O
SLSMG_COLOR_DEFAULT	int
)	O
Bce_Color_Offset	int
=	O
0	int
;	O
else	O
Bce_Color_Offset	int
=	O
1	int
;	O
}	O
return	O
Bce_Color_Offset	int
;	O
}	O
int	O
SLtt_utf8_enable	(int)->(int)
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
==	O
-	O
1	int
)	O
mode	int
=	O
_pSLutf8_mode	int
;	O
return	O
_pSLtt_UTF8_Mode	int
=	O
mode	int
;	O
}	O
int	O
SLtt_is_utf8_mode	()->(int)
(	O
void	O
)	O
{	O
int	O
mode	int
=	O
_pSLtt_UTF8_Mode	int
;	O
if	O
(	O
mode	int
==	O
-	O
1	int
)	O
mode	int
=	O
_pSLutf8_mode	int
;	O
return	O
mode	int
;	O
}	O
