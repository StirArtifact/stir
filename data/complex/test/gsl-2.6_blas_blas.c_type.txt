int	O
gsl_blas_sdsdot	(float,*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(float))->(int)
(	O
float	O
alpha	float
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
float	O
*	O
result	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
*	O
result	*(float)
=	O
cblas_sdsdot	(int,float,*(float),int,*(float),int)->(float)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dsdot	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(double))->(int)
(	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
double	O
*	O
result	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
*	O
result	*(float)
=	O
cblas_dsdot	(int,*(float),int,*(float),int)->(double)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_sdot	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(float))->(int)
(	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
float	O
*	O
result	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
*	O
result	*(float)
=	O
cblas_sdot	(int,*(float),int,*(float),int)->(float)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_ddot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(double))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
double	O
*	O
result	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
*	O
result	*(float)
=	O
cblas_ddot	(int,*(double),int,*(double),int)->(double)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_cdotu	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(array(float))))->(int)
(	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
gsl_complex_float	struct(array(float))
*	O
dotu	*(void)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_cdotu_sub	(int,*(void),int,*(void),int,*(void))->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
dotu	*(void)
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_cdotc	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(array(float))))->(int)
(	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
gsl_complex_float	struct(array(float))
*	O
dotc	*(void)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_cdotc_sub	(int,*(void),int,*(void),int,*(void))->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
dotc	*(void)
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zdotu	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))))->(int)
(	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
gsl_complex	struct(array(double))
*	O
dotu	*(void)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_zdotu_sub	(int,*(void),int,*(void),int,*(void))->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
dotu	*(void)
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zdotc	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(array(double))))->(int)
(	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
gsl_complex	struct(array(double))
*	O
dotc	*(void)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_zdotc_sub	(int,*(void),int,*(void),int,*(void))->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
dotc	*(void)
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
float	O
gsl_blas_snrm2	(*(struct(long,long,*(float),*(struct(long,*`)),int)))->(float)
(	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_snrm2	(int,*(float),int)->(float)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
double	O
gsl_blas_dnrm2	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_dnrm2	(int,*(double),int)->(double)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
float	O
gsl_blas_scnrm2	(*(struct(long,long,*(float),*(struct(long,*`)),int)))->(float)
(	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_scnrm2	(int,*(void),int)->(float)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
double	O
gsl_blas_dznrm2	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_dznrm2	(int,*(void),int)->(double)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
float	O
gsl_blas_sasum	(*(struct(long,long,*(float),*(struct(long,*`)),int)))->(float)
(	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_sasum	(int,*(float),int)->(float)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
double	O
gsl_blas_dasum	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_dasum	(int,*(double),int)->(double)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
float	O
gsl_blas_scasum	(*(struct(long,long,*(float),*(struct(long,*`)),int)))->(float)
(	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_scasum	(int,*(void),int)->(float)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
double	O
gsl_blas_dzasum	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_dzasum	(int,*(void),int)->(double)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
CBLAS_INDEX_t	long
gsl_blas_isamax	(*(struct(long,long,*(float),*(struct(long,*`)),int)))->(long)
(	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_isamax	(int,*(float),int)->(long)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
CBLAS_INDEX_t	long
gsl_blas_idamax	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_idamax	(int,*(double),int)->(long)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
CBLAS_INDEX_t	long
gsl_blas_icamax	(*(struct(long,long,*(float),*(struct(long,*`)),int)))->(long)
(	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_icamax	(int,*(void),int)->(long)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
CBLAS_INDEX_t	long
gsl_blas_izamax	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
return	O
cblas_izamax	(int,*(void),int)->(long)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
int	O
gsl_blas_sswap	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_sswap	(int,*(float),int,*(float),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dswap	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_dswap	(int,*(double),int,*(double),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
;	O
}	O
int	O
gsl_blas_cswap	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_cswap	(int,*(void),int,*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zswap	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_zswap	(int,*(void),int,*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_scopy	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_scopy	(int,*(float),int,*(float),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dcopy	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_dcopy	(int,*(double),int,*(double),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_ccopy	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_ccopy	(int,*(void),int,*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zcopy	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_zcopy	(int,*(void),int,*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_saxpy	(float,*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
float	O
alpha	float
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_saxpy	(int,float,*(float),int,*(float),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_daxpy	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
double	O
alpha	float
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_daxpy	(int,double,*(double),int,*(double),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_caxpy	(struct(array(float)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_caxpy	(int,*(void),*(void),int,*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zaxpy	(struct(array(double)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_zaxpy	(int,*(void),*(void),int,*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_srotg	(array(float),array(float),array(float),array(float))->(int)
(	O
float	O
a	double
[	O
]	O
,	O
float	O
b	double
[	O
]	O
,	O
float	O
c	*(float)
[	O
]	O
,	O
float	O
s	*(float)
[	O
]	O
)	O
{	O
cblas_srotg	(*(float),*(float),*(float),*(float))->(void)
(	O
a	double
,	O
b	double
,	O
c	*(float)
,	O
s	*(float)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_drotg	(array(double),array(double),array(double),array(double))->(int)
(	O
double	O
a	double
[	O
]	O
,	O
double	O
b	double
[	O
]	O
,	O
double	O
c	*(float)
[	O
]	O
,	O
double	O
s	*(float)
[	O
]	O
)	O
{	O
cblas_drotg	(*(double),*(double),*(double),*(double))->(void)
(	O
a	double
,	O
b	double
,	O
c	*(float)
,	O
s	*(float)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_srot	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),float,float)->(int)
(	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
float	O
c	*(float)
,	O
float	O
s	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_srot	(int,*(float),int,*(float),int,float,float)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
c	*(float)
,	O
s	*(float)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_drot	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,double)->(int)
(	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
const	O
double	O
c	*(float)
,	O
const	O
double	O
s	*(float)
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_drot	(int,*(double),int,*(double),int,double,double)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
c	*(float)
,	O
s	*(float)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_srotmg	(array(float),array(float),array(float),float,array(float))->(int)
(	O
float	O
d1	*(float)
[	O
]	O
,	O
float	O
d2	*(float)
[	O
]	O
,	O
float	O
b1	*(float)
[	O
]	O
,	O
float	O
b2	float
,	O
float	O
P	*(float)
[	O
]	O
)	O
{	O
cblas_srotmg	(*(float),*(float),*(float),float,*(float))->(void)
(	O
d1	*(float)
,	O
d2	*(float)
,	O
b1	*(float)
,	O
b2	float
,	O
P	*(float)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_drotmg	(array(double),array(double),array(double),double,array(double))->(int)
(	O
double	O
d1	*(float)
[	O
]	O
,	O
double	O
d2	*(float)
[	O
]	O
,	O
double	O
b1	*(float)
[	O
]	O
,	O
double	O
b2	float
,	O
double	O
P	*(float)
[	O
]	O
)	O
{	O
cblas_drotmg	(*(double),*(double),*(double),double,*(double))->(void)
(	O
d1	*(float)
,	O
d2	*(float)
,	O
b1	*(float)
,	O
b2	float
,	O
P	*(float)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_srotm	(*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),array(float))->(int)
(	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
const	O
float	O
P	*(float)
[	O
]	O
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_srotm	(int,*(float),int,*(float),int,*(float))->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
P	*(float)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_drotm	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),array(double))->(int)
(	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
const	O
double	O
P	*(float)
[	O
]	O
)	O
{	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
Y	*(float)
->	O
size	long
)	O
{	O
cblas_drotm	(int,*(double),int,*(double),int,*(double))->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
P	*(float)
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
void	O
gsl_blas_sscal	(float,*(struct(long,long,*(float),*(struct(long,*`)),int)))->(void)
(	O
float	O
alpha	float
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
cblas_sscal	(int,float,*(float),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
void	O
gsl_blas_dscal	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
double	O
alpha	float
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
cblas_dscal	(int,double,*(double),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
void	O
gsl_blas_cscal	(struct(array(float)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(void)
(	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
cblas_cscal	(int,*(void),*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
void	O
gsl_blas_zscal	(struct(array(double)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
cblas_zscal	(int,*(void),*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
void	O
gsl_blas_csscal	(float,*(struct(long,long,*(float),*(struct(long,*`)),int)))->(void)
(	O
float	O
alpha	float
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
cblas_csscal	(int,float,*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
void	O
gsl_blas_zdscal	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
double	O
alpha	float
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
cblas_zdscal	(int,double,*(void),int)->(void)
(	O
INT	O
(	O
X	*(float)
->	O
size	long
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
}	O
int	O
gsl_blas_sgemv	(enum(int,int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),float,*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
float	O
beta	float
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
&&	O
N	int
==	O
X	*(float)
->	O
size	long
&&	O
M	int
==	O
Y	*(float)
->	O
size	long
)	O
||	O
(	O
TransA	enum(int,int,int)
==	O
CblasTrans	int
&&	O
M	int
==	O
X	*(float)
->	O
size	long
&&	O
N	int
==	O
Y	*(float)
->	O
size	long
)	O
)	O
{	O
cblas_sgemv	(enum(int,int),enum(int,int,int),int,int,float,*(float),int,*(float),int,float,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
TransA	enum(int,int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
beta	float
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dgemv	(enum(int,int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
double	O
beta	float
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
&&	O
N	int
==	O
X	*(float)
->	O
size	long
&&	O
M	int
==	O
Y	*(float)
->	O
size	long
)	O
||	O
(	O
TransA	enum(int,int,int)
==	O
CblasTrans	int
&&	O
M	int
==	O
X	*(float)
->	O
size	long
&&	O
N	int
==	O
Y	*(float)
->	O
size	long
)	O
)	O
{	O
cblas_dgemv	(enum(int,int),enum(int,int,int),int,int,double,*(double),int,*(double),int,double,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
TransA	enum(int,int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
beta	float
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_cgemv	(enum(int,int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),struct(array(float)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_complex_float	struct(array(float))
beta	float
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
&&	O
N	int
==	O
X	*(float)
->	O
size	long
&&	O
M	int
==	O
Y	*(float)
->	O
size	long
)	O
||	O
(	O
TransA	enum(int,int,int)
==	O
CblasTrans	int
&&	O
M	int
==	O
X	*(float)
->	O
size	long
&&	O
N	int
==	O
Y	*(float)
->	O
size	long
)	O
||	O
(	O
TransA	enum(int,int,int)
==	O
CblasConjTrans	int
&&	O
M	int
==	O
X	*(float)
->	O
size	long
&&	O
N	int
==	O
Y	*(float)
->	O
size	long
)	O
)	O
{	O
cblas_cgemv	(enum(int,int),enum(int,int,int),int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
TransA	enum(int,int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zgemv	(enum(int,int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),struct(array(double)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_complex	struct(array(double))
beta	float
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
&&	O
N	int
==	O
X	*(float)
->	O
size	long
&&	O
M	int
==	O
Y	*(float)
->	O
size	long
)	O
||	O
(	O
TransA	enum(int,int,int)
==	O
CblasTrans	int
&&	O
M	int
==	O
X	*(float)
->	O
size	long
&&	O
N	int
==	O
Y	*(float)
->	O
size	long
)	O
||	O
(	O
TransA	enum(int,int,int)
==	O
CblasConjTrans	int
&&	O
M	int
==	O
X	*(float)
->	O
size	long
&&	O
N	int
==	O
Y	*(float)
->	O
size	long
)	O
)	O
{	O
cblas_zgemv	(enum(int,int),enum(int,int,int),int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
TransA	enum(int,int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_chemv	(enum(int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),struct(array(float)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_complex_float	struct(array(float))
beta	float
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
||	O
N	int
!=	O
Y	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_chemv	(enum(int,int),enum(int,int),int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_zhemv	(enum(int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),struct(array(double)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_complex	struct(array(double))
beta	float
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
||	O
N	int
!=	O
Y	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_zhemv	(enum(int,int),enum(int,int),int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_ssymv	(enum(int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),float,*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
float	O
beta	float
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
||	O
N	int
!=	O
Y	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ssymv	(enum(int,int),enum(int,int),int,float,*(float),int,*(float),int,float,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
beta	float
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_dsymv	(enum(int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
double	O
beta	float
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
||	O
N	int
!=	O
Y	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_dsymv	(enum(int,int),enum(int,int),int,double,*(double),int,*(double),int,double,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
beta	float
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_strmv	(enum(int,int),enum(int,int,int),enum(int,int),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_strmv	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,*(float),int,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_dtrmv	(enum(int,int),enum(int,int,int),enum(int,int),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_dtrmv	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,*(double),int,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_ctrmv	(enum(int,int),enum(int,int,int),enum(int,int),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ctrmv	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_ztrmv	(enum(int,int),enum(int,int,int),enum(int,int),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ztrmv	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_strsv	(enum(int,int),enum(int,int,int),enum(int,int),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_strsv	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,*(float),int,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_dtrsv	(enum(int,int),enum(int,int,int),enum(int,int),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_dtrsv	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,*(double),int,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_ctrsv	(enum(int,int),enum(int,int,int),enum(int,int),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ctrsv	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_ztrsv	(enum(int,int),enum(int,int,int),enum(int,int),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
X	*(float)
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ztrsv	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_sger	(float,*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
float	O
alpha	float
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
M	int
&&	O
Y	*(float)
->	O
size	long
==	O
N	int
)	O
{	O
cblas_sger	(enum(int,int),int,int,float,*(float),int,*(float),int,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dger	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
double	O
alpha	float
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
M	int
&&	O
Y	*(float)
->	O
size	long
==	O
N	int
)	O
{	O
cblas_dger	(enum(int,int),int,int,double,*(double),int,*(double),int,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_cgeru	(struct(array(float)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
M	int
&&	O
Y	*(float)
->	O
size	long
==	O
N	int
)	O
{	O
cblas_cgeru	(enum(int,int),int,int,*(void),*(void),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zgeru	(struct(array(double)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
M	int
&&	O
Y	*(float)
->	O
size	long
==	O
N	int
)	O
{	O
cblas_zgeru	(enum(int,int),int,int,*(void),*(void),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_cgerc	(struct(array(float)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
M	int
&&	O
Y	*(float)
->	O
size	long
==	O
N	int
)	O
{	O
cblas_cgerc	(enum(int,int),int,int,*(void),*(void),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zgerc	(struct(array(double)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
X	*(float)
->	O
size	long
==	O
M	int
&&	O
Y	*(float)
->	O
size	long
==	O
N	int
)	O
{	O
cblas_zgerc	(enum(int,int),int,int,*(void),*(void),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_cher	(enum(int,int),float,*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
X	*(float)
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_cher	(enum(int,int),enum(int,int),int,float,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_zher	(enum(int,int),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
X	*(float)
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_zher	(enum(int,int),enum(int,int),int,double,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_cher2	(enum(int,int),struct(array(float)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
X	*(float)
->	O
size	long
!=	O
N	int
||	O
Y	*(float)
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_cher2	(enum(int,int),enum(int,int),int,*(void),*(void),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_zher2	(enum(int,int),struct(array(double)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_complex	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
X	*(float)
->	O
size	long
!=	O
N	int
||	O
Y	*(float)
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_zher2	(enum(int,int),enum(int,int),int,*(void),*(void),int,*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_ssyr	(enum(int,int),float,*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
X	*(float)
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ssyr	(enum(int,int),enum(int,int),int,float,*(float),int,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_dsyr	(enum(int,int),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
X	*(float)
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_dsyr	(enum(int,int),enum(int,int),int,double,*(double),int,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_ssyr2	(enum(int,int),float,*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector_float	struct(long,long,*(float),*(struct(long,*(float))),int)
*	O
Y	*(float)
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
X	*(float)
->	O
size	long
!=	O
N	int
||	O
Y	*(float)
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ssyr2	(enum(int,int),enum(int,int),int,float,*(float),int,*(float),int,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_dsyr2	(enum(int,int),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
X	*(float)
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Y	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
X	*(float)
->	O
size	long
!=	O
N	int
||	O
Y	*(float)
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_dsyr2	(enum(int,int),enum(int,int),int,double,*(double),int,*(double),int,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
X	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
X	*(float)
->	O
stride	long
)	O
,	O
Y	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
Y	*(float)
->	O
stride	long
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_sgemm	(enum(int,int,int),enum(int,int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransB	enum(int,int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
,	O
float	O
beta	float
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
TransB	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
TransB	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
{	O
cblas_sgemm	(enum(int,int),enum(int,int,int),enum(int,int,int),int,int,int,float,*(float),int,*(float),int,float,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
TransA	enum(int,int,int)
,	O
TransB	enum(int,int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dgemm	(enum(int,int,int),enum(int,int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransB	enum(int,int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
double	O
beta	float
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
TransB	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
TransB	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
{	O
cblas_dgemm	(enum(int,int),enum(int,int,int),enum(int,int,int),int,int,int,double,*(double),int,*(double),int,double,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
TransA	enum(int,int,int)
,	O
TransB	enum(int,int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_cgemm	(enum(int,int,int),enum(int,int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransB	enum(int,int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
,	O
const	O
gsl_complex_float	struct(array(float))
beta	float
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
TransB	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
TransB	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
{	O
cblas_cgemm	(enum(int,int),enum(int,int,int),enum(int,int,int),int,int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
TransA	enum(int,int,int)
,	O
TransB	enum(int,int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zgemm	(enum(int,int,int),enum(int,int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransB	enum(int,int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
const	O
gsl_complex	struct(array(double))
beta	float
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
TransA	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
TransB	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
TransB	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
{	O
cblas_zgemm	(enum(int,int),enum(int,int,int),enum(int,int,int),int,int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
TransA	enum(int,int,int)
,	O
TransB	enum(int,int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_ssymm	(enum(int,int),enum(int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
,	O
float	O
beta	float
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MB	long
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NB	long
=	O
B	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
(	O
M	int
==	O
MB	long
&&	O
N	int
==	O
NA	long
&&	O
NB	long
==	O
MA	long
)	O
)	O
)	O
{	O
cblas_ssymm	(enum(int,int),enum(int,int),enum(int,int),int,int,float,*(float),int,*(float),int,float,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dsymm	(enum(int,int),enum(int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
double	O
beta	float
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MB	long
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NB	long
=	O
B	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
(	O
M	int
==	O
MB	long
&&	O
N	int
==	O
NA	long
&&	O
NB	long
==	O
MA	long
)	O
)	O
)	O
{	O
cblas_dsymm	(enum(int,int),enum(int,int),enum(int,int),int,int,double,*(double),int,*(double),int,double,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_csymm	(enum(int,int),enum(int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
,	O
const	O
gsl_complex_float	struct(array(float))
beta	float
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MB	long
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NB	long
=	O
B	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
(	O
M	int
==	O
MB	long
&&	O
N	int
==	O
NA	long
&&	O
NB	long
==	O
MA	long
)	O
)	O
)	O
{	O
cblas_csymm	(enum(int,int),enum(int,int),enum(int,int),int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zsymm	(enum(int,int),enum(int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
const	O
gsl_complex	struct(array(double))
beta	float
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MB	long
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NB	long
=	O
B	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
(	O
M	int
==	O
MB	long
&&	O
N	int
==	O
NA	long
&&	O
NB	long
==	O
MA	long
)	O
)	O
)	O
{	O
cblas_zsymm	(enum(int,int),enum(int,int),enum(int,int),int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_chemm	(enum(int,int),enum(int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
,	O
const	O
gsl_complex_float	struct(array(float))
beta	float
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MB	long
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NB	long
=	O
B	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
(	O
M	int
==	O
MB	long
&&	O
N	int
==	O
NA	long
&&	O
NB	long
==	O
MA	long
)	O
)	O
)	O
{	O
cblas_chemm	(enum(int,int),enum(int,int),enum(int,int),int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_zhemm	(enum(int,int),enum(int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
const	O
gsl_complex	struct(array(double))
beta	float
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MB	long
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NB	long
=	O
B	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
(	O
M	int
==	O
MA	long
&&	O
N	int
==	O
NB	long
&&	O
NA	long
==	O
MB	long
)	O
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
(	O
M	int
==	O
MB	long
&&	O
N	int
==	O
NA	long
&&	O
NB	long
==	O
MA	long
)	O
)	O
)	O
{	O
cblas_zhemm	(enum(int,int),enum(int,int),enum(int,int),int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_ssyrk	(enum(int,int),enum(int,int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
float	O
beta	float
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
J	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
K	int
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
J	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ssyrk	(enum(int,int),enum(int,int),enum(int,int,int),int,int,float,*(float),int,float,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
K	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_dsyrk	(enum(int,int),enum(int,int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
double	O
beta	float
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
J	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
K	int
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
J	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_dsyrk	(enum(int,int),enum(int,int),enum(int,int,int),int,int,double,*(double),int,double,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
K	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_csyrk	(enum(int,int),enum(int,int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_complex_float	struct(array(float))
beta	float
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
J	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
K	int
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
J	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_csyrk	(enum(int,int),enum(int,int),enum(int,int,int),int,int,*(void),*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
K	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_zsyrk	(enum(int,int),enum(int,int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_complex	struct(array(double))
beta	float
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
J	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
K	int
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
J	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_zsyrk	(enum(int,int),enum(int,int),enum(int,int,int),int,int,*(void),*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
K	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_cherk	(enum(int,int),enum(int,int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
float	O
beta	float
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
J	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
K	int
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
J	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_cherk	(enum(int,int),enum(int,int),enum(int,int,int),int,int,float,*(void),int,float,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
K	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_zherk	(enum(int,int),enum(int,int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
double	O
beta	float
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
J	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
K	int
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
J	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_zherk	(enum(int,int),enum(int,int),enum(int,int,int),int,int,double,*(void),int,double,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
K	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_ssyr2k	(enum(int,int),enum(int,int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
,	O
float	O
beta	float
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
MA	long
||	O
N	int
!=	O
MB	long
||	O
NA	long
!=	O
NB	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_ssyr2k	(enum(int,int),enum(int,int),enum(int,int,int),int,int,float,*(float),int,*(float),int,float,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_dsyr2k	(enum(int,int),enum(int,int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
double	O
beta	float
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
MA	long
||	O
N	int
!=	O
MB	long
||	O
NA	long
!=	O
NB	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_dsyr2k	(enum(int,int),enum(int,int),enum(int,int,int),int,int,double,*(double),int,*(double),int,double,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_csyr2k	(enum(int,int),enum(int,int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
,	O
const	O
gsl_complex_float	struct(array(float))
beta	float
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
MA	long
||	O
N	int
!=	O
MB	long
||	O
NA	long
!=	O
NB	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_csyr2k	(enum(int,int),enum(int,int),enum(int,int,int),int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_zsyr2k	(enum(int,int),enum(int,int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
const	O
gsl_complex	struct(array(double))
beta	float
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
MA	long
||	O
N	int
!=	O
MB	long
||	O
NA	long
!=	O
NB	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_zsyr2k	(enum(int,int),enum(int,int),enum(int,int,int),int,int,*(void),*(void),int,*(void),int,*(void),*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
beta	float
)	O
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_cher2k	(enum(int,int),enum(int,int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
,	O
float	O
beta	float
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
MA	long
||	O
N	int
!=	O
MB	long
||	O
NA	long
!=	O
NB	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_cher2k	(enum(int,int),enum(int,int),enum(int,int,int),int,int,*(void),*(void),int,*(void),int,float,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_zher2k	(enum(int,int),enum(int,int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
Trans	enum(int,int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
double	O
beta	float
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
C	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
C	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
C	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size1	long
:	O
A	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NA	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
A	*(float)
->	O
size2	long
:	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
MB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size1	long
:	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
NB	long
=	O
(	O
Trans	enum(int,int,int)
==	O
CblasNoTrans	int
)	O
?	O
B	*(float)
->	O
size2	long
:	O
B	*(float)
->	O
size1	long
;	O
if	O
(	O
M	int
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix C must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
MA	long
||	O
N	int
!=	O
MB	long
||	O
NA	long
!=	O
NB	long
)	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
cblas_zher2k	(enum(int,int),enum(int,int),enum(int,int,int),int,int,*(void),*(void),int,*(void),int,double,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Uplo	enum(int,int)
,	O
Trans	enum(int,int,int)
,	O
INT	O
(	O
N	int
)	O
,	O
INT	O
(	O
NA	long
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
,	O
beta	float
,	O
C	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
C	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_blas_strmm	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
M	int
==	O
MA	long
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
N	int
==	O
MA	long
)	O
)	O
{	O
cblas_strmm	(enum(int,int),enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,int,float,*(float),int,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dtrmm	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
M	int
==	O
MA	long
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
N	int
==	O
MA	long
)	O
)	O
{	O
cblas_dtrmm	(enum(int,int),enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,int,double,*(double),int,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_ctrmm	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
M	int
==	O
MA	long
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
N	int
==	O
MA	long
)	O
)	O
{	O
cblas_ctrmm	(enum(int,int),enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,int,*(void),*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_ztrmm	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
M	int
==	O
MA	long
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
N	int
==	O
MA	long
)	O
)	O
{	O
cblas_ztrmm	(enum(int,int),enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,int,*(void),*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_strsm	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),float,*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
float	O
alpha	float
,	O
const	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
gsl_matrix_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
M	int
==	O
MA	long
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
N	int
==	O
MA	long
)	O
)	O
{	O
cblas_strsm	(enum(int,int),enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,int,float,*(float),int,*(float),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_dtrsm	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
double	O
alpha	float
,	O
const	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
M	int
==	O
MA	long
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
N	int
==	O
MA	long
)	O
)	O
{	O
cblas_dtrsm	(enum(int,int),enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,int,double,*(double),int,*(double),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
alpha	float
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_ctrsm	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),struct(array(float)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)),*(struct(long,long,long,*(float),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_complex_float	struct(array(float))
alpha	float
,	O
const	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
A	*(float)
,	O
gsl_matrix_complex_float	struct(long,long,long,*(float),*(struct(long,*(float))),int)
*	O
B	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
M	int
==	O
MA	long
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
N	int
==	O
MA	long
)	O
)	O
{	O
cblas_ctrsm	(enum(int,int),enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,int,*(void),*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
int	O
gsl_blas_ztrsm	(enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),struct(array(double)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CBLAS_SIDE_t	enum(int,int)
Side	enum(int,int)
,	O
CBLAS_UPLO_t	enum(int,int)
Uplo	enum(int,int)
,	O
CBLAS_TRANSPOSE_t	enum(int,int,int)
TransA	enum(int,int,int)
,	O
CBLAS_DIAG_t	enum(int,int)
Diag	enum(int,int)
,	O
const	O
gsl_complex	struct(array(double))
alpha	float
,	O
const	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
A	*(float)
,	O
gsl_matrix_complex	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
)	O
{	O
const	O
size_t	long
M	int
=	O
B	*(float)
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
B	*(float)
->	O
size2	long
;	O
const	O
size_t	long
MA	long
=	O
A	*(float)
->	O
size1	long
;	O
const	O
size_t	long
NA	long
=	O
A	*(float)
->	O
size2	long
;	O
if	O
(	O
MA	long
!=	O
NA	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix A must be square"	*(char)
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
if	O
(	O
(	O
Side	enum(int,int)
==	O
CblasLeft	int
&&	O
M	int
==	O
MA	long
)	O
||	O
(	O
Side	enum(int,int)
==	O
CblasRight	int
&&	O
N	int
==	O
MA	long
)	O
)	O
{	O
cblas_ztrsm	(enum(int,int),enum(int,int),enum(int,int),enum(int,int,int),enum(int,int),int,int,*(void),*(void),int,*(void),int)->(void)
(	O
CblasRowMajor	int
,	O
Side	enum(int,int)
,	O
Uplo	enum(int,int)
,	O
TransA	enum(int,int,int)
,	O
Diag	enum(int,int)
,	O
INT	O
(	O
M	int
)	O
,	O
INT	O
(	O
N	int
)	O
,	O
GSL_COMPLEX_P	O
(	O
&	O
alpha	float
)	O
,	O
A	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
A	*(float)
->	O
tda	long
)	O
,	O
B	*(float)
->	O
data	*(long double)
,	O
INT	O
(	O
B	*(float)
->	O
tda	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"invalid length"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
}	O
