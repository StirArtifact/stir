static	O
int	O
crash_flags	int
=	O
RB_AUTOBOOT	O
;	O
static	O
int	O
verbose	int
=	O
0	int
;	O
const	O
char	O
*	O
argp_program_version	*(char)
=	O
STANDARD_HURD_VERSION	()->(int)
(	O
startup	int
)	O
;	O
static	O
struct	O
argp_option	O
options	int
[	O
]	O
=	O
{	O
{	O
"single-user"	*(char)
,	O
's'	O
,	O
0	int
,	O
0	int
,	O
"Startup system in single-user mode"	*(char)
}	O
,	O
{	O
"query"	*(char)
,	O
'q'	O
,	O
0	int
,	O
0	int
,	O
"Ask for the names of servers to start"	*(char)
}	O
,	O
{	O
"init-name"	*(char)
,	O
'n'	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"crash-debug"	*(char)
,	O
'H'	O
,	O
0	int
,	O
0	int
,	O
"On system crash, go to kernel debugger"	*(char)
}	O
,	O
{	O
"debug"	*(char)
,	O
'd'	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"fake-boot"	*(char)
,	O
'f'	O
,	O
0	int
,	O
0	int
,	O
"This hurd hasn't been booted on the raw machine"	*(char)
}	O
,	O
{	O
"verbose"	*(char)
,	O
'v'	O
,	O
0	int
,	O
0	int
,	O
"be verbose"	*(char)
}	O
,	O
{	O
0	int
,	O
'x'	O
,	O
0	int
,	O
OPTION_HIDDEN	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
char	O
doc	array(char)
[	O
]	O
=	O
"Start and maintain hurd core servers and system run state"	*(char)
;	O
static	O
int	O
booted	int
;	O
struct	O
ntfy_task	struct(int,*(struct(int,*(struct(int,*(struct`),*(char))),*(char))),*(char))
{	O
mach_port_t	O
notify_port	int
;	O
struct	O
ntfy_task	struct(int,*(struct(int,*(struct(int,*(struct`),*(char))),*(char))),*(char))
*	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
char	O
*	O
name	*(char)
;	O
}	O
;	O
struct	O
ess_task	struct(*(struct(*(struct(*(struct`),int,*(char))),int,*(char))),int,*(char))
{	O
struct	O
ess_task	struct(*(struct(*(struct(*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
task_t	O
task_port	int
;	O
char	O
*	O
name	*(char)
;	O
}	O
;	O
static	O
struct	O
ess_task	struct(*(struct(*(struct(*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
ess_tasks	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
;	O
static	O
struct	O
ntfy_task	struct(int,*(struct(int,*(struct(int,*(struct`),*(char))),*(char))),*(char))
*	O
ntfy_tasks	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
static	O
mach_port_t	O
startup	int
;	O
static	O
mach_port_t	O
host_priv	int
,	O
device_master	O
;	O
static	O
int	O
bootstrap_args	int
=	O
0	int
;	O
static	O
mach_port_t	O
procreply	int
,	O
authreply	O
;	O
static	O
mach_msg_type_name_t	O
procreplytype	int
,	O
authreplytype	O
;	O
static	O
mach_port_t	O
authserver	int
;	O
static	O
mach_port_t	O
procserver	int
;	O
static	O
mach_port_t	O
bootport	int
;	O
static	O
int	O
fakeboot	int
;	O
static	O
task_t	O
authtask	int
,	O
proctask	O
,	O
fstask	O
;	O
static	O
mach_port_t	O
default_ports	int
[	O
INIT_PORT_MAX	O
]	O
;	O
static	O
mach_port_t	O
default_dtable	array(int)
[	O
3	int
]	O
;	O
static	O
int	O
default_ints	int
[	O
INIT_INT_MAX	O
]	O
;	O
static	O
char	O
*	O
*	O
global_argv	*(*(char))
;	O
static	O
char	O
*	O
startup_envz	*(char)
;	O
static	O
size_t	O
startup_envz_len	int
;	O
void	O
launch_system	()->(void)
(	O
void	O
)	O
;	O
void	O
process_signal	(int)->(void)
(	O
int	O
signo	int
)	O
;	O
static	O
int	O
getstring	(*(char),int)->(int)
(	O
char	O
*	O
buf	*(char)
,	O
size_t	O
bufsize	int
)	O
{	O
if	O
(	O
fgets	()->(int)
(	O
buf	*(char)
,	O
bufsize	int
,	O
stdin	O
)	O
!=	O
NULL	O
&&	O
buf	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
size_t	O
len	*(int)
=	O
strlen	O
(	O
buf	*(char)
)	O
;	O
if	O
(	O
buf	*(char)
[	O
len	*(int)
-	O
1	int
]	O
==	O
'\n'	O
||	O
buf	*(char)
[	O
len	*(int)
-	O
1	int
]	O
==	O
'\r'	O
)	O
buf	*(char)
[	O
len	*(int)
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
reboot_mach	(int)->(void)
(	O
int	O
flags	int
)	O
{	O
if	O
(	O
fakeboot	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: Would %s Mach with flags %#x\n"	*(char)
,	O
program_invocation_short_name	O
,	O
BOOT	O
(	O
flags	int
)	O
,	O
flags	int
)	O
;	O
exit	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
error_t	O
err	int
;	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: %sing Mach (flags %#x)...\n"	*(char)
,	O
program_invocation_short_name	O
,	O
BOOT	O
(	O
flags	int
)	O
,	O
flags	int
)	O
;	O
sleep	()->(int)
(	O
5	int
)	O
;	O
while	O
(	O
(	O
err	int
=	O
host_reboot	()->(int)
(	O
host_priv	int
,	O
flags	int
)	O
)	O
)	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"reboot"	*(char)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
;	O
}	O
}	O
void	O
crash_mach	()->(void)
(	O
void	O
)	O
{	O
reboot_mach	(int)->(void)
(	O
crash_flags	int
)	O
;	O
}	O
void	O
notify_shutdown	(*(char))->(void)
(	O
const	O
char	O
*	O
msg	*(char)
)	O
{	O
struct	O
ntfy_task	struct(int,*(struct(int,*(struct(int,*(struct`),*(char))),*(char))),*(char))
*	O
n	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
for	O
(	O
n	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
ntfy_tasks	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
n	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
!=	O
NULL	O
;	O
n	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
n	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
)	O
{	O
error_t	O
err	int
;	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: notifying %s of %s..."	*(char)
,	O
program_invocation_short_name	O
,	O
n	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
name	*(char)
,	O
msg	*(char)
)	O
;	O
err	int
=	O
startup_dosync	()->(int)
(	O
n	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
notify_port	int
,	O
60000	int
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"(no longer present)\n"	*(char)
)	O
;	O
else	O
if	O
(	O
err	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s\n"	*(char)
,	O
strerror	O
(	O
err	int
)	O
)	O
;	O
else	O
fprintf	()->(int)
(	O
stderr	O
,	O
"done\n"	*(char)
)	O
;	O
}	O
}	O
void	O
reboot_system	(int)->(void)
(	O
int	O
flags	int
)	O
{	O
notify_shutdown	(*(char))->(void)
(	O
BOOT	O
(	O
flags	int
)	O
)	O
;	O
if	O
(	O
fakeboot	int
)	O
{	O
pid_t	O
*	O
pp	O
;	O
size_t	O
npids	O
=	O
0	int
;	O
error_t	O
err	int
;	O
int	O
ind	int
;	O
err	int
=	O
proc_getallpids	()->(int)
(	O
procserver	int
,	O
&	O
pp	O
,	O
&	O
npids	O
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
{	O
procbad	O
:	O
error	()->(int)
(	O
0	int
,	O
0	int
,	O
"Can't simulate crash; proc has died"	*(char)
)	O
;	O
reboot_mach	(int)->(void)
(	O
flags	int
)	O
;	O
}	O
for	O
(	O
ind	int
=	O
0	int
;	O
ind	int
<	O
npids	O
;	O
ind	int
++	O
)	O
{	O
task_t	O
task	int
;	O
err	int
=	O
proc_pid2task	()->(int)
(	O
procserver	int
,	O
pp	O
[	O
ind	int
]	O
,	O
&	O
task	int
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
goto	O
procbad	O
;	O
else	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"Getting task for pid %d"	*(char)
,	O
pp	O
[	O
ind	int
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
task	int
!=	O
mach_task_self	()->(int)
(	O
)	O
&&	O
task	int
!=	O
proctask	O
)	O
{	O
struct	O
procinfo	O
*	O
pi	*(struct)
=	O
0	int
;	O
size_t	O
pisize	O
=	O
0	int
;	O
char	O
*	O
noise	*(char)
;	O
size_t	O
noise_len	O
=	O
0	int
;	O
int	O
flags	int
;	O
err	int
=	O
proc_getprocinfo	()->(int)
(	O
procserver	int
,	O
pp	O
[	O
ind	int
]	O
,	O
&	O
flags	int
,	O
(	O
int	O
*	O
*	O
)	O
&	O
pi	*(struct)
,	O
&	O
pisize	O
,	O
&	O
noise	*(char)
,	O
&	O
noise_len	O
)	O
;	O
if	O
(	O
err	int
==	O
MACH_SEND_INVALID_DEST	O
)	O
goto	O
procbad	O
;	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"Getting procinfo for pid %d"	*(char)
,	O
pp	O
[	O
ind	int
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
(	O
pi	*(struct)
->	O
state	*(struct)
&	O
PI_NOPARENT	O
)	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: Killing pid %d\n"	*(char)
,	O
program_invocation_short_name	O
,	O
pp	O
[	O
ind	int
]	O
)	O
;	O
task_terminate	()->(int)
(	O
task	int
)	O
;	O
}	O
if	O
(	O
noise_len	O
>	O
0	int
)	O
munmap	()->(int)
(	O
noise	*(char)
,	O
noise_len	O
)	O
;	O
}	O
}	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: Killing proc server\n"	*(char)
,	O
program_invocation_short_name	O
)	O
;	O
task_terminate	()->(int)
(	O
proctask	O
)	O
;	O
fprintf	()->(int)
(	O
stderr	O
,	O
"%s: Exiting"	*(char)
,	O
program_invocation_short_name	O
)	O
;	O
}	O
reboot_mach	(int)->(void)
(	O
flags	int
)	O
;	O
}	O
void	O
crash_system	()->(void)
(	O
void	O
)	O
{	O
reboot_system	(int)->(void)
(	O
crash_flags	int
)	O
;	O
}	O
static	O
void	O
request_dead_name	(int)->(void)
(	O
mach_port_t	O
name	*(char)
)	O
{	O
mach_port_t	O
prev	O
;	O
mach_port_request_notification	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
name	*(char)
,	O
MACH_NOTIFY_DEAD_NAME	O
,	O
1	int
,	O
startup	int
,	O
MACH_MSG_TYPE_MAKE_SEND_ONCE	O
,	O
&	O
prev	O
)	O
;	O
if	O
(	O
prev	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
prev	O
)	O
;	O
}	O
static	O
error_t	O
record_essential_task	(*(char),int)->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
task_t	O
task	int
)	O
{	O
struct	O
ess_task	struct(*(struct(*(struct(*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
;	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
ess_task	struct(*(struct(*(struct(*(struct`),int,*(char))),int,*(char))),int,*(char))
)	O
)	O
;	O
if	O
(	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
->	O
task_port	int
=	O
task	int
;	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
=	O
strdup	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
==	O
NULL	O
)	O
{	O
free	()->(int)
(	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
)	O
;	O
return	O
ENOMEM	O
;	O
}	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
->	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
ess_tasks	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
;	O
ess_tasks	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
=	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
;	O
request_dead_name	(int)->(void)
(	O
task	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
run	(*(char),*(int),*(int))->(void)
(	O
const	O
char	O
*	O
server	*(char)
,	O
mach_port_t	O
*	O
ports	*(int)
,	O
task_t	O
*	O
task	int
)	O
{	O
char	O
buf	*(char)
[	O
BUFSIZ	O
]	O
;	O
const	O
char	O
*	O
prog	*(char)
=	O
server	*(char)
;	O
if	O
(	O
bootstrap_args	int
&	O
RB_INITNAME	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Server file name (default %s): "	*(char)
,	O
server	*(char)
)	O
;	O
if	O
(	O
getstring	(*(char),int)->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
)	O
prog	*(char)
=	O
buf	*(char)
;	O
}	O
while	O
(	O
1	int
)	O
{	O
file_t	O
file	O
;	O
error_t	O
err	int
;	O
file	O
=	O
file_name_lookup	()->(int)
(	O
prog	*(char)
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
file	O
==	O
MACH_PORT_NULL	O
)	O
error	()->(int)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
prog	*(char)
)	O
;	O
else	O
{	O
task_create	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
0	int
,	O
task	int
)	O
;	O
if	O
(	O
bootstrap_args	int
&	O
RB_KDB	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Pausing for %s\n"	*(char)
,	O
prog	*(char)
)	O
;	O
getchar	()->(int)
(	O
)	O
;	O
}	O
err	int
=	O
file_exec	()->(int)
(	O
file	O
,	O
*	O
task	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
prog	*(char)
,	O
strlen	O
(	O
prog	*(char)
)	O
+	O
1	int
,	O
startup_envz	*(char)
,	O
startup_envz_len	int
,	O
default_dtable	array(int)
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
3	int
,	O
ports	*(int)
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
default_ints	int
,	O
INIT_INT_MAX	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
err	int
)	O
break	O
;	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"%s"	*(char)
,	O
prog	*(char)
)	O
;	O
}	O
fprintf	()->(int)
(	O
stderr	O
,	O
"File name for server %s (or nothing to reboot): "	*(char)
,	O
server	*(char)
)	O
;	O
if	O
(	O
getstring	(*(char),int)->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
)	O
prog	*(char)
=	O
buf	*(char)
;	O
else	O
crash_system	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"started %s\n"	*(char)
,	O
prog	*(char)
)	O
;	O
request_dead_name	(int)->(void)
(	O
*	O
task	int
)	O
;	O
}	O
pid_t	O
run_for_real	(*(char),*(char),int,int,int)->(int)
(	O
char	O
*	O
filename	*(char)
,	O
char	O
*	O
args	*(char)
,	O
int	O
arglen	int
,	O
mach_port_t	O
ctty	int
,	O
int	O
setsid	int
)	O
{	O
file_t	O
file	O
;	O
error_t	O
err	int
;	O
task_t	O
task	int
;	O
char	O
*	O
progname	*(char)
;	O
int	O
pid	int
;	O
file	O
=	O
file_name_lookup	()->(int)
(	O
filename	*(char)
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
file	O
==	O
MACH_PORT_NULL	O
)	O
{	O
error	()->(int)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
task_create	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
0	int
,	O
&	O
task	int
)	O
;	O
proc_child	()->(int)
(	O
procserver	int
,	O
task	int
)	O
;	O
proc_task2pid	()->(int)
(	O
procserver	int
,	O
task	int
,	O
&	O
pid	int
)	O
;	O
proc_task2proc	()->(int)
(	O
procserver	int
,	O
task	int
,	O
&	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
proc_mark_exec	()->(int)
(	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
if	O
(	O
setsid	int
)	O
proc_setsid	()->(int)
(	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
if	O
(	O
ctty	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
term_getctty	()->(int)
(	O
ctty	int
,	O
&	O
default_ports	int
[	O
INIT_PORT_CTTYID	O
]	O
)	O
;	O
io_mod_owner	()->(int)
(	O
ctty	int
,	O
-	O
pid	int
)	O
;	O
proc_make_login_coll	()->(int)
(	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
}	O
if	O
(	O
bootstrap_args	int
&	O
RB_KDB	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Pausing for %s\n"	*(char)
,	O
filename	*(char)
)	O
;	O
getchar	()->(int)
(	O
)	O
;	O
}	O
progname	*(char)
=	O
strrchr	O
(	O
filename	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
progname	*(char)
)	O
++	O
progname	*(char)
;	O
else	O
progname	*(char)
=	O
filename	*(char)
;	O
err	int
=	O
file_exec	()->(int)
(	O
file	O
,	O
task	int
,	O
0	int
,	O
args	*(char)
,	O
arglen	int
,	O
startup_envz	*(char)
,	O
startup_envz_len	int
,	O
default_dtable	array(int)
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
3	int
,	O
default_ports	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
default_ints	int
,	O
INIT_INT_MAX	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
if	O
(	O
ctty	int
!=	O
MACH_PORT_NULL	O
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
default_ports	int
[	O
INIT_PORT_CTTYID	O
]	O
)	O
;	O
default_ports	int
[	O
INIT_PORT_CTTYID	O
]	O
=	O
MACH_PORT_NULL	O
;	O
}	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
file	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"Cannot execute %s"	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
return	O
pid	int
;	O
}	O
static	O
void	O
mig_reply_setup	(*(int),*(int))->(void)
(	O
const	O
mach_msg_header_t	O
*	O
in	*(int)
,	O
mach_msg_header_t	O
*	O
out	*(int)
)	O
{	O
static	O
const	O
mach_msg_type_t	O
RetCodeType	int
=	O
{	O
MACH_MSG_TYPE_INTEGER_32	O
,	O
32	int
,	O
1	int
,	O
TRUE	O
,	O
FALSE	O
,	O
FALSE	O
,	O
0	int
}	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_bits	O
=	O
MACH_MSGH_BITS	()->(int)
(	O
MACH_MSGH_BITS_REMOTE	()->(int)
(	O
InP	O
->	O
msgh_bits	O
)	O
,	O
0	int
)	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_size	O
=	O
sizeof	O
*	O
OutP	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_remote_port	O
=	O
InP	O
->	O
msgh_remote_port	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_local_port	O
=	O
MACH_PORT_NULL	O
;	O
OutP	O
->	O
Head	O
.	O
msgh_seqno	O
=	O
0	int
;	O
OutP	O
->	O
Head	O
.	O
msgh_id	O
=	O
InP	O
->	O
msgh_id	O
+	O
100	int
;	O
OutP	O
->	O
RetCodeType	int
=	O
RetCodeType	int
;	O
OutP	O
->	O
RetCode	O
=	O
MIG_BAD_ID	O
;	O
}	O
static	O
int	O
demuxer	(*(int),*(int))->(int)
(	O
mach_msg_header_t	O
*	O
inp	*(int)
,	O
mach_msg_header_t	O
*	O
outp	*(int)
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
verbose	int
>	O
1	int
)	O
error	()->(int)
(	O
0	int
,	O
0	int
,	O
"%d"	*(char)
,	O
inp	*(int)
->	O
msgh_id	O
)	O
;	O
mig_reply_setup	(*(int),*(int))->(void)
(	O
inp	*(int)
,	O
outp	*(int)
)	O
;	O
if	O
(	O
(	O
routine	O
=	O
notify_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
msg_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
fsys_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
fs_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
io_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
||	O
(	O
routine	O
=	O
startup_server_routine	()->(int)
(	O
inp	*(int)
)	O
)	O
)	O
{	O
(	O
*	O
routine	O
)	O
(	O
inp	*(int)
,	O
outp	*(int)
)	O
;	O
if	O
(	O
verbose	int
>	O
1	int
)	O
error	()->(int)
(	O
0	int
,	O
(	O
(	O
mig_reply_header_t	O
*	O
)	O
outp	*(int)
)	O
->	O
RetCode	O
,	O
"%d"	*(char)
,	O
inp	*(int)
->	O
msgh_id	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
error_t	O
install_as_translator	()->(int)
(	O
void	O
)	O
{	O
error_t	O
err	int
;	O
file_t	O
node	O
;	O
node	O
=	O
file_name_lookup	()->(int)
(	O
_SERVERS_STARTUP	O
,	O
O_NOTRANS	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
MACH_PORT_VALID	()->(int)
(	O
node	O
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	O
)	O
{	O
error	()->(int)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
_SERVERS_STARTUP	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
errno	O
;	O
}	O
err	int
=	O
file_set_translator	()->(int)
(	O
node	O
,	O
0	int
,	O
FS_TRANS_SET	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
startup	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
node	O
)	O
;	O
return	O
err	int
;	O
}	O
static	O
int	O
parse_opt	(int,*(char),*(struct))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	O
*	O
state	*(struct)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'q'	O
:	O
bootstrap_args	int
|=	O
RB_ASKNAME	O
;	O
break	O
;	O
case	O
's'	O
:	O
bootstrap_args	int
|=	O
RB_SINGLE	O
;	O
break	O
;	O
case	O
'd'	O
:	O
bootstrap_args	int
|=	O
RB_KDB	O
;	O
break	O
;	O
case	O
'n'	O
:	O
bootstrap_args	int
|=	O
RB_INITNAME	O
;	O
break	O
;	O
case	O
'f'	O
:	O
fakeboot	int
=	O
1	int
;	O
break	O
;	O
case	O
'H'	O
:	O
crash_flags	int
=	O
RB_DEBUGGER	O
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'x'	O
:	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
main	(int,*(*(char)),*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
char	O
*	O
*	O
envp	*(*(char))
)	O
{	O
volatile	O
int	O
err	int
;	O
int	O
i	int
;	O
int	O
flags	int
;	O
mach_port_t	O
consdev	O
;	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	int
,	O
parse_opt	(int,*(char),*(struct))->(int)
,	O
0	int
,	O
doc	array(char)
}	O
;	O
flags	int
=	O
ARGP_IN_ORDER	O
;	O
if	O
(	O
getpid	()->(int)
(	O
)	O
==	O
0	int
)	O
flags	int
|=	O
ARGP_NO_ERRS	O
;	O
argp_parse	()->(int)
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	*(*(char))
,	O
flags	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
getpid	()->(int)
(	O
)	O
>	O
0	int
)	O
error	()->(int)
(	O
2	int
,	O
0	int
,	O
"can only be run by bootstrap filesystem"	*(char)
)	O
;	O
global_argv	*(*(char))
=	O
argv	*(*(char))
;	O
if	O
(	O
task_get_bootstrap_port	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
&	O
bootport	int
)	O
||	O
fsys_getpriv	()->(int)
(	O
bootport	int
,	O
&	O
host_priv	int
,	O
&	O
device_master	O
,	O
&	O
fstask	O
)	O
||	O
device_open	()->(int)
(	O
device_master	O
,	O
D_READ	O
|	O
D_WRITE	O
,	O
"console"	*(char)
,	O
&	O
consdev	O
)	O
)	O
crash_mach	()->(void)
(	O
)	O
;	O
wire_task_self	()->(int)
(	O
)	O
;	O
task_set_bootstrap_port	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
MACH_PORT_NULL	O
)	O
;	O
stderr	O
=	O
stdout	O
=	O
mach_open_devstream	()->(int)
(	O
consdev	O
,	O
"w"	*(char)
)	O
;	O
stdin	O
=	O
mach_open_devstream	()->(int)
(	O
consdev	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
stdout	O
==	O
NULL	O
||	O
stdin	O
==	O
NULL	O
)	O
crash_mach	()->(void)
(	O
)	O
;	O
setbuf	()->(int)
(	O
stdout	O
,	O
NULL	O
)	O
;	O
err	int
=	O
argz_create	()->(int)
(	O
envp	*(*(char))
,	O
&	O
startup_envz	*(char)
,	O
&	O
startup_envz_len	int
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
mach_port_allocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
MACH_PORT_RIGHT_RECEIVE	O
,	O
&	O
startup	int
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
mach_port_insert_right	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
startup	int
,	O
startup	int
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
request_dead_name	(int)->(void)
(	O
fstask	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INIT_PORT_MAX	O
;	O
i	int
++	O
)	O
switch	O
(	O
i	int
)	O
{	O
case	O
INIT_PORT_CRDIR	O
:	O
default_ports	int
[	O
i	int
]	O
=	O
getcrdir	()->(int)
(	O
)	O
;	O
break	O
;	O
case	O
INIT_PORT_CWDIR	O
:	O
default_ports	int
[	O
i	int
]	O
=	O
getcwdir	()->(int)
(	O
)	O
;	O
break	O
;	O
default	O
:	O
default_ports	int
[	O
i	int
]	O
=	O
MACH_PORT_NULL	O
;	O
break	O
;	O
}	O
default_dtable	array(int)
[	O
0	int
]	O
=	O
getdport	()->(int)
(	O
0	int
)	O
;	O
default_dtable	array(int)
[	O
1	int
]	O
=	O
getdport	()->(int)
(	O
1	int
)	O
;	O
default_dtable	array(int)
[	O
2	int
]	O
=	O
getdport	()->(int)
(	O
2	int
)	O
;	O
default_ints	int
[	O
INIT_SIGIGN	O
]	O
=	O
(	O
sigmask	()->(int)
(	O
SIGTSTP	O
)	O
|	O
sigmask	()->(int)
(	O
SIGTTIN	O
)	O
|	O
sigmask	()->(int)
(	O
SIGTTOU	O
)	O
)	O
;	O
default_ports	int
[	O
INIT_PORT_BOOTSTRAP	O
]	O
=	O
startup	int
;	O
run	(*(char),*(int),*(int))->(void)
(	O
"/hurd/proc"	*(char)
,	O
default_ports	int
,	O
&	O
proctask	O
)	O
;	O
if	O
(	O
!	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
" proc"	*(char)
)	O
;	O
run	(*(char),*(int),*(int))->(void)
(	O
"/hurd/auth"	*(char)
,	O
default_ports	int
,	O
&	O
authtask	int
)	O
;	O
if	O
(	O
!	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
" auth"	*(char)
)	O
;	O
default_ports	int
[	O
INIT_PORT_BOOTSTRAP	O
]	O
=	O
MACH_PORT_NULL	O
;	O
while	O
(	O
1	int
)	O
{	O
err	int
=	O
mach_msg_server	()->(int)
(	O
demuxer	(*(int),*(int))->(int)
,	O
0	int
,	O
startup	int
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
}	O
}	O
void	O
launch_core_servers	()->(void)
(	O
void	O
)	O
{	O
mach_port_t	O
old	O
;	O
mach_port_t	O
authproc	O
,	O
fsproc	O
,	O
procproc	O
;	O
error_t	O
err	int
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Launching core servers\n"	*(char)
)	O
;	O
err	int
=	O
startup_procinit_reply	()->(int)
(	O
procreply	int
,	O
procreplytype	int
,	O
0	int
,	O
mach_task_self	()->(int)
(	O
)	O
,	O
authserver	int
,	O
host_priv	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
device_master	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
if	O
(	O
!	O
fakeboot	int
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
device_master	O
)	O
;	O
device_master	O
=	O
0	int
;	O
}	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"proc launched\n"	*(char)
)	O
;	O
err	int
=	O
proc_mark_important	()->(int)
(	O
procserver	int
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_exec	()->(int)
(	O
procserver	int
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_child	()->(int)
(	O
procserver	int
,	O
fstask	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_child	()->(int)
(	O
procserver	int
,	O
authtask	int
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_task2proc	()->(int)
(	O
procserver	int
,	O
authtask	int
,	O
&	O
authproc	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_important	()->(int)
(	O
authproc	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_exec	()->(int)
(	O
authproc	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
install_as_translator	()->(int)
(	O
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"Failed to bind to "	*(char)
_SERVERS_STARTUP	O
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Installed on /servers/startup\n"	*(char)
)	O
;	O
err	int
=	O
startup_authinit_reply	()->(int)
(	O
authreply	O
,	O
authreplytype	O
,	O
0	int
,	O
authproc	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
authproc	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"auth launched\n"	*(char)
)	O
;	O
_hurd_port_set	()->(int)
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_AUTH	O
]	O
,	O
authserver	int
)	O
;	O
_hurd_port_set	()->(int)
(	O
&	O
_hurd_ports	O
[	O
INIT_PORT_PROC	O
]	O
,	O
procserver	int
)	O
;	O
err	int
=	O
proc_set_arg_locations	()->(int)
(	O
procserver	int
,	O
(	O
vm_address_t	O
)	O
global_argv	*(*(char))
,	O
(	O
vm_address_t	O
)	O
environ	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
default_ports	int
[	O
INIT_PORT_AUTH	O
]	O
=	O
authserver	int
;	O
err	int
=	O
proc_child	()->(int)
(	O
procserver	int
,	O
proctask	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_task2proc	()->(int)
(	O
procserver	int
,	O
proctask	O
,	O
&	O
procproc	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
proc_mark_important	()->(int)
(	O
procproc	O
)	O
;	O
proc_mark_exec	()->(int)
(	O
procproc	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
procproc	O
)	O
;	O
}	O
err	int
=	O
proc_register_version	()->(int)
(	O
procserver	int
,	O
host_priv	int
,	O
"init"	*(char)
,	O
""	*(char)
,	O
HURD_VERSION	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_task2proc	()->(int)
(	O
procserver	int
,	O
fstask	O
,	O
&	O
fsproc	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_important	()->(int)
(	O
fsproc	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
proc_mark_exec	()->(int)
(	O
fsproc	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
fprintf	()->(int)
(	O
stderr	O
,	O
".\n"	*(char)
)	O
;	O
err	int
=	O
proc_setmsgport	()->(int)
(	O
procserver	int
,	O
startup	int
,	O
&	O
old	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
if	O
(	O
old	O
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
old	O
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Message port registered\n"	*(char)
)	O
;	O
err	int
=	O
fsys_init	()->(int)
(	O
bootport	int
,	O
fsproc	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
authserver	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
fsproc	O
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"fsys_init"	*(char)
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Fixed up bootstrap filesystem\n"	*(char)
)	O
;	O
}	O
void	O
init_stdarrays	()->(void)
(	O
)	O
{	O
auth_t	O
nullauth	O
;	O
mach_port_t	O
pt	O
;	O
mach_port_t	O
ref	O
;	O
mach_port_t	O
*	O
std_port_array	O
;	O
int	O
*	O
std_int_array	*(int)
;	O
int	O
i	int
;	O
std_port_array	O
=	O
alloca	O
(	O
sizeof	O
(	O
mach_port_t	O
)	O
*	O
INIT_PORT_MAX	O
)	O
;	O
std_int_array	*(int)
=	O
alloca	O
(	O
sizeof	O
(	O
int	O
)	O
*	O
INIT_INT_MAX	O
)	O
;	O
memset	O
(	O
std_port_array	O
,	O
0	int
,	O
sizeof	O
(	O
mach_port_t	O
)	O
*	O
INIT_PORT_MAX	O
)	O
;	O
memset	O
(	O
std_int_array	*(int)
,	O
0	int
,	O
sizeof	O
(	O
int	O
)	O
*	O
INIT_INT_MAX	O
)	O
;	O
__USEPORT	()->(int)
(	O
AUTH	O
,	O
auth_makeauth	()->(int)
(	O
port	*(int)
,	O
0	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
nullauth	O
)	O
)	O
;	O
pt	O
=	O
getcwdir	()->(int)
(	O
)	O
;	O
ref	O
=	O
mach_reply_port	()->(int)
(	O
)	O
;	O
io_reauthenticate	()->(int)
(	O
pt	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
auth_user_authenticate	()->(int)
(	O
nullauth	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
,	O
&	O
std_port_array	O
[	O
INIT_PORT_CWDIR	O
]	O
)	O
;	O
mach_port_destroy	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ref	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
pt	O
)	O
;	O
pt	O
=	O
getcrdir	()->(int)
(	O
)	O
;	O
ref	O
=	O
mach_reply_port	()->(int)
(	O
)	O
;	O
io_reauthenticate	()->(int)
(	O
pt	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
auth_user_authenticate	()->(int)
(	O
nullauth	O
,	O
ref	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
,	O
&	O
std_port_array	O
[	O
INIT_PORT_CRDIR	O
]	O
)	O
;	O
mach_port_destroy	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
ref	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
pt	O
)	O
;	O
std_port_array	O
[	O
INIT_PORT_AUTH	O
]	O
=	O
nullauth	O
;	O
std_int_array	*(int)
[	O
INIT_UMASK	O
]	O
=	O
CMASK	O
;	O
__USEPORT	()->(int)
(	O
PROC	O
,	O
proc_setexecdata	()->(int)
(	O
port	*(int)
,	O
std_port_array	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
std_int_array	*(int)
,	O
INIT_INT_MAX	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INIT_PORT_MAX	O
;	O
i	int
++	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
std_port_array	O
[	O
i	int
]	O
)	O
;	O
}	O
void	O
dump_processes	()->(void)
(	O
void	O
)	O
{	O
pid_t	O
pid	int
;	O
for	O
(	O
pid	int
=	O
1	int
;	O
pid	int
<	O
100	int
;	O
pid	int
++	O
)	O
{	O
char	O
args	*(char)
[	O
256	int
]	O
,	O
*	O
buffer	*(char)
=	O
args	*(char)
;	O
size_t	O
len	*(int)
=	O
sizeof	O
args	*(char)
;	O
if	O
(	O
proc_getprocargs	()->(int)
(	O
procserver	int
,	O
pid	int
,	O
&	O
buffer	*(char)
,	O
&	O
len	*(int)
)	O
==	O
0	int
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"pid%d\t%s\n"	*(char)
,	O
(	O
int	O
)	O
pid	int
,	O
buffer	*(char)
)	O
;	O
if	O
(	O
buffer	*(char)
!=	O
args	*(char)
)	O
vm_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
(	O
vm_offset_t	O
)	O
buffer	*(char)
,	O
len	*(int)
)	O
;	O
}	O
}	O
}	O
void	O
frob_kernel_process	()->(void)
(	O
void	O
)	O
{	O
error_t	O
err	int
;	O
int	O
argc	int
,	O
i	int
;	O
char	O
*	O
argz	*(char)
,	O
*	O
entry	*(char)
;	O
size_t	O
argzlen	O
;	O
size_t	O
windowsz	O
;	O
vm_address_t	O
mine	O
,	O
his	O
;	O
task_t	O
task	int
;	O
process_t	O
proc	int
,	O
kbs	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Frobbing kernel process\n"	*(char)
)	O
;	O
err	int
=	O
proc_pid2task	()->(int)
(	O
procserver	int
,	O
HURD_PID_KERNEL	O
,	O
&	O
task	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"cannot get kernel task port"	*(char)
)	O
;	O
return	O
;	O
}	O
err	int
=	O
proc_child	()->(int)
(	O
procserver	int
,	O
task	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"cannot make the kernel our child"	*(char)
)	O
;	O
dump_processes	()->(void)
(	O
)	O
;	O
}	O
err	int
=	O
proc_task2proc	()->(int)
(	O
procserver	int
,	O
task	int
,	O
&	O
proc	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"cannot get kernel task's proc server port"	*(char)
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
return	O
;	O
}	O
err	int
=	O
proc_mark_important	()->(int)
(	O
proc	int
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"cannot mark the kernel as important"	*(char)
)	O
;	O
err	int
=	O
record_essential_task	(*(char),int)->(int)
(	O
"kernel"	*(char)
,	O
task	int
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
err	int
=	O
task_get_bootstrap_port	()->(int)
(	O
task	int
,	O
&	O
kbs	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
if	O
(	O
kbs	O
==	O
MACH_PORT_NULL	O
)	O
{	O
err	int
=	O
task_set_bootstrap_port	()->(int)
(	O
task	int
,	O
proc	int
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"cannot set kernel task's bootstrap port"	*(char)
)	O
;	O
if	O
(	O
fakeboot	int
)	O
error	()->(int)
(	O
0	int
,	O
0	int
,	O
"warning: --fake-boot specified but I see no other Hurd"	*(char)
)	O
;	O
}	O
else	O
{	O
vm_address_t	O
kargv	O
,	O
kenvp	O
;	O
err	int
=	O
proc_get_arg_locations	()->(int)
(	O
kbs	O
,	O
&	O
kargv	O
,	O
&	O
kenvp	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
kbs	O
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"kernel task bootstrap port (ignoring)"	*(char)
)	O
;	O
else	O
{	O
err	int
=	O
proc_set_arg_locations	()->(int)
(	O
proc	int
,	O
kargv	O
,	O
kenvp	O
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"cannot propagate original kernel command line"	*(char)
)	O
;	O
else	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
proc	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
if	O
(	O
!	O
fakeboot	int
)	O
error	()->(int)
(	O
0	int
,	O
0	int
,	O
"warning: "	*(char)
"I see another Hurd, but --fake-boot was not given"	*(char)
)	O
;	O
return	O
;	O
}	O
}	O
}	O
err	int
=	O
argz_create	()->(int)
(	O
&	O
global_argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
argz	*(char)
,	O
&	O
argzlen	O
)	O
;	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
argc	int
=	O
argz_count	()->(int)
(	O
argz	*(char)
,	O
argzlen	O
)	O
;	O
windowsz	O
=	O
round_page	()->(int)
(	O
(	O
(	O
argc	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
+	O
argzlen	O
)	O
;	O
mine	O
=	O
(	O
vm_address_t	O
)	O
mmap	O
(	O
0	int
,	O
windowsz	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
assert	()->(int)
(	O
mine	O
!=	O
-	O
1	int
)	O
;	O
err	int
=	O
vm_allocate	()->(int)
(	O
task	int
,	O
&	O
his	O
,	O
windowsz	O
,	O
1	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"cannot allocate %Zu bytes in kernel task"	*(char)
,	O
windowsz	O
)	O
;	O
free	()->(int)
(	O
argz	*(char)
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
proc	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
munmap	()->(int)
(	O
(	O
caddr_t	O
)	O
mine	O
,	O
windowsz	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
entry	*(char)
=	O
argz	*(char)
;	O
entry	*(char)
!=	O
NULL	O
;	O
++	O
i	int
,	O
entry	*(char)
=	O
argz_next	()->(int)
(	O
argz	*(char)
,	O
argzlen	O
,	O
entry	*(char)
)	O
)	O
(	O
(	O
char	O
*	O
*	O
)	O
mine	O
)	O
[	O
i	int
]	O
=	O
(	O
(	O
char	O
*	O
)	O
&	O
(	O
(	O
char	O
*	O
*	O
)	O
his	O
)	O
[	O
argc	int
+	O
1	int
]	O
+	O
(	O
entry	*(char)
-	O
argz	*(char)
)	O
)	O
;	O
(	O
(	O
char	O
*	O
*	O
)	O
mine	O
)	O
[	O
argc	int
]	O
=	O
NULL	O
;	O
memcpy	O
(	O
&	O
(	O
(	O
char	O
*	O
*	O
)	O
mine	O
)	O
[	O
argc	int
+	O
1	int
]	O
,	O
argz	*(char)
,	O
argzlen	O
)	O
;	O
free	()->(int)
(	O
argz	*(char)
)	O
;	O
err	int
=	O
vm_write	()->(int)
(	O
task	int
,	O
his	O
,	O
mine	O
,	O
windowsz	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
task	int
)	O
;	O
munmap	()->(int)
(	O
(	O
caddr_t	O
)	O
mine	O
,	O
windowsz	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"cannot write command line into kernel task"	*(char)
)	O
;	O
return	O
;	O
}	O
err	int
=	O
proc_set_arg_locations	()->(int)
(	O
proc	int
,	O
his	O
,	O
his	O
+	O
(	O
argc	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
proc	int
)	O
;	O
if	O
(	O
err	int
)	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"proc_set_arg_locations for kernel task"	*(char)
)	O
;	O
}	O
static	O
pid_t	O
child_pid	int
;	O
static	O
task_t	O
child_task	int
;	O
static	O
void	O
launch_something	(*(char))->(void)
(	O
const	O
char	O
*	O
why	*(char)
)	O
;	O
void	O
process_signal	(int)->(void)
(	O
int	O
signo	int
)	O
{	O
if	O
(	O
signo	int
==	O
SIGCHLD	O
)	O
{	O
int	O
status	int
;	O
pid_t	O
pid	int
;	O
while	O
(	O
1	int
)	O
{	O
pid	int
=	O
waitpid	()->(int)
(	O
WAIT_ANY	O
,	O
&	O
status	int
,	O
WNOHANG	O
|	O
WUNTRACED	O
)	O
;	O
if	O
(	O
pid	int
<=	O
0	int
)	O
break	O
;	O
if	O
(	O
pid	int
==	O
child_pid	int
)	O
{	O
char	O
*	O
desc	*(char)
=	O
0	int
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
child_task	int
)	O
;	O
child_task	int
=	O
MACH_PORT_NULL	O
;	O
child_pid	int
=	O
-	O
1	int
;	O
if	O
(	O
WIFSIGNALED	()->(int)
(	O
status	int
)	O
)	O
asprintf	()->(int)
(	O
&	O
desc	*(char)
,	O
"terminated abnormally (%s)"	*(char)
,	O
strsignal	()->(int)
(	O
WTERMSIG	()->(int)
(	O
status	int
)	O
)	O
)	O
;	O
else	O
if	O
(	O
WIFSTOPPED	()->(int)
(	O
status	int
)	O
)	O
asprintf	()->(int)
(	O
&	O
desc	*(char)
,	O
"stopped abnormally (%s)"	*(char)
,	O
strsignal	()->(int)
(	O
WTERMSIG	()->(int)
(	O
status	int
)	O
)	O
)	O
;	O
else	O
if	O
(	O
WEXITSTATUS	()->(int)
(	O
status	int
)	O
==	O
0	int
)	O
desc	*(char)
=	O
strdup	O
(	O
"finished"	*(char)
)	O
;	O
else	O
asprintf	()->(int)
(	O
&	O
desc	*(char)
,	O
"exited with status %d"	*(char)
,	O
WEXITSTATUS	()->(int)
(	O
status	int
)	O
)	O
;	O
{	O
char	O
buf	*(char)
[	O
40	int
]	O
;	O
snprintf	O
(	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
,	O
"%d"	*(char)
,	O
status	int
)	O
;	O
setenv	()->(int)
(	O
"STATUS"	*(char)
,	O
buf	*(char)
,	O
1	int
)	O
;	O
}	O
launch_something	(*(char))->(void)
(	O
desc	*(char)
)	O
;	O
free	()->(int)
(	O
desc	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
start_child	(*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
prog	*(char)
,	O
char	O
*	O
*	O
progargs	*(*(char))
)	O
{	O
file_t	O
file	O
;	O
error_t	O
err	int
;	O
char	O
*	O
args	*(char)
;	O
size_t	O
arglen	int
;	O
if	O
(	O
progargs	*(*(char))
==	O
0	int
)	O
{	O
const	O
char	O
*	O
argv	*(*(char))
[	O
]	O
=	O
{	O
"/libexec/console-run"	*(char)
,	O
prog	*(char)
,	O
0	int
}	O
;	O
err	int
=	O
argz_create	()->(int)
(	O
(	O
char	O
*	O
*	O
)	O
argv	*(*(char))
,	O
&	O
args	*(char)
,	O
&	O
arglen	int
)	O
;	O
}	O
else	O
{	O
int	O
argc	int
=	O
0	int
;	O
while	O
(	O
progargs	*(*(char))
[	O
argc	int
]	O
!=	O
0	int
)	O
++	O
argc	int
;	O
{	O
const	O
char	O
*	O
argv	*(*(char))
[	O
2	int
+	O
argc	int
+	O
1	int
]	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
"/libexec/console-run"	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
prog	*(char)
;	O
argv	*(*(char))
[	O
2	int
+	O
argc	int
]	O
=	O
0	int
;	O
while	O
(	O
argc	int
--	O
>	O
0	int
)	O
argv	*(*(char))
[	O
2	int
+	O
argc	int
]	O
=	O
progargs	*(*(char))
[	O
argc	int
]	O
;	O
err	int
=	O
argz_create	()->(int)
(	O
(	O
char	O
*	O
*	O
)	O
argv	*(*(char))
,	O
&	O
args	*(char)
,	O
&	O
arglen	int
)	O
;	O
}	O
}	O
assert_perror	()->(int)
(	O
err	int
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Going to execute '%s'\n"	*(char)
,	O
args	*(char)
)	O
;	O
file	O
=	O
file_name_lookup	()->(int)
(	O
args	*(char)
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
file	O
==	O
MACH_PORT_NULL	O
)	O
{	O
error	()->(int)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
args	*(char)
)	O
;	O
free	()->(int)
(	O
args	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
task_create	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
0	int
,	O
&	O
child_task	int
)	O
;	O
proc_set_init_task	()->(int)
(	O
procserver	int
,	O
child_task	int
)	O
;	O
proc_task2pid	()->(int)
(	O
procserver	int
,	O
child_task	int
,	O
&	O
child_pid	int
)	O
;	O
proc_task2proc	()->(int)
(	O
procserver	int
,	O
child_task	int
,	O
&	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
if	O
(	O
bootstrap_args	int
&	O
RB_KDB	O
)	O
{	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Pausing for %s\n"	*(char)
,	O
args	*(char)
)	O
;	O
getchar	()->(int)
(	O
)	O
;	O
}	O
err	int
=	O
file_exec	()->(int)
(	O
file	O
,	O
child_task	int
,	O
0	int
,	O
args	*(char)
,	O
arglen	int
,	O
startup_envz	*(char)
,	O
startup_envz_len	int
,	O
NULL	O
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
0	int
,	O
default_ports	int
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	O
,	O
default_ints	int
,	O
INIT_INT_MAX	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
proc_mark_important	()->(int)
(	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
default_ports	int
[	O
INIT_PORT_PROC	O
]	O
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
file	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
error	()->(int)
(	O
0	int
,	O
err	int
,	O
"Cannot execute %s"	*(char)
,	O
args	*(char)
)	O
;	O
free	()->(int)
(	O
args	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
free	()->(int)
(	O
args	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
launch_something	(*(char))->(void)
(	O
const	O
char	O
*	O
why	*(char)
)	O
{	O
file_t	O
something	O
;	O
static	O
unsigned	O
int	O
try	int
;	O
static	O
const	O
char	O
*	O
const	O
tries	array(*(char))
[	O
]	O
=	O
{	O
"/libexec/runsystem"	*(char)
,	O
_PATH_BSHELL	O
,	O
"/bin/shd"	*(char)
,	O
}	O
;	O
if	O
(	O
why	*(char)
)	O
error	()->(int)
(	O
0	int
,	O
0	int
,	O
"%s %s"	*(char)
,	O
tries	array(*(char))
[	O
try	int
-	O
1	int
]	O
,	O
why	*(char)
)	O
;	O
something	O
=	O
file_name_lookup	()->(int)
(	O
tries	array(*(char))
[	O
try	int
]	O
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
something	O
!=	O
MACH_PORT_NULL	O
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
something	O
)	O
;	O
if	O
(	O
try	int
==	O
0	int
&&	O
start_child	(*(char),*(*(char)))->(int)
(	O
tries	array(*(char))
[	O
try	int
++	O
]	O
,	O
&	O
global_argv	*(*(char))
[	O
1	int
]	O
)	O
==	O
0	int
)	O
return	O
;	O
}	O
else	O
try	int
++	O
;	O
while	O
(	O
try	int
<	O
sizeof	O
tries	array(*(char))
/	O
sizeof	O
tries	array(*(char))
[	O
0	int
]	O
)	O
{	O
something	O
=	O
file_name_lookup	()->(int)
(	O
tries	array(*(char))
[	O
try	int
]	O
,	O
O_EXEC	O
,	O
0	int
)	O
;	O
if	O
(	O
something	O
!=	O
MACH_PORT_NULL	O
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
something	O
)	O
;	O
if	O
(	O
start_child	(*(char),*(*(char)))->(int)
(	O
tries	array(*(char))
[	O
try	int
++	O
]	O
,	O
NULL	O
)	O
==	O
0	int
)	O
return	O
;	O
}	O
else	O
try	int
++	O
;	O
}	O
crash_system	()->(void)
(	O
)	O
;	O
}	O
void	O
launch_system	()->(void)
(	O
void	O
)	O
{	O
launch_something	(*(char))->(void)
(	O
0	int
)	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Init has completed\n"	*(char)
)	O
;	O
}	O
kern_return_t	O
S_startup_procinit	(int,int,int,int,*(int),*(int),*(int),*(int),*(int),*(int))->(int)
(	O
startup_t	O
server	*(char)
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_porttype	int
,	O
process_t	O
proc	int
,	O
mach_port_t	O
*	O
startuptask	*(int)
,	O
auth_t	O
*	O
auth	*(int)
,	O
mach_port_t	O
*	O
priv	*(int)
,	O
mach_msg_type_name_t	O
*	O
hostprivtype	*(int)
,	O
mach_port_t	O
*	O
dev	*(int)
,	O
mach_msg_type_name_t	O
*	O
devtype	*(int)
)	O
{	O
if	O
(	O
procserver	int
)	O
return	O
EPERM	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Received startup message from proc\n"	*(char)
)	O
;	O
procserver	int
=	O
proc	int
;	O
procreply	int
=	O
reply	int
;	O
procreplytype	int
=	O
reply_porttype	int
;	O
if	O
(	O
authserver	int
)	O
launch_core_servers	()->(void)
(	O
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
kern_return_t	O
S_startup_authinit	(int,int,int,int,*(int),*(int))->(int)
(	O
startup_t	O
server	*(char)
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_porttype	int
,	O
mach_port_t	O
auth	*(int)
,	O
mach_port_t	O
*	O
proc	int
,	O
mach_msg_type_name_t	O
*	O
proctype	*(int)
)	O
{	O
if	O
(	O
authserver	int
)	O
return	O
EPERM	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Received startup message from auth\n"	*(char)
)	O
;	O
authserver	int
=	O
auth	*(int)
;	O
authreply	O
=	O
reply	int
;	O
authreplytype	O
=	O
reply_porttype	int
;	O
if	O
(	O
procserver	int
)	O
launch_core_servers	()->(void)
(	O
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
kern_return_t	O
S_startup_essential_task	(int,int,int,int,int,*(char),int)->(int)
(	O
mach_port_t	O
server	*(char)
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
replytype	int
,	O
task_t	O
task	int
,	O
mach_port_t	O
excpt	int
,	O
char	O
*	O
name	*(char)
,	O
mach_port_t	O
credential	int
)	O
{	O
static	O
int	O
authinit	int
,	O
procinit	int
,	O
execinit	int
;	O
int	O
fail	int
;	O
if	O
(	O
MACH_PORT_VALID	()->(int)
(	O
credential	int
)	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
credential	int
)	O
;	O
if	O
(	O
credential	int
!=	O
host_priv	int
)	O
return	O
EPERM	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"Received startup essential message from '%s'\n"	*(char)
,	O
name	*(char)
)	O
;	O
fail	int
=	O
record_essential_task	(*(char),int)->(int)
(	O
name	*(char)
,	O
task	int
)	O
;	O
if	O
(	O
fail	int
)	O
return	O
fail	int
;	O
if	O
(	O
!	O
booted	int
)	O
{	O
if	O
(	O
!	O
strcmp	O
(	O
name	*(char)
,	O
"auth"	*(char)
)	O
)	O
authinit	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
name	*(char)
,	O
"exec"	*(char)
)	O
)	O
{	O
execinit	int
=	O
1	int
;	O
mach_port_t	O
execproc	O
;	O
proc_task2proc	()->(int)
(	O
procserver	int
,	O
task	int
,	O
&	O
execproc	O
)	O
;	O
proc_mark_important	()->(int)
(	O
execproc	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	O
(	O
name	*(char)
,	O
"proc"	*(char)
)	O
)	O
procinit	int
=	O
1	int
;	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
"  still waiting for:"	*(char)
)	O
;	O
if	O
(	O
authinit	int
&&	O
execinit	int
&&	O
procinit	int
)	O
{	O
if	O
(	O
verbose	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
" none!\n"	*(char)
)	O
;	O
startup_essential_task_reply	()->(int)
(	O
reply	int
,	O
replytype	int
,	O
0	int
)	O
;	O
init_stdarrays	()->(void)
(	O
)	O
;	O
frob_kernel_process	()->(void)
(	O
)	O
;	O
launch_system	()->(void)
(	O
)	O
;	O
booted	int
=	O
1	int
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
if	O
(	O
!	O
authinit	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
" auth"	*(char)
)	O
;	O
if	O
(	O
!	O
execinit	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
" exec"	*(char)
)	O
;	O
if	O
(	O
!	O
procinit	int
)	O
fprintf	()->(int)
(	O
stderr	O
,	O
" proc"	*(char)
)	O
;	O
fprintf	()->(int)
(	O
stderr	O
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_startup_request_notification	(int,int,*(char))->(int)
(	O
mach_port_t	O
server	*(char)
,	O
mach_port_t	O
notify	int
,	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
ntfy_task	struct(int,*(struct(int,*(struct(int,*(struct`),*(char))),*(char))),*(char))
*	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
request_dead_name	(int)->(void)
(	O
notify	int
)	O
;	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
ntfy_task	struct(int,*(struct(int,*(struct(int,*(struct`),*(char))),*(char))),*(char))
)	O
)	O
;	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
notify_port	int
=	O
notify	int
;	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
ntfy_tasks	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
ntfy_tasks	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
name	*(char)
=	O
malloc	O
(	O
strlen	O
(	O
name	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	O
(	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
name	*(char)
,	O
name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
do_mach_notify_dead_name	(int,int)->(int)
(	O
mach_port_t	O
notify	int
,	O
mach_port_t	O
name	*(char)
)	O
{	O
struct	O
ntfy_task	struct(int,*(struct(int,*(struct(int,*(struct`),*(char))),*(char))),*(char))
*	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
,	O
*	O
pnt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
struct	O
ess_task	struct(*(struct(*(struct(*(struct`),int,*(char))),int,*(char))),int,*(char))
*	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
;	O
assert	()->(int)
(	O
notify	int
==	O
startup	int
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
name	*(char)
)	O
;	O
for	O
(	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
=	O
ess_tasks	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
;	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
!=	O
NULL	O
;	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
=	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
->	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
)	O
if	O
(	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
->	O
task_port	int
==	O
name	*(char)
)	O
{	O
error	()->(int)
(	O
0	int
,	O
0	int
,	O
"Crashing system; essential task %s died"	*(char)
,	O
et	*(struct(*(struct(*(struct`),int,*(char))),int,*(char)))
->	O
name	*(char)
)	O
;	O
crash_system	()->(void)
(	O
)	O
;	O
}	O
for	O
(	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
ntfy_tasks	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
,	O
pnt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
NULL	O
;	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
!=	O
NULL	O
;	O
pnt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
,	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
)	O
if	O
(	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
notify_port	int
==	O
name	*(char)
)	O
{	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
pnt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
!=	O
NULL	O
)	O
pnt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
else	O
ntfy_tasks	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
=	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
->	O
next	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
;	O
free	()->(int)
(	O
nt	*(struct(int,*(struct(int,*(struct`),*(char))),*(char)))
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
booted	int
)	O
{	O
static	O
const	O
struct	O
{	O
task_t	O
*	O
taskp	*(int)
;	O
const	O
char	O
*	O
name	*(char)
;	O
}	O
boots	array(struct(*(int),*(char)))
[	O
]	O
=	O
{	O
{	O
&	O
fstask	O
,	O
"bootstrap filesystem"	*(char)
}	O
,	O
{	O
&	O
authtask	int
,	O
"auth"	*(char)
}	O
,	O
{	O
&	O
proctask	O
,	O
"proc"	*(char)
}	O
,	O
}	O
;	O
size_t	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
boots	array(struct(*(int),*(char)))
/	O
sizeof	O
boots	array(struct(*(int),*(char)))
[	O
0	int
]	O
;	O
++	O
i	int
)	O
if	O
(	O
name	*(char)
==	O
*	O
boots	array(struct(*(int),*(char)))
[	O
i	int
]	O
.	O
taskp	*(int)
)	O
{	O
error	()->(int)
(	O
0	int
,	O
0	int
,	O
"Crashing system; %s server died during bootstrap"	*(char)
,	O
boots	array(struct(*(int),*(char)))
[	O
i	int
]	O
.	O
name	*(char)
)	O
;	O
crash_mach	()->(void)
(	O
)	O
;	O
}	O
error	()->(int)
(	O
0	int
,	O
0	int
,	O
"BUG!  Unexpected dead-name notification (name %#lx)"	*(char)
,	O
name	*(char)
)	O
;	O
crash_mach	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_startup_reboot	(int,int,int)->(int)
(	O
mach_port_t	O
server	*(char)
,	O
mach_port_t	O
refpt	int
,	O
int	O
code	int
)	O
{	O
if	O
(	O
refpt	int
!=	O
host_priv	int
)	O
return	O
EPERM	O
;	O
reboot_system	(int)->(void)
(	O
code	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
;	O
}	O
kern_return_t	O
S_msg_sig_post_untraced	(int,int,int,int,int,int)->(int)
(	O
mach_port_t	O
msgport	int
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
signo	int
,	O
natural_t	O
sigcode	int
,	O
mach_port_t	O
refport	int
)	O
{	O
if	O
(	O
refport	int
!=	O
mach_task_self	()->(int)
(	O
)	O
)	O
return	O
EPERM	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
refport	int
)	O
;	O
msg_sig_post_untraced_reply	()->(int)
(	O
reply	int
,	O
reply_type	int
,	O
0	int
)	O
;	O
process_signal	(int)->(void)
(	O
signo	int
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
kern_return_t	O
S_msg_sig_post	(int,int,int,int,int,int)->(int)
(	O
mach_port_t	O
msgport	int
,	O
mach_port_t	O
reply	int
,	O
mach_msg_type_name_t	O
reply_type	int
,	O
int	O
signo	int
,	O
natural_t	O
sigcode	int
,	O
mach_port_t	O
refport	int
)	O
{	O
if	O
(	O
refport	int
!=	O
mach_task_self	()->(int)
(	O
)	O
)	O
return	O
EPERM	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
refport	int
)	O
;	O
msg_sig_post_reply	()->(int)
(	O
reply	int
,	O
reply_type	int
,	O
0	int
)	O
;	O
process_signal	(int)->(void)
(	O
signo	int
)	O
;	O
return	O
MIG_NO_REPLY	O
;	O
}	O
kern_return_t	O
S_msg_proc_newids	(int,int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
task	int
,	O
pid_t	O
ppid	int
,	O
pid_t	O
pgrp	int
,	O
int	O
orphaned	int
)	O
{	O
return	O
_S_msg_proc_newids	()->(int)
(	O
process	int
,	O
task	int
,	O
ppid	int
,	O
pgrp	int
,	O
orphaned	int
)	O
;	O
}	O
kern_return_t	O
S_msg_add_auth	(int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
auth_t	O
auth	*(int)
)	O
{	O
return	O
_S_msg_add_auth	()->(int)
(	O
process	int
,	O
auth	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_del_auth	(int,int,int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
task	int
,	O
intarray_t	O
uids	int
,	O
mach_msg_type_number_t	O
uidsCnt	int
,	O
intarray_t	O
gids	int
,	O
mach_msg_type_number_t	O
gidsCnt	int
)	O
{	O
return	O
_S_msg_del_auth	()->(int)
(	O
process	int
,	O
task	int
,	O
uids	int
,	O
uidsCnt	int
,	O
gids	int
,	O
gidsCnt	int
)	O
;	O
}	O
kern_return_t	O
S_msg_get_init_port	(int,int,int,*(int),*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
which	int
,	O
mach_port_t	O
*	O
port	*(int)
,	O
mach_msg_type_name_t	O
*	O
portPoly	*(int)
)	O
{	O
return	O
_S_msg_get_init_port	()->(int)
(	O
process	int
,	O
refport	int
,	O
which	int
,	O
port	*(int)
,	O
portPoly	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_set_init_port	(int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
which	int
,	O
mach_port_t	O
port	*(int)
)	O
{	O
return	O
_S_msg_set_init_port	()->(int)
(	O
process	int
,	O
refport	int
,	O
which	int
,	O
port	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_get_init_ports	(int,int,*(int),*(int),*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
portarray_t	O
*	O
ports	*(int)
,	O
mach_msg_type_name_t	O
*	O
portsPoly	*(int)
,	O
mach_msg_type_number_t	O
*	O
portsCnt	*(int)
)	O
{	O
return	O
_S_msg_get_init_ports	()->(int)
(	O
process	int
,	O
refport	int
,	O
ports	*(int)
,	O
portsPoly	*(int)
,	O
portsCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_set_init_ports	(int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
portarray_t	O
ports	*(int)
,	O
mach_msg_type_number_t	O
portsCnt	*(int)
)	O
{	O
return	O
_S_msg_set_init_ports	()->(int)
(	O
process	int
,	O
refport	int
,	O
ports	*(int)
,	O
portsCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_get_init_int	(int,int,int,*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
which	int
,	O
int	O
*	O
value	*(int)
)	O
{	O
return	O
_S_msg_get_init_int	()->(int)
(	O
process	int
,	O
refport	int
,	O
which	int
,	O
value	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_set_init_int	(int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
which	int
,	O
int	O
value	*(int)
)	O
{	O
return	O
_S_msg_set_init_int	()->(int)
(	O
process	int
,	O
refport	int
,	O
which	int
,	O
value	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_get_init_ints	(int,int,*(int),*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
intarray_t	O
*	O
values	*(int)
,	O
mach_msg_type_number_t	O
*	O
valuesCnt	*(int)
)	O
{	O
return	O
_S_msg_get_init_ints	()->(int)
(	O
process	int
,	O
refport	int
,	O
values	*(int)
,	O
valuesCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_set_init_ints	(int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
intarray_t	O
values	*(int)
,	O
mach_msg_type_number_t	O
valuesCnt	*(int)
)	O
{	O
return	O
_S_msg_set_init_ints	()->(int)
(	O
process	int
,	O
refport	int
,	O
values	*(int)
,	O
valuesCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_get_dtable	(int,int,*(int),*(int),*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
portarray_t	O
*	O
dtable	*(int)
,	O
mach_msg_type_name_t	O
*	O
dtablePoly	*(int)
,	O
mach_msg_type_number_t	O
*	O
dtableCnt	*(int)
)	O
{	O
return	O
_S_msg_get_dtable	()->(int)
(	O
process	int
,	O
refport	int
,	O
dtable	*(int)
,	O
dtablePoly	*(int)
,	O
dtableCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_set_dtable	(int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
portarray_t	O
dtable	*(int)
,	O
mach_msg_type_number_t	O
dtableCnt	*(int)
)	O
{	O
return	O
_S_msg_set_dtable	()->(int)
(	O
process	int
,	O
refport	int
,	O
dtable	*(int)
,	O
dtableCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_get_fd	(int,int,int,*(int),*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
fd	int
,	O
mach_port_t	O
*	O
port	*(int)
,	O
mach_msg_type_name_t	O
*	O
portPoly	*(int)
)	O
{	O
return	O
_S_msg_get_fd	()->(int)
(	O
process	int
,	O
refport	int
,	O
fd	int
,	O
port	*(int)
,	O
portPoly	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_set_fd	(int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
int	O
fd	int
,	O
mach_port_t	O
port	*(int)
)	O
{	O
return	O
_S_msg_set_fd	()->(int)
(	O
process	int
,	O
refport	int
,	O
fd	int
,	O
port	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_get_environment	(int,*(int),*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
data_t	O
*	O
value	*(int)
,	O
mach_msg_type_number_t	O
*	O
valueCnt	*(int)
)	O
{	O
return	O
_S_msg_get_environment	()->(int)
(	O
process	int
,	O
value	*(int)
,	O
valueCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_set_environment	(int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
data_t	O
value	*(int)
,	O
mach_msg_type_number_t	O
valueCnt	*(int)
)	O
{	O
return	O
_S_msg_set_environment	()->(int)
(	O
process	int
,	O
refport	int
,	O
value	*(int)
,	O
valueCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_get_env_variable	(int,int,*(int),*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
string_t	O
variable	int
,	O
data_t	O
*	O
value	*(int)
,	O
mach_msg_type_number_t	O
*	O
valueCnt	*(int)
)	O
{	O
return	O
_S_msg_get_env_variable	()->(int)
(	O
process	int
,	O
variable	int
,	O
value	*(int)
,	O
valueCnt	*(int)
)	O
;	O
}	O
kern_return_t	O
S_msg_set_env_variable	(int,int,int,int,int)->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
string_t	O
variable	int
,	O
string_t	O
value	*(int)
,	O
boolean_t	O
replace	int
)	O
{	O
return	O
_S_msg_set_env_variable	()->(int)
(	O
process	int
,	O
refport	int
,	O
variable	int
,	O
value	*(int)
,	O
replace	int
)	O
;	O
}	O
error_t	O
S_msg_describe_ports	(int,int,int,int,*(int),*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
mach_port_t	O
refport	int
,	O
mach_port_array_t	O
names	int
,	O
mach_msg_type_number_t	O
namesCnt	int
,	O
data_t	O
*	O
descriptions	*(int)
,	O
mach_msg_type_number_t	O
*	O
descriptionsCnt	*(int)
)	O
{	O
return	O
_S_msg_describe_ports	()->(int)
(	O
process	int
,	O
refport	int
,	O
names	int
,	O
namesCnt	int
,	O
descriptions	*(int)
,	O
descriptionsCnt	*(int)
)	O
;	O
}	O
error_t	O
S_msg_report_wait	(int,int,int,*(int))->(int)
(	O
mach_port_t	O
process	int
,	O
thread_t	O
thread	int
,	O
string_t	O
desc	*(char)
,	O
mach_msg_id_t	O
*	O
rpc	*(int)
)	O
{	O
*	O
desc	*(char)
=	O
0	int
;	O
*	O
rpc	*(int)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
error_t	O
S_fsys_getroot	(int,int,*(int),int,*(int),int,int,*(int),*(char),*(int),*(int))->(int)
(	O
mach_port_t	O
fsys_t	int
,	O
mach_port_t	O
dotdotnode	int
,	O
uid_t	O
*	O
uids	int
,	O
size_t	O
nuids	int
,	O
uid_t	O
*	O
gids	int
,	O
size_t	O
ngids	int
,	O
int	O
flags	int
,	O
retry_type	O
*	O
do_retry	*(int)
,	O
char	O
*	O
retry_name	*(char)
,	O
mach_port_t	O
*	O
ret	*(int)
,	O
mach_msg_type_name_t	O
*	O
rettype	*(int)
)	O
{	O
int	O
is_root	int
=	O
0	int
;	O
size_t	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nuids	int
;	O
i	int
++	O
)	O
if	O
(	O
uids	int
[	O
i	int
]	O
==	O
0	int
)	O
{	O
is_root	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
is_root	int
)	O
return	O
EPERM	O
;	O
*	O
do_retry	*(int)
=	O
FS_RETRY_NORMAL	O
;	O
*	O
retry_name	*(char)
=	O
'\0'	O
;	O
*	O
ret	*(int)
=	O
startup	int
;	O
*	O
rettype	*(int)
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_fsys_get_options	(int,*(*(char)),*(int))->(int)
(	O
mach_port_t	O
control	int
,	O
char	O
*	O
*	O
data	*(*(char))
,	O
mach_msg_type_number_t	O
*	O
len	*(int)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_check_access	(int,*(int))->(int)
(	O
mach_port_t	O
server	*(char)
,	O
int	O
*	O
allowed	*(int)
)	O
{	O
if	O
(	O
server	*(char)
!=	O
startup	int
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
allowed	*(int)
=	O
0	int
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_stat	(int,*(struct))->(int)
(	O
mach_port_t	O
server	*(char)
,	O
struct	O
stat	O
*	O
st	*(struct)
)	O
{	O
if	O
(	O
server	*(char)
!=	O
startup	int
)	O
return	O
EOPNOTSUPP	O
;	O
memset	O
(	O
st	*(struct)
,	O
0	int
,	O
sizeof	O
*	O
st	*(struct)
)	O
;	O
st	*(struct)
->	O
st_fstype	O
=	O
FSTYPE_MISC	O
;	O
st	*(struct)
->	O
st_fsid	O
=	O
getpid	()->(int)
(	O
)	O
;	O
st	*(struct)
->	O
st_mode	O
=	O
S_IFCHR	O
|	O
S_IROOT	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_io_restrict_auth	(int,*(int),*(int),*(int),int,*(int),int)->(int)
(	O
mach_port_t	O
server	*(char)
,	O
mach_port_t	O
*	O
newport	*(int)
,	O
mach_msg_type_name_t	O
*	O
newporttype	*(int)
,	O
uid_t	O
*	O
uids	int
,	O
size_t	O
nuids	int
,	O
uid_t	O
*	O
gids	int
,	O
size_t	O
ngids	int
)	O
{	O
struct	O
idvec	O
user	struct
=	O
{	O
uids	int
,	O
(	O
unsigned	O
)	O
nuids	int
,	O
(	O
unsigned	O
)	O
nuids	int
}	O
;	O
if	O
(	O
server	*(char)
!=	O
startup	int
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
idvec_contains	()->(int)
(	O
&	O
user	struct
,	O
0	int
)	O
)	O
return	O
EPERM	O
;	O
*	O
newport	*(int)
=	O
server	*(char)
;	O
*	O
newporttype	*(int)
=	O
MACH_MSG_TYPE_COPY_SEND	O
;	O
return	O
0	int
;	O
}	O
