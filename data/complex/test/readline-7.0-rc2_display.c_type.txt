static	O
void	O
update_line	(*(char),*(char),int,int,int,int)->(void)
PARAMS	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
space_to_eol	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
delete_chars	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
insert_some_chars	(*(char),int,int)->(void)
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
open_some_spaces	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
cr	()->(void)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
redraw_prompt	(*(char))->(void)
PARAMS	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
expand_prompt	(*(char),int,*(int),*(int),*(int),*(int))->(*(char))
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
*	O
,	O
int	O
*	O
,	O
int	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
struct	O
line_state	struct(*(char),*(int),int,int,*(int))
{	O
char	O
*	O
line	*(char)
;	O
int	O
*	O
lbreaks	*(int)
;	O
int	O
lbsize	int
;	O
int	O
wbsize	int
;	O
int	O
*	O
wrapped_line	*(int)
;	O
}	O
;	O
static	O
struct	O
line_state	struct(*(char),*(int),int,int,*(int))
line_state_array	array(struct(*(char),*(int),int,int,*(int)))
[	O
2	int
]	O
;	O
static	O
struct	O
line_state	struct(*(char),*(int),int,int,*(int))
*	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
=	O
&	O
line_state_array	array(struct(*(char),*(int),int,int,*(int)))
[	O
0	int
]	O
;	O
static	O
struct	O
line_state	struct(*(char),*(int),int,int,*(int))
*	O
line_state_invisible	*(struct(*(char),*(int),int,int,*(int)))
=	O
&	O
line_state_array	array(struct(*(char),*(int),int,int,*(int)))
[	O
1	int
]	O
;	O
static	O
int	O
line_structures_initialized	int
=	O
0	int
;	O
static	O
int	O
_rl_col_width	(*(char),int,int,int)->(int)
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
rl_voidfunc_t	()->(void)
*	O
rl_redisplay_function	*(()->(void))
=	O
rl_redisplay	()->(void)
;	O
int	O
rl_display_fixed	int
=	O
0	int
;	O
int	O
_rl_suppress_redisplay	int
=	O
0	int
;	O
int	O
_rl_want_redisplay	int
=	O
0	int
;	O
char	O
*	O
rl_display_prompt	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
_rl_emacs_mode_str	*(char)
;	O
int	O
_rl_emacs_modestr_len	int
;	O
char	O
*	O
_rl_vi_ins_mode_str	*(char)
;	O
int	O
_rl_vi_ins_modestr_len	int
;	O
char	O
*	O
_rl_vi_cmd_mode_str	*(char)
;	O
int	O
_rl_vi_cmd_modestr_len	int
;	O
int	O
_rl_last_c_pos	int
=	O
0	int
;	O
int	O
_rl_last_v_pos	int
=	O
0	int
;	O
static	O
int	O
cpos_adjusted	int
;	O
static	O
int	O
cpos_buffer_position	int
;	O
static	O
int	O
displaying_prompt_first_line	int
;	O
static	O
int	O
prompt_multibyte_chars	int
;	O
int	O
_rl_vis_botlin	int
=	O
0	int
;	O
static	O
int	O
_rl_inv_botlin	int
=	O
0	int
;	O
static	O
int	O
last_lmargin	int
;	O
static	O
char	O
*	O
msg_buf	*(char)
=	O
0	int
;	O
static	O
int	O
msg_bufsiz	int
=	O
0	int
;	O
static	O
int	O
forced_display	int
;	O
static	O
int	O
line_size	int
=	O
1024	int
;	O
static	O
char	O
*	O
local_prompt	*(char)
,	O
*	O
local_prompt_prefix	*(char)
;	O
static	O
int	O
local_prompt_len	int
;	O
static	O
int	O
prompt_visible_length	int
,	O
prompt_prefix_length	int
;	O
static	O
int	O
visible_wrap_offset	int
;	O
static	O
int	O
wrap_offset	int
;	O
static	O
int	O
prompt_last_invisible	int
;	O
static	O
int	O
visible_first_line_len	int
;	O
static	O
int	O
prompt_invis_chars_first_line	int
;	O
static	O
int	O
prompt_last_screen_line	int
;	O
static	O
int	O
prompt_physical_chars	int
;	O
static	O
int	O
modmark	int
;	O
static	O
char	O
*	O
saved_local_prompt	*(char)
;	O
static	O
char	O
*	O
saved_local_prefix	*(char)
;	O
static	O
int	O
saved_last_invisible	int
;	O
static	O
int	O
saved_visible_length	int
;	O
static	O
int	O
saved_prefix_length	int
;	O
static	O
int	O
saved_local_length	int
;	O
static	O
int	O
saved_invis_chars_first_line	int
;	O
static	O
int	O
saved_physical_chars	int
;	O
static	O
char	O
*	O
prompt_modestr	(*(int))->(*(char))
(	O
lenp	*(int)
)	O
int	O
*	O
lenp	*(int)
;	O
{	O
if	O
(	O
rl_editing_mode	int
==	O
emacs_mode	int
)	O
{	O
if	O
(	O
lenp	*(int)
)	O
*	O
lenp	*(int)
=	O
_rl_emacs_mode_str	*(char)
?	O
_rl_emacs_modestr_len	int
:	O
RL_EMACS_MODESTR_DEFLEN	int
;	O
return	O
_rl_emacs_mode_str	*(char)
?	O
_rl_emacs_mode_str	*(char)
:	O
RL_EMACS_MODESTR_DEFAULT	*(char)
;	O
}	O
else	O
if	O
(	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
==	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
)	O
{	O
if	O
(	O
lenp	*(int)
)	O
*	O
lenp	*(int)
=	O
_rl_vi_ins_mode_str	*(char)
?	O
_rl_vi_ins_modestr_len	int
:	O
RL_VI_INS_MODESTR_DEFLEN	int
;	O
return	O
_rl_vi_ins_mode_str	*(char)
?	O
_rl_vi_ins_mode_str	*(char)
:	O
RL_VI_INS_MODESTR_DEFAULT	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
lenp	*(int)
)	O
*	O
lenp	*(int)
=	O
_rl_vi_cmd_mode_str	*(char)
?	O
_rl_vi_cmd_modestr_len	int
:	O
RL_VI_CMD_MODESTR_DEFLEN	int
;	O
return	O
_rl_vi_cmd_mode_str	*(char)
?	O
_rl_vi_cmd_mode_str	*(char)
:	O
RL_VI_CMD_MODESTR_DEFAULT	*(char)
;	O
}	O
}	O
static	O
char	O
*	O
expand_prompt	(*(char),int,*(int),*(int),*(int),*(int))->(*(char))
(	O
pmt	*(char)
,	O
flags	int
,	O
lp	*(int)
,	O
lip	*(int)
,	O
niflp	*(int)
,	O
vlp	*(int)
)	O
char	O
*	O
pmt	*(char)
;	O
int	O
flags	int
;	O
int	O
*	O
lp	*(int)
,	O
*	O
lip	*(int)
,	O
*	O
niflp	*(int)
,	O
*	O
vlp	*(int)
;	O
{	O
char	O
*	O
r	*(char)
,	O
*	O
ret	*(char)
,	O
*	O
p	*(char)
,	O
*	O
igstart	*(char)
,	O
*	O
nprompt	*(char)
,	O
*	O
ms	*(char)
;	O
int	O
l	int
,	O
rl	int
,	O
last	int
,	O
ignoring	int
,	O
ninvis	int
,	O
invfl	int
,	O
invflset	int
,	O
ind	int
,	O
pind	int
,	O
physchars	int
;	O
int	O
mlen	int
;	O
ms	*(char)
=	O
(	O
(	O
(	O
pmt	*(char)
==	O
rl_prompt	*(char)
)	O
^	O
(	O
flags	int
&	O
PMT_MULTILINE	int
)	O
)	O
&&	O
_rl_show_mode_in_prompt	int
)	O
?	O
prompt_modestr	(*(int))->(*(char))
(	O
&	O
mlen	int
)	O
:	O
0	int
;	O
if	O
(	O
ms	*(char)
)	O
{	O
l	int
=	O
strlen	(*(char))->(long)
(	O
pmt	*(char)
)	O
;	O
nprompt	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
l	int
+	O
mlen	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
nprompt	*(char)
,	O
ms	*(char)
,	O
mlen	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
nprompt	*(char)
+	O
mlen	int
,	O
pmt	*(char)
)	O
;	O
}	O
else	O
nprompt	*(char)
=	O
pmt	*(char)
;	O
if	O
(	O
(	O
MB_CUR_MAX	O
<=	O
1	int
||	O
rl_byte_oriented	int
)	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
nprompt	*(char)
,	O
RL_PROMPT_START_IGNORE	char
)	O
==	O
0	int
)	O
{	O
r	*(char)
=	O
(	O
nprompt	*(char)
==	O
pmt	*(char)
)	O
?	O
savestring	O
(	O
pmt	*(char)
)	O
:	O
nprompt	*(char)
;	O
if	O
(	O
lp	*(int)
)	O
*	O
lp	*(int)
=	O
strlen	(*(char))->(long)
(	O
r	*(char)
)	O
;	O
if	O
(	O
lip	*(int)
)	O
*	O
lip	*(int)
=	O
0	int
;	O
if	O
(	O
niflp	*(int)
)	O
*	O
niflp	*(int)
=	O
0	int
;	O
if	O
(	O
vlp	*(int)
)	O
*	O
vlp	*(int)
=	O
lp	*(int)
?	O
*	O
lp	*(int)
:	O
strlen	(*(char))->(long)
(	O
r	*(char)
)	O
;	O
return	O
r	*(char)
;	O
}	O
l	int
=	O
strlen	(*(char))->(long)
(	O
nprompt	*(char)
)	O
;	O
r	*(char)
=	O
ret	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
l	int
+	O
1	int
)	O
;	O
rl	int
=	O
physchars	int
=	O
0	int
;	O
invfl	int
=	O
0	int
;	O
invflset	int
=	O
0	int
;	O
igstart	*(char)
=	O
0	int
;	O
for	O
(	O
ignoring	int
=	O
last	int
=	O
ninvis	int
=	O
0	int
,	O
p	*(char)
=	O
nprompt	*(char)
;	O
p	*(char)
&&	O
*	O
p	*(char)
;	O
p	*(char)
++	O
)	O
{	O
if	O
(	O
ignoring	int
==	O
0	int
&&	O
*	O
p	*(char)
==	O
RL_PROMPT_START_IGNORE	char
)	O
{	O
ignoring	int
=	O
1	int
;	O
igstart	*(char)
=	O
p	*(char)
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
ignoring	int
&&	O
*	O
p	*(char)
==	O
RL_PROMPT_END_IGNORE	char
)	O
{	O
ignoring	int
=	O
0	int
;	O
if	O
(	O
p	*(char)
!=	O
(	O
igstart	*(char)
+	O
1	int
)	O
)	O
last	int
=	O
r	*(char)
-	O
ret	*(char)
-	O
1	int
;	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
pind	int
=	O
p	*(char)
-	O
nprompt	*(char)
;	O
ind	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
nprompt	*(char)
,	O
pind	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
l	int
=	O
ind	int
-	O
pind	int
;	O
while	O
(	O
l	int
--	O
)	O
*	O
r	*(char)
++	O
=	O
*	O
p	*(char)
++	O
;	O
if	O
(	O
!	O
ignoring	int
)	O
{	O
rl	int
+=	O
ind	int
-	O
pind	int
;	O
physchars	int
+=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
nprompt	*(char)
,	O
pind	int
,	O
ind	int
,	O
0	int
)	O
;	O
}	O
else	O
ninvis	int
+=	O
ind	int
-	O
pind	int
;	O
p	*(char)
--	O
;	O
}	O
else	O
{	O
*	O
r	*(char)
++	O
=	O
*	O
p	*(char)
;	O
if	O
(	O
!	O
ignoring	int
)	O
{	O
rl	int
++	O
;	O
physchars	int
++	O
;	O
}	O
else	O
ninvis	int
++	O
;	O
}	O
if	O
(	O
invflset	int
==	O
0	int
&&	O
rl	int
>=	O
_rl_screenwidth	int
)	O
{	O
invfl	int
=	O
ninvis	int
;	O
invflset	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
rl	int
<	O
_rl_screenwidth	int
)	O
invfl	int
=	O
ninvis	int
;	O
*	O
r	*(char)
=	O
'\0'	O
;	O
if	O
(	O
lp	*(int)
)	O
*	O
lp	*(int)
=	O
rl	int
;	O
if	O
(	O
lip	*(int)
)	O
*	O
lip	*(int)
=	O
last	int
;	O
if	O
(	O
niflp	*(int)
)	O
*	O
niflp	*(int)
=	O
invfl	int
;	O
if	O
(	O
vlp	*(int)
)	O
*	O
vlp	*(int)
=	O
physchars	int
;	O
if	O
(	O
nprompt	*(char)
!=	O
pmt	*(char)
)	O
free	(*(void))->(void)
(	O
nprompt	*(char)
)	O
;	O
return	O
ret	*(char)
;	O
}	O
char	O
*	O
_rl_strip_prompt	(*(char))->(*(char))
(	O
pmt	*(char)
)	O
char	O
*	O
pmt	*(char)
;	O
{	O
char	O
*	O
ret	*(char)
;	O
ret	*(char)
=	O
expand_prompt	(*(char),int,*(int),*(int),*(int),*(int))->(*(char))
(	O
pmt	*(char)
,	O
0	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
return	O
ret	*(char)
;	O
}	O
void	O
_rl_reset_prompt	()->(void)
(	O
)	O
{	O
rl_visible_prompt_length	int
=	O
rl_expand_prompt	(*(char))->(int)
(	O
rl_prompt	*(char)
)	O
;	O
}	O
int	O
rl_expand_prompt	(*(char))->(int)
(	O
prompt	*(char)
)	O
char	O
*	O
prompt	*(char)
;	O
{	O
char	O
*	O
p	*(char)
,	O
*	O
t	*(char)
;	O
int	O
c	int
;	O
FREE	O
(	O
local_prompt	*(char)
)	O
;	O
FREE	O
(	O
local_prompt_prefix	*(char)
)	O
;	O
local_prompt	*(char)
=	O
local_prompt_prefix	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
local_prompt_len	int
=	O
0	int
;	O
prompt_last_invisible	int
=	O
prompt_invis_chars_first_line	int
=	O
0	int
;	O
prompt_visible_length	int
=	O
prompt_physical_chars	int
=	O
0	int
;	O
if	O
(	O
prompt	*(char)
==	O
0	int
||	O
*	O
prompt	*(char)
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
p	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
prompt	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
p	*(char)
==	O
0	int
)	O
{	O
local_prompt	*(char)
=	O
expand_prompt	(*(char),int,*(int),*(int),*(int),*(int))->(*(char))
(	O
prompt	*(char)
,	O
0	int
,	O
&	O
prompt_visible_length	int
,	O
&	O
prompt_last_invisible	int
,	O
&	O
prompt_invis_chars_first_line	int
,	O
&	O
prompt_physical_chars	int
)	O
;	O
local_prompt_prefix	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
local_prompt_len	int
=	O
local_prompt	*(char)
?	O
strlen	(*(char))->(long)
(	O
local_prompt	*(char)
)	O
:	O
0	int
;	O
return	O
(	O
prompt_visible_length	int
)	O
;	O
}	O
else	O
{	O
t	*(char)
=	O
++	O
p	*(char)
;	O
local_prompt	*(char)
=	O
expand_prompt	(*(char),int,*(int),*(int),*(int),*(int))->(*(char))
(	O
p	*(char)
,	O
PMT_MULTILINE	int
,	O
&	O
prompt_visible_length	int
,	O
&	O
prompt_last_invisible	int
,	O
&	O
prompt_invis_chars_first_line	int
,	O
&	O
prompt_physical_chars	int
)	O
;	O
c	int
=	O
*	O
t	*(char)
;	O
*	O
t	*(char)
=	O
'\0'	O
;	O
local_prompt_prefix	*(char)
=	O
expand_prompt	(*(char),int,*(int),*(int),*(int),*(int))->(*(char))
(	O
prompt	*(char)
,	O
PMT_MULTILINE	int
,	O
&	O
prompt_prefix_length	int
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
*	O
t	*(char)
=	O
c	int
;	O
local_prompt_len	int
=	O
local_prompt	*(char)
?	O
strlen	(*(char))->(long)
(	O
local_prompt	*(char)
)	O
:	O
0	int
;	O
return	O
(	O
prompt_prefix_length	int
)	O
;	O
}	O
}	O
static	O
void	O
init_line_structures	(int)->(void)
(	O
minsize	int
)	O
int	O
minsize	int
;	O
{	O
register	O
int	O
n	int
;	O
if	O
(	O
invisible_line	O
==	O
0	int
)	O
{	O
if	O
(	O
line_size	int
<	O
minsize	int
)	O
line_size	int
=	O
minsize	int
;	O
visible_line	O
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
line_size	int
)	O
;	O
invisible_line	O
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
line_size	int
)	O
;	O
}	O
else	O
if	O
(	O
line_size	int
<	O
minsize	int
)	O
{	O
line_size	int
*=	O
2	int
;	O
if	O
(	O
line_size	int
<	O
minsize	int
)	O
line_size	int
=	O
minsize	int
;	O
visible_line	O
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
visible_line	O
,	O
line_size	int
)	O
;	O
invisible_line	O
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
invisible_line	O
,	O
line_size	int
)	O
;	O
}	O
for	O
(	O
n	int
=	O
minsize	int
;	O
n	int
<	O
line_size	int
;	O
n	int
++	O
)	O
{	O
visible_line	O
[	O
n	int
]	O
=	O
0	int
;	O
invisible_line	O
[	O
n	int
]	O
=	O
1	int
;	O
}	O
if	O
(	O
vis_lbreaks	O
==	O
0	int
)	O
{	O
inv_lbsize	O
=	O
vis_lbsize	O
=	O
256	int
;	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wbsize	int
=	O
vis_lbsize	O
;	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wrapped_line	*(int)
=	O
(	O
int	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wbsize	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
line_state_invisible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wbsize	int
=	O
inv_lbsize	O
;	O
line_state_invisible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wrapped_line	*(int)
=	O
(	O
int	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
line_state_invisible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wbsize	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
inv_lbreaks	O
=	O
(	O
int	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
inv_lbsize	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
vis_lbreaks	O
=	O
(	O
int	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
vis_lbsize	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
inv_lbreaks	O
[	O
0	int
]	O
=	O
vis_lbreaks	O
[	O
0	int
]	O
=	O
0	int
;	O
}	O
line_structures_initialized	int
=	O
1	int
;	O
}	O
void	O
rl_redisplay	()->(void)
(	O
)	O
{	O
register	O
int	O
in	int
,	O
out	int
,	O
c	int
,	O
linenum	int
,	O
cursor_linenum	int
;	O
register	O
char	O
*	O
line	*(char)
;	O
int	O
inv_botlin	int
,	O
lb_botlin	int
,	O
lb_linenum	int
,	O
o_cpos	int
;	O
int	O
newlines	int
,	O
lpos	int
,	O
temp	int
,	O
n0	int
,	O
num	int
,	O
prompt_lines_estimate	int
;	O
char	O
*	O
prompt_this_line	*(char)
;	O
int	O
mb_cur_max	int
=	O
MB_CUR_MAX	O
;	O
wchar_t	int
wc	int
;	O
size_t	long
wc_bytes	long
;	O
int	O
wc_width	int
;	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
;	O
int	O
_rl_wrapped_multicolumn	int
=	O
0	int
;	O
if	O
(	O
_rl_echoing_p	int
==	O
0	int
)	O
return	O
;	O
_rl_block_sigint	()->(void)
(	O
)	O
;	O
RL_SETSTATE	O
(	O
RL_STATE_REDISPLAYING	int
)	O
;	O
if	O
(	O
!	O
rl_display_prompt	*(char)
)	O
rl_display_prompt	*(char)
=	O
""	*(char)
;	O
if	O
(	O
line_structures_initialized	int
==	O
0	int
)	O
{	O
init_line_structures	(int)->(void)
(	O
0	int
)	O
;	O
rl_on_new_line	()->(int)
(	O
)	O
;	O
}	O
cpos_buffer_position	int
=	O
-	O
1	int
;	O
prompt_multibyte_chars	int
=	O
prompt_visible_length	int
-	O
prompt_physical_chars	int
;	O
line	*(char)
=	O
invisible_line	O
;	O
out	int
=	O
inv_botlin	int
=	O
0	int
;	O
modmark	int
=	O
0	int
;	O
if	O
(	O
_rl_mark_modified_lines	int
&&	O
current_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
&&	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
{	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
'*'	O
;	O
line	*(char)
[	O
out	int
]	O
=	O
'\0'	O
;	O
modmark	int
=	O
1	int
;	O
}	O
if	O
(	O
visible_line	O
[	O
0	int
]	O
!=	O
invisible_line	O
[	O
0	int
]	O
)	O
rl_display_fixed	int
=	O
0	int
;	O
if	O
(	O
rl_display_prompt	*(char)
==	O
rl_prompt	*(char)
||	O
local_prompt	*(char)
)	O
{	O
if	O
(	O
local_prompt_prefix	*(char)
&&	O
forced_display	int
)	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
local_prompt_prefix	*(char)
,	O
strlen	(*(char))->(long)
(	O
local_prompt_prefix	*(char)
)	O
)	O
;	O
if	O
(	O
local_prompt_len	int
>	O
0	int
)	O
{	O
temp	int
=	O
local_prompt_len	int
+	O
out	int
+	O
2	int
;	O
if	O
(	O
temp	int
>=	O
line_size	int
)	O
{	O
line_size	int
=	O
(	O
temp	int
+	O
1024	int
)	O
-	O
(	O
temp	int
%	O
1024	int
)	O
;	O
visible_line	O
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
visible_line	O
,	O
line_size	int
)	O
;	O
line	*(char)
=	O
invisible_line	O
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
invisible_line	O
,	O
line_size	int
)	O
;	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
line	*(char)
+	O
out	int
,	O
local_prompt	*(char)
,	O
local_prompt_len	int
)	O
;	O
out	int
+=	O
local_prompt_len	int
;	O
}	O
line	*(char)
[	O
out	int
]	O
=	O
'\0'	O
;	O
wrap_offset	int
=	O
local_prompt_len	int
-	O
prompt_visible_length	int
;	O
}	O
else	O
{	O
int	O
pmtlen	int
;	O
prompt_this_line	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
rl_display_prompt	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
prompt_this_line	*(char)
)	O
prompt_this_line	*(char)
=	O
rl_display_prompt	*(char)
;	O
else	O
{	O
prompt_this_line	*(char)
++	O
;	O
pmtlen	int
=	O
prompt_this_line	*(char)
-	O
rl_display_prompt	*(char)
;	O
if	O
(	O
forced_display	int
)	O
{	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
rl_display_prompt	*(char)
,	O
pmtlen	int
)	O
;	O
if	O
(	O
pmtlen	int
<	O
2	int
||	O
prompt_this_line	*(char)
[	O
-	O
2	int
]	O
!=	O
'\r'	O
)	O
cr	()->(void)
(	O
)	O
;	O
}	O
}	O
prompt_physical_chars	int
=	O
pmtlen	int
=	O
strlen	(*(char))->(long)
(	O
prompt_this_line	*(char)
)	O
;	O
temp	int
=	O
pmtlen	int
+	O
out	int
+	O
2	int
;	O
if	O
(	O
temp	int
>=	O
line_size	int
)	O
{	O
line_size	int
=	O
(	O
temp	int
+	O
1024	int
)	O
-	O
(	O
temp	int
%	O
1024	int
)	O
;	O
visible_line	O
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
visible_line	O
,	O
line_size	int
)	O
;	O
line	*(char)
=	O
invisible_line	O
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
invisible_line	O
,	O
line_size	int
)	O
;	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
line	*(char)
+	O
out	int
,	O
prompt_this_line	*(char)
,	O
pmtlen	int
)	O
;	O
out	int
+=	O
pmtlen	int
;	O
line	*(char)
[	O
out	int
]	O
=	O
'\0'	O
;	O
wrap_offset	int
=	O
prompt_invis_chars_first_line	int
=	O
0	int
;	O
}	O
inv_lbreaks	O
[	O
newlines	int
=	O
0	int
]	O
=	O
0	int
;	O
lpos	int
=	O
prompt_physical_chars	int
+	O
modmark	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
line_state_invisible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wrapped_line	*(int)
,	O
0	int
,	O
line_state_invisible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wbsize	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
num	int
=	O
0	int
;	O
prompt_lines_estimate	int
=	O
lpos	int
/	O
_rl_screenwidth	int
;	O
while	O
(	O
lpos	int
>=	O
_rl_screenwidth	int
)	O
{	O
int	O
z	int
,	O
p	*(char)
;	O
int	O
nocorrect	int
,	O
wadjust	int
;	O
nocorrect	int
=	O
0	int
;	O
wadjust	int
=	O
(	O
newlines	int
==	O
0	int
)	O
?	O
prompt_invis_chars_first_line	int
:	O
(	O
(	O
newlines	int
==	O
prompt_lines_estimate	int
)	O
?	O
wrap_offset	int
:	O
prompt_invis_chars_first_line	int
)	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
&&	O
prompt_multibyte_chars	int
>	O
0	int
)	O
{	O
nocorrect	int
=	O
1	int
;	O
n0	int
=	O
num	int
;	O
temp	int
=	O
local_prompt_len	int
;	O
while	O
(	O
num	int
<	O
temp	int
)	O
{	O
z	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
local_prompt	*(char)
,	O
n0	int
,	O
num	int
,	O
1	int
)	O
-	O
wadjust	int
;	O
if	O
(	O
z	int
>	O
_rl_screenwidth	int
)	O
{	O
num	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
local_prompt	*(char)
,	O
num	int
,	O
MB_FIND_ANY	int
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
z	int
==	O
_rl_screenwidth	int
)	O
{	O
p	*(char)
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
local_prompt	*(char)
,	O
num	int
,	O
MB_FIND_ANY	int
)	O
;	O
num	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
local_prompt	*(char)
,	O
p	*(char)
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
;	O
break	O
;	O
}	O
num	int
++	O
;	O
}	O
temp	int
=	O
num	int
;	O
}	O
else	O
temp	int
=	O
(	O
(	O
newlines	int
+	O
1	int
)	O
*	O
_rl_screenwidth	int
)	O
;	O
if	O
(	O
nocorrect	int
==	O
0	int
)	O
temp	int
+=	O
wadjust	int
;	O
inv_lbreaks	O
[	O
++	O
newlines	int
]	O
=	O
temp	int
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
&&	O
prompt_multibyte_chars	int
>	O
0	int
)	O
lpos	int
-=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
local_prompt	*(char)
,	O
n0	int
,	O
num	int
,	O
1	int
)	O
-	O
wadjust	int
;	O
else	O
lpos	int
-=	O
_rl_screenwidth	int
;	O
}	O
prompt_last_screen_line	int
=	O
newlines	int
;	O
lb_linenum	int
=	O
0	int
;	O
in	int
=	O
0	int
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
wc_bytes	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
rl_line_buffer	*(char)
,	O
rl_end	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
}	O
else	O
wc_bytes	long
=	O
1	int
;	O
while	O
(	O
in	int
<	O
rl_end	int
)	O
{	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
rl_line_buffer	*(char)
[	O
in	int
]	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
if	O
(	O
MB_INVALIDCH	O
(	O
wc_bytes	long
)	O
)	O
{	O
wc_bytes	long
=	O
1	int
;	O
wc_width	int
=	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
wc_bytes	long
)	O
)	O
break	O
;	O
else	O
{	O
temp	int
=	O
WCWIDTH	O
(	O
wc	int
)	O
;	O
wc_width	int
=	O
(	O
temp	int
>=	O
0	int
)	O
?	O
temp	int
:	O
1	int
;	O
}	O
}	O
if	O
(	O
out	int
+	O
8	int
>=	O
line_size	int
)	O
{	O
line_size	int
*=	O
2	int
;	O
visible_line	O
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
visible_line	O
,	O
line_size	int
)	O
;	O
invisible_line	O
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
invisible_line	O
,	O
line_size	int
)	O
;	O
line	*(char)
=	O
invisible_line	O
;	O
}	O
if	O
(	O
in	int
==	O
rl_point	int
)	O
{	O
cpos_buffer_position	int
=	O
out	int
;	O
lb_linenum	int
=	O
newlines	int
;	O
}	O
if	O
(	O
META_CHAR	O
(	O
c	int
)	O
&&	O
_rl_output_meta_chars	int
==	O
0	int
)	O
{	O
if	O
(	O
_rl_output_meta_chars	int
==	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
line	*(char)
+	O
out	int
,	O
"\\%o"	*(char)
,	O
c	int
)	O
;	O
if	O
(	O
lpos	int
+	O
4	int
>=	O
_rl_screenwidth	int
)	O
{	O
temp	int
=	O
_rl_screenwidth	int
-	O
lpos	int
;	O
CHECK_INV_LBREAKS	O
(	O
)	O
;	O
inv_lbreaks	O
[	O
++	O
newlines	int
]	O
=	O
out	int
+	O
temp	int
;	O
lpos	int
=	O
4	int
-	O
temp	int
;	O
}	O
else	O
lpos	int
+=	O
4	int
;	O
out	int
+=	O
4	int
;	O
}	O
else	O
{	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
c	int
;	O
CHECK_LPOS	O
(	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
{	O
register	O
int	O
newout	int
;	O
newout	int
=	O
out	int
+	O
8	int
-	O
lpos	int
%	O
8	int
;	O
temp	int
=	O
newout	int
-	O
out	int
;	O
if	O
(	O
lpos	int
+	O
temp	int
>=	O
_rl_screenwidth	int
)	O
{	O
register	O
int	O
temp2	int
;	O
temp2	int
=	O
_rl_screenwidth	int
-	O
lpos	int
;	O
CHECK_INV_LBREAKS	O
(	O
)	O
;	O
inv_lbreaks	O
[	O
++	O
newlines	int
]	O
=	O
out	int
+	O
temp2	int
;	O
lpos	int
=	O
temp	int
-	O
temp2	int
;	O
while	O
(	O
out	int
<	O
newout	int
)	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
' '	O
;	O
}	O
else	O
{	O
while	O
(	O
out	int
<	O
newout	int
)	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
' '	O
;	O
lpos	int
+=	O
temp	int
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
'\n'	O
&&	O
_rl_horizontal_scroll_mode	int
==	O
0	int
&&	O
_rl_term_up	*(char)
&&	O
*	O
_rl_term_up	*(char)
)	O
{	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
'\0'	O
;	O
CHECK_INV_LBREAKS	O
(	O
)	O
;	O
inv_lbreaks	O
[	O
++	O
newlines	int
]	O
=	O
out	int
;	O
lpos	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
||	O
c	int
==	O
RUBOUT	int
)	O
{	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
'^'	O
;	O
CHECK_LPOS	O
(	O
)	O
;	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
CTRL_CHAR	O
(	O
c	int
)	O
?	O
UNCTRL	O
(	O
c	int
)	O
:	O
'?'	O
;	O
CHECK_LPOS	O
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
register	O
int	O
i	int
;	O
_rl_wrapped_multicolumn	int
=	O
0	int
;	O
if	O
(	O
_rl_screenwidth	int
<	O
lpos	int
+	O
wc_width	int
)	O
for	O
(	O
i	int
=	O
lpos	int
;	O
i	int
<	O
_rl_screenwidth	int
;	O
i	int
++	O
)	O
{	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
' '	O
;	O
_rl_wrapped_multicolumn	int
++	O
;	O
CHECK_LPOS	O
(	O
)	O
;	O
}	O
if	O
(	O
in	int
==	O
rl_point	int
)	O
{	O
cpos_buffer_position	int
=	O
out	int
;	O
lb_linenum	int
=	O
newlines	int
;	O
}	O
for	O
(	O
i	int
=	O
in	int
;	O
i	int
<	O
in	int
+	O
wc_bytes	long
;	O
i	int
++	O
)	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
rl_line_buffer	*(char)
[	O
i	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wc_width	int
;	O
i	int
++	O
)	O
CHECK_LPOS	O
(	O
)	O
;	O
}	O
else	O
{	O
line	*(char)
[	O
out	int
++	O
]	O
=	O
c	int
;	O
CHECK_LPOS	O
(	O
)	O
;	O
}	O
}	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
in	int
+=	O
wc_bytes	long
;	O
wc_bytes	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
rl_line_buffer	*(char)
+	O
in	int
,	O
rl_end	int
-	O
in	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
}	O
else	O
in	int
++	O
;	O
}	O
line	*(char)
[	O
out	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
cpos_buffer_position	int
<	O
0	int
)	O
{	O
cpos_buffer_position	int
=	O
out	int
;	O
lb_linenum	int
=	O
newlines	int
;	O
}	O
inv_botlin	int
=	O
lb_botlin	int
=	O
_rl_inv_botlin	int
=	O
newlines	int
;	O
CHECK_INV_LBREAKS	O
(	O
)	O
;	O
inv_lbreaks	O
[	O
newlines	int
+	O
1	int
]	O
=	O
out	int
;	O
cursor_linenum	int
=	O
lb_linenum	int
;	O
displaying_prompt_first_line	int
=	O
1	int
;	O
if	O
(	O
_rl_horizontal_scroll_mode	int
==	O
0	int
&&	O
_rl_term_up	*(char)
&&	O
*	O
_rl_term_up	*(char)
)	O
{	O
int	O
nleft	int
,	O
pos	int
,	O
changed_screen_line	int
,	O
tx	int
;	O
if	O
(	O
!	O
rl_display_fixed	int
||	O
forced_display	int
)	O
{	O
forced_display	int
=	O
0	int
;	O
if	O
(	O
out	int
>=	O
_rl_screenchars	int
)	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
out	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
line	*(char)
,	O
_rl_screenchars	int
,	O
MB_FIND_ANY	int
)	O
;	O
else	O
out	int
=	O
_rl_screenchars	int
-	O
1	int
;	O
}	O
for	O
(	O
linenum	int
=	O
0	int
;	O
linenum	int
<=	O
inv_botlin	int
;	O
linenum	int
++	O
)	O
{	O
o_cpos	int
=	O
_rl_last_c_pos	int
;	O
cpos_adjusted	int
=	O
0	int
;	O
update_line	(*(char),*(char),int,int,int,int)->(void)
(	O
VIS_LINE	O
(	O
linenum	int
)	O
,	O
INV_LINE	O
(	O
linenum	int
)	O
,	O
linenum	int
,	O
VIS_LLEN	O
(	O
linenum	int
)	O
,	O
INV_LLEN	O
(	O
linenum	int
)	O
,	O
inv_botlin	int
)	O
;	O
if	O
(	O
linenum	int
==	O
0	int
&&	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
&&	O
OLD_CPOS_IN_PROMPT	O
(	O
)	O
)	O
_rl_last_c_pos	int
-=	O
prompt_invis_chars_first_line	int
;	O
else	O
if	O
(	O
linenum	int
==	O
prompt_last_screen_line	int
&&	O
prompt_physical_chars	int
>	O
_rl_screenwidth	int
&&	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
&&	O
cpos_adjusted	int
==	O
0	int
&&	O
_rl_last_c_pos	int
!=	O
o_cpos	int
&&	O
_rl_last_c_pos	int
>	O
(	O
prompt_last_invisible	int
-	O
_rl_screenwidth	int
-	O
prompt_invis_chars_first_line	int
)	O
)	O
_rl_last_c_pos	int
-=	O
(	O
wrap_offset	int
-	O
prompt_invis_chars_first_line	int
)	O
;	O
if	O
(	O
linenum	int
==	O
0	int
&&	O
inv_botlin	int
==	O
0	int
&&	O
_rl_last_c_pos	int
==	O
out	int
&&	O
(	O
wrap_offset	int
>	O
visible_wrap_offset	int
)	O
&&	O
(	O
_rl_last_c_pos	int
<	O
visible_first_line_len	int
)	O
)	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
nleft	int
=	O
_rl_screenwidth	int
-	O
_rl_last_c_pos	int
;	O
else	O
nleft	int
=	O
_rl_screenwidth	int
+	O
wrap_offset	int
-	O
_rl_last_c_pos	int
;	O
if	O
(	O
nleft	int
)	O
_rl_clear_to_eol	(int)->(void)
(	O
nleft	int
)	O
;	O
}	O
if	O
(	O
linenum	int
==	O
0	int
)	O
visible_first_line_len	int
=	O
(	O
inv_botlin	int
>	O
0	int
)	O
?	O
inv_lbreaks	O
[	O
1	int
]	O
:	O
out	int
-	O
wrap_offset	int
;	O
}	O
if	O
(	O
_rl_vis_botlin	int
>	O
inv_botlin	int
)	O
{	O
char	O
*	O
tt	*(char)
;	O
for	O
(	O
;	O
linenum	int
<=	O
_rl_vis_botlin	int
;	O
linenum	int
++	O
)	O
{	O
tt	*(char)
=	O
VIS_CHARS	O
(	O
linenum	int
)	O
;	O
_rl_move_vert	(int)->(void)
(	O
linenum	int
)	O
;	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
0	int
,	O
tt	*(char)
)	O
;	O
_rl_clear_to_eol	(int)->(void)
(	O
(	O
linenum	int
==	O
_rl_vis_botlin	int
)	O
?	O
strlen	(*(char))->(long)
(	O
tt	*(char)
)	O
:	O
_rl_screenwidth	int
)	O
;	O
}	O
}	O
_rl_vis_botlin	int
=	O
inv_botlin	int
;	O
changed_screen_line	int
=	O
_rl_last_v_pos	int
!=	O
cursor_linenum	int
;	O
if	O
(	O
changed_screen_line	int
)	O
{	O
_rl_move_vert	(int)->(void)
(	O
cursor_linenum	int
)	O
;	O
if	O
(	O
(	O
mb_cur_max	int
==	O
1	int
||	O
rl_byte_oriented	int
)	O
&&	O
cursor_linenum	int
==	O
0	int
&&	O
wrap_offset	int
)	O
_rl_last_c_pos	int
+=	O
wrap_offset	int
;	O
}	O
nleft	int
=	O
prompt_visible_length	int
+	O
wrap_offset	int
;	O
if	O
(	O
cursor_linenum	int
==	O
0	int
&&	O
wrap_offset	int
>	O
0	int
&&	O
_rl_last_c_pos	int
>	O
0	int
&&	O
_rl_last_c_pos	int
<	O
PROMPT_ENDING_INDEX	O
&&	O
local_prompt	*(char)
)	O
{	O
if	O
(	O
_rl_term_cr	*(char)
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
if	O
(	O
modmark	int
)	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
"*"	*(char)
,	O
1	int
)	O
;	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
local_prompt	*(char)
,	O
nleft	int
)	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
_rl_last_c_pos	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
local_prompt	*(char)
,	O
0	int
,	O
nleft	int
,	O
1	int
)	O
-	O
wrap_offset	int
+	O
modmark	int
;	O
else	O
_rl_last_c_pos	int
=	O
nleft	int
+	O
modmark	int
;	O
}	O
pos	int
=	O
inv_lbreaks	O
[	O
cursor_linenum	int
]	O
;	O
nleft	int
=	O
cpos_buffer_position	int
-	O
pos	int
;	O
if	O
(	O
wrap_offset	int
&&	O
cursor_linenum	int
==	O
0	int
&&	O
nleft	int
<	O
_rl_last_c_pos	int
)	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
tx	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
&	O
visible_line	O
[	O
pos	int
]	O
,	O
0	int
,	O
nleft	int
,	O
1	int
)	O
-	O
visible_wrap_offset	int
;	O
else	O
tx	int
=	O
nleft	int
;	O
if	O
(	O
tx	int
>=	O
0	int
&&	O
_rl_last_c_pos	int
>	O
tx	int
)	O
{	O
_rl_backspace	(int)->(int)
(	O
_rl_last_c_pos	int
-	O
tx	int
)	O
;	O
_rl_last_c_pos	int
=	O
tx	int
;	O
}	O
}	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
nleft	int
,	O
&	O
invisible_line	O
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
nleft	int
!=	O
_rl_last_c_pos	int
)	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
nleft	int
,	O
&	O
invisible_line	O
[	O
pos	int
]	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
lmargin	int
,	O
ndisp	int
,	O
nleft	int
,	O
phys_c_pos	int
,	O
t	*(char)
;	O
_rl_last_v_pos	int
=	O
0	int
;	O
ndisp	int
=	O
cpos_buffer_position	int
-	O
wrap_offset	int
;	O
nleft	int
=	O
prompt_visible_length	int
+	O
wrap_offset	int
;	O
phys_c_pos	int
=	O
cpos_buffer_position	int
-	O
(	O
last_lmargin	int
?	O
last_lmargin	int
:	O
wrap_offset	int
)	O
;	O
t	*(char)
=	O
_rl_screenwidth	int
/	O
3	int
;	O
if	O
(	O
phys_c_pos	int
>	O
_rl_screenwidth	int
-	O
2	int
)	O
{	O
lmargin	int
=	O
cpos_buffer_position	int
-	O
(	O
2	int
*	O
t	*(char)
)	O
;	O
if	O
(	O
lmargin	int
<	O
0	int
)	O
lmargin	int
=	O
0	int
;	O
if	O
(	O
wrap_offset	int
&&	O
lmargin	int
>	O
0	int
&&	O
lmargin	int
<	O
nleft	int
)	O
lmargin	int
=	O
nleft	int
;	O
}	O
else	O
if	O
(	O
ndisp	int
<	O
_rl_screenwidth	int
-	O
2	int
)	O
lmargin	int
=	O
0	int
;	O
else	O
if	O
(	O
phys_c_pos	int
<	O
1	int
)	O
{	O
lmargin	int
=	O
(	O
(	O
cpos_buffer_position	int
-	O
1	int
)	O
/	O
t	*(char)
)	O
*	O
t	*(char)
;	O
if	O
(	O
wrap_offset	int
&&	O
lmargin	int
>	O
0	int
&&	O
lmargin	int
<	O
nleft	int
)	O
lmargin	int
=	O
nleft	int
;	O
}	O
else	O
lmargin	int
=	O
last_lmargin	int
;	O
displaying_prompt_first_line	int
=	O
lmargin	int
<	O
nleft	int
;	O
if	O
(	O
lmargin	int
>	O
0	int
)	O
line	*(char)
[	O
lmargin	int
]	O
=	O
'<'	O
;	O
t	*(char)
=	O
lmargin	int
+	O
M_OFFSET	O
(	O
lmargin	int
,	O
wrap_offset	int
)	O
+	O
_rl_screenwidth	int
;	O
if	O
(	O
t	*(char)
<	O
out	int
)	O
line	*(char)
[	O
t	*(char)
-	O
1	int
]	O
=	O
'>'	O
;	O
if	O
(	O
rl_display_fixed	int
==	O
0	int
||	O
forced_display	int
||	O
lmargin	int
!=	O
last_lmargin	int
)	O
{	O
forced_display	int
=	O
0	int
;	O
o_cpos	int
=	O
_rl_last_c_pos	int
;	O
cpos_adjusted	int
=	O
0	int
;	O
update_line	(*(char),*(char),int,int,int,int)->(void)
(	O
&	O
visible_line	O
[	O
last_lmargin	int
]	O
,	O
&	O
invisible_line	O
[	O
lmargin	int
]	O
,	O
0	int
,	O
_rl_screenwidth	int
+	O
visible_wrap_offset	int
,	O
_rl_screenwidth	int
+	O
(	O
lmargin	int
?	O
0	int
:	O
wrap_offset	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
&&	O
displaying_prompt_first_line	int
&&	O
OLD_CPOS_IN_PROMPT	O
(	O
)	O
)	O
_rl_last_c_pos	int
-=	O
prompt_invis_chars_first_line	int
;	O
t	*(char)
=	O
_rl_last_c_pos	int
-	O
M_OFFSET	O
(	O
lmargin	int
,	O
wrap_offset	int
)	O
;	O
if	O
(	O
(	O
M_OFFSET	O
(	O
lmargin	int
,	O
wrap_offset	int
)	O
>	O
visible_wrap_offset	int
)	O
&&	O
(	O
_rl_last_c_pos	int
==	O
out	int
)	O
&&	O
displaying_prompt_first_line	int
&&	O
t	*(char)
<	O
visible_first_line_len	int
)	O
{	O
nleft	int
=	O
_rl_screenwidth	int
-	O
t	*(char)
;	O
_rl_clear_to_eol	(int)->(void)
(	O
nleft	int
)	O
;	O
}	O
visible_first_line_len	int
=	O
out	int
-	O
lmargin	int
-	O
M_OFFSET	O
(	O
lmargin	int
,	O
wrap_offset	int
)	O
;	O
if	O
(	O
visible_first_line_len	int
>	O
_rl_screenwidth	int
)	O
visible_first_line_len	int
=	O
_rl_screenwidth	int
;	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
cpos_buffer_position	int
-	O
lmargin	int
,	O
&	O
invisible_line	O
[	O
lmargin	int
]	O
)	O
;	O
last_lmargin	int
=	O
lmargin	int
;	O
}	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
{	O
struct	O
line_state	struct(*(char),*(int),int,int,*(int))
*	O
vtemp	*(struct(*(char),*(int),int,int,*(int)))
=	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
;	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
=	O
line_state_invisible	*(struct(*(char),*(int),int,int,*(int)))
;	O
line_state_invisible	*(struct(*(char),*(int),int,int,*(int)))
=	O
vtemp	*(struct(*(char),*(int),int,int,*(int)))
;	O
rl_display_fixed	int
=	O
0	int
;	O
if	O
(	O
_rl_horizontal_scroll_mode	int
&&	O
last_lmargin	int
)	O
visible_wrap_offset	int
=	O
0	int
;	O
else	O
visible_wrap_offset	int
=	O
wrap_offset	int
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_REDISPLAYING	int
)	O
;	O
_rl_release_sigint	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
update_line	(*(char),*(char),int,int,int,int)->(void)
(	O
old	*(char)
,	O
new	*(char)
,	O
current_line	int
,	O
omax	int
,	O
nmax	int
,	O
inv_botlin	int
)	O
register	O
char	O
*	O
old	*(char)
,	O
*	O
new	*(char)
;	O
int	O
current_line	int
,	O
omax	int
,	O
nmax	int
,	O
inv_botlin	int
;	O
{	O
register	O
char	O
*	O
ofd	*(char)
,	O
*	O
ols	*(char)
,	O
*	O
oe	*(char)
,	O
*	O
nfd	*(char)
,	O
*	O
nls	*(char)
,	O
*	O
ne	*(char)
;	O
int	O
temp	int
,	O
lendiff	int
,	O
wsatend	int
,	O
od	int
,	O
nd	int
,	O
twidth	int
,	O
o_cpos	int
;	O
int	O
current_invis_chars	int
;	O
int	O
col_lendiff	int
,	O
col_temp	int
;	O
int	O
bytes_to_insert	int
;	O
int	O
mb_cur_max	int
=	O
MB_CUR_MAX	O
;	O
mbstate_t	struct(int,union(int,array(char)))
ps_new	struct(int,union(int,array(char)))
,	O
ps_old	struct(int,union(int,array(char)))
;	O
int	O
new_offset	int
,	O
old_offset	int
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
temp	int
=	O
_rl_last_c_pos	int
;	O
else	O
temp	int
=	O
_rl_last_c_pos	int
-	O
WRAP_OFFSET	O
(	O
_rl_last_v_pos	int
,	O
visible_wrap_offset	int
)	O
;	O
if	O
(	O
temp	int
==	O
_rl_screenwidth	int
&&	O
_rl_term_autowrap	int
&&	O
!	O
_rl_horizontal_scroll_mode	int
&&	O
_rl_last_v_pos	int
==	O
current_line	int
-	O
1	int
)	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
wchar_t	int
wc	int
;	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
;	O
int	O
tempwidth	int
,	O
bytes	int
;	O
size_t	long
ret	*(char)
;	O
if	O
(	O
current_line	int
<	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wbsize	int
&&	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wrapped_line	*(int)
[	O
current_line	int
]	O
>	O
0	int
)	O
_rl_clear_to_eol	(int)->(void)
(	O
line_state_visible	*(struct(*(char),*(int),int,int,*(int)))
->	O
wrapped_line	*(int)
[	O
current_line	int
]	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
ret	*(char)
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
new	*(char)
,	O
mb_cur_max	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
ret	*(char)
)	O
)	O
{	O
tempwidth	int
=	O
1	int
;	O
ret	*(char)
=	O
1	int
;	O
}	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
ret	*(char)
)	O
)	O
tempwidth	int
=	O
0	int
;	O
else	O
tempwidth	int
=	O
WCWIDTH	O
(	O
wc	int
)	O
;	O
if	O
(	O
tempwidth	int
>	O
0	int
)	O
{	O
int	O
count	int
,	O
i	int
;	O
bytes	int
=	O
ret	*(char)
;	O
for	O
(	O
count	int
=	O
0	int
;	O
count	int
<	O
bytes	int
;	O
count	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
new	*(char)
[	O
count	int
]	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
_rl_last_c_pos	int
=	O
tempwidth	int
;	O
_rl_last_v_pos	int
++	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
ret	*(char)
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
old	*(char)
,	O
mb_cur_max	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
ret	*(char)
!=	O
0	int
&&	O
bytes	int
!=	O
0	int
)	O
{	O
if	O
(	O
MB_INVALIDCH	O
(	O
ret	*(char)
)	O
)	O
ret	*(char)
=	O
1	int
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
old	*(char)
+	O
bytes	int
,	O
old	*(char)
+	O
ret	*(char)
,	O
strlen	(*(char))->(long)
(	O
old	*(char)
+	O
ret	*(char)
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
old	*(char)
,	O
new	*(char)
,	O
bytes	int
)	O
;	O
omax	int
+=	O
bytes	int
-	O
ret	*(char)
;	O
for	O
(	O
i	int
=	O
current_line	int
+	O
1	int
;	O
i	int
<=	O
inv_botlin	int
+	O
1	int
;	O
i	int
++	O
)	O
vis_lbreaks	O
[	O
i	int
]	O
+=	O
bytes	int
-	O
ret	*(char)
;	O
}	O
}	O
else	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
_rl_last_c_pos	int
=	O
1	int
;	O
_rl_last_v_pos	int
++	O
;	O
if	O
(	O
old	*(char)
[	O
0	int
]	O
&&	O
new	*(char)
[	O
0	int
]	O
)	O
old	*(char)
[	O
0	int
]	O
=	O
new	*(char)
[	O
0	int
]	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
new	*(char)
[	O
0	int
]	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
new	*(char)
[	O
0	int
]	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
_rl_last_c_pos	int
=	O
1	int
;	O
_rl_last_v_pos	int
++	O
;	O
if	O
(	O
old	*(char)
[	O
0	int
]	O
&&	O
new	*(char)
[	O
0	int
]	O
)	O
old	*(char)
[	O
0	int
]	O
=	O
new	*(char)
[	O
0	int
]	O
;	O
}	O
}	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
temp	int
=	O
(	O
omax	int
<	O
nmax	int
)	O
?	O
omax	int
:	O
nmax	int
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
old	*(char)
,	O
new	*(char)
,	O
temp	int
)	O
==	O
0	int
)	O
{	O
new_offset	int
=	O
old_offset	int
=	O
temp	int
;	O
ofd	*(char)
=	O
old	*(char)
+	O
temp	int
;	O
nfd	*(char)
=	O
new	*(char)
+	O
temp	int
;	O
}	O
else	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps_new	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps_old	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
if	O
(	O
omax	int
==	O
nmax	int
&&	O
STREQN	O
(	O
new	*(char)
,	O
old	*(char)
,	O
omax	int
)	O
)	O
{	O
old_offset	int
=	O
omax	int
;	O
new_offset	int
=	O
nmax	int
;	O
ofd	*(char)
=	O
old	*(char)
+	O
omax	int
;	O
nfd	*(char)
=	O
new	*(char)
+	O
nmax	int
;	O
}	O
else	O
{	O
new_offset	int
=	O
old_offset	int
=	O
0	int
;	O
for	O
(	O
ofd	*(char)
=	O
old	*(char)
,	O
nfd	*(char)
=	O
new	*(char)
;	O
(	O
ofd	*(char)
-	O
old	*(char)
<	O
omax	int
)	O
&&	O
*	O
ofd	*(char)
&&	O
_rl_compare_chars	(*(char),int,*(struct(int,union(int,array(char)))),*(char),int,*(struct(int,union(int,array(char)))))->(int)
(	O
old	*(char)
,	O
old_offset	int
,	O
&	O
ps_old	struct(int,union(int,array(char)))
,	O
new	*(char)
,	O
new_offset	int
,	O
&	O
ps_new	struct(int,union(int,array(char)))
)	O
;	O
)	O
{	O
old_offset	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
old	*(char)
,	O
old_offset	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
;	O
new_offset	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
new	*(char)
,	O
new_offset	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
;	O
ofd	*(char)
=	O
old	*(char)
+	O
old_offset	int
;	O
nfd	*(char)
=	O
new	*(char)
+	O
new_offset	int
;	O
}	O
}	O
}	O
}	O
else	O
for	O
(	O
ofd	*(char)
=	O
old	*(char)
,	O
nfd	*(char)
=	O
new	*(char)
;	O
(	O
ofd	*(char)
-	O
old	*(char)
<	O
omax	int
)	O
&&	O
*	O
ofd	*(char)
&&	O
(	O
*	O
ofd	*(char)
==	O
*	O
nfd	*(char)
)	O
;	O
ofd	*(char)
++	O
,	O
nfd	*(char)
++	O
)	O
;	O
for	O
(	O
od	int
=	O
ofd	*(char)
-	O
old	*(char)
,	O
oe	*(char)
=	O
ofd	*(char)
;	O
od	int
<	O
omax	int
&&	O
*	O
oe	*(char)
;	O
oe	*(char)
++	O
,	O
od	int
++	O
)	O
;	O
for	O
(	O
nd	int
=	O
nfd	*(char)
-	O
new	*(char)
,	O
ne	*(char)
=	O
nfd	*(char)
;	O
nd	int
<	O
nmax	int
&&	O
*	O
ne	*(char)
;	O
ne	*(char)
++	O
,	O
nd	int
++	O
)	O
;	O
if	O
(	O
ofd	*(char)
==	O
oe	*(char)
&&	O
nfd	*(char)
==	O
ne	*(char)
)	O
return	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
&&	O
_rl_utf8locale	int
)	O
{	O
wchar_t	int
wc	int
;	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
=	O
{	O
0	int
}	O
;	O
int	O
t	*(char)
;	O
t	*(char)
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
ofd	*(char)
,	O
mb_cur_max	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
t	*(char)
>	O
0	int
&&	O
UNICODE_COMBINING_CHAR	O
(	O
wc	int
)	O
&&	O
WCWIDTH	O
(	O
wc	int
)	O
==	O
0	int
)	O
{	O
old_offset	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
old	*(char)
,	O
ofd	*(char)
-	O
old	*(char)
,	O
MB_FIND_ANY	int
)	O
;	O
new_offset	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
new	*(char)
,	O
nfd	*(char)
-	O
new	*(char)
,	O
MB_FIND_ANY	int
)	O
;	O
ofd	*(char)
=	O
old	*(char)
+	O
old_offset	int
;	O
nfd	*(char)
=	O
new	*(char)
+	O
new_offset	int
;	O
}	O
}	O
wsatend	int
=	O
1	int
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
ols	*(char)
=	O
old	*(char)
+	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
old	*(char)
,	O
oe	*(char)
-	O
old	*(char)
,	O
MB_FIND_ANY	int
)	O
;	O
nls	*(char)
=	O
new	*(char)
+	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
new	*(char)
,	O
ne	*(char)
-	O
new	*(char)
,	O
MB_FIND_ANY	int
)	O
;	O
while	O
(	O
(	O
ols	*(char)
>	O
ofd	*(char)
)	O
&&	O
(	O
nls	*(char)
>	O
nfd	*(char)
)	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps_old	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps_new	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
if	O
(	O
_rl_compare_chars	(*(char),int,*(struct(int,union(int,array(char)))),*(char),int,*(struct(int,union(int,array(char)))))->(int)
(	O
old	*(char)
,	O
ols	*(char)
-	O
old	*(char)
,	O
&	O
ps_old	struct(int,union(int,array(char)))
,	O
new	*(char)
,	O
nls	*(char)
-	O
new	*(char)
,	O
&	O
ps_new	struct(int,union(int,array(char)))
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
*	O
ols	*(char)
==	O
' '	O
)	O
wsatend	int
=	O
0	int
;	O
ols	*(char)
=	O
old	*(char)
+	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
old	*(char)
,	O
ols	*(char)
-	O
old	*(char)
,	O
MB_FIND_ANY	int
)	O
;	O
nls	*(char)
=	O
new	*(char)
+	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
new	*(char)
,	O
nls	*(char)
-	O
new	*(char)
,	O
MB_FIND_ANY	int
)	O
;	O
}	O
}	O
else	O
{	O
ols	*(char)
=	O
oe	*(char)
-	O
1	int
;	O
nls	*(char)
=	O
ne	*(char)
-	O
1	int
;	O
while	O
(	O
(	O
ols	*(char)
>	O
ofd	*(char)
)	O
&&	O
(	O
nls	*(char)
>	O
nfd	*(char)
)	O
&&	O
(	O
*	O
ols	*(char)
==	O
*	O
nls	*(char)
)	O
)	O
{	O
if	O
(	O
*	O
ols	*(char)
!=	O
' '	O
)	O
wsatend	int
=	O
0	int
;	O
ols	*(char)
--	O
;	O
nls	*(char)
--	O
;	O
}	O
}	O
if	O
(	O
wsatend	int
)	O
{	O
ols	*(char)
=	O
oe	*(char)
;	O
nls	*(char)
=	O
ne	*(char)
;	O
}	O
else	O
if	O
(	O
_rl_compare_chars	(*(char),int,*(struct(int,union(int,array(char)))),*(char),int,*(struct(int,union(int,array(char)))))->(int)
(	O
ols	*(char)
,	O
0	int
,	O
NULL	O
,	O
nls	*(char)
,	O
0	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
ols	*(char)
)	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
ols	*(char)
=	O
old	*(char)
+	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
old	*(char)
,	O
ols	*(char)
-	O
old	*(char)
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
;	O
else	O
ols	*(char)
++	O
;	O
}	O
if	O
(	O
*	O
nls	*(char)
)	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
nls	*(char)
=	O
new	*(char)
+	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
new	*(char)
,	O
nls	*(char)
-	O
new	*(char)
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
;	O
else	O
nls	*(char)
++	O
;	O
}	O
}	O
current_invis_chars	int
=	O
W_OFFSET	O
(	O
current_line	int
,	O
wrap_offset	int
)	O
;	O
if	O
(	O
_rl_last_v_pos	int
!=	O
current_line	int
)	O
{	O
_rl_move_vert	(int)->(void)
(	O
current_line	int
)	O
;	O
if	O
(	O
current_line	int
==	O
0	int
)	O
visible_wrap_offset	int
=	O
prompt_invis_chars_first_line	int
;	O
if	O
(	O
(	O
mb_cur_max	int
==	O
1	int
||	O
rl_byte_oriented	int
)	O
&&	O
current_line	int
==	O
0	int
&&	O
visible_wrap_offset	int
)	O
_rl_last_c_pos	int
+=	O
visible_wrap_offset	int
;	O
}	O
lendiff	int
=	O
local_prompt_len	int
;	O
if	O
(	O
lendiff	int
>	O
nmax	int
)	O
lendiff	int
=	O
nmax	int
;	O
od	int
=	O
ofd	*(char)
-	O
old	*(char)
;	O
nd	int
=	O
nfd	*(char)
-	O
new	*(char)
;	O
if	O
(	O
current_line	int
==	O
0	int
&&	O
!	O
_rl_horizontal_scroll_mode	int
&&	O
_rl_term_cr	*(char)
&&	O
lendiff	int
>	O
prompt_visible_length	int
&&	O
_rl_last_c_pos	int
>	O
0	int
&&	O
(	O
(	O
(	O
od	int
>	O
0	int
||	O
nd	int
>	O
0	int
)	O
&&	O
(	O
od	int
<=	O
prompt_last_invisible	int
||	O
nd	int
<=	O
prompt_last_invisible	int
)	O
)	O
||	O
(	O
(	O
od	int
>=	O
lendiff	int
)	O
&&	O
_rl_last_c_pos	int
<	O
PROMPT_ENDING_INDEX	O
)	O
)	O
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
if	O
(	O
modmark	int
)	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
"*"	*(char)
,	O
1	int
)	O
;	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
local_prompt	*(char)
,	O
lendiff	int
)	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
_rl_last_c_pos	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
local_prompt	*(char)
,	O
0	int
,	O
lendiff	int
,	O
1	int
)	O
-	O
wrap_offset	int
+	O
modmark	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
}	O
else	O
_rl_last_c_pos	int
=	O
lendiff	int
+	O
modmark	int
;	O
if	O
(	O
(	O
od	int
<=	O
prompt_last_invisible	int
||	O
nd	int
<=	O
prompt_last_invisible	int
)	O
&&	O
omax	int
==	O
nmax	int
&&	O
lendiff	int
>	O
(	O
ols	*(char)
-	O
old	*(char)
)	O
&&	O
lendiff	int
>	O
(	O
nls	*(char)
-	O
new	*(char)
)	O
)	O
return	O
;	O
if	O
(	O
(	O
od	int
<=	O
prompt_last_invisible	int
||	O
nd	int
<=	O
prompt_last_invisible	int
)	O
)	O
{	O
nfd	*(char)
=	O
new	*(char)
+	O
lendiff	int
;	O
nd	int
=	O
lendiff	int
;	O
temp	int
=	O
ne	*(char)
-	O
nfd	*(char)
;	O
if	O
(	O
temp	int
>	O
0	int
)	O
{	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
nfd	*(char)
,	O
temp	int
)	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
_rl_last_c_pos	int
+=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
new	*(char)
,	O
nd	int
,	O
ne	*(char)
-	O
new	*(char)
,	O
1	int
)	O
;	O
else	O
_rl_last_c_pos	int
+=	O
temp	int
;	O
}	O
if	O
(	O
nmax	int
<	O
omax	int
)	O
goto	O
clear_rest_of_line	O
;	O
else	O
return	O
;	O
}	O
}	O
o_cpos	int
=	O
_rl_last_c_pos	int
;	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
od	int
,	O
old	*(char)
)	O
;	O
if	O
(	O
current_line	int
==	O
0	int
&&	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
&&	O
(	O
_rl_last_c_pos	int
>	O
0	int
||	O
o_cpos	int
>	O
0	int
)	O
&&	O
_rl_last_c_pos	int
==	O
prompt_physical_chars	int
)	O
cpos_adjusted	int
=	O
1	int
;	O
lendiff	int
=	O
(	O
nls	*(char)
-	O
nfd	*(char)
)	O
-	O
(	O
ols	*(char)
-	O
ofd	*(char)
)	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
col_lendiff	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
new	*(char)
,	O
nfd	*(char)
-	O
new	*(char)
,	O
nls	*(char)
-	O
new	*(char)
,	O
1	int
)	O
-	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
old	*(char)
,	O
ofd	*(char)
-	O
old	*(char)
,	O
ols	*(char)
-	O
old	*(char)
,	O
1	int
)	O
;	O
else	O
col_lendiff	int
=	O
lendiff	int
;	O
if	O
(	O
current_line	int
==	O
0	int
&&	O
current_invis_chars	int
!=	O
visible_wrap_offset	int
)	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
lendiff	int
+=	O
visible_wrap_offset	int
-	O
current_invis_chars	int
;	O
col_lendiff	int
+=	O
visible_wrap_offset	int
-	O
current_invis_chars	int
;	O
}	O
else	O
{	O
lendiff	int
+=	O
visible_wrap_offset	int
-	O
current_invis_chars	int
;	O
col_lendiff	int
=	O
lendiff	int
;	O
}	O
}	O
temp	int
=	O
ne	*(char)
-	O
nfd	*(char)
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
col_temp	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
new	*(char)
,	O
nfd	*(char)
-	O
new	*(char)
,	O
ne	*(char)
-	O
new	*(char)
,	O
1	int
)	O
;	O
else	O
col_temp	int
=	O
temp	int
;	O
bytes_to_insert	int
=	O
nls	*(char)
-	O
nfd	*(char)
;	O
if	O
(	O
col_lendiff	int
>	O
0	int
)	O
{	O
int	O
gl	int
=	O
current_line	int
>=	O
_rl_vis_botlin	int
&&	O
inv_botlin	int
>	O
_rl_vis_botlin	int
;	O
if	O
(	O
lendiff	int
<	O
0	int
)	O
{	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
nfd	*(char)
,	O
temp	int
)	O
;	O
_rl_last_c_pos	int
+=	O
col_temp	int
;	O
if	O
(	O
current_line	int
==	O
0	int
&&	O
displaying_prompt_first_line	int
&&	O
wrap_offset	int
&&	O
(	O
(	O
nfd	*(char)
-	O
new	*(char)
)	O
<=	O
prompt_last_invisible	int
)	O
)	O
{	O
_rl_last_c_pos	int
-=	O
wrap_offset	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
}	O
return	O
;	O
}	O
else	O
if	O
(	O
_rl_terminal_can_insert	int
&&	O
(	O
(	O
2	int
*	O
col_temp	int
)	O
>=	O
col_lendiff	int
||	O
_rl_term_IC	*(char)
)	O
&&	O
(	O
!	O
_rl_term_autowrap	int
||	O
!	O
gl	int
)	O
)	O
{	O
if	O
(	O
*	O
ols	*(char)
&&	O
(	O
(	O
_rl_horizontal_scroll_mode	int
&&	O
_rl_last_c_pos	int
==	O
0	int
&&	O
lendiff	int
>	O
prompt_visible_length	int
&&	O
current_invis_chars	int
>	O
0	int
)	O
==	O
0	int
)	O
&&	O
(	O
(	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
&&	O
current_line	int
==	O
0	int
&&	O
wrap_offset	int
&&	O
(	O
(	O
nfd	*(char)
-	O
new	*(char)
)	O
<=	O
prompt_last_invisible	int
)	O
&&	O
(	O
col_lendiff	int
<	O
prompt_visible_length	int
)	O
)	O
==	O
0	int
)	O
&&	O
(	O
visible_wrap_offset	int
>=	O
current_invis_chars	int
)	O
)	O
{	O
open_some_spaces	(int)->(void)
(	O
col_lendiff	int
)	O
;	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
nfd	*(char)
,	O
bytes_to_insert	int
)	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
_rl_last_c_pos	int
+=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
nfd	*(char)
,	O
0	int
,	O
bytes_to_insert	int
,	O
1	int
)	O
;	O
else	O
_rl_last_c_pos	int
+=	O
bytes_to_insert	int
;	O
}	O
else	O
if	O
(	O
(	O
mb_cur_max	int
==	O
1	int
||	O
rl_byte_oriented	int
!=	O
0	int
)	O
&&	O
*	O
ols	*(char)
==	O
0	int
&&	O
lendiff	int
>	O
0	int
)	O
{	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
nfd	*(char)
,	O
temp	int
)	O
;	O
_rl_last_c_pos	int
+=	O
col_temp	int
;	O
return	O
;	O
}	O
else	O
{	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
nfd	*(char)
,	O
temp	int
)	O
;	O
_rl_last_c_pos	int
+=	O
col_temp	int
;	O
if	O
(	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
&&	O
current_line	int
==	O
0	int
&&	O
displaying_prompt_first_line	int
&&	O
wrap_offset	int
&&	O
(	O
(	O
nfd	*(char)
-	O
new	*(char)
)	O
<=	O
prompt_last_invisible	int
)	O
)	O
{	O
_rl_last_c_pos	int
-=	O
wrap_offset	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
}	O
return	O
;	O
}	O
if	O
(	O
bytes_to_insert	int
>	O
lendiff	int
)	O
{	O
if	O
(	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
&&	O
current_line	int
==	O
0	int
&&	O
displaying_prompt_first_line	int
&&	O
wrap_offset	int
&&	O
(	O
(	O
nfd	*(char)
-	O
new	*(char)
)	O
<=	O
prompt_last_invisible	int
)	O
)	O
{	O
_rl_last_c_pos	int
-=	O
wrap_offset	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
nfd	*(char)
,	O
temp	int
)	O
;	O
_rl_last_c_pos	int
+=	O
col_temp	int
;	O
if	O
(	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
&&	O
current_line	int
==	O
prompt_last_screen_line	int
&&	O
wrap_offset	int
&&	O
displaying_prompt_first_line	int
&&	O
wrap_offset	int
!=	O
prompt_invis_chars_first_line	int
&&	O
(	O
(	O
nfd	*(char)
-	O
new	*(char)
)	O
<	O
(	O
prompt_last_invisible	int
-	O
(	O
current_line	int
*	O
_rl_screenwidth	int
+	O
prompt_invis_chars_first_line	int
)	O
)	O
)	O
)	O
{	O
_rl_last_c_pos	int
-=	O
wrap_offset	int
-	O
prompt_invis_chars_first_line	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
_rl_term_dc	*(char)
&&	O
(	O
2	int
*	O
col_temp	int
)	O
>=	O
-	O
col_lendiff	int
)	O
{	O
if	O
(	O
_rl_horizontal_scroll_mode	int
&&	O
_rl_last_c_pos	int
==	O
0	int
&&	O
displaying_prompt_first_line	int
&&	O
-	O
lendiff	int
==	O
visible_wrap_offset	int
)	O
col_lendiff	int
=	O
0	int
;	O
if	O
(	O
_rl_horizontal_scroll_mode	int
&&	O
displaying_prompt_first_line	int
==	O
0	int
&&	O
col_lendiff	int
&&	O
_rl_last_c_pos	int
<	O
-	O
col_lendiff	int
)	O
col_lendiff	int
=	O
0	int
;	O
if	O
(	O
col_lendiff	int
)	O
delete_chars	(int)->(void)
(	O
-	O
col_lendiff	int
)	O
;	O
if	O
(	O
bytes_to_insert	int
>	O
0	int
)	O
{	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
nfd	*(char)
,	O
bytes_to_insert	int
)	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
_rl_last_c_pos	int
+=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
nfd	*(char)
,	O
0	int
,	O
bytes_to_insert	int
,	O
1	int
)	O
;	O
if	O
(	O
current_line	int
==	O
0	int
&&	O
wrap_offset	int
&&	O
displaying_prompt_first_line	int
&&	O
_rl_last_c_pos	int
>	O
wrap_offset	int
&&	O
(	O
(	O
nfd	*(char)
-	O
new	*(char)
)	O
<=	O
prompt_last_invisible	int
)	O
)	O
{	O
_rl_last_c_pos	int
-=	O
wrap_offset	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
}	O
}	O
else	O
_rl_last_c_pos	int
+=	O
bytes_to_insert	int
;	O
if	O
(	O
_rl_horizontal_scroll_mode	int
&&	O
(	O
(	O
oe	*(char)
-	O
old	*(char)
)	O
>	O
(	O
ne	*(char)
-	O
new	*(char)
)	O
)	O
)	O
{	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
ne	*(char)
-	O
new	*(char)
,	O
new	*(char)
)	O
;	O
goto	O
clear_rest_of_line	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
temp	int
>	O
0	int
)	O
{	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
nfd	*(char)
,	O
temp	int
)	O
;	O
_rl_last_c_pos	int
+=	O
col_temp	int
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
if	O
(	O
current_line	int
==	O
0	int
&&	O
wrap_offset	int
&&	O
displaying_prompt_first_line	int
&&	O
_rl_last_c_pos	int
>	O
wrap_offset	int
&&	O
(	O
(	O
nfd	*(char)
-	O
new	*(char)
)	O
<=	O
prompt_last_invisible	int
)	O
)	O
{	O
_rl_last_c_pos	int
-=	O
wrap_offset	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
}	O
}	O
}	O
clear_rest_of_line	O
:	O
lendiff	int
=	O
(	O
oe	*(char)
-	O
old	*(char)
)	O
-	O
(	O
ne	*(char)
-	O
new	*(char)
)	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
col_lendiff	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
old	*(char)
,	O
0	int
,	O
oe	*(char)
-	O
old	*(char)
,	O
1	int
)	O
-	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
new	*(char)
,	O
0	int
,	O
ne	*(char)
-	O
new	*(char)
,	O
1	int
)	O
;	O
else	O
col_lendiff	int
=	O
lendiff	int
;	O
if	O
(	O
col_lendiff	int
&&	O
(	O
(	O
mb_cur_max	int
==	O
1	int
||	O
rl_byte_oriented	int
)	O
||	O
(	O
_rl_last_c_pos	int
<	O
_rl_screenwidth	int
)	O
)	O
)	O
{	O
if	O
(	O
_rl_term_autowrap	int
&&	O
current_line	int
<	O
inv_botlin	int
)	O
space_to_eol	(int)->(void)
(	O
col_lendiff	int
)	O
;	O
else	O
_rl_clear_to_eol	(int)->(void)
(	O
col_lendiff	int
)	O
;	O
}	O
}	O
}	O
}	O
int	O
rl_on_new_line	()->(int)
(	O
)	O
{	O
if	O
(	O
visible_line	O
)	O
visible_line	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
_rl_last_c_pos	int
=	O
_rl_last_v_pos	int
=	O
0	int
;	O
_rl_vis_botlin	int
=	O
last_lmargin	int
=	O
0	int
;	O
if	O
(	O
vis_lbreaks	O
)	O
vis_lbreaks	O
[	O
0	int
]	O
=	O
vis_lbreaks	O
[	O
1	int
]	O
=	O
0	int
;	O
visible_wrap_offset	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
rl_clear_visible_line	()->(int)
(	O
)	O
{	O
int	O
curr_line	int
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
_rl_last_c_pos	int
=	O
0	int
;	O
_rl_move_vert	(int)->(void)
(	O
_rl_vis_botlin	int
)	O
;	O
for	O
(	O
curr_line	int
=	O
_rl_last_v_pos	int
;	O
curr_line	int
>=	O
0	int
;	O
curr_line	int
--	O
)	O
{	O
_rl_move_vert	(int)->(void)
(	O
curr_line	int
)	O
;	O
_rl_clear_to_eol	(int)->(void)
(	O
0	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_on_new_line_with_prompt	()->(int)
(	O
)	O
{	O
int	O
prompt_size	int
,	O
i	int
,	O
l	int
,	O
real_screenwidth	int
,	O
newlines	int
;	O
char	O
*	O
prompt_last_line	*(char)
,	O
*	O
lprompt	*(char)
;	O
prompt_size	int
=	O
strlen	(*(char))->(long)
(	O
rl_prompt	*(char)
)	O
+	O
1	int
;	O
init_line_structures	(int)->(void)
(	O
prompt_size	int
)	O
;	O
lprompt	*(char)
=	O
local_prompt	*(char)
?	O
local_prompt	*(char)
:	O
rl_prompt	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
visible_line	O
,	O
lprompt	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
invisible_line	O
,	O
lprompt	*(char)
)	O
;	O
prompt_last_line	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
rl_prompt	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
prompt_last_line	*(char)
)	O
prompt_last_line	*(char)
=	O
rl_prompt	*(char)
;	O
l	int
=	O
strlen	(*(char))->(long)
(	O
prompt_last_line	*(char)
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
_rl_last_c_pos	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
prompt_last_line	*(char)
,	O
0	int
,	O
l	int
,	O
1	int
)	O
;	O
else	O
_rl_last_c_pos	int
=	O
l	int
;	O
real_screenwidth	int
=	O
_rl_screenwidth	int
+	O
(	O
_rl_term_autowrap	int
?	O
0	int
:	O
1	int
)	O
;	O
_rl_last_v_pos	int
=	O
l	int
/	O
real_screenwidth	int
;	O
if	O
(	O
l	int
>	O
0	int
&&	O
(	O
l	int
%	O
real_screenwidth	int
)	O
==	O
0	int
)	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
"\n"	*(char)
,	O
1	int
)	O
;	O
last_lmargin	int
=	O
0	int
;	O
newlines	int
=	O
0	int
;	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<=	O
l	int
)	O
{	O
_rl_vis_botlin	int
=	O
newlines	int
;	O
vis_lbreaks	O
[	O
newlines	int
++	O
]	O
=	O
i	int
;	O
i	int
+=	O
real_screenwidth	int
;	O
}	O
vis_lbreaks	O
[	O
newlines	int
]	O
=	O
l	int
;	O
visible_wrap_offset	int
=	O
0	int
;	O
rl_display_prompt	*(char)
=	O
rl_prompt	*(char)
;	O
return	O
0	int
;	O
}	O
int	O
rl_forced_update_display	()->(int)
(	O
)	O
{	O
register	O
char	O
*	O
temp	int
;	O
if	O
(	O
visible_line	O
)	O
{	O
temp	int
=	O
visible_line	O
;	O
while	O
(	O
*	O
temp	int
)	O
*	O
temp	int
++	O
=	O
'\0'	O
;	O
}	O
rl_on_new_line	()->(int)
(	O
)	O
;	O
forced_display	int
++	O
;	O
(	O
*	O
rl_redisplay_function	*(()->(void))
)	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
rl_redraw_prompt_last_line	()->(void)
(	O
)	O
{	O
char	O
*	O
t	*(char)
;	O
t	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
rl_display_prompt	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
t	*(char)
)	O
redraw_prompt	(*(char))->(void)
(	O
++	O
t	*(char)
)	O
;	O
else	O
rl_forced_update_display	()->(int)
(	O
)	O
;	O
}	O
void	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
new	*(char)
,	O
data	*(void)
)	O
int	O
new	*(char)
;	O
const	O
char	O
*	O
data	*(void)
;	O
{	O
register	O
int	O
i	int
;	O
int	O
woff	int
;	O
int	O
cpos	int
,	O
dpos	int
;	O
int	O
adjust	int
;	O
int	O
in_invisline	int
;	O
int	O
mb_cur_max	int
=	O
MB_CUR_MAX	O
;	O
woff	int
=	O
WRAP_OFFSET	O
(	O
_rl_last_v_pos	int
,	O
wrap_offset	int
)	O
;	O
cpos	int
=	O
_rl_last_c_pos	int
;	O
if	O
(	O
cpos	int
==	O
0	int
&&	O
cpos	int
==	O
new	*(char)
)	O
return	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
adjust	int
=	O
1	int
;	O
if	O
(	O
new	*(char)
==	O
local_prompt_len	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
data	*(void)
,	O
local_prompt	*(char)
,	O
new	*(char)
)	O
==	O
0	int
)	O
{	O
dpos	int
=	O
prompt_physical_chars	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
adjust	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
new	*(char)
>	O
local_prompt_len	int
&&	O
local_prompt	*(char)
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
data	*(void)
,	O
local_prompt	*(char)
,	O
local_prompt_len	int
)	O
==	O
0	int
)	O
{	O
dpos	int
=	O
prompt_physical_chars	int
+	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
data	*(void)
,	O
local_prompt_len	int
,	O
new	*(char)
,	O
1	int
)	O
;	O
cpos_adjusted	int
=	O
1	int
;	O
adjust	int
=	O
0	int
;	O
}	O
else	O
dpos	int
=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
data	*(void)
,	O
0	int
,	O
new	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
displaying_prompt_first_line	int
==	O
0	int
)	O
adjust	int
=	O
0	int
;	O
in_invisline	int
=	O
0	int
;	O
if	O
(	O
data	*(void)
>	O
invisible_line	O
&&	O
data	*(void)
<	O
invisible_line	O
+	O
inv_lbreaks	O
[	O
_rl_inv_botlin	int
+	O
1	int
]	O
)	O
in_invisline	int
=	O
data	*(void)
-	O
invisible_line	O
;	O
if	O
(	O
adjust	int
&&	O
(	O
(	O
new	*(char)
>	O
prompt_last_invisible	int
)	O
||	O
(	O
new	*(char)
+	O
in_invisline	int
>	O
prompt_last_invisible	int
)	O
||	O
(	O
prompt_physical_chars	int
>=	O
_rl_screenwidth	int
&&	O
_rl_last_v_pos	int
==	O
prompt_last_screen_line	int
&&	O
wrap_offset	int
>=	O
woff	int
&&	O
dpos	int
>=	O
woff	int
&&	O
new	*(char)
>	O
(	O
prompt_last_invisible	int
-	O
(	O
vis_lbreaks	O
[	O
_rl_last_v_pos	int
]	O
)	O
-	O
wrap_offset	int
)	O
)	O
)	O
)	O
{	O
dpos	int
-=	O
woff	int
;	O
cpos_adjusted	int
=	O
1	int
;	O
}	O
}	O
else	O
dpos	int
=	O
new	*(char)
;	O
if	O
(	O
cpos	int
==	O
dpos	int
)	O
return	O
;	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
i	int
=	O
_rl_last_c_pos	int
;	O
else	O
i	int
=	O
_rl_last_c_pos	int
-	O
woff	int
;	O
if	O
(	O
dpos	int
==	O
0	int
||	O
CR_FASTER	O
(	O
dpos	int
,	O
_rl_last_c_pos	int
)	O
||	O
(	O
_rl_term_autowrap	int
&&	O
i	int
==	O
_rl_screenwidth	int
)	O
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
cpos	int
=	O
_rl_last_c_pos	int
=	O
0	int
;	O
}	O
if	O
(	O
cpos	int
<	O
dpos	int
)	O
{	O
if	O
(	O
mb_cur_max	int
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
if	O
(	O
_rl_term_forward_char	*(char)
)	O
{	O
for	O
(	O
i	int
=	O
cpos	int
;	O
i	int
<	O
dpos	int
;	O
i	int
++	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_forward_char	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
}	O
else	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
new	*(char)
;	O
i	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
data	*(void)
[	O
i	int
]	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
else	O
for	O
(	O
i	int
=	O
cpos	int
;	O
i	int
<	O
new	*(char)
;	O
i	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
data	*(void)
[	O
i	int
]	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
if	O
(	O
cpos	int
>	O
dpos	int
)	O
_rl_backspace	(int)->(int)
(	O
cpos	int
-	O
dpos	int
)	O
;	O
_rl_last_c_pos	int
=	O
dpos	int
;	O
}	O
void	O
_rl_move_vert	(int)->(void)
(	O
to	int
)	O
int	O
to	int
;	O
{	O
register	O
int	O
delta	int
,	O
i	int
;	O
if	O
(	O
_rl_last_v_pos	int
==	O
to	int
||	O
to	int
>	O
_rl_screenheight	int
)	O
return	O
;	O
if	O
(	O
(	O
delta	int
=	O
to	int
-	O
_rl_last_v_pos	int
)	O
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
delta	int
;	O
i	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
_rl_last_c_pos	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
_rl_term_up	*(char)
&&	O
*	O
_rl_term_up	*(char)
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
-	O
delta	int
;	O
i	int
++	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_up	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
}	O
_rl_last_v_pos	int
=	O
to	int
;	O
}	O
int	O
rl_show_char	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
n	int
=	O
1	int
;	O
if	O
(	O
META_CHAR	O
(	O
c	int
)	O
&&	O
(	O
_rl_output_meta_chars	int
==	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"M-"	*(char)
)	O
;	O
n	int
+=	O
2	int
;	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
}	O
if	O
(	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
&&	O
c	int
!=	O
'\t'	O
)	O
||	O
c	int
==	O
RUBOUT	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"C-"	*(char)
)	O
;	O
n	int
+=	O
2	int
;	O
c	int
=	O
CTRL_CHAR	O
(	O
c	int
)	O
?	O
UNCTRL	O
(	O
c	int
)	O
:	O
'?'	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
n	int
;	O
}	O
int	O
rl_character_len	(int,int)->(int)
(	O
c	int
,	O
pos	int
)	O
register	O
int	O
c	int
,	O
pos	int
;	O
{	O
unsigned	O
char	O
uc	char
;	O
uc	char
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
if	O
(	O
META_CHAR	O
(	O
uc	char
)	O
)	O
return	O
(	O
(	O
_rl_output_meta_chars	int
==	O
0	int
)	O
?	O
4	int
:	O
1	int
)	O
;	O
if	O
(	O
uc	char
==	O
'\t'	O
)	O
{	O
return	O
(	O
(	O
(	O
pos	int
|	O
7	int
)	O
+	O
1	int
)	O
-	O
pos	int
)	O
;	O
}	O
if	O
(	O
CTRL_CHAR	O
(	O
c	int
)	O
||	O
c	int
==	O
RUBOUT	int
)	O
return	O
(	O
2	int
)	O
;	O
return	O
(	O
(	O
ISPRINT	O
(	O
uc	char
)	O
)	O
?	O
1	int
:	O
2	int
)	O
;	O
}	O
static	O
int	O
msg_saved_prompt	int
=	O
0	int
;	O
int	O
rl_message	(*(char))->(int)
(	O
const	O
char	O
*	O
format	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
int	O
bneed	int
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
if	O
(	O
msg_buf	*(char)
==	O
0	int
)	O
msg_buf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
msg_bufsiz	int
=	O
128	int
)	O
;	O
bneed	int
=	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
msg_buf	*(char)
,	O
msg_bufsiz	int
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
bneed	int
>=	O
msg_bufsiz	int
-	O
1	int
)	O
{	O
msg_bufsiz	int
=	O
bneed	int
+	O
1	int
;	O
msg_buf	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
msg_buf	*(char)
,	O
msg_bufsiz	int
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
format	*(char)
)	O
;	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
msg_buf	*(char)
,	O
msg_bufsiz	int
-	O
1	int
,	O
format	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
saved_local_prompt	*(char)
==	O
0	int
)	O
{	O
rl_save_prompt	()->(void)
(	O
)	O
;	O
msg_saved_prompt	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
local_prompt	*(char)
!=	O
saved_local_prompt	*(char)
)	O
{	O
FREE	O
(	O
local_prompt	*(char)
)	O
;	O
FREE	O
(	O
local_prompt_prefix	*(char)
)	O
;	O
local_prompt	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
rl_display_prompt	*(char)
=	O
msg_buf	*(char)
;	O
local_prompt	*(char)
=	O
expand_prompt	(*(char),int,*(int),*(int),*(int),*(int))->(*(char))
(	O
msg_buf	*(char)
,	O
0	int
,	O
&	O
prompt_visible_length	int
,	O
&	O
prompt_last_invisible	int
,	O
&	O
prompt_invis_chars_first_line	int
,	O
&	O
prompt_physical_chars	int
)	O
;	O
local_prompt_prefix	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
local_prompt_len	int
=	O
local_prompt	*(char)
?	O
strlen	(*(char))->(long)
(	O
local_prompt	*(char)
)	O
:	O
0	int
;	O
(	O
*	O
rl_redisplay_function	*(()->(void))
)	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_clear_message	()->(int)
(	O
)	O
{	O
rl_display_prompt	*(char)
=	O
rl_prompt	*(char)
;	O
if	O
(	O
msg_saved_prompt	int
)	O
{	O
rl_restore_prompt	()->(void)
(	O
)	O
;	O
msg_saved_prompt	int
=	O
0	int
;	O
}	O
(	O
*	O
rl_redisplay_function	*(()->(void))
)	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_reset_line_state	()->(int)
(	O
)	O
{	O
rl_on_new_line	()->(int)
(	O
)	O
;	O
rl_display_prompt	*(char)
=	O
rl_prompt	*(char)
?	O
rl_prompt	*(char)
:	O
""	*(char)
;	O
forced_display	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
rl_save_prompt	()->(void)
(	O
)	O
{	O
saved_local_prompt	*(char)
=	O
local_prompt	*(char)
;	O
saved_local_prefix	*(char)
=	O
local_prompt_prefix	*(char)
;	O
saved_prefix_length	int
=	O
prompt_prefix_length	int
;	O
saved_local_length	int
=	O
local_prompt_len	int
;	O
saved_last_invisible	int
=	O
prompt_last_invisible	int
;	O
saved_visible_length	int
=	O
prompt_visible_length	int
;	O
saved_invis_chars_first_line	int
=	O
prompt_invis_chars_first_line	int
;	O
saved_physical_chars	int
=	O
prompt_physical_chars	int
;	O
local_prompt	*(char)
=	O
local_prompt_prefix	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
local_prompt_len	int
=	O
0	int
;	O
prompt_last_invisible	int
=	O
prompt_visible_length	int
=	O
prompt_prefix_length	int
=	O
0	int
;	O
prompt_invis_chars_first_line	int
=	O
prompt_physical_chars	int
=	O
0	int
;	O
}	O
void	O
rl_restore_prompt	()->(void)
(	O
)	O
{	O
FREE	O
(	O
local_prompt	*(char)
)	O
;	O
FREE	O
(	O
local_prompt_prefix	*(char)
)	O
;	O
local_prompt	*(char)
=	O
saved_local_prompt	*(char)
;	O
local_prompt_prefix	*(char)
=	O
saved_local_prefix	*(char)
;	O
local_prompt_len	int
=	O
saved_local_length	int
;	O
prompt_prefix_length	int
=	O
saved_prefix_length	int
;	O
prompt_last_invisible	int
=	O
saved_last_invisible	int
;	O
prompt_visible_length	int
=	O
saved_visible_length	int
;	O
prompt_invis_chars_first_line	int
=	O
saved_invis_chars_first_line	int
;	O
prompt_physical_chars	int
=	O
saved_physical_chars	int
;	O
saved_local_prompt	*(char)
=	O
saved_local_prefix	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
saved_local_length	int
=	O
0	int
;	O
saved_last_invisible	int
=	O
saved_visible_length	int
=	O
saved_prefix_length	int
=	O
0	int
;	O
saved_invis_chars_first_line	int
=	O
saved_physical_chars	int
=	O
0	int
;	O
}	O
char	O
*	O
_rl_make_prompt_for_search	(int)->(*(char))
(	O
pchar	int
)	O
int	O
pchar	int
;	O
{	O
int	O
len	int
;	O
char	O
*	O
pmt	*(char)
,	O
*	O
p	*(char)
;	O
rl_save_prompt	()->(void)
(	O
)	O
;	O
p	*(char)
=	O
rl_prompt	*(char)
?	O
strrchr	(*(char),int)->(*(char))
(	O
rl_prompt	*(char)
,	O
'\n'	O
)	O
:	O
0	int
;	O
if	O
(	O
p	*(char)
==	O
0	int
)	O
{	O
len	int
=	O
(	O
rl_prompt	*(char)
&&	O
*	O
rl_prompt	*(char)
)	O
?	O
strlen	(*(char))->(long)
(	O
rl_prompt	*(char)
)	O
:	O
0	int
;	O
pmt	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
len	int
+	O
2	int
)	O
;	O
if	O
(	O
len	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
pmt	*(char)
,	O
rl_prompt	*(char)
)	O
;	O
pmt	*(char)
[	O
len	int
]	O
=	O
pchar	int
;	O
pmt	*(char)
[	O
len	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
p	*(char)
++	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
;	O
pmt	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
len	int
+	O
2	int
)	O
;	O
if	O
(	O
len	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
pmt	*(char)
,	O
p	*(char)
)	O
;	O
pmt	*(char)
[	O
len	int
]	O
=	O
pchar	int
;	O
pmt	*(char)
[	O
len	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
prompt_physical_chars	int
=	O
saved_physical_chars	int
+	O
1	int
;	O
return	O
pmt	*(char)
;	O
}	O
void	O
_rl_erase_at_end_of_line	(int)->(void)
(	O
l	int
)	O
int	O
l	int
;	O
{	O
register	O
int	O
i	int
;	O
_rl_backspace	(int)->(int)
(	O
l	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
l	int
;	O
i	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
_rl_backspace	(int)->(int)
(	O
l	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
l	int
;	O
i	int
++	O
)	O
visible_line	O
[	O
--	O
_rl_last_c_pos	int
]	O
=	O
'\0'	O
;	O
rl_display_fixed	int
++	O
;	O
}	O
void	O
_rl_clear_to_eol	(int)->(void)
(	O
count	int
)	O
int	O
count	int
;	O
{	O
if	O
(	O
_rl_term_clreol	*(char)
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_clreol	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
else	O
if	O
(	O
count	int
)	O
space_to_eol	(int)->(void)
(	O
count	int
)	O
;	O
}	O
static	O
void	O
space_to_eol	(int)->(void)
(	O
count	int
)	O
int	O
count	int
;	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
_rl_last_c_pos	int
+=	O
count	int
;	O
}	O
void	O
_rl_clear_screen	()->(void)
(	O
)	O
{	O
if	O
(	O
_rl_term_clrpag	*(char)
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_clrpag	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
else	O
rl_crlf	()->(int)
(	O
)	O
;	O
}	O
static	O
void	O
insert_some_chars	(*(char),int,int)->(void)
(	O
string	*(char)
,	O
count	int
,	O
col	int
)	O
char	O
*	O
string	*(char)
;	O
int	O
count	int
,	O
col	int
;	O
{	O
open_some_spaces	(int)->(void)
(	O
col	int
)	O
;	O
_rl_output_some_chars	(*(char),int)->(void)
(	O
string	*(char)
,	O
count	int
)	O
;	O
}	O
static	O
void	O
open_some_spaces	(int)->(void)
(	O
col	int
)	O
int	O
col	int
;	O
{	O
char	O
*	O
buffer	*(char)
;	O
register	O
int	O
i	int
;	O
if	O
(	O
_rl_term_IC	*(char)
)	O
{	O
buffer	*(char)
=	O
tgoto	(*(char),int,int)->(*(char))
(	O
_rl_term_IC	*(char)
,	O
0	int
,	O
col	int
)	O
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
buffer	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
}	O
else	O
if	O
(	O
_rl_term_im	*(char)
&&	O
*	O
_rl_term_im	*(char)
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_im	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
for	O
(	O
i	int
=	O
col	int
;	O
i	int
--	O
;	O
)	O
_rl_output_character_function	(int)->(int)
(	O
' '	O
)	O
;	O
if	O
(	O
_rl_term_ei	*(char)
&&	O
*	O
_rl_term_ei	*(char)
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_ei	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
_rl_backspace	(int)->(int)
(	O
col	int
)	O
;	O
}	O
else	O
if	O
(	O
_rl_term_ic	*(char)
&&	O
*	O
_rl_term_ic	*(char)
)	O
{	O
for	O
(	O
i	int
=	O
col	int
;	O
i	int
--	O
;	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_ic	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
}	O
}	O
static	O
void	O
delete_chars	(int)->(void)
(	O
count	int
)	O
int	O
count	int
;	O
{	O
if	O
(	O
count	int
>	O
_rl_screenwidth	int
)	O
return	O
;	O
if	O
(	O
_rl_term_DC	*(char)
&&	O
*	O
_rl_term_DC	*(char)
)	O
{	O
char	O
*	O
buffer	*(char)
;	O
buffer	*(char)
=	O
tgoto	(*(char),int,int)->(*(char))
(	O
_rl_term_DC	*(char)
,	O
count	int
,	O
count	int
)	O
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
buffer	*(char)
,	O
count	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
_rl_term_dc	*(char)
&&	O
*	O
_rl_term_dc	*(char)
)	O
while	O
(	O
count	int
--	O
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_dc	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
}	O
}	O
void	O
_rl_update_final	()->(void)
(	O
)	O
{	O
int	O
full_lines	int
;	O
full_lines	int
=	O
0	int
;	O
if	O
(	O
_rl_vis_botlin	int
&&	O
_rl_last_c_pos	int
==	O
0	int
&&	O
visible_line	O
[	O
vis_lbreaks	O
[	O
_rl_vis_botlin	int
]	O
]	O
==	O
0	int
)	O
{	O
_rl_vis_botlin	int
--	O
;	O
full_lines	int
=	O
1	int
;	O
}	O
_rl_move_vert	(int)->(void)
(	O
_rl_vis_botlin	int
)	O
;	O
if	O
(	O
full_lines	int
&&	O
_rl_term_autowrap	int
&&	O
(	O
VIS_LLEN	O
(	O
_rl_vis_botlin	int
)	O
==	O
_rl_screenwidth	int
)	O
)	O
{	O
char	O
*	O
last_line	*(char)
;	O
last_line	*(char)
=	O
&	O
visible_line	O
[	O
vis_lbreaks	O
[	O
_rl_vis_botlin	int
]	O
]	O
;	O
cpos_buffer_position	int
=	O
-	O
1	int
;	O
_rl_move_cursor_relative	(int,*(char))->(void)
(	O
_rl_screenwidth	int
-	O
1	int
,	O
last_line	*(char)
)	O
;	O
_rl_clear_to_eol	(int)->(void)
(	O
0	int
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
last_line	*(char)
[	O
_rl_screenwidth	int
-	O
1	int
]	O
,	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
_rl_vis_botlin	int
=	O
0	int
;	O
rl_crlf	()->(int)
(	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
rl_display_fixed	int
++	O
;	O
}	O
static	O
void	O
cr	()->(void)
(	O
)	O
{	O
if	O
(	O
_rl_term_cr	*(char)
)	O
{	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
_rl_last_c_pos	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
redraw_prompt	(*(char))->(void)
(	O
t	*(char)
)	O
char	O
*	O
t	*(char)
;	O
{	O
char	O
*	O
oldp	*(char)
;	O
oldp	*(char)
=	O
rl_display_prompt	*(char)
;	O
rl_save_prompt	()->(void)
(	O
)	O
;	O
rl_display_prompt	*(char)
=	O
t	*(char)
;	O
local_prompt	*(char)
=	O
expand_prompt	(*(char),int,*(int),*(int),*(int),*(int))->(*(char))
(	O
t	*(char)
,	O
PMT_MULTILINE	int
,	O
&	O
prompt_visible_length	int
,	O
&	O
prompt_last_invisible	int
,	O
&	O
prompt_invis_chars_first_line	int
,	O
&	O
prompt_physical_chars	int
)	O
;	O
local_prompt_prefix	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
local_prompt_len	int
=	O
local_prompt	*(char)
?	O
strlen	(*(char))->(long)
(	O
local_prompt	*(char)
)	O
:	O
0	int
;	O
rl_forced_update_display	()->(int)
(	O
)	O
;	O
rl_display_prompt	*(char)
=	O
oldp	*(char)
;	O
rl_restore_prompt	()->(void)
(	O
)	O
;	O
}	O
void	O
_rl_redisplay_after_sigwinch	()->(void)
(	O
)	O
{	O
char	O
*	O
t	*(char)
;	O
if	O
(	O
_rl_term_cr	*(char)
)	O
{	O
_rl_move_vert	(int)->(void)
(	O
_rl_vis_botlin	int
)	O
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
_rl_last_c_pos	int
=	O
0	int
;	O
if	O
(	O
_rl_term_clreol	*(char)
)	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_clreol	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
else	O
{	O
space_to_eol	(int)->(void)
(	O
_rl_screenwidth	int
)	O
;	O
tputs	(*(char),int,*((int)->(int)))->(int)
(	O
_rl_term_cr	*(char)
,	O
1	int
,	O
_rl_output_character_function	(int)->(int)
)	O
;	O
}	O
if	O
(	O
_rl_last_v_pos	int
>	O
0	int
)	O
_rl_move_vert	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
rl_crlf	()->(int)
(	O
)	O
;	O
t	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
rl_display_prompt	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
t	*(char)
)	O
redraw_prompt	(*(char))->(void)
(	O
++	O
t	*(char)
)	O
;	O
else	O
rl_forced_update_display	()->(int)
(	O
)	O
;	O
}	O
void	O
_rl_clean_up_for_exit	()->(void)
(	O
)	O
{	O
if	O
(	O
_rl_echoing_p	int
)	O
{	O
if	O
(	O
_rl_vis_botlin	int
>	O
0	int
)	O
_rl_move_vert	(int)->(void)
(	O
_rl_vis_botlin	int
)	O
;	O
_rl_vis_botlin	int
=	O
0	int
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
rl_restart_output	(int,int)->(int)
(	O
1	int
,	O
0	int
)	O
;	O
}	O
}	O
void	O
_rl_erase_entire_line	()->(void)
(	O
)	O
{	O
cr	()->(void)
(	O
)	O
;	O
_rl_clear_to_eol	(int)->(void)
(	O
0	int
)	O
;	O
cr	()->(void)
(	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
_rl_ttyflush	()->(void)
(	O
)	O
{	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rl_outstream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
int	O
_rl_current_display_line	()->(int)
(	O
)	O
{	O
int	O
ret	*(char)
,	O
nleft	int
;	O
if	O
(	O
rl_display_prompt	*(char)
==	O
rl_prompt	*(char)
)	O
nleft	int
=	O
_rl_last_c_pos	int
-	O
_rl_screenwidth	int
-	O
rl_visible_prompt_length	int
;	O
else	O
nleft	int
=	O
_rl_last_c_pos	int
-	O
_rl_screenwidth	int
;	O
if	O
(	O
nleft	int
>	O
0	int
)	O
ret	*(char)
=	O
1	int
+	O
nleft	int
/	O
_rl_screenwidth	int
;	O
else	O
ret	*(char)
=	O
0	int
;	O
return	O
ret	*(char)
;	O
}	O
static	O
int	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
str	*(char)
,	O
start	int
,	O
end	int
,	O
flags	int
)	O
const	O
char	O
*	O
str	*(char)
;	O
int	O
start	int
,	O
end	int
,	O
flags	int
;	O
{	O
wchar_t	int
wc	int
;	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
;	O
int	O
tmp	int
,	O
point	int
,	O
width	int
,	O
max	int
;	O
if	O
(	O
end	int
<=	O
start	int
)	O
return	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
return	O
(	O
end	int
-	O
start	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
point	int
=	O
0	int
;	O
max	int
=	O
end	int
;	O
if	O
(	O
flags	int
&&	O
start	int
==	O
0	int
&&	O
end	int
==	O
local_prompt_len	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
str	*(char)
,	O
local_prompt	*(char)
,	O
local_prompt_len	int
)	O
==	O
0	int
)	O
return	O
(	O
prompt_physical_chars	int
+	O
wrap_offset	int
)	O
;	O
else	O
if	O
(	O
flags	int
&&	O
start	int
==	O
0	int
&&	O
local_prompt_len	int
>	O
0	int
&&	O
end	int
>	O
local_prompt_len	int
&&	O
local_prompt	*(char)
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
str	*(char)
,	O
local_prompt	*(char)
,	O
local_prompt_len	int
)	O
==	O
0	int
)	O
{	O
tmp	int
=	O
prompt_physical_chars	int
+	O
wrap_offset	int
;	O
tmp	int
+=	O
_rl_col_width	(*(char),int,int,int)->(int)
(	O
str	*(char)
,	O
local_prompt_len	int
,	O
end	int
,	O
flags	int
)	O
;	O
return	O
(	O
tmp	int
)	O
;	O
}	O
while	O
(	O
point	int
<	O
start	int
)	O
{	O
tmp	int
=	O
mbrlen	(*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
str	*(char)
+	O
point	int
,	O
max	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
(	O
size_t	long
)	O
tmp	int
)	O
)	O
{	O
point	int
++	O
;	O
max	int
--	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
tmp	int
)	O
)	O
break	O
;	O
else	O
{	O
point	int
+=	O
tmp	int
;	O
max	int
-=	O
tmp	int
;	O
}	O
}	O
width	int
=	O
point	int
-	O
start	int
;	O
while	O
(	O
point	int
<	O
end	int
)	O
{	O
tmp	int
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
str	*(char)
+	O
point	int
,	O
max	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
(	O
size_t	long
)	O
tmp	int
)	O
)	O
{	O
point	int
++	O
;	O
max	int
--	O
;	O
width	int
++	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
tmp	int
)	O
)	O
break	O
;	O
else	O
{	O
point	int
+=	O
tmp	int
;	O
max	int
-=	O
tmp	int
;	O
tmp	int
=	O
WCWIDTH	O
(	O
wc	int
)	O
;	O
width	int
+=	O
(	O
tmp	int
>=	O
0	int
)	O
?	O
tmp	int
:	O
1	int
;	O
}	O
}	O
width	int
+=	O
point	int
-	O
end	int
;	O
return	O
width	int
;	O
}	O
