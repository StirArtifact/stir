int	O
edit_key_emulation	int
=	O
EDIT_KEY_EMULATION_NORMAL	int
;	O
int	O
option_word_wrap_line_length	int
=	O
72	int
;	O
int	O
option_typewriter_wrap	int
=	O
0	int
;	O
int	O
option_auto_para_formatting	int
=	O
0	int
;	O
int	O
option_tab_spacing	int
=	O
8	int
;	O
int	O
option_fill_tabs_with_spaces	int
=	O
0	int
;	O
int	O
option_return_does_auto_indent	int
=	O
1	int
;	O
int	O
option_backspace_through_tabs	int
=	O
0	int
;	O
int	O
option_fake_half_tabs	int
=	O
1	int
;	O
int	O
option_save_mode	int
=	O
EDIT_QUICK_SAVE	int
;	O
int	O
option_save_position	int
=	O
1	int
;	O
int	O
option_max_undo	int
=	O
32768	int
;	O
int	O
option_edit_right_extreme	int
=	O
0	int
;	O
int	O
option_edit_left_extreme	int
=	O
0	int
;	O
int	O
option_edit_top_extreme	int
=	O
0	int
;	O
int	O
option_edit_bottom_extreme	int
=	O
0	int
;	O
const	O
char	O
*	O
option_whole_chars_search	*(char)
=	O
"0123456789abcdefghijklmnopqrstuvwxyz_"	*(char)
;	O
char	O
*	O
option_backup_ext	*(char)
=	O
NULL	O
;	O
static	O
void	O
user_menu	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
;	O
int	O
edit_get_byte	(*(struct),long)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
byte_index	long
)	O
{	O
unsigned	O
long	O
p	*(void)
;	O
if	O
(	O
byte_index	long
>=	O
(	O
edit	*(struct)
->	O
curs1	long
+	O
edit	*(struct)
->	O
curs2	long
)	O
||	O
byte_index	long
<	O
0	int
)	O
return	O
'\n'	O
;	O
if	O
(	O
byte_index	long
>=	O
edit	*(struct)
->	O
curs1	long
)	O
{	O
p	*(void)
=	O
edit	*(struct)
->	O
curs1	long
+	O
edit	*(struct)
->	O
curs2	long
-	O
byte_index	long
-	O
1	int
;	O
return	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
p	*(void)
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
p	*(void)
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
;	O
}	O
else	O
{	O
return	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
byte_index	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
byte_index	long
&	O
M_EDIT_BUF_SIZE	O
]	O
;	O
}	O
}	O
static	O
void	O
edit_init_buffers	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
MAXBUFF	int
;	O
j	int
++	O
)	O
{	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
j	int
]	O
=	O
NULL	O
;	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
j	int
]	O
=	O
NULL	O
;	O
}	O
edit	*(struct)
->	O
curs1	long
=	O
0	int
;	O
edit	*(struct)
->	O
curs2	long
=	O
0	int
;	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
0	int
]	O
=	O
g_malloc	(long)->(*(void))
(	O
EDIT_BUF_SIZE	O
)	O
;	O
}	O
static	O
int	O
edit_load_file_fast	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
long	O
buf	*(char)
,	O
buf2	long
;	O
int	O
file	*(char)
=	O
-	O
1	int
;	O
edit	*(struct)
->	O
curs2	long
=	O
edit	*(struct)
->	O
last_byte	long
;	O
buf2	long
=	O
edit	*(struct)
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
;	O
if	O
(	O
(	O
file	*(char)
=	O
mc_open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
GString	struct
*	O
errmsg	*(struct(*(char),long,long))
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
NULL	O
)	O
;	O
g_string_sprintf	O
(	O
errmsg	*(struct(*(char),long,long))
,	O
_	O
(	O
" Cannot open %s for reading "	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
get_sys_error	O
(	O
errmsg	*(struct(*(char),long,long))
->	O
str	*(char)
)	O
)	O
;	O
g_string_free	(*(struct(*(char),long,long)),int)->(*(char))
(	O
errmsg	*(struct(*(char),long,long))
,	O
TRUE	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
buf2	long
]	O
)	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
buf2	long
]	O
=	O
g_malloc	(long)->(*(void))
(	O
EDIT_BUF_SIZE	O
)	O
;	O
mc_read	(int,*(void),int)->(int)
(	O
file	*(char)
,	O
(	O
char	O
*	O
)	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
buf2	long
]	O
+	O
EDIT_BUF_SIZE	O
-	O
(	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
,	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
;	O
for	O
(	O
buf	*(char)
=	O
buf2	long
-	O
1	int
;	O
buf	*(char)
>=	O
0	int
;	O
buf	*(char)
--	O
)	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
buf	*(char)
]	O
)	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
buf	*(char)
]	O
=	O
g_malloc	(long)->(*(void))
(	O
EDIT_BUF_SIZE	O
)	O
;	O
mc_read	(int,*(void),int)->(int)
(	O
file	*(char)
,	O
(	O
char	O
*	O
)	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
buf	*(char)
]	O
,	O
EDIT_BUF_SIZE	O
)	O
;	O
}	O
mc_close	(int)->(int)
(	O
file	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
edit_filters	struct(*(char),*(char),*(char))
{	O
const	O
char	O
*	O
read	*((*(void),*(char),long)->(long))
,	O
*	O
write	*((*(void),*(char),long)->(long))
,	O
*	O
extension	(*(char))->(*(char))
;	O
}	O
all_filters	array(struct(*(char),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"bzip2 -cd %s 2>&1"	*(char)
,	O
"bzip2 > %s"	*(char)
,	O
".bz2"	*(char)
}	O
,	O
{	O
"gzip -cd %s 2>&1"	*(char)
,	O
"gzip > %s"	*(char)
,	O
".gz"	*(char)
}	O
,	O
{	O
"gzip -cd %s 2>&1"	*(char)
,	O
"gzip > %s"	*(char)
,	O
".Z"	*(char)
}	O
}	O
;	O
static	O
int	O
edit_find_filter	(*(char))->(int)
(	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
size_t	long
i	array(int)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
e	*(struct)
;	O
if	O
(	O
!	O
filename	*(char)
)	O
return	O
-	O
1	int
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
sizeof	O
(	O
all_filters	array(struct(*(char),*(char),*(char)))
)	O
/	O
sizeof	O
(	O
all_filters	array(struct(*(char),*(char),*(char)))
[	O
0	int
]	O
)	O
;	O
i	array(int)
++	O
)	O
{	O
e	*(struct)
=	O
strlen	(*(char))->(long)
(	O
all_filters	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
extension	(*(char))->(*(char))
)	O
;	O
if	O
(	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
>	O
e	*(struct)
)	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
all_filters	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
extension	(*(char))->(*(char))
,	O
filename	*(char)
+	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
-	O
e	*(struct)
)	O
)	O
return	O
i	array(int)
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
char	O
*	O
edit_get_filter	(*(char))->(*(char))
(	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
int	O
i	array(int)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
char	O
*	O
p	*(void)
,	O
*	O
quoted_name	*(char)
;	O
i	array(int)
=	O
edit_find_filter	(*(char))->(int)
(	O
filename	*(char)
)	O
;	O
if	O
(	O
i	array(int)
<	O
0	int
)	O
return	O
0	int
;	O
quoted_name	*(char)
=	O
name_quote	(*(char),int)->(*(char))
(	O
filename	*(char)
,	O
0	int
)	O
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
strlen	(*(char))->(long)
(	O
quoted_name	*(char)
)	O
;	O
p	*(void)
=	O
g_malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
all_filters	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
read	*((*(void),*(char),long)->(long))
)	O
+	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
+	O
2	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
all_filters	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
read	*((*(void),*(char),long)->(long))
,	O
quoted_name	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
quoted_name	*(char)
)	O
;	O
return	O
p	*(void)
;	O
}	O
char	O
*	O
edit_get_write_filter	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
write_name	*(char)
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
int	O
i	array(int)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
char	O
*	O
p	*(void)
,	O
*	O
writename	*(char)
;	O
i	array(int)
=	O
edit_find_filter	(*(char))->(int)
(	O
filename	*(char)
)	O
;	O
if	O
(	O
i	array(int)
<	O
0	int
)	O
return	O
0	int
;	O
writename	*(char)
=	O
name_quote	(*(char),int)->(*(char))
(	O
write_name	*(char)
,	O
0	int
)	O
;	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
strlen	(*(char))->(long)
(	O
writename	*(char)
)	O
;	O
p	*(void)
=	O
g_malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
all_filters	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
write	*((*(void),*(char),long)->(long))
)	O
+	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
+	O
2	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
all_filters	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
write	*((*(void),*(char),long)->(long))
,	O
writename	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
writename	*(char)
)	O
;	O
return	O
p	*(void)
;	O
}	O
static	O
long	O
edit_insert_stream	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
c	int
;	O
long	O
i	array(int)
=	O
0	int
;	O
while	O
(	O
(	O
c	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
>=	O
0	int
)	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
c	int
)	O
;	O
i	array(int)
++	O
;	O
}	O
return	O
i	array(int)
;	O
}	O
long	O
edit_write_stream	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
long	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
edit	*(struct)
->	O
last_byte	long
;	O
i	array(int)
++	O
)	O
if	O
(	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
<	O
0	int
)	O
break	O
;	O
return	O
i	array(int)
;	O
}	O
int	O
edit_insert_file	(*(struct),*(char))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
(	O
p	*(void)
=	O
edit_get_filter	(*(char))->(*(char))
(	O
filename	*(char)
)	O
)	O
)	O
{	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
long	O
current	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
(	O
FILE	struct
*	O
)	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(void)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
edit_insert_stream	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
edit	*(struct)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
current	long
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
>	O
0	int
)	O
{	O
GString	struct
*	O
errmsg	*(struct(*(char),long,long))
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
NULL	O
)	O
;	O
g_string_sprintf	O
(	O
errmsg	*(struct(*(char),long,long))
,	O
_	O
(	O
" Error reading from pipe: %s "	*(char)
)	O
,	O
p	*(void)
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
errmsg	*(struct(*(char),long,long))
->	O
str	*(char)
)	O
;	O
g_string_free	(*(struct(*(char),long,long)),int)->(*(char))
(	O
errmsg	*(struct(*(char),long,long))
,	O
TRUE	O
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
GString	struct
*	O
errmsg	*(struct(*(char),long,long))
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
NULL	O
)	O
;	O
g_string_sprintf	O
(	O
errmsg	*(struct(*(char),long,long))
,	O
_	O
(	O
" Cannot open pipe for reading: %s "	*(char)
)	O
,	O
p	*(void)
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
errmsg	*(struct(*(char),long,long))
->	O
str	*(char)
)	O
;	O
g_string_free	(*(struct(*(char),long,long)),int)->(*(char))
(	O
errmsg	*(struct(*(char),long,long))
,	O
TRUE	O
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
else	O
{	O
int	O
i	array(int)
,	O
file	*(char)
,	O
blocklen	int
;	O
long	O
current	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
unsigned	O
char	O
*	O
buf	*(char)
;	O
if	O
(	O
(	O
file	*(char)
=	O
mc_open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
buf	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
TEMP_BUF_LEN	int
)	O
;	O
while	O
(	O
(	O
blocklen	int
=	O
mc_read	(int,*(void),int)->(int)
(	O
file	*(char)
,	O
(	O
char	O
*	O
)	O
buf	*(char)
,	O
TEMP_BUF_LEN	int
)	O
)	O
>	O
0	int
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
blocklen	int
;	O
i	array(int)
++	O
)	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
buf	*(char)
[	O
i	array(int)
]	O
)	O
;	O
}	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
current	long
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
g_free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
mc_close	(int)->(int)
(	O
file	*(char)
)	O
;	O
if	O
(	O
blocklen	int
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
check_file_access	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
filename	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
int	O
file	*(char)
;	O
GString	struct
*	O
errmsg	*(struct(*(char),long,long))
=	O
(	O
GString	struct
*	O
)	O
0	int
;	O
file	*(char)
=	O
mc_open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_NONBLOCK	int
|	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0666	int
)	O
;	O
if	O
(	O
file	*(char)
<	O
0	int
)	O
{	O
file	*(char)
=	O
mc_open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
O_NONBLOCK	int
|	O
O_RDONLY	int
|	O
O_BINARY	int
|	O
O_CREAT	int
|	O
O_EXCL	int
,	O
0666	int
)	O
;	O
if	O
(	O
file	*(char)
<	O
0	int
)	O
{	O
g_string_sprintf	O
(	O
errmsg	*(struct(*(char),long,long))
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
NULL	O
)	O
,	O
_	O
(	O
" Cannot open %s for reading "	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
goto	O
cleanup	O
;	O
}	O
else	O
{	O
edit	*(struct)
->	O
delete_file	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
mc_fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
file	*(char)
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
<	O
0	int
)	O
{	O
g_string_sprintf	O
(	O
errmsg	*(struct(*(char),long,long))
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
NULL	O
)	O
,	O
_	O
(	O
" Cannot get size/permissions for %s "	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
{	O
g_string_sprintf	O
(	O
errmsg	*(struct(*(char),long,long))
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
NULL	O
)	O
,	O
_	O
(	O
" %s is not a regular file "	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
>	O
0	int
)	O
{	O
edit	*(struct)
->	O
delete_file	int
=	O
0	int
;	O
}	O
if	O
(	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
>=	O
SIZE_LIMIT	O
)	O
{	O
g_string_sprintf	O
(	O
errmsg	*(struct(*(char),long,long))
=	O
g_string_new	(*(char))->(*(struct(*(char),long,long)))
(	O
NULL	O
)	O
,	O
_	O
(	O
" File %s is too large "	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
goto	O
cleanup	O
;	O
}	O
cleanup	O
:	O
(	O
void	O
)	O
mc_close	(int)->(int)
(	O
file	*(char)
)	O
;	O
if	O
(	O
errmsg	*(struct(*(char),long,long))
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
errmsg	*(struct(*(char),long,long))
->	O
str	*(char)
)	O
;	O
g_string_free	(*(struct(*(char),long,long)),int)->(*(char))
(	O
errmsg	*(struct(*(char),long,long))
,	O
TRUE	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
edit_load_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
fast_load	int
=	O
1	int
;	O
if	O
(	O
edit_find_filter	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
>=	O
0	int
)	O
fast_load	int
=	O
0	int
;	O
if	O
(	O
!	O
vfs_file_is_local	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
)	O
fast_load	int
=	O
0	int
;	O
if	O
(	O
*	O
edit	*(struct)
->	O
filename	*(char)
)	O
{	O
if	O
(	O
check_file_access	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
filename	*(char)
,	O
&	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
fast_load	int
=	O
0	int
;	O
}	O
edit_init_buffers	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
fast_load	int
)	O
{	O
edit	*(struct)
->	O
last_byte	long
=	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
;	O
edit_load_file_fast	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),*(char))->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
edit	*(struct)
->	O
total_lines	long
=	O
edit_count_lines	(*(struct),long,int)->(int)
(	O
edit	*(struct)
,	O
0	int
,	O
edit	*(struct)
->	O
last_byte	long
)	O
;	O
}	O
else	O
{	O
edit	*(struct)
->	O
last_byte	long
=	O
0	int
;	O
if	O
(	O
*	O
edit	*(struct)
->	O
filename	*(char)
)	O
{	O
edit	*(struct)
->	O
stack_disable	int
=	O
1	int
;	O
if	O
(	O
!	O
edit_insert_file	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
filename	*(char)
)	O
)	O
{	O
edit_clean	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
edit	*(struct)
->	O
stack_disable	int
=	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
edit_load_position	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
char	O
*	O
filename	*(char)
;	O
long	O
line	int
,	O
column	*(long)
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
filename	*(char)
||	O
!	O
*	O
edit	*(struct)
->	O
filename	*(char)
)	O
return	O
;	O
filename	*(char)
=	O
vfs_canon	(*(char))->(*(char))
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
load_file_position	(*(char),*(long),*(long))->(void)
(	O
filename	*(char)
,	O
&	O
line	int
,	O
&	O
column	*(long)
)	O
;	O
g_free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
edit_move_to_line	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
line	int
-	O
1	int
)	O
;	O
edit	*(struct)
->	O
prev_col	long
=	O
column	*(long)
;	O
edit_move_to_prev_col	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
)	O
;	O
edit_move_display	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
line	int
-	O
(	O
edit	*(struct)
->	O
num_widget_lines	int
/	O
2	int
)	O
)	O
;	O
}	O
static	O
void	O
edit_save_position	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
char	O
*	O
filename	*(char)
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
filename	*(char)
||	O
!	O
*	O
edit	*(struct)
->	O
filename	*(char)
)	O
return	O
;	O
filename	*(char)
=	O
vfs_canon	(*(char))->(*(char))
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
save_file_position	(*(char),long,long)->(void)
(	O
filename	*(char)
,	O
edit	*(struct)
->	O
curs_line	long
+	O
1	int
,	O
edit	*(struct)
->	O
curs_col	long
)	O
;	O
g_free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
}	O
static	O
inline	O
void	O
edit_purge_widget	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
len	int
=	O
sizeof	O
(	O
WEdit	struct
)	O
-	O
sizeof	O
(	O
Widget	struct
)	O
;	O
char	O
*	O
start	*(int)
=	O
(	O
char	O
*	O
)	O
edit	*(struct)
+	O
sizeof	O
(	O
Widget	struct
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
start	*(int)
,	O
0	int
,	O
len	int
)	O
;	O
edit	*(struct)
->	O
macro_i	int
=	O
-	O
1	int
;	O
}	O
WEdit	struct
*	O
edit_init	(*(struct),int,int,*(char),long)->(*(struct))
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
lines	*(int)
,	O
int	O
columns	*(int)
,	O
const	O
char	O
*	O
filename	*(char)
,	O
long	O
line	int
)	O
{	O
int	O
to_free	int
=	O
0	int
;	O
option_auto_syntax	int
=	O
1	int
;	O
if	O
(	O
!	O
edit	*(struct)
)	O
{	O
static	O
char	O
option_whole_chars_search_buf	array(char)
[	O
256	int
]	O
;	O
if	O
(	O
option_whole_chars_search_buf	array(char)
!=	O
option_whole_chars_search	*(char)
)	O
{	O
size_t	long
i	array(int)
;	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
option_whole_chars_search	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
option_whole_chars_search_buf	array(char)
,	O
option_whole_chars_search	*(char)
)	O
;	O
for	O
(	O
i	array(int)
=	O
1	int
;	O
i	array(int)
<=	O
sizeof	O
(	O
option_whole_chars_search_buf	array(char)
)	O
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
islower	(int)->(int)
(	O
i	array(int)
)	O
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
option_whole_chars_search	*(char)
,	O
i	array(int)
)	O
)	O
{	O
option_whole_chars_search_buf	array(char)
[	O
len	int
++	O
]	O
=	O
i	array(int)
;	O
}	O
}	O
option_whole_chars_search_buf	array(char)
[	O
len	int
]	O
=	O
0	int
;	O
option_whole_chars_search	*(char)
=	O
option_whole_chars_search_buf	array(char)
;	O
}	O
edit	*(struct)
=	O
g_malloc0	(long)->(*(void))
(	O
sizeof	O
(	O
WEdit	struct
)	O
)	O
;	O
to_free	int
=	O
1	int
;	O
}	O
edit_purge_widget	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
num_widget_lines	int
=	O
lines	*(int)
;	O
edit	*(struct)
->	O
num_widget_columns	int
=	O
columns	*(int)
;	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
=	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
;	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_uid	int
=	O
getuid	()->(int)
(	O
)	O
;	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_gid	int
=	O
getgid	()->(int)
(	O
)	O
;	O
edit	*(struct)
->	O
stat1	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
=	O
0	int
;	O
edit	*(struct)
->	O
bracket	long
=	O
-	O
1	int
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_set_filename	(*(struct),*(char))->(void)
(	O
edit	*(struct)
,	O
filename	*(char)
)	O
;	O
edit	*(struct)
->	O
stack_size	long
=	O
START_STACK_SIZE	int
;	O
edit	*(struct)
->	O
stack_size_mask	long
=	O
START_STACK_SIZE	int
-	O
1	int
;	O
edit	*(struct)
->	O
undo_stack	*(long)
=	O
g_malloc	(long)->(*(void))
(	O
(	O
edit	*(struct)
->	O
stack_size	long
+	O
10	int
)	O
*	O
sizeof	O
(	O
long	O
)	O
)	O
;	O
if	O
(	O
edit_load_file	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
{	O
if	O
(	O
to_free	int
)	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
edit	*(struct)
->	O
loading_done	int
=	O
1	int
;	O
edit	*(struct)
->	O
modified	long
=	O
0	int
;	O
edit	*(struct)
->	O
locked	int
=	O
0	int
;	O
edit_load_syntax	(*(struct),*(*(*(char))),*(char))->(void)
(	O
edit	*(struct)
,	O
0	int
,	O
0	int
)	O
;	O
{	O
int	O
color	*(int)
;	O
edit_get_syntax_color	(*(struct),long,*(int))->(void)
(	O
edit	*(struct)
,	O
-	O
1	int
,	O
&	O
color	*(int)
)	O
;	O
}	O
if	O
(	O
(	O
line	int
==	O
0	int
)	O
&&	O
option_save_position	int
)	O
{	O
edit_load_position	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
line	int
<=	O
0	int
)	O
line	int
=	O
1	int
;	O
edit_move_display	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
line	int
-	O
1	int
)	O
;	O
edit_move_to_line	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
line	int
-	O
1	int
)	O
;	O
}	O
edit_load_user_map	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
return	O
edit	*(struct)
;	O
}	O
int	O
edit_clean	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
!	O
edit	*(struct)
)	O
return	O
0	int
;	O
if	O
(	O
edit	*(struct)
->	O
locked	int
)	O
edit	*(struct)
->	O
locked	int
=	O
edit_unlock_file	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
if	O
(	O
option_save_position	int
)	O
edit_save_position	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
delete_file	int
)	O
unlink	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
edit_free_syntax_rules	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
book_mark_flush	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
-	O
1	int
)	O
;	O
for	O
(	O
;	O
j	int
<=	O
MAXBUFF	int
;	O
j	int
++	O
)	O
{	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
j	int
]	O
)	O
;	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
j	int
]	O
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
undo_stack	*(long)
)	O
;	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
dir	*(struct)
)	O
;	O
edit_purge_widget	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
freestrs	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
edit_renew	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
lines	*(int)
=	O
edit	*(struct)
->	O
num_widget_lines	int
;	O
int	O
columns	*(int)
=	O
edit	*(struct)
->	O
num_widget_columns	int
;	O
int	O
retval	*(void)
=	O
1	int
;	O
edit_clean	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
!	O
edit_init	(*(struct),int,int,*(char),long)->(*(struct))
(	O
edit	*(struct)
,	O
lines	*(int)
,	O
columns	*(int)
,	O
""	*(char)
,	O
0	int
)	O
)	O
retval	*(void)
=	O
0	int
;	O
return	O
retval	*(void)
;	O
}	O
int	O
edit_reload	(*(struct),*(char))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
WEdit	struct
*	O
e	*(struct)
;	O
int	O
lines	*(int)
=	O
edit	*(struct)
->	O
num_widget_lines	int
;	O
int	O
columns	*(int)
=	O
edit	*(struct)
->	O
num_widget_columns	int
;	O
e	*(struct)
=	O
g_malloc0	(long)->(*(void))
(	O
sizeof	O
(	O
WEdit	struct
)	O
)	O
;	O
e	*(struct)
->	O
widget	*(struct)
=	O
edit	*(struct)
->	O
widget	*(struct)
;	O
if	O
(	O
!	O
edit_init	(*(struct),int,int,*(char),long)->(*(struct))
(	O
e	*(struct)
,	O
lines	*(int)
,	O
columns	*(int)
,	O
filename	*(char)
,	O
0	int
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
e	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
edit_clean	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
edit	*(struct)
,	O
e	*(struct)
,	O
sizeof	O
(	O
WEdit	struct
)	O
)	O
;	O
g_free	(*(void))->(void)
(	O
e	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
void	O
edit_push_action	(*(struct),long)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
c	int
,	O
...	O
)	O
{	O
unsigned	O
long	O
sp	long
=	O
edit	*(struct)
->	O
stack_pointer	long
;	O
unsigned	O
long	O
spm1	long
;	O
long	O
*	O
t	long
;	O
if	O
(	O
sp	long
>	O
edit	*(struct)
->	O
stack_size	long
-	O
10	int
)	O
{	O
if	O
(	O
option_max_undo	int
<	O
256	int
)	O
option_max_undo	int
=	O
256	int
;	O
if	O
(	O
edit	*(struct)
->	O
stack_size	long
<	O
(	O
unsigned	O
long	O
)	O
option_max_undo	int
)	O
{	O
t	long
=	O
g_realloc	(*(void),long)->(*(void))
(	O
edit	*(struct)
->	O
undo_stack	*(long)
,	O
(	O
edit	*(struct)
->	O
stack_size	long
*	O
2	int
+	O
10	int
)	O
*	O
sizeof	O
(	O
long	O
)	O
)	O
;	O
if	O
(	O
t	long
)	O
{	O
edit	*(struct)
->	O
undo_stack	*(long)
=	O
t	long
;	O
edit	*(struct)
->	O
stack_size	long
<<=	O
1	int
;	O
edit	*(struct)
->	O
stack_size_mask	long
=	O
edit	*(struct)
->	O
stack_size	long
-	O
1	int
;	O
}	O
}	O
}	O
spm1	long
=	O
(	O
edit	*(struct)
->	O
stack_pointer	long
-	O
1	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
;	O
if	O
(	O
edit	*(struct)
->	O
stack_disable	int
)	O
return	O
;	O
if	O
(	O
edit	*(struct)
->	O
stack_bottom	long
!=	O
sp	long
&&	O
spm1	long
!=	O
edit	*(struct)
->	O
stack_bottom	long
&&	O
(	O
(	O
sp	long
-	O
2	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
)	O
!=	O
edit	*(struct)
->	O
stack_bottom	long
)	O
{	O
int	O
d	double
;	O
if	O
(	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
spm1	long
]	O
<	O
0	int
)	O
{	O
d	double
=	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
(	O
sp	long
-	O
2	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
]	O
;	O
if	O
(	O
d	double
==	O
c	int
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
spm1	long
]	O
>	O
-	O
1000000000	int
)	O
{	O
if	O
(	O
c	int
<	O
KEY_PRESS	int
)	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
spm1	long
]	O
--	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
CURS_LEFT	int
&&	O
d	double
==	O
CURS_RIGHT	int
)	O
||	O
(	O
c	int
==	O
CURS_RIGHT	int
&&	O
d	double
==	O
CURS_LEFT	int
)	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
spm1	long
]	O
==	O
-	O
2	int
)	O
edit	*(struct)
->	O
stack_pointer	long
=	O
spm1	long
;	O
else	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
spm1	long
]	O
++	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
d	double
=	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
spm1	long
]	O
;	O
if	O
(	O
d	double
==	O
c	int
)	O
{	O
if	O
(	O
c	int
>=	O
KEY_PRESS	int
)	O
return	O
;	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
sp	long
]	O
=	O
-	O
2	int
;	O
goto	O
check_bottom	O
;	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
CURS_LEFT	int
&&	O
d	double
==	O
CURS_RIGHT	int
)	O
||	O
(	O
c	int
==	O
CURS_RIGHT	int
&&	O
d	double
==	O
CURS_LEFT	int
)	O
)	O
{	O
edit	*(struct)
->	O
stack_pointer	long
=	O
spm1	long
;	O
return	O
;	O
}	O
}	O
}	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
sp	long
]	O
=	O
c	int
;	O
check_bottom	O
:	O
edit	*(struct)
->	O
stack_pointer	long
=	O
(	O
edit	*(struct)
->	O
stack_pointer	long
+	O
1	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
;	O
c	int
=	O
(	O
edit	*(struct)
->	O
stack_pointer	long
+	O
2	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
c	int
==	O
edit	*(struct)
->	O
stack_bottom	long
||	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
c	int
+	O
1	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
)	O
==	O
edit	*(struct)
->	O
stack_bottom	long
)	O
do	O
{	O
edit	*(struct)
->	O
stack_bottom	long
=	O
(	O
edit	*(struct)
->	O
stack_bottom	long
+	O
1	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
;	O
}	O
while	O
(	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
edit	*(struct)
->	O
stack_bottom	long
]	O
<	O
KEY_PRESS	int
&&	O
edit	*(struct)
->	O
stack_bottom	long
!=	O
edit	*(struct)
->	O
stack_pointer	long
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
stack_pointer	long
!=	O
edit	*(struct)
->	O
stack_bottom	long
&&	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
edit	*(struct)
->	O
stack_bottom	long
]	O
<	O
KEY_PRESS	int
)	O
edit	*(struct)
->	O
stack_bottom	long
=	O
edit	*(struct)
->	O
stack_pointer	long
=	O
0	int
;	O
}	O
static	O
long	O
pop_action	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
c	int
;	O
unsigned	O
long	O
sp	long
=	O
edit	*(struct)
->	O
stack_pointer	long
;	O
if	O
(	O
sp	long
==	O
edit	*(struct)
->	O
stack_bottom	long
)	O
{	O
return	O
STACK_BOTTOM	int
;	O
}	O
sp	long
=	O
(	O
sp	long
-	O
1	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
;	O
if	O
(	O
(	O
c	int
=	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
sp	long
]	O
)	O
>=	O
0	int
)	O
{	O
edit	*(struct)
->	O
stack_pointer	long
=	O
(	O
edit	*(struct)
->	O
stack_pointer	long
-	O
1	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
;	O
return	O
c	int
;	O
}	O
if	O
(	O
sp	long
==	O
edit	*(struct)
->	O
stack_bottom	long
)	O
{	O
return	O
STACK_BOTTOM	int
;	O
}	O
c	int
=	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
(	O
sp	long
-	O
1	int
)	O
&	O
edit	*(struct)
->	O
stack_size_mask	long
]	O
;	O
if	O
(	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
sp	long
]	O
==	O
-	O
2	int
)	O
{	O
edit	*(struct)
->	O
stack_pointer	long
=	O
sp	long
;	O
}	O
else	O
edit	*(struct)
->	O
undo_stack	*(long)
[	O
sp	long
]	O
++	O
;	O
return	O
c	int
;	O
}	O
static	O
inline	O
void	O
edit_modification	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit	*(struct)
->	O
caches_valid	int
=	O
0	int
;	O
edit	*(struct)
->	O
screen_modified	int
=	O
1	int
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
modified	long
&&	O
!	O
edit	*(struct)
->	O
delete_file	int
)	O
edit	*(struct)
->	O
locked	int
=	O
edit_lock_file	(*(char))->(int)
(	O
edit	*(struct)
->	O
filename	*(char)
)	O
;	O
edit	*(struct)
->	O
modified	long
=	O
1	int
;	O
}	O
void	O
edit_insert	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
c	int
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
last_byte	long
>=	O
SIZE_LIMIT	O
)	O
return	O
;	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
<	O
edit	*(struct)
->	O
start_display	long
)	O
{	O
edit	*(struct)
->	O
start_display	long
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
edit	*(struct)
->	O
start_line	long
++	O
;	O
}	O
if	O
(	O
edit	*(struct)
->	O
loading_done	int
)	O
{	O
edit_modification	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
book_mark	*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`)))))
)	O
book_mark_inc	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
)	O
;	O
edit	*(struct)
->	O
curs_line	long
++	O
;	O
edit	*(struct)
->	O
total_lines	long
++	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_LINE_ABOVE	O
|	O
REDRAW_AFTER_CURSOR	O
;	O
}	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
BACKSPACE	int
)	O
;	O
edit	*(struct)
->	O
mark1	long
+=	O
(	O
edit	*(struct)
->	O
mark1	long
>	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
mark2	long
+=	O
(	O
edit	*(struct)
->	O
mark2	long
>	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
last_get_rule	long
+=	O
(	O
edit	*(struct)
->	O
last_get_rule	long
>	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
edit	*(struct)
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
g_malloc	(long)->(*(void))
(	O
EDIT_BUF_SIZE	O
)	O
;	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
edit	*(struct)
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
edit	*(struct)
->	O
last_byte	long
++	O
;	O
edit	*(struct)
->	O
curs1	long
++	O
;	O
}	O
void	O
edit_insert_ahead	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
c	int
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
last_byte	long
>=	O
SIZE_LIMIT	O
)	O
return	O
;	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
<	O
edit	*(struct)
->	O
start_display	long
)	O
{	O
edit	*(struct)
->	O
start_display	long
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
edit	*(struct)
->	O
start_line	long
++	O
;	O
}	O
edit_modification	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
book_mark	*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`)))))
)	O
book_mark_inc	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
)	O
;	O
edit	*(struct)
->	O
total_lines	long
++	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_AFTER_CURSOR	O
;	O
}	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
DELCHAR	int
)	O
;	O
edit	*(struct)
->	O
mark1	long
+=	O
(	O
edit	*(struct)
->	O
mark1	long
>=	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
mark2	long
+=	O
(	O
edit	*(struct)
->	O
mark2	long
>=	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
last_get_rule	long
+=	O
(	O
edit	*(struct)
->	O
last_get_rule	long
>=	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
(	O
edit	*(struct)
->	O
curs2	long
+	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
(	O
edit	*(struct)
->	O
curs2	long
+	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
g_malloc	(long)->(*(void))
(	O
EDIT_BUF_SIZE	O
)	O
;	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
edit	*(struct)
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
=	O
c	int
;	O
edit	*(struct)
->	O
last_byte	long
++	O
;	O
edit	*(struct)
->	O
curs2	long
++	O
;	O
}	O
int	O
edit_delete	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
p	*(void)
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
curs2	long
)	O
return	O
0	int
;	O
edit	*(struct)
->	O
mark1	long
-=	O
(	O
edit	*(struct)
->	O
mark1	long
>	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
mark2	long
-=	O
(	O
edit	*(struct)
->	O
mark2	long
>	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
last_get_rule	long
-=	O
(	O
edit	*(struct)
->	O
last_get_rule	long
>	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
p	*(void)
=	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
(	O
edit	*(struct)
->	O
curs2	long
-	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
(	O
edit	*(struct)
->	O
curs2	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
;	O
if	O
(	O
!	O
(	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
edit	*(struct)
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
)	O
;	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
edit	*(struct)
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
NULL	O
;	O
}	O
edit	*(struct)
->	O
last_byte	long
--	O
;	O
edit	*(struct)
->	O
curs2	long
--	O
;	O
edit_modification	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
p	*(void)
==	O
'\n'	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
book_mark	*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`)))))
)	O
book_mark_dec	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
)	O
;	O
edit	*(struct)
->	O
total_lines	long
--	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_AFTER_CURSOR	O
;	O
}	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
p	*(void)
+	O
256	int
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
<	O
edit	*(struct)
->	O
start_display	long
)	O
{	O
edit	*(struct)
->	O
start_display	long
--	O
;	O
if	O
(	O
p	*(void)
==	O
'\n'	O
)	O
edit	*(struct)
->	O
start_line	long
--	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
int	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
p	*(void)
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
curs1	long
)	O
return	O
0	int
;	O
edit	*(struct)
->	O
mark1	long
-=	O
(	O
edit	*(struct)
->	O
mark1	long
>=	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
mark2	long
-=	O
(	O
edit	*(struct)
->	O
mark2	long
>=	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
last_get_rule	long
-=	O
(	O
edit	*(struct)
->	O
last_get_rule	long
>=	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
p	*(void)
=	O
*	O
(	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
(	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
+	O
(	O
(	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
(	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
)	O
;	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
NULL	O
;	O
}	O
edit	*(struct)
->	O
last_byte	long
--	O
;	O
edit	*(struct)
->	O
curs1	long
--	O
;	O
edit_modification	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
p	*(void)
==	O
'\n'	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
book_mark	*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`)))))
)	O
book_mark_dec	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
)	O
;	O
edit	*(struct)
->	O
curs_line	long
--	O
;	O
edit	*(struct)
->	O
total_lines	long
--	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_AFTER_CURSOR	O
;	O
}	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
p	*(void)
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
<	O
edit	*(struct)
->	O
start_display	long
)	O
{	O
edit	*(struct)
->	O
start_display	long
--	O
;	O
if	O
(	O
p	*(void)
==	O
'\n'	O
)	O
edit	*(struct)
->	O
start_line	long
--	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
int	O
edit_cursor_move	(*(struct),long)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
increment	long
)	O
{	O
int	O
c	int
;	O
if	O
(	O
increment	long
<	O
0	int
)	O
{	O
for	O
(	O
;	O
increment	long
<	O
0	int
;	O
increment	long
++	O
)	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
curs1	long
)	O
return	O
-	O
1	int
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
CURS_RIGHT	int
)	O
;	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
;	O
if	O
(	O
!	O
(	O
(	O
edit	*(struct)
->	O
curs2	long
+	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
(	O
edit	*(struct)
->	O
curs2	long
+	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
g_malloc	(long)->(*(void))
(	O
EDIT_BUF_SIZE	O
)	O
;	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
edit	*(struct)
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
=	O
c	int
;	O
edit	*(struct)
->	O
curs2	long
++	O
;	O
c	int
=	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
(	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
(	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
]	O
;	O
if	O
(	O
!	O
(	O
(	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
)	O
;	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
NULL	O
;	O
}	O
edit	*(struct)
->	O
curs1	long
--	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
edit	*(struct)
->	O
curs_line	long
--	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_LINE_BELOW	O
;	O
}	O
}	O
return	O
c	int
;	O
}	O
else	O
if	O
(	O
increment	long
>	O
0	int
)	O
{	O
for	O
(	O
;	O
increment	long
>	O
0	int
;	O
increment	long
--	O
)	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
curs2	long
)	O
return	O
-	O
2	int
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
CURS_LEFT	int
)	O
;	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
edit	*(struct)
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
g_malloc	(long)->(*(void))
(	O
EDIT_BUF_SIZE	O
)	O
;	O
edit	*(struct)
->	O
buffers1	array(*(char))
[	O
edit	*(struct)
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
edit	*(struct)
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
]	O
=	O
c	int
;	O
edit	*(struct)
->	O
curs1	long
++	O
;	O
c	int
=	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
(	O
edit	*(struct)
->	O
curs2	long
-	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
(	O
edit	*(struct)
->	O
curs2	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
;	O
if	O
(	O
!	O
(	O
edit	*(struct)
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
g_free	(*(void))->(void)
(	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
edit	*(struct)
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
)	O
;	O
edit	*(struct)
->	O
buffers2	array(*(char))
[	O
edit	*(struct)
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
0	int
;	O
}	O
edit	*(struct)
->	O
curs2	long
--	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
edit	*(struct)
->	O
curs_line	long
++	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_LINE_ABOVE	O
;	O
}	O
}	O
return	O
c	int
;	O
}	O
else	O
return	O
-	O
3	int
;	O
}	O
long	O
edit_eol	(*(struct),long)->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
current	long
)	O
{	O
if	O
(	O
current	long
<	O
edit	*(struct)
->	O
last_byte	long
)	O
{	O
for	O
(	O
;	O
;	O
current	long
++	O
)	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
current	long
)	O
==	O
'\n'	O
)	O
break	O
;	O
}	O
else	O
return	O
edit	*(struct)
->	O
last_byte	long
;	O
return	O
current	long
;	O
}	O
long	O
edit_bol	(*(struct),long)->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
current	long
)	O
{	O
if	O
(	O
current	long
>	O
0	int
)	O
{	O
for	O
(	O
;	O
;	O
current	long
--	O
)	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
current	long
-	O
1	int
)	O
==	O
'\n'	O
)	O
break	O
;	O
}	O
else	O
return	O
0	int
;	O
return	O
current	long
;	O
}	O
int	O
edit_count_lines	(*(struct),long,int)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
current	long
,	O
int	O
upto	int
)	O
{	O
int	O
lines	*(int)
=	O
0	int
;	O
if	O
(	O
upto	int
>	O
edit	*(struct)
->	O
last_byte	long
)	O
upto	int
=	O
edit	*(struct)
->	O
last_byte	long
;	O
if	O
(	O
current	long
<	O
0	int
)	O
current	long
=	O
0	int
;	O
while	O
(	O
current	long
<	O
upto	int
)	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
current	long
++	O
)	O
==	O
'\n'	O
)	O
lines	*(int)
++	O
;	O
return	O
lines	*(int)
;	O
}	O
long	O
edit_move_forward	(*(struct),long,int,long)->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
current	long
,	O
int	O
lines	*(int)
,	O
long	O
upto	int
)	O
{	O
if	O
(	O
upto	int
)	O
{	O
return	O
edit_count_lines	(*(struct),long,int)->(int)
(	O
edit	*(struct)
,	O
current	long
,	O
upto	int
)	O
;	O
}	O
else	O
{	O
int	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
lines	*(int)
<	O
0	int
)	O
lines	*(int)
=	O
0	int
;	O
while	O
(	O
lines	*(int)
--	O
)	O
{	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
edit_eol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
current	long
)	O
+	O
1	int
;	O
if	O
(	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
>	O
edit	*(struct)
->	O
last_byte	long
)	O
break	O
;	O
else	O
current	long
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
return	O
current	long
;	O
}	O
}	O
long	O
edit_move_backward	(*(struct),long,int)->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
current	long
,	O
int	O
lines	*(int)
)	O
{	O
if	O
(	O
lines	*(int)
<	O
0	int
)	O
lines	*(int)
=	O
0	int
;	O
current	long
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
current	long
)	O
;	O
while	O
(	O
(	O
lines	*(int)
--	O
)	O
&&	O
current	long
!=	O
0	int
)	O
current	long
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
current	long
-	O
1	int
)	O
;	O
return	O
current	long
;	O
}	O
long	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
current	long
,	O
int	O
cols	int
,	O
long	O
upto	int
)	O
{	O
long	O
p	*(void)
,	O
q	long
;	O
int	O
col	int
=	O
0	int
;	O
if	O
(	O
upto	int
)	O
{	O
q	long
=	O
upto	int
;	O
cols	int
=	O
-	O
10	int
;	O
}	O
else	O
q	long
=	O
edit	*(struct)
->	O
last_byte	long
+	O
2	int
;	O
for	O
(	O
col	int
=	O
0	int
,	O
p	*(void)
=	O
current	long
;	O
p	*(void)
<	O
q	long
;	O
p	*(void)
++	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
cols	int
!=	O
-	O
10	int
)	O
{	O
if	O
(	O
col	int
==	O
cols	int
)	O
return	O
p	*(void)
;	O
if	O
(	O
col	int
>	O
cols	int
)	O
return	O
p	*(void)
-	O
1	int
;	O
}	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
p	*(void)
)	O
;	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
col	int
+=	O
TAB_SIZE	O
-	O
col	int
%	O
TAB_SIZE	O
;	O
else	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
upto	int
)	O
return	O
col	int
;	O
else	O
return	O
p	*(void)
;	O
}	O
else	O
if	O
(	O
c	int
<	O
32	int
||	O
c	int
==	O
127	int
)	O
col	int
+=	O
2	int
;	O
else	O
col	int
++	O
;	O
}	O
return	O
col	int
;	O
}	O
int	O
edit_get_col	(*(struct))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
return	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
,	O
0	int
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
}	O
void	O
edit_update_curs_row	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit	*(struct)
->	O
curs_row	long
=	O
edit	*(struct)
->	O
curs_line	long
-	O
edit	*(struct)
->	O
start_line	long
;	O
}	O
void	O
edit_update_curs_col	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit	*(struct)
->	O
curs_col	long
=	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
,	O
0	int
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
}	O
void	O
edit_scroll_upward	(*(struct),long)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
unsigned	O
long	O
i	array(int)
)	O
{	O
unsigned	O
long	O
lines_above	long
=	O
edit	*(struct)
->	O
start_line	long
;	O
if	O
(	O
i	array(int)
>	O
lines_above	long
)	O
i	array(int)
=	O
lines_above	long
;	O
if	O
(	O
i	array(int)
)	O
{	O
edit	*(struct)
->	O
start_line	long
-=	O
i	array(int)
;	O
edit	*(struct)
->	O
start_display	long
=	O
edit_move_backward	(*(struct),long,int)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
start_display	long
,	O
i	array(int)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	*(struct)
->	O
force	int
&=	O
(	O
0xfff	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
}	O
edit_update_curs_row	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
void	O
edit_scroll_downward	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
i	array(int)
)	O
{	O
int	O
lines_below	int
;	O
lines_below	int
=	O
edit	*(struct)
->	O
total_lines	long
-	O
edit	*(struct)
->	O
start_line	long
-	O
(	O
edit	*(struct)
->	O
num_widget_lines	int
-	O
1	int
)	O
;	O
if	O
(	O
lines_below	int
>	O
0	int
)	O
{	O
if	O
(	O
i	array(int)
>	O
lines_below	int
)	O
i	array(int)
=	O
lines_below	int
;	O
edit	*(struct)
->	O
start_line	long
+=	O
i	array(int)
;	O
edit	*(struct)
->	O
start_display	long
=	O
edit_move_forward	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
start_display	long
,	O
i	array(int)
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	*(struct)
->	O
force	int
&=	O
(	O
0xfff	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
}	O
edit_update_curs_row	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
void	O
edit_scroll_right	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
i	array(int)
)	O
{	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	*(struct)
->	O
force	int
&=	O
(	O
0xfff	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
edit	*(struct)
->	O
start_col	long
-=	O
i	array(int)
;	O
}	O
void	O
edit_scroll_left	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
i	array(int)
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
start_col	long
)	O
{	O
edit	*(struct)
->	O
start_col	long
+=	O
i	array(int)
;	O
if	O
(	O
edit	*(struct)
->	O
start_col	long
>	O
0	int
)	O
edit	*(struct)
->	O
start_col	long
=	O
0	int
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	*(struct)
->	O
force	int
&=	O
(	O
0xfff	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
}	O
}	O
static	O
int	O
is_in_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
p	*(void)
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
while	O
(	O
p	*(void)
<	O
edit	*(struct)
->	O
curs1	long
)	O
if	O
(	O
!	O
strchr	(*(char),int)->(*(char))
(	O
" \t"	*(char)
,	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
p	*(void)
++	O
)	O
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
left_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
;	O
void	O
edit_move_to_prev_col	(*(struct),long)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
p	*(void)
)	O
{	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
p	*(void)
,	O
edit	*(struct)
->	O
prev_col	long
,	O
0	int
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
is_in_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
&&	O
option_fake_half_tabs	int
)	O
{	O
edit_update_curs_col	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
space_width	int
)	O
if	O
(	O
edit	*(struct)
->	O
curs_col	long
%	O
(	O
HALF_TAB_SIZE	O
*	O
space_width	int
)	O
)	O
{	O
int	O
q	long
=	O
edit	*(struct)
->	O
curs_col	long
;	O
edit	*(struct)
->	O
curs_col	long
-=	O
(	O
edit	*(struct)
->	O
curs_col	long
%	O
(	O
HALF_TAB_SIZE	O
*	O
space_width	int
)	O
)	O
;	O
p	*(void)
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
p	*(void)
,	O
edit	*(struct)
->	O
curs_col	long
,	O
0	int
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
left_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
p	*(void)
,	O
q	long
,	O
0	int
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
}	O
}	O
}	O
void	O
edit_move_up	(*(struct),long,int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
unsigned	O
long	O
i	array(int)
,	O
int	O
scroll	int
)	O
{	O
unsigned	O
long	O
p	*(void)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
edit	*(struct)
->	O
curs_line	long
;	O
if	O
(	O
i	array(int)
>	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
i	array(int)
=	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
if	O
(	O
i	array(int)
)	O
{	O
if	O
(	O
i	array(int)
>	O
1	int
)	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
if	O
(	O
scroll	int
)	O
edit_scroll_upward	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
;	O
p	*(void)
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
(	O
p	*(void)
=	O
edit_move_backward	(*(struct),long,int)->(long)
(	O
edit	*(struct)
,	O
p	*(void)
,	O
i	array(int)
)	O
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_move_to_prev_col	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
p	*(void)
)	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit	*(struct)
->	O
found_len	int
=	O
0	int
;	O
}	O
}	O
static	O
int	O
is_blank	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
offset	long
)	O
{	O
long	O
s	*(char)
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
c	int
;	O
s	*(char)
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
offset	long
)	O
;	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
edit_eol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
offset	long
)	O
-	O
1	int
;	O
while	O
(	O
s	*(char)
<=	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
s	*(char)
++	O
)	O
;	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
long	O
edit_find_line	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
line	int
)	O
{	O
int	O
i	array(int)
,	O
j	int
=	O
0	int
;	O
int	O
m	int
=	O
2000000000	int
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
caches_valid	int
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
N_LINE_CACHES	int
;	O
i	array(int)
++	O
)	O
edit	*(struct)
->	O
line_numbers	array(int)
[	O
i	array(int)
]	O
=	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
i	array(int)
]	O
=	O
0	int
;	O
edit	*(struct)
->	O
line_numbers	array(int)
[	O
1	int
]	O
=	O
edit	*(struct)
->	O
curs_line	long
;	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
1	int
]	O
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
line_numbers	array(int)
[	O
2	int
]	O
=	O
edit	*(struct)
->	O
total_lines	long
;	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
2	int
]	O
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
last_byte	long
)	O
;	O
edit	*(struct)
->	O
caches_valid	int
=	O
1	int
;	O
}	O
if	O
(	O
line	int
>=	O
edit	*(struct)
->	O
total_lines	long
)	O
return	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
2	int
]	O
;	O
if	O
(	O
line	int
<=	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
N_LINE_CACHES	int
;	O
i	array(int)
++	O
)	O
{	O
int	O
n	long
;	O
n	long
=	O
abs	(int)->(int)
(	O
edit	*(struct)
->	O
line_numbers	array(int)
[	O
i	array(int)
]	O
-	O
line	int
)	O
;	O
if	O
(	O
n	long
<	O
m	int
)	O
{	O
m	int
=	O
n	long
;	O
j	int
=	O
i	array(int)
;	O
}	O
}	O
if	O
(	O
m	int
==	O
0	int
)	O
return	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
j	int
]	O
;	O
if	O
(	O
m	int
==	O
1	int
&&	O
j	int
>=	O
3	int
)	O
i	array(int)
=	O
j	int
;	O
else	O
i	array(int)
=	O
3	int
+	O
(	O
rand	()->(int)
(	O
)	O
%	O
(	O
N_LINE_CACHES	int
-	O
3	int
)	O
)	O
;	O
if	O
(	O
line	int
>	O
edit	*(struct)
->	O
line_numbers	array(int)
[	O
j	int
]	O
)	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
i	array(int)
]	O
=	O
edit_move_forward	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
j	int
]	O
,	O
line	int
-	O
edit	*(struct)
->	O
line_numbers	array(int)
[	O
j	int
]	O
,	O
0	int
)	O
;	O
else	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
i	array(int)
]	O
=	O
edit_move_backward	(*(struct),long,int)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
j	int
]	O
,	O
edit	*(struct)
->	O
line_numbers	array(int)
[	O
j	int
]	O
-	O
line	int
)	O
;	O
edit	*(struct)
->	O
line_numbers	array(int)
[	O
i	array(int)
]	O
=	O
line	int
;	O
return	O
edit	*(struct)
->	O
line_offsets	array(long)
[	O
i	array(int)
]	O
;	O
}	O
int	O
line_is_blank	(*(struct),long)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
line	int
)	O
{	O
return	O
is_blank	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),long)->(int)
(	O
edit	*(struct)
,	O
edit_find_line	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(long)
(	O
edit	*(struct)
,	O
line	int
)	O
)	O
;	O
}	O
static	O
void	O
edit_move_up_paragraph	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
scroll	int
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
edit	*(struct)
->	O
curs_line	long
<=	O
1	int
)	O
{	O
i	array(int)
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
)	O
)	O
{	O
if	O
(	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
-	O
1	int
)	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
edit	*(struct)
->	O
curs_line	long
-	O
1	int
;	O
i	array(int)
;	O
i	array(int)
--	O
)	O
if	O
(	O
!	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
)	O
{	O
i	array(int)
++	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array(int)
=	O
edit	*(struct)
->	O
curs_line	long
-	O
1	int
;	O
i	array(int)
;	O
i	array(int)
--	O
)	O
if	O
(	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array(int)
=	O
edit	*(struct)
->	O
curs_line	long
-	O
1	int
;	O
i	array(int)
;	O
i	array(int)
--	O
)	O
if	O
(	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
)	O
break	O
;	O
}	O
}	O
edit_move_up	(*(struct),long,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
-	O
i	array(int)
,	O
scroll	int
)	O
;	O
}	O
void	O
edit_move_down	(*(struct),int,int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
i	array(int)
,	O
int	O
scroll	int
)	O
{	O
long	O
p	*(void)
,	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
edit	*(struct)
->	O
total_lines	long
-	O
edit	*(struct)
->	O
curs_line	long
;	O
if	O
(	O
i	array(int)
>	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
i	array(int)
=	O
l	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
if	O
(	O
i	array(int)
)	O
{	O
if	O
(	O
i	array(int)
>	O
1	int
)	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
if	O
(	O
scroll	int
)	O
edit_scroll_downward	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
;	O
p	*(void)
=	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
(	O
p	*(void)
=	O
edit_move_forward	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
p	*(void)
,	O
i	array(int)
,	O
0	int
)	O
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_move_to_prev_col	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
p	*(void)
)	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit	*(struct)
->	O
found_len	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
edit_move_down_paragraph	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
scroll	int
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
edit	*(struct)
->	O
curs_line	long
>=	O
edit	*(struct)
->	O
total_lines	long
-	O
1	int
)	O
{	O
i	array(int)
=	O
edit	*(struct)
->	O
total_lines	long
;	O
}	O
else	O
{	O
if	O
(	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
)	O
)	O
{	O
if	O
(	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
+	O
1	int
)	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
edit	*(struct)
->	O
curs_line	long
+	O
1	int
;	O
i	array(int)
;	O
i	array(int)
++	O
)	O
if	O
(	O
!	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
||	O
i	array(int)
>	O
edit	*(struct)
->	O
total_lines	long
)	O
{	O
i	array(int)
--	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array(int)
=	O
edit	*(struct)
->	O
curs_line	long
+	O
1	int
;	O
i	array(int)
;	O
i	array(int)
++	O
)	O
if	O
(	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
||	O
i	array(int)
>=	O
edit	*(struct)
->	O
total_lines	long
)	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array(int)
=	O
edit	*(struct)
->	O
curs_line	long
+	O
1	int
;	O
i	array(int)
;	O
i	array(int)
++	O
)	O
if	O
(	O
line_is_blank	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
i	array(int)
)	O
||	O
i	array(int)
>=	O
edit	*(struct)
->	O
total_lines	long
)	O
break	O
;	O
}	O
}	O
edit_move_down	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
i	array(int)
-	O
edit	*(struct)
->	O
curs_line	long
,	O
scroll	int
)	O
;	O
}	O
static	O
void	O
edit_begin_page	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_update_curs_row	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit_move_up	(*(struct),long,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_row	long
,	O
0	int
)	O
;	O
}	O
static	O
void	O
edit_end_page	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_update_curs_row	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit_move_down	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
num_widget_lines	int
-	O
edit	*(struct)
->	O
curs_row	long
-	O
1	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
edit_move_to_top	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
curs_line	long
)	O
{	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit_move_to_prev_col	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
0	int
;	O
edit_update_curs_row	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
}	O
static	O
void	O
edit_move_to_bottom	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
curs_line	long
<	O
edit	*(struct)
->	O
total_lines	long
)	O
{	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs2	long
)	O
;	O
edit	*(struct)
->	O
start_display	long
=	O
edit	*(struct)
->	O
last_byte	long
;	O
edit	*(struct)
->	O
start_line	long
=	O
edit	*(struct)
->	O
total_lines	long
;	O
edit_update_curs_row	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit_scroll_upward	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
num_widget_lines	int
-	O
1	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
}	O
static	O
void	O
edit_cursor_to_bol	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit	*(struct)
->	O
prev_col	long
=	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
static	O
void	O
edit_cursor_to_eol	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit_eol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit	*(struct)
->	O
prev_col	long
=	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
void	O
edit_move_to_line	(*(struct),long)->(void)
(	O
WEdit	struct
*	O
e	*(struct)
,	O
long	O
line	int
)	O
{	O
if	O
(	O
line	int
<	O
e	*(struct)
->	O
curs_line	long
)	O
edit_move_up	(*(struct),long,int)->(void)
(	O
e	*(struct)
,	O
e	*(struct)
->	O
curs_line	long
-	O
line	int
,	O
0	int
)	O
;	O
else	O
edit_move_down	(*(struct),int,int)->(void)
(	O
e	*(struct)
,	O
line	int
-	O
e	*(struct)
->	O
curs_line	long
,	O
0	int
)	O
;	O
edit_scroll_screen_over_cursor	(*(struct))->(void)
(	O
e	*(struct)
)	O
;	O
}	O
void	O
edit_move_display	(*(struct),long)->(void)
(	O
WEdit	struct
*	O
e	*(struct)
,	O
long	O
line	int
)	O
{	O
if	O
(	O
line	int
<	O
e	*(struct)
->	O
start_line	long
)	O
edit_scroll_upward	(*(struct),long)->(void)
(	O
e	*(struct)
,	O
e	*(struct)
->	O
start_line	long
-	O
line	int
)	O
;	O
else	O
edit_scroll_downward	(*(struct),int)->(void)
(	O
e	*(struct)
,	O
line	int
-	O
e	*(struct)
->	O
start_line	long
)	O
;	O
}	O
void	O
edit_push_markers	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
MARK_1	int
+	O
edit	*(struct)
->	O
mark1	long
)	O
;	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
MARK_2	int
+	O
edit	*(struct)
->	O
mark2	long
)	O
;	O
}	O
void	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
m1	long
,	O
long	O
m2	long
,	O
int	O
c1	int
,	O
int	O
c2	int
)	O
{	O
edit	*(struct)
->	O
mark1	long
=	O
m1	long
;	O
edit	*(struct)
->	O
mark2	long
=	O
m2	long
;	O
edit	*(struct)
->	O
column1	int
=	O
c1	int
;	O
edit	*(struct)
->	O
column2	int
=	O
c2	int
;	O
}	O
void	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
unmark	int
)	O
{	O
edit_push_markers	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
unmark	int
)	O
{	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
{	O
if	O
(	O
edit	*(struct)
->	O
mark2	long
>=	O
0	int
)	O
{	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
,	O
-	O
1	int
,	O
edit	*(struct)
->	O
curs_col	long
,	O
edit	*(struct)
->	O
curs_col	long
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
edit_set_markers	(*(struct),long,long,int,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
mark1	long
,	O
edit	*(struct)
->	O
curs1	long
,	O
edit	*(struct)
->	O
column1	int
,	O
edit	*(struct)
->	O
curs_col	long
)	O
;	O
}	O
}	O
static	O
unsigned	O
long	O
my_type_of	(int)->(long)
(	O
int	O
c	int
)	O
{	O
int	O
x	array(long)
,	O
r	int
=	O
0	int
;	O
const	O
char	O
*	O
p	*(void)
,	O
*	O
q	long
;	O
const	O
char	O
option_chars_move_whole_word	array(char)
[	O
]	O
=	O
"!=&|<>^~ !:;, !'!`!.?!\"!( !) !Aa0 !+-*/= |<> ![ !] !\\#! "	*(char)
;	O
if	O
(	O
!	O
c	int
)	O
return	O
0	int
;	O
if	O
(	O
c	int
==	O
'!'	O
)	O
{	O
if	O
(	O
*	O
option_chars_move_whole_word	array(char)
==	O
'!'	O
)	O
return	O
2	int
;	O
return	O
0x80000000UL	int
;	O
}	O
if	O
(	O
isupper	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
'A'	O
;	O
else	O
if	O
(	O
islower	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
'a'	O
;	O
else	O
if	O
(	O
isalpha	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
'a'	O
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
'0'	O
;	O
else	O
if	O
(	O
isspace	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
' '	O
;	O
q	long
=	O
strchr	(*(char),int)->(*(char))
(	O
option_chars_move_whole_word	array(char)
,	O
c	int
)	O
;	O
if	O
(	O
!	O
q	long
)	O
return	O
0xFFFFFFFFUL	int
;	O
do	O
{	O
for	O
(	O
x	array(long)
=	O
1	int
,	O
p	*(void)
=	O
option_chars_move_whole_word	array(char)
;	O
p	*(void)
<	O
q	long
;	O
p	*(void)
++	O
)	O
if	O
(	O
*	O
p	*(void)
==	O
'!'	O
)	O
x	array(long)
<<=	O
1	int
;	O
r	int
|=	O
x	array(long)
;	O
}	O
while	O
(	O
(	O
q	long
=	O
strchr	(*(char),int)->(*(char))
(	O
q	long
+	O
1	int
,	O
c	int
)	O
)	O
)	O
;	O
return	O
r	int
;	O
}	O
static	O
void	O
edit_left_word_move	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
s	*(char)
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c1	int
,	O
c2	int
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
curs1	long
)	O
break	O
;	O
c1	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
;	O
c2	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
my_type_of	(int)->(long)
(	O
c1	int
)	O
&	O
my_type_of	(int)->(long)
(	O
c2	int
)	O
)	O
)	O
break	O
;	O
if	O
(	O
isspace	(int)->(int)
(	O
c1	int
)	O
&&	O
!	O
isspace	(int)->(int)
(	O
c2	int
)	O
)	O
break	O
;	O
if	O
(	O
s	*(char)
)	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
c1	int
)	O
&&	O
isspace	(int)->(int)
(	O
c2	int
)	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
edit_left_word_move_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_left_word_move	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
static	O
void	O
edit_right_word_move	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
s	*(char)
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c1	int
,	O
c2	int
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
>=	O
edit	*(struct)
->	O
last_byte	long
)	O
break	O
;	O
c1	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
;	O
c2	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
my_type_of	(int)->(long)
(	O
c1	int
)	O
&	O
my_type_of	(int)->(long)
(	O
c2	int
)	O
)	O
)	O
break	O
;	O
if	O
(	O
isspace	(int)->(int)
(	O
c1	int
)	O
&&	O
!	O
isspace	(int)->(int)
(	O
c2	int
)	O
)	O
break	O
;	O
if	O
(	O
s	*(char)
)	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
c1	int
)	O
&&	O
isspace	(int)->(int)
(	O
c2	int
)	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
edit_right_word_move_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_right_word_move	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
static	O
void	O
edit_right_delete_word	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
c1	int
,	O
c2	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
>=	O
edit	*(struct)
->	O
last_byte	long
)	O
break	O
;	O
c1	int
=	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
c2	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
if	O
(	O
(	O
isspace	(int)->(int)
(	O
c1	int
)	O
==	O
0	int
)	O
!=	O
(	O
isspace	(int)->(int)
(	O
c2	int
)	O
==	O
0	int
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
my_type_of	(int)->(long)
(	O
c1	int
)	O
&	O
my_type_of	(int)->(long)
(	O
c2	int
)	O
)	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
edit_left_delete_word	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
c1	int
,	O
c2	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
curs1	long
<=	O
0	int
)	O
break	O
;	O
c1	int
=	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
c2	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
;	O
if	O
(	O
(	O
isspace	(int)->(int)
(	O
c1	int
)	O
==	O
0	int
)	O
!=	O
(	O
isspace	(int)->(int)
(	O
c2	int
)	O
==	O
0	int
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
my_type_of	(int)->(long)
(	O
c1	int
)	O
&	O
my_type_of	(int)->(long)
(	O
c2	int
)	O
)	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
edit_do_undo	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
ac	long
;	O
long	O
count	int
=	O
0	int
;	O
edit	*(struct)
->	O
stack_disable	int
=	O
1	int
;	O
while	O
(	O
(	O
ac	long
=	O
pop_action	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(long)
(	O
edit	*(struct)
)	O
)	O
<	O
KEY_PRESS	int
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
ac	long
)	O
{	O
case	O
STACK_BOTTOM	int
:	O
goto	O
done_undo	O
;	O
case	O
CURS_RIGHT	int
:	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CURS_LEFT	int
:	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
BACKSPACE	int
:	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
DELCHAR	int
:	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
COLUMN_ON	int
:	O
column_highlighting	int
=	O
1	int
;	O
break	O
;	O
case	O
COLUMN_OFF	int
:	O
column_highlighting	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
ac	long
>=	O
256	int
&&	O
ac	long
<	O
512	int
)	O
edit_insert_ahead	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
ac	long
-	O
256	int
)	O
;	O
if	O
(	O
ac	long
>=	O
0	int
&&	O
ac	long
<	O
256	int
)	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
ac	long
)	O
;	O
if	O
(	O
ac	long
>=	O
MARK_1	int
-	O
2	int
&&	O
ac	long
<	O
MARK_2	int
-	O
2	int
)	O
{	O
edit	*(struct)
->	O
mark1	long
=	O
ac	long
-	O
MARK_1	int
;	O
edit	*(struct)
->	O
column1	int
=	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
mark1	long
)	O
,	O
0	int
,	O
edit	*(struct)
->	O
mark1	long
)	O
;	O
}	O
else	O
if	O
(	O
ac	long
>=	O
MARK_2	int
-	O
2	int
&&	O
ac	long
<	O
KEY_PRESS	int
)	O
{	O
edit	*(struct)
->	O
mark2	long
=	O
ac	long
-	O
MARK_2	int
;	O
edit	*(struct)
->	O
column2	int
=	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
edit_bol	(*(struct),long)->(long)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
mark2	long
)	O
,	O
0	int
,	O
edit	*(struct)
->	O
mark2	long
)	O
;	O
}	O
if	O
(	O
count	int
++	O
)	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
if	O
(	O
edit	*(struct)
->	O
start_display	long
>	O
ac	long
-	O
KEY_PRESS	int
)	O
{	O
edit	*(struct)
->	O
start_line	long
-=	O
edit_count_lines	(*(struct),long,int)->(int)
(	O
edit	*(struct)
,	O
ac	long
-	O
KEY_PRESS	int
,	O
edit	*(struct)
->	O
start_display	long
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
if	O
(	O
edit	*(struct)
->	O
start_display	long
<	O
ac	long
-	O
KEY_PRESS	int
)	O
{	O
edit	*(struct)
->	O
start_line	long
+=	O
edit_count_lines	(*(struct),long,int)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
start_display	long
,	O
ac	long
-	O
KEY_PRESS	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
edit	*(struct)
->	O
start_display	long
=	O
ac	long
-	O
KEY_PRESS	int
;	O
edit_update_curs_row	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
done_undo	O
:	O
;	O
edit	*(struct)
->	O
stack_disable	int
=	O
0	int
;	O
}	O
static	O
void	O
edit_delete_to_line_end	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
while	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
curs2	long
)	O
break	O
;	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
}	O
static	O
void	O
edit_delete_to_line_begin	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
while	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
!	O
edit	*(struct)
->	O
curs1	long
)	O
break	O
;	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
}	O
void	O
edit_delete_line	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
while	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
{	O
(	O
void	O
)	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
(	O
void	O
)	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
while	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
!=	O
'\n'	O
)	O
{	O
(	O
void	O
)	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
;	O
}	O
static	O
void	O
insert_spaces_tab	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
half	int
)	O
{	O
int	O
i	array(int)
;	O
edit_update_curs_col	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
i	array(int)
=	O
(	O
(	O
edit	*(struct)
->	O
curs_col	long
/	O
(	O
option_tab_spacing	int
*	O
space_width	int
/	O
(	O
half	int
+	O
1	int
)	O
)	O
)	O
+	O
1	int
)	O
*	O
(	O
option_tab_spacing	int
*	O
space_width	int
/	O
(	O
half	int
+	O
1	int
)	O
)	O
-	O
edit	*(struct)
->	O
curs_col	long
;	O
while	O
(	O
i	array(int)
>	O
0	int
)	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
' '	O
)	O
;	O
i	array(int)
-=	O
space_width	int
;	O
}	O
}	O
static	O
int	O
is_aligned_on_a_tab	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_update_curs_col	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
(	O
edit	*(struct)
->	O
curs_col	long
%	O
(	O
TAB_SIZE	O
*	O
space_width	int
)	O
)	O
&&	O
edit	*(struct)
->	O
curs_col	long
%	O
(	O
TAB_SIZE	O
*	O
space_width	int
)	O
!=	O
(	O
HALF_TAB_SIZE	O
*	O
space_width	int
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
right_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
i	array(int)
,	O
ch	int
=	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
1	int
;	O
i	array(int)
<=	O
HALF_TAB_SIZE	O
;	O
i	array(int)
++	O
)	O
ch	int
|=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
i	array(int)
)	O
;	O
if	O
(	O
ch	int
==	O
' '	O
)	O
return	O
is_aligned_on_a_tab	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
left_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
i	array(int)
,	O
ch	int
=	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
HALF_TAB_SIZE	O
;	O
i	array(int)
++	O
)	O
ch	int
|=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
+	O
i	array(int)
)	O
;	O
if	O
(	O
ch	int
==	O
' '	O
)	O
return	O
is_aligned_on_a_tab	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_indent_width	(*(struct),long)->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
p	*(void)
)	O
{	O
long	O
q	long
=	O
p	*(void)
;	O
while	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"\t "	*(char)
,	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
q	long
)	O
)	O
&&	O
q	long
<	O
edit	*(struct)
->	O
last_byte	long
-	O
1	int
)	O
q	long
++	O
;	O
return	O
edit_move_forward3	(*(struct),long,int,long)->(long)
(	O
edit	*(struct)
,	O
p	*(void)
,	O
0	int
,	O
q	long
)	O
;	O
}	O
void	O
edit_insert_indent	(*(struct),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
indent	int
)	O
{	O
if	O
(	O
!	O
option_fill_tabs_with_spaces	int
)	O
{	O
while	O
(	O
indent	int
>=	O
TAB_SIZE	O
)	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\t'	O
)	O
;	O
indent	int
-=	O
TAB_SIZE	O
;	O
}	O
}	O
while	O
(	O
indent	int
--	O
>	O
0	int
)	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
' '	O
)	O
;	O
}	O
static	O
void	O
edit_auto_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
p	*(void)
;	O
char	O
c	int
;	O
p	*(void)
=	O
edit	*(struct)
->	O
curs1	long
;	O
p	*(void)
=	O
edit_move_backward	(*(struct),long,int)->(long)
(	O
edit	*(struct)
,	O
p	*(void)
,	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
p	*(void)
++	O
)	O
;	O
if	O
(	O
c	int
!=	O
' '	O
&&	O
c	int
!=	O
'\t'	O
)	O
break	O
;	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
c	int
)	O
;	O
}	O
}	O
static	O
void	O
edit_double_newline	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\n'	O
)	O
;	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
==	O
'\n'	O
)	O
return	O
;	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
2	int
)	O
==	O
'\n'	O
)	O
return	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
edit_tab_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
if	O
(	O
is_in_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
{	O
if	O
(	O
!	O
option_fill_tabs_with_spaces	int
&&	O
right_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
1	int
;	O
i	array(int)
<=	O
HALF_TAB_SIZE	O
;	O
i	array(int)
++	O
)	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\t'	O
)	O
;	O
}	O
else	O
{	O
insert_spaces_tab	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
}	O
return	O
;	O
}	O
}	O
if	O
(	O
option_fill_tabs_with_spaces	int
)	O
{	O
insert_spaces_tab	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\t'	O
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
check_and_wrap_line	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
int	O
curs	int
,	O
c	int
;	O
if	O
(	O
!	O
option_typewriter_wrap	int
)	O
return	O
;	O
edit_update_curs_col	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
curs_col	long
<	O
option_word_wrap_line_length	int
)	O
return	O
;	O
curs	int
=	O
edit	*(struct)
->	O
curs1	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
curs	int
--	O
;	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
curs	int
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
curs	int
<=	O
0	int
)	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\n'	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
)	O
{	O
int	O
current	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
curs	int
-	O
edit	*(struct)
->	O
curs1	long
+	O
1	int
)	O
;	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\n'	O
)	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
current	long
-	O
edit	*(struct)
->	O
curs1	long
+	O
1	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
edit_execute_macro	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),array(struct(short,short)),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
struct	O
macro	struct(short,short)
macro	struct(short,short)
[	O
]	O
,	O
int	O
n	long
)	O
;	O
void	O
edit_push_key_press	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
KEY_PRESS	int
+	O
edit	*(struct)
->	O
start_display	long
)	O
;	O
if	O
(	O
edit	*(struct)
->	O
mark2	long
==	O
-	O
1	int
)	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
MARK_1	int
+	O
edit	*(struct)
->	O
mark1	long
)	O
;	O
}	O
static	O
long	O
edit_get_bracket	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int,long)->(long)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
in_screen	int
,	O
unsigned	O
long	O
furthest_bracket_search	long
)	O
{	O
const	O
char	O
*	O
const	O
b	*(void)
=	O
"{}{[][()("	*(char)
,	O
*	O
p	*(void)
;	O
int	O
i	array(int)
=	O
1	int
,	O
a	*(void)
,	O
inc	int
=	O
-	O
1	int
,	O
c	int
,	O
d	double
,	O
n	long
=	O
0	int
;	O
unsigned	O
long	O
j	int
=	O
0	int
;	O
long	O
q	long
;	O
edit_update_curs_row	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
c	int
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
b	*(void)
,	O
c	int
)	O
;	O
if	O
(	O
!	O
furthest_bracket_search	long
)	O
furthest_bracket_search	long
--	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
-	O
1	int
;	O
d	double
=	O
p	*(void)
[	O
1	int
]	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"{[("	*(char)
,	O
c	int
)	O
)	O
inc	int
=	O
1	int
;	O
for	O
(	O
q	long
=	O
edit	*(struct)
->	O
curs1	long
+	O
inc	int
;	O
;	O
q	long
+=	O
inc	int
)	O
{	O
if	O
(	O
q	long
>=	O
edit	*(struct)
->	O
last_byte	long
||	O
q	long
<	O
0	int
)	O
break	O
;	O
a	*(void)
=	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
q	long
)	O
;	O
if	O
(	O
j	int
++	O
>	O
furthest_bracket_search	long
)	O
break	O
;	O
if	O
(	O
in_screen	int
)	O
{	O
if	O
(	O
q	long
<	O
edit	*(struct)
->	O
start_display	long
)	O
break	O
;	O
if	O
(	O
inc	int
>	O
0	int
&&	O
a	*(void)
==	O
'\n'	O
)	O
if	O
(	O
n	long
++	O
>=	O
edit	*(struct)
->	O
num_widget_lines	int
-	O
edit	*(struct)
->	O
curs_row	long
)	O
break	O
;	O
}	O
i	array(int)
+=	O
(	O
a	*(void)
==	O
c	int
)	O
-	O
(	O
a	*(void)
==	O
d	double
)	O
;	O
if	O
(	O
!	O
i	array(int)
)	O
return	O
q	long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
long	O
last_bracket	long
=	O
-	O
1	int
;	O
void	O
edit_find_bracket	(*(struct))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
edit	*(struct)
->	O
bracket	long
=	O
edit_get_bracket	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int,long)->(long)
(	O
edit	*(struct)
,	O
1	int
,	O
10000	int
)	O
;	O
if	O
(	O
last_bracket	long
!=	O
edit	*(struct)
->	O
bracket	long
)	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
last_bracket	long
=	O
edit	*(struct)
->	O
bracket	long
;	O
}	O
static	O
void	O
edit_goto_matching_bracket	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
long	O
q	long
;	O
q	long
=	O
edit_get_bracket	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int,long)->(long)
(	O
edit	*(struct)
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
q	long
<	O
0	int
)	O
return	O
;	O
edit	*(struct)
->	O
bracket	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
q	long
-	O
edit	*(struct)
->	O
curs1	long
)	O
;	O
}	O
void	O
edit_execute_key_command	(*(struct),int,int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
command	*(char)
,	O
int	O
char_for_insertion	int
)	O
{	O
if	O
(	O
command	*(char)
==	O
CK_Begin_Record_Macro	int
)	O
{	O
edit	*(struct)
->	O
macro_i	int
=	O
0	int
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_CHAR_ONLY	O
|	O
REDRAW_LINE	O
;	O
return	O
;	O
}	O
if	O
(	O
command	*(char)
==	O
CK_End_Record_Macro	int
&&	O
edit	*(struct)
->	O
macro_i	int
!=	O
-	O
1	int
)	O
{	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
edit_save_macro_cmd	(*(struct),array(struct(short,short)),int)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
macro	struct(short,short)
,	O
edit	*(struct)
->	O
macro_i	int
)	O
;	O
edit	*(struct)
->	O
macro_i	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
edit	*(struct)
->	O
macro_i	int
>=	O
0	int
&&	O
edit	*(struct)
->	O
macro_i	int
<	O
MAX_MACRO_LENGTH	int
-	O
1	int
)	O
{	O
edit	*(struct)
->	O
macro	struct(short,short)
[	O
edit	*(struct)
->	O
macro_i	int
]	O
.	O
command	*(char)
=	O
command	*(char)
;	O
edit	*(struct)
->	O
macro	struct(short,short)
[	O
edit	*(struct)
->	O
macro_i	int
++	O
]	O
.	O
ch	int
=	O
char_for_insertion	int
;	O
}	O
if	O
(	O
command	*(char)
!=	O
CK_Undo	int
&&	O
command	*(char)
!=	O
CK_Ext_Mode	int
)	O
edit_push_key_press	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit_execute_cmd	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
command	*(char)
,	O
char_for_insertion	int
)	O
;	O
if	O
(	O
column_highlighting	int
)	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
static	O
const	O
char	O
*	O
const	O
shell_cmd	*(char)
[	O
]	O
=	O
SHELL_COMMANDS_i	O
;	O
void	O
edit_execute_cmd	(*(struct),int,int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
int	O
command	*(char)
,	O
int	O
char_for_insertion	int
)	O
{	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_LINE	O
;	O
if	O
(	O
edit	*(struct)
->	O
found_len	int
||	O
column_highlighting	int
)	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
if	O
(	O
command	*(char)
/	O
100	int
==	O
6	int
)	O
{	O
column_highlighting	int
=	O
0	int
;	O
if	O
(	O
!	O
edit	*(struct)
->	O
highlight	int
||	O
(	O
edit	*(struct)
->	O
mark2	long
!=	O
-	O
1	int
&&	O
edit	*(struct)
->	O
mark1	long
!=	O
edit	*(struct)
->	O
mark2	long
)	O
)	O
{	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
}	O
edit	*(struct)
->	O
highlight	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
edit	*(struct)
->	O
highlight	int
)	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
highlight	int
=	O
0	int
;	O
}	O
if	O
(	O
command	*(char)
==	O
CK_Undo	int
)	O
{	O
edit_do_undo	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
found_len	int
=	O
0	int
;	O
edit	*(struct)
->	O
prev_col	long
=	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
return	O
;	O
}	O
if	O
(	O
char_for_insertion	int
>=	O
0	int
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
overwrite	int
)	O
{	O
if	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
char_for_insertion	int
)	O
;	O
if	O
(	O
option_auto_para_formatting	int
)	O
{	O
format_paragraph	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
check_and_wrap_line	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
found_len	int
=	O
0	int
;	O
edit	*(struct)
->	O
prev_col	long
=	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit_find_bracket	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
command	*(char)
)	O
{	O
case	O
CK_Begin_Page	int
:	O
case	O
CK_End_Page	int
:	O
case	O
CK_Begin_Page_Highlight	int
:	O
case	O
CK_End_Page_Highlight	int
:	O
case	O
CK_Word_Left	int
:	O
case	O
CK_Word_Right	int
:	O
case	O
CK_Up	int
:	O
case	O
CK_Down	int
:	O
case	O
CK_Word_Left_Highlight	int
:	O
case	O
CK_Word_Right_Highlight	int
:	O
case	O
CK_Up_Highlight	int
:	O
case	O
CK_Down_Highlight	int
:	O
if	O
(	O
edit	*(struct)
->	O
mark2	long
==	O
-	O
1	int
)	O
break	O
;	O
case	O
CK_Left	int
:	O
case	O
CK_Right	int
:	O
case	O
CK_Left_Highlight	int
:	O
case	O
CK_Right_Highlight	int
:	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_CHAR_ONLY	O
;	O
}	O
switch	O
(	O
command	*(char)
)	O
{	O
case	O
CK_BackSpace	int
:	O
if	O
(	O
option_backspace_through_tabs	int
&&	O
is_in_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
{	O
while	O
(	O
edit_get_byte	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs1	long
-	O
1	int
)	O
!=	O
'\n'	O
&&	O
edit	*(struct)
->	O
curs1	long
>	O
0	int
)	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
is_in_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
&&	O
right_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
HALF_TAB_SIZE	O
;	O
i	array(int)
++	O
)	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
edit_backspace	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Delete	int
:	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
int	O
i	array(int)
;	O
if	O
(	O
is_in_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
&&	O
left_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
1	int
;	O
i	array(int)
<=	O
HALF_TAB_SIZE	O
;	O
i	array(int)
++	O
)	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
}	O
}	O
edit_delete	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Delete_Word_Left	int
:	O
edit_left_delete_word	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Delete_Word_Right	int
:	O
edit_right_delete_word	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Delete_Line	int
:	O
edit_delete_line	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Delete_To_Line_End	int
:	O
edit_delete_to_line_end	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Delete_To_Line_Begin	int
:	O
edit_delete_to_line_begin	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Enter	int
:	O
if	O
(	O
option_auto_para_formatting	int
)	O
{	O
edit_double_newline	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
option_return_does_auto_indent	int
)	O
edit_auto_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
format_paragraph	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\n'	O
)	O
;	O
if	O
(	O
option_return_does_auto_indent	int
)	O
{	O
edit_auto_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CK_Return	int
:	O
edit_insert	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
CK_Page_Up	int
:	O
case	O
CK_Page_Up_Highlight	int
:	O
edit_move_up	(*(struct),long,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
num_widget_lines	int
-	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Page_Down	int
:	O
case	O
CK_Page_Down_Highlight	int
:	O
edit_move_down	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
num_widget_lines	int
-	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Left	int
:	O
case	O
CK_Left_Highlight	int
:	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
if	O
(	O
is_in_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
&&	O
right_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
{	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
-	O
HALF_TAB_SIZE	O
)	O
;	O
edit	*(struct)
->	O
force	int
&=	O
(	O
0xFFF	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
break	O
;	O
}	O
}	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Right	int
:	O
case	O
CK_Right_Highlight	int
:	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
if	O
(	O
is_in_indent	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
&&	O
left_of_four_spaces	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(int)
(	O
edit	*(struct)
)	O
)	O
{	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
HALF_TAB_SIZE	O
)	O
;	O
edit	*(struct)
->	O
force	int
&=	O
(	O
0xFFF	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
break	O
;	O
}	O
}	O
edit_cursor_move	(*(struct),long)->(int)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Begin_Page	int
:	O
case	O
CK_Begin_Page_Highlight	int
:	O
edit_begin_page	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_End_Page	int
:	O
case	O
CK_End_Page_Highlight	int
:	O
edit_end_page	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Word_Left	int
:	O
case	O
CK_Word_Left_Highlight	int
:	O
edit_left_word_move_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Word_Right	int
:	O
case	O
CK_Word_Right_Highlight	int
:	O
edit_right_word_move_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Up	int
:	O
case	O
CK_Up_Highlight	int
:	O
edit_move_up	(*(struct),long,int)->(void)
(	O
edit	*(struct)
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Down	int
:	O
case	O
CK_Down_Highlight	int
:	O
edit_move_down	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Paragraph_Up	int
:	O
case	O
CK_Paragraph_Up_Highlight	int
:	O
edit_move_up_paragraph	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Paragraph_Down	int
:	O
case	O
CK_Paragraph_Down_Highlight	int
:	O
edit_move_down_paragraph	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Scroll_Up	int
:	O
case	O
CK_Scroll_Up_Highlight	int
:	O
edit_move_up	(*(struct),long,int)->(void)
(	O
edit	*(struct)
,	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Scroll_Down	int
:	O
case	O
CK_Scroll_Down_Highlight	int
:	O
edit_move_down	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Home	int
:	O
case	O
CK_Home_Highlight	int
:	O
edit_cursor_to_bol	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_End	int
:	O
case	O
CK_End_Highlight	int
:	O
edit_cursor_to_eol	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Tab	int
:	O
edit_tab_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
option_auto_para_formatting	int
)	O
{	O
format_paragraph	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
check_and_wrap_line	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Toggle_Insert	int
:	O
edit	*(struct)
->	O
overwrite	int
=	O
(	O
edit	*(struct)
->	O
overwrite	int
==	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Mark	int
:	O
if	O
(	O
edit	*(struct)
->	O
mark2	long
>=	O
0	int
)	O
{	O
if	O
(	O
column_highlighting	int
)	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
COLUMN_ON	int
)	O
;	O
column_highlighting	int
=	O
0	int
;	O
}	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Column_Mark	int
:	O
if	O
(	O
!	O
column_highlighting	int
)	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
COLUMN_OFF	int
)	O
;	O
column_highlighting	int
=	O
1	int
;	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Unmark	int
:	O
if	O
(	O
column_highlighting	int
)	O
edit_push_action	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
COLUMN_ON	int
)	O
;	O
column_highlighting	int
=	O
0	int
;	O
edit_mark_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Toggle_Bookmark	int
:	O
book_mark_clear	(*(struct),int,int)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
,	O
BOOK_MARK_FOUND_COLOR	O
)	O
;	O
if	O
(	O
book_mark_query_color	(*(struct),int,int)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
,	O
BOOK_MARK_COLOR	O
)	O
)	O
book_mark_clear	(*(struct),int,int)->(int)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
,	O
BOOK_MARK_COLOR	O
)	O
;	O
else	O
book_mark_insert	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
,	O
BOOK_MARK_COLOR	O
)	O
;	O
break	O
;	O
case	O
CK_Flush_Bookmarks	int
:	O
book_mark_flush	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
BOOK_MARK_COLOR	O
)	O
;	O
book_mark_flush	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
BOOK_MARK_FOUND_COLOR	O
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
break	O
;	O
case	O
CK_Next_Bookmark	int
:	O
if	O
(	O
edit	*(struct)
->	O
book_mark	*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`)))))
)	O
{	O
struct	O
_book_mark	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`))))),*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`))))))
*	O
p	*(void)
;	O
p	*(void)
=	O
(	O
struct	O
_book_mark	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`))))),*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`))))))
*	O
)	O
book_mark_find	(*(struct),int)->(*(struct))
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
)	O
;	O
if	O
(	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
p	*(void)
->	O
line	int
>=	O
edit	*(struct)
->	O
start_line	long
+	O
edit	*(struct)
->	O
num_widget_lines	int
||	O
p	*(void)
->	O
line	int
<	O
edit	*(struct)
->	O
start_line	long
)	O
edit_move_display	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
p	*(void)
->	O
line	int
-	O
edit	*(struct)
->	O
num_widget_lines	int
/	O
2	int
)	O
;	O
edit_move_to_line	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
p	*(void)
->	O
line	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CK_Prev_Bookmark	int
:	O
if	O
(	O
edit	*(struct)
->	O
book_mark	*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`)))))
)	O
{	O
struct	O
_book_mark	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`))))),*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`))))))
*	O
p	*(void)
;	O
p	*(void)
=	O
(	O
struct	O
_book_mark	struct(int,int,*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`))))),*(struct(int,int,*(struct(int,int,*(struct`),*(struct`))),*(struct(int,int,*(struct`),*(struct`))))))
*	O
)	O
book_mark_find	(*(struct),int)->(*(struct))
(	O
edit	*(struct)
,	O
edit	*(struct)
->	O
curs_line	long
)	O
;	O
while	O
(	O
p	*(void)
->	O
line	int
==	O
edit	*(struct)
->	O
curs_line	long
)	O
if	O
(	O
p	*(void)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
p	*(void)
=	O
p	*(void)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
p	*(void)
->	O
line	int
>=	O
0	int
)	O
{	O
if	O
(	O
p	*(void)
->	O
line	int
>=	O
edit	*(struct)
->	O
start_line	long
+	O
edit	*(struct)
->	O
num_widget_lines	int
||	O
p	*(void)
->	O
line	int
<	O
edit	*(struct)
->	O
start_line	long
)	O
edit_move_display	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
p	*(void)
->	O
line	int
-	O
edit	*(struct)
->	O
num_widget_lines	int
/	O
2	int
)	O
;	O
edit_move_to_line	(*(struct),long)->(void)
(	O
edit	*(struct)
,	O
p	*(void)
->	O
line	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CK_Beginning_Of_Text	int
:	O
case	O
CK_Beginning_Of_Text_Highlight	int
:	O
edit_move_to_top	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_End_Of_Text	int
:	O
case	O
CK_End_Of_Text_Highlight	int
:	O
edit_move_to_bottom	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Copy	int
:	O
edit_block_copy_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Remove	int
:	O
edit_block_delete_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Move	int
:	O
edit_block_move_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_XStore	int
:	O
edit_copy_to_X_buf_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_XCut	int
:	O
edit_cut_to_X_buf_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_XPaste	int
:	O
edit_paste_from_X_buf_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Selection_History	int
:	O
edit_paste_from_history	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Save_As	int
:	O
edit_save_as_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Save	int
:	O
edit_save_confirm_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Load	int
:	O
edit_load_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Save_Block	int
:	O
edit_save_block_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Insert_File	int
:	O
edit_insert_file_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Toggle_Syntax	int
:	O
if	O
(	O
(	O
option_syntax_highlighting	int
^=	O
1	int
)	O
==	O
1	int
)	O
edit_load_syntax	(*(struct),*(*(*(char))),*(char))->(void)
(	O
edit	*(struct)
,	O
NULL	O
,	O
option_syntax_type	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
break	O
;	O
case	O
CK_Find	int
:	O
edit_search_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Find_Again	int
:	O
edit_search_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Replace	int
:	O
edit_replace_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Replace_Again	int
:	O
edit_replace_cmd	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Complete_Word	int
:	O
edit_complete_word_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Exit	int
:	O
dlg_stop	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
edit	*(struct)
->	O
widget	*(struct)
.	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
break	O
;	O
case	O
CK_New	int
:	O
edit_new_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Help	int
:	O
edit_help_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Refresh	int
:	O
edit_refresh_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Date	int
:	O
{	O
time_t	long
t	long
;	O
char	O
s	*(char)
[	O
1024	int
]	O
;	O
char	O
time_format	array(char)
[	O
]	O
=	O
"_c"	*(char)
;	O
time_format	array(char)
[	O
0	int
]	O
=	O
'%'	O
;	O
time	long
(	O
&	O
t	long
)	O
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
s	*(char)
,	O
sizeof	O
(	O
s	*(char)
)	O
,	O
time_format	array(char)
,	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
)	O
)	O
;	O
edit_print_string	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
s	*(char)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
break	O
;	O
}	O
case	O
CK_Goto	int
:	O
edit_goto_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Paragraph_Format	int
:	O
format_paragraph	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
1	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
break	O
;	O
case	O
CK_Delete_Macro	int
:	O
edit_delete_macro_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Match_Bracket	int
:	O
edit_goto_matching_bracket	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_User_Menu	int
:	O
user_menu	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Sort	int
:	O
edit_sort_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_ExtCmd	int
:	O
edit_ext_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Mail	int
:	O
edit_mail_dialog	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Shell	int
:	O
view_other_cmd	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
CK_Select_Codepage	int
:	O
edit_select_codepage_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Insert_Literal	int
:	O
edit_insert_literal_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Execute_Macro	int
:	O
edit_execute_macro_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Begin_End_Macro	int
:	O
edit_begin_end_macro_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Ext_Mode	int
:	O
edit	*(struct)
->	O
extmod	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
(	O
command	*(char)
/	O
1000	int
)	O
==	O
1	int
)	O
edit_block_process_cmd	(*(struct),*(char),int)->(void)
(	O
edit	*(struct)
,	O
shell_cmd	*(char)
[	O
command	*(char)
-	O
1000	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
command	*(char)
>	O
CK_Macro	O
(	O
0	int
)	O
&&	O
command	*(char)
<=	O
CK_Last_Macro	O
)	O
{	O
struct	O
macro	struct(short,short)
m	int
[	O
MAX_MACRO_LENGTH	int
]	O
;	O
int	O
nm	int
;	O
if	O
(	O
edit_load_macro_cmd	(*(struct),array(struct(short,short)),*(int),int)->(int)
(	O
edit	*(struct)
,	O
m	int
,	O
&	O
nm	int
,	O
command	*(char)
-	O
2000	int
)	O
)	O
edit_execute_macro	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),array(struct(short,short)),int)->(void)
(	O
edit	*(struct)
,	O
m	int
,	O
nm	int
)	O
;	O
}	O
switch	O
(	O
command	*(char)
)	O
{	O
case	O
CK_Find	int
:	O
case	O
CK_Find_Again	int
:	O
case	O
CK_Replace	int
:	O
case	O
CK_Replace_Again	int
:	O
case	O
CK_Complete_Word	int
:	O
edit	*(struct)
->	O
prev_col	long
=	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
break	O
;	O
case	O
CK_Up	int
:	O
case	O
CK_Up_Highlight	int
:	O
case	O
CK_Down	int
:	O
case	O
CK_Down_Highlight	int
:	O
case	O
CK_Page_Up	int
:	O
case	O
CK_Page_Up_Highlight	int
:	O
case	O
CK_Page_Down	int
:	O
case	O
CK_Page_Down_Highlight	int
:	O
case	O
CK_Beginning_Of_Text	int
:	O
case	O
CK_Beginning_Of_Text_Highlight	int
:	O
case	O
CK_End_Of_Text	int
:	O
case	O
CK_End_Of_Text_Highlight	int
:	O
case	O
CK_Paragraph_Up	int
:	O
case	O
CK_Paragraph_Up_Highlight	int
:	O
case	O
CK_Paragraph_Down	int
:	O
case	O
CK_Paragraph_Down_Highlight	int
:	O
case	O
CK_Scroll_Up	int
:	O
case	O
CK_Scroll_Up_Highlight	int
:	O
case	O
CK_Scroll_Down	int
:	O
case	O
CK_Scroll_Down_Highlight	int
:	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
edit	*(struct)
->	O
found_len	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
edit	*(struct)
->	O
found_len	int
=	O
0	int
;	O
edit	*(struct)
->	O
prev_col	long
=	O
edit_get_col	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
search_start	long
=	O
edit	*(struct)
->	O
curs1	long
;	O
}	O
edit_find_bracket	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
option_auto_para_formatting	int
)	O
{	O
switch	O
(	O
command	*(char)
)	O
{	O
case	O
CK_BackSpace	int
:	O
case	O
CK_Delete	int
:	O
case	O
CK_Delete_Word_Left	int
:	O
case	O
CK_Delete_Word_Right	int
:	O
case	O
CK_Delete_To_Line_End	int
:	O
case	O
CK_Delete_To_Line_Begin	int
:	O
format_paragraph	(*(struct),int)->(void)
(	O
edit	*(struct)
,	O
0	int
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
}	O
}	O
static	O
void	O
edit_execute_macro	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))),array(struct(short,short)),int)->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
struct	O
macro	struct(short,short)
macro	struct(short,short)
[	O
]	O
,	O
int	O
n	long
)	O
{	O
int	O
i	array(int)
=	O
0	int
;	O
if	O
(	O
edit	*(struct)
->	O
macro_depth	int
++	O
>	O
256	int
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	*(char)
)	O
,	O
_	O
(	O
"Macro recursion is too deep"	*(char)
)	O
)	O
;	O
edit	*(struct)
->	O
macro_depth	int
--	O
;	O
return	O
;	O
}	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
for	O
(	O
;	O
i	array(int)
<	O
n	long
;	O
i	array(int)
++	O
)	O
{	O
edit_execute_cmd	(*(struct),int,int)->(void)
(	O
edit	*(struct)
,	O
macro	struct(short,short)
[	O
i	array(int)
]	O
.	O
command	*(char)
,	O
macro	struct(short,short)
[	O
i	array(int)
]	O
.	O
ch	int
)	O
;	O
}	O
edit_update_screen	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
macro_depth	int
--	O
;	O
}	O
static	O
void	O
user_menu	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
WEdit	struct
*	O
edit	*(struct)
)	O
{	O
FILE	struct
*	O
fd	int
;	O
int	O
nomark	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
status	int
;	O
long	O
start_mark	*(long)
,	O
end_mark	*(long)
;	O
char	O
*	O
block_file	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
BLOCK_FILE	O
)	O
;	O
int	O
rc	*(int)
=	O
0	int
;	O
nomark	int
=	O
eval_marks	(*(struct),*(long),*(long))->(int)
(	O
edit	*(struct)
,	O
&	O
start_mark	*(long)
,	O
&	O
end_mark	*(long)
)	O
;	O
if	O
(	O
!	O
nomark	int
)	O
edit_save_block	(*(struct),*(char),long,long)->(int)
(	O
edit	*(struct)
,	O
block_file	*(char)
,	O
start_mark	*(long)
,	O
end_mark	*(long)
)	O
;	O
user_menu_cmd	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,*(char),*(char),long,long,array(*(char)),array(*(char)),long,int,long,long,long,long,long,long,long,int,int,int,int,int,int,int,int,long,long,long,long,long,long,int,int,long,int,array(int),array(long),*(struct(int,int,*`,*`)),long,*(long),long,long,long,int,struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),int,*(struct),*(*(struct`)),long,struct(short,char,char,char,char),*(char),*(struct),int,int,array(struct(short,short)),*(struct(long,long)),*(struct(long,long)),int,array(*(char)))))->(void)
(	O
edit	*(struct)
)	O
;	O
if	O
(	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
block_file	*(char)
,	O
&	O
status	int
)	O
!=	O
0	int
||	O
!	O
status	int
.	O
st_size	long
)	O
{	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
!	O
nomark	int
)	O
{	O
rc	*(int)
=	O
edit_block_delete_cmd	(*(struct))->(int)
(	O
edit	*(struct)
)	O
;	O
}	O
if	O
(	O
!	O
rc	*(int)
)	O
{	O
edit_insert_file	(*(struct),*(char))->(int)
(	O
edit	*(struct)
,	O
block_file	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
fd	int
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
block_file	*(char)
,	O
"w"	*(char)
)	O
)	O
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fd	int
)	O
;	O
}	O
edit_refresh_cmd	(*(struct))->(void)
(	O
edit	*(struct)
)	O
;	O
edit	*(struct)
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
cleanup	O
:	O
g_free	(*(void))->(void)
(	O
block_file	*(char)
)	O
;	O
}	O
