static	O
const	O
char	O
*	O
next_brace_sub	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
begin	*(char)
,	O
int	O
flags	int
)	O
__THROW	O
;	O
static	O
int	O
glob_in_dir	(*(char),*(char),int,*((*(char),int)->(int)),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
const	O
char	O
*	O
pattern	*(char)
,	O
const	O
char	O
*	O
directory	*(char)
,	O
int	O
flags	int
,	O
int	O
(	O
*	O
errfunc	*((*(char),int)->(int))
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
,	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
extern	O
int	O
__glob_pattern_type	(*(char),int)->(int)
(	O
const	O
char	O
*	O
pattern	*(char)
,	O
int	O
quote	int
)	O
attribute_hidden	O
;	O
static	O
int	O
prefix_array	(*(char),*(*(char)),long)->(int)
(	O
const	O
char	O
*	O
prefix	*(char)
,	O
char	O
*	O
*	O
array	*(*(char))
,	O
size_t	long
n	long
)	O
__THROW	O
;	O
static	O
int	O
collated_compare	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
__THROW	O
;	O
static	O
const	O
char	O
*	O
next_brace_sub	(*(char),int)->(*(char))
(	O
const	O
char	O
*	O
cp	*(char)
,	O
int	O
flags	int
)	O
{	O
unsigned	O
int	O
depth	int
=	O
0	int
;	O
while	O
(	O
*	O
cp	*(char)
!=	O
'\0'	O
)	O
if	O
(	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
==	O
0	int
&&	O
*	O
cp	*(char)
==	O
'\\'	O
)	O
{	O
if	O
(	O
*	O
++	O
cp	*(char)
==	O
'\0'	O
)	O
break	O
;	O
++	O
cp	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
(	O
*	O
cp	*(char)
==	O
'}'	O
&&	O
depth	int
--	O
==	O
0	int
)	O
||	O
(	O
*	O
cp	*(char)
==	O
','	O
&&	O
depth	int
==	O
0	int
)	O
)	O
break	O
;	O
if	O
(	O
*	O
cp	*(char)
++	O
==	O
'{'	O
)	O
depth	int
++	O
;	O
}	O
return	O
*	O
cp	*(char)
!=	O
'\0'	O
?	O
cp	*(char)
:	O
NULL	O
;	O
}	O
int	O
glob	O
(	O
pattern	*(char)
,	O
flags	int
,	O
errfunc	*((*(char),int)->(int))
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
const	O
char	O
*	O
restrict	O
pattern	*(char)
;	O
int	O
flags	int
;	O
int	O
(	O
*	O
errfunc	*((*(char),int)->(int))
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
*	O
restrict	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
;	O
{	O
const	O
char	O
*	O
filename	*(char)
;	O
const	O
char	O
*	O
dirname	*(char)
;	O
size_t	long
dirlen	long
;	O
int	O
status	int
;	O
size_t	long
oldcount	long
;	O
int	O
meta	int
;	O
int	O
dirname_modified	int
;	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
;	O
if	O
(	O
pattern	*(char)
==	O
NULL	O
||	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
==	O
NULL	O
||	O
(	O
flags	int
&	O
~	O
__GLOB_FLAGS	O
)	O
!=	O
0	int
)	O
{	O
__set_errno	O
(	O
EINVAL	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_DOOFFS	O
)	O
)	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
GLOB_BRACE	O
)	O
{	O
const	O
char	O
*	O
begin	*(char)
;	O
if	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
begin	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
pattern	*(char)
,	O
'{'	O
)	O
;	O
else	O
{	O
begin	*(char)
=	O
pattern	*(char)
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
*	O
begin	*(char)
==	O
'\0'	O
)	O
{	O
begin	*(char)
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
begin	*(char)
==	O
'\\'	O
&&	O
begin	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
)	O
++	O
begin	*(char)
;	O
else	O
if	O
(	O
*	O
begin	*(char)
==	O
'{'	O
)	O
break	O
;	O
++	O
begin	*(char)
;	O
}	O
}	O
if	O
(	O
begin	*(char)
!=	O
NULL	O
)	O
{	O
size_t	long
firstc	long
;	O
char	O
*	O
alt_start	*(char)
;	O
const	O
char	O
*	O
p	*(char)
;	O
const	O
char	O
*	O
next	*(char)
;	O
const	O
char	O
*	O
rest	*(char)
;	O
size_t	long
rest_len	long
;	O
char	O
onealt	O
[	O
strlen	(*(char))->(long)
(	O
pattern	*(char)
)	O
-	O
1	int
]	O
;	O
alt_start	*(char)
=	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
onealt	O
,	O
pattern	*(char)
,	O
begin	*(char)
-	O
pattern	*(char)
)	O
;	O
next	*(char)
=	O
next_brace_sub	(*(char),int)->(*(char))
(	O
begin	*(char)
+	O
1	int
,	O
flags	int
)	O
;	O
if	O
(	O
next	*(char)
==	O
NULL	O
)	O
{	O
return	O
glob	O
(	O
pattern	*(char)
,	O
flags	int
&	O
~	O
GLOB_BRACE	O
,	O
errfunc	*((*(char),int)->(int))
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
}	O
rest	*(char)
=	O
next	*(char)
;	O
while	O
(	O
*	O
rest	*(char)
!=	O
'}'	O
)	O
{	O
rest	*(char)
=	O
next_brace_sub	(*(char),int)->(*(char))
(	O
rest	*(char)
+	O
1	int
,	O
flags	int
)	O
;	O
if	O
(	O
rest	*(char)
==	O
NULL	O
)	O
{	O
return	O
glob	O
(	O
pattern	*(char)
,	O
flags	int
&	O
~	O
GLOB_BRACE	O
,	O
errfunc	*((*(char),int)->(int))
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
}	O
}	O
rest_len	long
=	O
strlen	(*(char))->(long)
(	O
++	O
rest	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_APPEND	O
)	O
)	O
{	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
=	O
NULL	O
;	O
}	O
firstc	long
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
;	O
p	*(char)
=	O
begin	*(char)
+	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
result	int
;	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
alt_start	*(char)
,	O
p	*(char)
,	O
next	*(char)
-	O
p	*(char)
)	O
,	O
rest	*(char)
,	O
rest_len	long
)	O
;	O
result	int
=	O
glob	O
(	O
onealt	O
,	O
(	O
(	O
flags	int
&	O
~	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
)	O
|	O
GLOB_APPEND	O
)	O
,	O
errfunc	*((*(char),int)->(int))
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
if	O
(	O
result	int
&&	O
result	int
!=	O
GLOB_NOMATCH	int
)	O
{	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_APPEND	O
)	O
)	O
{	O
globfree	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
}	O
return	O
result	int
;	O
}	O
if	O
(	O
*	O
next	*(char)
==	O
'}'	O
)	O
break	O
;	O
p	*(char)
=	O
next	*(char)
+	O
1	int
;	O
next	*(char)
=	O
next_brace_sub	(*(char),int)->(*(char))
(	O
p	*(char)
,	O
flags	int
)	O
;	O
assert	O
(	O
next	*(char)
!=	O
NULL	O
)	O
;	O
}	O
if	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
!=	O
firstc	long
)	O
return	O
0	int
;	O
else	O
if	O
(	O
!	O
(	O
flags	int
&	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
)	O
)	O
return	O
GLOB_NOMATCH	int
;	O
}	O
}	O
filename	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
pattern	*(char)
,	O
'/'	O
)	O
;	O
dirname_modified	int
=	O
0	int
;	O
if	O
(	O
filename	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
(	O
GLOB_TILDE	O
|	O
GLOB_TILDE_CHECK	O
)	O
)	O
&&	O
pattern	*(char)
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
dirname	*(char)
=	O
pattern	*(char)
;	O
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
pattern	*(char)
)	O
;	O
filename	*(char)
=	O
NULL	O
;	O
}	O
else	O
{	O
filename	*(char)
=	O
pattern	*(char)
;	O
dirname	*(char)
=	O
"."	*(char)
;	O
dirlen	long
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
filename	*(char)
==	O
pattern	*(char)
||	O
(	O
filename	*(char)
==	O
pattern	*(char)
+	O
1	int
&&	O
pattern	*(char)
[	O
0	int
]	O
==	O
'\\'	O
&&	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
==	O
0	int
)	O
)	O
{	O
dirname	*(char)
=	O
"/"	*(char)
;	O
dirlen	long
=	O
1	int
;	O
++	O
filename	*(char)
;	O
}	O
else	O
{	O
char	O
*	O
newp	*(char)
;	O
dirlen	long
=	O
filename	*(char)
-	O
pattern	*(char)
;	O
newp	*(char)
=	O
__alloca	O
(	O
dirlen	long
+	O
1	int
)	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
newp	*(char)
,	O
pattern	*(char)
,	O
dirlen	long
)	O
)	O
=	O
'\0'	O
;	O
dirname	*(char)
=	O
newp	*(char)
;	O
++	O
filename	*(char)
;	O
if	O
(	O
filename	*(char)
[	O
0	int
]	O
==	O
'\0'	O
&&	O
dirlen	long
>	O
1	int
)	O
{	O
int	O
orig_flags	int
=	O
flags	int
;	O
int	O
val	array(int)
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
&&	O
dirname	*(char)
[	O
dirlen	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
dirname	*(char)
[	O
dirlen	long
-	O
1	int
]	O
;	O
while	O
(	O
p	*(char)
>	O
dirname	*(char)
&&	O
p	*(char)
[	O
-	O
1	int
]	O
==	O
'\\'	O
)	O
--	O
p	*(char)
;	O
if	O
(	O
(	O
&	O
dirname	*(char)
[	O
dirlen	long
]	O
-	O
p	*(char)
)	O
&	O
1	int
)	O
{	O
*	O
(	O
char	O
*	O
)	O
&	O
dirname	*(char)
[	O
--	O
dirlen	long
]	O
=	O
'\0'	O
;	O
flags	int
&=	O
~	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
;	O
}	O
}	O
val	array(int)
=	O
glob	O
(	O
dirname	*(char)
,	O
flags	int
|	O
GLOB_MARK	O
,	O
errfunc	*((*(char),int)->(int))
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
if	O
(	O
val	array(int)
==	O
0	int
)	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_flags	int
=	O
(	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_flags	int
&	O
~	O
GLOB_MARK	O
)	O
|	O
(	O
flags	int
&	O
GLOB_MARK	O
)	O
)	O
;	O
else	O
if	O
(	O
val	array(int)
==	O
GLOB_NOMATCH	int
&&	O
flags	int
!=	O
orig_flags	int
)	O
{	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
=	O
NULL	O
;	O
flags	int
=	O
orig_flags	int
;	O
oldcount	long
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
;	O
goto	O
no_matches	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_APPEND	O
)	O
)	O
{	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_DOOFFS	O
)	O
)	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
=	O
NULL	O
;	O
else	O
{	O
size_t	long
i	long
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
=	O
malloc	(long)->(*(void))
(	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
==	O
NULL	O
)	O
return	O
GLOB_NOSPACE	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
;	O
++	O
i	long
)	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
i	long
]	O
=	O
NULL	O
;	O
}	O
}	O
oldcount	long
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
;	O
if	O
(	O
(	O
flags	int
&	O
(	O
GLOB_TILDE	O
|	O
GLOB_TILDE_CHECK	O
)	O
)	O
&&	O
dirname	*(char)
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
if	O
(	O
dirname	*(char)
[	O
1	int
]	O
==	O
'\0'	O
||	O
dirname	*(char)
[	O
1	int
]	O
==	O
'/'	O
||	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
&&	O
dirname	*(char)
[	O
1	int
]	O
==	O
'\\'	O
&&	O
(	O
dirname	*(char)
[	O
2	int
]	O
==	O
'\0'	O
||	O
dirname	*(char)
[	O
2	int
]	O
==	O
'/'	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
home_dir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
home_dir	*(char)
==	O
NULL	O
||	O
home_dir	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
int	O
success	int
;	O
char	O
*	O
name	*(char)
;	O
size_t	long
buflen	long
=	O
GET_LOGIN_NAME_MAX	O
(	O
)	O
+	O
1	int
;	O
if	O
(	O
buflen	long
==	O
0	int
)	O
buflen	long
=	O
20	int
;	O
name	*(char)
=	O
__alloca	O
(	O
buflen	long
)	O
;	O
success	int
=	O
getlogin_r	(*(char),long)->(int)
(	O
name	*(char)
,	O
buflen	long
)	O
==	O
0	int
;	O
if	O
(	O
success	int
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
p	*(char)
;	O
long	O
int	O
pwbuflen	long
=	O
GETPW_R_SIZE_MAX	O
(	O
)	O
;	O
char	O
*	O
pwtmpbuf	*(char)
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
pwbuf	struct(*(char),*(char),int,int,*(char),*(char),*(char))
;	O
int	O
save	int
=	O
errno	O
;	O
if	O
(	O
pwbuflen	long
==	O
-	O
1	int
)	O
pwbuflen	long
=	O
1024	int
;	O
pwtmpbuf	*(char)
=	O
__alloca	O
(	O
pwbuflen	long
)	O
;	O
while	O
(	O
getpwnam_r	(*(char),*(struct(*(char),*(char),int,int,*(char),*(char),*(char))),*(char),long,*(*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))))->(int)
(	O
name	*(char)
,	O
&	O
pwbuf	struct(*(char),*(char),int,int,*(char),*(char),*(char))
,	O
pwtmpbuf	*(char)
,	O
pwbuflen	long
,	O
&	O
p	*(char)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ERANGE	int
)	O
{	O
p	*(char)
=	O
NULL	O
;	O
break	O
;	O
}	O
pwbuflen	long
*=	O
2	int
;	O
pwtmpbuf	*(char)
=	O
__alloca	O
(	O
pwbuflen	long
)	O
;	O
__set_errno	O
(	O
save	int
)	O
;	O
}	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
home_dir	*(char)
=	O
p	*(char)
->	O
pw_dir	*(char)
;	O
}	O
}	O
if	O
(	O
home_dir	*(char)
==	O
NULL	O
||	O
home_dir	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
flags	int
&	O
GLOB_TILDE_CHECK	O
)	O
return	O
GLOB_NOMATCH	int
;	O
else	O
home_dir	*(char)
=	O
"~"	*(char)
;	O
}	O
if	O
(	O
dirname	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
dirname	*(char)
=	O
home_dir	*(char)
;	O
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
;	O
}	O
else	O
{	O
char	O
*	O
newp	*(char)
;	O
size_t	long
home_len	long
=	O
strlen	(*(char))->(long)
(	O
home_dir	*(char)
)	O
;	O
newp	*(char)
=	O
__alloca	O
(	O
home_len	long
+	O
dirlen	long
)	O
;	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
newp	*(char)
,	O
home_dir	*(char)
,	O
home_len	long
)	O
,	O
&	O
dirname	*(char)
[	O
1	int
]	O
,	O
dirlen	long
)	O
;	O
dirname	*(char)
=	O
newp	*(char)
;	O
dirlen	long
+=	O
home_len	long
-	O
1	int
;	O
}	O
dirname_modified	int
=	O
1	int
;	O
}	O
else	O
{	O
char	O
*	O
end_name	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
dirname	*(char)
,	O
'/'	O
)	O
;	O
const	O
char	O
*	O
user_name	*(char)
;	O
const	O
char	O
*	O
home_dir	*(char)
;	O
char	O
*	O
unescape	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
)	O
{	O
if	O
(	O
end_name	*(char)
==	O
NULL	O
)	O
{	O
unescape	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
dirname	*(char)
,	O
'\\'	O
)	O
;	O
if	O
(	O
unescape	*(char)
)	O
end_name	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
unescape	*(char)
,	O
'\0'	O
)	O
;	O
}	O
else	O
unescape	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
dirname	*(char)
,	O
'\\'	O
,	O
end_name	*(char)
-	O
dirname	*(char)
)	O
;	O
}	O
if	O
(	O
end_name	*(char)
==	O
NULL	O
)	O
user_name	*(char)
=	O
dirname	*(char)
+	O
1	int
;	O
else	O
{	O
char	O
*	O
newp	*(char)
;	O
newp	*(char)
=	O
__alloca	O
(	O
end_name	*(char)
-	O
dirname	*(char)
)	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
newp	*(char)
,	O
dirname	*(char)
+	O
1	int
,	O
end_name	*(char)
-	O
dirname	*(char)
)	O
)	O
=	O
'\0'	O
;	O
if	O
(	O
unescape	*(char)
!=	O
NULL	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
newp	*(char)
,	O
dirname	*(char)
+	O
1	int
,	O
unescape	*(char)
-	O
dirname	*(char)
-	O
1	int
)	O
;	O
char	O
*	O
q	*(char)
=	O
unescape	*(char)
;	O
while	O
(	O
*	O
q	*(char)
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
q	*(char)
==	O
'\\'	O
)	O
{	O
if	O
(	O
q	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
filename	*(char)
==	O
NULL	O
)	O
*	O
p	*(char)
++	O
=	O
'\\'	O
;	O
break	O
;	O
}	O
++	O
q	*(char)
;	O
}	O
*	O
p	*(char)
++	O
=	O
*	O
q	*(char)
++	O
;	O
}	O
*	O
p	*(char)
=	O
'\0'	O
;	O
}	O
else	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
newp	*(char)
,	O
dirname	*(char)
+	O
1	int
,	O
end_name	*(char)
-	O
dirname	*(char)
)	O
)	O
=	O
'\0'	O
;	O
user_name	*(char)
=	O
newp	*(char)
;	O
}	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
p	*(char)
;	O
long	O
int	O
buflen	long
=	O
GETPW_R_SIZE_MAX	O
(	O
)	O
;	O
char	O
*	O
pwtmpbuf	*(char)
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
pwbuf	struct(*(char),*(char),int,int,*(char),*(char),*(char))
;	O
int	O
save	int
=	O
errno	O
;	O
if	O
(	O
buflen	long
==	O
-	O
1	int
)	O
buflen	long
=	O
1024	int
;	O
pwtmpbuf	*(char)
=	O
__alloca	O
(	O
buflen	long
)	O
;	O
while	O
(	O
getpwnam_r	(*(char),*(struct(*(char),*(char),int,int,*(char),*(char),*(char))),*(char),long,*(*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))))->(int)
(	O
user_name	*(char)
,	O
&	O
pwbuf	struct(*(char),*(char),int,int,*(char),*(char),*(char))
,	O
pwtmpbuf	*(char)
,	O
buflen	long
,	O
&	O
p	*(char)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ERANGE	int
)	O
{	O
p	*(char)
=	O
NULL	O
;	O
break	O
;	O
}	O
buflen	long
*=	O
2	int
;	O
pwtmpbuf	*(char)
=	O
__alloca	O
(	O
buflen	long
)	O
;	O
__set_errno	O
(	O
save	int
)	O
;	O
}	O
if	O
(	O
p	*(char)
!=	O
NULL	O
)	O
home_dir	*(char)
=	O
p	*(char)
->	O
pw_dir	*(char)
;	O
else	O
home_dir	*(char)
=	O
NULL	O
;	O
}	O
if	O
(	O
home_dir	*(char)
!=	O
NULL	O
)	O
{	O
char	O
*	O
newp	*(char)
;	O
size_t	long
home_len	long
=	O
strlen	(*(char))->(long)
(	O
home_dir	*(char)
)	O
;	O
size_t	long
rest_len	long
=	O
end_name	*(char)
==	O
NULL	O
?	O
0	int
:	O
strlen	(*(char))->(long)
(	O
end_name	*(char)
)	O
;	O
newp	*(char)
=	O
__alloca	O
(	O
home_len	long
+	O
rest_len	long
+	O
1	int
)	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
newp	*(char)
,	O
home_dir	*(char)
,	O
home_len	long
)	O
,	O
end_name	*(char)
,	O
rest_len	long
)	O
)	O
=	O
'\0'	O
;	O
dirname	*(char)
=	O
newp	*(char)
;	O
dirlen	long
=	O
home_len	long
+	O
rest_len	long
;	O
dirname_modified	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
flags	int
&	O
GLOB_TILDE_CHECK	O
)	O
return	O
GLOB_NOMATCH	int
;	O
}	O
}	O
if	O
(	O
filename	*(char)
==	O
NULL	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
struct_stat64	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
(	O
flags	int
&	O
GLOB_NOCHECK	O
)	O
||	O
(	O
(	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
)	O
?	O
(	O
(	O
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_stat	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int))
)	O
(	O
dirname	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
:	O
(	O
__stat64	O
(	O
dirname	*(char)
,	O
&	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
)	O
)	O
)	O
{	O
int	O
newcount	int
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
;	O
char	O
*	O
*	O
new_gl_pathv	*(*(char))
;	O
new_gl_pathv	*(*(char))
=	O
realloc	(*(void),long)->(*(void))
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
,	O
(	O
newcount	int
+	O
1	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
new_gl_pathv	*(*(char))
==	O
NULL	O
)	O
{	O
nospace	O
:	O
free	(*(void))->(void)
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
=	O
NULL	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
=	O
new_gl_pathv	*(*(char))
;	O
if	O
(	O
flags	int
&	O
GLOB_MARK	O
)	O
{	O
char	O
*	O
p	*(char)
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
newcount	int
]	O
=	O
malloc	(long)->(*(void))
(	O
dirlen	long
+	O
2	int
)	O
;	O
if	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
newcount	int
]	O
==	O
NULL	O
)	O
goto	O
nospace	O
;	O
p	*(char)
=	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
newcount	int
]	O
,	O
dirname	*(char)
,	O
dirlen	long
)	O
;	O
p	*(char)
[	O
0	int
]	O
=	O
'/'	O
;	O
p	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
newcount	int
]	O
=	O
strdup	(*(char))->(*(char))
(	O
dirname	*(char)
)	O
;	O
if	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
newcount	int
]	O
==	O
NULL	O
)	O
goto	O
nospace	O
;	O
}	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
++	O
newcount	int
]	O
=	O
NULL	O
;	O
++	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_flags	int
=	O
flags	int
;	O
return	O
0	int
;	O
}	O
return	O
GLOB_NOMATCH	int
;	O
}	O
meta	int
=	O
__glob_pattern_type	(*(char),int)->(int)
(	O
dirname	*(char)
,	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
)	O
;	O
if	O
(	O
meta	int
&	O
5	int
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
&&	O
dirlen	long
>	O
0	int
&&	O
dirname	*(char)
[	O
dirlen	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
dirname	*(char)
[	O
dirlen	long
-	O
1	int
]	O
;	O
while	O
(	O
p	*(char)
>	O
dirname	*(char)
&&	O
p	*(char)
[	O
-	O
1	int
]	O
==	O
'\\'	O
)	O
--	O
p	*(char)
;	O
if	O
(	O
(	O
&	O
dirname	*(char)
[	O
dirlen	long
]	O
-	O
p	*(char)
)	O
&	O
1	int
)	O
*	O
(	O
char	O
*	O
)	O
&	O
dirname	*(char)
[	O
--	O
dirlen	long
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
__builtin_expect	O
(	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
)	O
!=	O
0	int
,	O
0	int
)	O
)	O
{	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_opendir	*((*(char))->(*(void)))
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_opendir	*((*(char))->(*(void)))
;	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_readdir	*((*(void))->(*(struct)))
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_readdir	*((*(void))->(*(struct)))
;	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_closedir	*((*(void))->(void))
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_closedir	*((*(void))->(void))
;	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_stat	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int))
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_stat	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int))
;	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_lstat	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int))
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_lstat	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int))
;	O
}	O
status	int
=	O
glob	O
(	O
dirname	*(char)
,	O
(	O
(	O
flags	int
&	O
(	O
GLOB_ERR	O
|	O
GLOB_NOESCAPE	O
|	O
GLOB_ALTDIRFUNC	O
)	O
)	O
|	O
GLOB_NOSORT	O
|	O
GLOB_ONLYDIR	O
)	O
,	O
errfunc	*((*(char),int)->(int))
,	O
&	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
GLOB_NOCHECK	O
)	O
==	O
0	int
||	O
status	int
!=	O
GLOB_NOMATCH	int
)	O
return	O
status	int
;	O
goto	O
no_matches	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
;	O
++	O
i	long
)	O
{	O
int	O
old_pathc	int
;	O
old_pathc	int
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
;	O
status	int
=	O
glob_in_dir	(*(char),*(char),int,*((*(char),int)->(int)),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
filename	*(char)
,	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
[	O
i	long
]	O
,	O
(	O
(	O
flags	int
|	O
GLOB_APPEND	O
)	O
&	O
~	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
)	O
,	O
errfunc	*((*(char),int)->(int))
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
if	O
(	O
status	int
==	O
GLOB_NOMATCH	int
)	O
continue	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
globfree	O
(	O
&	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
globfree	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
status	int
;	O
}	O
if	O
(	O
prefix_array	(*(char),*(*(char)),long)->(int)
(	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
[	O
i	long
]	O
,	O
&	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
old_pathc	int
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
]	O
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
-	O
old_pathc	int
)	O
)	O
{	O
globfree	O
(	O
&	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
globfree	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
}	O
flags	int
|=	O
GLOB_MAGCHAR	O
;	O
if	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
==	O
oldcount	long
)	O
{	O
no_matches	O
:	O
if	O
(	O
flags	int
&	O
GLOB_NOCHECK	O
)	O
{	O
int	O
newcount	int
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
;	O
char	O
*	O
*	O
new_gl_pathv	*(*(char))
;	O
new_gl_pathv	*(*(char))
=	O
realloc	(*(void),long)->(*(void))
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
,	O
(	O
newcount	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
new_gl_pathv	*(*(char))
==	O
NULL	O
)	O
{	O
globfree	O
(	O
&	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
=	O
new_gl_pathv	*(*(char))
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
newcount	int
]	O
=	O
strdup	(*(char))->(*(char))
(	O
pattern	*(char)
)	O
;	O
if	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
newcount	int
]	O
==	O
NULL	O
)	O
{	O
globfree	O
(	O
&	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
globfree	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
++	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
;	O
++	O
newcount	int
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
newcount	int
]	O
=	O
NULL	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_flags	int
=	O
flags	int
;	O
}	O
else	O
{	O
globfree	O
(	O
&	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
return	O
GLOB_NOMATCH	int
;	O
}	O
}	O
globfree	O
(	O
&	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
}	O
else	O
{	O
int	O
old_pathc	int
=	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
;	O
int	O
orig_flags	int
=	O
flags	int
;	O
if	O
(	O
meta	int
&	O
2	int
)	O
{	O
char	O
*	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
dirname	*(char)
,	O
'\\'	O
)	O
,	O
*	O
q	*(char)
;	O
q	*(char)
=	O
p	*(char)
;	O
do	O
{	O
if	O
(	O
*	O
p	*(char)
==	O
'\\'	O
)	O
{	O
*	O
q	*(char)
=	O
*	O
++	O
p	*(char)
;	O
--	O
dirlen	long
;	O
}	O
else	O
*	O
q	*(char)
=	O
*	O
p	*(char)
;	O
++	O
q	*(char)
;	O
}	O
while	O
(	O
*	O
p	*(char)
++	O
!=	O
'\0'	O
)	O
;	O
dirname_modified	int
=	O
1	int
;	O
}	O
if	O
(	O
dirname_modified	int
)	O
flags	int
&=	O
~	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
;	O
status	int
=	O
glob_in_dir	(*(char),*(char),int,*((*(char),int)->(int)),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
filename	*(char)
,	O
dirname	*(char)
,	O
flags	int
,	O
errfunc	*((*(char),int)->(int))
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
if	O
(	O
status	int
==	O
GLOB_NOMATCH	int
&&	O
flags	int
!=	O
orig_flags	int
&&	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
==	O
oldcount	long
)	O
{	O
dirs	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
=	O
NULL	O
;	O
flags	int
=	O
orig_flags	int
;	O
goto	O
no_matches	O
;	O
}	O
return	O
status	int
;	O
}	O
if	O
(	O
dirlen	long
>	O
0	int
)	O
{	O
if	O
(	O
prefix_array	(*(char),*(*(char)),long)->(int)
(	O
dirname	*(char)
,	O
&	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
old_pathc	int
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
]	O
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
-	O
old_pathc	int
)	O
)	O
{	O
globfree	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
}	O
}	O
if	O
(	O
flags	int
&	O
GLOB_MARK	O
)	O
{	O
size_t	long
i	long
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
struct_stat64	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
for	O
(	O
i	long
=	O
oldcount	long
;	O
i	long
<	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
;	O
++	O
i	long
)	O
if	O
(	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
(	O
(	O
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_stat	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int))
)	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
i	long
]	O
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
:	O
(	O
__stat64	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
i	long
]	O
,	O
&	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
)	O
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
i	long
]	O
)	O
+	O
2	int
;	O
char	O
*	O
new	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
i	long
]	O
,	O
len	long
)	O
;	O
if	O
(	O
new	*(char)
==	O
NULL	O
)	O
{	O
globfree	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
&	O
new	*(char)
[	O
len	long
-	O
2	int
]	O
,	O
"/"	*(char)
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
i	long
]	O
=	O
new	*(char)
;	O
}	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOSORT	O
)	O
)	O
{	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
&	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
oldcount	long
]	O
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
-	O
oldcount	long
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
collated_compare	(*(void),*(void))->(int)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
globfree	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
register	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
;	O
{	O
if	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
!=	O
NULL	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
;	O
++	O
i	long
)	O
if	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
+	O
i	long
]	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
+	O
i	long
]	O
)	O
;	O
free	(*(void))->(void)
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
)	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
collated_compare	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(void)
,	O
const	O
void	O
*	O
b	*(void)
)	O
{	O
char	O
*	O
const	O
*	O
ps1	*(*(char))
=	O
a	*(void)
;	O
char	O
*	O
s1	*(char)
=	O
*	O
ps1	*(*(char))
;	O
char	O
*	O
const	O
*	O
ps2	*(*(char))
=	O
b	*(void)
;	O
char	O
*	O
s2	*(char)
=	O
*	O
ps2	*(*(char))
;	O
if	O
(	O
s1	*(char)
==	O
s2	*(char)
)	O
return	O
0	int
;	O
if	O
(	O
s1	*(char)
==	O
NULL	O
)	O
return	O
1	int
;	O
if	O
(	O
s2	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
strcoll	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
s2	*(char)
)	O
;	O
}	O
static	O
int	O
prefix_array	(*(char),*(*(char)),long)->(int)
(	O
const	O
char	O
*	O
dirname	*(char)
,	O
char	O
*	O
*	O
array	*(*(char))
,	O
size_t	long
n	long
)	O
{	O
register	O
size_t	long
i	long
;	O
size_t	long
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
;	O
if	O
(	O
dirlen	long
==	O
1	int
&&	O
dirname	*(char)
[	O
0	int
]	O
==	O
'/'	O
)	O
dirlen	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
++	O
i	long
)	O
{	O
size_t	long
eltlen	long
=	O
strlen	(*(char))->(long)
(	O
array	*(*(char))
[	O
i	long
]	O
)	O
+	O
1	int
;	O
char	O
*	O
new	*(char)
=	O
malloc	(long)->(*(void))
(	O
dirlen	long
+	O
1	int
+	O
eltlen	long
)	O
;	O
if	O
(	O
new	*(char)
==	O
NULL	O
)	O
{	O
while	O
(	O
i	long
>	O
0	int
)	O
free	(*(void))->(void)
(	O
array	*(*(char))
[	O
--	O
i	long
]	O
)	O
;	O
return	O
1	int
;	O
}	O
{	O
char	O
*	O
endp	*(char)
=	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
new	*(char)
,	O
dirname	*(char)
,	O
dirlen	long
)	O
;	O
*	O
endp	*(char)
++	O
=	O
DIRSEP_CHAR	char
;	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
endp	*(char)
,	O
array	*(*(char))
[	O
i	long
]	O
,	O
eltlen	long
)	O
;	O
}	O
free	(*(void))->(void)
(	O
array	*(*(char))
[	O
i	long
]	O
)	O
;	O
array	*(*(char))
[	O
i	long
]	O
=	O
new	*(char)
;	O
}	O
return	O
0	int
;	O
}	O
int	O
__glob_pattern_type	(*(char),int)->(int)
(	O
pattern	*(char)
,	O
quote	int
)	O
const	O
char	O
*	O
pattern	*(char)
;	O
int	O
quote	int
;	O
{	O
register	O
const	O
char	O
*	O
p	*(char)
;	O
int	O
ret	int
=	O
0	int
;	O
for	O
(	O
p	*(char)
=	O
pattern	*(char)
;	O
*	O
p	*(char)
!=	O
'\0'	O
;	O
++	O
p	*(char)
)	O
switch	O
(	O
*	O
p	*(char)
)	O
{	O
case	O
'?'	O
:	O
case	O
'*'	O
:	O
return	O
1	int
;	O
case	O
'\\'	O
:	O
if	O
(	O
quote	int
)	O
{	O
if	O
(	O
p	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
)	O
++	O
p	*(char)
;	O
ret	int
|=	O
2	int
;	O
}	O
break	O
;	O
case	O
'['	O
:	O
ret	int
|=	O
4	int
;	O
break	O
;	O
case	O
']'	O
:	O
if	O
(	O
ret	int
&	O
4	int
)	O
return	O
1	int
;	O
break	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
__glob_pattern_p	O
(	O
pattern	*(char)
,	O
quote	int
)	O
const	O
char	O
*	O
pattern	*(char)
;	O
int	O
quote	int
;	O
{	O
return	O
__glob_pattern_type	(*(char),int)->(int)
(	O
pattern	*(char)
,	O
quote	int
)	O
==	O
1	int
;	O
}	O
static	O
int	O
__attribute_noinline__	O
link_exists2_p	(*(char),long,*(char),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
const	O
char	O
*	O
dir	*(char)
,	O
size_t	long
dirlen	long
,	O
const	O
char	O
*	O
fname	*(char)
,	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
{	O
size_t	long
fnamelen	long
=	O
strlen	(*(char))->(long)
(	O
fname	*(char)
)	O
;	O
char	O
*	O
fullname	*(char)
=	O
__alloca	O
(	O
dirlen	long
+	O
1	int
+	O
fnamelen	long
+	O
1	int
)	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
fullname	*(char)
,	O
dir	*(char)
,	O
dirlen	long
)	O
,	O
"/"	*(char)
,	O
1	int
)	O
,	O
fname	*(char)
,	O
fnamelen	long
+	O
1	int
)	O
;	O
return	O
(	O
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_stat	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int))
)	O
(	O
fullname	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
;	O
}	O
static	O
int	O
link_exists_p	(int,*(char),long,*(char),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))),int)->(int)
(	O
int	O
dfd	int
,	O
const	O
char	O
*	O
dir	*(char)
,	O
size_t	long
dirlen	long
,	O
const	O
char	O
*	O
fname	*(char)
,	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
,	O
int	O
flags	int
)	O
{	O
if	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
)	O
return	O
link_exists2_p	(*(char),long,*(char),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
dir	*(char)
,	O
dirlen	long
,	O
fname	*(char)
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
;	O
else	O
{	O
struct_stat64	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
return	O
__fxstatat64	(int,int,*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),int)->(int)
(	O
_STAT_VER	O
,	O
dfd	int
,	O
fname	*(char)
,	O
&	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
0	int
)	O
==	O
0	int
;	O
}	O
}	O
static	O
int	O
glob_in_dir	(*(char),*(char),int,*((*(char),int)->(int)),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))))->(int)
(	O
const	O
char	O
*	O
pattern	*(char)
,	O
const	O
char	O
*	O
directory	*(char)
,	O
int	O
flags	int
,	O
int	O
(	O
*	O
errfunc	*((*(char),int)->(int))
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
,	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
)	O
{	O
size_t	long
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
directory	*(char)
)	O
;	O
void	O
*	O
stream	*(void)
=	O
NULL	O
;	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
{	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
*	O
next	*(char)
;	O
size_t	long
count	long
;	O
char	O
*	O
name	*(char)
[	O
64	int
]	O
;	O
}	O
;	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
init_names	struct(*(struct(*(struct(*`,long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
;	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
*	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
&	O
init_names	struct(*(struct(*(struct(*`,long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
;	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
*	O
names_alloca	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
&	O
init_names	struct(*(struct(*(struct(*`,long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
;	O
size_t	long
nfound	long
=	O
0	int
;	O
size_t	long
allocasize	long
=	O
sizeof	O
(	O
init_names	struct(*(struct(*(struct(*`,long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
)	O
;	O
size_t	long
cur	long
=	O
0	int
;	O
int	O
meta	int
;	O
int	O
save	int
;	O
int	O
result	int
;	O
init_names	struct(*(struct(*(struct(*`,long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
.	O
next	*(char)
=	O
NULL	O
;	O
init_names	struct(*(struct(*(struct(*`,long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
.	O
count	long
=	O
INITIAL_COUNT	O
;	O
meta	int
=	O
__glob_pattern_type	(*(char),int)->(int)
(	O
pattern	*(char)
,	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
)	O
;	O
if	O
(	O
meta	int
==	O
0	int
&&	O
(	O
flags	int
&	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
)	O
)	O
{	O
flags	int
|=	O
GLOB_NOCHECK	O
;	O
}	O
else	O
if	O
(	O
meta	int
==	O
0	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
struct_stat64	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
size_t	long
patlen	long
=	O
strlen	(*(char))->(long)
(	O
pattern	*(char)
)	O
;	O
char	O
*	O
fullname	*(char)
=	O
__alloca	O
(	O
dirlen	long
+	O
1	int
+	O
patlen	long
+	O
1	int
)	O
;	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
fullname	*(char)
,	O
directory	*(char)
,	O
dirlen	long
)	O
,	O
"/"	*(char)
,	O
1	int
)	O
,	O
pattern	*(char)
,	O
patlen	long
+	O
1	int
)	O
;	O
if	O
(	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
(	O
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_stat	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int))
)	O
(	O
fullname	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
:	O
__stat64	O
(	O
fullname	*(char)
,	O
&	O
st64	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
==	O
0	int
)	O
flags	int
|=	O
GLOB_NOCHECK	O
;	O
}	O
else	O
{	O
stream	*(void)
=	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
(	O
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_opendir	*((*(char))->(*(void)))
)	O
(	O
directory	*(char)
)	O
:	O
opendir	(*(char))->(*(struct))
(	O
directory	*(char)
)	O
)	O
;	O
if	O
(	O
stream	*(void)
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOTDIR	int
&&	O
(	O
(	O
errfunc	*((*(char),int)->(int))
!=	O
NULL	O
&&	O
(	O
*	O
errfunc	*((*(char),int)->(int))
)	O
(	O
directory	*(char)
,	O
errno	O
)	O
)	O
||	O
(	O
flags	int
&	O
GLOB_ERR	O
)	O
)	O
)	O
return	O
GLOB_ABORTED	int
;	O
}	O
else	O
{	O
int	O
dfd	int
=	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
-	O
1	int
:	O
dirfd	(*(struct))->(int)
(	O
(	O
DIR	struct
*	O
)	O
stream	*(void)
)	O
)	O
;	O
int	O
fnm_flags	int
=	O
(	O
(	O
!	O
(	O
flags	int
&	O
GLOB_PERIOD	O
)	O
?	O
FNM_PERIOD	O
:	O
0	int
)	O
|	O
(	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
?	O
FNM_NOESCAPE	O
:	O
0	int
)	O
)	O
;	O
flags	int
|=	O
GLOB_MAGCHAR	O
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
size_t	long
len	long
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
d	*(struct(long,long,short,char,array(char)))
=	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
(	O
(	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
)	O
(	O
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_readdir	*((*(void))->(*(struct)))
)	O
(	O
stream	*(void)
)	O
)	O
:	O
__readdir	O
(	O
stream	*(void)
)	O
)	O
;	O
if	O
(	O
d	*(struct(long,long,short,char,array(char)))
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
!	O
REAL_DIR_ENTRY	O
(	O
d	*(struct(long,long,short,char,array(char)))
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
flags	int
&	O
GLOB_ONLYDIR	O
)	O
&&	O
!	O
DIRENT_MIGHT_BE_DIR	O
(	O
d	*(struct(long,long,short,char,array(char)))
)	O
)	O
continue	O
;	O
name	*(char)
=	O
d	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
;	O
if	O
(	O
fnmatch	(*(char),*(char),int)->(int)
(	O
pattern	*(char)
,	O
name	*(char)
,	O
fnm_flags	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
DIRENT_MIGHT_BE_SYMLINK	O
(	O
d	*(struct(long,long,short,char,array(char)))
)	O
||	O
link_exists_p	(int,*(char),long,*(char),*(struct(long,*(*(char)),long,int,*((*`)->(void)),*((*`)->(*`)),*((*`)->(*`)),*((*`,*`)->(int)),*((*`,*`)->(int)))),int)->(int)
(	O
dfd	int
,	O
directory	*(char)
,	O
dirlen	long
,	O
name	*(char)
,	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
,	O
flags	int
)	O
)	O
{	O
if	O
(	O
cur	long
==	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
count	long
)	O
{	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
*	O
newnames	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
;	O
size_t	long
count	long
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
count	long
*	O
2	int
;	O
size_t	long
size	long
=	O
(	O
sizeof	O
(	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
)	O
+	O
(	O
(	O
count	long
-	O
INITIAL_COUNT	O
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
;	O
allocasize	long
+=	O
size	long
;	O
if	O
(	O
__libc_use_alloca	O
(	O
allocasize	long
)	O
)	O
newnames	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
names_alloca	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
__alloca	O
(	O
size	long
)	O
;	O
else	O
if	O
(	O
(	O
newnames	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
)	O
==	O
NULL	O
)	O
goto	O
memory_error	O
;	O
newnames	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
count	long
=	O
count	long
;	O
newnames	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
next	*(char)
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
;	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
newnames	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
;	O
cur	long
=	O
0	int
;	O
}	O
len	long
=	O
_D_EXACT_NAMLEN	O
(	O
d	*(struct(long,long,short,char,array(char)))
)	O
;	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
name	*(char)
[	O
cur	long
]	O
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
name	*(char)
[	O
cur	long
]	O
==	O
NULL	O
)	O
goto	O
memory_error	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
name	*(char)
[	O
cur	long
++	O
]	O
,	O
name	*(char)
,	O
len	long
)	O
)	O
=	O
'\0'	O
;	O
++	O
nfound	long
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
nfound	long
==	O
0	int
&&	O
(	O
flags	int
&	O
GLOB_NOCHECK	O
)	O
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
pattern	*(char)
)	O
;	O
nfound	long
=	O
1	int
;	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
name	*(char)
[	O
cur	long
]	O
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
name	*(char)
[	O
cur	long
]	O
==	O
NULL	O
)	O
goto	O
memory_error	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	(*(void),*(void),long)->(*(void))
(	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
name	*(char)
[	O
cur	long
++	O
]	O
,	O
pattern	*(char)
,	O
len	long
)	O
)	O
=	O
'\0'	O
;	O
}	O
result	int
=	O
GLOB_NOMATCH	int
;	O
if	O
(	O
nfound	long
!=	O
0	int
)	O
{	O
char	O
*	O
*	O
new_gl_pathv	*(*(char))
=	O
realloc	(*(void),long)->(*(void))
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
,	O
(	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
+	O
nfound	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
result	int
=	O
0	int
;	O
if	O
(	O
new_gl_pathv	*(*(char))
==	O
NULL	O
)	O
{	O
memory_error	O
:	O
while	O
(	O
1	int
)	O
{	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
*	O
old	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cur	long
;	O
++	O
i	long
)	O
free	(*(void))->(void)
(	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
name	*(char)
[	O
i	long
]	O
)	O
;	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
next	*(char)
;	O
if	O
(	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
==	O
NULL	O
)	O
{	O
assert	O
(	O
old	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
==	O
&	O
init_names	struct(*(struct(*(struct(*`,long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
)	O
;	O
break	O
;	O
}	O
cur	long
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
count	long
;	O
if	O
(	O
old	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
==	O
names_alloca	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
)	O
names_alloca	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
;	O
else	O
free	(*(void))->(void)
(	O
old	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
)	O
;	O
}	O
result	int
=	O
GLOB_NOSPACE	int
;	O
}	O
else	O
{	O
while	O
(	O
1	int
)	O
{	O
struct	O
globnames	struct(*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
*	O
old	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cur	long
;	O
++	O
i	long
)	O
new_gl_pathv	*(*(char))
[	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
++	O
]	O
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
name	*(char)
[	O
i	long
]	O
;	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
next	*(char)
;	O
if	O
(	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
==	O
NULL	O
)	O
{	O
assert	O
(	O
old	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
==	O
&	O
init_names	struct(*(struct(*(struct(*`,long,array(*(char)))),long,array(*(char)))),long,array(*(char)))
)	O
;	O
break	O
;	O
}	O
cur	long
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
->	O
count	long
;	O
if	O
(	O
old	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
==	O
names_alloca	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
)	O
names_alloca	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
=	O
names	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
;	O
else	O
free	(*(void))->(void)
(	O
old	*(struct(*(struct(*(struct`),long,array(*(char)))),long,array(*(char))))
)	O
;	O
}	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
=	O
new_gl_pathv	*(*(char))
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathv	*(*(char))
[	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_offs	long
+	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_pathc	long
]	O
=	O
NULL	O
;	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_flags	int
=	O
flags	int
;	O
}	O
}	O
if	O
(	O
stream	*(void)
!=	O
NULL	O
)	O
{	O
save	int
=	O
errno	O
;	O
if	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
)	O
(	O
*	O
pglob	*(struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct`))),*((*(char))->(*(void))),*((*(char),*(struct`))->(int)),*((*(char),*(struct`))->(int))))
->	O
gl_closedir	*((*(void))->(void))
)	O
(	O
stream	*(void)
)	O
;	O
else	O
closedir	(*(struct))->(int)
(	O
stream	*(void)
)	O
;	O
__set_errno	O
(	O
save	int
)	O
;	O
}	O
return	O
result	int
;	O
}	O
