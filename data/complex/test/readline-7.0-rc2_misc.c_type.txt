static	O
int	O
rl_digit_loop	()->(int)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
_rl_history_set_point	()->(void)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
void	O
_rl_free_history_entry	(*(struct(*(char),*(char),*(void))))->(void)
PARAMS	O
(	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
)	O
;	O
int	O
_rl_history_preserve_point	int
=	O
0	int
;	O
_rl_arg_cxt	int
_rl_argcxt	int
;	O
int	O
_rl_history_saved_point	int
=	O
-	O
1	int
;	O
int	O
_rl_arg_overflow	()->(int)
(	O
)	O
{	O
if	O
(	O
rl_numeric_arg	int
>	O
1000000	int
)	O
{	O
_rl_argcxt	int
=	O
0	int
;	O
rl_explicit_arg	int
=	O
rl_numeric_arg	int
=	O
0	int
;	O
rl_ding	()->(int)
(	O
)	O
;	O
rl_restore_prompt	()->(void)
(	O
)	O
;	O
rl_clear_message	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
_rl_arg_init	()->(void)
(	O
)	O
{	O
rl_save_prompt	()->(void)
(	O
)	O
;	O
_rl_argcxt	int
=	O
0	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
}	O
int	O
_rl_arg_getchar	()->(int)
(	O
)	O
{	O
int	O
c	int
;	O
rl_message	(*(char))->(int)
(	O
"(arg: %d) "	*(char)
,	O
rl_arg_sign	int
*	O
rl_numeric_arg	int
)	O
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
return	O
c	int
;	O
}	O
int	O
_rl_arg_dispatch	(int,int)->(int)
(	O
cxt	int
,	O
c	int
)	O
_rl_arg_cxt	int
cxt	int
;	O
int	O
c	int
;	O
{	O
int	O
key	int
,	O
r	int
;	O
key	int
=	O
c	int
;	O
if	O
(	O
c	int
>=	O
0	int
&&	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
c	int
]	O
.	O
type	char
==	O
ISFUNC	int
&&	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
c	int
]	O
.	O
function	*((int,int)->(int))
==	O
rl_universal_argument	(int,int)->(int)
)	O
{	O
if	O
(	O
(	O
cxt	int
&	O
NUM_SAWDIGITS	int
)	O
==	O
0	int
)	O
{	O
rl_numeric_arg	int
*=	O
4	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_argcxt	int
|=	O
NUM_READONE	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
key	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
rl_restore_prompt	()->(void)
(	O
)	O
;	O
rl_clear_message	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
if	O
(	O
key	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
(	O
_rl_dispatch	(int,*(struct(char,*((int,int)->(int)))))->(int)
(	O
key	int
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
)	O
;	O
}	O
}	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
if	O
(	O
_rl_digit_p	(int)->(int)
(	O
c	int
)	O
)	O
{	O
r	int
=	O
_rl_digit_value	(int)->(int)
(	O
c	int
)	O
;	O
rl_numeric_arg	int
=	O
rl_explicit_arg	int
?	O
(	O
rl_numeric_arg	int
*	O
10	int
)	O
+	O
r	int
:	O
r	int
;	O
rl_explicit_arg	int
=	O
1	int
;	O
_rl_argcxt	int
|=	O
NUM_SAWDIGITS	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'-'	O
&&	O
rl_explicit_arg	int
==	O
0	int
)	O
{	O
rl_numeric_arg	int
=	O
1	int
;	O
_rl_argcxt	int
|=	O
NUM_SAWMINUS	int
;	O
rl_arg_sign	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
_rl_argcxt	int
&	O
NUM_SAWMINUS	int
)	O
&&	O
rl_numeric_arg	int
==	O
1	int
&&	O
rl_explicit_arg	int
==	O
0	int
)	O
rl_explicit_arg	int
=	O
1	int
;	O
rl_restore_prompt	()->(void)
(	O
)	O
;	O
rl_clear_message	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
r	int
=	O
_rl_dispatch	(int,*(struct(char,*((int,int)->(int)))))->(int)
(	O
key	int
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
if	O
(	O
rl_done	int
==	O
0	int
)	O
(	O
*	O
rl_redisplay_function	*(()->(void))
)	O
(	O
)	O
;	O
r	int
=	O
0	int
;	O
}	O
return	O
r	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
rl_digit_loop	()->(int)
(	O
)	O
{	O
int	O
c	int
,	O
r	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
_rl_arg_overflow	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
c	int
=	O
_rl_arg_getchar	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
_rl_abort_internal	()->(int)
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	int
=	O
_rl_arg_dispatch	(int,int)->(int)
(	O
_rl_argcxt	int
,	O
c	int
)	O
;	O
if	O
(	O
r	int
<=	O
0	int
||	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
==	O
0	int
)	O
)	O
break	O
;	O
}	O
return	O
r	int
;	O
}	O
void	O
_rl_reset_argument	()->(void)
(	O
)	O
{	O
rl_numeric_arg	int
=	O
rl_arg_sign	int
=	O
1	int
;	O
rl_explicit_arg	int
=	O
0	int
;	O
_rl_argcxt	int
=	O
0	int
;	O
}	O
int	O
rl_digit_argument	(int,int)->(int)
(	O
ignore	int
,	O
key	int
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
_rl_arg_init	()->(void)
(	O
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_arg_dispatch	(int,int)->(int)
(	O
_rl_argcxt	int
,	O
key	int
)	O
;	O
rl_message	(*(char))->(int)
(	O
"(arg: %d) "	*(char)
,	O
rl_arg_sign	int
*	O
rl_numeric_arg	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
rl_execute_next	(int)->(int)
(	O
key	int
)	O
;	O
return	O
(	O
rl_digit_loop	()->(int)
(	O
)	O
)	O
;	O
}	O
}	O
int	O
rl_universal_argument	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
_rl_arg_init	()->(void)
(	O
)	O
;	O
rl_numeric_arg	int
*=	O
4	int
;	O
return	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
?	O
0	int
:	O
rl_digit_loop	()->(int)
(	O
)	O
)	O
;	O
}	O
int	O
_rl_arg_callback	(int)->(int)
(	O
cxt	int
)	O
_rl_arg_cxt	int
cxt	int
;	O
{	O
int	O
c	int
,	O
r	int
;	O
c	int
=	O
_rl_arg_getchar	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
_rl_argcxt	int
&	O
NUM_READONE	int
)	O
{	O
_rl_argcxt	int
&=	O
~	O
NUM_READONE	int
;	O
rl_restore_prompt	()->(void)
(	O
)	O
;	O
rl_clear_message	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
rl_execute_next	(int)->(int)
(	O
c	int
)	O
;	O
return	O
0	int
;	O
}	O
r	int
=	O
_rl_arg_dispatch	(int,int)->(int)
(	O
cxt	int
,	O
c	int
)	O
;	O
return	O
(	O
r	int
!=	O
1	int
)	O
;	O
}	O
int	O
rl_discard_argument	()->(int)
(	O
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
rl_clear_message	()->(int)
(	O
)	O
;	O
_rl_reset_argument	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
void	O
_rl_start_using_history	()->(void)
(	O
)	O
{	O
using_history	()->(void)
(	O
)	O
;	O
if	O
(	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
)	O
_rl_free_history_entry	(*(struct(*(char),*(char),*(void))))->(void)
(	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
)	O
;	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
}	O
void	O
_rl_free_history_entry	(*(struct(*(char),*(char),*(void))))->(void)
(	O
entry	*(struct(*(char),*(char),*(void)))
)	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
entry	*(struct(*(char),*(char),*(void)))
;	O
{	O
if	O
(	O
entry	*(struct(*(char),*(char),*(void)))
==	O
0	int
)	O
return	O
;	O
FREE	O
(	O
entry	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
)	O
;	O
FREE	O
(	O
entry	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
entry	*(struct(*(char),*(char),*(void)))
)	O
;	O
}	O
int	O
rl_maybe_replace_line	()->(int)
(	O
)	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
temp	*(struct(*(char),*(char),*(void)))
;	O
temp	*(struct(*(char),*(char),*(void)))
=	O
current_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
;	O
if	O
(	O
temp	*(struct(*(char),*(char),*(void)))
&&	O
(	O
(	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
)	O
(	O
temp	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
)	O
!=	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
)	O
{	O
temp	*(struct(*(char),*(char),*(void)))
=	O
replace_history_entry	(int,*(char),*(void))->(*(struct(*(char),*(char),*(void))))
(	O
where_history	()->(int)
(	O
)	O
,	O
rl_line_buffer	*(char)
,	O
(	O
histdata_t	*(void)
)	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
;	O
xfree	(*(void))->(void)
(	O
temp	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
)	O
;	O
FREE	O
(	O
temp	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
temp	*(struct(*(char),*(char),*(void)))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_maybe_unsave_line	()->(int)
(	O
)	O
{	O
if	O
(	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
)	O
{	O
rl_replace_line	(*(char),int)->(void)
(	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
,	O
0	int
)	O
;	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
(	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
)	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
;	O
_rl_free_history_entry	(*(struct(*(char),*(char),*(void))))->(void)
(	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
)	O
;	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
rl_point	int
=	O
rl_end	int
;	O
}	O
else	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_maybe_save_line	()->(int)
(	O
)	O
{	O
if	O
(	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
==	O
0	int
)	O
{	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
)	O
)	O
;	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
=	O
savestring	O
(	O
rl_line_buffer	*(char)
)	O
;	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
->	O
timestamp	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
(	O
char	O
*	O
)	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
}	O
return	O
0	int
;	O
}	O
int	O
_rl_free_saved_history_line	()->(int)
(	O
)	O
{	O
if	O
(	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
)	O
{	O
_rl_free_history_entry	(*(struct(*(char),*(char),*(void))))->(void)
(	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
)	O
;	O
_rl_saved_line_for_history	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
_rl_history_set_point	()->(void)
(	O
)	O
{	O
rl_point	int
=	O
(	O
_rl_history_preserve_point	int
&&	O
_rl_history_saved_point	int
!=	O
-	O
1	int
)	O
?	O
_rl_history_saved_point	int
:	O
rl_end	int
;	O
if	O
(	O
rl_point	int
>	O
rl_end	int
)	O
rl_point	int
=	O
rl_end	int
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
&&	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
!=	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
)	O
rl_point	int
=	O
0	int
;	O
if	O
(	O
rl_editing_mode	int
==	O
emacs_mode	int
)	O
rl_mark	int
=	O
(	O
rl_point	int
==	O
rl_end	int
?	O
0	int
:	O
rl_end	int
)	O
;	O
}	O
void	O
rl_replace_from_history	(*(struct(*(char),*(char),*(void))),int)->(void)
(	O
entry	*(struct(*(char),*(char),*(void)))
,	O
flags	int
)	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
entry	*(struct(*(char),*(char),*(void)))
;	O
int	O
flags	int
;	O
{	O
rl_replace_line	(*(char),int)->(void)
(	O
entry	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
,	O
0	int
)	O
;	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
(	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
)	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
;	O
rl_point	int
=	O
rl_end	int
;	O
rl_mark	int
=	O
0	int
;	O
if	O
(	O
rl_editing_mode	int
==	O
vi_mode	int
)	O
{	O
rl_point	int
=	O
0	int
;	O
rl_mark	int
=	O
rl_end	int
;	O
}	O
}	O
void	O
_rl_revert_all_lines	()->(void)
(	O
)	O
{	O
int	O
hpos	int
;	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
entry	*(struct(*(char),*(char),*(void)))
;	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
ul	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
,	O
*	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
char	O
*	O
lbuf	*(char)
;	O
lbuf	*(char)
=	O
savestring	O
(	O
rl_line_buffer	*(char)
)	O
;	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
hpos	int
=	O
where_history	()->(int)
(	O
)	O
;	O
entry	*(struct(*(char),*(char),*(void)))
=	O
(	O
hpos	int
==	O
history_length	int
)	O
?	O
previous_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
:	O
current_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
;	O
while	O
(	O
entry	*(struct(*(char),*(char),*(void)))
)	O
{	O
if	O
(	O
ul	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
(	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
)	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
)	O
{	O
if	O
(	O
ul	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
==	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
0	int
;	O
rl_replace_from_history	(*(struct(*(char),*(char),*(void))),int)->(void)
(	O
entry	*(struct(*(char),*(char),*(void)))
,	O
0	int
)	O
;	O
entry	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
0	int
;	O
while	O
(	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
rl_do_undo	()->(int)
(	O
)	O
;	O
FREE	O
(	O
entry	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(void)))
->	O
line	*(char)
=	O
savestring	O
(	O
rl_line_buffer	*(char)
)	O
;	O
}	O
entry	*(struct(*(char),*(char),*(void)))
=	O
previous_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
;	O
}	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
history_set_pos	(int)->(int)
(	O
hpos	int
)	O
;	O
rl_replace_line	(*(char),int)->(void)
(	O
lbuf	*(char)
,	O
0	int
)	O
;	O
_rl_set_the_line	()->(void)
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
lbuf	*(char)
)	O
;	O
}	O
void	O
rl_clear_history	()->(void)
(	O
)	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
*	O
hlist	*(*(struct(*(char),*(char),*(void))))
,	O
*	O
hent	*(struct(*(char),*(char),*(void)))
;	O
register	O
int	O
i	int
;	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
ul	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
,	O
*	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
hlist	*(*(struct(*(char),*(char),*(void))))
=	O
history_list	()->(*(*(struct(*(char),*(char),*(void)))))
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
history_length	int
;	O
i	int
++	O
)	O
{	O
hent	*(struct(*(char),*(char),*(void)))
=	O
hlist	*(*(struct(*(char),*(char),*(void))))
[	O
i	int
]	O
;	O
if	O
(	O
ul	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
(	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
)	O
hent	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
)	O
{	O
if	O
(	O
ul	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
==	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
0	int
;	O
_rl_free_undo_list	(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))))->(void)
(	O
ul	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
;	O
hent	*(struct(*(char),*(char),*(void)))
->	O
data	*(void)
=	O
0	int
;	O
}	O
_rl_free_history_entry	(*(struct(*(char),*(char),*(void))))->(void)
(	O
hent	*(struct(*(char),*(char),*(void)))
)	O
;	O
}	O
history_offset	int
=	O
history_length	int
=	O
0	int
;	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
saved_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
}	O
int	O
rl_beginning_of_history	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_get_previous_history	(int,int)->(int)
(	O
1	int
+	O
where_history	()->(int)
(	O
)	O
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_end_of_history	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_maybe_replace_line	()->(int)
(	O
)	O
;	O
using_history	()->(void)
(	O
)	O
;	O
rl_maybe_unsave_line	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_get_next_history	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
temp	*(struct(*(char),*(char),*(void)))
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_get_previous_history	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
0	int
;	O
rl_maybe_replace_line	()->(int)
(	O
)	O
;	O
if	O
(	O
_rl_history_saved_point	int
==	O
-	O
1	int
&&	O
(	O
rl_point	int
||	O
rl_end	int
)	O
)	O
_rl_history_saved_point	int
=	O
(	O
rl_point	int
==	O
rl_end	int
)	O
?	O
-	O
1	int
:	O
rl_point	int
;	O
temp	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
while	O
(	O
count	int
)	O
{	O
temp	*(struct(*(char),*(char),*(void)))
=	O
next_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
;	O
if	O
(	O
!	O
temp	*(struct(*(char),*(char),*(void)))
)	O
break	O
;	O
--	O
count	int
;	O
}	O
if	O
(	O
temp	*(struct(*(char),*(char),*(void)))
==	O
0	int
)	O
rl_maybe_unsave_line	()->(int)
(	O
)	O
;	O
else	O
{	O
rl_replace_from_history	(*(struct(*(char),*(char),*(void))),int)->(void)
(	O
temp	*(struct(*(char),*(char),*(void)))
,	O
0	int
)	O
;	O
_rl_history_set_point	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_get_previous_history	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
old_temp	*(struct(*(char),*(char),*(void)))
,	O
*	O
temp	*(struct(*(char),*(char),*(void)))
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_get_next_history	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
_rl_history_saved_point	int
==	O
-	O
1	int
&&	O
(	O
rl_point	int
||	O
rl_end	int
)	O
)	O
_rl_history_saved_point	int
=	O
(	O
rl_point	int
==	O
rl_end	int
)	O
?	O
-	O
1	int
:	O
rl_point	int
;	O
rl_maybe_save_line	()->(int)
(	O
)	O
;	O
rl_maybe_replace_line	()->(int)
(	O
)	O
;	O
temp	*(struct(*(char),*(char),*(void)))
=	O
old_temp	*(struct(*(char),*(char),*(void)))
=	O
(	O
HIST_ENTRY	struct(*(char),*(char),*(void))
*	O
)	O
NULL	O
;	O
while	O
(	O
count	int
)	O
{	O
temp	*(struct(*(char),*(char),*(void)))
=	O
previous_history	()->(*(struct(*(char),*(char),*(void))))
(	O
)	O
;	O
if	O
(	O
temp	*(struct(*(char),*(char),*(void)))
==	O
0	int
)	O
break	O
;	O
old_temp	*(struct(*(char),*(char),*(void)))
=	O
temp	*(struct(*(char),*(char),*(void)))
;	O
--	O
count	int
;	O
}	O
if	O
(	O
!	O
temp	*(struct(*(char),*(char),*(void)))
&&	O
old_temp	*(struct(*(char),*(char),*(void)))
)	O
temp	*(struct(*(char),*(char),*(void)))
=	O
old_temp	*(struct(*(char),*(char),*(void)))
;	O
if	O
(	O
temp	*(struct(*(char),*(char),*(void)))
==	O
0	int
)	O
rl_ding	()->(int)
(	O
)	O
;	O
else	O
{	O
rl_replace_from_history	(*(struct(*(char),*(char),*(void))),int)->(void)
(	O
temp	*(struct(*(char),*(char),*(void)))
,	O
0	int
)	O
;	O
_rl_history_set_point	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_vi_editing_mode	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
_rl_set_insert_mode	(int,int)->(void)
(	O
RL_IM_INSERT	int
,	O
1	int
)	O
;	O
rl_editing_mode	int
=	O
vi_mode	int
;	O
rl_vi_insert_mode	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rl_emacs_editing_mode	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_editing_mode	int
=	O
emacs_mode	int
;	O
_rl_set_insert_mode	(int,int)->(void)
(	O
RL_IM_INSERT	int
,	O
1	int
)	O
;	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
emacs_standard_keymap	array(struct(char,*((int,int)->(int))))
;	O
if	O
(	O
_rl_show_mode_in_prompt	int
)	O
_rl_reset_prompt	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
_rl_set_insert_mode	(int,int)->(void)
(	O
im	int
,	O
force	int
)	O
int	O
im	int
,	O
force	int
;	O
{	O
rl_insert_mode	int
=	O
im	int
;	O
}	O
int	O
rl_overwrite_mode	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_explicit_arg	int
==	O
0	int
)	O
_rl_set_insert_mode	(int,int)->(void)
(	O
rl_insert_mode	int
^	O
1	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
count	int
>	O
0	int
)	O
_rl_set_insert_mode	(int,int)->(void)
(	O
RL_IM_OVERWRITE	int
,	O
0	int
)	O
;	O
else	O
_rl_set_insert_mode	(int,int)->(void)
(	O
RL_IM_INSERT	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
