FILE	struct
*	O
logfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
int	O
tracing_table	array(int)
[	O
END_TRACE_LEVEL	int
]	O
;	O
static	O
int	O
use_syslog	int
=	O
0	int
;	O
static	O
osip_trace_func_t	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void)
*	O
trace_func	*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void))
=	O
0	int
;	O
static	O
unsigned	O
int	O
random_seed_set	int
=	O
0	int
;	O
osip_malloc_func_t	(long)->(*(void))
*	O
osip_malloc_func	*((long)->(*(void)))
=	O
0	int
;	O
osip_realloc_func_t	(*(void),long)->(*(void))
*	O
osip_realloc_func	*((*(void),long)->(*(void)))
=	O
0	int
;	O
osip_free_func_t	(*(void))->(void)
*	O
osip_free_func	*((*(void))->(void))
=	O
0	int
;	O
const	O
char	O
*	O
osip_error_table	array(*(char))
[	O
]	O
=	O
{	O
"success"	*(char)
,	O
"undefined error"	*(char)
,	O
"bad parameter"	*(char)
,	O
"wrong state"	*(char)
,	O
"allocation failure"	*(char)
,	O
"syntax error"	*(char)
,	O
"not found"	*(char)
,	O
"api not initialized"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"no network"	*(char)
,	O
"busy port"	*(char)
,	O
"unknown host"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"disk full"	*(char)
,	O
"no rights"	*(char)
,	O
"file not found"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"time out"	*(char)
,	O
"too much call"	*(char)
,	O
"wrong format"	*(char)
,	O
"no common codec"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
"undefined"	*(char)
,	O
}	O
;	O
const	O
char	O
*	O
osip_strerror	(int)->(*(char))
(	O
int	O
err	int
)	O
{	O
if	O
(	O
err	int
>	O
0	int
)	O
return	O
osip_error_table	array(*(char))
[	O
0	int
]	O
;	O
if	O
(	O
err	int
>	O
-	O
60	int
)	O
return	O
osip_error_table	array(*(char))
[	O
-	O
err	int
]	O
;	O
return	O
osip_error_table	array(*(char))
[	O
59	int
]	O
;	O
}	O
unsigned	O
int	O
osip_build_random_number	()->(int)
(	O
)	O
{	O
if	O
(	O
!	O
random_seed_set	int
)	O
{	O
unsigned	O
int	O
ticks	int
;	O
struct	O
timeval	struct(long,long)
tv	struct(long,long)
;	O
int	O
fd	int
;	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
tv	struct(long,long)
,	O
NULL	O
)	O
;	O
ticks	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
tv	struct(long,long)
.	O
tv_sec	long
+	O
tv	struct(long,long)
.	O
tv_usec	long
)	O
;	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
"/dev/urandom"	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
>	O
0	int
)	O
{	O
unsigned	O
int	O
r	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
512	int
;	O
i	int
++	O
)	O
{	O
read	(int,*(void),long)->(long)
(	O
fd	int
,	O
&	O
r	int
,	O
sizeof	O
(	O
r	int
)	O
)	O
;	O
ticks	int
+=	O
r	int
;	O
}	O
close	(int)->(int)
(	O
fd	int
)	O
;	O
}	O
srand48	(long)->(void)
(	O
ticks	int
)	O
;	O
random_seed_set	int
=	O
1	int
;	O
}	O
{	O
int	O
val	int
=	O
(	O
int	O
)	O
lrand48	()->(long)
(	O
)	O
;	O
if	O
(	O
val	int
==	O
0	int
)	O
{	O
unsigned	O
int	O
ticks	int
;	O
struct	O
timeval	struct(long,long)
tv	struct(long,long)
;	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
tv	struct(long,long)
,	O
NULL	O
)	O
;	O
ticks	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
tv	struct(long,long)
.	O
tv_sec	long
+	O
tv	struct(long,long)
.	O
tv_usec	long
)	O
;	O
srand48	(long)->(void)
(	O
ticks	int
)	O
;	O
return	O
(	O
unsigned	O
int	O
)	O
lrand48	()->(long)
(	O
)	O
;	O
}	O
return	O
val	int
;	O
}	O
}	O
char	O
*	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
dest	*(char)
,	O
const	O
char	O
*	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
size_t	long
length	long
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dest	*(char)
,	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
length	long
)	O
;	O
dest	*(char)
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
dest	*(char)
;	O
}	O
char	O
*	O
osip_strdup	(*(char))->(*(char))
(	O
const	O
char	O
*	O
ch	*(char)
)	O
{	O
char	O
*	O
copy	*(char)
;	O
size_t	long
length	long
;	O
if	O
(	O
ch	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
length	long
=	O
strlen	(*(char))->(long)
(	O
ch	*(char)
)	O
;	O
copy	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
copy	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
copy	*(char)
,	O
ch	*(char)
,	O
length	long
)	O
;	O
return	O
copy	*(char)
;	O
}	O
int	O
osip_atoi	(*(char))->(int)
(	O
const	O
char	O
*	O
number	*(char)
)	O
{	O
long	O
int	O
i	int
;	O
if	O
(	O
number	*(char)
==	O
NULL	O
)	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
i	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
number	*(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
i	int
==	O
LONG_MIN	O
||	O
i	int
==	O
LONG_MAX	O
)	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
return	O
i	int
;	O
return	O
atoi	(*(char))->(int)
(	O
number	*(char)
)	O
;	O
}	O
void	O
osip_usleep	(int)->(void)
(	O
int	O
useconds	int
)	O
{	O
struct	O
timeval	struct(long,long)
delay	struct(long,long)
;	O
int	O
sec	int
;	O
sec	int
=	O
(	O
int	O
)	O
useconds	int
/	O
1000000	int
;	O
if	O
(	O
sec	int
>	O
0	int
)	O
{	O
delay	struct(long,long)
.	O
tv_sec	long
=	O
sec	int
;	O
delay	struct(long,long)
.	O
tv_usec	long
=	O
0	int
;	O
}	O
else	O
{	O
delay	struct(long,long)
.	O
tv_sec	long
=	O
0	int
;	O
delay	struct(long,long)
.	O
tv_usec	long
=	O
useconds	int
;	O
}	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
delay	struct(long,long)
)	O
;	O
}	O
char	O
*	O
osip_strdup_without_quote	(*(char))->(*(char))
(	O
const	O
char	O
*	O
ch	*(char)
)	O
{	O
char	O
*	O
copy	*(char)
=	O
(	O
char	O
*	O
)	O
osip_malloc	O
(	O
strlen	(*(char))->(long)
(	O
ch	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
copy	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
*	O
ch	*(char)
==	O
'\"'	O
)	O
)	O
{	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
copy	*(char)
,	O
ch	*(char)
+	O
1	int
,	O
strlen	(*(char))->(long)
(	O
ch	*(char)
+	O
1	int
)	O
)	O
;	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
copy	*(char)
+	O
strlen	(*(char))->(long)
(	O
copy	*(char)
)	O
-	O
1	int
,	O
"\0"	*(char)
,	O
1	int
)	O
;	O
}	O
else	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
copy	*(char)
,	O
ch	*(char)
,	O
strlen	(*(char))->(long)
(	O
ch	*(char)
)	O
)	O
;	O
return	O
copy	*(char)
;	O
}	O
int	O
osip_tolower	(*(char))->(int)
(	O
char	O
*	O
word	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
word	*(char)
;	O
word	*(char)
++	O
)	O
*	O
word	*(char)
=	O
(	O
char	O
)	O
tolower	(int)->(int)
(	O
*	O
word	*(char)
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_strcasecmp	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
s1	*(char)
,	O
const	O
char	O
*	O
s2	*(char)
)	O
{	O
return	O
strcasecmp	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
s2	*(char)
)	O
;	O
}	O
int	O
osip_strncasecmp	(*(char),*(char),long)->(int)
(	O
const	O
char	O
*	O
s1	*(char)
,	O
const	O
char	O
*	O
s2	*(char)
,	O
size_t	long
len	long
)	O
{	O
return	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s1	*(char)
,	O
s2	*(char)
,	O
len	long
)	O
;	O
}	O
char	O
*	O
osip_strcasestr	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
haystack	*(char)
,	O
const	O
char	O
*	O
needle	*(char)
)	O
{	O
char	O
c	char
,	O
sc	char
;	O
size_t	long
len	long
;	O
if	O
(	O
(	O
c	char
=	O
*	O
needle	*(char)
++	O
)	O
!=	O
0	int
)	O
{	O
c	char
=	O
tolower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
c	char
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
needle	*(char)
)	O
;	O
do	O
{	O
do	O
{	O
if	O
(	O
(	O
sc	char
=	O
*	O
haystack	*(char)
++	O
)	O
==	O
0	int
)	O
return	O
(	O
NULL	O
)	O
;	O
}	O
while	O
(	O
(	O
char	O
)	O
tolower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
sc	char
)	O
!=	O
c	char
)	O
;	O
}	O
while	O
(	O
osip_strncasecmp	(*(char),*(char),long)->(int)
(	O
haystack	*(char)
,	O
needle	*(char)
,	O
len	long
)	O
!=	O
0	int
)	O
;	O
haystack	*(char)
--	O
;	O
}	O
return	O
(	O
char	O
*	O
)	O
haystack	*(char)
;	O
}	O
int	O
osip_clrspace	(*(char))->(int)
(	O
char	O
*	O
word	*(char)
)	O
{	O
char	O
*	O
pbeg	*(char)
;	O
char	O
*	O
pend	*(char)
;	O
size_t	long
len	long
;	O
if	O
(	O
word	*(char)
==	O
NULL	O
)	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
if	O
(	O
*	O
word	*(char)
==	O
'\0'	O
)	O
return	O
OSIP_SUCCESS	int
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
pbeg	*(char)
=	O
word	*(char)
;	O
pbeg	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
pbeg	*(char)
,	O
" \r\n\t"	*(char)
)	O
;	O
pend	*(char)
=	O
word	*(char)
+	O
len	long
-	O
1	int
;	O
while	O
(	O
(	O
' '	O
==	O
*	O
pend	*(char)
)	O
||	O
(	O
'\r'	O
==	O
*	O
pend	*(char)
)	O
||	O
(	O
'\n'	O
==	O
*	O
pend	*(char)
)	O
||	O
(	O
'\t'	O
==	O
*	O
pend	*(char)
)	O
)	O
{	O
pend	*(char)
--	O
;	O
if	O
(	O
pend	*(char)
<	O
pbeg	*(char)
)	O
{	O
*	O
word	*(char)
=	O
'\0'	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
}	O
if	O
(	O
pend	*(char)
+	O
1	int
<=	O
word	*(char)
+	O
(	O
len	long
-	O
1	int
)	O
)	O
pend	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
pbeg	*(char)
!=	O
word	*(char)
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
word	*(char)
,	O
pbeg	*(char)
,	O
pend	*(char)
-	O
pbeg	*(char)
+	O
2	int
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
__osip_set_next_token	(*(*(char)),*(char),int,*(*(char)))->(int)
(	O
char	O
*	O
*	O
dest	*(char)
,	O
char	O
*	O
buf	*(char)
,	O
int	O
end_separator	int
,	O
char	O
*	O
*	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
)	O
{	O
char	O
*	O
sep	*(char)
;	O
*	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
NULL	O
;	O
sep	*(char)
=	O
buf	*(char)
;	O
while	O
(	O
(	O
*	O
sep	*(char)
!=	O
end_separator	int
)	O
&&	O
(	O
*	O
sep	*(char)
!=	O
'\0'	O
)	O
&&	O
(	O
*	O
sep	*(char)
!=	O
'\r'	O
)	O
&&	O
(	O
*	O
sep	*(char)
!=	O
'\n'	O
)	O
)	O
sep	*(char)
++	O
;	O
if	O
(	O
(	O
*	O
sep	*(char)
==	O
'\r'	O
)	O
||	O
(	O
*	O
sep	*(char)
==	O
'\n'	O
)	O
)	O
{	O
if	O
(	O
*	O
sep	*(char)
!=	O
end_separator	int
)	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
}	O
if	O
(	O
*	O
sep	*(char)
==	O
'\0'	O
)	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
if	O
(	O
sep	*(char)
==	O
buf	*(char)
)	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
*	O
dest	*(char)
=	O
osip_malloc	O
(	O
sep	*(char)
-	O
(	O
buf	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
*	O
dest	*(char)
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
osip_strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
dest	*(char)
,	O
buf	*(char)
,	O
sep	*(char)
-	O
buf	*(char)
)	O
;	O
*	O
next	*(struct(*(struct(*(struct`),*(void))),*(void)))
=	O
sep	*(char)
+	O
1	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
const	O
char	O
*	O
__osip_quote_find	(*(char))->(*(char))
(	O
const	O
char	O
*	O
qstring	*(char)
)	O
{	O
const	O
char	O
*	O
quote	*(char)
;	O
quote	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
qstring	*(char)
,	O
'"'	O
)	O
;	O
if	O
(	O
quote	*(char)
==	O
qstring	*(char)
)	O
return	O
quote	*(char)
;	O
if	O
(	O
quote	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
{	O
int	O
i	int
=	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
0	int
==	O
strncmp	(*(char),*(char),long)->(int)
(	O
quote	*(char)
-	O
i	int
,	O
"\\"	*(char)
,	O
1	int
)	O
)	O
i	int
++	O
;	O
else	O
{	O
if	O
(	O
i	int
%	O
2	int
==	O
1	int
)	O
return	O
quote	*(char)
;	O
quote	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
quote	*(char)
+	O
1	int
,	O
'"'	O
)	O
;	O
if	O
(	O
quote	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
i	int
=	O
1	int
;	O
}	O
if	O
(	O
quote	*(char)
-	O
i	int
==	O
qstring	*(char)
-	O
1	int
)	O
{	O
if	O
(	O
*	O
qstring	*(char)
==	O
'\\'	O
)	O
i	int
++	O
;	O
if	O
(	O
i	int
%	O
2	int
==	O
0	int
)	O
return	O
quote	*(char)
;	O
else	O
{	O
qstring	*(char)
=	O
quote	*(char)
+	O
1	int
;	O
quote	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
quote	*(char)
+	O
1	int
,	O
'"'	O
)	O
;	O
if	O
(	O
quote	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
i	int
=	O
1	int
;	O
}	O
}	O
}	O
return	O
NULL	O
;	O
}	O
}	O
char	O
*	O
osip_enquote	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
rtn	*(char)
;	O
char	O
*	O
t	*(char)
;	O
t	*(char)
=	O
rtn	*(char)
=	O
osip_malloc	O
(	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
*	O
2	int
+	O
3	int
)	O
;	O
if	O
(	O
rtn	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
*	O
t	*(char)
++	O
=	O
'"'	O
;	O
for	O
(	O
;	O
*	O
s	*(char)
!=	O
'\0'	O
;	O
s	*(char)
++	O
)	O
{	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
'"'	O
:	O
case	O
'\\'	O
:	O
case	O
0x7f	int
:	O
*	O
t	*(char)
++	O
=	O
'\\'	O
;	O
*	O
t	*(char)
++	O
=	O
*	O
s	*(char)
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
*	O
t	*(char)
++	O
=	O
' '	O
;	O
break	O
;	O
default	O
:	O
*	O
t	*(char)
++	O
=	O
*	O
s	*(char)
;	O
break	O
;	O
}	O
}	O
*	O
t	*(char)
++	O
=	O
'"'	O
;	O
*	O
t	*(char)
++	O
=	O
'\0'	O
;	O
return	O
rtn	*(char)
;	O
}	O
void	O
osip_dequote	(*(char))->(void)
(	O
char	O
*	O
s	*(char)
)	O
{	O
size_t	long
len	long
;	O
if	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
return	O
;	O
if	O
(	O
*	O
s	*(char)
!=	O
'"'	O
)	O
return	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
s	*(char)
,	O
s	*(char)
+	O
1	int
,	O
len	long
--	O
)	O
;	O
if	O
(	O
len	long
>	O
0	int
&&	O
s	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'"'	O
)	O
s	*(char)
[	O
--	O
len	long
]	O
=	O
'\0'	O
;	O
for	O
(	O
;	O
*	O
s	*(char)
!=	O
'\0'	O
;	O
s	*(char)
++	O
,	O
len	long
--	O
)	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
'\\'	O
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
s	*(char)
,	O
s	*(char)
+	O
1	int
,	O
len	long
--	O
)	O
;	O
}	O
}	O
int	O
osip_trace_initialize	(enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
level	enum(int,int,int,int,int,int,int,int,int)
,	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
i	int
=	O
TRACE_LEVEL0	int
;	O
logfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
if	O
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
logfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
logfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
while	O
(	O
i	int
<	O
END_TRACE_LEVEL	int
)	O
{	O
if	O
(	O
i	int
<	O
level	enum(int,int,int,int,int,int,int,int,int)
)	O
tracing_table	array(int)
[	O
i	int
]	O
=	O
LOG_TRUE	int
;	O
else	O
tracing_table	array(int)
[	O
i	int
]	O
=	O
LOG_FALSE	int
;	O
i	int
++	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
osip_trace_initialize_syslog	(enum(int,int,int,int,int,int,int,int,int),*(char))->(void)
(	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
level	enum(int,int,int,int,int,int,int,int,int)
,	O
char	O
*	O
ident	*(char)
)	O
{	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
i	int
=	O
TRACE_LEVEL0	int
;	O
openlog	(*(char),int,int)->(void)
(	O
ident	*(char)
,	O
LOG_CONS	int
|	O
LOG_PID	int
,	O
LOG_DAEMON	O
)	O
;	O
use_syslog	int
=	O
1	int
;	O
while	O
(	O
i	int
<	O
END_TRACE_LEVEL	int
)	O
{	O
if	O
(	O
i	int
<	O
level	enum(int,int,int,int,int,int,int,int,int)
)	O
tracing_table	array(int)
[	O
i	int
]	O
=	O
LOG_TRUE	int
;	O
else	O
tracing_table	array(int)
[	O
i	int
]	O
=	O
LOG_FALSE	int
;	O
i	int
++	O
;	O
}	O
}	O
void	O
osip_trace_enable_until_level	(enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
level	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
END_TRACE_LEVEL	int
)	O
{	O
if	O
(	O
i	int
<	O
level	enum(int,int,int,int,int,int,int,int,int)
)	O
tracing_table	array(int)
[	O
i	int
]	O
=	O
LOG_TRUE	int
;	O
else	O
tracing_table	array(int)
[	O
i	int
]	O
=	O
LOG_FALSE	int
;	O
i	int
++	O
;	O
}	O
}	O
void	O
osip_trace_initialize_func	(enum(int,int,int,int,int,int,int,int,int),*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void)))->(void)
(	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
level	enum(int,int,int,int,int,int,int,int,int)
,	O
osip_trace_func_t	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void)
*	O
func	*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void))
)	O
{	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
i	int
=	O
0	int
;	O
trace_func	*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void))
=	O
func	*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void))
;	O
while	O
(	O
i	int
<	O
END_TRACE_LEVEL	int
)	O
{	O
if	O
(	O
i	int
<	O
level	enum(int,int,int,int,int,int,int,int,int)
)	O
tracing_table	array(int)
[	O
i	int
]	O
=	O
LOG_TRUE	int
;	O
else	O
tracing_table	array(int)
[	O
i	int
]	O
=	O
LOG_FALSE	int
;	O
i	int
++	O
;	O
}	O
}	O
void	O
osip_trace_enable_level	(enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
level	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
tracing_table	array(int)
[	O
level	enum(int,int,int,int,int,int,int,int,int)
]	O
=	O
LOG_TRUE	int
;	O
}	O
void	O
osip_trace_disable_level	(enum(int,int,int,int,int,int,int,int,int))->(void)
(	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
level	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
tracing_table	array(int)
[	O
level	enum(int,int,int,int,int,int,int,int,int)
]	O
=	O
LOG_FALSE	int
;	O
}	O
int	O
osip_is_trace_level_activate	(enum(int,int,int,int,int,int,int,int,int))->(int)
(	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
level	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
return	O
tracing_table	array(int)
[	O
level	enum(int,int,int,int,int,int,int,int,int)
]	O
;	O
}	O
int	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
char	O
*	O
filename_long	*(char)
,	O
int	O
li	*(struct)
,	O
osip_trace_level_t	enum(int,int,int,int,int,int,int,int,int)
level	enum(int,int,int,int,int,int,int,int,int)
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
char	O
*	O
chfr	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
int	O
relative_time	int
=	O
0	int
;	O
char	O
*	O
fi	*(char)
=	O
NULL	O
;	O
static	O
struct	O
timeval	struct(long,long)
start	struct(long,long)
=	O
{	O
0	int
,	O
0	int
}	O
;	O
struct	O
timeval	struct(long,long)
now	struct(long,long)
;	O
if	O
(	O
start	struct(long,long)
.	O
tv_sec	long
==	O
0	int
&&	O
start	struct(long,long)
.	O
tv_usec	long
==	O
0	int
)	O
{	O
__osip_port_gettimeofday	O
(	O
&	O
start	struct(long,long)
,	O
NULL	O
)	O
;	O
}	O
__osip_port_gettimeofday	O
(	O
&	O
now	struct(long,long)
,	O
NULL	O
)	O
;	O
relative_time	int
=	O
(	O
int	O
)	O
(	O
1000	int
*	O
(	O
now	struct(long,long)
.	O
tv_sec	long
-	O
start	struct(long,long)
.	O
tv_sec	long
)	O
)	O
;	O
if	O
(	O
now	struct(long,long)
.	O
tv_usec	long
-	O
start	struct(long,long)
.	O
tv_usec	long
>	O
0	int
)	O
relative_time	int
=	O
relative_time	int
+	O
(	O
(	O
now	struct(long,long)
.	O
tv_usec	long
-	O
start	struct(long,long)
.	O
tv_usec	long
)	O
/	O
1000	int
)	O
;	O
else	O
relative_time	int
=	O
relative_time	int
-	O
(	O
(	O
start	struct(long,long)
.	O
tv_usec	long
-	O
now	struct(long,long)
.	O
tv_usec	long
)	O
/	O
1000	int
)	O
;	O
if	O
(	O
filename_long	*(char)
!=	O
NULL	O
)	O
{	O
fi	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
filename_long	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
fi	*(char)
==	O
NULL	O
)	O
fi	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
filename_long	*(char)
,	O
'\\'	O
)	O
;	O
if	O
(	O
fi	*(char)
!=	O
NULL	O
)	O
fi	*(char)
++	O
;	O
if	O
(	O
fi	*(char)
==	O
NULL	O
)	O
fi	*(char)
=	O
filename_long	*(char)
;	O
}	O
if	O
(	O
logfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
&&	O
use_syslog	int
==	O
0	int
&&	O
trace_func	*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void))
==	O
NULL	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
tracing_table	array(int)
[	O
level	enum(int,int,int,int,int,int,int,int,int)
]	O
==	O
LOG_FALSE	int
)	O
return	O
OSIP_SUCCESS	int
;	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
&&	O
trace_func	*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void))
==	O
NULL	O
)	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
logfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
VA_START	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
chfr	*(char)
)	O
;	O
if	O
(	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
&&	O
use_syslog	int
==	O
0	int
)	O
{	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_FATAL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"| FATAL | %i <%s: %i> "	*(char)
,	O
relative_time	int
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_BUG	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"|  BUG  | %i <%s: %i> "	*(char)
,	O
relative_time	int
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_ERROR	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"| ERROR | %i <%s: %i> "	*(char)
,	O
relative_time	int
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_WARNING	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"|WARNING| %i <%s: %i> "	*(char)
,	O
relative_time	int
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO1	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"| INFO1 | %i <%s: %i> "	*(char)
,	O
relative_time	int
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO2	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"| INFO2 | %i <%s: %i> "	*(char)
,	O
relative_time	int
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO3	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"| INFO3 | %i <%s: %i> "	*(char)
,	O
relative_time	int
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO4	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"| INFO4 | %i <%s: %i> "	*(char)
,	O
relative_time	int
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
chfr	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
if	O
(	O
trace_func	*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void))
)	O
{	O
trace_func	*((*(char),int,enum(int,int,int,int,int,int,int,int,int),*(char),array(struct(int,int,*(void),*(void))))->(void))
(	O
fi	*(char)
,	O
li	*(struct)
,	O
level	enum(int,int,int,int,int,int,int,int,int)
,	O
chfr	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
else	O
if	O
(	O
use_syslog	int
==	O
1	int
)	O
{	O
char	O
buffer	array(char)
[	O
MAX_LENGTH_TR	int
]	O
;	O
int	O
in	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
buffer	array(char)
,	O
0	int
,	O
sizeof	O
(	O
buffer	array(char)
)	O
)	O
;	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_FATAL	O
)	O
in	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	array(char)
,	O
MAX_LENGTH_TR	int
-	O
1	int
,	O
"| FATAL | <%s: %i> "	*(char)
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_BUG	O
)	O
in	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	array(char)
,	O
MAX_LENGTH_TR	int
-	O
1	int
,	O
"|  BUG  | <%s: %i> "	*(char)
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_ERROR	O
)	O
in	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	array(char)
,	O
MAX_LENGTH_TR	int
-	O
1	int
,	O
"| ERROR | <%s: %i> "	*(char)
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_WARNING	O
)	O
in	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	array(char)
,	O
MAX_LENGTH_TR	int
-	O
1	int
,	O
"|WARNING| <%s: %i> "	*(char)
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO1	O
)	O
in	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	array(char)
,	O
MAX_LENGTH_TR	int
-	O
1	int
,	O
"| INFO1 | <%s: %i> "	*(char)
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO2	O
)	O
in	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	array(char)
,	O
MAX_LENGTH_TR	int
-	O
1	int
,	O
"| INFO2 | <%s: %i> "	*(char)
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO3	O
)	O
in	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	array(char)
,	O
MAX_LENGTH_TR	int
-	O
1	int
,	O
"| INFO3 | <%s: %i> "	*(char)
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO4	O
)	O
in	int
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	array(char)
,	O
MAX_LENGTH_TR	int
-	O
1	int
,	O
"| INFO4 | <%s: %i> "	*(char)
,	O
fi	*(char)
,	O
li	*(struct)
)	O
;	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
buffer	array(char)
+	O
in	int
,	O
MAX_LENGTH_TR	int
-	O
1	int
-	O
in	int
,	O
chfr	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_FATAL	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"%s"	*(char)
,	O
buffer	array(char)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_BUG	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"%s"	*(char)
,	O
buffer	array(char)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_ERROR	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"%s"	*(char)
,	O
buffer	array(char)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_WARNING	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_WARNING	int
,	O
"%s"	*(char)
,	O
buffer	array(char)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO1	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"%s"	*(char)
,	O
buffer	array(char)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO2	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"%s"	*(char)
,	O
buffer	array(char)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO3	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_DEBUG	int
,	O
"%s"	*(char)
,	O
buffer	array(char)
)	O
;	O
else	O
if	O
(	O
level	enum(int,int,int,int,int,int,int,int,int)
==	O
OSIP_INFO4	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_DEBUG	int
,	O
"%s"	*(char)
,	O
buffer	array(char)
)	O
;	O
}	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
void	O
osip_set_allocators	(*((long)->(*(void))),*((*(void),long)->(*(void))),*((*(void))->(void)))->(void)
(	O
osip_malloc_func_t	(long)->(*(void))
*	O
malloc_func	*((long)->(*(void)))
,	O
osip_realloc_func_t	(*(void),long)->(*(void))
*	O
realloc_func	*((*(void),long)->(*(void)))
,	O
osip_free_func_t	(*(void))->(void)
*	O
free_func	*((*(void))->(void))
)	O
{	O
osip_malloc_func	*((long)->(*(void)))
=	O
malloc_func	*((long)->(*(void)))
;	O
osip_realloc_func	*((*(void),long)->(*(void)))
=	O
realloc_func	*((*(void),long)->(*(void)))
;	O
osip_free_func	*((*(void))->(void))
=	O
free_func	*((*(void))->(void))
;	O
}	O
unsigned	O
long	O
osip_hash	(*(char))->(long)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
unsigned	O
int	O
hash	int
=	O
5381	int
;	O
int	O
c	char
;	O
while	O
(	O
(	O
c	char
=	O
*	O
str	*(char)
++	O
)	O
)	O
hash	int
=	O
(	O
(	O
hash	int
<<	O
5	int
)	O
+	O
hash	int
)	O
+	O
c	char
;	O
return	O
hash	int
&	O
0xFFFFFFFFu	int
;	O
}	O
char	O
*	O
osip_str_append	(*(char),*(char))->(*(char))
(	O
char	O
*	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
const	O
char	O
*	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
)	O
{	O
while	O
(	O
*	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
!=	O
'\0'	O
)	O
{	O
*	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
=	O
*	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
;	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
++	O
;	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
++	O
;	O
}	O
*	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
=	O
'\0'	O
;	O
return	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
;	O
}	O
char	O
*	O
osip_strn_append	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
const	O
char	O
*	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
size_t	long
len	long
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
(	O
void	O
*	O
)	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
(	O
void	O
*	O
)	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
len	long
)	O
;	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
+=	O
len	long
;	O
*	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
=	O
'\0'	O
;	O
return	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
;	O
}	O
char	O
*	O
osip_clrncpy	(*(char),*(char),long)->(*(char))
(	O
char	O
*	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
const	O
char	O
*	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
size_t	long
len	long
)	O
{	O
const	O
char	O
*	O
pbeg	*(char)
;	O
const	O
char	O
*	O
pend	*(char)
;	O
char	O
*	O
p	*(char)
;	O
size_t	long
spaceless_length	long
;	O
if	O
(	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
==	O
NULL	O
||	O
len	long
==	O
0	int
)	O
{	O
*	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
=	O
'\0'	O
;	O
return	O
NULL	O
;	O
}	O
pbeg	*(char)
=	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
;	O
pbeg	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
pbeg	*(char)
,	O
" \r\n\t"	*(char)
)	O
;	O
pend	*(char)
=	O
src	*(struct(int,*(struct(*(struct`),*(void)))))
+	O
len	long
-	O
1	int
;	O
while	O
(	O
(	O
' '	O
==	O
*	O
pend	*(char)
)	O
||	O
(	O
'\r'	O
==	O
*	O
pend	*(char)
)	O
||	O
(	O
'\n'	O
==	O
*	O
pend	*(char)
)	O
||	O
(	O
'\t'	O
==	O
*	O
pend	*(char)
)	O
)	O
{	O
pend	*(char)
--	O
;	O
if	O
(	O
pend	*(char)
<	O
pbeg	*(char)
)	O
{	O
*	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
=	O
'\0'	O
;	O
return	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
;	O
}	O
}	O
spaceless_length	long
=	O
pend	*(char)
-	O
pbeg	*(char)
+	O
1	int
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
,	O
pbeg	*(char)
,	O
spaceless_length	long
)	O
;	O
p	*(char)
=	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
+	O
spaceless_length	long
;	O
*	O
p	*(char)
=	O
'\0'	O
;	O
if	O
(	O
__builtin_expect	O
(	O
++	O
spaceless_length	long
<	O
len	long
,	O
0	int
)	O
)	O
{	O
do	O
*	O
++	O
p	*(char)
=	O
'\0'	O
;	O
while	O
(	O
++	O
spaceless_length	long
<	O
len	long
)	O
;	O
}	O
return	O
dst	*(struct(int,*(struct(*(struct`),*(void)))))
;	O
}	O
