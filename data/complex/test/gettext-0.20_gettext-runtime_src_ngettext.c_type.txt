static	O
int	O
do_expand	int
;	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"context"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"domain"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
const	O
char	O
*	O
expand_escape	(*(char))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
)	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
{	O
int	O
optchar	int
;	O
const	O
char	O
*	O
msgid	*(char)
;	O
const	O
char	O
*	O
msgid_plural	*(char)
;	O
const	O
char	O
*	O
count	*(char)
;	O
unsigned	O
long	O
n	long
;	O
bool	bool
do_help	bool
=	O
false	int
;	O
bool	bool
do_version	bool
=	O
false	int
;	O
const	O
char	O
*	O
domain	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TEXTDOMAIN"	*(char)
)	O
;	O
const	O
char	O
*	O
domaindir	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TEXTDOMAINDIR"	*(char)
)	O
;	O
const	O
char	O
*	O
context	*(char)
=	O
NULL	O
;	O
do_expand	int
=	O
false	int
;	O
set_program_name	(*(char))->(void)
(	O
argv	array(*(char))
[	O
0	int
]	O
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
atexit	(*(()->(void)))->(int)
(	O
close_stdout	()->(void)
)	O
;	O
while	O
(	O
(	O
optchar	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	array(*(char))
,	O
"+c:d:eEhV"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'c'	O
:	O
context	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'd'	O
:	O
domain	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'e'	O
:	O
do_expand	int
=	O
true	int
;	O
break	O
;	O
case	O
'E'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
usage	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	(*(char))->(int)
(	O
"%s (GNU %s) %s\n"	*(char)
,	O
basename	(*(char))->(*(char))
(	O
program_name	*(char)
)	O
,	O
PACKAGE	*(char)
,	O
VERSION	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
,	O
"1995-1997, 2000-2019"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Written by %s.\n"	*(char)
)	O
,	O
proper_name	(*(char))->(*(char))
(	O
"Ulrich Drepper"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
switch	O
(	O
argc	int
-	O
optind	int
)	O
{	O
default	O
:	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
case	O
4	int
:	O
domain	*(char)
=	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
;	O
case	O
3	int
:	O
break	O
;	O
case	O
2	int
:	O
case	O
1	int
:	O
case	O
0	int
:	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"missing arguments"	*(char)
)	O
)	O
;	O
}	O
msgid	*(char)
=	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
;	O
msgid_plural	*(char)
=	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
;	O
count	*(char)
=	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
abort	()->(void)
(	O
)	O
;	O
{	O
char	O
*	O
endp	*(char)
;	O
unsigned	O
long	O
tmp_val	long
;	O
errno	O
=	O
0	int
;	O
tmp_val	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
count	*(char)
,	O
&	O
endp	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
errno	O
==	O
0	int
&&	O
count	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
endp	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
n	long
=	O
tmp_val	long
;	O
else	O
n	long
=	O
99	int
;	O
}	O
if	O
(	O
do_expand	int
)	O
{	O
msgid	*(char)
=	O
expand_escape	(*(char))->(*(char))
(	O
msgid	*(char)
)	O
;	O
msgid_plural	*(char)
=	O
expand_escape	(*(char))->(*(char))
(	O
msgid_plural	*(char)
)	O
;	O
}	O
if	O
(	O
domain	*(char)
==	O
NULL	O
||	O
domain	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
n	long
==	O
1	int
?	O
msgid	*(char)
:	O
msgid_plural	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
if	O
(	O
domaindir	*(char)
!=	O
NULL	O
&&	O
domaindir	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
domain	*(char)
,	O
domaindir	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
(	O
context	*(char)
!=	O
NULL	O
?	O
dnpgettext_expr	O
(	O
domain	*(char)
,	O
context	*(char)
,	O
msgid	*(char)
,	O
msgid_plural	*(char)
,	O
n	long
)	O
:	O
dngettext	(*(char),*(char),*(char),long)->(*(char))
(	O
domain	*(char)
,	O
msgid	*(char)
,	O
msgid_plural	*(char)
,	O
n	long
)	O
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION] [TEXTDOMAIN] MSGID MSGID-PLURAL COUNT\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Display native language translation of a textual message whose grammatical\nform depends on a number.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -d, --domain=TEXTDOMAIN   retrieve translated message from TEXTDOMAIN\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -c, --context=CONTEXT     specify context for MSGID\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -e                        enable expansion of some escape sequences\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -E                        (ignored for compatibility)\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [TEXTDOMAIN]              retrieve translated message from TEXTDOMAIN\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  MSGID MSGID-PLURAL        translate MSGID (singular) / MSGID-PLURAL (plural)\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  COUNT                     choose singular/plural form based on this value\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Informative output:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -h, --help                display this help and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -V, --version             display version information and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"If the TEXTDOMAIN parameter is not given, the domain is determined from the\nenvironment variable TEXTDOMAIN.  If the message catalog is not found in the\nregular directory, another location can be specified with the environment\nvariable TEXTDOMAINDIR.\nStandard search directory: %s\n"	*(char)
)	O
,	O
getenv	(*(char))->(*(char))
(	O
"IN_HELP2MAN"	*(char)
)	O
==	O
NULL	O
?	O
LOCALEDIR	O
:	O
"@localedir@"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
expand_escape	(*(char))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
retval	*(char)
,	O
*	O
rp	*(char)
;	O
const	O
char	O
*	O
cp	*(char)
=	O
str	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\\'	O
)	O
++	O
cp	*(char)
;	O
if	O
(	O
cp	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
str	*(char)
;	O
if	O
(	O
cp	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
return	O
str	*(char)
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"abcfnrtv\\01234567"	*(char)
,	O
cp	*(char)
[	O
1	int
]	O
)	O
!=	O
NULL	O
)	O
break	O
;	O
++	O
cp	*(char)
;	O
}	O
retval	*(char)
=	O
XNMALLOC	O
(	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
,	O
char	O
)	O
;	O
rp	*(char)
=	O
retval	*(char)
+	O
(	O
cp	*(char)
-	O
str	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
retval	*(char)
,	O
str	*(char)
,	O
cp	*(char)
-	O
str	*(char)
)	O
;	O
do	O
{	O
switch	O
(	O
*	O
++	O
cp	*(char)
)	O
{	O
case	O
'a'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\a'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\b'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\f'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\n'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\r'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\t'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'v'	O
:	O
*	O
rp	*(char)
++	O
=	O
'\v'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
rp	*(char)
=	O
'\\'	O
;	O
++	O
cp	*(char)
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
{	O
int	O
ch	int
=	O
*	O
cp	*(char)
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
cp	*(char)
>=	O
'0'	O
&&	O
*	O
cp	*(char)
<=	O
'7'	O
)	O
{	O
ch	int
*=	O
8	int
;	O
ch	int
+=	O
*	O
cp	*(char)
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
cp	*(char)
>=	O
'0'	O
&&	O
*	O
cp	*(char)
<=	O
'7'	O
)	O
{	O
ch	int
*=	O
8	int
;	O
ch	int
+=	O
*	O
cp	*(char)
++	O
-	O
'0'	O
;	O
}	O
}	O
*	O
rp	*(char)
=	O
ch	int
;	O
}	O
break	O
;	O
default	O
:	O
*	O
rp	*(char)
=	O
'\\'	O
;	O
break	O
;	O
}	O
while	O
(	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\\'	O
)	O
*	O
rp	*(char)
++	O
=	O
*	O
cp	*(char)
++	O
;	O
}	O
while	O
(	O
cp	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
;	O
*	O
rp	*(char)
=	O
'\0'	O
;	O
return	O
(	O
const	O
char	O
*	O
)	O
retval	*(char)
;	O
}	O
