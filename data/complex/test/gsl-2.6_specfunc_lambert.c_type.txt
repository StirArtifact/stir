static	O
int	O
halley_iteration	(double,double,int,*(struct(double,double)))->(int)
(	O
double	O
x	double
,	O
double	O
w_initial	double
,	O
unsigned	O
int	O
max_iters	int
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
double	O
w	double
=	O
w_initial	double
;	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
max_iters	int
;	O
i	int
++	O
)	O
{	O
double	O
tol	double
;	O
const	O
double	O
e	int
=	O
exp	(double)->(double)
(	O
w	double
)	O
;	O
const	O
double	O
p	double
=	O
w	double
+	O
1.0	int
;	O
double	O
t	double
=	O
w	double
*	O
e	int
-	O
x	double
;	O
if	O
(	O
w	double
>	O
0	int
)	O
{	O
t	double
=	O
(	O
t	double
/	O
p	double
)	O
/	O
e	int
;	O
}	O
else	O
{	O
t	double
/=	O
e	int
*	O
p	double
-	O
0.5	int
*	O
(	O
p	double
+	O
1.0	int
)	O
*	O
t	double
/	O
p	double
;	O
}	O
;	O
w	double
-=	O
t	double
;	O
tol	double
=	O
10	int
*	O
GSL_DBL_EPSILON	int
*	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
w	double
)	O
,	O
1.0	int
/	O
(	O
fabs	(double)->(double)
(	O
p	double
)	O
*	O
e	int
)	O
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
t	double
)	O
<	O
tol	double
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
w	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
tol	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
w	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
w	double
)	O
;	O
return	O
GSL_EMAXITER	int
;	O
}	O
static	O
double	O
series_eval	(double)->(double)
(	O
double	O
r	*(struct(double,double))
)	O
{	O
static	O
const	O
double	O
c	array(double)
[	O
12	int
]	O
=	O
{	O
-	O
1.0	int
,	O
2.331643981597124203363536062168	int
,	O
-	O
1.812187885639363490240191647568	int
,	O
1.936631114492359755363277457668	int
,	O
-	O
2.353551201881614516821543561516	int
,	O
3.066858901050631912893148922704	int
,	O
-	O
4.175335600258177138854984177460	int
,	O
5.858023729874774148815053846119	int
,	O
-	O
8.401032217523977370984161688514	int
,	O
12.250753501314460424	int
,	O
-	O
18.100697012472442755	int
,	O
27.029044799010561650	int
}	O
;	O
const	O
double	O
t_8	double
=	O
c	array(double)
[	O
8	int
]	O
+	O
r	*(struct(double,double))
*	O
(	O
c	array(double)
[	O
9	int
]	O
+	O
r	*(struct(double,double))
*	O
(	O
c	array(double)
[	O
10	int
]	O
+	O
r	*(struct(double,double))
*	O
c	array(double)
[	O
11	int
]	O
)	O
)	O
;	O
const	O
double	O
t_5	double
=	O
c	array(double)
[	O
5	int
]	O
+	O
r	*(struct(double,double))
*	O
(	O
c	array(double)
[	O
6	int
]	O
+	O
r	*(struct(double,double))
*	O
(	O
c	array(double)
[	O
7	int
]	O
+	O
r	*(struct(double,double))
*	O
t_8	double
)	O
)	O
;	O
const	O
double	O
t_1	double
=	O
c	array(double)
[	O
1	int
]	O
+	O
r	*(struct(double,double))
*	O
(	O
c	array(double)
[	O
2	int
]	O
+	O
r	*(struct(double,double))
*	O
(	O
c	array(double)
[	O
3	int
]	O
+	O
r	*(struct(double,double))
*	O
(	O
c	array(double)
[	O
4	int
]	O
+	O
r	*(struct(double,double))
*	O
t_5	double
)	O
)	O
)	O
;	O
return	O
c	array(double)
[	O
0	int
]	O
+	O
r	*(struct(double,double))
*	O
t_1	double
;	O
}	O
int	O
gsl_sf_lambert_W0_e	(double,*(struct(double,double)))->(int)
(	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
const	O
double	O
one_over_E	double
=	O
1.0	int
/	O
M_E	int
;	O
const	O
double	O
q	double
=	O
x	double
+	O
one_over_E	double
;	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
q	double
<	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
sqrt	(double)->(double)
(	O
-	O
q	double
)	O
;	O
return	O
GSL_EDOM	int
;	O
}	O
else	O
if	O
(	O
q	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
q	double
<	O
1.0e-03	int
)	O
{	O
const	O
double	O
r	*(struct(double,double))
=	O
sqrt	(double)->(double)
(	O
q	double
)	O
;	O
result	*(struct(double,double))
->	O
val	double
=	O
series_eval	(double)->(double)
(	O
r	*(struct(double,double))
)	O
;	O
result	*(struct(double,double))
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
result	*(struct(double,double))
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
static	O
const	O
unsigned	O
int	O
MAX_ITERS	int
=	O
10	int
;	O
double	O
w	double
;	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
const	O
double	O
p	double
=	O
sqrt	(double)->(double)
(	O
2.0	int
*	O
M_E	int
*	O
q	double
)	O
;	O
w	double
=	O
-	O
1.0	int
+	O
p	double
*	O
(	O
1.0	int
+	O
p	double
*	O
(	O
-	O
1.0	int
/	O
3.0	int
+	O
p	double
*	O
11.0	int
/	O
72.0	int
)	O
)	O
;	O
}	O
else	O
{	O
w	double
=	O
log	(double)->(double)
(	O
x	double
)	O
;	O
if	O
(	O
x	double
>	O
3.0	int
)	O
w	double
-=	O
log	(double)->(double)
(	O
w	double
)	O
;	O
}	O
return	O
halley_iteration	(double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
w	double
,	O
MAX_ITERS	int
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
int	O
gsl_sf_lambert_Wm1_e	(double,*(struct(double,double)))->(int)
(	O
double	O
x	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
if	O
(	O
x	double
>	O
0.0	int
)	O
{	O
return	O
gsl_sf_lambert_W0_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
0.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
static	O
const	O
unsigned	O
int	O
MAX_ITERS	int
=	O
32	int
;	O
const	O
double	O
one_over_E	double
=	O
1.0	int
/	O
M_E	int
;	O
const	O
double	O
q	double
=	O
x	double
+	O
one_over_E	double
;	O
double	O
w	double
;	O
if	O
(	O
q	double
<	O
0.0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
-	O
1.0	int
;	O
result	*(struct(double,double))
->	O
err	double
=	O
sqrt	(double)->(double)
(	O
-	O
q	double
)	O
;	O
return	O
GSL_EDOM	int
;	O
}	O
if	O
(	O
x	double
<	O
-	O
1.0e-6	int
)	O
{	O
const	O
double	O
r	*(struct(double,double))
=	O
-	O
sqrt	(double)->(double)
(	O
q	double
)	O
;	O
w	double
=	O
series_eval	(double)->(double)
(	O
r	*(struct(double,double))
)	O
;	O
if	O
(	O
q	double
<	O
3.0e-3	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
w	double
;	O
result	*(struct(double,double))
->	O
err	double
=	O
5.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	(double)->(double)
(	O
w	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
else	O
{	O
const	O
double	O
L_1	double
=	O
log	(double)->(double)
(	O
-	O
x	double
)	O
;	O
const	O
double	O
L_2	double
=	O
log	(double)->(double)
(	O
-	O
L_1	double
)	O
;	O
w	double
=	O
L_1	double
-	O
L_2	double
+	O
L_2	double
/	O
L_1	double
;	O
}	O
return	O
halley_iteration	(double,double,int,*(struct(double,double)))->(int)
(	O
x	double
,	O
w	double
,	O
MAX_ITERS	int
,	O
result	*(struct(double,double))
)	O
;	O
}	O
}	O
double	O
gsl_sf_lambert_W0	(double)->(double)
(	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_lambert_W0_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_lambert_Wm1	(double)->(double)
(	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_lambert_Wm1_e	(double,*(struct(double,double)))->(int)
(	O
x	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
