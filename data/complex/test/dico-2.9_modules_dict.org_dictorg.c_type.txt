static	O
char	O
*	O
dbdir	*(char)
;	O
static	O
size_t	long
compare_count	long
;	O
static	O
int	O
sort_index	int
;	O
static	O
int	O
trim_ws	int
;	O
static	O
int	O
show_dictorg_entries	int
;	O
static	O
int	O
is_alnumspace	(int)->(int)
(	O
unsigned	O
c	int
)	O
{	O
return	O
utf8_wc_is_alnum	(int)->(int)
(	O
c	int
)	O
||	O
utf8_wc_is_space	(int)->(int)
(	O
c	int
)	O
;	O
}	O
static	O
inline	O
int	O
headword_compare	(*(char),*(char),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(int)
(	O
char	O
const	O
*	O
a	*(struct)
,	O
char	O
const	O
*	O
b	*(struct)
,	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
)	O
{	O
return	O
utf8_compare	(*(char),*(char),int,long,*((int)->(int)))->(int)
(	O
a	*(struct)
,	O
b	*(struct)
,	O
db	*(char)
->	O
flag_casesensitive	int
?	O
case_sensitive	int
:	O
case_insensitive	int
,	O
0	int
,	O
db	*(char)
->	O
flag_allchars	int
?	O
NULL	O
:	O
is_alnumspace	(int)->(int)
)	O
;	O
}	O
static	O
inline	O
int	O
headword_compare_allchars	(*(char),*(char),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),long)->(int)
(	O
char	O
const	O
*	O
a	*(struct)
,	O
char	O
const	O
*	O
b	*(struct)
,	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
size_t	long
len	int
)	O
{	O
return	O
utf8_compare	(*(char),*(char),int,long,*((int)->(int)))->(int)
(	O
a	*(struct)
,	O
b	*(struct)
,	O
db	*(char)
->	O
flag_casesensitive	int
?	O
case_sensitive	int
:	O
case_insensitive	int
,	O
len	int
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
compare_index_entry	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
epa	*(struct(*(char),*(char),long,long,long,long))
=	O
a	*(struct)
;	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
epb	*(struct(*(char),*(char),long,long,long,long))
=	O
b	*(struct)
;	O
compare_count	long
++	O
;	O
return	O
headword_compare	(*(char),*(char),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(int)
(	O
epa	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
epb	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
)	O
closure	*(void)
)	O
;	O
}	O
static	O
int	O
get_db_flag	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
char	O
*	O
name	*(char)
)	O
;	O
static	O
int	O
register_strategies	()->(int)
(	O
void	O
)	O
;	O
static	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
init_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
dbdir	*(char)
)	O
,	O
dico_opt_string	int
,	O
&	O
dbdir	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
sort	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
sort_index	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
trim	O
-	O
ws	*(int)
)	O
,	O
dico_opt_bool	int
,	O
&	O
trim_ws	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
show	O
-	O
dictorg	O
-	O
entries	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
show_dictorg_entries	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
mod_init	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
dico_parseopt	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),int,*(*(char)),int,*(int))->(int)
(	O
init_option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
dbdir	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
dbdir	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"mod_init: cannot stat `%s'"	*(char)
)	O
,	O
dbdir	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: `%s' is not a directory"	*(char)
)	O
,	O
dbdir	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
access	(*(char),int)->(int)
(	O
dbdir	*(char)
,	O
R_OK	int
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: `%s' is not readable"	*(char)
)	O
,	O
dbdir	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
register_strategies	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
dealloc_index_entry	(*(struct(*(char),*(char),long,long,long,long)))->(void)
(	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
ent	*(struct(*(char),*(char),long,long,long,long))
)	O
{	O
free	(*(void))->(void)
(	O
ent	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ent	*(struct(*(char),*(char),long,long,long,long))
->	O
orig	*(char)
)	O
;	O
}	O
static	O
void	O
free_db	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(void)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
)	O
{	O
size_t	long
i	long
;	O
dico_stream_close	(*(struct))->(int)
(	O
db	*(char)
->	O
stream	*(struct)
)	O
;	O
dico_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
db	*(char)
->	O
stream	*(struct)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
db	*(char)
->	O
numwords	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
.	O
word	*(char)
)	O
break	O
;	O
dealloc_index_entry	(*(struct(*(char),*(char),long,long,long,long)))->(void)
(	O
&	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
)	O
;	O
}	O
if	O
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
db	*(char)
->	O
numwords	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
[	O
i	long
]	O
.	O
word	*(char)
)	O
break	O
;	O
free	(*(void))->(void)
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
[	O
i	long
]	O
.	O
word	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
db	*(char)
->	O
index	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
db	*(char)
->	O
basename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
db	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
mkname	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
fname	*(char)
,	O
const	O
char	O
*	O
suf	*(char)
)	O
{	O
size_t	long
len	int
=	O
strlen	(*(char))->(long)
(	O
fname	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
suf	*(char)
)	O
+	O
1	int
;	O
char	O
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
=	O
malloc	(long)->(*(void))
(	O
len	int
)	O
;	O
if	O
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
,	O
fname	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
,	O
"."	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
,	O
suf	*(char)
)	O
;	O
}	O
return	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
;	O
}	O
static	O
int	O
b64_decode	(*(char),long,*(long))->(int)
(	O
const	O
char	O
*	O
val	*(char)
,	O
size_t	long
len	int
,	O
size_t	long
*	O
presult	*(long)
)	O
{	O
size_t	long
v	union(long,*(*(char)))
=	O
0	int
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	int
;	O
i	long
++	O
)	O
{	O
int	O
x	int
=	O
dico_base64_input	(int)->(int)
(	O
val	*(char)
[	O
i	long
]	O
)	O
;	O
if	O
(	O
x	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
v	union(long,*(*(char)))
<<=	O
6	int
;	O
v	union(long,*(*(char)))
|=	O
x	int
;	O
}	O
if	O
(	O
i	long
<	O
len	int
)	O
v	union(long,*(*(char)))
<<=	O
(	O
len	int
-	O
1	int
)	O
*	O
6	int
;	O
*	O
presult	*(long)
=	O
v	union(long,*(*(char)))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_index_entry	(*(char),long,*(struct),*(char),int)->(int)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
size_t	long
line	long
,	O
dico_list_t	*(struct)
list	array(*(struct))
,	O
char	O
*	O
buf	*(void)
,	O
int	O
tws	int
)	O
{	O
struct	O
utf8_iterator	struct(*(char),*(char),int,long,int,int)
itr	*((*(void),*(void))->(int))
;	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
idx	struct(*(char),*(char),long,long,long,long)
,	O
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
int	O
nfield	int
=	O
0	int
;	O
int	O
rc	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
itr	*((*(void),*(void))->(int))
,	O
0	int
,	O
sizeof	O
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
idx	struct(*(char),*(char),long,long,long,long)
,	O
0	int
,	O
sizeof	O
(	O
idx	struct(*(char),*(char),long,long,long,long)
)	O
)	O
;	O
utf8_iter_first	(*(struct(*(char),*(char),int,long,int,int)),*(char))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
,	O
buf	*(void)
)	O
;	O
rc	int
=	O
0	int
;	O
for	O
(	O
nfield	int
=	O
0	int
;	O
nfield	int
<	O
4	int
;	O
nfield	int
++	O
)	O
{	O
char	O
const	O
*	O
start	*(int)
;	O
char	O
const	O
*	O
end	int
;	O
size_t	long
len	int
;	O
if	O
(	O
nfield	int
)	O
{	O
for	O
(	O
;	O
!	O
utf8_iter_end_p	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
&&	O
utf8_iter_isascii	O
(	O
itr	*((*(void),*(void))->(int))
)	O
&&	O
ISWS	O
(	O
*	O
itr	*((*(void),*(void))->(int))
.	O
curptr	*(char)
)	O
;	O
utf8_iter_next	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
)	O
;	O
}	O
if	O
(	O
utf8_iter_end_p	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
)	O
break	O
;	O
start	*(int)
=	O
itr	*((*(void),*(void))->(int))
.	O
curptr	*(char)
;	O
for	O
(	O
;	O
!	O
utf8_iter_end_p	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
&&	O
!	O
(	O
utf8_iter_isascii	O
(	O
itr	*((*(void),*(void))->(int))
)	O
&&	O
*	O
itr	*((*(void),*(void))->(int))
.	O
curptr	*(char)
==	O
'\t'	O
)	O
;	O
utf8_iter_next	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
)	O
;	O
end	int
=	O
itr	*((*(void),*(void))->(int))
.	O
curptr	*(char)
;	O
len	int
=	O
end	int
-	O
start	*(int)
;	O
if	O
(	O
nfield	int
==	O
0	int
)	O
{	O
if	O
(	O
tws	int
)	O
{	O
while	O
(	O
len	int
>	O
0	int
&&	O
start	*(int)
[	O
len	int
-	O
1	int
]	O
==	O
' '	O
)	O
--	O
len	int
;	O
}	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
word	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
word	*(char)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
word	*(char)
,	O
start	*(int)
,	O
len	int
)	O
;	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
word	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
length	long
=	O
len	int
;	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
word	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
nfield	int
==	O
3	int
)	O
{	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
orig	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
orig	*(char)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
orig	*(char)
,	O
start	*(int)
,	O
len	int
)	O
;	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
orig	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
size_t	long
n	long
;	O
if	O
(	O
b64_decode	(*(char),long,*(long))->(int)
(	O
start	*(int)
,	O
len	int
,	O
&	O
n	long
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%lu: invalid base64 value: `%.*s'"	*(char)
)	O
,	O
filename	*(char)
,	O
(	O
unsigned	O
long	O
)	O
line	long
,	O
(	O
int	O
)	O
len	int
,	O
start	*(int)
)	O
;	O
rc	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
nfield	int
==	O
1	int
)	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
offset	long
=	O
n	long
;	O
else	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
size	long
=	O
n	long
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
utf8_iter_end_p	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%lu: malformed entry"	*(char)
)	O
,	O
filename	*(char)
,	O
(	O
unsigned	O
long	O
)	O
line	long
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
)	O
;	O
if	O
(	O
!	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
rc	int
)	O
free	(*(void))->(void)
(	O
idx	struct(*(char),*(char),long,long,long,long)
.	O
word	*(char)
)	O
;	O
else	O
{	O
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
idx	struct(*(char),*(char),long,long,long,long)
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
free_index_entry	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
item	*(void)
;	O
dealloc_index_entry	(*(struct(*(char),*(char),long,long,long,long)))->(void)
(	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
;	O
free	(*(void))->(void)
(	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
read_index	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),int)->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
char	O
*	O
idxname	*(char)
,	O
int	O
tws	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
rc	int
;	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
dico_stream_t	*(struct)
stream	*(struct)
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
idxname	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"open_index: cannot stat `%s'"	*(char)
)	O
,	O
idxname	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"open_index: `%s' is not a regular file"	*(char)
)	O
,	O
idxname	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
stream	*(struct)
=	O
dico_mapfile_stream_create	(*(char),int)->(*(struct))
(	O
idxname	*(char)
,	O
DICO_STREAM_READ	int
)	O
;	O
if	O
(	O
!	O
stream	*(struct)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot create stream `%s'"	*(char)
)	O
,	O
idxname	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
dico_stream_open	(*(struct))->(int)
(	O
stream	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot open stream `%s': %s"	*(char)
)	O
,	O
idxname	*(char)
,	O
dico_stream_strerror	(*(struct),int)->(*(char))
(	O
stream	*(struct)
,	O
rc	int
)	O
)	O
;	O
dico_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
}	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
list	array(*(struct))
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
dico_iterator_t	*(struct)
itr	*((*(void),*(void))->(int))
;	O
size_t	long
i	long
;	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
char	O
*	O
buf	*(void)
=	O
NULL	O
;	O
size_t	long
bufsize	long
=	O
0	int
;	O
size_t	long
rdsize	long
;	O
rc	int
=	O
0	int
;	O
i	long
=	O
0	int
;	O
while	O
(	O
!	O
dico_stream_getline	(*(struct),*(*(char)),*(long),*(long))->(int)
(	O
stream	*(struct)
,	O
&	O
buf	*(void)
,	O
&	O
bufsize	long
,	O
&	O
rdsize	long
)	O
)	O
{	O
i	long
++	O
;	O
dico_trim_nl	(*(char))->(long)
(	O
buf	*(void)
)	O
;	O
rc	int
=	O
parse_index_entry	(*(char),long,*(struct),*(char),int)->(int)
(	O
idxname	*(char)
,	O
i	long
,	O
list	array(*(struct))
,	O
buf	*(void)
,	O
tws	int
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	array(*(struct))
,	O
free_index_entry	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
db	*(char)
->	O
numwords	long
=	O
dico_list_count	(*(struct))->(long)
(	O
list	array(*(struct))
)	O
;	O
db	*(char)
->	O
index	*(int)
=	O
calloc	(long,long)->(*(void))
(	O
db	*(char)
->	O
numwords	long
,	O
sizeof	O
(	O
db	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
)	O
;	O
itr	*((*(void),*(void))->(int))
=	O
dico_list_iterator	(*(struct))->(*(struct))
(	O
list	array(*(struct))
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
dico_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
i	long
++	O
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
dico_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
=	O
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
free	(*(void))->(void)
(	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
;	O
}	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
}	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	array(*(struct))
)	O
;	O
}	O
dico_stream_close	(*(struct))->(int)
(	O
stream	*(struct)
)	O
;	O
dico_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
open_index	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),int)->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
int	O
tws	int
)	O
{	O
char	O
*	O
idxname	*(char)
=	O
mkname	(*(char),*(char))->(*(char))
(	O
db	*(char)
->	O
basename	*(char)
,	O
"index"	*(char)
)	O
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
idxname	*(char)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
read_index	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),int)->(int)
(	O
db	*(char)
,	O
idxname	*(char)
,	O
tws	int
)	O
;	O
free	(*(void))->(void)
(	O
idxname	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
mod_free_db	(*(struct))->(int)
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
)	O
hp	*(struct)
;	O
free_db	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(void)
(	O
db	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
open_stream	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
)	O
{	O
char	O
*	O
name	*(char)
;	O
static	O
char	O
*	O
suff	array(*(char))
[	O
]	O
=	O
{	O
"dict.dz"	*(char)
,	O
"dict"	*(char)
}	O
;	O
int	O
i	long
;	O
int	O
rc	int
;	O
dico_stream_t	*(struct)
str	*(struct)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
DICO_ARRAY_SIZE	O
(	O
suff	array(*(char))
)	O
;	O
i	long
++	O
)	O
{	O
name	*(char)
=	O
mkname	(*(char),*(char))->(*(char))
(	O
db	*(char)
->	O
basename	*(char)
,	O
suff	array(*(char))
[	O
i	long
]	O
)	O
;	O
if	O
(	O
access	(*(char),int)->(int)
(	O
name	*(char)
,	O
R_OK	int
)	O
==	O
0	int
)	O
{	O
str	*(struct)
=	O
dict_stream_create	(*(char),long)->(*(struct))
(	O
name	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
str	*(struct)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot create stream `%s'"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
continue	O
;	O
}	O
rc	int
=	O
dico_stream_open	(*(struct))->(int)
(	O
str	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot open stream `%s': %s"	*(char)
)	O
,	O
name	*(char)
,	O
dico_stream_strerror	(*(struct),int)->(*(char))
(	O
str	*(struct)
,	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
continue	O
;	O
}	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
db	*(char)
->	O
stream	*(struct)
=	O
str	*(struct)
;	O
return	O
0	int
;	O
}	O
}	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot open stream for dictionary `%s'"	*(char)
)	O
,	O
db	*(char)
->	O
basename	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
dico_handle_t	*(struct)
mod_init_db	(*(char),int,*(*(char)))->(*(struct))
(	O
const	O
char	O
*	O
dbname	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
;	O
char	O
*	O
filename	*(char)
=	O
NULL	O
;	O
int	O
sort_option	int
=	O
sort_index	int
;	O
int	O
trimws_option	int
=	O
trim_ws	int
;	O
int	O
show_dictorg_option	int
=	O
show_dictorg_entries	int
;	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
sort	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
sort_option	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
database	*(char)
)	O
,	O
dico_opt_const_string	int
,	O
&	O
filename	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
trim	O
-	O
ws	*(int)
)	O
,	O
dico_opt_bool	int
,	O
&	O
trimws_option	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
show	O
-	O
dictorg	O
-	O
entries	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
show_dictorg_option	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),int,*(*(char)),int,*(int))->(int)
(	O
option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
filename	*(char)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init_db(%s): database name not given"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
filename	*(char)
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
if	O
(	O
dbdir	*(char)
)	O
{	O
filename	*(char)
=	O
dico_full_file_name	(*(char),*(char))->(*(char))
(	O
dbdir	*(char)
,	O
filename	*(char)
)	O
;	O
}	O
else	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init_db: `%s' is not an absolute file name"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
filename	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
!	O
filename	*(char)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
db	*(char)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
db	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
db	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
db	*(char)
->	O
dbname	*(char)
=	O
dbname	*(char)
;	O
db	*(char)
->	O
basename	*(char)
=	O
filename	*(char)
;	O
db	*(char)
->	O
show_dictorg_entries	int
=	O
show_dictorg_option	int
;	O
db	*(char)
->	O
flag_allchars	int
=	O
1	int
;	O
if	O
(	O
open_index	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),int)->(int)
(	O
db	*(char)
,	O
trimws_option	int
)	O
)	O
{	O
free_db	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(void)
(	O
db	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
open_stream	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(int)
(	O
db	*(char)
)	O
)	O
{	O
free_db	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(void)
(	O
db	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
db	*(char)
->	O
flag_allchars	int
=	O
get_db_flag	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(int)
(	O
db	*(char)
,	O
DICTORG_FLAG_ALLCHARS	O
)	O
;	O
db	*(char)
->	O
flag_casesensitive	int
=	O
get_db_flag	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(int)
(	O
db	*(char)
,	O
DICTORG_FLAG_CASESENSITIVE	O
)	O
;	O
db	*(char)
->	O
flag_utf8	int
=	O
get_db_flag	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(int)
(	O
db	*(char)
,	O
DICTORG_FLAG_UTF8	O
)	O
;	O
db	*(char)
->	O
flag_8bit	int
=	O
get_db_flag	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(int)
(	O
db	*(char)
,	O
DICTORG_FLAG_8BIT_NEW	O
)	O
;	O
if	O
(	O
get_db_flag	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(int)
(	O
db	*(char)
,	O
DICTORG_FLAG_8BIT_OLD	O
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init_db(%s): index files in old 8-bit format are not supported"	*(char)
)	O
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
free_db	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(void)
(	O
db	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
sort_option	int
)	O
{	O
dico_sort	(*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
db	*(char)
->	O
index	*(int)
,	O
db	*(char)
->	O
numwords	long
,	O
sizeof	O
(	O
db	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
,	O
compare_index_entry	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
;	O
}	O
return	O
(	O
dico_handle_t	*(struct)
)	O
db	*(char)
;	O
}	O
static	O
void	O
revert_word	(*(char),*(char),long)->(void)
(	O
char	O
*	O
dst	*(char)
,	O
const	O
char	O
*	O
src	*(char)
,	O
size_t	long
len	int
)	O
{	O
struct	O
utf8_iterator	struct(*(char),*(char),int,long,int,int)
itr	*((*(void),*(void))->(int))
;	O
char	O
*	O
p	*(char)
=	O
dst	*(char)
+	O
len	int
;	O
*	O
p	*(char)
=	O
0	int
;	O
for	O
(	O
utf8_iter_init	(*(struct(*(char),*(char),int,long,int,int)),*(char),long)->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
,	O
(	O
char	O
*	O
)	O
src	*(char)
,	O
len	int
)	O
;	O
!	O
utf8_iter_end_p	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
utf8_iter_next	(*(struct(*(char),*(char),int,long,int,int)))->(int)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
p	*(char)
-=	O
itr	*((*(void),*(void))->(int))
.	O
curwidth	int
;	O
if	O
(	O
p	*(char)
<	O
dst	*(char)
)	O
break	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
,	O
itr	*((*(void),*(void))->(int))
.	O
curptr	*(char)
,	O
itr	*((*(void),*(void))->(int))
.	O
curwidth	int
)	O
;	O
}	O
}	O
static	O
int	O
compare_rev_entry	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
struct	O
rev_entry	struct(*(char),*(struct(*(char),*(char),long,long,long,long)))
const	O
*	O
epa	*(struct(*(char),*(char),long,long,long,long))
=	O
a	*(struct)
;	O
struct	O
rev_entry	struct(*(char),*(struct(*(char),*(char),long,long,long,long)))
const	O
*	O
epb	*(struct(*(char),*(char),long,long,long,long))
=	O
b	*(struct)
;	O
return	O
headword_compare_allchars	(*(char),*(char),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),long)->(int)
(	O
epa	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
epb	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
closure	*(void)
,	O
0	int
)	O
;	O
}	O
static	O
int	O
init_suffix_index	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
)	O
{	O
if	O
(	O
!	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
)	O
{	O
size_t	long
i	long
;	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
=	O
calloc	(long,long)->(*(void))
(	O
db	*(char)
->	O
numwords	long
,	O
sizeof	O
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
)	O
return	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
db	*(char)
->	O
numwords	long
;	O
i	long
++	O
)	O
{	O
char	O
*	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
.	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
while	O
(	O
i	long
>	O
0	int
)	O
free	(*(void))->(void)
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
[	O
--	O
i	long
]	O
.	O
word	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
)	O
;	O
return	O
1	int
;	O
}	O
revert_word	(*(char),*(char),long)->(void)
(	O
p	*(char)
,	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
.	O
word	*(char)
,	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
.	O
length	long
)	O
;	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
[	O
i	long
]	O
.	O
word	*(char)
=	O
p	*(char)
;	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
[	O
i	long
]	O
.	O
ptr	*(void)
=	O
&	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
;	O
}	O
dico_sort	(*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
,	O
db	*(char)
->	O
numwords	long
,	O
sizeof	O
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
[	O
0	int
]	O
)	O
,	O
compare_rev_entry	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
exact_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	*(int)
*	O
)	O
;	O
static	O
int	O
prefix_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	*(int)
*	O
)	O
;	O
static	O
int	O
suffix_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
,	O
const	O
char	O
*	O
,	O
struct	O
result	*(int)
*	O
)	O
;	O
static	O
struct	O
strategy_def	struct(struct(*(char),*(char),*((int,*(struct(*`,*`,*`,int)),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int)))
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int))))
[	O
]	O
=	O
{	O
{	O
{	O
"exact"	*(char)
,	O
"Match words exactly"	*(char)
}	O
,	O
exact_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
}	O
,	O
{	O
{	O
"prefix"	*(char)
,	O
"Match word prefixes"	*(char)
}	O
,	O
prefix_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
}	O
,	O
{	O
{	O
"suffix"	*(char)
,	O
"Match word suffixes"	*(char)
}	O
,	O
suffix_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
}	O
}	O
;	O
static	O
entry_match_t	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
find_matcher	(*(char))->(*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int)))
(	O
const	O
char	O
*	O
strat	*(struct)
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
DICO_ARRAY_SIZE	O
(	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int))))
)	O
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
strat	*(struct)
,	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int))))
[	O
i	long
]	O
.	O
strat	*(struct)
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int))))
[	O
i	long
]	O
.	O
match	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
register_strategies	()->(int)
(	O
void	O
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
DICO_ARRAY_SIZE	O
(	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int))))
)	O
;	O
i	long
++	O
)	O
dico_strategy_add	(*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))))->(int)
(	O
&	O
strat_tab	array(struct(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct)),*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int))))
[	O
i	long
]	O
.	O
strat	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
compare_entry_ptr	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
epa	*(struct(*(char),*(char),long,long,long,long))
=	O
*	O
(	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
*	O
)	O
a	*(struct)
;	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
epb	*(struct(*(char),*(char),long,long,long,long))
=	O
*	O
(	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
*	O
)	O
b	*(struct)
;	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
closure	*(void)
;	O
return	O
headword_compare_allchars	(*(char),*(char),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),long)->(int)
(	O
epa	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
epb	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
db	*(char)
,	O
0	int
)	O
;	O
}	O
static	O
int	O
uniq_comp	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
epa	*(struct(*(char),*(char),long,long,long,long))
=	O
a	*(struct)
;	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
epb	*(struct(*(char),*(char),long,long,long,long))
=	O
b	*(struct)
;	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
closure	*(void)
;	O
return	O
headword_compare	(*(char),*(char),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(int)
(	O
epa	*(struct(*(char),*(char),long,long,long,long))
->	O
orig	*(char)
?	O
epa	*(struct(*(char),*(char),long,long,long,long))
->	O
orig	*(char)
:	O
epa	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
epb	*(struct(*(char),*(char),long,long,long,long))
->	O
orig	*(char)
?	O
epb	*(struct(*(char),*(char),long,long,long,long))
->	O
orig	*(char)
:	O
epb	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
db	*(char)
)	O
;	O
}	O
static	O
int	O
common_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*((*(void),*(void),*(void))->(int)),int,*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
int	O
(	O
*	O
compare	*((*(void),*(void),*(void))->(int))
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
int	O
unique	int
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
{	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
x	int
,	O
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
x	int
.	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
word	*(char)
;	O
x	int
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
x	int
.	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
compare_count	long
=	O
0	int
;	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
dico_bsearch	(*(void),*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(*(void))
(	O
&	O
x	int
,	O
db	*(char)
->	O
index	*(int)
,	O
db	*(char)
->	O
numwords	long
,	O
sizeof	O
(	O
db	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
,	O
compare	*((*(void),*(void),*(void))->(int))
,	O
db	*(char)
)	O
;	O
if	O
(	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
{	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
type	enum(int,int,int)
=	O
result_match	int
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
db	*(char)
=	O
db	*(char)
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
itr	*((*(void),*(void))->(int))
=	O
NULL	O
;	O
if	O
(	O
unique	int
)	O
{	O
dico_list_set_comparator	(*(struct),*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
,	O
uniq_comp	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
;	O
dico_list_set_flags	(*(struct),int)->(int)
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
,	O
DICO_LIST_COMPARE_TAIL	int
)	O
;	O
}	O
for	O
(	O
;	O
ep	*(struct(*(char),*(char),long,long,long,long))
<	O
db	*(char)
->	O
index	*(int)
+	O
db	*(char)
->	O
numwords	long
&&	O
compare	*((*(void),*(void),*(void))->(int))
(	O
&	O
x	int
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
,	O
db	*(char)
)	O
==	O
0	int
;	O
ep	*(struct(*(char),*(char),long,long,long,long))
++	O
)	O
if	O
(	O
!	O
RESERVED_WORD	O
(	O
db	*(char)
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
)	O
)	O
dico_list_append	(*(struct),*(void))->(int)
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
exact_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
{	O
return	O
common_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*((*(void),*(void),*(void))->(int)),int,*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
db	*(char)
,	O
word	*(char)
,	O
compare_index_entry	(*(void),*(void),*(void))->(int)
,	O
0	int
,	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
;	O
}	O
static	O
int	O
compare_prefix	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
pkey	*(struct(*(char),*(char),long,long,long,long))
=	O
a	*(struct)
;	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
pelt	*(struct(*(char),*(char),long,long,long,long))
=	O
b	*(struct)
;	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
closure	*(void)
;	O
size_t	long
wordlen	long
=	O
pkey	*(struct(*(char),*(char),long,long,long,long))
->	O
wordlen	long
;	O
compare_count	long
++	O
;	O
if	O
(	O
pelt	*(struct(*(char),*(char),long,long,long,long))
->	O
wordlen	long
<	O
wordlen	long
)	O
return	O
-	O
1	int
;	O
return	O
headword_compare_allchars	(*(char),*(char),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),long)->(int)
(	O
pkey	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
pelt	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
db	*(char)
,	O
wordlen	long
)	O
;	O
}	O
static	O
int	O
prefix_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
{	O
return	O
common_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*((*(void),*(void),*(void))->(int)),int,*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
db	*(char)
,	O
word	*(char)
,	O
compare_prefix	(*(void),*(void),*(void))->(int)
,	O
1	int
,	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
;	O
}	O
static	O
int	O
compare_rev_prefix	(*(void),*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(struct)
,	O
const	O
void	O
*	O
b	*(struct)
,	O
void	O
*	O
closure	*(void)
)	O
{	O
const	O
struct	O
rev_entry	struct(*(char),*(struct(*(char),*(char),long,long,long,long)))
*	O
pkey	*(struct(*(char),*(char),long,long,long,long))
=	O
a	*(struct)
;	O
const	O
struct	O
rev_entry	struct(*(char),*(struct(*(char),*(char),long,long,long,long)))
*	O
pelt	*(struct(*(char),*(char),long,long,long,long))
=	O
b	*(struct)
;	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
closure	*(void)
;	O
size_t	long
wordlen	long
=	O
pkey	*(struct(*(char),*(char),long,long,long,long))
->	O
ptr	*(void)
->	O
wordlen	long
;	O
if	O
(	O
pelt	*(struct(*(char),*(char),long,long,long,long))
->	O
ptr	*(void)
->	O
wordlen	long
<	O
wordlen	long
)	O
wordlen	long
=	O
pelt	*(struct(*(char),*(char),long,long,long,long))
->	O
ptr	*(void)
->	O
wordlen	long
;	O
compare_count	long
++	O
;	O
return	O
headword_compare_allchars	(*(char),*(char),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),long)->(int)
(	O
pkey	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
pelt	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
,	O
db	*(char)
,	O
wordlen	long
)	O
;	O
}	O
static	O
int	O
suffix_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
char	O
*	O
word	*(char)
,	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
{	O
struct	O
rev_entry	struct(*(char),*(struct(*(char),*(char),long,long,long,long)))
x	int
,	O
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
ent	*(struct(*(char),*(char),long,long,long,long))
;	O
int	O
rc	int
;	O
if	O
(	O
init_suffix_index	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))))->(int)
(	O
db	*(char)
)	O
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
ent	*(struct(*(char),*(char),long,long,long,long))
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
x	int
.	O
word	*(char)
=	O
malloc	(long)->(*(void))
(	O
ent	*(struct(*(char),*(char),long,long,long,long))
.	O
length	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
x	int
.	O
word	*(char)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
ent	*(struct(*(char),*(char),long,long,long,long))
.	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
word	*(char)
)	O
;	O
revert_word	(*(char),*(char),long)->(void)
(	O
x	int
.	O
word	*(char)
,	O
word	*(char)
,	O
ent	*(struct(*(char),*(char),long,long,long,long))
.	O
length	long
)	O
;	O
x	int
.	O
ptr	*(void)
=	O
&	O
ent	*(struct(*(char),*(char),long,long,long,long))
;	O
compare_count	long
=	O
0	int
;	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
dico_bsearch	(*(void),*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(*(void))
(	O
&	O
x	int
,	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
,	O
db	*(char)
->	O
numwords	long
,	O
sizeof	O
(	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
[	O
0	int
]	O
)	O
,	O
compare_rev_prefix	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
;	O
if	O
(	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
{	O
struct	O
rev_entry	struct(*(char),*(struct(*(char),*(char),long,long,long,long)))
*	O
p	*(char)
;	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
*	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
;	O
size_t	long
i	long
;	O
size_t	long
count	long
=	O
0	int
;	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
for	O
(	O
p	*(char)
=	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
p	*(char)
<	O
db	*(char)
->	O
suf_index	*(struct(*(char),*(struct(*(char),*(char),long,long,long,long))))
+	O
db	*(char)
->	O
numwords	long
&&	O
compare_rev_prefix	(*(void),*(void),*(void))->(int)
(	O
&	O
x	int
,	O
p	*(char)
,	O
db	*(char)
)	O
==	O
0	int
;	O
p	*(char)
++	O
)	O
count	long
++	O
;	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
=	O
calloc	(long,long)->(*(void))
(	O
count	long
,	O
sizeof	O
(	O
*	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
)	O
)	O
;	O
if	O
(	O
!	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
x	int
.	O
word	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
RESERVED_WORD	O
(	O
db	*(char)
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
[	O
i	long
]	O
.	O
ptr	*(void)
->	O
word	*(char)
)	O
)	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
[	O
i	long
]	O
=	O
ep	*(struct(*(char),*(char),long,long,long,long))
[	O
i	long
]	O
.	O
ptr	*(void)
;	O
count	long
=	O
i	long
;	O
dico_sort	(*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
,	O
count	long
,	O
sizeof	O
(	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
[	O
0	int
]	O
)	O
,	O
compare_entry_ptr	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
;	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
list	array(*(struct))
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
x	int
.	O
word	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
)	O
;	O
return	O
1	int
;	O
}	O
dico_list_set_comparator	(*(struct),*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
list	array(*(struct))
,	O
uniq_comp	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
;	O
dico_list_set_flags	(*(struct),int)->(int)
(	O
list	array(*(struct))
,	O
DICO_LIST_COMPARE_TAIL	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
;	O
i	long
++	O
)	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
,	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
[	O
i	long
]	O
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(*(struct(*(char),*(char),long,long,long,long)))
)	O
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
type	enum(int,int,int)
=	O
result_match	int
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
=	O
list	array(*(struct))
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
itr	*((*(void),*(void))->(int))
=	O
NULL	O
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
compare_count	long
=	O
compare_count	long
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
rc	int
=	O
1	int
;	O
free	(*(void))->(void)
(	O
x	int
.	O
word	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
char	O
*	O
find_db_entry	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(*(char))
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
x	int
;	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
char	O
*	O
buf	*(void)
;	O
int	O
rc	int
;	O
x	int
.	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
name	*(char)
;	O
x	int
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
x	int
.	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
dico_bsearch	(*(void),*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(*(void))
(	O
&	O
x	int
,	O
db	*(char)
->	O
index	*(int)
,	O
db	*(char)
->	O
numwords	long
,	O
sizeof	O
(	O
db	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
,	O
compare_index_entry	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
;	O
if	O
(	O
!	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
return	O
NULL	O
;	O
buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf	*(void)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
dico_stream_seek	(*(struct),long,int)->(long)
(	O
db	*(char)
->	O
stream	*(struct)
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
offset	long
,	O
DICO_SEEK_SET	int
)	O
;	O
rc	int
=	O
dico_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
db	*(char)
->	O
stream	*(struct)
,	O
buf	*(void)
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: read error: %s"	*(char)
)	O
,	O
db	*(char)
->	O
basename	*(char)
,	O
dico_stream_strerror	(*(struct),int)->(*(char))
(	O
db	*(char)
->	O
stream	*(struct)
,	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
buf	*(void)
=	O
NULL	O
;	O
}	O
else	O
buf	*(void)
[	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
size	long
]	O
=	O
0	int
;	O
return	O
buf	*(void)
;	O
}	O
static	O
int	O
get_db_flag	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(int)
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
x	int
;	O
x	int
.	O
word	*(char)
=	O
(	O
char	O
*	O
)	O
name	*(char)
;	O
x	int
.	O
length	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
x	int
.	O
wordlen	long
=	O
utf8_strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
return	O
dico_bsearch	(*(void),*(void),long,long,*((*(void),*(void),*(void))->(int)),*(void))->(*(void))
(	O
&	O
x	int
,	O
db	*(char)
->	O
index	*(int)
,	O
db	*(char)
->	O
numwords	long
,	O
sizeof	O
(	O
db	*(char)
->	O
index	*(int)
[	O
0	int
]	O
)	O
,	O
compare_index_entry	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
!=	O
NULL	O
;	O
}	O
static	O
char	O
*	O
mod_info	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
)	O
hp	*(struct)
;	O
return	O
find_db_entry	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(*(char))
(	O
db	*(char)
,	O
DICTORG_INFO_ENTRY_NAME	O
)	O
;	O
}	O
static	O
char	O
*	O
mod_descr	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
)	O
hp	*(struct)
;	O
char	O
*	O
ptr	*(void)
=	O
find_db_entry	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(*(char))
(	O
db	*(char)
,	O
DICTORG_SHORT_ENTRY_NAME	O
)	O
;	O
if	O
(	O
ptr	*(void)
)	O
{	O
size_t	long
len	int
=	O
dico_trim_nl	(*(char))->(long)
(	O
ptr	*(void)
)	O
;	O
if	O
(	O
len	int
>=	O
sizeof	O
(	O
DICTORG_SHORT_ENTRY_NAME	O
)	O
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
ptr	*(void)
,	O
DICTORG_SHORT_ENTRY_NAME	O
"\n"	*(char)
,	O
sizeof	O
(	O
DICTORG_SHORT_ENTRY_NAME	O
)	O
)	O
==	O
0	int
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
sizeof	O
(	O
DICTORG_SHORT_ENTRY_NAME	O
)	O
;	O
ptr	*(void)
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
ptr	*(void)
[	O
i	long
]	O
)	O
)	O
break	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
ptr	*(void)
,	O
ptr	*(void)
+	O
i	long
,	O
len	int
-	O
i	long
+	O
1	int
)	O
;	O
}	O
}	O
return	O
ptr	*(void)
;	O
}	O
static	O
char	O
*	O
mod_mime_header	(*(struct))->(*(char))
(	O
dico_handle_t	*(struct)
hp	*(struct)
)	O
{	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
)	O
hp	*(struct)
;	O
return	O
find_db_entry	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char))->(*(char))
(	O
db	*(char)
,	O
DICTORG_ENTRY_MIME_HEADER	O
)	O
;	O
}	O
static	O
dico_result_t	*(struct)
_match_simple	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int)),*(char))->(*(struct))
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
entry_match_t	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
match	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
)	O
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
return	O
NULL	O
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
db	*(char)
=	O
db	*(char)
;	O
if	O
(	O
match	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
(	O
db	*(char)
,	O
word	*(char)
,	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
)	O
{	O
free	(*(void))->(void)
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
=	O
NULL	O
;	O
}	O
else	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
;	O
}	O
static	O
dico_result_t	*(struct)
_match_all	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
dico_strategy_t	*(struct)
strat	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
size_t	long
count	long
,	O
i	long
;	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
;	O
struct	O
dico_key	struct(*(char),*(void),*(struct(*(char),*(char),*((int,*(struct`),*(char))->(int)),*(void),int,*(struct))),int)
key	*(char)
;	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
list	array(*(struct))
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
dico_list_set_comparator	(*(struct),*((*(void),*(void),*(void))->(int)),*(void))->(int)
(	O
list	array(*(struct))
,	O
uniq_comp	(*(void),*(void),*(void))->(int)
,	O
db	*(char)
)	O
;	O
dico_list_set_flags	(*(struct),int)->(int)
(	O
list	array(*(struct))
,	O
DICO_LIST_COMPARE_TAIL	int
)	O
;	O
if	O
(	O
dico_key_init	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(int)
(	O
&	O
key	*(char)
,	O
strat	*(struct)
,	O
word	*(char)
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"_match_all: key initialization failed"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
db	*(char)
->	O
numwords	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
RESERVED_WORD	O
(	O
db	*(char)
,	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
.	O
word	*(char)
)	O
&&	O
dico_key_match	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)),*(char))->(int)
(	O
&	O
key	*(char)
,	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
.	O
word	*(char)
)	O
)	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
,	O
&	O
db	*(char)
->	O
index	*(int)
[	O
i	long
]	O
)	O
;	O
dico_key_deinit	(*(struct(*(char),*(void),*(struct(*`,*`,*`,*`,int,*`)),int)))->(void)
(	O
&	O
key	*(char)
)	O
;	O
compare_count	long
=	O
db	*(char)
->	O
numwords	long
;	O
count	long
=	O
dico_list_count	(*(struct))->(long)
(	O
list	array(*(struct))
)	O
;	O
if	O
(	O
count	long
==	O
0	int
)	O
{	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	array(*(struct))
)	O
;	O
return	O
NULL	O
;	O
}	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
)	O
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
return	O
NULL	O
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
db	*(char)
=	O
db	*(char)
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
type	enum(int,int,int)
=	O
result_match	int
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
=	O
list	array(*(struct))
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
itr	*((*(void),*(void))->(int))
=	O
NULL	O
;	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
compare_count	long
=	O
compare_count	long
;	O
return	O
(	O
dico_result_t	*(struct)
)	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
;	O
}	O
static	O
dico_result_t	*(struct)
mod_match	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
const	O
dico_strategy_t	*(struct)
strat	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
)	O
hp	*(struct)
;	O
entry_match_t	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
match	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
;	O
if	O
(	O
RESERVED_WORD	O
(	O
db	*(char)
,	O
word	*(char)
)	O
)	O
return	O
NULL	O
;	O
match	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
=	O
find_matcher	(*(char))->(*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int)))
(	O
strat	*(struct)
->	O
name	*(char)
)	O
;	O
if	O
(	O
match	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
)	O
return	O
_match_simple	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*((*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),*(char),*(struct(*`,enum(int,int),long,*`,*`)))->(int)),*(char))->(*(struct))
(	O
db	*(char)
,	O
match	*((*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),*(char),*(struct(*(struct`),enum(int,int),long,*(struct`),*(struct`))))->(int))
,	O
word	*(char)
)	O
;	O
else	O
if	O
(	O
strat	*(struct)
->	O
sel	*((*(char),*(void))->(int))
)	O
return	O
_match_all	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
(	O
db	*(char)
,	O
strat	*(struct)
,	O
word	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
dico_result_t	*(struct)
mod_define	(*(struct),*(char))->(*(struct))
(	O
dico_handle_t	*(struct)
hp	*(struct)
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
=	O
(	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
)	O
hp	*(struct)
;	O
struct	O
result	*(int)
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
,	O
*	O
rp	*(struct)
;	O
int	O
rc	int
;	O
if	O
(	O
RESERVED_WORD	O
(	O
db	*(char)
,	O
word	*(char)
)	O
)	O
return	O
NULL	O
;	O
rc	int
=	O
common_match	(*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(char),*((*(void),*(void),*(void))->(int)),int,*(struct(*(struct(*`,*`,int,int,int,int,long,*`,*`,int,*`)),enum(int,int),long,*(struct),*(struct))))->(int)
(	O
db	*(char)
,	O
word	*(char)
,	O
compare_index_entry	(*(void),*(void),*(void))->(int)
,	O
0	int
,	O
&	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
NULL	O
;	O
rp	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
rp	*(struct)
)	O
)	O
;	O
if	O
(	O
!	O
rp	*(struct)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
.	O
list	array(*(struct))
)	O
;	O
return	O
NULL	O
;	O
}	O
*	O
rp	*(struct)
=	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
;	O
rp	*(struct)
->	O
type	enum(int,int,int)
=	O
result_define	int
;	O
return	O
(	O
dico_result_t	*(struct)
)	O
rp	*(struct)
;	O
}	O
static	O
void	O
printdef	(*(struct),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(struct(*(char),*(char),long,long,long,long)))->(void)
(	O
dico_stream_t	*(struct)
str	*(struct)
,	O
struct	O
dictdb	struct(*(char),*(char),int,int,int,int,long,*(struct(*(char),*(char),long,long,long,long)),*(struct(*(char),*(struct(*(char),*(char),long,long,long,long)))),int,*(struct))
*	O
db	*(char)
,	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
{	O
size_t	long
size	long
=	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
size	long
;	O
char	O
buf	*(void)
[	O
128	int
]	O
;	O
int	O
rc	int
;	O
if	O
(	O
dico_stream_seek	(*(struct),long,int)->(long)
(	O
db	*(char)
->	O
stream	*(struct)
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
offset	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: seek error: %s"	*(char)
)	O
,	O
db	*(char)
->	O
basename	*(char)
,	O
dico_stream_strerror	(*(struct),int)->(*(char))
(	O
db	*(char)
->	O
stream	*(struct)
,	O
dico_stream_last_error	(*(struct))->(int)
(	O
db	*(char)
->	O
stream	*(struct)
)	O
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
size	long
)	O
{	O
size_t	long
rdsize	long
=	O
size	long
;	O
if	O
(	O
rdsize	long
>	O
sizeof	O
(	O
buf	*(void)
)	O
)	O
rdsize	long
=	O
sizeof	O
(	O
buf	*(void)
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
dico_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
db	*(char)
->	O
stream	*(struct)
,	O
buf	*(void)
,	O
rdsize	long
,	O
NULL	O
)	O
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: read error: %s"	*(char)
)	O
,	O
db	*(char)
->	O
basename	*(char)
,	O
dico_stream_strerror	(*(struct),int)->(*(char))
(	O
db	*(char)
->	O
stream	*(struct)
,	O
rc	int
)	O
)	O
;	O
break	O
;	O
}	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
buf	*(void)
,	O
rdsize	long
)	O
;	O
size	long
-=	O
rdsize	long
;	O
}	O
}	O
static	O
int	O
mod_output_result	(*(struct),long,*(struct))->(int)
(	O
dico_result_t	*(struct)
rp	*(struct)
,	O
size_t	long
n	long
,	O
dico_stream_t	*(struct)
str	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
const	O
struct	O
index_entry	struct(*(char),*(char),long,long,long,long)
*	O
ep	*(struct(*(char),*(char),long,long,long,long))
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
itr	*((*(void),*(void))->(int))
)	O
{	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
itr	*((*(void),*(void))->(int))
=	O
dico_list_iterator	(*(struct))->(*(struct))
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
)	O
;	O
if	O
(	O
!	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
itr	*((*(void),*(void))->(int))
)	O
return	O
1	int
;	O
}	O
ep	*(struct(*(char),*(char),long,long,long,long))
=	O
dico_iterator_item	(*(struct),long)->(*(void))
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
itr	*((*(void),*(void))->(int))
,	O
n	long
)	O
;	O
switch	O
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
result_match	int
:	O
{	O
char	O
*	O
headword	*(char)
=	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
orig	*(char)
?	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
orig	*(char)
:	O
ep	*(struct(*(char),*(char),long,long,long,long))
->	O
word	*(char)
;	O
dico_stream_write	(*(struct),*(void),long)->(int)
(	O
str	*(struct)
,	O
headword	*(char)
,	O
strlen	(*(char))->(long)
(	O
headword	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
case	O
result_define	int
:	O
printdef	(*(struct),*(struct(*(char),*(char),int,int,int,int,long,*(struct(*`,*`,long,long,long,long)),*(struct(*`,*`)),int,*(struct))),*(struct(*(char),*(char),long,long,long,long)))->(void)
(	O
str	*(struct)
,	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
db	*(char)
,	O
ep	*(struct(*(char),*(char),long,long,long,long))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	long
mod_result_count	(*(struct))->(long)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
return	O
dico_list_count	(*(struct))->(long)
(	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
)	O
;	O
}	O
static	O
size_t	long
mod_compare_count	(*(struct))->(long)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
return	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
compare_count	long
;	O
}	O
static	O
void	O
mod_free_result	(*(struct))->(void)
(	O
dico_result_t	*(struct)
rp	*(struct)
)	O
{	O
struct	O
result	*(int)
*	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
=	O
(	O
struct	O
result	*(int)
*	O
)	O
rp	*(struct)
;	O
dico_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
itr	*((*(void),*(void))->(int))
)	O
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
res	*(struct(*(struct(*(char),*(char),int,int,int,int,long,*(struct`),*(struct`),int,*(struct`))),enum(int,int),long,*(struct),*(struct)))
->	O
list	array(*(struct))
)	O
;	O
free	(*(void))->(void)
(	O
rp	*(struct)
)	O
;	O
}	O
struct	O
dico_database_module	struct(int,int,*((int,*(*(char)))->(int)),*((*(char),int,*(*(char)))->(*(struct))),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(*(char))),*((*(struct))->(*(char))),*((*(struct),array(*(struct)))->(int)),*((*(struct),*(struct),*(char))->(*(struct))),*((*(struct),*(char))->(*(struct))),*((*(struct),long,*(struct))->(int)),*((*(struct))->(long)),*((*(struct))->(long)),*((*(struct))->(void)),*((*(struct),*(struct))->(int)),*((int,*(*(char)))->(int)),*((*(struct))->(*(char))),*((*(char),int,*(*(char)),*(void))->(*(struct))),*((*(struct))->(int)),*((*(struct),long)->(*(struct))))
DICO_EXPORT	O
(	O
dictorg	O
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NONE	int
,	O
.	O
dico_init	*((int,*(*(char)))->(int))
=	O
mod_init	(int,*(*(char)))->(int)
,	O
.	O
dico_init_db	*((*(char),int,*(*(char)))->(*(struct)))
=	O
mod_init_db	(*(char),int,*(*(char)))->(*(struct))
,	O
.	O
dico_free_db	*((*(struct))->(int))
=	O
mod_free_db	(*(struct))->(int)
,	O
.	O
dico_db_info	*((*(struct))->(*(char)))
=	O
mod_info	(*(struct))->(*(char))
,	O
.	O
dico_db_descr	*((*(struct))->(*(char)))
=	O
mod_descr	(*(struct))->(*(char))
,	O
.	O
dico_match	*((*(struct),*(struct),*(char))->(*(struct)))
=	O
mod_match	(*(struct),*(struct(*(char),*(char),*((int,*`,*`)->(int)),*(void),int,*(struct))),*(char))->(*(struct))
,	O
.	O
dico_define	*((*(struct),*(char))->(*(struct)))
=	O
mod_define	(*(struct),*(char))->(*(struct))
,	O
.	O
dico_output_result	*((*(struct),long,*(struct))->(int))
=	O
mod_output_result	(*(struct),long,*(struct))->(int)
,	O
.	O
dico_result_count	*((*(struct))->(long))
=	O
mod_result_count	(*(struct))->(long)
,	O
.	O
dico_compare_count	*((*(struct))->(long))
=	O
mod_compare_count	(*(struct))->(long)
,	O
.	O
dico_free_result	*((*(struct))->(void))
=	O
mod_free_result	(*(struct))->(void)
,	O
.	O
dico_db_mime_header	*((*(struct))->(*(char)))
=	O
mod_mime_header	(*(struct))->(*(char))
}	O
;	O
