void	O
*	O
server_loop	(*(void))->(*(void))
(	O
void	O
*	O
arg	*(void)
)	O
{	O
int	O
fd	int
=	O
(	O
int	O
)	O
arg	*(void)
;	O
char	O
buf	array(char)
[	O
MAXIOSIZE	int
]	O
;	O
int	O
xid	int
;	O
int	O
*	O
p	*(int)
,	O
*	O
r	*(int)
;	O
char	O
*	O
rbuf	*(char)
;	O
struct	O
cached_reply	struct(*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char))),*(*(struct(*(struct(*`,*`,union`,struct`,int,long,int,long,*`)),*(*(struct`)),union(struct(int,int,int,int,int,short,short,struct`),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))),union(struct(int,int,int,int,int,short,short,struct(*(struct(*`,*`)),*(struct(*`,*`)))),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char))
*	O
cr	*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))
;	O
int	O
program	int
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
sender	struct(short,short,struct(int),array(char))
;	O
int	O
version	int
;	O
int	O
procedure	struct(*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)
;	O
struct	O
proctable	struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)))
*	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
=	O
0	int
;	O
struct	O
procedure	struct(*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)
*	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
;	O
struct	O
idspec	struct(*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int)),*(*(struct(*(struct(*`,*`,int,int,*`,*`,long,int)),*(*(struct`)),int,int,*(int),*(int),long,int))),int,int,*(int),*(int),long,int)
*	O
cred	*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int))
;	O
struct	O
cache_handle	struct(*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int)),*(*(struct(*(struct(*`,*`,union`,*`,int,long,int)),*(*(struct`)),union(array(char),int),*(struct(*`,*`,int,int,*`,*`,long,int)),int,long,int))),union(array(char),int),*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int)),int,long,int)
*	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
,	O
fakec	struct(*(struct(*(struct(*`,*`,union`,*`,int,long,int)),*(*(struct`)),union(array(char),int),*(struct(*`,*`,int,int,*`,*`,long,int)),int,long,int)),*(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int))),union(array(char),int),*(struct(*(struct(*`,*`,int,int,*`,*`,long,int)),*(*(struct`)),int,int,*(int),*(int),long,int)),int,long,int)
;	O
error_t	int
err	long
;	O
socklen_t	int
addrlen	int
;	O
int	O
cc	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
fakec	struct(*(struct(*(struct(*`,*`,union`,*`,int,long,int)),*(*(struct`)),union(array(char),int),*(struct(*`,*`,int,int,*`,*`,long,int)),int,long,int)),*(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int))),union(array(char),int),*(struct(*(struct(*`,*`,int,int,*`,*`,long,int)),*(*(struct`)),int,int,*(int),*(int),long,int)),int,long,int)
,	O
0	int
,	O
sizeof	O
(	O
struct	O
cache_handle	struct(*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int)),*(*(struct(*(struct(*`,*`,union`,*`,int,long,int)),*(*(struct`)),union(array(char),int),*(struct(*`,*`,int,int,*`,*`,long,int)),int,long,int))),union(array(char),int),*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int)),int,long,int)
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
p	*(int)
=	O
(	O
int	O
*	O
)	O
buf	array(char)
;	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
=	O
0	int
;	O
addrlen	int
=	O
sizeof	O
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
)	O
;	O
cc	int
=	O
recvfrom	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(long)
(	O
fd	int
,	O
buf	array(char)
,	O
MAXIOSIZE	int
,	O
0	int
,	O
&	O
sender	struct(short,short,struct(int),array(char))
,	O
&	O
addrlen	int
)	O
;	O
if	O
(	O
cc	int
==	O
-	O
1	int
)	O
continue	O
;	O
xid	int
=	O
*	O
(	O
p	*(int)
++	O
)	O
;	O
if	O
(	O
ntohl	(int)->(int)
(	O
*	O
p	*(int)
)	O
!=	O
CALL	O
)	O
continue	O
;	O
p	*(int)
++	O
;	O
cr	*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))
=	O
check_cached_replies	(int,*(struct(short,short,struct(int),array(char))))->(*(struct(*(struct(*`,*`,union`,struct`,int,long,int,long,*`)),*(*(struct`)),union(struct(int,int,int,int,int,short,short,struct`),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char))))
(	O
xid	int
,	O
&	O
sender	struct(short,short,struct(int),array(char))
)	O
;	O
if	O
(	O
cr	*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))
->	O
data	*(char)
)	O
goto	O
repost_reply	O
;	O
r	*(int)
=	O
(	O
int	O
*	O
)	O
(	O
rbuf	*(char)
=	O
malloc	(long)->(*(void))
(	O
MAXIOSIZE	int
)	O
)	O
;	O
if	O
(	O
ntohl	(int)->(int)
(	O
*	O
p	*(int)
)	O
!=	O
RPC_MSG_VERSION	O
)	O
{	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
MSG_DENIED	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
RPC_MISMATCH	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
RPC_MSG_VERSION	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
RPC_MSG_VERSION	O
)	O
;	O
goto	O
send_reply	O
;	O
}	O
p	*(int)
++	O
;	O
program	int
=	O
ntohl	(int)->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
switch	O
(	O
program	int
)	O
{	O
case	O
MOUNTPROG	O
:	O
version	int
=	O
MOUNTVERS	O
;	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
=	O
&	O
mounttable	struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)))
;	O
break	O
;	O
case	O
NFS_PROGRAM	O
:	O
version	int
=	O
NFS_VERSION	O
;	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
=	O
&	O
nfs2table	struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)))
;	O
break	O
;	O
case	O
PMAPPROG	O
:	O
version	int
=	O
PMAPVERS	O
;	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
=	O
&	O
pmaptable	struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)))
;	O
break	O
;	O
default	O
:	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
MSG_ACCEPTED	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
AUTH_NULL	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
0	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
PROG_UNAVAIL	O
)	O
;	O
goto	O
send_reply	O
;	O
}	O
if	O
(	O
ntohl	(int)->(int)
(	O
*	O
p	*(int)
)	O
!=	O
version	int
)	O
{	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
MSG_ACCEPTED	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
AUTH_NULL	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
0	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
PROG_MISMATCH	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
version	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
version	int
)	O
;	O
goto	O
send_reply	O
;	O
}	O
p	*(int)
++	O
;	O
procedure	struct(*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)
=	O
htonl	(int)->(int)
(	O
*	O
p	*(int)
)	O
;	O
p	*(int)
++	O
;	O
if	O
(	O
procedure	struct(*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)
<	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
->	O
min	int
||	O
procedure	struct(*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)
>	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
->	O
max	int
||	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
->	O
procs	array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))
[	O
procedure	struct(*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)
-	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
->	O
min	int
]	O
.	O
func	*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int))
==	O
0	int
)	O
{	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
MSG_ACCEPTED	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
AUTH_NULL	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
0	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
PROC_UNAVAIL	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
->	O
min	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
->	O
max	int
)	O
;	O
goto	O
send_reply	O
;	O
}	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
=	O
&	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
->	O
procs	array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))
[	O
procedure	struct(*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int)
-	O
table	*(struct(int,int,array(struct(*((*(struct(*`,*`,union`,*`,int,long,int)),*(int),*(*(int)),int)->(int)),*((*(int),int)->(long)),int,int))))
->	O
min	int
]	O
;	O
p	*(int)
=	O
process_cred	(*(int),*(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int))))->(*(int))
(	O
p	*(int)
,	O
&	O
cred	*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int))
)	O
;	O
if	O
(	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
->	O
need_handle	int
)	O
p	*(int)
=	O
lookup_cache_handle	(*(int),*(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int))),*(struct(*(struct(*`,*`,int,int,*`,*`,long,int)),*(*(struct`)),int,int,*(int),*(int),long,int)))->(*(int))
(	O
p	*(int)
,	O
&	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
,	O
cred	*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int))
)	O
;	O
else	O
{	O
fakec	struct(*(struct(*(struct(*`,*`,union`,*`,int,long,int)),*(*(struct`)),union(array(char),int),*(struct(*`,*`,int,int,*`,*`,long,int)),int,long,int)),*(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int))),union(array(char),int),*(struct(*(struct(*`,*`,int,int,*`,*`,long,int)),*(*(struct`)),int,int,*(int),*(int),long,int)),int,long,int)
.	O
ids	*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int))
=	O
cred	*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int))
;	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
=	O
&	O
fakec	struct(*(struct(*(struct(*`,*`,union`,*`,int,long,int)),*(*(struct`)),union(array(char),int),*(struct(*`,*`,int,int,*`,*`,long,int)),int,long,int)),*(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int))),union(array(char),int),*(struct(*(struct(*`,*`,int,int,*`,*`,long,int)),*(*(struct`)),int,int,*(int),*(int),long,int)),int,long,int)
;	O
}	O
if	O
(	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
->	O
alloc_reply	*((*(int),int)->(long))
)	O
{	O
size_t	long
amt	long
;	O
amt	long
=	O
(	O
*	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
->	O
alloc_reply	*((*(int),int)->(long))
)	O
(	O
p	*(int)
,	O
version	int
)	O
+	O
256	int
;	O
if	O
(	O
amt	long
>	O
MAXIOSIZE	int
)	O
{	O
free	(*(void))->(void)
(	O
rbuf	*(char)
)	O
;	O
r	*(int)
=	O
(	O
int	O
*	O
)	O
(	O
rbuf	*(char)
=	O
malloc	(long)->(*(void))
(	O
amt	long
)	O
)	O
;	O
}	O
}	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
xid	int
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
REPLY	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
MSG_ACCEPTED	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
AUTH_NULL	O
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
0	int
)	O
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
SUCCESS	O
)	O
;	O
if	O
(	O
!	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
->	O
process_error	int
)	O
(	O
void	O
)	O
(	O
*	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
->	O
func	*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int))
)	O
(	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
,	O
p	*(int)
,	O
&	O
r	*(int)
,	O
version	int
)	O
;	O
else	O
{	O
if	O
(	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
)	O
{	O
int	O
*	O
errloc	*(int)
=	O
r	*(int)
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
0	int
)	O
;	O
err	long
=	O
(	O
*	O
proc	*(struct(*((*(struct`),*(int),*(*`),int)->(int)),*((*(int),int)->(long)),int,int))
->	O
func	*((*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(int),*(*(int)),int)->(int))
)	O
(	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
,	O
p	*(int)
,	O
&	O
r	*(int)
,	O
version	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
r	*(int)
=	O
errloc	*(int)
;	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
nfs_error_trans	(int,int)->(int)
(	O
err	long
,	O
version	int
)	O
)	O
;	O
}	O
}	O
else	O
*	O
(	O
r	*(int)
++	O
)	O
=	O
htonl	(int)->(int)
(	O
nfs_error_trans	(int,int)->(int)
(	O
ESTALE	int
,	O
version	int
)	O
)	O
;	O
}	O
cred_rele	(*(struct(*(struct(*`,*`,int,int,*`,*`,long,int)),*(*(struct`)),int,int,*(int),*(int),long,int)))->(void)
(	O
cred	*(struct(*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),*(*(struct(*`,*`,int,int,*`,*`,long,int))),int,int,*(int),*(int),long,int))
)	O
;	O
if	O
(	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
&&	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
!=	O
&	O
fakec	struct(*(struct(*(struct(*`,*`,union`,*`,int,long,int)),*(*(struct`)),union(array(char),int),*(struct(*`,*`,int,int,*`,*`,long,int)),int,long,int)),*(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int))),union(array(char),int),*(struct(*(struct(*`,*`,int,int,*`,*`,long,int)),*(*(struct`)),int,int,*(int),*(int),long,int)),int,long,int)
)	O
cache_handle_rele	(*(struct(*(struct(*`,*`,union`,*`,int,long,int)),*(*(struct`)),union(array(char),int),*(struct(*`,*`,int,int,*`,*`,long,int)),int,long,int)))->(void)
(	O
c	*(struct(*(struct(*(struct`),*(*`),union(array(char),int),*(struct`),int,long,int)),*(*(struct(*`,*`,union`,*`,int,long,int))),union(array(char),int),*(struct(*(struct`),*(*`),int,int,*(int),*(int),long,int)),int,long,int))
)	O
;	O
send_reply	O
:	O
cr	*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))
->	O
data	*(char)
=	O
rbuf	*(char)
;	O
cr	*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))
->	O
len	long
=	O
(	O
char	O
*	O
)	O
r	*(int)
-	O
rbuf	*(char)
;	O
repost_reply	O
:	O
sendto	(int,*(void),long,int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(long)
(	O
fd	int
,	O
cr	*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))
->	O
data	*(char)
,	O
cr	*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))
->	O
len	long
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
sender	struct(short,short,struct(int),array(char))
,	O
addrlen	int
)	O
;	O
release_cached_reply	(*(struct(*(struct(*`,*`,union`,struct`,int,long,int,long,*`)),*(*(struct`)),union(struct(int,int,int,int,int,short,short,struct`),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char))))->(void)
(	O
cr	*(struct(*(struct(*(struct`),*(*`),union(struct`,array(char),long),struct(short,short,struct`,array(char)),int,long,int,long,*(char))),*(*(struct(*`,*`,union`,struct`,int,long,int,long,*`))),union(struct(int,int,int,int,int,short,short,struct(*`,*`)),array(char),long),struct(short,short,struct(int),array(char)),int,long,int,long,*(char)))
)	O
;	O
}	O
}	O
