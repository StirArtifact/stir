static	O
int	O
limit_search	int
=	O
0	int
;	O
static	O
int	O
search_mask	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
do_genmove	(int,float,array(int),*(float),*(int))->(int)
(	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
int	O
allowed_moves	array(int)
[	O
BOARDMAX	O
]	O
,	O
float	O
*	O
value	*(char)
,	O
int	O
*	O
resign	*(int)
)	O
;	O
static	O
int	O
worms_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
initial_influence_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
dragons_examined_without_owl	int
=	O
-	O
1	int
;	O
static	O
int	O
dragons_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
initial_influence2_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
dragons_refinedly_examined	int
=	O
-	O
1	int
;	O
static	O
int	O
revise_semeai	(int)->(int)
(	O
int	O
color	int
)	O
;	O
static	O
int	O
revise_thrashing_dragon	(int,float,float)->(int)
(	O
int	O
color	int
,	O
float	O
our_score	float
,	O
float	O
advantage	float
)	O
;	O
static	O
void	O
break_mirror_go	(int)->(void)
(	O
int	O
color	int
)	O
;	O
static	O
int	O
find_mirror_move	(*(int),int)->(int)
(	O
int	O
*	O
move	*(int)
,	O
int	O
color	int
)	O
;	O
static	O
int	O
should_resign	(int,float,int)->(int)
(	O
int	O
color	int
,	O
float	O
optimistic_score	float
,	O
int	O
move	*(int)
)	O
;	O
static	O
void	O
compute_scores	(int)->(void)
(	O
int	O
use_chinese_rules	int
)	O
;	O
void	O
reset_engine	()->(void)
(	O
)	O
{	O
reuse_random_seed	()->(void)
(	O
)	O
;	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
hashdata_recalc	(*(struct(array(long))),*(char),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
board	*(char)
,	O
board_ko_pos	int
)	O
;	O
worms_examined	int
=	O
-	O
1	int
;	O
initial_influence_examined	int
=	O
-	O
1	int
;	O
dragons_examined_without_owl	int
=	O
-	O
1	int
;	O
dragons_examined	int
=	O
-	O
1	int
;	O
initial_influence2_examined	int
=	O
-	O
1	int
;	O
dragons_refinedly_examined	int
=	O
-	O
1	int
;	O
clear_move_reasons	()->(void)
(	O
)	O
;	O
clear_break_in_list	()->(void)
(	O
)	O
;	O
set_depth_values	(int,int)->(void)
(	O
get_level	()->(int)
(	O
)	O
,	O
0	int
)	O
;	O
clear_unconditionally_meaningless_moves	()->(void)
(	O
)	O
;	O
}	O
void	O
examine_position	(int,int)->(void)
(	O
int	O
how_much	int
,	O
int	O
aftermath_play	int
)	O
{	O
int	O
save_verbose	int
=	O
verbose	int
;	O
purge_persistent_caches	()->(void)
(	O
)	O
;	O
if	O
(	O
verbose	int
==	O
1	int
||	O
verbose	int
==	O
2	int
)	O
--	O
verbose	int
;	O
if	O
(	O
NEEDS_UPDATE	O
(	O
worms_examined	int
)	O
)	O
{	O
start_timer	(int)->(void)
(	O
0	int
)	O
;	O
make_worms	()->(void)
(	O
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
0	int
,	O
"  make worms"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
how_much	int
==	O
EXAMINE_WORMS	int
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	()->(int)
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
NEEDS_UPDATE	O
(	O
initial_influence_examined	int
)	O
)	O
compute_worm_influence	()->(void)
(	O
)	O
;	O
if	O
(	O
how_much	int
==	O
EXAMINE_INITIAL_INFLUENCE	int
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	()->(int)
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
how_much	int
==	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
{	O
if	O
(	O
NEEDS_UPDATE	O
(	O
dragons_examined_without_owl	int
)	O
)	O
make_dragons	(int)->(void)
(	O
1	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	()->(int)
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
NEEDS_UPDATE	O
(	O
dragons_examined	int
)	O
)	O
{	O
make_dragons	(int)->(void)
(	O
0	int
)	O
;	O
compute_scores	(int)->(void)
(	O
chinese_rules	int
||	O
aftermath_play	int
)	O
;	O
dragons_examined_without_owl	int
=	O
position_number	int
;	O
}	O
if	O
(	O
how_much	int
==	O
EXAMINE_DRAGONS	int
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	()->(int)
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
how_much	int
==	O
EXAMINE_INITIAL_INFLUENCE	int
||	O
how_much	int
==	O
EXAMINE_DRAGONS	int
||	O
how_much	int
==	O
EXAMINE_ALL	int
)	O
{	O
initialize_dragon_data	()->(void)
(	O
)	O
;	O
compute_scores	(int)->(void)
(	O
chinese_rules	int
||	O
aftermath_play	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
gg_assert	O
(	O
test_gray_border	()->(int)
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
verbose	int
=	O
save_verbose	int
;	O
if	O
(	O
NEEDS_UPDATE	O
(	O
initial_influence2_examined	int
)	O
)	O
{	O
compute_dragon_influence	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
how_much	int
==	O
EXAMINE_INITIAL_INFLUENCE2	int
)	O
{	O
gg_assert	O
(	O
test_gray_border	()->(int)
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
NEEDS_UPDATE	O
(	O
dragons_refinedly_examined	int
)	O
)	O
{	O
compute_refined_dragon_weaknesses	()->(void)
(	O
)	O
;	O
compute_strategic_sizes	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
how_much	int
==	O
FULL_EXAMINE_DRAGONS	int
)	O
{	O
gg_assert	O
(	O
test_gray_border	()->(int)
(	O
)	O
<	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
printworms	int
)	O
show_dragons	()->(void)
(	O
)	O
;	O
}	O
void	O
silent_examine_position	(int)->(void)
(	O
int	O
how_much	int
)	O
{	O
int	O
save_verbose	int
=	O
verbose	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	int
=	O
count_variations	int
;	O
int	O
save_debug	int
=	O
debug	int
;	O
int	O
save_printmoyo	int
=	O
printmoyo	int
;	O
verbose	int
=	O
0	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
debug	int
=	O
0	int
;	O
printmoyo	int
=	O
0	int
;	O
examine_position	(int,int)->(void)
(	O
how_much	int
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
count_variations	int
=	O
save_count_variations	int
;	O
debug	int
=	O
save_debug	int
;	O
printmoyo	int
=	O
save_printmoyo	int
;	O
}	O
int	O
genmove	(int,*(float),*(int))->(int)
(	O
int	O
color	int
,	O
float	O
*	O
value	*(char)
,	O
int	O
*	O
resign	*(int)
)	O
{	O
int	O
move	*(int)
=	O
PASS_MOVE	int
;	O
if	O
(	O
resign	*(int)
)	O
*	O
resign	*(int)
=	O
0	int
;	O
if	O
(	O
limit_search	int
)	O
move	*(int)
=	O
do_genmove	(int,float,array(int),*(float),*(int))->(int)
(	O
color	int
,	O
0.4	int
,	O
search_mask	array(int)
,	O
value	*(char)
,	O
resign	*(int)
)	O
;	O
else	O
move	*(int)
=	O
do_genmove	(int,float,array(int),*(float),*(int))->(int)
(	O
color	int
,	O
0.4	int
,	O
NULL	O
,	O
value	*(char)
,	O
resign	*(int)
)	O
;	O
gg_assert	O
(	O
move	*(int)
==	O
PASS_MOVE	int
||	O
ON_BOARD	O
(	O
move	*(int)
)	O
)	O
;	O
return	O
move	*(int)
;	O
}	O
int	O
genmove_conservative	(int,*(float))->(int)
(	O
int	O
color	int
,	O
float	O
*	O
value	*(char)
)	O
{	O
return	O
do_genmove	(int,float,array(int),*(float),*(int))->(int)
(	O
color	int
,	O
0.0	int
,	O
NULL	O
,	O
value	*(char)
,	O
NULL	O
)	O
;	O
}	O
int	O
genmove_restricted	(int,array(int))->(int)
(	O
int	O
color	int
,	O
int	O
allowed_moves	array(int)
[	O
BOARDMAX	O
]	O
)	O
{	O
return	O
do_genmove	(int,float,array(int),*(float),*(int))->(int)
(	O
color	int
,	O
0.0	int
,	O
allowed_moves	array(int)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
void	O
collect_move_reasons	(int)->(void)
(	O
int	O
color	int
)	O
{	O
worm_reasons	(int)->(void)
(	O
color	int
)	O
;	O
semeai_move_reasons	(int)->(void)
(	O
color	int
)	O
;	O
owl_reasons	(int)->(void)
(	O
color	int
)	O
;	O
cut_reasons	(int)->(void)
(	O
color	int
)	O
;	O
break_in_move_reasons	(int)->(void)
(	O
color	int
)	O
;	O
unconditional_move_reasons	(int)->(void)
(	O
color	int
)	O
;	O
}	O
static	O
int	O
monte_carlo_genmove	(int,array(int),*(float),*(int))->(int)
(	O
int	O
color	int
,	O
int	O
allowed_moves	array(int)
[	O
BOARDMAX	O
]	O
,	O
float	O
*	O
value	*(char)
,	O
int	O
*	O
resign	*(int)
)	O
{	O
int	O
pos	int
;	O
int	O
best_move	int
=	O
PASS_MOVE	int
;	O
int	O
best_uct_move	int
=	O
PASS_MOVE	int
;	O
int	O
unconditional_territory_black	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
unconditional_territory_white	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
forbidden_move	array(int)
[	O
BOARDMAX	O
]	O
;	O
float	O
move_values	*(float)
[	O
BOARDMAX	O
]	O
;	O
int	O
move_frequencies	*(int)
[	O
BOARDMAX	O
]	O
;	O
float	O
best_value	float
;	O
int	O
frequency_cutoff	int
;	O
int	O
frequency_cutoff2	int
;	O
int	O
number_of_simulations	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
move_values	*(float)
,	O
0	int
,	O
sizeof	O
(	O
move_values	*(float)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
move_frequencies	*(int)
,	O
0	int
,	O
sizeof	O
(	O
move_frequencies	*(int)
)	O
)	O
;	O
if	O
(	O
0	int
)	O
{	O
simple_showboard	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
resign	*(int)
)	O
*	O
resign	*(int)
=	O
0	int
;	O
unconditional_life	(array(int),int)->(void)
(	O
unconditional_territory_black	array(int)
,	O
BLACK	int
)	O
;	O
unconditional_life	(array(int),int)->(void)
(	O
unconditional_territory_white	array(int)
,	O
WHITE	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
unconditional_territory_black	array(int)
[	O
pos	int
]	O
)	O
forbidden_move	array(int)
[	O
pos	int
]	O
=	O
BLACK	int
;	O
else	O
if	O
(	O
unconditional_territory_white	array(int)
[	O
pos	int
]	O
)	O
forbidden_move	array(int)
[	O
pos	int
]	O
=	O
WHITE	int
;	O
else	O
forbidden_move	array(int)
[	O
pos	int
]	O
=	O
0	int
;	O
number_of_simulations	int
=	O
mc_games_per_level	int
*	O
gg_max	O
(	O
get_level	()->(int)
(	O
)	O
,	O
1	int
)	O
;	O
uct_genmove	(int,*(int),*(int),*(int),int,*(float),*(int))->(void)
(	O
color	int
,	O
&	O
best_uct_move	int
,	O
forbidden_move	array(int)
,	O
allowed_moves	array(int)
,	O
number_of_simulations	int
,	O
move_values	*(float)
,	O
move_frequencies	*(int)
)	O
;	O
best_move	int
=	O
best_uct_move	int
;	O
best_value	float
=	O
0.0	int
;	O
frequency_cutoff	int
=	O
move_frequencies	*(int)
[	O
best_uct_move	int
]	O
/	O
2	int
;	O
frequency_cutoff2	int
=	O
move_frequencies	*(int)
[	O
best_uct_move	int
]	O
/	O
10	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
(	O
move_frequencies	*(int)
[	O
pos	int
]	O
>	O
frequency_cutoff	int
||	O
(	O
move_values	*(float)
[	O
pos	int
]	O
>	O
0.9	int
&&	O
move_frequencies	*(int)
[	O
pos	int
]	O
>	O
frequency_cutoff2	int
)	O
||	O
move_values	*(float)
[	O
best_uct_move	int
]	O
<	O
0.1	int
)	O
&&	O
(	O
!	O
allowed_moves	array(int)
||	O
allowed_moves	array(int)
[	O
pos	int
]	O
)	O
&&	O
potential_moves	array(float)
[	O
pos	int
]	O
>	O
best_value	float
)	O
{	O
best_move	int
=	O
pos	int
;	O
best_value	float
=	O
potential_moves	array(float)
[	O
pos	int
]	O
;	O
}	O
}	O
unconditionally_meaningless_move	(int,int,*(int))->(int)
(	O
best_move	int
,	O
color	int
,	O
&	O
best_move	int
)	O
;	O
*	O
value	*(char)
=	O
1.0	int
;	O
return	O
best_move	int
;	O
}	O
static	O
int	O
do_genmove	(int,float,array(int),*(float),*(int))->(int)
(	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
int	O
allowed_moves	array(int)
[	O
BOARDMAX	O
]	O
,	O
float	O
*	O
value	*(char)
,	O
int	O
*	O
resign	*(int)
)	O
{	O
float	O
average_score	float
,	O
pessimistic_score	float
,	O
optimistic_score	float
;	O
int	O
save_verbose	int
;	O
int	O
save_depth	int
;	O
int	O
move	*(int)
;	O
float	O
dummy_value	float
;	O
int	O
use_thrashing_dragon_heuristics	int
=	O
0	int
;	O
if	O
(	O
!	O
value	*(char)
)	O
value	*(char)
=	O
&	O
dummy_value	float
;	O
start_timer	(int)->(void)
(	O
0	int
)	O
;	O
clearstats	()->(void)
(	O
)	O
;	O
if	O
(	O
resign	*(int)
)	O
*	O
resign	*(int)
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
potential_moves	array(float)
,	O
0	int
,	O
sizeof	O
(	O
potential_moves	array(float)
)	O
)	O
;	O
move	*(int)
=	O
PASS_MOVE	int
;	O
*	O
value	*(char)
=	O
0.0	int
;	O
reset_engine	()->(void)
(	O
)	O
;	O
save_depth	int
=	O
depth	int
;	O
if	O
(	O
play_mirror_go	int
&&	O
(	O
mirror_stones_limit	int
<	O
0	int
||	O
stones_on_board	(int)->(int)
(	O
WHITE	int
|	O
BLACK	int
)	O
<=	O
mirror_stones_limit	int
)	O
&&	O
find_mirror_move	(*(int),int)->(int)
(	O
&	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
TRACE	O
(	O
"genmove() recommends mirror move at %1m\n"	*(char)
,	O
move	*(int)
)	O
;	O
*	O
value	*(char)
=	O
1.0	int
;	O
return	O
move	*(int)
;	O
}	O
start_timer	(int)->(void)
(	O
1	int
)	O
;	O
examine_position	(int,int)->(void)
(	O
EXAMINE_ALL	int
,	O
0	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"examine position"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
pessimistic_score	float
=	O
black_score	float
;	O
optimistic_score	float
=	O
white_score	float
;	O
}	O
else	O
{	O
pessimistic_score	float
=	O
-	O
white_score	float
;	O
optimistic_score	float
=	O
-	O
black_score	float
;	O
}	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
average_score	float
=	O
(	O
white_score	float
+	O
black_score	float
)	O
/	O
2.0	int
;	O
else	O
average_score	float
=	O
-	O
(	O
white_score	float
+	O
black_score	float
)	O
/	O
2.0	int
;	O
choose_strategy	(int,float,float)->(void)
(	O
color	int
,	O
average_score	float
,	O
game_status	(int)->(float)
(	O
color	int
)	O
)	O
;	O
if	O
(	O
printboard	int
)	O
{	O
if	O
(	O
printboard	int
==	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n          dragon_status display:\n\n"	*(char)
)	O
;	O
if	O
(	O
printboard	int
==	O
2	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n          eye display:\n\n"	*(char)
)	O
;	O
showboard	(int)->(void)
(	O
printboard	int
)	O
;	O
if	O
(	O
printboard	int
==	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n           owl_status display:\n\n"	*(char)
)	O
;	O
showboard	(int)->(void)
(	O
3	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n           matcher_status display:\n\n"	*(char)
)	O
;	O
showboard	(int)->(void)
(	O
4	int
)	O
;	O
}	O
}	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
collect_move_reasons	(int)->(void)
(	O
color	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"generate move reasons"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
fuseki	(int)->(void)
(	O
color	int
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
break_mirror_go	(int)->(void)
(	O
color	int
)	O
;	O
if	O
(	O
!	O
doing_scoring	int
)	O
use_thrashing_dragon_heuristics	int
=	O
revise_thrashing_dragon	(int,float,float)->(int)
(	O
color	int
,	O
pessimistic_score	float
,	O
5.0	int
)	O
;	O
shapes	(int)->(void)
(	O
color	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"shapes"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
combinations	(int)->(void)
(	O
color	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"combinations"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
review_move_reasons	(*(int),*(float),int,float,float,array(int),int)->(int)
(	O
&	O
move	*(int)
,	O
value	*(char)
,	O
color	int
,	O
pure_threat_value	float
,	O
pessimistic_score	float
,	O
allowed_moves	array(int)
,	O
use_thrashing_dragon_heuristics	int
)	O
)	O
TRACE	O
(	O
"Move generation likes %1m with value %f\n"	*(char)
,	O
move	*(int)
,	O
*	O
value	*(char)
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"review move reasons"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
if	O
(	O
*	O
value	*(char)
<=	O
6.0	int
&&	O
!	O
disable_endgame_patterns	int
)	O
{	O
endgame_shapes	(int)->(void)
(	O
color	int
)	O
;	O
endgame	(int)->(void)
(	O
color	int
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
review_move_reasons	(*(int),*(float),int,float,float,array(int),int)->(int)
(	O
&	O
move	*(int)
,	O
value	*(char)
,	O
color	int
,	O
pure_threat_value	float
,	O
pessimistic_score	float
,	O
allowed_moves	array(int)
,	O
use_thrashing_dragon_heuristics	int
)	O
)	O
TRACE	O
(	O
"Move generation likes %1m with value %f\n"	*(char)
,	O
move	*(int)
,	O
*	O
value	*(char)
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"endgame"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	int
)	O
{	O
if	O
(	O
revise_semeai	(int)->(int)
(	O
color	int
)	O
)	O
{	O
shapes	(int)->(void)
(	O
color	int
)	O
;	O
endgame_shapes	(int)->(void)
(	O
color	int
)	O
;	O
if	O
(	O
review_move_reasons	(*(int),*(float),int,float,float,array(int),int)->(int)
(	O
&	O
move	*(int)
,	O
value	*(char)
,	O
color	int
,	O
pure_threat_value	float
,	O
pessimistic_score	float
,	O
allowed_moves	array(int)
,	O
use_thrashing_dragon_heuristics	int
)	O
)	O
{	O
TRACE	O
(	O
"Upon reconsideration move generation likes %1m with value %f\n"	*(char)
,	O
move	*(int)
,	O
*	O
value	*(char)
)	O
;	O
}	O
}	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"move reasons with revised semeai status"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
use_monte_carlo_genmove	int
&&	O
move	*(int)
!=	O
PASS_MOVE	int
&&	O
(	O
*	O
value	*(char)
<	O
75.0	int
||	O
*	O
value	*(char)
>	O
75.01	int
)	O
&&	O
!	O
doing_scoring	int
)	O
{	O
int	O
allowed_moves2	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
num_allowed_moves2	int
=	O
0	int
;	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
(	O
!	O
allowed_moves	array(int)
||	O
allowed_moves	array(int)
[	O
pos	int
]	O
)	O
&&	O
is_allowed_move	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
allowed_moves2	array(int)
[	O
pos	int
]	O
=	O
1	int
;	O
num_allowed_moves2	int
++	O
;	O
}	O
else	O
allowed_moves2	array(int)
[	O
pos	int
]	O
=	O
0	int
;	O
if	O
(	O
num_allowed_moves2	int
>	O
1	int
)	O
move	*(int)
=	O
monte_carlo_genmove	(int,array(int),*(float),*(int))->(int)
(	O
color	int
,	O
allowed_moves2	array(int)
,	O
value	*(char)
,	O
resign	*(int)
)	O
;	O
}	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	int
&&	O
fill_liberty	(*(int),int)->(int)
(	O
&	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
if	O
(	O
!	O
allowed_moves	array(int)
||	O
allowed_moves	array(int)
[	O
move	*(int)
]	O
)	O
{	O
*	O
value	*(char)
=	O
1.0	int
;	O
TRACE	O
(	O
"Filling a liberty at %1m\n"	*(char)
,	O
move	*(int)
)	O
;	O
record_top_move	(int,float)->(void)
(	O
move	*(int)
,	O
*	O
value	*(char)
)	O
;	O
move_considered	(int,float)->(void)
(	O
move	*(int)
,	O
*	O
value	*(char)
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"fill liberty"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
else	O
move	*(int)
=	O
PASS_MOVE	int
;	O
}	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	int
)	O
{	O
if	O
(	O
play_out_aftermath	int
||	O
capture_all_dead	int
||	O
(	O
!	O
doing_scoring	int
&&	O
thrashing_dragon	int
&&	O
pessimistic_score	float
>	O
15.0	int
)	O
)	O
move	*(int)
=	O
aftermath_genmove	(int,int,array(int))->(int)
(	O
color	int
,	O
capture_all_dead	int
,	O
allowed_moves	array(int)
)	O
;	O
if	O
(	O
move	*(int)
!=	O
PASS_MOVE	int
)	O
{	O
ASSERT1	O
(	O
is_legal	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
,	O
move	*(int)
)	O
;	O
*	O
value	*(char)
=	O
1.0	int
;	O
TRACE	O
(	O
"Aftermath move at %1m\n"	*(char)
,	O
move	*(int)
)	O
;	O
record_top_move	(int,float)->(void)
(	O
move	*(int)
,	O
*	O
value	*(char)
)	O
;	O
move_considered	(int,float)->(void)
(	O
move	*(int)
,	O
*	O
value	*(char)
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
1	int
,	O
"aftermath_genmove"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
is_allowed_move	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
TRACE	O
(	O
"ILLEGAL MOVE GENERATED. Passing instead.\n"	*(char)
)	O
;	O
move	*(int)
=	O
PASS_MOVE	int
;	O
*	O
value	*(char)
=	O
-	O
1.0	int
;	O
}	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	int
)	O
{	O
TRACE	O
(	O
"I pass.\n"	*(char)
)	O
;	O
}	O
else	O
{	O
TRACE	O
(	O
"genmove() recommends %1m with value %f\n"	*(char)
,	O
move	*(int)
,	O
*	O
value	*(char)
)	O
;	O
}	O
if	O
(	O
resign	*(int)
&&	O
resign_allowed	int
&&	O
*	O
value	*(char)
<	O
10.0	int
&&	O
should_resign	(int,float,int)->(int)
(	O
color	int
,	O
optimistic_score	float
,	O
move	*(int)
)	O
)	O
{	O
TRACE	O
(	O
"... though, genmove() thinks the position is hopeless\n"	*(char)
)	O
;	O
*	O
resign	*(int)
=	O
1	int
;	O
}	O
if	O
(	O
showstatistics	int
)	O
showstats	()->(void)
(	O
)	O
;	O
if	O
(	O
showtime	int
)	O
{	O
double	O
spent	double
=	O
time_report	(int,*(char),int,double)->(double)
(	O
0	int
,	O
"TIME to generate move at "	*(char)
,	O
move	*(int)
,	O
1.0	int
)	O
;	O
total_time	double
+=	O
spent	double
;	O
if	O
(	O
spent	double
>	O
slowest_time	double
)	O
{	O
slowest_time	double
=	O
spent	double
;	O
slowest_move	int
=	O
move	*(int)
;	O
slowest_movenum	int
=	O
movenum	int
+	O
1	int
;	O
}	O
}	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
gg_assert	O
(	O
test_gray_border	()->(int)
(	O
)	O
<	O
0	int
)	O
;	O
gg_assert	O
(	O
depth	int
==	O
save_depth	int
)	O
;	O
return	O
move	*(int)
;	O
}	O
void	O
move_considered	(int,float)->(void)
(	O
int	O
move	*(int)
,	O
float	O
value	*(char)
)	O
{	O
if	O
(	O
value	*(char)
>	O
potential_moves	array(float)
[	O
move	*(int)
]	O
)	O
potential_moves	array(float)
[	O
move	*(int)
]	O
=	O
value	*(char)
;	O
}	O
static	O
int	O
revise_semeai	(int)->(int)
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
int	O
found_one	int
=	O
0	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
doing_scoring	int
)	O
return	O
0	int
;	O
gg_assert	O
(	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
!=	O
NULL	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
color	int
==	O
other	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
semeais	int
&&	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
{	O
found_one	int
=	O
1	int
;	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
UNKNOWN	int
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
)	O
TRACE	O
(	O
"revise_semeai: changed status of dragon %1m from DEAD to UNKNOWN\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
}	O
return	O
found_one	int
;	O
}	O
static	O
int	O
revise_thrashing_dragon	(int,float,float)->(int)
(	O
int	O
color	int
,	O
float	O
our_score	float
,	O
float	O
advantage	float
)	O
{	O
int	O
pos	int
;	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
;	O
float	O
strength	array(float)
[	O
BOARDMAX	O
]	O
;	O
if	O
(	O
our_score	float
<	O
advantage	float
)	O
return	O
0	int
;	O
if	O
(	O
disable_threat_computation	int
||	O
!	O
thrashing_dragon	int
||	O
dragon	int
[	O
thrashing_dragon	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
)	O
return	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
thrashing_stone	array(char)
[	O
pos	int
]	O
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
)	O
{	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
UNKNOWN	int
;	O
DRAGON2	O
(	O
pos	int
)	O
.	O
safety	int
=	O
ALIVE	int
;	O
}	O
set_strength_data	(int,array(char),array(float))->(void)
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array(char)
,	O
strength	array(float)
)	O
;	O
compute_influence	(int,array(char),array(float),*(struct),int,*(char))->(void)
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
NO_MOVE	O
,	O
"revised thrashing dragon"	*(char)
)	O
;	O
compute_refined_dragon_weaknesses	()->(void)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
find_mirror_move	(*(int),int)->(int)
(	O
int	O
*	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
int	O
last_move	int
=	O
get_last_move	()->(int)
(	O
)	O
;	O
int	O
mirror_move	int
;	O
if	O
(	O
last_move	int
!=	O
NO_MOVE	O
)	O
{	O
mirror_move	int
=	O
MIRROR_MOVE	O
(	O
last_move	int
)	O
;	O
if	O
(	O
test_symmetry_after_move	(int,int,int)->(int)
(	O
mirror_move	int
,	O
color	int
,	O
0	int
)	O
)	O
{	O
*	O
move	*(int)
=	O
mirror_move	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
mirror_move	int
=	O
BOARDMIN	O
;	O
mirror_move	int
<	O
BOARDMAX	O
;	O
mirror_move	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
mirror_move	int
)	O
&&	O
test_symmetry_after_move	(int,int,int)->(int)
(	O
mirror_move	int
,	O
color	int
,	O
0	int
)	O
)	O
{	O
*	O
move	*(int)
=	O
mirror_move	int
;	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
compute_scores	(int)->(void)
(	O
int	O
use_chinese_rules	int
)	O
{	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
;	O
float	O
strength	array(float)
[	O
BOARDMAX	O
]	O
;	O
set_strength_data	(int,array(char),array(float))->(void)
(	O
WHITE	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
)	O
;	O
compute_influence	(int,array(char),array(float),*(struct),int,*(char))->(void)
(	O
EMPTY	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
&	O
move_influence	struct
,	O
NO_MOVE	O
,	O
"White territory estimate"	*(char)
)	O
;	O
white_score	float
=	O
influence_score	(*(struct),int)->(float)
(	O
&	O
move_influence	struct
,	O
use_chinese_rules	int
)	O
;	O
set_strength_data	(int,array(char),array(float))->(void)
(	O
BLACK	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
)	O
;	O
compute_influence	(int,array(char),array(float),*(struct),int,*(char))->(void)
(	O
EMPTY	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
&	O
move_influence	struct
,	O
NO_MOVE	O
,	O
"White territory estimate"	*(char)
)	O
;	O
black_score	float
=	O
influence_score	(*(struct),int)->(float)
(	O
&	O
move_influence	struct
,	O
use_chinese_rules	int
)	O
;	O
if	O
(	O
verbose	int
||	O
showscore	int
)	O
{	O
if	O
(	O
white_score	float
==	O
black_score	float
)	O
gprintf	(*(char))->(int)
(	O
"Score estimate: %s %f\n"	*(char)
,	O
black_score	float
>	O
0	int
?	O
"W "	*(char)
:	O
"B "	*(char)
,	O
gg_abs	O
(	O
black_score	float
)	O
)	O
;	O
else	O
gprintf	(*(char))->(int)
(	O
"Score estimate: %s %f to %s %f\n"	*(char)
,	O
black_score	float
>	O
0	int
?	O
"W "	*(char)
:	O
"B "	*(char)
,	O
gg_abs	O
(	O
black_score	float
)	O
,	O
white_score	float
>	O
0	int
?	O
"W "	*(char)
:	O
"B "	*(char)
,	O
gg_abs	O
(	O
white_score	float
)	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
static	O
void	O
break_mirror_go	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
tengen	int
=	O
POS	O
(	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
,	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
tengen	int
]	O
==	O
EMPTY	int
&&	O
color	int
==	O
BLACK	int
&&	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
10	int
&&	O
test_symmetry_after_move	(int,int,int)->(int)
(	O
tengen	int
,	O
color	int
,	O
1	int
)	O
)	O
{	O
set_minimum_move_value	(int,float)->(int)
(	O
tengen	int
,	O
30.0	int
)	O
;	O
TRACE	O
(	O
"Play %1m to break mirror go, value 30.\n"	*(char)
,	O
tengen	int
)	O
;	O
}	O
}	O
static	O
int	O
should_resign	(int,float,int)->(int)
(	O
int	O
color	int
,	O
float	O
optimistic_score	float
,	O
int	O
move	*(int)
)	O
{	O
float	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int	O
d	int
;	O
if	O
(	O
board_size	int
>	O
2	int
&&	O
move	*(int)
==	O
PASS_MOVE	int
&&	O
!	O
lively_dragon_exists	(int)->(int)
(	O
color	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	int
||	O
board_size	int
<	O
19	int
||	O
optimistic_score	float
>	O
-	O
45.0	int
)	O
return	O
0	int
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
origin	int
]	O
==	O
color	int
&&	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
return	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
origin	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
&&	O
DRAGON	O
(	O
d	int
)	O
.	O
effective_size	float
>=	O
10	int
&&	O
dragon_weak	(int)->(int)
(	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
origin	int
)	O
)	O
return	O
0	int
;	O
}	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
game_status	(int)->(float)
(	O
color	int
)	O
;	O
if	O
(	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
<	O
0.8	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
void	O
set_limit_search	(int)->(void)
(	O
int	O
value	*(char)
)	O
{	O
limit_search	int
=	O
value	*(char)
;	O
}	O
void	O
set_search_diamond	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
int	O
m	int
,	O
n	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
gg_abs	O
(	O
m	int
-	O
i	int
)	O
+	O
gg_abs	O
(	O
n	int
-	O
j	int
)	O
<=	O
6	int
)	O
search_mask	array(int)
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
=	O
1	int
;	O
else	O
search_mask	array(int)
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
=	O
0	int
;	O
}	O
limit_search	int
=	O
pos	int
;	O
if	O
(	O
0	int
)	O
draw_search_area	()->(void)
(	O
)	O
;	O
}	O
void	O
reset_search_mask	()->(void)
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
search_mask	array(int)
,	O
0	int
,	O
sizeof	O
(	O
search_mask	array(int)
)	O
)	O
;	O
}	O
void	O
set_search_mask	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
value	*(char)
)	O
{	O
search_mask	array(int)
[	O
pos	int
]	O
=	O
value	*(char)
;	O
}	O
void	O
draw_search_area	()->(void)
(	O
void	O
)	O
{	O
int	O
m	int
,	O
n	int
;	O
start_draw_board	()->(void)
(	O
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
int	O
col	int
,	O
c	char
;	O
if	O
(	O
search_mask	array(int)
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
col	int
=	O
GG_COLOR_RED	int
;	O
else	O
col	int
=	O
GG_COLOR_BLACK	int
;	O
if	O
(	O
board	*(char)
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
BLACK	int
)	O
c	char
=	O
'X'	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
==	O
WHITE	int
)	O
c	char
=	O
'O'	O
;	O
else	O
if	O
(	O
search_mask	array(int)
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
c	char
=	O
'*'	O
;	O
else	O
c	char
=	O
'.'	O
;	O
draw_color_char	(int,int,int,int)->(void)
(	O
m	int
,	O
n	int
,	O
c	char
,	O
col	int
)	O
;	O
}	O
end_draw_board	()->(void)
(	O
)	O
;	O
}	O
int	O
within_search_area	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
if	O
(	O
!	O
limit_search	int
)	O
return	O
1	int
;	O
return	O
search_mask	array(int)
[	O
pos	int
]	O
;	O
}	O
