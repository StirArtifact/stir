CLASSID	long
EDMAPROC	O
_edma_get_local_class_id	()->(long)
(	O
)	O
{	O
ESint32	long
i	long
,	O
j	long
,	O
n	long
,	O
ret	long
;	O
HMEM	long
h	long
;	O
j	long
=	O
0	int
;	O
n	long
=	O
MAX_CLASE	int
+	O
nLocalClasses	long
;	O
for	O
(	O
i	long
=	O
MAX_CLASE	int
;	O
j	long
<	O
n	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
MAX_CLASE	int
+	O
nMaxLocalClasses	long
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"[%s] Resizing of local class pool still not implemented"	*(char)
,	O
__FUNCTION__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
h	long
=	O
edma_palloc	(long)->(long)
(	O
sizeof	O
(	O
CLASE	struct(char,char,char,char,char,long,long,array(char),char,char,long,array(char),long,long,long,struct(long,long,long,array(char),*(*(char))),char,long,char,char,long,long,long,short,short,short,char,char,long,long)
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_get_local_class_id] Can't alloc memory "	*(char)
"for new local class"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
gClass	O
[	O
i	long
]	O
=	O
edma_pget	(long)->(*(void))
(	O
h	long
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
gClass	O
[	O
i	long
]	O
,	O
0	int
,	O
sizeof	O
(	O
CLASE	struct(char,char,char,char,char,long,long,array(char),char,char,long,array(char),long,long,long,struct(long,long,long,array(char),*(*(char))),char,long,char,char,long,long,long,short,short,short,char,char,long,long)
)	O
)	O
;	O
ProcMapTable	*(char)
[	O
i	long
]	O
=	O
CLASS_TEMP	int
;	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
=	O
CLASS_TEMP	int
;	O
gClass	O
[	O
i	long
]	O
->	O
repo_type	char
=	O
EDMA_LOCAL_REPO	int
;	O
gClass	O
[	O
i	long
]	O
->	O
repo_id	long
=	O
-	O
1	int
;	O
gClass	O
[	O
i	long
]	O
->	O
CurrentVer	long
=	O
i	long
;	O
if	O
(	O
(	O
ret	long
=	O
_edma_class_alloc_priv_data	(long)->(long)
(	O
i	long
)	O
)	O
<	O
0	int
)	O
{	O
edma_pfree	(long,*(void))->(void)
(	O
h	long
,	O
gClass	O
[	O
i	long
]	O
)	O
;	O
ProcMapTable	*(char)
[	O
i	long
]	O
=	O
CLASS_FREE	int
;	O
return	O
ret	long
;	O
}	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
i	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
MySelf	long
=	O
h	long
;	O
gClass	O
[	O
i	long
]	O
->	O
SIUProxy	long
=	O
-	O
1	int
;	O
gClass	O
[	O
i	long
]	O
->	O
IDFParser	long
=	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_add_local_class_property	(long,*(char),long,long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
prop_name	*(char)
,	O
EUint32	long
type	long
,	O
ESint32	long
access	(*(char),int)->(int)
,	O
EUint32	long
nelems	long
)	O
{	O
ESint32	long
n	long
,	O
indx	long
;	O
if	O
(	O
gClass	O
[	O
class_id	long
]	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_method] Invalid Class "	*(char)
"Identifier [%d]"	*(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
prop_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ProcMapTable	*(char)
[	O
class_id	long
]	O
!=	O
CLASS_TEMP	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_property] Class %d "	*(char)
"not in definition state"	*(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_get_prop_indx	(long,*(char))->(long)
(	O
class_id	long
,	O
prop_name	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_set_property] Property '%s' "	*(char)
"already defined"	*(char)
,	O
prop_name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	long
=	O
indx	long
=	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
;	O
n	long
++	O
;	O
if	O
(	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hProp	long
=	O
edma_prealloc	(long,long)->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hProp	long
,	O
sizeof	O
(	O
PROP	struct(array(char),long,char,short,long,long)
)	O
*	O
n	long
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_property] Can't alloc memory for "	*(char)
" property '%s'"	*(char)
,	O
prop_name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
=	O
edma_pget	(long)->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hProp	long
)	O
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
IdProp	array(char)
,	O
prop_name	*(char)
,	O
EDMA_PROP_NAME_LEN	O
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
Tipo	long
=	O
type	long
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
ioTipo	char
=	O
access	(*(char),int)->(int)
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
nElem	long
=	O
nelems	long
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
Off	short
=	O
gClass	O
[	O
class_id	long
]	O
->	O
TamDatos	long
;	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
++	O
;	O
gClass	O
[	O
class_id	long
]	O
->	O
TamDatos	long
+=	O
edma_get_type_size	(long)->(long)
(	O
type	long
)	O
;	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_add_local_class_method	(long,*(char),*(char),*(*(()->(long))),long,long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
met_name	*(char)
,	O
EPChar	*(char)
met_sig	*(char)
,	O
PPROC	*(()->(long))
*	O
f	*(char)
,	O
ESint32	long
mvirtual	long
,	O
ESint32	long
mstatic	long
,	O
ESint32	long
mabstract	long
)	O
{	O
ESint32	long
n	long
,	O
indx	long
;	O
PROCMET	struct(*(*(()->(long))))
aux	struct(*(*(()->(long))))
;	O
if	O
(	O
gClass	O
[	O
class_id	long
]	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_method] Invalid "	*(char)
"Class Identifier [%d]"	*(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
met_name	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_local_class_add_method] Invalid "	*(char)
"method name"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
met_sig	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_local_class_add_method] Invalid "	*(char)
"method signature"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
f	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_local_class_add_method] Invalid function"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ProcMapTable	*(char)
[	O
class_id	long
]	O
!=	O
CLASS_TEMP	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_method] Class %d "	*(char)
"not in definition state"	*(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
edma_get_met_indx	(long,*(char))->(long)
(	O
class_id	long
,	O
met_name	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_method] Method '%s:%s' "	*(char)
"already defined"	*(char)
,	O
met_name	*(char)
,	O
met_sig	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	long
=	O
indx	long
=	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
n	long
++	O
;	O
if	O
(	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hMet	long
=	O
edma_prealloc	(long,long)->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hMet	long
,	O
sizeof	O
(	O
MET	struct(array(char),array(char),char,long,char,char)
)	O
*	O
n	long
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_method] Can't alloc memory "	*(char)
"for method '%s:%s'"	*(char)
,	O
met_name	*(char)
,	O
met_sig	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hMetFunc	long
=	O
edma_prealloc	(long,long)->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hMetFunc	long
,	O
sizeof	O
(	O
PROCMET	struct(*(*(()->(long))))
)	O
*	O
n	long
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_method] Can't alloc memory "	*(char)
"for method '%s:%s'"	*(char)
,	O
met_name	*(char)
,	O
met_sig	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
=	O
edma_pget	(long)->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hMet	long
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
=	O
edma_pget	(long)->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hMetFunc	long
)	O
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
IdMet	array(char)
,	O
met_name	*(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Sign	array(char)
,	O
met_sig	*(char)
,	O
EDMA_MET_SIG_LEN	int
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Virtual	char
=	O
mvirtual	long
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Abstract	char
=	O
mabstract	long
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Static	char
=	O
mstatic	long
;	O
aux	struct(*(*(()->(long))))
.	O
Func	*(()->(long))
=	O
f	*(char)
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
[	O
indx	long
]	O
=	O
aux	struct(*(*(()->(long))))
;	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
++	O
;	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_add_local_class_superclass	(long,long,*(char),*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
CLASSID	long
superclass_id	long
,	O
EPChar	*(char)
pap	*(char)
,	O
EPChar	*(char)
pap1	*(char)
)	O
{	O
ESint32	long
n	long
,	O
indx	long
;	O
if	O
(	O
gClass	O
[	O
class_id	long
]	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_add_local_class_superclass] Invalid "	*(char)
"Class Identifier [%d]"	*(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pap	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_add_local_class_superclass] Invalid "	*(char)
"first preferer anchor point"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pap1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_add_local_class_superclass] Invalid "	*(char)
"second preferer anchor point"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	long
=	O
indx	long
=	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
;	O
n	long
++	O
;	O
if	O
(	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSCList	long
=	O
edma_prealloc	(long,long)->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSCList	long
,	O
sizeof	O
(	O
CLASSID	long
)	O
*	O
n	long
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_superclass] Can't alloc "	*(char)
"memory for superclass %d:'%s'"	*(char)
,	O
class_id	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSCIdList	long
=	O
edma_prealloc	(long,long)->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSCIdList	long
,	O
n	long
*	O
sizeof	O
(	O
ID	array(char)
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_superclass] Can't alloc "	*(char)
"memory for superclass %d:'%s'"	*(char)
,	O
class_id	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSubCIdList	long
=	O
edma_prealloc	(long,long)->(long)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSubCIdList	long
,	O
n	long
*	O
sizeof	O
(	O
ID	array(char)
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_superclass] Can't alloc memory "	*(char)
"for superclass %d:'%s'"	*(char)
,	O
class_id	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SCList	*(long)
=	O
edma_pget	(long)->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSCList	long
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SCIdList	*(array(char))
=	O
edma_pget	(long)->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSCIdList	long
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SubCIdList	*(array(char))
=	O
edma_pget	(long)->(*(void))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
hSubCIdList	long
)	O
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SCList	*(long)
[	O
indx	long
]	O
=	O
superclass_id	long
;	O
if	O
(	O
pap	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
edma_get_class_id	(*(char))->(long)
(	O
pap	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
edma_printf	(*(char))->(long)
(	O
"[edma_add_local_class_add_superclass] WARNNING: "	*(char)
"Uplink Anchor Point '%s' matches "	*(char)
"a classname this may crash your application"	*(char)
,	O
pap	*(char)
)	O
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SCIdList	*(array(char))
[	O
indx	long
]	O
,	O
pap	*(char)
,	O
sizeof	O
(	O
ID	array(char)
)	O
)	O
;	O
}	O
else	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SCIdList	*(array(char))
[	O
indx	long
]	O
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
sizeof	O
(	O
ID	array(char)
)	O
)	O
;	O
if	O
(	O
pap1	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
edma_get_class_id	(*(char))->(long)
(	O
pap1	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
edma_printf	(*(char))->(long)
(	O
"[edma_add_local_class_add_superclass] WARNNING: "	*(char)
"Downlink Anchor Point '%s' matches "	*(char)
"a classname this may crash your application"	*(char)
,	O
pap1	*(char)
)	O
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SubCIdList	*(array(char))
[	O
indx	long
]	O
,	O
pap1	*(char)
,	O
sizeof	O
(	O
ID	array(char)
)	O
)	O
;	O
}	O
else	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SubCIdList	*(array(char))
[	O
indx	long
]	O
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
sizeof	O
(	O
ID	array(char)
)	O
)	O
;	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
++	O
;	O
return	O
indx	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_add_local_class_superclass_by_name	(long,*(char),*(char),*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
class_name	*(char)
,	O
EPChar	*(char)
pap	*(char)
,	O
EPChar	*(char)
pap1	*(char)
)	O
{	O
CLASSID	long
super_cid	long
;	O
if	O
(	O
class_name	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_local_class_add_superclass_by_name] "	*(char)
"Invalid class_name"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
super_cid	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
class_name	*(char)
)	O
;	O
if	O
(	O
super_cid	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_local_class_add_superclass_by_name] Class %s "	*(char)
"doesn't exist"	*(char)
,	O
class_name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
edma_add_local_class_superclass	(long,long,*(char),*(char))->(long)
(	O
class_id	long
,	O
super_cid	long
,	O
pap1	*(char)
,	O
pap	*(char)
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_local_class_finish	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
ProcMapTable	*(char)
[	O
class_id	long
]	O
=	O
CLASS_LOADED	int
;	O
nLocalClasses	long
++	O
;	O
edma_idf_set_class_id	(long)->(long)
(	O
class_id	long
)	O
;	O
return	O
0	int
;	O
}	O
