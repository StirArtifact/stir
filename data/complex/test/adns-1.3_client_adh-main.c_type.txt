int	O
rcode	int
;	O
const	O
char	O
*	O
config_text	*(char)
;	O
static	O
int	O
used	int
,	O
avail	int
;	O
static	O
char	O
*	O
buf	*(char)
;	O
void	O
quitnow	(int)->(void)
(	O
int	O
rc	int
)	O
{	O
if	O
(	O
ads	*(struct)
)	O
adns_finish	(*(struct))->(void)
(	O
ads	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
ov_id	*(char)
)	O
;	O
exit	(int)->(void)
(	O
rc	int
)	O
;	O
}	O
void	O
sysfail	(*(char),int)->(void)
(	O
const	O
char	O
*	O
what	*(char)
,	O
int	O
errnoval	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"adnshost failed: %s: %s\n"	*(char)
,	O
what	*(char)
,	O
strerror	(int)->(*(char))
(	O
errnoval	int
)	O
)	O
;	O
quitnow	(int)->(void)
(	O
10	int
)	O
;	O
}	O
void	O
usageerr	(*(char))->(void)
(	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
al	array(struct(int,int,*(void),*(void)))
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"adnshost usage error: "	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
va_start	O
(	O
al	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
al	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
al	array(struct(int,int,*(void),*(void)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
quitnow	(int)->(void)
(	O
11	int
)	O
;	O
}	O
void	O
outerr	()->(void)
(	O
void	O
)	O
{	O
sysfail	(*(char),int)->(void)
(	O
"write to stdout"	*(char)
,	O
errno	O
)	O
;	O
}	O
void	O
*	O
xmalloc	(long)->(*(void))
(	O
size_t	long
sz	long
)	O
{	O
void	O
*	O
p	*(void)
;	O
p	*(void)
=	O
malloc	(long)->(*(void))
(	O
sz	long
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
sysfail	(*(char),int)->(void)
(	O
"malloc"	*(char)
,	O
sz	long
)	O
;	O
return	O
p	*(void)
;	O
}	O
char	O
*	O
xstrsave	(*(char))->(*(char))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
str	*(char)
)	O
;	O
return	O
p	*(void)
;	O
}	O
void	O
of_config	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
(	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oi	*(struct)
,	O
const	O
char	O
*	O
arg	*(char)
,	O
const	O
char	O
*	O
arg2	*(char)
)	O
{	O
config_text	*(char)
=	O
arg	*(char)
;	O
}	O
void	O
of_type	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)
(	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oi	*(struct)
,	O
const	O
char	O
*	O
arg	*(char)
,	O
const	O
char	O
*	O
arg2	*(char)
)	O
{	O
static	O
const	O
struct	O
typename	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))
{	O
adns_rrtype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
const	O
char	O
*	O
desc	*(char)
;	O
}	O
typenames	array(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
[	O
]	O
=	O
{	O
{	O
adns_r_ns	int
,	O
"ns"	*(char)
}	O
,	O
{	O
adns_r_soa	int
,	O
"soa"	*(char)
}	O
,	O
{	O
adns_r_ptr	int
,	O
"ptr"	*(char)
}	O
,	O
{	O
adns_r_mx	int
,	O
"mx"	*(char)
}	O
,	O
{	O
adns_r_rp	int
,	O
"rp"	*(char)
}	O
,	O
{	O
adns_r_srv	int
,	O
"srv"	*(char)
}	O
,	O
{	O
adns_r_addr	int
,	O
"addr"	*(char)
}	O
,	O
{	O
adns_r_cname	int
,	O
"cname"	*(char)
}	O
,	O
{	O
adns_r_hinfo	int
,	O
"hinfo"	*(char)
}	O
,	O
{	O
adns_r_txt	int
,	O
"txt"	*(char)
}	O
,	O
{	O
adns_r_a	int
,	O
"a"	*(char)
}	O
,	O
{	O
adns_r_ns_raw	int
,	O
"ns-"	*(char)
}	O
,	O
{	O
adns_r_soa_raw	int
,	O
"soa-"	*(char)
}	O
,	O
{	O
adns_r_ptr_raw	int
,	O
"ptr-"	*(char)
}	O
,	O
{	O
adns_r_mx_raw	int
,	O
"mx-"	*(char)
}	O
,	O
{	O
adns_r_rp_raw	int
,	O
"rp-"	*(char)
}	O
,	O
{	O
adns_r_srv_raw	int
,	O
"srv-"	*(char)
}	O
,	O
{	O
adns_r_none	int
,	O
0	int
}	O
}	O
;	O
const	O
struct	O
typename	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char))
*	O
tnp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
;	O
unsigned	O
long	O
unknowntype	long
;	O
char	O
*	O
ep	*(char)
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
>	O
4	int
&&	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
arg	*(char)
,	O
"type"	*(char)
,	O
4	int
)	O
&&	O
(	O
unknowntype	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
+	O
4	int
,	O
&	O
ep	*(char)
,	O
10	int
)	O
,	O
!	O
*	O
ep	*(char)
)	O
&&	O
unknowntype	long
<	O
65536	int
)	O
{	O
ov_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
unknowntype	long
|	O
adns_r_unknown	int
;	O
return	O
;	O
}	O
for	O
(	O
tnp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
=	O
typenames	array(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
;	O
tnp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
tnp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
->	O
desc	*(char)
)	O
;	O
tnp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
++	O
)	O
;	O
if	O
(	O
!	O
tnp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
usageerr	(*(char))->(void)
(	O
"unknown RR type %s"	*(char)
,	O
arg	*(char)
)	O
;	O
ov_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
tnp	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
}	O
static	O
void	O
process_optarg	(*(char),*(*(*(char))),*(char))->(void)
(	O
const	O
char	O
*	O
arg	*(char)
,	O
const	O
char	O
*	O
const	O
*	O
*	O
argv_p	*(*(*(char)))
,	O
const	O
char	O
*	O
value	int
)	O
{	O
const	O
struct	O
optioninfo	struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),*(char),*(char))->(void)),*(char),*(char))
*	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
;	O
const	O
char	O
*	O
arg2	*(char)
;	O
int	O
invert	int
;	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
==	O
'-'	O
||	O
arg	*(char)
[	O
0	int
]	O
==	O
'+'	O
)	O
{	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
==	O
'-'	O
&&	O
arg	*(char)
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
arg	*(char)
,	O
"--no-"	*(char)
,	O
5	int
)	O
)	O
{	O
invert	int
=	O
1	int
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
=	O
opt_findl	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
arg	*(char)
+	O
5	int
)	O
;	O
}	O
else	O
{	O
invert	int
=	O
0	int
;	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
=	O
opt_findl	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
arg	*(char)
+	O
2	int
)	O
;	O
}	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ot_funcarg	int
)	O
{	O
arg	*(char)
=	O
argv_p	*(*(*(char)))
?	O
*	O
++	O
(	O
*	O
argv_p	*(*(*(char)))
)	O
:	O
value	int
;	O
if	O
(	O
!	O
arg	*(char)
)	O
usageerr	(*(char))->(void)
(	O
"option --%s requires a value argument"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
;	O
arg2	*(char)
=	O
0	int
;	O
}	O
else	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ot_funcarg2	int
)	O
{	O
assert	O
(	O
argv_p	*(*(*(char)))
)	O
;	O
arg	*(char)
=	O
*	O
++	O
(	O
*	O
argv_p	*(*(*(char)))
)	O
;	O
arg2	*(char)
=	O
arg	*(char)
?	O
*	O
++	O
(	O
*	O
argv_p	*(*(*(char)))
)	O
:	O
0	int
;	O
if	O
(	O
!	O
arg	*(char)
||	O
!	O
arg2	*(char)
)	O
usageerr	(*(char))->(void)
(	O
"option --%s requires two more arguments"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
value	int
)	O
usageerr	(*(char))->(void)
(	O
"option --%s does not take a value"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
lopt	*(char)
)	O
;	O
arg	*(char)
=	O
0	int
;	O
arg2	*(char)
=	O
0	int
;	O
}	O
opt_do	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),int,*(char),*(char))->(void)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
,	O
invert	int
,	O
arg	*(char)
,	O
arg2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
arg	*(char)
[	O
0	int
]	O
==	O
'-'	O
&&	O
arg	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
{	O
arg	*(char)
=	O
argv_p	*(*(*(char)))
?	O
*	O
++	O
(	O
*	O
argv_p	*(*(*(char)))
)	O
:	O
value	int
;	O
if	O
(	O
!	O
arg	*(char)
)	O
usageerr	(*(char))->(void)
(	O
"option `-' must be followed by a domain"	*(char)
)	O
;	O
query_do	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
}	O
else	O
{	O
invert	int
=	O
(	O
arg	*(char)
[	O
0	int
]	O
==	O
'+'	O
)	O
;	O
++	O
arg	*(char)
;	O
while	O
(	O
*	O
arg	*(char)
)	O
{	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
=	O
opt_finds	(*(*(char)))->(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))))
(	O
&	O
arg	*(char)
)	O
;	O
if	O
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ot_funcarg	int
)	O
{	O
if	O
(	O
!	O
*	O
arg	*(char)
)	O
{	O
arg	*(char)
=	O
argv_p	*(*(*(char)))
?	O
*	O
++	O
(	O
*	O
argv_p	*(*(*(char)))
)	O
:	O
value	int
;	O
if	O
(	O
!	O
arg	*(char)
)	O
usageerr	(*(char))->(void)
(	O
"option -%s requires a value argument"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
value	int
)	O
usageerr	(*(char))->(void)
(	O
"two values for option -%s given !"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
;	O
}	O
opt_do	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),int,*(char),*(char))->(void)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
,	O
invert	int
,	O
arg	*(char)
,	O
0	int
)	O
;	O
arg	*(char)
=	O
""	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
value	int
)	O
usageerr	(*(char))->(void)
(	O
"option -%s does not take a value"	*(char)
,	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
->	O
sopt	*(char)
)	O
;	O
opt_do	(*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*`,*`,*`)->(void)),*(char),*(char))),int,*(char),*(char))->(void)
(	O
oip	*(struct(enum(int,int,int,int,int,int,int),*(char),*(char),*(char),*(int),int,*((*(struct`),*(char),*(char))->(void)),*(char),*(char)))
,	O
invert	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
query_do	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
read_stdin	()->(void)
(	O
void	O
)	O
{	O
int	O
anydone	int
,	O
r	int
;	O
char	O
*	O
newline	*(char)
,	O
*	O
space	*(char)
;	O
anydone	int
=	O
0	int
;	O
while	O
(	O
!	O
anydone	int
||	O
used	int
)	O
{	O
while	O
(	O
!	O
(	O
newline	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
buf	*(char)
,	O
'\n'	O
,	O
used	int
)	O
)	O
)	O
{	O
if	O
(	O
used	int
==	O
avail	int
)	O
{	O
avail	int
+=	O
20	int
;	O
avail	int
<<=	O
1	int
;	O
buf	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
buf	*(char)
,	O
avail	int
)	O
;	O
if	O
(	O
!	O
buf	*(char)
)	O
sysfail	(*(char),int)->(void)
(	O
"realloc stdin buffer"	*(char)
,	O
errno	O
)	O
;	O
}	O
do	O
{	O
r	int
=	O
read	(int,*(void),long)->(long)
(	O
0	int
,	O
buf	*(char)
+	O
used	int
,	O
avail	int
-	O
used	int
)	O
;	O
}	O
while	O
(	O
r	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
if	O
(	O
r	int
==	O
0	int
)	O
{	O
if	O
(	O
used	int
)	O
{	O
buf	*(char)
[	O
used	int
++	O
]	O
=	O
'\n'	O
;	O
r	int
=	O
1	int
;	O
}	O
else	O
{	O
ov_pipe	int
=	O
0	int
;	O
return	O
;	O
}	O
}	O
if	O
(	O
r	int
<	O
0	int
)	O
sysfail	(*(char),int)->(void)
(	O
"read stdin"	*(char)
,	O
errno	O
)	O
;	O
used	int
+=	O
r	int
;	O
}	O
*	O
newline	*(char)
++	O
=	O
0	int
;	O
space	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
' '	O
)	O
;	O
if	O
(	O
space	*(char)
)	O
*	O
space	*(char)
++	O
=	O
0	int
;	O
process_optarg	(*(char),*(*(*(char))),*(char))->(void)
(	O
buf	*(char)
,	O
0	int
,	O
space	*(char)
)	O
;	O
used	int
-=	O
(	O
newline	*(char)
-	O
buf	*(char)
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
,	O
newline	*(char)
,	O
used	int
)	O
;	O
anydone	int
=	O
1	int
;	O
}	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
const	O
char	O
*	O
const	O
*	O
argv	*(*(char))
)	O
{	O
struct	O
timeval	struct(long,long)
*	O
tv	*(struct(long,long))
,	O
tvbuf	struct(long,long)
;	O
adns_query	*(struct)
qu	*(struct)
;	O
void	O
*	O
qun_v	*(void)
;	O
adns_answer	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,int,int,union(*(void),*(char),*(*(char)),*(*(struct(int,*`))),*(struct(int,union(struct`,struct`))),*(struct(int)),*(struct(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*(struct`))),*(struct(array(struct(int,*(char))))),*(struct(array(*(char)))),*(struct(int,struct(*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`))),*(struct(int,*(char))),*(struct(*(char),*(char),long,long,long,long,long)),*(struct(int,int,int,*(char))),*(struct(int,int,int,struct(*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`))),*(struct(int,*(char)))))
*	O
answer	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,int,int,union(*(void),*(char),*(*(char)),*(*(struct`)),*(struct(int,union`)),*(struct(int)),*(struct(*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`)),*(struct(array(struct(int,*(char))))),*(struct(array(*(char)))),*(struct(int,struct`)),*(struct(int,*`)),*(struct(*`,*`,long,long,long,long,long)),*(struct(int,int,int,*`)),*(struct(int,int,int,struct`)),*(struct(int,*`)))))
;	O
int	O
r	int
,	O
maxfd	*(int)
;	O
fd_set	struct(array(long))
readfds	*(struct(array(long)))
,	O
writefds	*(struct(array(long)))
,	O
exceptfds	*(struct(array(long)))
;	O
const	O
char	O
*	O
arg	*(char)
;	O
while	O
(	O
(	O
arg	*(char)
=	O
*	O
++	O
argv	*(*(char))
)	O
)	O
process_optarg	(*(char),*(*(*(char))),*(char))->(void)
(	O
arg	*(char)
,	O
&	O
argv	*(*(char))
,	O
0	int
)	O
;	O
if	O
(	O
!	O
ov_pipe	int
&&	O
!	O
ads	*(struct)
)	O
usageerr	(*(char))->(void)
(	O
"no domains given, and -f/--pipe not used; try --help"	*(char)
)	O
;	O
ensure_adns_init	()->(void)
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
qu	*(struct)
=	O
ov_asynch	int
?	O
0	int
:	O
outstanding	struct(*(struct(*(struct(*`,*`,struct`,*`,*`,*`)),*(struct(*`,*`,struct`,*`,*`,*`)),struct(int,int,int,int),*(char),*(char),*(struct))),*(struct(*(struct(*`,*`,struct`,*`,*`,*`)),*(struct(*`,*`,struct`,*`,*`,*`)),struct(int,int,int,int),*(char),*(char),*(struct))))
.	O
head	*(struct(*(struct(*(struct`),*(struct`),struct(int,int,int,int),*(char),*(char),*(struct`))),*(struct(*(struct`),*(struct`),struct(int,int,int,int),*(char),*(char),*(struct`))),struct(int,int,int,int),*(char),*(char),*(struct)))
?	O
outstanding	struct(*(struct(*(struct(*`,*`,struct`,*`,*`,*`)),*(struct(*`,*`,struct`,*`,*`,*`)),struct(int,int,int,int),*(char),*(char),*(struct))),*(struct(*(struct(*`,*`,struct`,*`,*`,*`)),*(struct(*`,*`,struct`,*`,*`,*`)),struct(int,int,int,int),*(char),*(char),*(struct))))
.	O
head	*(struct(*(struct(*(struct`),*(struct`),struct(int,int,int,int),*(char),*(char),*(struct`))),*(struct(*(struct`),*(struct`),struct(int,int,int,int),*(char),*(char),*(struct`))),struct(int,int,int,int),*(char),*(char),*(struct)))
->	O
qu	*(struct)
:	O
0	int
;	O
r	int
=	O
adns_check	(*(struct),*(*(struct)),*(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,int,int,union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))),*(*(void)))->(int)
(	O
ads	*(struct)
,	O
&	O
qu	*(struct)
,	O
&	O
answer	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,int,int,union(*(void),*(char),*(*(char)),*(*(struct`)),*(struct(int,union`)),*(struct(int)),*(struct(*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`)),*(struct(array(struct(int,*(char))))),*(struct(array(*(char)))),*(struct(int,struct`)),*(struct(int,*`)),*(struct(*`,*`,long,long,long,long,long)),*(struct(int,int,int,*`)),*(struct(int,int,int,struct`)),*(struct(int,*`)))))
,	O
&	O
qun_v	*(void)
)	O
;	O
if	O
(	O
r	int
==	O
EAGAIN	int
)	O
break	O
;	O
if	O
(	O
r	int
==	O
ESRCH	int
)	O
{	O
if	O
(	O
!	O
ov_pipe	int
)	O
goto	O
x_quit	O
;	O
else	O
break	O
;	O
}	O
assert	O
(	O
!	O
r	int
)	O
;	O
query_done	(*(struct(*(struct(*`,*`,struct`,*`,*`,*`)),*(struct(*`,*`,struct`,*`,*`,*`)),struct(int,int,int,int),*(char),*(char),*(struct))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,int,int,union(*(void),*(char),*(*`),*(*`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`)))))->(void)
(	O
qun_v	*(void)
,	O
answer	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,int,int,union(*(void),*(char),*(*(char)),*(*(struct`)),*(struct(int,union`)),*(struct(int)),*(struct(*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,*`)),*(struct(array(struct(int,*(char))))),*(struct(array(*(char)))),*(struct(int,struct`)),*(struct(int,*`)),*(struct(*`,*`,long,long,long,long,long)),*(struct(int,int,int,*`)),*(struct(int,int,int,struct`)),*(struct(int,*`)))))
)	O
;	O
}	O
maxfd	*(int)
=	O
0	int
;	O
FD_ZERO	O
(	O
&	O
readfds	*(struct(array(long)))
)	O
;	O
FD_ZERO	O
(	O
&	O
writefds	*(struct(array(long)))
)	O
;	O
FD_ZERO	O
(	O
&	O
exceptfds	*(struct(array(long)))
)	O
;	O
if	O
(	O
ov_pipe	int
)	O
{	O
maxfd	*(int)
=	O
1	int
;	O
FD_SET	O
(	O
0	int
,	O
&	O
readfds	*(struct(array(long)))
)	O
;	O
}	O
tv	*(struct(long,long))
=	O
0	int
;	O
adns_beforeselect	(*(struct),*(int),*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(*(struct(long,long))),*(struct(long,long)),*(struct(long,long)))->(void)
(	O
ads	*(struct)
,	O
&	O
maxfd	*(int)
,	O
&	O
readfds	*(struct(array(long)))
,	O
&	O
writefds	*(struct(array(long)))
,	O
&	O
exceptfds	*(struct(array(long)))
,	O
&	O
tv	*(struct(long,long))
,	O
&	O
tvbuf	struct(long,long)
,	O
0	int
)	O
;	O
r	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
maxfd	*(int)
,	O
&	O
readfds	*(struct(array(long)))
,	O
&	O
writefds	*(struct(array(long)))
,	O
&	O
exceptfds	*(struct(array(long)))
,	O
tv	*(struct(long,long))
)	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
sysfail	(*(char),int)->(void)
(	O
"select"	*(char)
,	O
errno	O
)	O
;	O
}	O
adns_afterselect	(*(struct),int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(void)
(	O
ads	*(struct)
,	O
maxfd	*(int)
,	O
&	O
readfds	*(struct(array(long)))
,	O
&	O
writefds	*(struct(array(long)))
,	O
&	O
exceptfds	*(struct(array(long)))
,	O
0	int
)	O
;	O
if	O
(	O
ov_pipe	int
&&	O
FD_ISSET	O
(	O
0	int
,	O
&	O
readfds	*(struct(array(long)))
)	O
)	O
read_stdin	()->(void)
(	O
)	O
;	O
}	O
x_quit	O
:	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
outerr	()->(void)
(	O
)	O
;	O
quitnow	(int)->(void)
(	O
rcode	int
)	O
;	O
}	O
