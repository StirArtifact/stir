enum	O
{	O
_OPTION_INIT	int
=	O
255	int
,	O
OPTION_HOST	int
,	O
OPTION_SOURCE	int
,	O
OPTION_LEVDIST	int
,	O
OPTION_SASL	int
,	O
OPTION_NOSASL	int
,	O
OPTION_AUTOLOGIN	int
,	O
OPTION_TIME_STAMP	int
,	O
OPTION_SOURCE_INFO	int
,	O
OPTION_USAGE	int
,	O
MAX_OPTION	int
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"host"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPTION_HOST	int
}	O
,	O
{	O
"port"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"database"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"source"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPTION_SOURCE	int
}	O
,	O
{	O
"match"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'm'	O
}	O
,	O
{	O
"strategy"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"levdist"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPTION_LEVDIST	int
}	O
,	O
{	O
"dbs"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"strategies"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"serverhelp"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
"info"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"serverinfo"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"quiet"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"noauth"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"sasl"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPTION_SASL	int
}	O
,	O
{	O
"nosasl"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPTION_NOSASL	int
}	O
,	O
{	O
"user"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"key"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"autologin"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
OPTION_AUTOLOGIN	int
}	O
,	O
{	O
"client"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"transcript"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"time-stamp"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPTION_TIME_STAMP	int
}	O
,	O
{	O
"source-info"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPTION_SOURCE_INFO	int
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"usage"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
OPTION_USAGE	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
struct	O
grecs_opthelp	struct(*(char),*(char),int,*(char))
opthelp	*(struct)
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Server selection"	*(char)
)	O
}	O
,	O
{	O
"--host"	*(char)
,	O
N_	O
(	O
"SERVER"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"connect to this server"	*(char)
)	O
}	O
,	O
{	O
"-p, --port"	*(char)
,	O
N_	O
(	O
"SERVICE"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"specify port to connect to"	*(char)
)	O
}	O
,	O
{	O
"-d, --database"	*(char)
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"select a database to search"	*(char)
)	O
}	O
,	O
{	O
"--source"	*(char)
,	O
N_	O
(	O
"ADDR"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"set a source address for TCP connections"	*(char)
)	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Operation modes"	*(char)
)	O
}	O
,	O
{	O
"-m, --match"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"match instead of define"	*(char)
)	O
}	O
,	O
{	O
"-s, --strategy"	*(char)
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"select a strategy for matching; implies --match"	*(char)
)	O
}	O
,	O
{	O
"--levdist"	*(char)
,	O
N_	O
(	O
"N"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"set maximum Levenshtein distance"	*(char)
)	O
}	O
,	O
{	O
"-D, --dbs"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"show available databases"	*(char)
)	O
}	O
,	O
{	O
"-S, --strategies"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"show available search strategies"	*(char)
)	O
}	O
,	O
{	O
"-H, --serverhelp"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"show server help"	*(char)
)	O
}	O
,	O
{	O
"-i, --info"	*(char)
,	O
N_	O
(	O
"DBNAME"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"show information about database DBNAME"	*(char)
)	O
}	O
,	O
{	O
"-I, --serverinfo"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"show information about the server"	*(char)
)	O
}	O
,	O
{	O
"-q, --quiet"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"do not print the normal dico welcome"	*(char)
)	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Authentication"	*(char)
)	O
}	O
,	O
{	O
"-a, --noauth"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"disable authentication"	*(char)
)	O
}	O
,	O
{	O
"--sasl"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"enable SASL authentication (default)"	*(char)
)	O
}	O
,	O
{	O
"--nosasl"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"disable SASL authentication"	*(char)
)	O
}	O
,	O
{	O
"-u, --user"	*(char)
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"set user name for authentication"	*(char)
)	O
}	O
,	O
{	O
"-k, --key"	*(char)
,	O
N_	O
(	O
"STRING"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"set shared secret for authentication"	*(char)
)	O
}	O
,	O
{	O
"--autologin"	*(char)
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"set the name of autologin file to use"	*(char)
)	O
}	O
,	O
{	O
"-c, --client"	*(char)
,	O
N_	O
(	O
"STRING"	*(char)
)	O
,	O
0	int
,	O
N_	O
(	O
"additional text for client command"	*(char)
)	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Debugging"	*(char)
)	O
}	O
,	O
{	O
"-t, --transcript"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"enable session transcript"	*(char)
)	O
}	O
,	O
{	O
"-v, --verbose"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"increase debugging verbosity level"	*(char)
)	O
}	O
,	O
{	O
"--time-stamp"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"include time stamp in the debugging output"	*(char)
)	O
}	O
,	O
{	O
"--source-info"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"include source line information in the debugging output"	*(char)
)	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Other options"	*(char)
)	O
}	O
,	O
{	O
"-h, --help"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Give this help list"	*(char)
)	O
}	O
,	O
{	O
"--usage"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Give a short usage message"	*(char)
)	O
}	O
,	O
{	O
"-V, --version"	*(char)
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"Print program version"	*(char)
)	O
}	O
,	O
}	O
;	O
static	O
struct	O
grecs_proginfo	struct(*(char),*(*(char)),*(char),*(char),*(struct),long,*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(void)),*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))
proginfo	struct(*(char),*(*(char)),*(char),*(char),*(struct(*(char),*(char),int,*(char))),long,*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))
=	O
{	O
"dico"	*(char)
,	O
NULL	O
,	O
N_	O
(	O
"GNU dictionary client program"	*(char)
)	O
,	O
N_	O
(	O
"[URL-or-WORD]"	*(char)
)	O
,	O
opthelp	*(struct)
,	O
sizeof	O
(	O
opthelp	*(struct)
)	O
/	O
sizeof	O
(	O
opthelp	*(struct)
[	O
0	int
]	O
)	O
,	O
NULL	O
,	O
NULL	O
,	O
PACKAGE_NAME	*(char)
,	O
PACKAGE_VERSION	*(char)
,	O
NULL	O
,	O
"2005-2017"	*(char)
,	O
"Free Software Foundation, Inc."	*(char)
,	O
NULL	O
,	O
"<"	*(char)
PACKAGE_BUGREPORT	*(char)
">"	*(char)
,	O
PACKAGE_URL	*(char)
,	O
NULL	O
}	O
;	O
void	O
get_options	(int,array(*(char)),*(int))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
,	O
int	O
*	O
index	(*(char),int)->(*(char))
)	O
{	O
{	O
int	O
c	int
;	O
optind	int
=	O
0	int
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"p:d:ms:DSHi:Iqau:k:c:tvhV"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
default	O
:	O
exit	(int)->(void)
(	O
EX_USAGE	int
)	O
;	O
case	O
OPTION_HOST	int
:	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
host	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
case	O
'p'	O
:	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
port	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
case	O
'd'	O
:	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_SOURCE	int
:	O
{	O
source_addr	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
}	O
case	O
'm'	O
:	O
{	O
mode	int
=	O
mode_match	int
;	O
break	O
;	O
}	O
case	O
's'	O
:	O
{	O
xdico_assign_string	(*(*(char)),*(char))->(*(char))
(	O
&	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
strategy	*(char)
,	O
optarg	*(char)
)	O
;	O
mode	int
=	O
mode_match	int
;	O
break	O
;	O
}	O
case	O
OPTION_LEVDIST	int
:	O
{	O
char	O
*	O
p	*(void)
;	O
levenshtein_threshold	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
p	*(void)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	*(void)
)	O
dico_die	(int,int,int,*(char))->(void)
(	O
1	int
,	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: invalid number"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
case	O
'D'	O
:	O
{	O
mode	int
=	O
mode_dbs	int
;	O
break	O
;	O
}	O
case	O
'S'	O
:	O
{	O
mode	int
=	O
mode_strats	int
;	O
break	O
;	O
}	O
case	O
'H'	O
:	O
{	O
mode	int
=	O
mode_help	int
;	O
break	O
;	O
}	O
case	O
'i'	O
:	O
{	O
mode	int
=	O
mode_info	int
;	O
dico_url	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))
.	O
req	struct(int,*(char),*(char),*(char),long)
.	O
database	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
}	O
case	O
'I'	O
:	O
{	O
mode	int
=	O
mode_server	int
;	O
break	O
;	O
}	O
case	O
'q'	O
:	O
{	O
quiet_option	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
'a'	O
:	O
{	O
noauth_option	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
OPTION_SASL	int
:	O
{	O
sasl_enable	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_NOSASL	int
:	O
{	O
sasl_enable	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
}	O
case	O
'u'	O
:	O
{	O
default_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
.	O
user	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
}	O
case	O
'k'	O
:	O
{	O
default_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
.	O
pass	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
}	O
case	O
OPTION_AUTOLOGIN	int
:	O
{	O
autologin_file	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
}	O
case	O
'c'	O
:	O
{	O
client	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
}	O
case	O
't'	O
:	O
{	O
transcript	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
'v'	O
:	O
{	O
debug_level	int
++	O
;	O
break	O
;	O
}	O
case	O
OPTION_TIME_STAMP	int
:	O
{	O
int	O
n	long
=	O
1	int
;	O
dico_stream_ioctl	(*(struct),int,*(void))->(int)
(	O
debug_stream	*(struct)
,	O
DICO_DBG_CTL_SET_TS	int
,	O
&	O
n	long
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_SOURCE_INFO	int
:	O
{	O
debug_source_info	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
'h'	O
:	O
{	O
grecs_print_help	(*(struct(*(char),*(*(char)),*(char),*(char),*(struct(*`,*`,int,*`)),long,*((*`)->(void)),*((*`)->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))))->(void)
(	O
&	O
proginfo	struct(*(char),*(*(char)),*(char),*(char),*(struct(*(char),*(char),int,*(char))),long,*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
}	O
case	O
OPTION_USAGE	int
:	O
{	O
grecs_print_usage	(*(struct(*(char),*(*(char)),*(char),*(char),*(struct(*`,*`,int,*`)),long,*((*`)->(void)),*((*`)->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))))->(void)
(	O
&	O
proginfo	struct(*(char),*(*(char)),*(char),*(char),*(struct(*(char),*(char),int,*(char))),long,*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
}	O
case	O
'V'	O
:	O
{	O
grecs_print_version	(*(struct(*(char),*(*(char)),*(char),*(char),*(struct(*`,*`,int,*`)),long,*((*`)->(void)),*((*`)->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
&	O
proginfo	struct(*(char),*(*(char)),*(char),*(char),*(struct(*(char),*(char),int,*(char))),long,*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
*	O
index	(*(char),int)->(*(char))
=	O
optind	int
;	O
}	O
}	O
static	O
char	O
gplv3_text	array(char)
[	O
]	O
=	O
"   GNU Dico is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   GNU Dico is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GNU Dico.  If not, see <http://www.gnu.org/licenses/>.\n"	*(char)
;	O
void	O
ds_warranty	(int,*(*(char)))->(void)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
grecs_print_version_only	(*(struct(*(char),*(*(char)),*(char),*(char),*(struct(*`,*`,int,*`)),long,*((*`)->(void)),*((*`)->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
&	O
proginfo	struct(*(char),*(*(char)),*(char),*(char),*(struct(*(char),*(char),int,*(char))),long,*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
gplv3_text	array(char)
)	O
;	O
}	O
void	O
shell_banner	()->(void)
(	O
)	O
{	O
grecs_print_version	(*(struct(*(char),*(*(char)),*(char),*(char),*(struct(*`,*`,int,*`)),long,*((*`)->(void)),*((*`)->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
&	O
proginfo	struct(*(char),*(*(char)),*(char),*(char),*(struct(*(char),*(char),int,*(char))),long,*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*((*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))->(void)),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char))
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
"%s\n\n"	*(char)
,	O
_	O
(	O
"Type ? for help summary"	*(char)
)	O
)	O
;	O
}	O
