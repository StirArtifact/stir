public	O
int	O
errmsgs	int
;	O
public	O
int	O
need_clr	int
;	O
public	O
int	O
final_attr	int
;	O
public	O
int	O
at_prompt	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
sc_width	int
;	O
extern	O
int	O
so_s_width	int
,	O
so_e_width	int
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
any_display	int
;	O
extern	O
int	O
is_tty	int
;	O
extern	O
int	O
oldbot	int
;	O
public	O
void	O
put_line	()->(void)
(	O
)	O
{	O
int	O
c	int
;	O
int	O
i	int
;	O
int	O
a	int
;	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
{	O
screen_trashed	int
=	O
1	int
;	O
return	O
;	O
}	O
final_attr	int
=	O
AT_NORMAL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
c	int
=	O
gline	(int,*(int))->(int)
(	O
i	int
,	O
&	O
a	int
)	O
)	O
!=	O
'\0'	O
;	O
i	int
++	O
)	O
{	O
at_switch	(int)->(void)
(	O
a	int
)	O
;	O
final_attr	int
=	O
a	int
;	O
if	O
(	O
c	int
==	O
'\b'	O
)	O
putbs	()->(void)
(	O
)	O
;	O
else	O
putchr	(int)->(int)
(	O
c	int
)	O
;	O
}	O
at_exit	()->(void)
(	O
)	O
;	O
}	O
static	O
char	O
obuf	array(char)
[	O
OUTBUF_SIZE	int
]	O
;	O
static	O
char	O
*	O
ob	*(char)
=	O
obuf	array(char)
;	O
public	O
void	O
flush	()->(void)
(	O
)	O
{	O
int	O
n	int
;	O
int	O
fd	int
;	O
n	int
=	O
(	O
int	O
)	O
(	O
ob	*(char)
-	O
obuf	array(char)
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
fd	int
=	O
(	O
any_display	int
)	O
?	O
1	int
:	O
2	int
;	O
if	O
(	O
write	(int,*(void),long)->(long)
(	O
fd	int
,	O
obuf	array(char)
,	O
n	int
)	O
!=	O
n	int
)	O
screen_trashed	int
=	O
1	int
;	O
ob	*(char)
=	O
obuf	array(char)
;	O
}	O
public	O
int	O
putchr	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
need_clr	int
)	O
{	O
need_clr	int
=	O
0	int
;	O
clear_bot	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
ob	*(char)
>=	O
&	O
obuf	array(char)
[	O
sizeof	O
(	O
obuf	array(char)
)	O
-	O
1	int
]	O
)	O
flush	()->(void)
(	O
)	O
;	O
*	O
ob	*(char)
++	O
=	O
c	int
;	O
at_prompt	int
=	O
0	int
;	O
return	O
(	O
c	int
)	O
;	O
}	O
public	O
void	O
putstr	(*(char))->(void)
(	O
s	*(char)
)	O
constant	O
char	O
*	O
s	*(char)
;	O
{	O
while	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
putchr	(int)->(int)
(	O
*	O
s	*(char)
++	O
)	O
;	O
}	O
TYPE_TO_A_FUNC	O
(	O
postoa	(long,*(char))->(void)
,	O
POSITION	long
)	O
TYPE_TO_A_FUNC	O
(	O
linenumtoa	(long,*(char))->(void)
,	O
LINENUM	long
)	O
TYPE_TO_A_FUNC	O
(	O
inttoa	(int,*(char))->(void)
,	O
int	O
)	O
static	O
int	O
iprint_int	(int)->(int)
(	O
num	long
)	O
int	O
num	long
;	O
{	O
char	O
buf	*(char)
[	O
INT_STRLEN_BOUND	O
(	O
num	long
)	O
]	O
;	O
inttoa	(int,*(char))->(void)
(	O
num	long
,	O
buf	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
buf	*(char)
)	O
;	O
return	O
(	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
iprint_linenum	(long)->(int)
(	O
num	long
)	O
LINENUM	long
num	long
;	O
{	O
char	O
buf	*(char)
[	O
INT_STRLEN_BOUND	O
(	O
num	long
)	O
]	O
;	O
linenumtoa	(long,*(char))->(void)
(	O
num	long
,	O
buf	*(char)
)	O
;	O
putstr	(*(char))->(void)
(	O
buf	*(char)
)	O
;	O
return	O
(	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
less_printf	(*(char),*(union(*(char),int,long)))->(int)
(	O
fmt	*(char)
,	O
parg	union(*(char),int,long)
)	O
char	O
*	O
fmt	*(char)
;	O
PARG	union(*(char),int,long)
*	O
parg	union(*(char),int,long)
;	O
{	O
char	O
*	O
s	*(char)
;	O
int	O
col	int
;	O
col	int
=	O
0	int
;	O
while	O
(	O
*	O
fmt	*(char)
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
fmt	*(char)
!=	O
'%'	O
)	O
{	O
putchr	(int)->(int)
(	O
*	O
fmt	*(char)
++	O
)	O
;	O
col	int
++	O
;	O
}	O
else	O
{	O
++	O
fmt	*(char)
;	O
switch	O
(	O
*	O
fmt	*(char)
++	O
)	O
{	O
case	O
's'	O
:	O
s	*(char)
=	O
parg	union(*(char),int,long)
->	O
p_string	*(char)
;	O
parg	union(*(char),int,long)
++	O
;	O
while	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
putchr	(int)->(int)
(	O
*	O
s	*(char)
++	O
)	O
;	O
col	int
++	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
col	int
+=	O
iprint_int	(int)->(int)
(	O
parg	union(*(char),int,long)
->	O
p_int	int
)	O
;	O
parg	union(*(char),int,long)
++	O
;	O
break	O
;	O
case	O
'n'	O
:	O
col	int
+=	O
iprint_linenum	(long)->(int)
(	O
parg	union(*(char),int,long)
->	O
p_linenum	long
)	O
;	O
parg	union(*(char),int,long)
++	O
;	O
break	O
;	O
case	O
'%'	O
:	O
putchr	(int)->(int)
(	O
'%'	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
(	O
col	int
)	O
;	O
}	O
public	O
void	O
get_return	()->(void)
(	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
getchr	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
'\r'	O
&&	O
c	int
!=	O
' '	O
&&	O
c	int
!=	O
READ_INTR	O
)	O
ungetcc	(long)->(void)
(	O
c	int
)	O
;	O
}	O
public	O
void	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
fmt	*(char)
,	O
parg	union(*(char),int,long)
)	O
char	O
*	O
fmt	*(char)
;	O
PARG	union(*(char),int,long)
*	O
parg	union(*(char),int,long)
;	O
{	O
int	O
col	int
=	O
0	int
;	O
static	O
char	O
return_to_continue	array(char)
[	O
]	O
=	O
"  (press RETURN)"	*(char)
;	O
errmsgs	int
++	O
;	O
if	O
(	O
any_display	int
&&	O
is_tty	int
)	O
{	O
if	O
(	O
!	O
oldbot	int
)	O
squish_check	()->(void)
(	O
)	O
;	O
at_exit	()->(void)
(	O
)	O
;	O
clear_bot	()->(void)
(	O
)	O
;	O
at_enter	(int)->(void)
(	O
AT_STANDOUT	O
)	O
;	O
col	int
+=	O
so_s_width	int
;	O
}	O
col	int
+=	O
less_printf	(*(char),*(union(*(char),int,long)))->(int)
(	O
fmt	*(char)
,	O
parg	union(*(char),int,long)
)	O
;	O
if	O
(	O
!	O
(	O
any_display	int
&&	O
is_tty	int
)	O
)	O
{	O
putchr	(int)->(int)
(	O
'\n'	O
)	O
;	O
return	O
;	O
}	O
putstr	(*(char))->(void)
(	O
return_to_continue	array(char)
)	O
;	O
at_exit	()->(void)
(	O
)	O
;	O
col	int
+=	O
sizeof	O
(	O
return_to_continue	array(char)
)	O
+	O
so_e_width	int
;	O
get_return	()->(void)
(	O
)	O
;	O
lower_left	()->(void)
(	O
)	O
;	O
clear_eol	()->(void)
(	O
)	O
;	O
if	O
(	O
col	int
>=	O
sc_width	int
)	O
screen_trashed	int
=	O
1	int
;	O
flush	()->(void)
(	O
)	O
;	O
}	O
static	O
char	O
intr_to_abort	array(char)
[	O
]	O
=	O
"... (interrupt to abort)"	*(char)
;	O
public	O
void	O
ierror	(*(char),*(union(*(char),int,long)))->(void)
(	O
fmt	*(char)
,	O
parg	union(*(char),int,long)
)	O
char	O
*	O
fmt	*(char)
;	O
PARG	union(*(char),int,long)
*	O
parg	union(*(char),int,long)
;	O
{	O
at_exit	()->(void)
(	O
)	O
;	O
clear_bot	()->(void)
(	O
)	O
;	O
at_enter	(int)->(void)
(	O
AT_STANDOUT	O
)	O
;	O
(	O
void	O
)	O
less_printf	(*(char),*(union(*(char),int,long)))->(int)
(	O
fmt	*(char)
,	O
parg	union(*(char),int,long)
)	O
;	O
putstr	(*(char))->(void)
(	O
intr_to_abort	array(char)
)	O
;	O
at_exit	()->(void)
(	O
)	O
;	O
flush	()->(void)
(	O
)	O
;	O
need_clr	int
=	O
1	int
;	O
}	O
public	O
int	O
query	(*(char),*(union(*(char),int,long)))->(int)
(	O
fmt	*(char)
,	O
parg	union(*(char),int,long)
)	O
char	O
*	O
fmt	*(char)
;	O
PARG	union(*(char),int,long)
*	O
parg	union(*(char),int,long)
;	O
{	O
int	O
c	int
;	O
int	O
col	int
=	O
0	int
;	O
if	O
(	O
any_display	int
&&	O
is_tty	int
)	O
clear_bot	()->(void)
(	O
)	O
;	O
(	O
void	O
)	O
less_printf	(*(char),*(union(*(char),int,long)))->(int)
(	O
fmt	*(char)
,	O
parg	union(*(char),int,long)
)	O
;	O
c	int
=	O
getchr	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
(	O
any_display	int
&&	O
is_tty	int
)	O
)	O
{	O
putchr	(int)->(int)
(	O
'\n'	O
)	O
;	O
return	O
(	O
c	int
)	O
;	O
}	O
lower_left	()->(void)
(	O
)	O
;	O
if	O
(	O
col	int
>=	O
sc_width	int
)	O
screen_trashed	int
=	O
1	int
;	O
flush	()->(void)
(	O
)	O
;	O
return	O
(	O
c	int
)	O
;	O
}	O
