typedef	O
struct	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
{	O
unsigned	O
long	O
used	long
;	O
const	O
void	O
*	O
key	*(void)
;	O
size_t	long
keylen	long
;	O
void	O
*	O
data	*(void)
;	O
struct	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
next	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
;	O
}	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
;	O
static	O
int	O
is_prime	(long)->(int)
(	O
unsigned	O
long	O
int	O
candidate	long
)	O
{	O
unsigned	O
long	O
int	O
divn	long
=	O
3	int
;	O
unsigned	O
long	O
int	O
sq	long
=	O
divn	long
*	O
divn	long
;	O
while	O
(	O
sq	long
<	O
candidate	long
&&	O
candidate	long
%	O
divn	long
!=	O
0	int
)	O
{	O
++	O
divn	long
;	O
sq	long
+=	O
4	int
*	O
divn	long
;	O
++	O
divn	long
;	O
}	O
return	O
candidate	long
%	O
divn	long
!=	O
0	int
;	O
}	O
unsigned	O
long	O
next_prime	(long)->(long)
(	O
unsigned	O
long	O
int	O
seed	long
)	O
{	O
seed	long
|=	O
1	int
;	O
while	O
(	O
!	O
is_prime	(long)->(int)
(	O
seed	long
)	O
)	O
seed	long
+=	O
2	int
;	O
return	O
seed	long
;	O
}	O
int	O
hash_init	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),long)->(int)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
unsigned	O
long	O
int	O
init_size	long
)	O
{	O
init_size	long
=	O
next_prime	(long)->(long)
(	O
init_size	long
)	O
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
=	O
init_size	long
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
filled	long
=	O
0	int
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
=	O
NULL	O
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
=	O
XCALLOC	O
(	O
init_size	long
+	O
1	int
,	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
)	O
;	O
obstack_init	O
(	O
&	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
mem_pool	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
hash_destroy	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(int)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
)	O
{	O
free	(*(void))->(void)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
)	O
;	O
obstack_free	O
(	O
&	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
mem_pool	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
unsigned	O
long	O
compute_hashval	(*(void),long)->(long)
(	O
const	O
void	O
*	O
key	*(void)
,	O
size_t	long
keylen	long
)	O
{	O
size_t	long
cnt	long
;	O
unsigned	O
long	O
int	O
hval	long
;	O
cnt	long
=	O
0	int
;	O
hval	long
=	O
keylen	long
;	O
while	O
(	O
cnt	long
<	O
keylen	long
)	O
{	O
hval	long
=	O
(	O
hval	long
<<	O
9	int
)	O
|	O
(	O
hval	long
>>	O
(	O
sizeof	O
(	O
unsigned	O
long	O
)	O
*	O
CHAR_BIT	O
-	O
9	int
)	O
)	O
;	O
hval	long
+=	O
(	O
unsigned	O
long	O
int	O
)	O
*	O
(	O
(	O
(	O
const	O
char	O
*	O
)	O
key	*(void)
)	O
+	O
cnt	long
++	O
)	O
;	O
}	O
return	O
hval	long
!=	O
0	int
?	O
hval	long
:	O
~	O
(	O
(	O
unsigned	O
long	O
)	O
0	int
)	O
;	O
}	O
static	O
size_t	long
lookup	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long)->(long)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
const	O
void	O
*	O
key	*(void)
,	O
size_t	long
keylen	long
,	O
unsigned	O
long	O
int	O
hval	long
)	O
{	O
unsigned	O
long	O
int	O
hash	long
;	O
size_t	long
idx	long
;	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
table	*(struct)
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
;	O
hash	long
=	O
1	int
+	O
hval	long
%	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
;	O
idx	long
=	O
hash	long
;	O
if	O
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
)	O
{	O
if	O
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
==	O
hval	long
&&	O
table	*(struct)
[	O
idx	long
]	O
.	O
keylen	long
==	O
keylen	long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
key	*(void)
,	O
key	*(void)
,	O
keylen	long
)	O
==	O
0	int
)	O
return	O
idx	long
;	O
hash	long
=	O
1	int
+	O
hval	long
%	O
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
-	O
2	int
)	O
;	O
do	O
{	O
if	O
(	O
idx	long
<=	O
hash	long
)	O
idx	long
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
+	O
idx	long
-	O
hash	long
;	O
else	O
idx	long
-=	O
hash	long
;	O
if	O
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
==	O
hval	long
&&	O
table	*(struct)
[	O
idx	long
]	O
.	O
keylen	long
==	O
keylen	long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
key	*(void)
,	O
key	*(void)
,	O
keylen	long
)	O
==	O
0	int
)	O
return	O
idx	long
;	O
}	O
while	O
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
)	O
;	O
}	O
return	O
idx	long
;	O
}	O
int	O
hash_find_entry	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,*(*(void)))->(int)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
const	O
void	O
*	O
key	*(void)
,	O
size_t	long
keylen	long
,	O
void	O
*	O
*	O
result	*(*(void))
)	O
{	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
table	*(struct)
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
;	O
size_t	long
idx	long
=	O
lookup	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long)->(long)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
key	*(void)
,	O
keylen	long
,	O
compute_hashval	(*(void),long)->(long)
(	O
key	*(void)
,	O
keylen	long
)	O
)	O
;	O
if	O
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
*	O
result	*(*(void))
=	O
table	*(struct)
[	O
idx	long
]	O
.	O
data	*(void)
;	O
return	O
0	int
;	O
}	O
static	O
void	O
insert_entry_2	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long,long,*(void))->(void)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
const	O
void	O
*	O
key	*(void)
,	O
size_t	long
keylen	long
,	O
unsigned	O
long	O
int	O
hval	long
,	O
size_t	long
idx	long
,	O
void	O
*	O
data	*(void)
)	O
{	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
table	*(struct)
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
;	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
=	O
hval	long
;	O
table	*(struct)
[	O
idx	long
]	O
.	O
key	*(void)
=	O
key	*(void)
;	O
table	*(struct)
[	O
idx	long
]	O
.	O
keylen	long
=	O
keylen	long
;	O
table	*(struct)
[	O
idx	long
]	O
.	O
data	*(void)
=	O
data	*(void)
;	O
if	O
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
==	O
NULL	O
)	O
{	O
table	*(struct)
[	O
idx	long
]	O
.	O
next	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
&	O
table	*(struct)
[	O
idx	long
]	O
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
=	O
&	O
table	*(struct)
[	O
idx	long
]	O
;	O
}	O
else	O
{	O
table	*(struct)
[	O
idx	long
]	O
.	O
next	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
->	O
next	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
->	O
next	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
&	O
table	*(struct)
[	O
idx	long
]	O
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
=	O
&	O
table	*(struct)
[	O
idx	long
]	O
;	O
}	O
++	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
filled	long
;	O
}	O
static	O
void	O
resize	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(void)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
)	O
{	O
unsigned	O
long	O
int	O
old_size	long
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
;	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
table	*(struct)
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
;	O
size_t	long
idx	long
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
=	O
next_prime	(long)->(long)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
*	O
2	int
)	O
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
filled	long
=	O
0	int
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
=	O
NULL	O
;	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
=	O
XCALLOC	O
(	O
1	int
+	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
,	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
)	O
;	O
for	O
(	O
idx	long
=	O
1	int
;	O
idx	long
<=	O
old_size	long
;	O
++	O
idx	long
)	O
if	O
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
)	O
insert_entry_2	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long,long,*(void))->(void)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
table	*(struct)
[	O
idx	long
]	O
.	O
key	*(void)
,	O
table	*(struct)
[	O
idx	long
]	O
.	O
keylen	long
,	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
,	O
lookup	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long)->(long)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
table	*(struct)
[	O
idx	long
]	O
.	O
key	*(void)
,	O
table	*(struct)
[	O
idx	long
]	O
.	O
keylen	long
,	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
)	O
,	O
table	*(struct)
[	O
idx	long
]	O
.	O
data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
table	*(struct)
)	O
;	O
}	O
const	O
void	O
*	O
hash_insert_entry	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,*(void))->(*(void))
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
const	O
void	O
*	O
key	*(void)
,	O
size_t	long
keylen	long
,	O
void	O
*	O
data	*(void)
)	O
{	O
unsigned	O
long	O
int	O
hval	long
=	O
compute_hashval	(*(void),long)->(long)
(	O
key	*(void)
,	O
keylen	long
)	O
;	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
table	*(struct)
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
;	O
size_t	long
idx	long
=	O
lookup	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long)->(long)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
key	*(void)
,	O
keylen	long
,	O
hval	long
)	O
;	O
if	O
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
)	O
return	O
NULL	O
;	O
else	O
{	O
void	O
*	O
keycopy	*(void)
=	O
obstack_copy	O
(	O
&	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
mem_pool	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
key	*(void)
,	O
keylen	long
)	O
;	O
insert_entry_2	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long,long,*(void))->(void)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
keycopy	*(void)
,	O
keylen	long
,	O
hval	long
,	O
idx	long
,	O
data	*(void)
)	O
;	O
if	O
(	O
100	int
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
filled	long
>	O
75	int
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
)	O
resize	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(void)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
)	O
;	O
return	O
keycopy	*(void)
;	O
}	O
}	O
int	O
hash_set_value	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,*(void))->(int)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
const	O
void	O
*	O
key	*(void)
,	O
size_t	long
keylen	long
,	O
void	O
*	O
data	*(void)
)	O
{	O
unsigned	O
long	O
int	O
hval	long
=	O
compute_hashval	(*(void),long)->(long)
(	O
key	*(void)
,	O
keylen	long
)	O
;	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
table	*(struct)
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
table	*(struct)
;	O
size_t	long
idx	long
=	O
lookup	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long)->(long)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
key	*(void)
,	O
keylen	long
,	O
hval	long
)	O
;	O
if	O
(	O
table	*(struct)
[	O
idx	long
]	O
.	O
used	long
)	O
{	O
table	*(struct)
[	O
idx	long
]	O
.	O
data	*(void)
=	O
data	*(void)
;	O
return	O
0	int
;	O
}	O
else	O
{	O
void	O
*	O
keycopy	*(void)
=	O
obstack_copy	O
(	O
&	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
mem_pool	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
key	*(void)
,	O
keylen	long
)	O
;	O
insert_entry_2	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(void),long,long,long,*(void))->(void)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
keycopy	*(void)
,	O
keylen	long
,	O
hval	long
,	O
idx	long
,	O
data	*(void)
)	O
;	O
if	O
(	O
100	int
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
filled	long
>	O
75	int
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
size	long
)	O
resize	(*(struct(long,long,*(struct(long,*`,long,*`,*`)),*(struct(long,*`,long,*`,*`)),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(void)
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
)	O
;	O
return	O
0	int
;	O
}	O
}	O
int	O
hash_iterate	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(*(void)),*(*(void)),*(long),*(*(void)))->(int)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
void	O
*	O
*	O
ptr	*(*(void))
,	O
const	O
void	O
*	O
*	O
key	*(void)
,	O
size_t	long
*	O
keylen	long
,	O
void	O
*	O
*	O
data	*(void)
)	O
{	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
;	O
if	O
(	O
*	O
ptr	*(*(void))
==	O
NULL	O
)	O
{	O
if	O
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
;	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr	*(*(void))
==	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
)	O
return	O
-	O
1	int
;	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
(	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
)	O
*	O
ptr	*(*(void))
;	O
}	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
->	O
next	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
;	O
*	O
ptr	*(*(void))
=	O
(	O
void	O
*	O
)	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
;	O
*	O
key	*(void)
=	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
->	O
key	*(void)
;	O
*	O
keylen	long
=	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
->	O
keylen	long
;	O
*	O
data	*(void)
=	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
->	O
data	*(void)
;	O
return	O
0	int
;	O
}	O
int	O
hash_iterate_modify	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(*(void)),*(*(void)),*(long),*(*(*(void))))->(int)
(	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
void	O
*	O
*	O
ptr	*(*(void))
,	O
const	O
void	O
*	O
*	O
key	*(void)
,	O
size_t	long
*	O
keylen	long
,	O
void	O
*	O
*	O
*	O
datap	*(*(*(void)))
)	O
{	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
;	O
if	O
(	O
*	O
ptr	*(*(void))
==	O
NULL	O
)	O
{	O
if	O
(	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
;	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr	*(*(void))
==	O
htab	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
->	O
first	*(struct)
)	O
return	O
-	O
1	int
;	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
(	O
hash_entry	struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`))))))
*	O
)	O
*	O
ptr	*(*(void))
;	O
}	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
=	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
->	O
next	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
;	O
*	O
ptr	*(*(void))
=	O
(	O
void	O
*	O
)	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
;	O
*	O
key	*(void)
=	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
->	O
key	*(void)
;	O
*	O
keylen	long
=	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
->	O
keylen	long
;	O
*	O
datap	*(*(*(void)))
=	O
&	O
curr	*(struct(long,*(void),long,*(void),*(struct(long,*(void),long,*(void),*(struct`)))))
->	O
data	*(void)
;	O
return	O
0	int
;	O
}	O
