static	O
void	O
scale_and_align_entries	O
(	O
void	O
)	O
;	O
static	O
void	O
print_header	O
(	O
int	O
)	O
;	O
static	O
void	O
print_line	O
(	O
Sym	O
*	O
,	O
double	O
)	O
;	O
static	O
int	O
cmp_time	O
(	O
const	O
PTR	O
,	O
const	O
PTR	O
)	O
;	O
extern	O
void	O
flat_blurb	O
(	O
FILE	struct
*	O
fp	O
)	O
;	O
static	O
histogram	O
*	O
find_histogram	O
(	O
bfd_vma	long
lowpc	O
,	O
bfd_vma	long
highpc	O
)	O
;	O
static	O
histogram	O
*	O
find_histogram_for_pc	O
(	O
bfd_vma	long
pc	O
)	O
;	O
histogram	O
*	O
histograms	O
;	O
unsigned	O
num_histograms	O
;	O
double	O
hist_scale	O
;	O
static	O
char	O
hist_dimension	O
[	O
16	int
]	O
=	O
"seconds"	*(char)
;	O
static	O
char	O
hist_dimension_abbrev	O
=	O
's'	O
;	O
static	O
double	O
accum_time	O
;	O
static	O
double	O
total_time	O
;	O
const	O
struct	O
{	O
char	O
prefix	O
;	O
double	O
scale	O
;	O
}	O
SItab	O
[	O
]	O
=	O
{	O
{	O
'T'	O
,	O
1e-12	int
}	O
,	O
{	O
'G'	O
,	O
1e-09	int
}	O
,	O
{	O
'M'	O
,	O
1e-06	int
}	O
,	O
{	O
'K'	O
,	O
1e-03	int
}	O
,	O
{	O
' '	O
,	O
1e-00	int
}	O
,	O
{	O
'm'	O
,	O
1e+03	int
}	O
,	O
{	O
'u'	O
,	O
1e+06	int
}	O
,	O
{	O
'n'	O
,	O
1e+09	int
}	O
,	O
{	O
'p'	O
,	O
1e+12	int
}	O
,	O
{	O
'f'	O
,	O
1e+15	int
}	O
,	O
{	O
'a'	O
,	O
1e+18	int
}	O
}	O
;	O
static	O
void	O
read_histogram_header	O
(	O
histogram	O
*	O
record	O
,	O
FILE	struct
*	O
ifp	O
,	O
const	O
char	O
*	O
filename	*(char)
,	O
int	O
first	O
)	O
{	O
unsigned	O
int	O
profrate	O
;	O
char	O
n_hist_dimension	O
[	O
15	int
]	O
;	O
char	O
n_hist_dimension_abbrev	O
;	O
double	O
n_hist_scale	O
;	O
if	O
(	O
gmon_io_read_vma	O
(	O
ifp	O
,	O
&	O
record	O
->	O
lowpc	O
)	O
||	O
gmon_io_read_vma	O
(	O
ifp	O
,	O
&	O
record	O
->	O
highpc	O
)	O
||	O
gmon_io_read_32	O
(	O
ifp	O
,	O
&	O
record	O
->	O
num_bins	O
)	O
||	O
gmon_io_read_32	O
(	O
ifp	O
,	O
&	O
profrate	O
)	O
||	O
gmon_io_read	O
(	O
ifp	O
,	O
n_hist_dimension	O
,	O
15	int
)	O
||	O
gmon_io_read	O
(	O
ifp	O
,	O
&	O
n_hist_dimension_abbrev	O
,	O
1	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: %s: unexpected end of file\n"	*(char)
)	O
,	O
whoami	O
,	O
filename	*(char)
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
n_hist_scale	O
=	O
(	O
double	O
)	O
(	O
(	O
record	O
->	O
highpc	O
-	O
record	O
->	O
lowpc	O
)	O
/	O
sizeof	O
(	O
UNIT	O
)	O
)	O
/	O
record	O
->	O
num_bins	O
;	O
if	O
(	O
first	O
)	O
{	O
hz	O
=	O
profrate	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hist_dimension	O
,	O
n_hist_dimension	O
,	O
15	int
)	O
;	O
hist_dimension_abbrev	O
=	O
n_hist_dimension_abbrev	O
;	O
hist_scale	O
=	O
n_hist_scale	O
;	O
}	O
else	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
n_hist_dimension	O
,	O
hist_dimension	O
,	O
15	int
)	O
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: dimension unit changed between histogram records\n"	*(char)
"%s: from '%s'\n"	*(char)
"%s: to '%s'\n"	*(char)
)	O
,	O
whoami	O
,	O
whoami	O
,	O
hist_dimension	O
,	O
whoami	O
,	O
n_hist_dimension	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
n_hist_dimension_abbrev	O
!=	O
hist_dimension_abbrev	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: dimension abbreviation changed between histogram records\n"	*(char)
"%s: from '%c'\n"	*(char)
"%s: to '%c'\n"	*(char)
)	O
,	O
whoami	O
,	O
whoami	O
,	O
hist_dimension_abbrev	O
,	O
whoami	O
,	O
n_hist_dimension_abbrev	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fabs	O
(	O
hist_scale	O
-	O
n_hist_scale	O
)	O
>	O
0.000001	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: different scales in histogram records"	*(char)
)	O
,	O
whoami	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
hist_read_rec	O
(	O
FILE	struct
*	O
ifp	O
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
bfd_vma	long
lowpc	O
,	O
highpc	O
;	O
histogram	O
n_record	O
;	O
histogram	O
*	O
record	O
,	O
*	O
existing_record	O
;	O
unsigned	O
i	*(struct)
;	O
read_histogram_header	O
(	O
&	O
n_record	O
,	O
ifp	O
,	O
filename	*(char)
,	O
num_histograms	O
==	O
0	int
)	O
;	O
existing_record	O
=	O
find_histogram	O
(	O
n_record	O
.	O
lowpc	O
,	O
n_record	O
.	O
highpc	O
)	O
;	O
if	O
(	O
existing_record	O
)	O
{	O
record	O
=	O
existing_record	O
;	O
}	O
else	O
{	O
lowpc	O
=	O
n_record	O
.	O
lowpc	O
;	O
highpc	O
=	O
n_record	O
.	O
highpc	O
;	O
hist_clip_symbol_address	O
(	O
&	O
lowpc	O
,	O
&	O
highpc	O
)	O
;	O
if	O
(	O
lowpc	O
!=	O
highpc	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: overlapping histogram records\n"	*(char)
)	O
,	O
whoami	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
histograms	O
=	O
(	O
struct	O
histogram	O
*	O
)	O
xrealloc	O
(	O
histograms	O
,	O
sizeof	O
(	O
histogram	O
)	O
*	O
(	O
num_histograms	O
+	O
1	int
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
histograms	O
+	O
num_histograms	O
,	O
&	O
n_record	O
,	O
sizeof	O
(	O
histogram	O
)	O
)	O
;	O
record	O
=	O
&	O
histograms	O
[	O
num_histograms	O
]	O
;	O
++	O
num_histograms	O
;	O
record	O
->	O
sample	O
=	O
(	O
int	O
*	O
)	O
xmalloc	O
(	O
record	O
->	O
num_bins	O
*	O
sizeof	O
(	O
record	O
->	O
sample	O
[	O
0	int
]	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
record	O
->	O
sample	O
,	O
0	int
,	O
record	O
->	O
num_bins	O
*	O
sizeof	O
(	O
record	O
->	O
sample	O
[	O
0	int
]	O
)	O
)	O
;	O
}	O
DBG	O
(	O
SAMPLEDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[hist_read_rec] n_lowpc 0x%lx n_highpc 0x%lx ncnt %u\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
record	O
->	O
lowpc	O
,	O
(	O
unsigned	O
long	O
)	O
record	O
->	O
highpc	O
,	O
record	O
->	O
num_bins	O
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
record	O
->	O
num_bins	O
;	O
++	O
i	*(struct)
)	O
{	O
UNIT	O
count	int
;	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
count	int
[	O
0	int
]	O
,	O
sizeof	O
(	O
count	int
)	O
,	O
1	int
,	O
ifp	O
)	O
!=	O
1	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: %s: unexpected EOF after reading %u of %u samples\n"	*(char)
)	O
,	O
whoami	O
,	O
filename	*(char)
,	O
i	*(struct)
,	O
record	O
->	O
num_bins	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
record	O
->	O
sample	O
[	O
i	*(struct)
]	O
+=	O
bfd_get_16	O
(	O
core_bfd	*(struct(*(char),*(struct),*(void),*(struct),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),long,long,struct(*(*(struct`)),*((*`,*`,*`)->(*`)),*(void),int,int,int,int),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,long,*(*(struct(*`,*`,long,int,*`,union`))),int,int,*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(void),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),union(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct)),union(*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(void)),*(void),*(void),*(struct(long,array(char)))))
,	O
(	O
bfd_byte	char
*	O
)	O
&	O
count	int
[	O
0	int
]	O
)	O
;	O
DBG	O
(	O
SAMPLEDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[hist_read_rec] 0x%lx: %u\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
(	O
record	O
->	O
lowpc	O
+	O
i	*(struct)
*	O
(	O
record	O
->	O
highpc	O
-	O
record	O
->	O
lowpc	O
)	O
/	O
record	O
->	O
num_bins	O
)	O
,	O
record	O
->	O
sample	O
[	O
i	*(struct)
]	O
)	O
)	O
;	O
}	O
}	O
void	O
hist_write_hist	O
(	O
FILE	struct
*	O
ofp	O
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
UNIT	O
count	int
;	O
unsigned	O
int	O
i	*(struct)
,	O
r	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
num_histograms	O
;	O
++	O
r	O
)	O
{	O
histogram	O
*	O
record	O
=	O
&	O
histograms	O
[	O
r	O
]	O
;	O
if	O
(	O
gmon_io_write_8	O
(	O
ofp	O
,	O
GMON_TAG_TIME_HIST	O
)	O
||	O
gmon_io_write_vma	O
(	O
ofp	O
,	O
record	O
->	O
lowpc	O
)	O
||	O
gmon_io_write_vma	O
(	O
ofp	O
,	O
record	O
->	O
highpc	O
)	O
||	O
gmon_io_write_32	O
(	O
ofp	O
,	O
record	O
->	O
num_bins	O
)	O
||	O
gmon_io_write_32	O
(	O
ofp	O
,	O
hz	O
)	O
||	O
gmon_io_write	O
(	O
ofp	O
,	O
hist_dimension	O
,	O
15	int
)	O
||	O
gmon_io_write	O
(	O
ofp	O
,	O
&	O
hist_dimension_abbrev	O
,	O
1	int
)	O
)	O
{	O
perror	(*(char))->(void)
(	O
filename	*(char)
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
record	O
->	O
num_bins	O
;	O
++	O
i	*(struct)
)	O
{	O
bfd_put_16	O
(	O
core_bfd	*(struct(*(char),*(struct),*(void),*(struct),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),long,long,struct(*(*(struct`)),*((*`,*`,*`)->(*`)),*(void),int,int,int,int),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,long,*(*(struct(*`,*`,long,int,*`,union`))),int,int,*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),*(void),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),union(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(struct)),union(*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(void)),*(void),*(void),*(struct(long,array(char)))))
,	O
(	O
bfd_vma	long
)	O
record	O
->	O
sample	O
[	O
i	*(struct)
]	O
,	O
(	O
bfd_byte	char
*	O
)	O
&	O
count	int
[	O
0	int
]	O
)	O
;	O
if	O
(	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
count	int
[	O
0	int
]	O
,	O
sizeof	O
(	O
count	int
)	O
,	O
1	int
,	O
ofp	O
)	O
!=	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
filename	*(char)
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
scale_and_align_entries	O
(	O
void	O
)	O
{	O
Sym	O
*	O
sym	*(struct)
;	O
bfd_vma	long
bin_of_entry	O
;	O
bfd_vma	long
bin_of_code	O
;	O
for	O
(	O
sym	*(struct)
=	O
symtab	O
.	O
base	int
;	O
sym	*(struct)
<	O
symtab	O
.	O
limit	O
;	O
sym	*(struct)
++	O
)	O
{	O
histogram	O
*	O
r	O
=	O
find_histogram_for_pc	O
(	O
sym	*(struct)
->	O
addr	*(void)
)	O
;	O
sym	*(struct)
->	O
hist	O
.	O
scaled_addr	O
=	O
sym	*(struct)
->	O
addr	*(void)
/	O
sizeof	O
(	O
UNIT	O
)	O
;	O
if	O
(	O
r	O
)	O
{	O
bin_of_entry	O
=	O
(	O
sym	*(struct)
->	O
hist	O
.	O
scaled_addr	O
-	O
r	O
->	O
lowpc	O
)	O
/	O
hist_scale	O
;	O
bin_of_code	O
=	O
(	O
(	O
sym	*(struct)
->	O
hist	O
.	O
scaled_addr	O
+	O
UNITS_TO_CODE	O
-	O
r	O
->	O
lowpc	O
)	O
/	O
hist_scale	O
)	O
;	O
if	O
(	O
bin_of_entry	O
<	O
bin_of_code	O
)	O
{	O
DBG	O
(	O
SAMPLEDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[scale_and_align_entries] pushing 0x%lx to 0x%lx\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
sym	*(struct)
->	O
hist	O
.	O
scaled_addr	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
sym	*(struct)
->	O
hist	O
.	O
scaled_addr	O
+	O
UNITS_TO_CODE	O
)	O
)	O
)	O
;	O
sym	*(struct)
->	O
hist	O
.	O
scaled_addr	O
+=	O
UNITS_TO_CODE	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
hist_assign_samples_1	O
(	O
histogram	O
*	O
r	O
)	O
{	O
bfd_vma	long
bin_low_pc	O
,	O
bin_high_pc	O
;	O
bfd_vma	long
sym_low_pc	O
,	O
sym_high_pc	O
;	O
bfd_vma	long
overlap	O
,	O
addr	*(void)
;	O
unsigned	O
int	O
bin_count	O
;	O
unsigned	O
int	O
i	*(struct)
,	O
j	O
,	O
k	O
;	O
double	O
count_time	O
,	O
credit	O
;	O
bfd_vma	long
lowpc	O
=	O
r	O
->	O
lowpc	O
/	O
sizeof	O
(	O
UNIT	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
k	O
=	O
1	int
;	O
i	*(struct)
<	O
r	O
->	O
num_bins	O
;	O
++	O
i	*(struct)
)	O
{	O
bin_count	O
=	O
r	O
->	O
sample	O
[	O
i	*(struct)
]	O
;	O
if	O
(	O
!	O
bin_count	O
)	O
continue	O
;	O
bin_low_pc	O
=	O
lowpc	O
+	O
(	O
bfd_vma	long
)	O
(	O
hist_scale	O
*	O
i	*(struct)
)	O
;	O
bin_high_pc	O
=	O
lowpc	O
+	O
(	O
bfd_vma	long
)	O
(	O
hist_scale	O
*	O
(	O
i	*(struct)
+	O
1	int
)	O
)	O
;	O
count_time	O
=	O
bin_count	O
;	O
DBG	O
(	O
SAMPLEDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[assign_samples] bin_low_pc=0x%lx, bin_high_pc=0x%lx, bin_count=%u\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
(	O
sizeof	O
(	O
UNIT	O
)	O
*	O
bin_low_pc	O
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
sizeof	O
(	O
UNIT	O
)	O
*	O
bin_high_pc	O
)	O
,	O
bin_count	O
)	O
)	O
;	O
total_time	O
+=	O
count_time	O
;	O
for	O
(	O
j	O
=	O
k	O
-	O
1	int
;	O
j	O
<	O
symtab	O
.	O
len	long
;	O
k	O
=	O
++	O
j	O
)	O
{	O
sym_low_pc	O
=	O
symtab	O
.	O
base	int
[	O
j	O
]	O
.	O
hist	O
.	O
scaled_addr	O
;	O
sym_high_pc	O
=	O
symtab	O
.	O
base	int
[	O
j	O
+	O
1	int
]	O
.	O
hist	O
.	O
scaled_addr	O
;	O
if	O
(	O
bin_high_pc	O
<	O
sym_low_pc	O
)	O
break	O
;	O
if	O
(	O
bin_low_pc	O
>=	O
sym_high_pc	O
)	O
continue	O
;	O
overlap	O
=	O
MIN	O
(	O
bin_high_pc	O
,	O
sym_high_pc	O
)	O
-	O
MAX	O
(	O
bin_low_pc	O
,	O
sym_low_pc	O
)	O
;	O
if	O
(	O
overlap	O
>	O
0	int
)	O
{	O
DBG	O
(	O
SAMPLEDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[assign_samples] [0x%lx,0x%lx) %s gets %f ticks %ld overlap\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
symtab	O
.	O
base	int
[	O
j	O
]	O
.	O
addr	*(void)
,	O
(	O
unsigned	O
long	O
)	O
(	O
sizeof	O
(	O
UNIT	O
)	O
*	O
sym_high_pc	O
)	O
,	O
symtab	O
.	O
base	int
[	O
j	O
]	O
.	O
name	*(char)
,	O
overlap	O
*	O
count_time	O
/	O
hist_scale	O
,	O
(	O
long	O
)	O
overlap	O
)	O
)	O
;	O
addr	*(void)
=	O
symtab	O
.	O
base	int
[	O
j	O
]	O
.	O
addr	*(void)
;	O
credit	O
=	O
overlap	O
*	O
count_time	O
/	O
hist_scale	O
;	O
if	O
(	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_FLAT	O
]	O
,	O
addr	*(void)
)	O
||	O
(	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_FLAT	O
]	O
.	O
len	long
==	O
0	int
&&	O
!	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
EXCL_FLAT	O
]	O
,	O
addr	*(void)
)	O
)	O
)	O
{	O
symtab	O
.	O
base	int
[	O
j	O
]	O
.	O
hist	O
.	O
time	struct(long,long)
+=	O
credit	O
;	O
}	O
else	O
{	O
total_time	O
-=	O
credit	O
;	O
}	O
}	O
}	O
}	O
DBG	O
(	O
SAMPLEDEBUG	O
,	O
printf	(*(char))->(int)
(	O
"[assign_samples] total_time %f\n"	*(char)
,	O
total_time	O
)	O
)	O
;	O
}	O
void	O
hist_assign_samples	O
(	O
void	O
)	O
{	O
unsigned	O
i	*(struct)
;	O
scale_and_align_entries	O
(	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
num_histograms	O
;	O
++	O
i	*(struct)
)	O
hist_assign_samples_1	O
(	O
&	O
histograms	O
[	O
i	*(struct)
]	O
)	O
;	O
}	O
static	O
void	O
print_header	O
(	O
int	O
prefix	O
)	O
{	O
char	O
unit	O
[	O
64	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
unit	O
,	O
_	O
(	O
"%c%c/call"	*(char)
)	O
,	O
prefix	O
,	O
hist_dimension_abbrev	O
)	O
;	O
if	O
(	O
bsd_style_output	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\ngranularity: each sample hit covers %ld byte(s)"	*(char)
)	O
,	O
(	O
long	O
)	O
hist_scale	O
*	O
(	O
long	O
)	O
sizeof	O
(	O
UNIT	O
)	O
)	O
;	O
if	O
(	O
total_time	O
>	O
0.0	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
" for %.2f%% of %.2f %s\n\n"	*(char)
)	O
,	O
100.0	int
/	O
total_time	O
,	O
total_time	O
/	O
hz	O
,	O
hist_dimension	O
)	O
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nEach sample counts as %g %s.\n"	*(char)
)	O
,	O
1.0	int
/	O
hz	O
,	O
hist_dimension	O
)	O
;	O
}	O
if	O
(	O
total_time	O
<=	O
0.0	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
" no time accumulated\n\n"	*(char)
)	O
)	O
;	O
total_time	O
=	O
1.0	int
;	O
}	O
printf	(*(char))->(int)
(	O
"%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n"	*(char)
,	O
"%  "	*(char)
,	O
_	O
(	O
"cumulative"	*(char)
)	O
,	O
_	O
(	O
"self  "	*(char)
)	O
,	O
""	*(char)
,	O
_	O
(	O
"self  "	*(char)
)	O
,	O
_	O
(	O
"total "	*(char)
)	O
,	O
""	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%5.5s %9.9s  %8.8s %8.8s %8.8s %8.8s  %-8.8s\n"	*(char)
,	O
_	O
(	O
"time"	*(char)
)	O
,	O
hist_dimension	O
,	O
hist_dimension	O
,	O
_	O
(	O
"calls"	*(char)
)	O
,	O
unit	O
,	O
unit	O
,	O
_	O
(	O
"name"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
print_line	O
(	O
Sym	O
*	O
sym	*(struct)
,	O
double	O
scale	O
)	O
{	O
if	O
(	O
ignore_zeros	O
&&	O
sym	*(struct)
->	O
ncalls	O
==	O
0	int
&&	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
==	O
0	int
)	O
return	O
;	O
accum_time	O
+=	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
;	O
if	O
(	O
bsd_style_output	O
)	O
printf	(*(char))->(int)
(	O
"%5.1f %10.2f %8.2f"	*(char)
,	O
total_time	O
>	O
0.0	int
?	O
100	int
*	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
/	O
total_time	O
:	O
0.0	int
,	O
accum_time	O
/	O
hz	O
,	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
/	O
hz	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%6.2f %9.2f %8.2f"	*(char)
,	O
total_time	O
>	O
0.0	int
?	O
100	int
*	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
/	O
total_time	O
:	O
0.0	int
,	O
accum_time	O
/	O
hz	O
,	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
/	O
hz	O
)	O
;	O
if	O
(	O
sym	*(struct)
->	O
ncalls	O
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
" %8lu %8.2f %8.2f  "	*(char)
,	O
sym	*(struct)
->	O
ncalls	O
,	O
scale	O
*	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
/	O
hz	O
/	O
sym	*(struct)
->	O
ncalls	O
,	O
scale	O
*	O
(	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
+	O
sym	*(struct)
->	O
cg	O
.	O
child_time	O
)	O
/	O
hz	O
/	O
sym	*(struct)
->	O
ncalls	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
" %8.8s %8.8s %8.8s  "	*(char)
,	O
""	*(char)
,	O
""	*(char)
,	O
""	*(char)
)	O
;	O
if	O
(	O
bsd_style_output	O
)	O
print_name	O
(	O
sym	*(struct)
)	O
;	O
else	O
print_name_only	O
(	O
sym	*(struct)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
static	O
int	O
cmp_time	O
(	O
const	O
PTR	O
lp	O
,	O
const	O
PTR	O
rp	O
)	O
{	O
const	O
Sym	O
*	O
left	O
=	O
*	O
(	O
const	O
Sym	O
*	O
*	O
)	O
lp	O
;	O
const	O
Sym	O
*	O
right	O
=	O
*	O
(	O
const	O
Sym	O
*	O
*	O
)	O
rp	O
;	O
double	O
time_diff	O
;	O
time_diff	O
=	O
right	O
->	O
hist	O
.	O
time	struct(long,long)
-	O
left	O
->	O
hist	O
.	O
time	struct(long,long)
;	O
if	O
(	O
time_diff	O
>	O
0.0	int
)	O
return	O
1	int
;	O
if	O
(	O
time_diff	O
<	O
0.0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
right	O
->	O
ncalls	O
>	O
left	O
->	O
ncalls	O
)	O
return	O
1	int
;	O
if	O
(	O
right	O
->	O
ncalls	O
<	O
left	O
->	O
ncalls	O
)	O
return	O
-	O
1	int
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
left	O
->	O
name	*(char)
,	O
right	O
->	O
name	*(char)
)	O
;	O
}	O
void	O
hist_print	O
(	O
void	O
)	O
{	O
Sym	O
*	O
*	O
time_sorted_syms	O
,	O
*	O
top_dog	O
,	O
*	O
sym	*(struct)
;	O
unsigned	O
int	O
sym_index	O
;	O
unsigned	O
log_scale	O
;	O
double	O
top_time	O
;	O
bfd_vma	long
addr	*(void)
;	O
if	O
(	O
first_output	O
)	O
first_output	O
=	O
FALSE	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\f\n"	*(char)
)	O
;	O
accum_time	O
=	O
0.0	int
;	O
if	O
(	O
bsd_style_output	O
)	O
{	O
if	O
(	O
print_descriptions	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\n\n\nflat profile:\n"	*(char)
)	O
)	O
;	O
flat_blurb	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Flat profile:\n"	*(char)
)	O
)	O
;	O
}	O
time_sorted_syms	O
=	O
(	O
Sym	O
*	O
*	O
)	O
xmalloc	O
(	O
symtab	O
.	O
len	long
*	O
sizeof	O
(	O
Sym	O
*	O
)	O
)	O
;	O
for	O
(	O
sym_index	O
=	O
0	int
;	O
sym_index	O
<	O
symtab	O
.	O
len	long
;	O
++	O
sym_index	O
)	O
time_sorted_syms	O
[	O
sym_index	O
]	O
=	O
&	O
symtab	O
.	O
base	int
[	O
sym_index	O
]	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
time_sorted_syms	O
,	O
symtab	O
.	O
len	long
,	O
sizeof	O
(	O
Sym	O
*	O
)	O
,	O
cmp_time	O
)	O
;	O
if	O
(	O
bsd_style_output	O
)	O
{	O
log_scale	O
=	O
5	int
;	O
}	O
else	O
{	O
log_scale	O
=	O
0	int
;	O
top_dog	O
=	O
0	int
;	O
top_time	O
=	O
0.0	int
;	O
for	O
(	O
sym_index	O
=	O
0	int
;	O
sym_index	O
<	O
symtab	O
.	O
len	long
;	O
++	O
sym_index	O
)	O
{	O
sym	*(struct)
=	O
time_sorted_syms	O
[	O
sym_index	O
]	O
;	O
if	O
(	O
sym	*(struct)
->	O
ncalls	O
!=	O
0	int
)	O
{	O
double	O
call_time	O
;	O
call_time	O
=	O
(	O
sym	*(struct)
->	O
hist	O
.	O
time	struct(long,long)
+	O
sym	*(struct)
->	O
cg	O
.	O
child_time	O
)	O
/	O
sym	*(struct)
->	O
ncalls	O
;	O
if	O
(	O
call_time	O
>	O
top_time	O
)	O
{	O
top_dog	O
=	O
sym	*(struct)
;	O
top_time	O
=	O
call_time	O
;	O
}	O
}	O
}	O
if	O
(	O
top_dog	O
&&	O
top_dog	O
->	O
ncalls	O
!=	O
0	int
&&	O
top_time	O
>	O
0.0	int
)	O
{	O
top_time	O
/=	O
hz	O
;	O
for	O
(	O
log_scale	O
=	O
0	int
;	O
log_scale	O
<	O
ARRAY_SIZE	O
(	O
SItab	O
)	O
;	O
log_scale	O
++	O
)	O
{	O
double	O
scaled_value	O
=	O
SItab	O
[	O
log_scale	O
]	O
.	O
scale	O
*	O
top_time	O
;	O
if	O
(	O
scaled_value	O
>=	O
1.0	int
&&	O
scaled_value	O
<	O
1000.0	int
)	O
break	O
;	O
}	O
}	O
}	O
print_header	O
(	O
SItab	O
[	O
log_scale	O
]	O
.	O
prefix	O
)	O
;	O
for	O
(	O
sym_index	O
=	O
0	int
;	O
sym_index	O
<	O
symtab	O
.	O
len	long
;	O
++	O
sym_index	O
)	O
{	O
addr	*(void)
=	O
time_sorted_syms	O
[	O
sym_index	O
]	O
->	O
addr	*(void)
;	O
if	O
(	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_FLAT	O
]	O
,	O
addr	*(void)
)	O
||	O
(	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
INCL_FLAT	O
]	O
.	O
len	long
==	O
0	int
&&	O
!	O
sym_lookup	O
(	O
&	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
[	O
EXCL_FLAT	O
]	O
,	O
addr	*(void)
)	O
)	O
)	O
print_line	O
(	O
time_sorted_syms	O
[	O
sym_index	O
]	O
,	O
SItab	O
[	O
log_scale	O
]	O
.	O
scale	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
time_sorted_syms	O
)	O
;	O
if	O
(	O
print_descriptions	O
&&	O
!	O
bsd_style_output	O
)	O
flat_blurb	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
int	O
hist_check_address	O
(	O
unsigned	O
address	long
)	O
{	O
unsigned	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
num_histograms	O
;	O
++	O
i	*(struct)
)	O
if	O
(	O
histograms	O
[	O
i	*(struct)
]	O
.	O
lowpc	O
<=	O
address	long
&&	O
address	long
<	O
histograms	O
[	O
i	*(struct)
]	O
.	O
highpc	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
hist_clip_symbol_address	O
(	O
bfd_vma	long
*	O
p_lowpc	O
,	O
bfd_vma	long
*	O
p_highpc	O
)	O
{	O
unsigned	O
i	*(struct)
;	O
int	O
found	O
=	O
0	int
;	O
if	O
(	O
num_histograms	O
==	O
0	int
)	O
{	O
*	O
p_highpc	O
=	O
*	O
p_lowpc	O
;	O
return	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
num_histograms	O
;	O
++	O
i	*(struct)
)	O
{	O
bfd_vma	long
common_low	O
,	O
common_high	O
;	O
common_low	O
=	O
max	O
(	O
histograms	O
[	O
i	*(struct)
]	O
.	O
lowpc	O
,	O
*	O
p_lowpc	O
)	O
;	O
common_high	O
=	O
min	O
(	O
histograms	O
[	O
i	*(struct)
]	O
.	O
highpc	O
,	O
*	O
p_highpc	O
)	O
;	O
if	O
(	O
common_low	O
<	O
common_high	O
)	O
{	O
if	O
(	O
found	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: found a symbol that covers "	*(char)
"several histogram records"	*(char)
)	O
,	O
whoami	O
)	O
;	O
done	O
(	O
1	int
)	O
;	O
}	O
found	O
=	O
1	int
;	O
*	O
p_lowpc	O
=	O
common_low	O
;	O
*	O
p_highpc	O
=	O
common_high	O
;	O
}	O
}	O
if	O
(	O
!	O
found	O
)	O
*	O
p_highpc	O
=	O
*	O
p_lowpc	O
;	O
}	O
static	O
histogram	O
*	O
find_histogram	O
(	O
bfd_vma	long
lowpc	O
,	O
bfd_vma	long
highpc	O
)	O
{	O
unsigned	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
num_histograms	O
;	O
++	O
i	*(struct)
)	O
{	O
if	O
(	O
histograms	O
[	O
i	*(struct)
]	O
.	O
lowpc	O
==	O
lowpc	O
&&	O
histograms	O
[	O
i	*(struct)
]	O
.	O
highpc	O
==	O
highpc	O
)	O
return	O
&	O
histograms	O
[	O
i	*(struct)
]	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
histogram	O
*	O
find_histogram_for_pc	O
(	O
bfd_vma	long
pc	O
)	O
{	O
unsigned	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
num_histograms	O
;	O
++	O
i	*(struct)
)	O
{	O
if	O
(	O
histograms	O
[	O
i	*(struct)
]	O
.	O
lowpc	O
<=	O
pc	O
&&	O
pc	O
<	O
histograms	O
[	O
i	*(struct)
]	O
.	O
highpc	O
)	O
return	O
&	O
histograms	O
[	O
i	*(struct)
]	O
;	O
}	O
return	O
0	int
;	O
}	O
