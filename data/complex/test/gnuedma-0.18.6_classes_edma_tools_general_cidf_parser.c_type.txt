static	O
char	O
*	O
keyword	array(*(char))
[	O
]	O
=	O
{	O
"@version"	*(char)
,	O
"@namespace"	*(char)
,	O
"@accessors"	*(char)
,	O
"class"	*(char)
,	O
NULL	O
}	O
;	O
static	O
int	O
kw_version	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
int	O
kw_namespace	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
int	O
kw_accessors	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
int	O
kw_class	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
PROCESS_KW_FUNC	*((*(struct(int,int,*(char),*(char),int,int,int,*(*`),*(*`),*(*`))),int,*(char))->(int))
kw_func	array(*((*(struct(int,int,*(char),*(char),int,int,int,*(*`),*(*`),*(*`))),int,*(char))->(int)))
[	O
]	O
=	O
{	O
kw_version	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
,	O
kw_namespace	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
,	O
kw_accessors	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
,	O
kw_class	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
method_flags	array(*(char))
[	O
]	O
=	O
{	O
"abstract"	*(char)
,	O
"virtual"	*(char)
,	O
"static"	*(char)
,	O
NULL	O
}	O
;	O
static	O
int	O
class	int
=	O
0	int
;	O
void	O
*	O
create_object	(int)->(*(void))
(	O
int	O
size	int
)	O
{	O
void	O
*	O
temp	*(void)
;	O
if	O
(	O
(	O
temp	*(void)
=	O
malloc	(int)->(*(void))
(	O
size	int
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"Cannot allocate memory for Object\n"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
memset	(*(void),int,int)->(*(void))
(	O
temp	*(void)
,	O
0	int
,	O
size	int
)	O
;	O
return	O
temp	*(void)
;	O
}	O
int	O
add_item	(*(*(*(void))),*(int),*(void))->(int)
(	O
void	O
*	O
*	O
*	O
list	*(*(*(void)))
,	O
int	O
*	O
n	*(int)
,	O
void	O
*	O
data	*(void)
)	O
{	O
if	O
(	O
(	O
*	O
list	*(*(*(void)))
=	O
realloc	(*(void),int)->(*(void))
(	O
*	O
list	*(*(*(void)))
,	O
(	O
*	O
n	*(int)
+	O
1	int
)	O
*	O
sizeof	O
(	O
void	O
*	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"Cannot allocate memory\n"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
(	O
*	O
list	*(*(*(void)))
)	O
[	O
(	O
*	O
n	*(int)
)	O
]	O
=	O
data	*(void)
;	O
(	O
*	O
n	*(int)
)	O
++	O
;	O
return	O
0	int
;	O
}	O
void	O
xfree	(*(void))->(void)
(	O
void	O
*	O
p	*(void)
)	O
{	O
if	O
(	O
p	*(void)
)	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
int	O
cidf_free_data	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
)	O
{	O
int	O
i	int
,	O
j	int
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
name	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
namespace	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_sc	int
;	O
i	int
++	O
)	O
{	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
sc	*(*(struct(*(char),*(char),*(char))))
[	O
i	int
]	O
->	O
name	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
sc	*(*(struct(*(char),*(char),*(char))))
[	O
i	int
]	O
->	O
ap	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
sc	*(*(struct(*(char),*(char),*(char))))
[	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
[	O
i	int
]	O
->	O
name	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
[	O
i	int
]	O
->	O
type	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
[	O
i	int
]	O
->	O
access	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
[	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_met	int
;	O
i	int
++	O
)	O
{	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
name	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
rtype	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
n_param	int
;	O
j	int
++	O
)	O
{	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
param	*(*(struct(*(char),*(char))))
[	O
j	int
]	O
->	O
name	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
param	*(*(struct(*(char),*(char))))
[	O
j	int
]	O
->	O
type	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
param	*(*(struct(*(char),*(char))))
[	O
j	int
]	O
)	O
;	O
}	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
param	*(*(struct(*(char),*(char))))
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
)	O
;	O
}	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
sc	*(*(struct(*(char),*(char),*(char))))
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
)	O
;	O
xfree	(*(void))->(void)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
)	O
;	O
class	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
cidf_dump_class	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
)	O
{	O
int	O
i	int
,	O
j	int
;	O
printf	(*(char))->(int)
(	O
"--------------------------------------------\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Class         : '%s'\n"	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"NameSpace     : '%s'\n"	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
namespace	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Version       : %d.%d\n"	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
major_version	int
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
minor_version	int
)	O
;	O
printf	(*(char))->(int)
(	O
"Super Classes : %d\n"	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_sc	int
)	O
;	O
printf	(*(char))->(int)
(	O
"Properties    : %d\n"	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_prop	int
)	O
;	O
printf	(*(char))->(int)
(	O
"Methods       : %d\n"	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_met	int
)	O
;	O
printf	(*(char))->(int)
(	O
"...........................................................\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_sc	int
;	O
i	int
++	O
)	O
printf	(*(char))->(int)
(	O
"+ SuperClass %d: '%s' AT '%s' | '%s'\n"	*(char)
,	O
i	int
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
sc	*(*(struct(*(char),*(char),*(char))))
[	O
i	int
]	O
->	O
name	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
sc	*(*(struct(*(char),*(char),*(char))))
[	O
i	int
]	O
->	O
ap	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
sc	*(*(struct(*(char),*(char),*(char))))
[	O
i	int
]	O
->	O
ap1	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"...........................................................\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_prop	int
;	O
i	int
++	O
)	O
printf	(*(char))->(int)
(	O
"+ Property %d: '%s' '%s' : '%s'\n"	*(char)
,	O
i	int
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
[	O
i	int
]	O
->	O
type	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
[	O
i	int
]	O
->	O
name	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
[	O
i	int
]	O
->	O
access	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"...........................................................\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_met	int
;	O
i	int
++	O
)	O
{	O
printf	(*(char))->(int)
(	O
"+ Method %d: "	*(char)
,	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
j	int
++	O
)	O
if	O
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
flags	array(int)
[	O
j	int
]	O
)	O
printf	(*(char))->(int)
(	O
" %s "	*(char)
,	O
method_flags	array(*(char))
[	O
j	int
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"'%s' '%s' ("	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
rtype	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
name	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
n_param	int
;	O
j	int
++	O
)	O
printf	(*(char))->(int)
(	O
"%s %s |"	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
param	*(*(struct(*(char),*(char))))
[	O
j	int
]	O
->	O
type	*(char)
,	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
[	O
i	int
]	O
->	O
param	*(*(struct(*(char),*(char))))
[	O
j	int
]	O
->	O
name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
")\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"--------------------------------------------\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
check_keyword	(*(char))->(int)
(	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
*	O
list	*(*(*(void)))
=	O
keyword	array(*(char))
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
list	*(*(*(void)))
[	O
i	int
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strncasecmp	(*(char),*(char),int)->(int)
(	O
str	*(char)
,	O
list	*(*(*(void)))
[	O
i	int
]	O
,	O
strlen	(*(char))->(int)
(	O
list	*(*(*(void)))
[	O
i	int
]	O
)	O
)	O
==	O
0	int
)	O
break	O
;	O
else	O
i	int
++	O
;	O
}	O
return	O
i	int
;	O
}	O
static	O
int	O
check_str	(*(*(char)),*(char))->(int)
(	O
char	O
*	O
*	O
list	*(*(*(void)))
,	O
char	O
*	O
str	*(char)
)	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
list	*(*(*(void)))
[	O
i	int
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strncasecmp	(*(char),*(char),int)->(int)
(	O
str	*(char)
,	O
list	*(*(*(void)))
[	O
i	int
]	O
,	O
strlen	(*(char))->(int)
(	O
str	*(char)
)	O
)	O
==	O
0	int
)	O
break	O
;	O
else	O
i	int
++	O
;	O
}	O
return	O
i	int
;	O
}	O
static	O
int	O
skip_spaces	(*(char))->(int)
(	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
aux	*(char)
=	O
str	*(char)
;	O
while	O
(	O
*	O
aux	*(char)
!=	O
0	int
&&	O
isspace	(int)->(int)
(	O
*	O
aux	*(char)
)	O
)	O
aux	*(char)
++	O
;	O
return	O
aux	*(char)
-	O
str	*(char)
;	O
}	O
static	O
int	O
trim_str	(*(char))->(int)
(	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
aux	*(char)
=	O
str	*(char)
;	O
aux	*(char)
+=	O
strlen	(*(char))->(int)
(	O
str	*(char)
)	O
-	O
1	int
;	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
aux	*(char)
)	O
&&	O
aux	*(char)
>=	O
str	*(char)
)	O
aux	*(char)
--	O
;	O
*	O
(	O
aux	*(char)
+	O
1	int
)	O
=	O
0	int
;	O
return	O
skip_spaces	(*(char))->(int)
(	O
str	*(char)
)	O
;	O
}	O
static	O
int	O
get_id	(*(char))->(int)
(	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
aux	*(char)
=	O
str	*(char)
;	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
*	O
aux	*(char)
)	O
&&	O
*	O
aux	*(char)
!=	O
'('	O
&&	O
*	O
aux	*(char)
!=	O
0	int
)	O
aux	*(char)
++	O
;	O
return	O
aux	*(char)
-	O
str	*(char)
;	O
}	O
static	O
int	O
get_id2	(*(char),*(char))->(int)
(	O
char	O
*	O
str	*(char)
,	O
char	O
*	O
sep	*(char)
)	O
{	O
char	O
*	O
aux	*(char)
=	O
str	*(char)
;	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
*	O
aux	*(char)
)	O
&&	O
!	O
(	O
strchr	(*(char),int)->(*(char))
(	O
sep	*(char)
,	O
*	O
aux	*(char)
)	O
)	O
&&	O
*	O
aux	*(char)
!=	O
0	int
)	O
aux	*(char)
++	O
;	O
return	O
aux	*(char)
-	O
str	*(char)
;	O
}	O
static	O
int	O
parse_class_header	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
int	O
line	int
,	O
char	O
*	O
pline	*(char)
)	O
{	O
char	O
*	O
temp	*(void)
,	O
*	O
aux	*(char)
,	O
*	O
aux1	*(char)
,	O
*	O
aux2	*(char)
,	O
finish	char
,	O
*	O
aux3	*(char)
;	O
CIF_SUPERCLASS	struct(*(char),*(char),*(char))
*	O
sc	*(*(struct(*(char),*(char),*(char))))
;	O
temp	*(void)
=	O
strdup	(*(char))->(*(char))
(	O
pline	*(char)
)	O
;	O
aux	*(char)
=	O
temp	*(void)
;	O
aux	*(char)
+=	O
5	int
;	O
aux	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
aux1	*(char)
=	O
aux	*(char)
;	O
aux1	*(char)
+=	O
get_id	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
*	O
aux1	*(char)
=	O
0	int
;	O
aux1	*(char)
++	O
;	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux	*(char)
)	O
;	O
aux1	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
aux1	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
aux1	*(char)
==	O
NULL	O
)	O
return	O
0	int
;	O
aux1	*(char)
++	O
;	O
aux1	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux1	*(char)
)	O
;	O
aux	*(char)
=	O
aux1	*(char)
;	O
finish	char
=	O
0	int
;	O
do	O
{	O
aux1	*(char)
+=	O
get_id	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
if	O
(	O
*	O
aux1	*(char)
==	O
0	int
)	O
finish	char
=	O
1	int
;	O
sc	*(*(struct(*(char),*(char),*(char))))
=	O
create_object	(int)->(*(void))
(	O
sizeof	O
(	O
CIF_SUPERCLASS	struct(*(char),*(char),*(char))
)	O
)	O
;	O
*	O
aux1	*(char)
=	O
0	int
;	O
aux1	*(char)
++	O
;	O
if	O
(	O
(	O
aux2	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
aux	*(char)
,	O
'@'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
aux2	*(char)
=	O
0	int
;	O
aux2	*(char)
++	O
;	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux	*(char)
)	O
;	O
if	O
(	O
(	O
aux3	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
aux2	*(char)
,	O
'|'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
ap	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux2	*(char)
)	O
;	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
ap1	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
"INNER"	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
aux3	*(char)
=	O
0	int
;	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
ap	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux2	*(char)
)	O
;	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
ap1	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux3	*(char)
+	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux	*(char)
)	O
;	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
ap	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
name	*(char)
)	O
;	O
sc	*(*(struct(*(char),*(char),*(char))))
->	O
ap1	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
name	*(char)
)	O
;	O
}	O
add_item	(*(*(*(void))),*(int),*(void))->(int)
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
sc	*(*(struct(*(char),*(char),*(char))))
,	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_sc	int
,	O
sc	*(*(struct(*(char),*(char),*(char))))
)	O
;	O
aux	*(char)
=	O
aux1	*(char)
;	O
}	O
while	O
(	O
!	O
finish	char
)	O
;	O
free	(*(void))->(void)
(	O
temp	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_prop	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
int	O
line	int
,	O
char	O
*	O
pline	*(char)
)	O
{	O
char	O
*	O
name	*(char)
,	O
*	O
flags	array(int)
,	O
*	O
aux	*(char)
,	O
*	O
temp	*(void)
;	O
CIF_PROPERTY	struct(*(char),*(char),*(char),int)
*	O
prop	*(*(struct(*(char),*(char),*(char),int)))
;	O
temp	*(void)
=	O
strdup	(*(char))->(*(char))
(	O
pline	*(char)
)	O
;	O
aux	*(char)
=	O
temp	*(void)
;	O
aux	*(char)
+=	O
get_id	(*(char))->(int)
(	O
temp	*(void)
)	O
;	O
if	O
(	O
*	O
aux	*(char)
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"[%s] Syntax Error in line %d: '%s'\n"	*(char)
,	O
__FUNCTION__	O
,	O
line	int
,	O
pline	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
prop	*(*(struct(*(char),*(char),*(char),int)))
=	O
create_object	(int)->(*(void))
(	O
sizeof	O
(	O
CIF_PROPERTY	struct(*(char),*(char),*(char),int)
)	O
)	O
;	O
*	O
aux	*(char)
=	O
0	int
;	O
aux	*(char)
++	O
;	O
prop	*(*(struct(*(char),*(char),*(char),int)))
->	O
type	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
temp	*(void)
)	O
;	O
aux	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
name	*(char)
=	O
aux	*(char)
;	O
aux	*(char)
+=	O
get_id2	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
":;"	*(char)
)	O
;	O
if	O
(	O
*	O
aux	*(char)
==	O
0	int
)	O
{	O
if	O
(	O
aux	*(char)
==	O
name	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"Property Name not found in line %d\n"	*(char)
,	O
line	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
*	O
aux	*(char)
=	O
0	int
;	O
aux	*(char)
++	O
;	O
}	O
prop	*(*(struct(*(char),*(char),*(char),int)))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
aux	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
aux	*(char)
,	O
':'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
prop	*(*(struct(*(char),*(char),*(char),int)))
->	O
access	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
"RW"	*(char)
)	O
;	O
}	O
else	O
{	O
flags	array(int)
=	O
aux	*(char)
+	O
1	int
;	O
flags	array(int)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
if	O
(	O
(	O
aux	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
flags	array(int)
,	O
';'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"[%s] Syntax error in line %d. Missing ';': '%s'\n"	*(char)
,	O
__FUNCTION__	O
,	O
line	int
,	O
pline	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
temp	*(void)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
aux	*(char)
=	O
0	int
;	O
prop	*(*(struct(*(char),*(char),*(char),int)))
->	O
access	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
flags	array(int)
)	O
;	O
}	O
add_item	(*(*(*(void))),*(int),*(void))->(int)
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
prop	*(*(struct(*(char),*(char),*(char),int)))
,	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_prop	int
,	O
prop	*(*(struct(*(char),*(char),*(char),int)))
)	O
;	O
free	(*(void))->(void)
(	O
temp	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_met	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char),int)->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
int	O
line	int
,	O
char	O
*	O
pline	*(char)
,	O
int	O
params	int
)	O
{	O
char	O
*	O
aux	*(char)
,	O
*	O
aux1	*(char)
,	O
*	O
aux2	*(char)
,	O
*	O
temp	*(void)
,	O
*	O
aux3	*(char)
;	O
int	O
pn	int
,	O
indx	int
,	O
fp	int
,	O
process	int
=	O
1	int
;	O
CIF_METHOD	struct(*(char),*(char),*(char),int,*(*(struct(*(char),*(char)))),array(int))
*	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
;	O
CIF_PARAM	struct(*(char),*(char))
*	O
param	*(*(struct(*(char),*(char))))
;	O
temp	*(void)
=	O
strdup	(*(char))->(*(char))
(	O
pline	*(char)
)	O
;	O
aux	*(char)
=	O
temp	*(void)
;	O
aux	*(char)
+=	O
get_id	(*(char))->(int)
(	O
temp	*(void)
)	O
;	O
if	O
(	O
*	O
aux	*(char)
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"[%s] Syntax Error in line %d: '%s'\n"	*(char)
,	O
__FUNCTION__	O
,	O
line	int
,	O
pline	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
aux	*(char)
=	O
0	int
;	O
aux	*(char)
++	O
;	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
=	O
create_object	(int)->(*(void))
(	O
sizeof	O
(	O
CIF_METHOD	struct(*(char),*(char),*(char),int,*(*(struct(*(char),*(char)))),array(int))
)	O
)	O
;	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
->	O
n_param	int
=	O
0	int
;	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
->	O
rtype	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
temp	*(void)
)	O
;	O
aux	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
aux1	*(char)
=	O
aux	*(char)
;	O
while	O
(	O
process	int
)	O
{	O
aux	*(char)
+=	O
get_id	(*(char))->(int)
(	O
aux1	*(char)
)	O
;	O
*	O
aux	*(char)
=	O
0	int
;	O
aux	*(char)
++	O
;	O
if	O
(	O
method_flags	array(*(char))
[	O
(	O
indx	int
=	O
check_str	(*(*(char)),*(char))->(int)
(	O
method_flags	array(*(char))
,	O
aux1	*(char)
)	O
)	O
]	O
==	O
NULL	O
)	O
{	O
break	O
;	O
}	O
aux	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
aux1	*(char)
=	O
aux	*(char)
;	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
->	O
flags	array(int)
[	O
indx	int
]	O
=	O
1	int
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux1	*(char)
)	O
;	O
process	int
=	O
1	int
;	O
aux2	*(char)
=	O
aux1	*(char)
=	O
aux	*(char)
=	O
pline	*(char)
+	O
params	int
+	O
1	int
;	O
aux2	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
aux	*(char)
,	O
')'	O
)	O
;	O
if	O
(	O
aux2	*(char)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"Missing Parenthesys in line %d\n"	*(char)
,	O
line	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
*	O
aux2	*(char)
=	O
0	int
;	O
aux	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
if	O
(	O
*	O
aux	*(char)
==	O
0	int
)	O
{	O
add_item	(*(*(*(void))),*(int),*(void))->(int)
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
,	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_met	int
,	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
)	O
;	O
return	O
0	int
;	O
}	O
pn	int
=	O
1	int
;	O
fp	int
=	O
0	int
;	O
while	O
(	O
process	int
)	O
{	O
if	O
(	O
(	O
aux3	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
aux	*(char)
,	O
','	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
aux3	*(char)
=	O
0	int
;	O
else	O
fp	int
=	O
1	int
;	O
aux2	*(char)
=	O
aux3	*(char)
;	O
aux1	*(char)
+=	O
get_id	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
if	O
(	O
*	O
aux1	*(char)
==	O
0	int
&&	O
aux1	*(char)
!=	O
aux2	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"Missing name for parameter %d\n"	*(char)
,	O
pn	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
*	O
aux1	*(char)
=	O
0	int
;	O
aux1	*(char)
++	O
;	O
}	O
param	*(*(struct(*(char),*(char))))
=	O
create_object	(int)->(*(void))
(	O
sizeof	O
(	O
CIF_PARAM	struct(*(char),*(char))
)	O
)	O
;	O
param	*(*(struct(*(char),*(char))))
->	O
type	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux	*(char)
)	O
;	O
aux1	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux1	*(char)
)	O
;	O
aux2	*(char)
+=	O
get_id	(*(char))->(int)
(	O
aux1	*(char)
)	O
;	O
aux2	*(char)
++	O
;	O
param	*(*(struct(*(char),*(char))))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux1	*(char)
)	O
;	O
add_item	(*(*(*(void))),*(int),*(void))->(int)
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
->	O
param	*(*(struct(*(char),*(char))))
,	O
&	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
->	O
n_param	int
,	O
param	*(*(struct(*(char),*(char))))
)	O
;	O
if	O
(	O
!	O
fp	int
)	O
{	O
aux	*(char)
=	O
aux3	*(char)
+	O
1	int
;	O
aux	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
}	O
else	O
break	O
;	O
aux1	*(char)
=	O
aux	*(char)
;	O
pn	int
++	O
;	O
}	O
add_item	(*(*(*(void))),*(int),*(void))->(int)
(	O
(	O
void	O
*	O
*	O
*	O
)	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
,	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_met	int
,	O
met	*(*(struct(*(char),*(char),*(char),int,*(*(struct`)),array(int))))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_class_line	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
int	O
line	int
,	O
char	O
*	O
pline	*(char)
)	O
{	O
char	O
*	O
params	int
;	O
if	O
(	O
pline	*(char)
[	O
0	int
]	O
==	O
'{'	O
||	O
pline	*(char)
[	O
0	int
]	O
==	O
'}'	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
params	int
=	O
strchr	(*(char),int)->(*(char))
(	O
pline	*(char)
,	O
'('	O
)	O
)	O
==	O
NULL	O
)	O
return	O
parse_prop	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
line	int
,	O
pline	*(char)
)	O
;	O
else	O
return	O
parse_met	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char),int)->(int)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
line	int
,	O
pline	*(char)
,	O
params	int
-	O
pline	*(char)
)	O
;	O
}	O
static	O
int	O
kw_version	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
int	O
line	int
,	O
char	O
*	O
pline	*(char)
)	O
{	O
char	O
*	O
aux	*(char)
=	O
pline	*(char)
;	O
if	O
(	O
(	O
aux	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
aux	*(char)
,	O
':'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"Syntax error in line %d. No namespace specified\n"	*(char)
,	O
line	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
aux	*(char)
++	O
;	O
aux	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
aux	*(char)
,	O
"%d.%d"	*(char)
,	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
major_version	int
,	O
&	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
minor_version	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
kw_namespace	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
int	O
line	int
,	O
char	O
*	O
pline	*(char)
)	O
{	O
char	O
*	O
aux	*(char)
=	O
pline	*(char)
;	O
if	O
(	O
(	O
aux	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
aux	*(char)
,	O
':'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"Syntax error in line %d. No namespace specified\n"	*(char)
,	O
line	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
aux	*(char)
++	O
;	O
aux	*(char)
+=	O
skip_spaces	(*(char))->(int)
(	O
aux	*(char)
)	O
;	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
namespace	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
aux	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
kw_accessors	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
int	O
line	int
,	O
char	O
*	O
pline	*(char)
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
kw_class	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
int	O
line	int
,	O
char	O
*	O
pline	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
"[%s] Unreacheable code\n"	*(char)
,	O
__FUNCTION__	O
)	O
;	O
return	O
0	int
;	O
}	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
cidf_parse	(*(char))->(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))))
(	O
char	O
*	O
filename	*(char)
)	O
{	O
int	O
line	int
,	O
kw	int
;	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
;	O
char	O
buffer	array(char)
[	O
1024	int
]	O
,	O
*	O
aux	*(char)
,	O
*	O
pline	*(char)
;	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
*	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
;	O
if	O
(	O
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))))
(	O
filename	*(char)
,	O
"rt"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
,	O
"Cannot open file '%s'\n"	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
=	O
create_object	(int)->(*(void))
(	O
sizeof	O
(	O
CIF_CLASS	struct(int,int,*(char),*(char),int,int,int,*(*(struct(*(char),*(char),*(char)))),*(*(struct(*(char),*(char),*(char),int))),*(*(struct(*(char),*(char),*(char),int,*(*`),array(int)))))
)	O
)	O
;	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_sc	int
=	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_prop	int
=	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
->	O
n_met	int
=	O
0	int
;	O
line	int
=	O
0	int
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
)	O
)	O
{	O
line	int
++	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
buffer	array(char)
,	O
0	int
,	O
1024	int
)	O
;	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))))->(*(char))
(	O
buffer	array(char)
,	O
1024	int
,	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
)	O
;	O
aux	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buffer	array(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
aux	*(char)
!=	O
NULL	O
)	O
*	O
aux	*(char)
=	O
0	int
;	O
if	O
(	O
(	O
aux	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
buffer	array(char)
,	O
"//"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
*	O
aux	*(char)
=	O
0	int
;	O
pline	*(char)
=	O
buffer	array(char)
;	O
pline	*(char)
+=	O
trim_str	(*(char))->(int)
(	O
pline	*(char)
)	O
;	O
if	O
(	O
strlen	(*(char))->(int)
(	O
pline	*(char)
)	O
==	O
0	int
)	O
continue	O
;	O
kw	int
=	O
check_keyword	(*(char))->(int)
(	O
pline	*(char)
)	O
;	O
if	O
(	O
keyword	array(*(char))
[	O
kw	int
]	O
!=	O
NULL	O
&&	O
kw	int
!=	O
3	int
)	O
{	O
kw_func	array(*((*(struct(int,int,*(char),*(char),int,int,int,*(*`),*(*`),*(*`))),int,*(char))->(int)))
[	O
kw	int
]	O
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
line	int
,	O
pline	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
keyword	array(*(char))
[	O
kw	int
]	O
==	O
NULL	O
&&	O
class	int
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"ERROR: Syntax error in line %d: '%s'\n"	*(char)
,	O
line	int
,	O
pline	*(char)
)	O
;	O
cidf_free_data	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))))->(int)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
)	O
;	O
class	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
class	int
)	O
if	O
(	O
parse_class_line	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
line	int
,	O
pline	*(char)
)	O
<	O
0	int
)	O
{	O
cidf_free_data	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))))->(int)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
)	O
;	O
class	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
kw	int
==	O
3	int
)	O
{	O
if	O
(	O
class	int
==	O
0	int
)	O
{	O
class	int
=	O
1	int
;	O
if	O
(	O
(	O
parse_class_header	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))),int,*(char))->(int)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
,	O
line	int
,	O
pline	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
cidf_free_data	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))))->(int)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"ERROR: Cannot declare inner classes in line %d\n"	*(char)
,	O
line	int
)	O
;	O
cidf_free_data	(*(struct(int,int,*(char),*(char),int,int,int,*(*(struct`)),*(*(struct`)),*(*(struct`)))))->(int)
(	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long long,*`,*`,*`,*`,int,int,array(char))),*(void),int,int,array(char))))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),int,int,long,short,char,array(char),*(void),long long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long long,*(struct`),*(struct`),*(struct`),*(void),int,int,array(char))),*(void),int,int,array(char)))
)	O
;	O
class	int
=	O
0	int
;	O
return	O
the_class	*(struct(int,int,*(char),*(char),int,int,int,*(*(struct(*`,*`,*`))),*(*(struct(*`,*`,*`,int))),*(*(struct(*`,*`,*`,int,*`,array(int))))))
;	O
}	O
