static	O
bool	bool
initialize_wd_for_exec	(*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*`),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*`)),int)),int,*(char))->(bool)
(	O
struct	O
exec_val	struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int)
*	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
,	O
int	O
cwd_fd	int
,	O
const	O
char	O
*	O
dir	*(char)
)	O
{	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
)	O
)	O
;	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
->	O
name	*(char)
=	O
NULL	O
;	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
->	O
desc	int
=	O
openat	(int,*(char),int)->(int)
(	O
cwd_fd	int
,	O
dir	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
->	O
desc	int
<	O
0	int
)	O
return	O
false	int
;	O
set_cloexec_flag	(int,bool)->(int)
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
->	O
desc	int
,	O
true	int
)	O
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
record_exec_dir	(*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*`),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*`)),int)))->(bool)
(	O
struct	O
exec_val	struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int)
*	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
)	O
{	O
if	O
(	O
!	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
todo	int
)	O
{	O
assert	O
(	O
!	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
todo	int
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
rel_pathname	*(char)
,	O
'/'	O
)	O
)	O
{	O
char	O
*	O
dir	*(char)
=	O
mdir_name	(*(char))->(*(char))
(	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
rel_pathname	*(char)
)	O
;	O
bool	bool
result	*(*(char))
=	O
initialize_wd_for_exec	(*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*`),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*`)),int)),int,*(char))->(bool)
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
,	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
cwd_dir_fd	int
,	O
dir	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
dir	*(char)
)	O
;	O
return	O
result	*(*(char))
;	O
}	O
else	O
{	O
return	O
initialize_wd_for_exec	(*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*`),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*`)),int)),int,*(char))->(bool)
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
,	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
cwd_dir_fd	int
,	O
"."	*(char)
)	O
;	O
}	O
}	O
return	O
true	int
;	O
}	O
bool	bool
impl_pred_exec	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*(char),*(struct`),struct(bool,struct`,struct`,*`,int,bool,*`,int),struct(enum(int,int,int),bool,long),struct(enum(int,int,int),int,long),int,int,struct(enum(int,int,int,int,int),enum(int,int,int),struct`),struct(enum(int,int,int),array(int)),struct(long,long,int),int,struct(*`,*`,*`,bool,*`),*(char)),*(struct(*`,*`,enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*`,union`,*`,*`,*`,struct`,*`)),*(struct(*`,*`,enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*`,union`,*`,*`,*`,struct`,*`)),*(struct(*`,*`,enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*`,union`,*`,*`,*`,struct`,*`)),struct(long,long),*(struct(enum(int,int,int,int,int,int,int),*`,*`,*`)))))->(bool)
(	O
const	O
char	O
*	O
pathname	*(char)
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
stat_buf	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
,	O
struct	O
predicate	struct(*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))))->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*(char),*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int),struct(enum(int,int,int),bool,long),struct(enum(int,int,int),int,long),int,int,struct(enum(int,int,int,int,int),enum(int,int,int),struct(long,long)),struct(enum(int,int,int),array(int)),struct(long,long,int),int,struct(*(struct(enum(int,int,int),array(char),*(char),int,*(struct`))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),bool,*(struct)),*(char)),*(struct(*((*(char),*(struct`),*(struct`))->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*(char),*(struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int)),struct(bool,struct(int,long,long,long,long,long,*`,long,*`,long,long),struct(long,*`,long,*`,long,long,*`,int,int,long,long),*(*`),int,bool,*(struct`),int),struct(enum(int,int,int),bool,long),struct(enum(int,int,int),int,long),int,int,struct(enum(int,int,int,int,int),enum(int,int,int),struct(long,long)),struct(enum(int,int,int),array(int)),struct(long,long,int),int,struct(*(struct`),*(struct`),*(char),bool,*(struct`)),*(char)),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),struct(long,long),*(struct))),*(struct(*((*(char),*(struct`),*(struct`))->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*(char),*(struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int)),struct(bool,struct(int,long,long,long,long,long,*`,long,*`,long,long),struct(long,*`,long,*`,long,long,*`,int,int,long,long),*(*`),int,bool,*(struct`),int),struct(enum(int,int,int),bool,long),struct(enum(int,int,int),int,long),int,int,struct(enum(int,int,int,int,int),enum(int,int,int),struct(long,long)),struct(enum(int,int,int),array(int)),struct(long,long,int),int,struct(*(struct`),*(struct`),*(char),bool,*(struct`)),*(char)),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),struct(long,long),*(struct))),*(struct(*((*(char),*(struct`),*(struct`))->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*(char),*(struct(*`,long,long,long,*`,*`,long,int,int,int,int,int,int,int)),struct(bool,struct(int,long,long,long,long,long,*`,long,*`,long,long),struct(long,*`,long,*`,long,long,*`,int,int,long,long),*(*`),int,bool,*(struct`),int),struct(enum(int,int,int),bool,long),struct(enum(int,int,int),int,long),int,int,struct(enum(int,int,int,int,int),enum(int,int,int),struct(long,long)),struct(enum(int,int,int),array(int)),struct(long,long,int),int,struct(*(struct`),*(struct`),*(char),bool,*(struct`)),*(char)),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))),struct(long,long),*(struct))),struct(long,long),*(struct))
*	O
pred_ptr	*(struct)
)	O
{	O
struct	O
exec_val	struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int)
*	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
=	O
&	O
pred_ptr	*(struct)
->	O
args	union(*(char),*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int),struct(enum(int,int,int),bool,long),struct(enum(int,int,int),int,long),int,int,struct(enum(int,int,int,int,int),enum(int,int,int),struct(long,long)),struct(enum(int,int,int),array(int)),struct(long,long,int),int,struct(*(struct(enum(int,int,int),array(char),*(char),int,*(struct`))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),bool,*(struct)),*(char))
.	O
exec_vec	struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int)
;	O
char	O
*	O
buf	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
target	*(char)
;	O
bool	bool
result	*(*(char))
;	O
const	O
bool	bool
local	bool
=	O
is_exec_in_local_dir	(*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))),*(struct(*`,*`,enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*`,union`,*`,*`,*`,struct`,*`)))->(bool)))->(bool)
(	O
pred_ptr	*(struct)
->	O
pred_func	*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(struct(*((*`,*`,*`)->(bool)),*(char),enum(int,int,int,int,int,int),enum(int,int,int,int,int,int),bool,bool,bool,bool,bool,enum(int,int,int,int,int,int,int,int,int,int,int,int),float,bool,bool,*(char),union(*`,*`,struct`,struct`,struct`,int,int,struct`,struct`,struct`,int,struct`,*`),*(struct`),*(struct`),*(struct`),struct(long,long),*(struct`))))->(bool))
)	O
;	O
char	O
*	O
prefix	*(char)
;	O
size_t	long
pfxlen	long
;	O
(	O
void	O
)	O
stat_buf	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
if	O
(	O
local	bool
)	O
{	O
if	O
(	O
!	O
record_exec_dir	(*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*`),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*`)),int)))->(bool)
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to save working directory in order to "	*(char)
"run a command on %s"	*(char)
)	O
,	O
safely_quote_err_filename	(int,*(char))->(*(char))
(	O
0	int
,	O
pathname	*(char)
)	O
)	O
;	O
}	O
target	*(char)
=	O
buf	*(char)
=	O
base_name	(*(char))->(*(char))
(	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
rel_pathname	*(char)
)	O
;	O
if	O
(	O
'/'	O
==	O
target	*(char)
[	O
0	int
]	O
)	O
{	O
prefix	*(char)
=	O
NULL	O
;	O
pfxlen	long
=	O
0	int
;	O
}	O
else	O
{	O
prefix	*(char)
=	O
"./"	*(char)
;	O
pfxlen	long
=	O
2u	int
;	O
}	O
}	O
else	O
{	O
assert	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
==	O
initial_wd	*(struct(int,*(char)))
)	O
;	O
target	*(char)
=	O
pathname	*(char)
;	O
prefix	*(char)
=	O
NULL	O
;	O
pfxlen	long
=	O
0u	int
;	O
}	O
if	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
multiple	bool
)	O
{	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
&	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
&	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
,	O
target	*(char)
,	O
strlen	(*(char))->(long)
(	O
target	*(char)
)	O
+	O
1	int
,	O
prefix	*(char)
,	O
pfxlen	long
,	O
0	int
)	O
;	O
if	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
todo	int
)	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
execdirs_outstanding	bool
=	O
true	int
;	O
result	*(*(char))
=	O
true	int
;	O
}	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
num_args	int
;	O
++	O
i	int
)	O
{	O
bc_do_insert	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,*(char),long,int)->(void)
(	O
&	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
&	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
,	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
replace_vec	*(*(char))
[	O
i	int
]	O
,	O
strlen	(*(char))->(long)
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
replace_vec	*(*(char))
[	O
i	int
]	O
)	O
,	O
prefix	*(char)
,	O
pfxlen	long
,	O
target	*(char)
,	O
strlen	(*(char))->(long)
(	O
target	*(char)
)	O
,	O
0	int
)	O
;	O
}	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
&	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
&	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
last_child_status	int
)	O
)	O
{	O
if	O
(	O
0	int
==	O
WEXITSTATUS	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
last_child_status	int
)	O
)	O
result	*(*(char))
=	O
true	int
;	O
else	O
result	*(*(char))
=	O
false	int
;	O
}	O
else	O
{	O
result	*(*(char))
=	O
false	int
;	O
}	O
if	O
(	O
local	bool
)	O
free_cwd	(*(struct(int,*(char))))->(void)
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
)	O
;	O
}	O
if	O
(	O
buf	*(char)
)	O
{	O
assert	O
(	O
local	bool
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
}	O
return	O
result	*(*(char))
;	O
}	O
static	O
bool	bool
prep_child_for_exec	(bool,*(struct(int,*(char))))->(bool)
(	O
bool	bool
close_stdin	bool
,	O
const	O
struct	O
saved_cwd	struct(int,*(char))
*	O
wd	*(struct(int,*(char)))
)	O
{	O
bool	bool
ok	bool
=	O
true	int
;	O
if	O
(	O
close_stdin	bool
)	O
{	O
const	O
char	O
inputfile	array(char)
[	O
]	O
=	O
"/dev/null"	*(char)
;	O
if	O
(	O
close	*((*(void))->(int))
(	O
0	int
)	O
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Cannot close standard input"	*(char)
)	O
)	O
;	O
ok	bool
=	O
false	int
;	O
}	O
else	O
{	O
if	O
(	O
open	(*(char),int)->(int)
(	O
inputfile	array(char)
,	O
O_RDONLY	int
|	O
O_LARGEFILE	O
)	O
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
safely_quote_err_filename	(int,*(char))->(*(char))
(	O
0	int
,	O
inputfile	array(char)
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
0	int
!=	O
restore_cwd	(*(struct(int,*(char))))->(int)
(	O
wd	*(struct(int,*(char)))
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"Failed to change directory%s%s"	*(char)
)	O
,	O
(	O
wd	*(struct(int,*(char)))
->	O
desc	int
<	O
0	int
&&	O
wd	*(struct(int,*(char)))
->	O
name	*(char)
)	O
?	O
": "	*(char)
:	O
""	*(char)
,	O
(	O
wd	*(struct(int,*(char)))
->	O
desc	int
<	O
0	int
&&	O
wd	*(struct(int,*(char)))
->	O
name	*(char)
)	O
?	O
wd	*(struct(int,*(char)))
->	O
name	*(char)
:	O
""	*(char)
)	O
;	O
ok	bool
=	O
false	int
;	O
}	O
return	O
ok	bool
;	O
}	O
int	O
launch	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
void	O
*	O
usercontext	*(void)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
pid_t	int
child_pid	int
;	O
static	O
int	O
first_time	int
=	O
1	int
;	O
struct	O
exec_val	struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*`,long,*`,long,long)),*(void),int,*(*(char)))->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int)
*	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
=	O
usercontext	*(void)
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
first_time	int
)	O
{	O
first_time	int
=	O
0	int
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
}	O
child_pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
child_pid	int
==	O
-	O
1	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"cannot fork"	*(char)
)	O
)	O
;	O
if	O
(	O
child_pid	int
==	O
0	int
)	O
{	O
assert	O
(	O
NULL	O
!=	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
)	O
;	O
if	O
(	O
!	O
prep_child_for_exec	(bool,*(struct(int,*(char))))->(bool)
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
close_stdin	bool
,	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
wd_for_exec	*(struct(int,*(char)))
)	O
)	O
{	O
_exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
fd_leak_check_is_enabled	()->(bool)
(	O
)	O
)	O
{	O
complain_about_leaky_fds	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
bc_args_exceed_testing_limit	(*(*(char)))->(bool)
(	O
argv	*(*(char))
)	O
)	O
errno	O
=	O
E2BIG	int
;	O
else	O
execvp	(*(char),array(*(char)))->(int)
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
argv	*(*(char))
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
safely_quote_err_filename	(int,*(char))->(*(char))
(	O
0	int
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
_exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
while	O
(	O
waitpid	(int,*(int),int)->(int)
(	O
child_pid	int
,	O
&	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
last_child_status	int
)	O
,	O
0	int
)	O
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"error waiting for %s"	*(char)
)	O
,	O
safely_quote_err_filename	(int,*(char))->(*(char))
(	O
0	int
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
)	O
;	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
exit_status	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
WIFSIGNALED	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
last_child_status	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s terminated by signal %d"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
options	struct(bool,bool,int,int,bool,bool,bool,bool,bool,bool,struct(long,long),struct(long,long),bool,int,long,enum(int,int,int),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)),bool,int,*((int,*(char),*(*(char)))->(int)),short,enum(int,int,int,int,int,int,int,int,int,int,int))
.	O
err_quoting_style	enum(int,int,int,int,int,int,int,int,int,int,int)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
,	O
WTERMSIG	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
last_child_status	int
)	O
)	O
;	O
if	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
multiple	bool
)	O
{	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
exit_status	int
=	O
1	int
;	O
}	O
return	O
1	int
;	O
}	O
if	O
(	O
0	int
==	O
WEXITSTATUS	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
last_child_status	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
execp	*(struct(bool,struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long),struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long),*(*(char)),int,bool,*(struct(int,*(char))),int))
->	O
multiple	bool
)	O
{	O
state	*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long))
.	O
exit_status	int
=	O
1	int
;	O
}	O
return	O
1	int
;	O
}	O
}	O
