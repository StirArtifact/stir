static	O
int	O
uleb128_size	O
(	O
unsigned	O
int	O
i	*(struct)
)	O
{	O
int	O
size	long
;	O
size	long
=	O
1	int
;	O
while	O
(	O
i	*(struct)
>=	O
0x80	int
)	O
{	O
i	*(struct)
>>=	O
7	int
;	O
size	long
++	O
;	O
}	O
return	O
size	long
;	O
}	O
static	O
bfd_boolean	int
is_default_attr	O
(	O
obj_attribute	O
*	O
attr	O
)	O
{	O
if	O
(	O
ATTR_TYPE_HAS_ERROR	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
ATTR_TYPE_HAS_INT_VAL	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
&&	O
attr	O
->	O
i	*(struct)
!=	O
0	int
)	O
return	O
FALSE	O
;	O
if	O
(	O
ATTR_TYPE_HAS_STR_VAL	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
&&	O
attr	O
->	O
s	*(void)
&&	O
*	O
attr	O
->	O
s	*(void)
)	O
return	O
FALSE	O
;	O
if	O
(	O
ATTR_TYPE_HAS_NO_DEFAULT	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_vma	long
obj_attr_size	O
(	O
unsigned	O
int	O
tag	O
,	O
obj_attribute	O
*	O
attr	O
)	O
{	O
bfd_vma	long
size	long
;	O
if	O
(	O
is_default_attr	O
(	O
attr	O
)	O
)	O
return	O
0	int
;	O
size	long
=	O
uleb128_size	O
(	O
tag	O
)	O
;	O
if	O
(	O
ATTR_TYPE_HAS_INT_VAL	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
)	O
size	long
+=	O
uleb128_size	O
(	O
attr	O
->	O
i	*(struct)
)	O
;	O
if	O
(	O
ATTR_TYPE_HAS_STR_VAL	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
)	O
size	long
+=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
attr	O
->	O
s	*(void)
)	O
+	O
1	int
;	O
return	O
size	long
;	O
}	O
static	O
const	O
char	O
*	O
vendor_obj_attr_name	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
vendor	O
)	O
{	O
return	O
(	O
vendor	O
==	O
OBJ_ATTR_PROC	O
?	O
get_elf_backend_data	O
(	O
abfd	*(struct)
)	O
->	O
obj_attrs_vendor	O
:	O
"gnu"	*(char)
)	O
;	O
}	O
static	O
bfd_vma	long
vendor_obj_attr_size	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
vendor	O
)	O
{	O
bfd_vma	long
size	long
;	O
obj_attribute	O
*	O
attr	O
;	O
obj_attribute_list	O
*	O
list	O
;	O
int	O
i	*(struct)
;	O
const	O
char	O
*	O
vendor_name	O
=	O
vendor_obj_attr_name	O
(	O
abfd	*(struct)
,	O
vendor	O
)	O
;	O
if	O
(	O
!	O
vendor_name	O
)	O
return	O
0	int
;	O
attr	O
=	O
elf_known_obj_attributes	O
(	O
abfd	*(struct)
)	O
[	O
vendor	O
]	O
;	O
size	long
=	O
0	int
;	O
for	O
(	O
i	*(struct)
=	O
LEAST_KNOWN_OBJ_ATTRIBUTE	O
;	O
i	*(struct)
<	O
NUM_KNOWN_OBJ_ATTRIBUTES	O
;	O
i	*(struct)
++	O
)	O
size	long
+=	O
obj_attr_size	O
(	O
i	*(struct)
,	O
&	O
attr	O
[	O
i	*(struct)
]	O
)	O
;	O
for	O
(	O
list	O
=	O
elf_other_obj_attributes	O
(	O
abfd	*(struct)
)	O
[	O
vendor	O
]	O
;	O
list	O
;	O
list	O
=	O
list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
size	long
+=	O
obj_attr_size	O
(	O
list	O
->	O
tag	O
,	O
&	O
list	O
->	O
attr	O
)	O
;	O
return	O
(	O
size	long
?	O
size	long
+	O
10	int
+	O
strlen	(*(char))->(long)
(	O
vendor_name	O
)	O
:	O
0	int
)	O
;	O
}	O
bfd_vma	long
bfd_elf_obj_attr_size	O
(	O
bfd	struct
*	O
abfd	*(struct)
)	O
{	O
bfd_vma	long
size	long
;	O
size	long
=	O
vendor_obj_attr_size	O
(	O
abfd	*(struct)
,	O
OBJ_ATTR_PROC	O
)	O
;	O
size	long
+=	O
vendor_obj_attr_size	O
(	O
abfd	*(struct)
,	O
OBJ_ATTR_GNU	O
)	O
;	O
return	O
(	O
size	long
?	O
size	long
+	O
1	int
:	O
0	int
)	O
;	O
}	O
static	O
bfd_byte	char
*	O
write_uleb128	O
(	O
bfd_byte	char
*	O
p	*(void)
,	O
unsigned	O
int	O
val	array(int)
)	O
{	O
bfd_byte	char
c	O
;	O
do	O
{	O
c	O
=	O
val	array(int)
&	O
0x7f	int
;	O
val	array(int)
>>=	O
7	int
;	O
if	O
(	O
val	array(int)
)	O
c	O
|=	O
0x80	int
;	O
*	O
(	O
p	*(void)
++	O
)	O
=	O
c	O
;	O
}	O
while	O
(	O
val	array(int)
)	O
;	O
return	O
p	*(void)
;	O
}	O
static	O
bfd_byte	char
*	O
write_obj_attribute	O
(	O
bfd_byte	char
*	O
p	*(void)
,	O
unsigned	O
int	O
tag	O
,	O
obj_attribute	O
*	O
attr	O
)	O
{	O
if	O
(	O
is_default_attr	O
(	O
attr	O
)	O
)	O
return	O
p	*(void)
;	O
p	*(void)
=	O
write_uleb128	O
(	O
p	*(void)
,	O
tag	O
)	O
;	O
if	O
(	O
ATTR_TYPE_HAS_INT_VAL	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
)	O
p	*(void)
=	O
write_uleb128	O
(	O
p	*(void)
,	O
attr	O
->	O
i	*(struct)
)	O
;	O
if	O
(	O
ATTR_TYPE_HAS_STR_VAL	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
)	O
{	O
int	O
len	long
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
attr	O
->	O
s	*(void)
)	O
+	O
1	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
attr	O
->	O
s	*(void)
,	O
len	long
)	O
;	O
p	*(void)
+=	O
len	long
;	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
void	O
vendor_set_obj_attr_contents	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
bfd_byte	char
*	O
contents	*(char)
,	O
bfd_vma	long
size	long
,	O
int	O
vendor	O
)	O
{	O
bfd_byte	char
*	O
p	*(void)
;	O
obj_attribute	O
*	O
attr	O
;	O
obj_attribute_list	O
*	O
list	O
;	O
int	O
i	*(struct)
;	O
const	O
char	O
*	O
vendor_name	O
=	O
vendor_obj_attr_name	O
(	O
abfd	*(struct)
,	O
vendor	O
)	O
;	O
size_t	long
vendor_length	O
=	O
strlen	(*(char))->(long)
(	O
vendor_name	O
)	O
+	O
1	int
;	O
p	*(void)
=	O
contents	*(char)
;	O
bfd_put_32	O
(	O
abfd	*(struct)
,	O
size	long
,	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
4	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
vendor_name	O
,	O
vendor_length	O
)	O
;	O
p	*(void)
+=	O
vendor_length	O
;	O
*	O
(	O
p	*(void)
++	O
)	O
=	O
Tag_File	O
;	O
bfd_put_32	O
(	O
abfd	*(struct)
,	O
size	long
-	O
4	int
-	O
vendor_length	O
,	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
4	int
;	O
attr	O
=	O
elf_known_obj_attributes	O
(	O
abfd	*(struct)
)	O
[	O
vendor	O
]	O
;	O
for	O
(	O
i	*(struct)
=	O
LEAST_KNOWN_OBJ_ATTRIBUTE	O
;	O
i	*(struct)
<	O
NUM_KNOWN_OBJ_ATTRIBUTES	O
;	O
i	*(struct)
++	O
)	O
{	O
unsigned	O
int	O
tag	O
=	O
i	*(struct)
;	O
if	O
(	O
get_elf_backend_data	O
(	O
abfd	*(struct)
)	O
->	O
obj_attrs_order	O
)	O
tag	O
=	O
get_elf_backend_data	O
(	O
abfd	*(struct)
)	O
->	O
obj_attrs_order	O
(	O
i	*(struct)
)	O
;	O
p	*(void)
=	O
write_obj_attribute	O
(	O
p	*(void)
,	O
tag	O
,	O
&	O
attr	O
[	O
tag	O
]	O
)	O
;	O
}	O
for	O
(	O
list	O
=	O
elf_other_obj_attributes	O
(	O
abfd	*(struct)
)	O
[	O
vendor	O
]	O
;	O
list	O
;	O
list	O
=	O
list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
p	*(void)
=	O
write_obj_attribute	O
(	O
p	*(void)
,	O
list	O
->	O
tag	O
,	O
&	O
list	O
->	O
attr	O
)	O
;	O
}	O
void	O
bfd_elf_set_obj_attr_contents	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
bfd_byte	char
*	O
contents	*(char)
,	O
bfd_vma	long
size	long
)	O
{	O
bfd_byte	char
*	O
p	*(void)
;	O
int	O
vendor	O
;	O
bfd_vma	long
my_size	O
;	O
p	*(void)
=	O
contents	*(char)
;	O
*	O
(	O
p	*(void)
++	O
)	O
=	O
'A'	O
;	O
my_size	O
=	O
1	int
;	O
for	O
(	O
vendor	O
=	O
OBJ_ATTR_FIRST	O
;	O
vendor	O
<=	O
OBJ_ATTR_LAST	O
;	O
vendor	O
++	O
)	O
{	O
bfd_vma	long
vendor_size	O
=	O
vendor_obj_attr_size	O
(	O
abfd	*(struct)
,	O
vendor	O
)	O
;	O
if	O
(	O
vendor_size	O
)	O
vendor_set_obj_attr_contents	O
(	O
abfd	*(struct)
,	O
p	*(void)
,	O
vendor_size	O
,	O
vendor	O
)	O
;	O
p	*(void)
+=	O
vendor_size	O
;	O
my_size	O
+=	O
vendor_size	O
;	O
}	O
if	O
(	O
size	long
!=	O
my_size	O
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
static	O
obj_attribute	O
*	O
elf_new_obj_attr	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
vendor	O
,	O
unsigned	O
int	O
tag	O
)	O
{	O
obj_attribute	O
*	O
attr	O
;	O
obj_attribute_list	O
*	O
list	O
;	O
obj_attribute_list	O
*	O
p	*(void)
;	O
obj_attribute_list	O
*	O
*	O
lastp	O
;	O
if	O
(	O
tag	O
<	O
NUM_KNOWN_OBJ_ATTRIBUTES	O
)	O
{	O
attr	O
=	O
&	O
elf_known_obj_attributes	O
(	O
abfd	*(struct)
)	O
[	O
vendor	O
]	O
[	O
tag	O
]	O
;	O
}	O
else	O
{	O
list	O
=	O
(	O
obj_attribute_list	O
*	O
)	O
bfd_alloc	(*(struct),long)->(*(void))
(	O
abfd	*(struct)
,	O
sizeof	O
(	O
obj_attribute_list	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
list	O
,	O
0	int
,	O
sizeof	O
(	O
obj_attribute_list	O
)	O
)	O
;	O
list	O
->	O
tag	O
=	O
tag	O
;	O
lastp	O
=	O
&	O
elf_other_obj_attributes	O
(	O
abfd	*(struct)
)	O
[	O
vendor	O
]	O
;	O
for	O
(	O
p	*(void)
=	O
*	O
lastp	O
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
tag	O
<	O
p	*(void)
->	O
tag	O
)	O
break	O
;	O
lastp	O
=	O
&	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
}	O
list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
*	O
lastp	O
;	O
*	O
lastp	O
=	O
list	O
;	O
attr	O
=	O
&	O
list	O
->	O
attr	O
;	O
}	O
return	O
attr	O
;	O
}	O
int	O
bfd_elf_get_obj_attr_int	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
vendor	O
,	O
unsigned	O
int	O
tag	O
)	O
{	O
obj_attribute_list	O
*	O
p	*(void)
;	O
if	O
(	O
tag	O
<	O
NUM_KNOWN_OBJ_ATTRIBUTES	O
)	O
{	O
return	O
elf_known_obj_attributes	O
(	O
abfd	*(struct)
)	O
[	O
vendor	O
]	O
[	O
tag	O
]	O
.	O
i	*(struct)
;	O
}	O
else	O
{	O
for	O
(	O
p	*(void)
=	O
elf_other_obj_attributes	O
(	O
abfd	*(struct)
)	O
[	O
vendor	O
]	O
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
if	O
(	O
tag	O
==	O
p	*(void)
->	O
tag	O
)	O
return	O
p	*(void)
->	O
attr	O
.	O
i	*(struct)
;	O
if	O
(	O
tag	O
<	O
p	*(void)
->	O
tag	O
)	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
}	O
void	O
bfd_elf_add_obj_attr_int	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
vendor	O
,	O
unsigned	O
int	O
tag	O
,	O
unsigned	O
int	O
i	*(struct)
)	O
{	O
obj_attribute	O
*	O
attr	O
;	O
attr	O
=	O
elf_new_obj_attr	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
)	O
;	O
attr	O
->	O
type	enum(int,int,int,int)
=	O
_bfd_elf_obj_attrs_arg_type	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
)	O
;	O
attr	O
->	O
i	*(struct)
=	O
i	*(struct)
;	O
}	O
char	O
*	O
_bfd_elf_attr_strdup	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
const	O
char	O
*	O
s	*(void)
)	O
{	O
char	O
*	O
p	*(void)
;	O
int	O
len	long
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
s	*(void)
)	O
+	O
1	int
;	O
p	*(void)
=	O
(	O
char	O
*	O
)	O
bfd_alloc	(*(struct),long)->(*(void))
(	O
abfd	*(struct)
,	O
len	long
)	O
;	O
return	O
(	O
char	O
*	O
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
s	*(void)
,	O
len	long
)	O
;	O
}	O
void	O
bfd_elf_add_obj_attr_string	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
vendor	O
,	O
unsigned	O
int	O
tag	O
,	O
const	O
char	O
*	O
s	*(void)
)	O
{	O
obj_attribute	O
*	O
attr	O
;	O
attr	O
=	O
elf_new_obj_attr	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
)	O
;	O
attr	O
->	O
type	enum(int,int,int,int)
=	O
_bfd_elf_obj_attrs_arg_type	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
)	O
;	O
attr	O
->	O
s	*(void)
=	O
_bfd_elf_attr_strdup	O
(	O
abfd	*(struct)
,	O
s	*(void)
)	O
;	O
}	O
void	O
bfd_elf_add_obj_attr_int_string	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
vendor	O
,	O
unsigned	O
int	O
tag	O
,	O
unsigned	O
int	O
i	*(struct)
,	O
const	O
char	O
*	O
s	*(void)
)	O
{	O
obj_attribute	O
*	O
attr	O
;	O
attr	O
=	O
elf_new_obj_attr	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
)	O
;	O
attr	O
->	O
type	enum(int,int,int,int)
=	O
_bfd_elf_obj_attrs_arg_type	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
)	O
;	O
attr	O
->	O
i	*(struct)
=	O
i	*(struct)
;	O
attr	O
->	O
s	*(void)
=	O
_bfd_elf_attr_strdup	O
(	O
abfd	*(struct)
,	O
s	*(void)
)	O
;	O
}	O
void	O
_bfd_elf_copy_obj_attributes	O
(	O
bfd	struct
*	O
ibfd	*(struct)
,	O
bfd	struct
*	O
obfd	*(struct)
)	O
{	O
obj_attribute	O
*	O
in_attr	O
;	O
obj_attribute	O
*	O
out_attr	O
;	O
obj_attribute_list	O
*	O
list	O
;	O
int	O
i	*(struct)
;	O
int	O
vendor	O
;	O
if	O
(	O
bfd_get_flavour	O
(	O
ibfd	*(struct)
)	O
!=	O
bfd_target_elf_flavour	int
||	O
bfd_get_flavour	O
(	O
obfd	*(struct)
)	O
!=	O
bfd_target_elf_flavour	int
)	O
return	O
;	O
for	O
(	O
vendor	O
=	O
OBJ_ATTR_FIRST	O
;	O
vendor	O
<=	O
OBJ_ATTR_LAST	O
;	O
vendor	O
++	O
)	O
{	O
in_attr	O
=	O
&	O
elf_known_obj_attributes	O
(	O
ibfd	*(struct)
)	O
[	O
vendor	O
]	O
[	O
LEAST_KNOWN_OBJ_ATTRIBUTE	O
]	O
;	O
out_attr	O
=	O
&	O
elf_known_obj_attributes	O
(	O
obfd	*(struct)
)	O
[	O
vendor	O
]	O
[	O
LEAST_KNOWN_OBJ_ATTRIBUTE	O
]	O
;	O
for	O
(	O
i	*(struct)
=	O
LEAST_KNOWN_OBJ_ATTRIBUTE	O
;	O
i	*(struct)
<	O
NUM_KNOWN_OBJ_ATTRIBUTES	O
;	O
i	*(struct)
++	O
)	O
{	O
out_attr	O
->	O
type	enum(int,int,int,int)
=	O
in_attr	O
->	O
type	enum(int,int,int,int)
;	O
out_attr	O
->	O
i	*(struct)
=	O
in_attr	O
->	O
i	*(struct)
;	O
if	O
(	O
in_attr	O
->	O
s	*(void)
&&	O
*	O
in_attr	O
->	O
s	*(void)
)	O
out_attr	O
->	O
s	*(void)
=	O
_bfd_elf_attr_strdup	O
(	O
obfd	*(struct)
,	O
in_attr	O
->	O
s	*(void)
)	O
;	O
in_attr	O
++	O
;	O
out_attr	O
++	O
;	O
}	O
for	O
(	O
list	O
=	O
elf_other_obj_attributes	O
(	O
ibfd	*(struct)
)	O
[	O
vendor	O
]	O
;	O
list	O
;	O
list	O
=	O
list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
)	O
{	O
in_attr	O
=	O
&	O
list	O
->	O
attr	O
;	O
switch	O
(	O
in_attr	O
->	O
type	enum(int,int,int,int)
&	O
(	O
ATTR_TYPE_FLAG_INT_VAL	O
|	O
ATTR_TYPE_FLAG_STR_VAL	O
)	O
)	O
{	O
case	O
ATTR_TYPE_FLAG_INT_VAL	O
:	O
bfd_elf_add_obj_attr_int	O
(	O
obfd	*(struct)
,	O
vendor	O
,	O
list	O
->	O
tag	O
,	O
in_attr	O
->	O
i	*(struct)
)	O
;	O
break	O
;	O
case	O
ATTR_TYPE_FLAG_STR_VAL	O
:	O
bfd_elf_add_obj_attr_string	O
(	O
obfd	*(struct)
,	O
vendor	O
,	O
list	O
->	O
tag	O
,	O
in_attr	O
->	O
s	*(void)
)	O
;	O
break	O
;	O
case	O
ATTR_TYPE_FLAG_INT_VAL	O
|	O
ATTR_TYPE_FLAG_STR_VAL	O
:	O
bfd_elf_add_obj_attr_int_string	O
(	O
obfd	*(struct)
,	O
vendor	O
,	O
list	O
->	O
tag	O
,	O
in_attr	O
->	O
i	*(struct)
,	O
in_attr	O
->	O
s	*(void)
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
gnu_obj_attrs_arg_type	O
(	O
unsigned	O
int	O
tag	O
)	O
{	O
if	O
(	O
tag	O
==	O
Tag_compatibility	O
)	O
return	O
3	int
;	O
else	O
return	O
(	O
tag	O
&	O
1	int
)	O
!=	O
0	int
?	O
2	int
:	O
1	int
;	O
}	O
int	O
_bfd_elf_obj_attrs_arg_type	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
int	O
vendor	O
,	O
unsigned	O
int	O
tag	O
)	O
{	O
switch	O
(	O
vendor	O
)	O
{	O
case	O
OBJ_ATTR_PROC	O
:	O
return	O
get_elf_backend_data	O
(	O
abfd	*(struct)
)	O
->	O
obj_attrs_arg_type	O
(	O
tag	O
)	O
;	O
break	O
;	O
case	O
OBJ_ATTR_GNU	O
:	O
return	O
gnu_obj_attrs_arg_type	O
(	O
tag	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
_bfd_elf_parse_attributes	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
Elf_Internal_Shdr	O
*	O
hdr	O
)	O
{	O
bfd_byte	char
*	O
contents	*(char)
;	O
bfd_byte	char
*	O
p	*(void)
;	O
bfd_byte	char
*	O
p_end	O
;	O
bfd_vma	long
len	long
;	O
const	O
char	O
*	O
std_sec	O
;	O
if	O
(	O
hdr	O
->	O
sh_size	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
hdr	O
->	O
sh_size	O
>	O
bfd_get_file_size	(*(struct))->(long)
(	O
abfd	*(struct)
)	O
)	O
{	O
_bfd_error_handler	(*(char))->(void)
(	O
_	O
(	O
"%pB: error: attribute section '%pA' too big: %#llx"	*(char)
)	O
,	O
abfd	*(struct)
,	O
hdr	O
->	O
bfd_section	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))))),*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*(struct),long))),int,int,*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`))))),union(*(struct),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`))))))
,	O
(	O
long	O
long	O
)	O
hdr	O
->	O
sh_size	O
)	O
;	O
bfd_set_error	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
;	O
}	O
contents	*(char)
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	O
(	O
hdr	O
->	O
sh_size	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
contents	*(char)
)	O
return	O
;	O
if	O
(	O
!	O
bfd_get_section_contents	(*(struct),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),*(void),long,long)->(int)
(	O
abfd	*(struct)
,	O
hdr	O
->	O
bfd_section	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))))),*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*(struct),long))),int,int,*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`))))),union(*(struct),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`))))))
,	O
contents	*(char)
,	O
0	int
,	O
hdr	O
->	O
sh_size	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
contents	*(char)
)	O
;	O
return	O
;	O
}	O
contents	*(char)
[	O
hdr	O
->	O
sh_size	O
]	O
=	O
0	int
;	O
p	*(void)
=	O
contents	*(char)
;	O
p_end	O
=	O
p	*(void)
+	O
hdr	O
->	O
sh_size	O
;	O
std_sec	O
=	O
get_elf_backend_data	O
(	O
abfd	*(struct)
)	O
->	O
obj_attrs_vendor	O
;	O
if	O
(	O
*	O
(	O
p	*(void)
++	O
)	O
==	O
'A'	O
)	O
{	O
len	long
=	O
hdr	O
->	O
sh_size	O
-	O
1	int
;	O
while	O
(	O
len	long
>	O
0	int
&&	O
p	*(void)
<	O
p_end	O
-	O
4	int
)	O
{	O
unsigned	O
namelen	O
;	O
bfd_vma	long
section_len	O
;	O
int	O
vendor	O
;	O
section_len	O
=	O
bfd_get_32	O
(	O
abfd	*(struct)
,	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
4	int
;	O
if	O
(	O
section_len	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
section_len	O
>	O
len	long
)	O
section_len	O
=	O
len	long
;	O
len	long
-=	O
section_len	O
;	O
if	O
(	O
section_len	O
<=	O
4	int
)	O
{	O
_bfd_error_handler	(*(char))->(void)
(	O
_	O
(	O
"%pB: error: attribute section length too small: %"	*(char)
PRId64	O
)	O
,	O
abfd	*(struct)
,	O
(	O
int64_t	long
)	O
section_len	O
)	O
;	O
break	O
;	O
}	O
section_len	O
-=	O
4	int
;	O
namelen	O
=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
section_len	O
)	O
+	O
1	int
;	O
if	O
(	O
namelen	O
==	O
0	int
||	O
namelen	O
>=	O
section_len	O
)	O
break	O
;	O
section_len	O
-=	O
namelen	O
;	O
if	O
(	O
std_sec	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
std_sec	O
)	O
==	O
0	int
)	O
vendor	O
=	O
OBJ_ATTR_PROC	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
"gnu"	*(char)
)	O
==	O
0	int
)	O
vendor	O
=	O
OBJ_ATTR_GNU	O
;	O
else	O
{	O
p	*(void)
+=	O
namelen	O
+	O
section_len	O
;	O
continue	O
;	O
}	O
p	*(void)
+=	O
namelen	O
;	O
while	O
(	O
section_len	O
>	O
0	int
&&	O
p	*(void)
<	O
p_end	O
)	O
{	O
unsigned	O
int	O
tag	O
;	O
unsigned	O
int	O
n	long
;	O
unsigned	O
int	O
val	array(int)
;	O
bfd_vma	long
subsection_len	O
;	O
bfd_byte	char
*	O
end	*(*(char))
;	O
tag	O
=	O
_bfd_safe_read_leb128	O
(	O
abfd	*(struct)
,	O
p	*(void)
,	O
&	O
n	long
,	O
FALSE	O
,	O
p_end	O
)	O
;	O
p	*(void)
+=	O
n	long
;	O
if	O
(	O
p	*(void)
<	O
p_end	O
-	O
4	int
)	O
subsection_len	O
=	O
bfd_get_32	O
(	O
abfd	*(struct)
,	O
p	*(void)
)	O
;	O
else	O
subsection_len	O
=	O
0	int
;	O
p	*(void)
+=	O
4	int
;	O
if	O
(	O
subsection_len	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
subsection_len	O
>	O
section_len	O
)	O
subsection_len	O
=	O
section_len	O
;	O
section_len	O
-=	O
subsection_len	O
;	O
subsection_len	O
-=	O
n	long
+	O
4	int
;	O
end	*(*(char))
=	O
p	*(void)
+	O
subsection_len	O
;	O
if	O
(	O
end	*(*(char))
>	O
p_end	O
)	O
end	*(*(char))
=	O
p_end	O
;	O
switch	O
(	O
tag	O
)	O
{	O
case	O
Tag_File	O
:	O
while	O
(	O
p	*(void)
<	O
end	*(*(char))
)	O
{	O
int	O
type	enum(int,int,int,int)
;	O
tag	O
=	O
_bfd_safe_read_leb128	O
(	O
abfd	*(struct)
,	O
p	*(void)
,	O
&	O
n	long
,	O
FALSE	O
,	O
end	*(*(char))
)	O
;	O
p	*(void)
+=	O
n	long
;	O
type	enum(int,int,int,int)
=	O
_bfd_elf_obj_attrs_arg_type	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
)	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
&	O
(	O
ATTR_TYPE_FLAG_INT_VAL	O
|	O
ATTR_TYPE_FLAG_STR_VAL	O
)	O
)	O
{	O
case	O
ATTR_TYPE_FLAG_INT_VAL	O
|	O
ATTR_TYPE_FLAG_STR_VAL	O
:	O
val	array(int)
=	O
_bfd_safe_read_leb128	O
(	O
abfd	*(struct)
,	O
p	*(void)
,	O
&	O
n	long
,	O
FALSE	O
,	O
end	*(*(char))
)	O
;	O
p	*(void)
+=	O
n	long
;	O
bfd_elf_add_obj_attr_int_string	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
,	O
val	array(int)
,	O
(	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
)	O
+	O
1	int
;	O
break	O
;	O
case	O
ATTR_TYPE_FLAG_STR_VAL	O
:	O
bfd_elf_add_obj_attr_string	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
,	O
(	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
)	O
+	O
1	int
;	O
break	O
;	O
case	O
ATTR_TYPE_FLAG_INT_VAL	O
:	O
val	array(int)
=	O
_bfd_safe_read_leb128	O
(	O
abfd	*(struct)
,	O
p	*(void)
,	O
&	O
n	long
,	O
FALSE	O
,	O
end	*(*(char))
)	O
;	O
p	*(void)
+=	O
n	long
;	O
bfd_elf_add_obj_attr_int	O
(	O
abfd	*(struct)
,	O
vendor	O
,	O
tag	O
,	O
val	array(int)
)	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
Tag_Section	O
:	O
case	O
Tag_Symbol	O
:	O
default	O
:	O
p	*(void)
+=	O
subsection_len	O
;	O
subsection_len	O
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
contents	*(char)
)	O
;	O
}	O
bfd_boolean	int
_bfd_elf_merge_object_attributes	O
(	O
bfd	struct
*	O
ibfd	*(struct)
,	O
struct	O
bfd_link_info	O
*	O
info	*(void)
)	O
{	O
bfd	struct
*	O
obfd	*(struct)
=	O
info	*(void)
->	O
output_bfd	*(struct)
;	O
obj_attribute	O
*	O
in_attr	O
;	O
obj_attribute	O
*	O
out_attr	O
;	O
int	O
vendor	O
;	O
for	O
(	O
vendor	O
=	O
OBJ_ATTR_FIRST	O
;	O
vendor	O
<=	O
OBJ_ATTR_LAST	O
;	O
vendor	O
++	O
)	O
{	O
in_attr	O
=	O
&	O
elf_known_obj_attributes	O
(	O
ibfd	*(struct)
)	O
[	O
vendor	O
]	O
[	O
Tag_compatibility	O
]	O
;	O
out_attr	O
=	O
&	O
elf_known_obj_attributes	O
(	O
obfd	*(struct)
)	O
[	O
vendor	O
]	O
[	O
Tag_compatibility	O
]	O
;	O
if	O
(	O
in_attr	O
->	O
i	*(struct)
>	O
0	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
in_attr	O
->	O
s	*(void)
,	O
"gnu"	*(char)
)	O
!=	O
0	int
)	O
{	O
_bfd_error_handler	(*(char))->(void)
(	O
_	O
(	O
"error: %pB: object has vendor-specific contents that "	*(char)
"must be processed by the '%s' toolchain"	*(char)
)	O
,	O
ibfd	*(struct)
,	O
in_attr	O
->	O
s	*(void)
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
in_attr	O
->	O
i	*(struct)
!=	O
out_attr	O
->	O
i	*(struct)
||	O
(	O
in_attr	O
->	O
i	*(struct)
!=	O
0	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
in_attr	O
->	O
s	*(void)
,	O
out_attr	O
->	O
s	*(void)
)	O
!=	O
0	int
)	O
)	O
{	O
_bfd_error_handler	(*(char))->(void)
(	O
_	O
(	O
"error: %pB: object tag '%d, %s' is "	*(char)
"incompatible with tag '%d, %s'"	*(char)
)	O
,	O
ibfd	*(struct)
,	O
in_attr	O
->	O
i	*(struct)
,	O
in_attr	O
->	O
s	*(void)
?	O
in_attr	O
->	O
s	*(void)
:	O
""	*(char)
,	O
out_attr	O
->	O
i	*(struct)
,	O
out_attr	O
->	O
s	*(void)
?	O
out_attr	O
->	O
s	*(void)
:	O
""	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_elf_merge_unknown_attribute_low	O
(	O
bfd	struct
*	O
ibfd	*(struct)
,	O
bfd	struct
*	O
obfd	*(struct)
,	O
int	O
tag	O
)	O
{	O
obj_attribute	O
*	O
in_attr	O
;	O
obj_attribute	O
*	O
out_attr	O
;	O
bfd	struct
*	O
err_bfd	O
=	O
NULL	O
;	O
bfd_boolean	int
result	O
=	O
TRUE	int
;	O
in_attr	O
=	O
elf_known_obj_attributes_proc	O
(	O
ibfd	*(struct)
)	O
;	O
out_attr	O
=	O
elf_known_obj_attributes_proc	O
(	O
obfd	*(struct)
)	O
;	O
if	O
(	O
out_attr	O
[	O
tag	O
]	O
.	O
i	*(struct)
!=	O
0	int
||	O
out_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
!=	O
NULL	O
)	O
err_bfd	O
=	O
obfd	*(struct)
;	O
else	O
if	O
(	O
in_attr	O
[	O
tag	O
]	O
.	O
i	*(struct)
!=	O
0	int
||	O
in_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
!=	O
NULL	O
)	O
err_bfd	O
=	O
ibfd	*(struct)
;	O
if	O
(	O
err_bfd	O
!=	O
NULL	O
)	O
result	O
=	O
get_elf_backend_data	O
(	O
err_bfd	O
)	O
->	O
obj_attrs_handle_unknown	O
(	O
err_bfd	O
,	O
tag	O
)	O
;	O
if	O
(	O
in_attr	O
[	O
tag	O
]	O
.	O
i	*(struct)
!=	O
out_attr	O
[	O
tag	O
]	O
.	O
i	*(struct)
||	O
(	O
in_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
==	O
NULL	O
)	O
!=	O
(	O
out_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
==	O
NULL	O
)	O
||	O
(	O
in_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
!=	O
NULL	O
&&	O
out_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
in_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
,	O
out_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
)	O
!=	O
0	int
)	O
)	O
{	O
out_attr	O
[	O
tag	O
]	O
.	O
i	*(struct)
=	O
0	int
;	O
out_attr	O
[	O
tag	O
]	O
.	O
s	*(void)
=	O
NULL	O
;	O
}	O
return	O
result	O
;	O
}	O
bfd_boolean	int
_bfd_elf_merge_unknown_attribute_list	O
(	O
bfd	struct
*	O
ibfd	*(struct)
,	O
bfd	struct
*	O
obfd	*(struct)
)	O
{	O
obj_attribute_list	O
*	O
in_list	O
;	O
obj_attribute_list	O
*	O
out_list	O
;	O
obj_attribute_list	O
*	O
*	O
out_listp	O
;	O
bfd_boolean	int
result	O
=	O
TRUE	int
;	O
in_list	O
=	O
elf_other_obj_attributes_proc	O
(	O
ibfd	*(struct)
)	O
;	O
out_listp	O
=	O
&	O
elf_other_obj_attributes_proc	O
(	O
obfd	*(struct)
)	O
;	O
out_list	O
=	O
*	O
out_listp	O
;	O
for	O
(	O
;	O
in_list	O
||	O
out_list	O
;	O
)	O
{	O
bfd	struct
*	O
err_bfd	O
=	O
NULL	O
;	O
unsigned	O
int	O
err_tag	O
=	O
0	int
;	O
if	O
(	O
out_list	O
&&	O
(	O
!	O
in_list	O
||	O
in_list	O
->	O
tag	O
>	O
out_list	O
->	O
tag	O
)	O
)	O
{	O
err_bfd	O
=	O
obfd	*(struct)
;	O
err_tag	O
=	O
out_list	O
->	O
tag	O
;	O
*	O
out_listp	O
=	O
out_list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
out_list	O
=	O
*	O
out_listp	O
;	O
}	O
else	O
if	O
(	O
in_list	O
&&	O
(	O
!	O
out_list	O
||	O
in_list	O
->	O
tag	O
<	O
out_list	O
->	O
tag	O
)	O
)	O
{	O
err_bfd	O
=	O
ibfd	*(struct)
;	O
err_tag	O
=	O
in_list	O
->	O
tag	O
;	O
in_list	O
=	O
in_list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
}	O
else	O
{	O
err_bfd	O
=	O
obfd	*(struct)
;	O
err_tag	O
=	O
out_list	O
->	O
tag	O
;	O
if	O
(	O
in_list	O
->	O
attr	O
.	O
i	*(struct)
!=	O
out_list	O
->	O
attr	O
.	O
i	*(struct)
||	O
(	O
in_list	O
->	O
attr	O
.	O
s	*(void)
==	O
NULL	O
)	O
!=	O
(	O
out_list	O
->	O
attr	O
.	O
s	*(void)
==	O
NULL	O
)	O
||	O
(	O
in_list	O
->	O
attr	O
.	O
s	*(void)
&&	O
out_list	O
->	O
attr	O
.	O
s	*(void)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
in_list	O
->	O
attr	O
.	O
s	*(void)
,	O
out_list	O
->	O
attr	O
.	O
s	*(void)
)	O
!=	O
0	int
)	O
)	O
{	O
*	O
out_listp	O
=	O
out_list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
out_list	O
=	O
*	O
out_listp	O
;	O
}	O
else	O
{	O
out_list	O
=	O
out_list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
in_list	O
=	O
in_list	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
}	O
}	O
if	O
(	O
err_bfd	O
)	O
result	O
=	O
result	O
&&	O
get_elf_backend_data	O
(	O
err_bfd	O
)	O
->	O
obj_attrs_handle_unknown	O
(	O
err_bfd	O
,	O
err_tag	O
)	O
;	O
}	O
return	O
result	O
;	O
}	O
