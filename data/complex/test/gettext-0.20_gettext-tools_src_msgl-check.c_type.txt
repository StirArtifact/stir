static	O
unsigned	O
int	O
plural_expression_histogram	O
(	O
const	O
struct	O
plural_distribution	O
*	O
self	O
,	O
int	O
min	int
,	O
int	O
max	int
,	O
unsigned	O
long	O
j	O
)	O
{	O
if	O
(	O
min	int
<	O
0	int
)	O
min	int
=	O
0	int
;	O
if	O
(	O
max	int
-	O
min	int
>	O
1000	int
)	O
max	int
=	O
min	int
+	O
1000	int
;	O
if	O
(	O
min	int
<=	O
max	int
)	O
{	O
const	O
struct	O
expression	O
*	O
expr	O
=	O
self	O
->	O
expr	O
;	O
unsigned	O
long	O
n	long
;	O
unsigned	O
int	O
count	O
;	O
install_sigfpe_handler	O
(	O
)	O
;	O
count	O
=	O
0	int
;	O
for	O
(	O
n	long
=	O
min	int
;	O
n	long
<=	O
max	int
;	O
n	long
++	O
)	O
{	O
unsigned	O
long	O
val	O
=	O
plural_eval	O
(	O
expr	O
,	O
n	long
)	O
;	O
if	O
(	O
val	O
==	O
j	O
)	O
count	O
++	O
;	O
}	O
uninstall_sigfpe_handler	O
(	O
)	O
;	O
return	O
count	O
;	O
}	O
else	O
return	O
0	int
;	O
}	O
int	O
check_plural_eval	O
(	O
const	O
struct	O
expression	O
*	O
plural_expr	O
,	O
unsigned	O
long	O
nplurals_value	O
,	O
const	O
message_ty	struct
*	O
header	O
,	O
struct	O
plural_distribution	O
*	O
distribution	O
)	O
{	O
unsigned	O
char	O
*	O
volatile	O
array	O
;	O
if	O
(	O
nplurals_value	O
<=	O
100	int
)	O
array	O
=	O
XCALLOC	O
(	O
nplurals_value	O
,	O
unsigned	O
char	O
)	O
;	O
else	O
array	O
=	O
NULL	O
;	O
if	O
(	O
sigsetjmp	O
(	O
sigfpe_exit	O
,	O
1	int
)	O
==	O
0	int
)	O
{	O
unsigned	O
long	O
n	long
;	O
install_sigfpe_handler	O
(	O
)	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<=	O
1000	int
;	O
n	long
++	O
)	O
{	O
unsigned	O
long	O
val	O
=	O
plural_eval	O
(	O
plural_expr	O
,	O
n	long
)	O
;	O
if	O
(	O
(	O
long	O
)	O
val	O
<	O
0	int
)	O
{	O
uninstall_sigfpe_handler	O
(	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
_	O
(	O
"plural expression can produce negative values"	*(char)
)	O
)	O
;	O
free	O
(	O
array	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
val	O
>=	O
nplurals_value	O
)	O
{	O
char	O
*	O
msg	O
;	O
uninstall_sigfpe_handler	O
(	O
)	O
;	O
msg	O
=	O
xasprintf	O
(	O
_	O
(	O
"nplurals = %lu but plural expression can produce values as large as %lu"	*(char)
)	O
,	O
nplurals_value	O
,	O
val	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
free	O
(	O
array	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
array	O
!=	O
NULL	O
&&	O
array	O
[	O
val	O
]	O
<	O
OFTEN	O
)	O
array	O
[	O
val	O
]	O
++	O
;	O
}	O
uninstall_sigfpe_handler	O
(	O
)	O
;	O
if	O
(	O
array	O
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
val	O
;	O
for	O
(	O
val	O
=	O
0	int
;	O
val	O
<	O
nplurals_value	O
;	O
val	O
++	O
)	O
array	O
[	O
val	O
]	O
=	O
(	O
array	O
[	O
val	O
]	O
==	O
OFTEN	O
?	O
1	int
:	O
0	int
)	O
;	O
}	O
distribution	O
->	O
expr	O
=	O
plural_expr	O
;	O
distribution	O
->	O
often	O
=	O
array	O
;	O
distribution	O
->	O
often_length	O
=	O
(	O
array	O
!=	O
NULL	O
?	O
nplurals_value	O
:	O
0	int
)	O
;	O
distribution	O
->	O
histogram	O
=	O
plural_expression_histogram	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
const	O
char	O
*	O
msg	O
;	O
uninstall_sigfpe_handler	O
(	O
)	O
;	O
switch	O
(	O
sigfpe_code	O
)	O
{	O
case	O
FPE_INTDIV	O
:	O
msg	O
=	O
_	O
(	O
"plural expression can produce division by zero"	*(char)
)	O
;	O
break	O
;	O
case	O
FPE_INTOVF	O
:	O
msg	O
=	O
_	O
(	O
"plural expression can produce integer overflow"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
msg	O
=	O
_	O
(	O
"plural expression can produce arithmetic exceptions, possibly division by zero"	*(char)
)	O
;	O
}	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg	O
)	O
;	O
free	O
(	O
array	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
static	O
char	O
*	O
plural_help	O
(	O
const	O
char	O
*	O
nullentry	O
)	O
{	O
struct	O
plural_table_entry	O
*	O
ptentry	O
=	O
NULL	O
;	O
{	O
const	O
char	O
*	O
language	O
;	O
language	O
=	O
c_strstr	O
(	O
nullentry	O
,	O
"Language: "	*(char)
)	O
;	O
if	O
(	O
language	O
!=	O
NULL	O
)	O
{	O
size_t	long
len	O
;	O
language	O
+=	O
10	int
;	O
len	O
=	O
strcspn	(*(char),*(char))->(long)
(	O
language	O
,	O
" \t\n"	*(char)
)	O
;	O
if	O
(	O
len	O
>	O
0	int
)	O
{	O
size_t	long
j	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
plural_table_size	O
;	O
j	O
++	O
)	O
if	O
(	O
len	O
==	O
strlen	(*(char))->(long)
(	O
plural_table	O
[	O
j	O
]	O
.	O
lang	O
)	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
language	O
,	O
plural_table	O
[	O
j	O
]	O
.	O
lang	O
,	O
len	O
)	O
==	O
0	int
)	O
{	O
ptentry	O
=	O
&	O
plural_table	O
[	O
j	O
]	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ptentry	O
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
language	O
;	O
language	O
=	O
c_strstr	O
(	O
nullentry	O
,	O
"Language-Team: "	*(char)
)	O
;	O
if	O
(	O
language	O
!=	O
NULL	O
)	O
{	O
size_t	long
j	O
;	O
language	O
+=	O
15	int
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
plural_table_size	O
;	O
j	O
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
language	O
,	O
plural_table	O
[	O
j	O
]	O
.	O
language	O
,	O
strlen	(*(char))->(long)
(	O
plural_table	O
[	O
j	O
]	O
.	O
language	O
)	O
)	O
==	O
0	int
)	O
{	O
ptentry	O
=	O
&	O
plural_table	O
[	O
j	O
]	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
ptentry	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
helpline1	O
=	O
xasprintf	O
(	O
_	O
(	O
"Try using the following, valid for %s:"	*(char)
)	O
,	O
ptentry	O
->	O
language	O
)	O
;	O
char	O
*	O
help	O
=	O
xasprintf	O
(	O
"%s\n\"Plural-Forms: %s\\n\"\n"	*(char)
,	O
helpline1	O
,	O
ptentry	O
->	O
value	O
)	O
;	O
free	O
(	O
helpline1	O
)	O
;	O
return	O
help	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
check_plural	O
(	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
int	O
ignore_untranslated_messages	O
,	O
int	O
ignore_fuzzy_messages	O
,	O
struct	O
plural_distribution	O
*	O
distributionp	O
)	O
{	O
int	O
seen_errors	O
=	O
0	int
;	O
const	O
message_ty	struct
*	O
has_plural	O
;	O
unsigned	O
long	O
min_nplurals	O
;	O
const	O
message_ty	struct
*	O
min_pos	O
;	O
unsigned	O
long	O
max_nplurals	O
;	O
const	O
message_ty	struct
*	O
max_pos	O
;	O
struct	O
plural_distribution	O
distribution	O
;	O
size_t	long
j	O
;	O
message_ty	struct
*	O
header	O
;	O
has_plural	O
=	O
NULL	O
;	O
min_nplurals	O
=	O
ULONG_MAX	O
;	O
min_pos	O
=	O
NULL	O
;	O
max_nplurals	O
=	O
0	int
;	O
max_pos	O
=	O
NULL	O
;	O
distribution	O
.	O
expr	O
=	O
NULL	O
;	O
distribution	O
.	O
often	O
=	O
NULL	O
;	O
distribution	O
.	O
often_length	O
=	O
0	int
;	O
distribution	O
.	O
histogram	O
=	O
NULL	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
;	O
j	O
++	O
)	O
{	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
item	*(*(char))
[	O
j	O
]	O
;	O
if	O
(	O
!	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
obsolete	bool
&&	O
!	O
(	O
ignore_untranslated_messages	O
&&	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
&&	O
!	O
(	O
ignore_fuzzy_messages	O
&&	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
is_fuzzy	bool
&&	O
!	O
is_header	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
)	O
)	O
&&	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
const	O
char	O
*	O
p_end	O
;	O
unsigned	O
long	O
n	long
;	O
if	O
(	O
has_plural	O
==	O
NULL	O
)	O
has_plural	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
n	long
=	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
,	O
p_end	O
=	O
p	*(void)
+	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
;	O
p	*(void)
<	O
p_end	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
1	int
)	O
n	long
++	O
;	O
if	O
(	O
min_nplurals	O
>	O
n	long
)	O
{	O
min_nplurals	O
=	O
n	long
;	O
min_pos	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
}	O
if	O
(	O
max_nplurals	O
<	O
n	long
)	O
{	O
max_nplurals	O
=	O
n	long
;	O
max_pos	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
}	O
}	O
}	O
header	O
=	O
message_list_search	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*`,long,long)),*(struct(*`,long,long)),long,*(struct(*`,long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`)),int,*(struct(*`,long,*`,*`,*`,*`)))))
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
NULL	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
header	O
!=	O
NULL	O
&&	O
!	O
header	O
->	O
obsolete	bool
)	O
{	O
const	O
char	O
*	O
nullentry	O
;	O
const	O
char	O
*	O
plural	O
;	O
const	O
char	O
*	O
nplurals	O
;	O
nullentry	O
=	O
header	O
->	O
msgstr	*(char)
;	O
plural	O
=	O
c_strstr	O
(	O
nullentry	O
,	O
"plural="	*(char)
)	O
;	O
nplurals	O
=	O
c_strstr	O
(	O
nullentry	O
,	O
"nplurals="	*(char)
)	O
;	O
if	O
(	O
plural	O
==	O
NULL	O
&&	O
has_plural	O
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
msg1	O
=	O
_	O
(	O
"message catalog has plural form translations"	*(char)
)	O
;	O
const	O
char	O
*	O
msg2	O
=	O
_	O
(	O
"but header entry lacks a \"plural=EXPRESSION\" attribute"	*(char)
)	O
;	O
char	O
*	O
help	O
=	O
plural_help	O
(	O
nullentry	O
)	O
;	O
if	O
(	O
help	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
msg2ext	O
=	O
xasprintf	O
(	O
"%s\n%s"	*(char)
,	O
msg2	O
,	O
help	O
)	O
;	O
po_xerror2	O
(	O
PO_SEVERITY_ERROR	O
,	O
has_plural	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg1	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	O
,	O
msg2ext	O
)	O
;	O
free	O
(	O
msg2ext	O
)	O
;	O
free	O
(	O
help	O
)	O
;	O
}	O
else	O
po_xerror2	O
(	O
PO_SEVERITY_ERROR	O
,	O
has_plural	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg1	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg2	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
if	O
(	O
nplurals	O
==	O
NULL	O
&&	O
has_plural	O
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
msg1	O
=	O
_	O
(	O
"message catalog has plural form translations"	*(char)
)	O
;	O
const	O
char	O
*	O
msg2	O
=	O
_	O
(	O
"but header entry lacks a \"nplurals=INTEGER\" attribute"	*(char)
)	O
;	O
char	O
*	O
help	O
=	O
plural_help	O
(	O
nullentry	O
)	O
;	O
if	O
(	O
help	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
msg2ext	O
=	O
xasprintf	O
(	O
"%s\n%s"	*(char)
,	O
msg2	O
,	O
help	O
)	O
;	O
po_xerror2	O
(	O
PO_SEVERITY_ERROR	O
,	O
has_plural	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg1	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	O
,	O
msg2ext	O
)	O
;	O
free	O
(	O
msg2ext	O
)	O
;	O
free	O
(	O
help	O
)	O
;	O
}	O
else	O
po_xerror2	O
(	O
PO_SEVERITY_ERROR	O
,	O
has_plural	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg1	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg2	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
if	O
(	O
plural	O
!=	O
NULL	O
&&	O
nplurals	O
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
endp	O
;	O
unsigned	O
long	O
int	O
nplurals_value	O
;	O
struct	O
parse_args	O
args	array(*(struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
;	O
const	O
struct	O
expression	O
*	O
plural_expr	O
;	O
nplurals	O
+=	O
9	int
;	O
while	O
(	O
*	O
nplurals	O
!=	O
'\0'	O
&&	O
c_isspace	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
nplurals	O
)	O
)	O
++	O
nplurals	O
;	O
endp	O
=	O
nplurals	O
;	O
nplurals_value	O
=	O
0	int
;	O
if	O
(	O
*	O
nplurals	O
>=	O
'0'	O
&&	O
*	O
nplurals	O
<=	O
'9'	O
)	O
nplurals_value	O
=	O
strtoul	O
(	O
nplurals	O
,	O
(	O
char	O
*	O
*	O
)	O
&	O
endp	O
,	O
10	int
)	O
;	O
if	O
(	O
nplurals	O
==	O
endp	O
)	O
{	O
const	O
char	O
*	O
msg	O
=	O
_	O
(	O
"invalid nplurals value"	*(char)
)	O
;	O
char	O
*	O
help	O
=	O
plural_help	O
(	O
nullentry	O
)	O
;	O
if	O
(	O
help	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
msgext	O
=	O
xasprintf	O
(	O
"%s\n%s"	*(char)
,	O
msg	O
,	O
help	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	O
,	O
msgext	O
)	O
;	O
free	O
(	O
msgext	O
)	O
;	O
free	O
(	O
help	O
)	O
;	O
}	O
else	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
plural	O
+=	O
7	int
;	O
args	array(*(struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
.	O
cp	O
=	O
plural	O
;	O
if	O
(	O
parse_plural_expression	O
(	O
&	O
args	array(*(struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
)	O
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
msg	O
=	O
_	O
(	O
"invalid plural expression"	*(char)
)	O
;	O
char	O
*	O
help	O
=	O
plural_help	O
(	O
nullentry	O
)	O
;	O
if	O
(	O
help	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
msgext	O
=	O
xasprintf	O
(	O
"%s\n%s"	*(char)
,	O
msg	O
,	O
help	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	O
,	O
msgext	O
)	O
;	O
free	O
(	O
msgext	O
)	O
;	O
free	O
(	O
help	O
)	O
;	O
}	O
else	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
plural_expr	O
=	O
args	array(*(struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
.	O
res	O
;	O
if	O
(	O
!	O
seen_errors	O
)	O
seen_errors	O
=	O
check_plural_eval	O
(	O
plural_expr	O
,	O
nplurals_value	O
,	O
header	O
,	O
&	O
distribution	O
)	O
;	O
if	O
(	O
!	O
seen_errors	O
)	O
{	O
if	O
(	O
min_nplurals	O
<	O
nplurals_value	O
)	O
{	O
char	O
*	O
msg1	O
=	O
xasprintf	O
(	O
_	O
(	O
"nplurals = %lu"	*(char)
)	O
,	O
nplurals_value	O
)	O
;	O
char	O
*	O
msg2	O
=	O
xasprintf	O
(	O
ngettext	O
(	O
"but some messages have only one plural form"	*(char)
,	O
"but some messages have only %lu plural forms"	*(char)
,	O
min_nplurals	O
)	O
,	O
min_nplurals	O
)	O
;	O
po_xerror2	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg1	O
,	O
min_pos	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg2	O
)	O
;	O
free	O
(	O
msg2	O
)	O
;	O
free	O
(	O
msg1	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
else	O
if	O
(	O
max_nplurals	O
>	O
nplurals_value	O
)	O
{	O
char	O
*	O
msg1	O
=	O
xasprintf	O
(	O
_	O
(	O
"nplurals = %lu"	*(char)
)	O
,	O
nplurals_value	O
)	O
;	O
char	O
*	O
msg2	O
=	O
xasprintf	O
(	O
ngettext	O
(	O
"but some messages have one plural form"	*(char)
,	O
"but some messages have %lu plural forms"	*(char)
,	O
max_nplurals	O
)	O
,	O
max_nplurals	O
)	O
;	O
po_xerror2	O
(	O
PO_SEVERITY_ERROR	O
,	O
header	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg1	O
,	O
max_pos	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg2	O
)	O
;	O
free	O
(	O
msg2	O
)	O
;	O
free	O
(	O
msg1	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
}	O
}	O
else	O
goto	O
no_plural	O
;	O
}	O
else	O
{	O
if	O
(	O
has_plural	O
!=	O
NULL	O
)	O
{	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
has_plural	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
_	O
(	O
"message catalog has plural form translations, but lacks a header entry with \"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\""	*(char)
)	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
no_plural	O
:	O
distribution	O
.	O
expr	O
=	O
&	O
germanic_plural	O
;	O
{	O
unsigned	O
char	O
*	O
array	O
=	O
XCALLOC	O
(	O
2	int
,	O
unsigned	O
char	O
)	O
;	O
array	O
[	O
1	int
]	O
=	O
1	int
;	O
distribution	O
.	O
often	O
=	O
array	O
;	O
}	O
distribution	O
.	O
often_length	O
=	O
2	int
;	O
distribution	O
.	O
histogram	O
=	O
plural_expression_histogram	O
;	O
}	O
if	O
(	O
seen_errors	O
>	O
0	int
)	O
free	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
distribution	O
.	O
often	O
)	O
;	O
else	O
*	O
distributionp	O
=	O
distribution	O
;	O
return	O
seen_errors	O
;	O
}	O
static	O
const	O
message_ty	struct
*	O
curr_mp	O
;	O
static	O
lex_pos_ty	struct
curr_msgid_pos	O
;	O
static	O
void	O
formatstring_error_logger	O
(	O
const	O
char	O
*	O
format	O
,	O
...	O
)	O
__attribute__	O
(	O
(	O
__format__	O
(	O
__printf__	O
,	O
1	int
,	O
2	int
)	O
)	O
)	O
;	O
static	O
void	O
formatstring_error_logger	O
(	O
const	O
char	O
*	O
format	O
,	O
...	O
)	O
{	O
va_list	O
args	array(*(struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
;	O
char	O
*	O
msg	O
;	O
va_start	O
(	O
args	array(*(struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
,	O
format	O
)	O
;	O
if	O
(	O
vasprintf	O
(	O
&	O
msg	O
,	O
format	O
,	O
args	array(*(struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
)	O
<	O
0	int
)	O
error	O
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
va_end	O
(	O
args	array(*(struct(int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))))
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
curr_mp	O
,	O
curr_msgid_pos	O
.	O
file_name	*(char)
,	O
curr_msgid_pos	O
.	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
}	O
static	O
int	O
check_pair	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
char	O
*	O
msgid	*(char)
,	O
const	O
lex_pos_ty	struct
*	O
msgid_pos	O
,	O
const	O
char	O
*	O
msgid_plural	*(char)
,	O
const	O
char	O
*	O
msgstr	*(char)
,	O
size_t	long
msgstr_len	long
,	O
const	O
enum	O
is_format	enum(int,int,int,int,int,int)
is_format	enum(int,int,int,int,int,int)
[	O
NFORMATS	int
]	O
,	O
int	O
check_newlines	O
,	O
int	O
check_format_strings	O
,	O
const	O
struct	O
plural_distribution	O
*	O
distribution	O
,	O
int	O
check_compatibility	O
,	O
int	O
check_accelerators	O
,	O
char	O
accelerator_char	O
)	O
{	O
int	O
seen_errors	O
;	O
int	O
has_newline	O
;	O
unsigned	O
int	O
j	O
;	O
if	O
(	O
msgid	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
0	int
;	O
seen_errors	O
=	O
0	int
;	O
if	O
(	O
check_newlines	O
)	O
{	O
has_newline	O
=	O
(	O
msgid	*(char)
[	O
0	int
]	O
==	O
'\n'	O
)	O
;	O
if	O
(	O
msgid_plural	*(char)
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
TEST_NEWLINE	O
(	O
msgid_plural	*(char)
)	O
!=	O
has_newline	O
)	O
{	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
_	O
(	O
"'msgid' and 'msgid_plural' entries do not both begin with '\\n'"	*(char)
)	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
for	O
(	O
p	*(void)
=	O
msgstr	*(char)
,	O
j	O
=	O
0	int
;	O
p	*(void)
<	O
msgstr	*(char)
+	O
msgstr_len	long
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
1	int
,	O
j	O
++	O
)	O
if	O
(	O
TEST_NEWLINE	O
(	O
p	*(void)
)	O
!=	O
has_newline	O
)	O
{	O
char	O
*	O
msg	O
=	O
xasprintf	O
(	O
_	O
(	O
"'msgid' and 'msgstr[%u]' entries do not both begin with '\\n'"	*(char)
)	O
,	O
j	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
TEST_NEWLINE	O
(	O
msgstr	*(char)
)	O
!=	O
has_newline	O
)	O
{	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
_	O
(	O
"'msgid' and 'msgstr' entries do not both begin with '\\n'"	*(char)
)	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
}	O
has_newline	O
=	O
(	O
msgid	*(char)
[	O
strlen	(*(char))->(long)
(	O
msgid	*(char)
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
;	O
if	O
(	O
msgid_plural	*(char)
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
TEST_NEWLINE	O
(	O
msgid_plural	*(char)
)	O
!=	O
has_newline	O
)	O
{	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
_	O
(	O
"'msgid' and 'msgid_plural' entries do not both end with '\\n'"	*(char)
)	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
for	O
(	O
p	*(void)
=	O
msgstr	*(char)
,	O
j	O
=	O
0	int
;	O
p	*(void)
<	O
msgstr	*(char)
+	O
msgstr_len	long
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
1	int
,	O
j	O
++	O
)	O
if	O
(	O
TEST_NEWLINE	O
(	O
p	*(void)
)	O
!=	O
has_newline	O
)	O
{	O
char	O
*	O
msg	O
=	O
xasprintf	O
(	O
_	O
(	O
"'msgid' and 'msgstr[%u]' entries do not both end with '\\n'"	*(char)
)	O
,	O
j	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
TEST_NEWLINE	O
(	O
msgstr	*(char)
)	O
!=	O
has_newline	O
)	O
{	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
_	O
(	O
"'msgid' and 'msgstr' entries do not both end with '\\n'"	*(char)
)	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
}	O
}	O
if	O
(	O
check_compatibility	O
&&	O
msgid_plural	*(char)
!=	O
NULL	O
)	O
{	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
_	O
(	O
"plural handling is a GNU gettext extension"	*(char)
)	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
if	O
(	O
check_format_strings	O
)	O
{	O
curr_mp	O
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
curr_msgid_pos	O
=	O
*	O
msgid_pos	O
;	O
seen_errors	O
+=	O
check_msgid_msgstr_format	O
(	O
msgid	*(char)
,	O
msgid_plural	*(char)
,	O
msgstr	*(char)
,	O
msgstr_len	long
,	O
is_format	enum(int,int,int,int,int,int)
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
range	struct(int,int)
,	O
distribution	O
,	O
formatstring_error_logger	O
)	O
;	O
}	O
if	O
(	O
check_accelerators	O
&&	O
msgid_plural	*(char)
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
msgid	*(char)
,	O
accelerator_char	O
)	O
;	O
if	O
(	O
p	*(void)
!=	O
NULL	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
+	O
1	int
,	O
accelerator_char	O
)	O
==	O
NULL	O
)	O
{	O
unsigned	O
int	O
count	O
=	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
msgstr	*(char)
;	O
(	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
accelerator_char	O
)	O
)	O
!=	O
NULL	O
;	O
p	*(void)
++	O
)	O
if	O
(	O
p	*(void)
[	O
1	int
]	O
==	O
accelerator_char	O
)	O
p	*(void)
++	O
;	O
else	O
count	O
++	O
;	O
if	O
(	O
count	O
==	O
0	int
)	O
{	O
char	O
*	O
msg	O
=	O
xasprintf	O
(	O
_	O
(	O
"msgstr lacks the keyboard accelerator mark '%c'"	*(char)
)	O
,	O
accelerator_char	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
else	O
if	O
(	O
count	O
>	O
1	int
)	O
{	O
char	O
*	O
msg	O
=	O
xasprintf	O
(	O
_	O
(	O
"msgstr has too many keyboard accelerator marks '%c'"	*(char)
)	O
,	O
accelerator_char	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
msgid_pos	O
->	O
file_name	*(char)
,	O
msgid_pos	O
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
}	O
}	O
return	O
seen_errors	O
;	O
}	O
static	O
int	O
check_header_entry	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
char	O
*	O
msgstr_string	O
)	O
{	O
static	O
const	O
char	O
*	O
required_fields	O
[	O
]	O
=	O
{	O
"Project-Id-Version"	*(char)
,	O
"PO-Revision-Date"	*(char)
,	O
"Last-Translator"	*(char)
,	O
"Language-Team"	*(char)
,	O
"MIME-Version"	*(char)
,	O
"Content-Type"	*(char)
,	O
"Content-Transfer-Encoding"	*(char)
,	O
"Language"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
default_values	O
[	O
]	O
=	O
{	O
"PACKAGE VERSION"	*(char)
,	O
"YEAR-MO-DA HO:MI+ZONE"	*(char)
,	O
"FULL NAME <EMAIL@ADDRESS>"	*(char)
,	O
"LANGUAGE <LL@li.org>"	*(char)
,	O
NULL	O
,	O
"text/plain; charset=CHARSET"	*(char)
,	O
"ENCODING"	*(char)
,	O
""	*(char)
}	O
;	O
const	O
size_t	long
nfields	O
=	O
SIZEOF	O
(	O
required_fields	O
)	O
;	O
int	O
seen_errors	O
=	O
0	int
;	O
int	O
cnt	O
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
nfields	O
;	O
++	O
cnt	O
)	O
{	O
int	O
severity	O
=	O
PO_SEVERITY_WARNING	O
;	O
const	O
char	O
*	O
field	O
=	O
required_fields	O
[	O
cnt	O
]	O
;	O
size_t	long
len	O
=	O
strlen	(*(char))->(long)
(	O
field	O
)	O
;	O
const	O
char	O
*	O
line	long
;	O
for	O
(	O
line	long
=	O
msgstr_string	O
;	O
*	O
line	long
!=	O
'\0'	O
;	O
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	long
,	O
field	O
,	O
len	O
)	O
==	O
0	int
&&	O
line	long
[	O
len	O
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
=	O
line	long
+	O
len	O
+	O
1	int
;	O
if	O
(	O
*	O
p	*(void)
==	O
' '	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
default_values	O
[	O
cnt	O
]	O
!=	O
NULL	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
default_values	O
[	O
cnt	O
]	O
,	O
strlen	(*(char))->(long)
(	O
default_values	O
[	O
cnt	O
]	O
)	O
)	O
==	O
0	int
)	O
{	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
default_values	O
[	O
cnt	O
]	O
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
'\0'	O
||	O
*	O
p	*(void)
==	O
'\n'	O
)	O
{	O
char	O
*	O
msg	O
=	O
xasprintf	O
(	O
_	O
(	O
"header field '%s' still has the initial default value\n"	*(char)
)	O
,	O
field	O
)	O
;	O
po_xerror	O
(	O
severity	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
if	O
(	O
severity	O
==	O
PO_SEVERITY_ERROR	O
)	O
seen_errors	O
++	O
;	O
}	O
}	O
break	O
;	O
}	O
line	long
=	O
strchrnul	(*(char),int)->(*(char))
(	O
line	long
,	O
'\n'	O
)	O
;	O
if	O
(	O
*	O
line	long
==	O
'\n'	O
)	O
line	long
++	O
;	O
}	O
if	O
(	O
*	O
line	long
==	O
'\0'	O
)	O
{	O
char	O
*	O
msg	O
=	O
xasprintf	O
(	O
_	O
(	O
"header field '%s' missing in header\n"	*(char)
)	O
,	O
field	O
)	O
;	O
po_xerror	O
(	O
severity	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
if	O
(	O
severity	O
==	O
PO_SEVERITY_ERROR	O
)	O
seen_errors	O
++	O
;	O
}	O
}	O
return	O
seen_errors	O
;	O
}	O
int	O
check_message	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
lex_pos_ty	struct
*	O
msgid_pos	O
,	O
int	O
check_newlines	O
,	O
int	O
check_format_strings	O
,	O
const	O
struct	O
plural_distribution	O
*	O
distribution	O
,	O
int	O
check_header	O
,	O
int	O
check_compatibility	O
,	O
int	O
check_accelerators	O
,	O
char	O
accelerator_char	O
)	O
{	O
int	O
seen_errors	O
=	O
0	int
;	O
if	O
(	O
check_header	O
&&	O
is_header	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
)	O
seen_errors	O
+=	O
check_header_entry	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
)	O
;	O
seen_errors	O
+=	O
check_pair	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid	*(char)
,	O
msgid_pos	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr_len	long
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
is_format	enum(int,int,int,int,int,int)
,	O
check_newlines	O
,	O
check_format_strings	O
,	O
distribution	O
,	O
check_compatibility	O
,	O
check_accelerators	O
,	O
accelerator_char	O
)	O
;	O
return	O
seen_errors	O
;	O
}	O
int	O
check_message_list	O
(	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
int	O
ignore_untranslated_messages	O
,	O
int	O
ignore_fuzzy_messages	O
,	O
int	O
check_newlines	O
,	O
int	O
check_format_strings	O
,	O
int	O
check_header	O
,	O
int	O
check_compatibility	O
,	O
int	O
check_accelerators	O
,	O
char	O
accelerator_char	O
)	O
{	O
int	O
seen_errors	O
=	O
0	int
;	O
struct	O
plural_distribution	O
distribution	O
;	O
size_t	long
j	O
;	O
distribution	O
.	O
expr	O
=	O
NULL	O
;	O
distribution	O
.	O
often	O
=	O
NULL	O
;	O
distribution	O
.	O
often_length	O
=	O
0	int
;	O
distribution	O
.	O
histogram	O
=	O
NULL	O
;	O
if	O
(	O
check_header	O
)	O
seen_errors	O
+=	O
check_plural	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
ignore_untranslated_messages	O
,	O
ignore_fuzzy_messages	O
,	O
&	O
distribution	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
;	O
j	O
++	O
)	O
{	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
item	*(*(char))
[	O
j	O
]	O
;	O
if	O
(	O
!	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
obsolete	bool
&&	O
!	O
(	O
ignore_untranslated_messages	O
&&	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
&&	O
!	O
(	O
ignore_fuzzy_messages	O
&&	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
is_fuzzy	bool
&&	O
!	O
is_header	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
)	O
)	O
)	O
seen_errors	O
+=	O
check_message	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
&	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
pos	struct(*(char),long)
,	O
check_newlines	O
,	O
check_format_strings	O
,	O
&	O
distribution	O
,	O
check_header	O
,	O
check_compatibility	O
,	O
check_accelerators	O
,	O
accelerator_char	O
)	O
;	O
}	O
return	O
seen_errors	O
;	O
}	O
static	O
int	O
syntax_check_ellipsis_unicode	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
char	O
*	O
msgid	*(char)
)	O
{	O
const	O
char	O
*	O
str	O
=	O
msgid	*(char)
;	O
const	O
char	O
*	O
str_limit	O
=	O
str	O
+	O
strlen	(*(char))->(long)
(	O
msgid	*(char)
)	O
;	O
int	O
seen_errors	O
=	O
0	int
;	O
while	O
(	O
str	O
<	O
str_limit	O
)	O
{	O
const	O
char	O
*	O
end	O
,	O
*	O
cp	O
;	O
ucs4_t	O
ending_char	O
;	O
end	O
=	O
sentence_end	O
(	O
str	O
,	O
&	O
ending_char	O
)	O
;	O
cp	O
=	O
end	O
-	O
(	O
ending_char	O
==	O
'.'	O
?	O
2	int
:	O
3	int
)	O
;	O
if	O
(	O
cp	O
>=	O
str	O
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
cp	O
,	O
"..."	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
{	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
_	O
(	O
"ASCII ellipsis ('...') instead of Unicode"	*(char)
)	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
str	O
=	O
end	O
+	O
1	int
;	O
}	O
return	O
seen_errors	O
;	O
}	O
static	O
int	O
syntax_check_space_ellipsis	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
char	O
*	O
msgid	*(char)
)	O
{	O
const	O
char	O
*	O
str	O
=	O
msgid	*(char)
;	O
const	O
char	O
*	O
str_limit	O
=	O
str	O
+	O
strlen	(*(char))->(long)
(	O
msgid	*(char)
)	O
;	O
int	O
seen_errors	O
=	O
0	int
;	O
while	O
(	O
str	O
<	O
str_limit	O
)	O
{	O
const	O
char	O
*	O
end	O
,	O
*	O
ellipsis	O
=	O
NULL	O
;	O
ucs4_t	O
ending_char	O
;	O
end	O
=	O
sentence_end	O
(	O
str	O
,	O
&	O
ending_char	O
)	O
;	O
if	O
(	O
ending_char	O
==	O
0x2026	int
)	O
ellipsis	O
=	O
end	O
;	O
else	O
if	O
(	O
ending_char	O
==	O
'.'	O
)	O
{	O
const	O
char	O
*	O
cp	O
=	O
end	O
-	O
2	int
;	O
if	O
(	O
cp	O
>=	O
str	O
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
cp	O
,	O
"..."	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
ellipsis	O
=	O
cp	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
cp	O
=	O
end	O
-	O
3	int
;	O
if	O
(	O
cp	O
>=	O
str	O
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
cp	O
,	O
"..."	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
ellipsis	O
=	O
cp	O
;	O
else	O
{	O
ucs4_t	O
uc	O
=	O
0xfffd	int
;	O
for	O
(	O
cp	O
=	O
end	O
-	O
1	int
;	O
cp	O
>=	O
str	O
;	O
cp	O
--	O
)	O
{	O
u8_mbtouc	O
(	O
&	O
uc	O
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
cp	O
,	O
end	O
-	O
cp	O
)	O
;	O
if	O
(	O
uc	O
!=	O
0xfffd	int
)	O
break	O
;	O
}	O
if	O
(	O
uc	O
==	O
0x2026	int
)	O
ellipsis	O
=	O
cp	O
;	O
}	O
}	O
if	O
(	O
ellipsis	O
)	O
{	O
const	O
char	O
*	O
cp	O
;	O
ucs4_t	O
uc	O
=	O
0xfffd	int
;	O
for	O
(	O
cp	O
=	O
ellipsis	O
-	O
1	int
;	O
cp	O
>=	O
str	O
;	O
cp	O
--	O
)	O
{	O
u8_mbtouc	O
(	O
&	O
uc	O
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
cp	O
,	O
ellipsis	O
-	O
cp	O
)	O
;	O
if	O
(	O
uc	O
!=	O
0xfffd	int
)	O
break	O
;	O
}	O
if	O
(	O
uc	O
!=	O
0xfffd	int
&&	O
uc_is_space	O
(	O
uc	O
)	O
)	O
{	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
_	O
(	O
"space before ellipsis found in user visible strings"	*(char)
)	O
)	O
;	O
seen_errors	O
++	O
;	O
}	O
}	O
str	O
=	O
end	O
+	O
1	int
;	O
}	O
return	O
seen_errors	O
;	O
}	O
struct	O
callback_arg	O
{	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
int	O
seen_errors	O
;	O
}	O
;	O
static	O
void	O
syntax_check_quote_unicode_callback	O
(	O
char	O
quote	O
,	O
const	O
char	O
*	O
quoted	O
,	O
size_t	long
quoted_length	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
callback_arg	O
*	O
arg	O
=	O
data	*(void)
;	O
switch	O
(	O
quote	O
)	O
{	O
case	O
'"'	O
:	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
arg	O
->	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
_	O
(	O
"ASCII double quote used instead of Unicode"	*(char)
)	O
)	O
;	O
arg	O
->	O
seen_errors	O
++	O
;	O
break	O
;	O
case	O
'\''	O
:	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
arg	O
->	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
_	O
(	O
"ASCII single quote used instead of Unicode"	*(char)
)	O
)	O
;	O
arg	O
->	O
seen_errors	O
++	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
int	O
syntax_check_quote_unicode	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
char	O
*	O
msgid	*(char)
)	O
{	O
struct	O
callback_arg	O
arg	O
;	O
arg	O
.	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
;	O
arg	O
.	O
seen_errors	O
=	O
0	int
;	O
scan_quoted	O
(	O
msgid	*(char)
,	O
strlen	(*(char))->(long)
(	O
msgid	*(char)
)	O
,	O
syntax_check_quote_unicode_callback	O
,	O
&	O
arg	O
)	O
;	O
return	O
arg	O
.	O
seen_errors	O
;	O
}	O
struct	O
bullet_ty	O
{	O
int	O
c	O
;	O
size_t	long
depth	O
;	O
}	O
;	O
struct	O
bullet_stack_ty	O
{	O
struct	O
bullet_ty	O
*	O
items	O
;	O
size_t	long
nitems	long
;	O
size_t	long
nitems_max	long
;	O
}	O
;	O
static	O
struct	O
bullet_stack_ty	O
bullet_stack	O
;	O
static	O
int	O
syntax_check_bullet_unicode	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
char	O
*	O
msgid	*(char)
)	O
{	O
const	O
char	O
*	O
str	O
=	O
msgid	*(char)
;	O
const	O
char	O
*	O
str_limit	O
=	O
str	O
+	O
strlen	(*(char))->(long)
(	O
msgid	*(char)
)	O
;	O
struct	O
bullet_ty	O
*	O
last_bullet	O
=	O
NULL	O
;	O
bool	bool
seen_error	O
=	O
false	O
;	O
bullet_stack	O
.	O
nitems	long
=	O
0	int
;	O
while	O
(	O
str	O
<	O
str_limit	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
=	O
str	O
,	O
*	O
end	O
;	O
while	O
(	O
p	*(void)
<	O
str_limit	O
&&	O
c_isspace	O
(	O
*	O
p	*(void)
)	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
(	O
*	O
p	*(void)
==	O
'*'	O
||	O
*	O
p	*(void)
==	O
'-'	O
)	O
&&	O
*	O
(	O
p	*(void)
+	O
1	int
)	O
==	O
' '	O
)	O
{	O
size_t	long
depth	O
=	O
p	*(void)
-	O
str	O
;	O
if	O
(	O
last_bullet	O
==	O
NULL	O
||	O
depth	O
>	O
last_bullet	O
->	O
depth	O
)	O
{	O
struct	O
bullet_ty	O
bullet	O
;	O
bullet	O
.	O
c	O
=	O
*	O
p	*(void)
;	O
bullet	O
.	O
depth	O
=	O
depth	O
;	O
if	O
(	O
bullet_stack	O
.	O
nitems	long
>=	O
bullet_stack	O
.	O
nitems_max	long
)	O
{	O
bullet_stack	O
.	O
nitems_max	long
=	O
2	int
*	O
bullet_stack	O
.	O
nitems_max	long
+	O
4	int
;	O
bullet_stack	O
.	O
items	O
=	O
xrealloc	O
(	O
bullet_stack	O
.	O
items	O
,	O
bullet_stack	O
.	O
nitems_max	long
*	O
sizeof	O
(	O
struct	O
bullet_ty	O
)	O
)	O
;	O
}	O
last_bullet	O
=	O
&	O
bullet_stack	O
.	O
items	O
[	O
bullet_stack	O
.	O
nitems	long
++	O
]	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
last_bullet	O
,	O
&	O
bullet	O
,	O
sizeof	O
(	O
struct	O
bullet_ty	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
depth	O
<	O
last_bullet	O
->	O
depth	O
)	O
{	O
if	O
(	O
bullet_stack	O
.	O
nitems	long
>	O
1	int
)	O
{	O
bullet_stack	O
.	O
nitems	long
--	O
;	O
last_bullet	O
=	O
&	O
bullet_stack	O
.	O
items	O
[	O
bullet_stack	O
.	O
nitems	long
-	O
1	int
]	O
;	O
}	O
else	O
last_bullet	O
=	O
NULL	O
;	O
}	O
if	O
(	O
last_bullet	O
&&	O
depth	O
==	O
last_bullet	O
->	O
depth	O
)	O
{	O
if	O
(	O
last_bullet	O
->	O
c	O
!=	O
*	O
p	*(void)
)	O
last_bullet	O
->	O
c	O
=	O
*	O
p	*(void)
;	O
else	O
{	O
seen_error	O
=	O
true	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
bullet_stack	O
.	O
nitems	long
=	O
0	int
;	O
last_bullet	O
=	O
NULL	O
;	O
}	O
end	O
=	O
strchrnul	(*(char),int)->(*(char))
(	O
str	O
,	O
'\n'	O
)	O
;	O
str	O
=	O
end	O
+	O
1	int
;	O
}	O
if	O
(	O
seen_error	O
)	O
{	O
char	O
*	O
msg	O
;	O
msg	O
=	O
xasprintf	O
(	O
_	O
(	O
"ASCII bullet ('%c') instead of Unicode"	*(char)
)	O
,	O
last_bullet	O
->	O
c	O
)	O
;	O
po_xerror	O
(	O
PO_SEVERITY_ERROR	O
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	O
,	O
msg	O
)	O
;	O
free	O
(	O
msg	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
typedef	O
int	O
(	O
*	O
syntax_check_function	O
)	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
char	O
*	O
msgid	*(char)
)	O
;	O
static	O
const	O
syntax_check_function	O
sc_funcs	O
[	O
NSYNTAXCHECKS	int
]	O
=	O
{	O
syntax_check_ellipsis_unicode	O
,	O
syntax_check_space_ellipsis	O
,	O
syntax_check_quote_unicode	O
,	O
syntax_check_bullet_unicode	O
}	O
;	O
static	O
int	O
syntax_check_message	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
{	O
int	O
seen_errors	O
=	O
0	int
;	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
do_syntax_check	array(enum(int,int,int,int,int,int))
[	O
i	long
]	O
==	O
yes	int
)	O
{	O
seen_errors	O
+=	O
sc_funcs	O
[	O
i	long
]	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid	*(char)
)	O
;	O
if	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
)	O
seen_errors	O
+=	O
sc_funcs	O
[	O
i	long
]	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgid_plural	*(char)
)	O
;	O
}	O
}	O
return	O
seen_errors	O
;	O
}	O
int	O
syntax_check_message_list	O
(	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
)	O
{	O
int	O
seen_errors	O
=	O
0	int
;	O
size_t	long
j	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
nitems	long
;	O
j	O
++	O
)	O
{	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
=	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
->	O
item	*(*(char))
[	O
j	O
]	O
;	O
if	O
(	O
!	O
is_header	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
)	O
seen_errors	O
+=	O
syntax_check_message	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
;	O
}	O
return	O
seen_errors	O
;	O
}	O
