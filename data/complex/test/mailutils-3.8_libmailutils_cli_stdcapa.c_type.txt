static	O
void	O
cli_log_facility	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
mu_string_to_syslog_facility	(*(char),*(int))->(int)
(	O
arg	*(char)
,	O
&	O
mu_log_facility	int
)	O
)	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"unknown syslog facility `%s'"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
}	O
static	O
int	O
cb_facility	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_string_to_syslog_facility	(*(char),*(int))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
&	O
mu_log_facility	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unknown syslog facility `%s'"	*(char)
)	O
,	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_severity	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
unsigned	O
n	long
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_severity_from_string	(*(char),*(int))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
&	O
n	long
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unknown severity `%s'"	*(char)
)	O
,	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
mu_log_severity_threshold	int
=	O
n	long
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
logging_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"syslog"	*(char)
,	O
mu_c_bool	int
,	O
&	O
mu_log_syslog	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Send diagnostics to syslog."	*(char)
)	O
}	O
,	O
{	O
"print-severity"	*(char)
,	O
mu_c_bool	int
,	O
&	O
mu_log_print_severity	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Print message severity levels."	*(char)
)	O
}	O
,	O
{	O
"severity"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_severity	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Output only messages with a severity equal to or greater than "	*(char)
"this one."	*(char)
)	O
,	O
N_	O
(	O
"arg: debug|info|notice|warning|error|crit|alert|emerg"	*(char)
)	O
}	O
,	O
{	O
"facility"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_facility	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set syslog facility. Arg is one of the following: user, daemon, "	*(char)
"auth, authpriv, mail, cron, local0 through local7 (case-insensitive), "	*(char)
"or a facility number."	*(char)
)	O
,	O
N_	O
(	O
"arg: auth|authpriv|mail|local0-local7|<number>"	*(char)
)	O
}	O
,	O
{	O
"session-id"	*(char)
,	O
mu_c_bool	int
,	O
&	O
mu_log_session_id	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Log session ID"	*(char)
)	O
}	O
,	O
{	O
"tag"	*(char)
,	O
mu_c_string	int
,	O
&	O
mu_log_tag	*(char)
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Tag syslog messages with this string."	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
logging_option	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
{	O
"log-facility"	*(char)
,	O
0	int
,	O
N_	O
(	O
"FACILITY"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"output logs to syslog FACILITY"	*(char)
)	O
,	O
mu_c_int	int
,	O
&	O
mu_log_facility	int
,	O
cli_log_facility	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
MU_OPTION_END	O
}	O
;	O
static	O
void	O
logging_commit	(*(void))->(void)
(	O
void	O
*	O
unused	*(void)
)	O
{	O
if	O
(	O
mu_log_syslog	int
>=	O
0	int
)	O
mu_stdstream_strerr_setup	(int)->(int)
(	O
mu_log_syslog	int
?	O
MU_STRERR_SYSLOG	int
:	O
MU_STRERR_STDERR	int
)	O
;	O
}	O
static	O
void	O
cli_mailer	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
int	O
rc	int
=	O
mu_mailer_set_url_default	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
mu_parseopt_error	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(char))->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"invalid mailer URL `%s': %s"	*(char)
)	O
,	O
arg	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
static	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
mailer_option	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
{	O
"mailer"	*(char)
,	O
'M'	O
,	O
N_	O
(	O
"MAILER"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"use specified URL as the default mailer"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_mailer	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
MU_OPTION_END	O
}	O
;	O
static	O
int	O
cb_mailer	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_mailer_set_url_default	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s: invalid mailer URL: %s"	*(char)
)	O
,	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
mailer_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"url"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_mailer	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Use this URL as the default mailer"	*(char)
)	O
,	O
N_	O
(	O
"url: string"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
void	O
cli_debug_level	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
mu_debug_clear_all	()->(void)
(	O
)	O
;	O
mu_debug_parse_spec	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
}	O
static	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
debug_option	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
MU_OPTION_GROUP	O
(	O
N_	O
(	O
"Global debugging settings"	*(char)
)	O
)	O
,	O
{	O
"debug-level"	*(char)
,	O
0	int
,	O
N_	O
(	O
"LEVEL"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set Mailutils debugging level"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_debug_level	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"debug-line-info"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"show source info with debugging messages"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
mu_debug_line_info	int
}	O
,	O
MU_OPTION_END	O
}	O
;	O
static	O
int	O
cb_debug_level	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
mu_debug_parse_spec	(*(char))->(void)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
debug_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"level"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
&	O
cb_debug_level	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set Mailutils debugging level. Argument is a semicolon-separated list "	*(char)
"of debugging specifications. A simplified specification syntax is:\n"	*(char)
"   [!]<category: string>[.<level: string>,<level: string>...]\n"	*(char)
"For details, please see the section 3.3 \"Debugging\" of the GNU Mailutils\n"	*(char)
"manual, or visit <http://mailutils.org/wiki/Debug_level>."	*(char)
)	O
,	O
N_	O
(	O
"arg: string"	*(char)
)	O
}	O
,	O
{	O
"line-info"	*(char)
,	O
mu_c_bool	int
,	O
&	O
mu_debug_line_info	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Prefix debug messages with Mailutils source locations."	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
cb_mail_spool	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_set_mail_directory	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot set mail directory name to `%s': %s"	*(char)
)	O
,	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
cb_mailbox_pattern	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_set_mailbox_pattern	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot set mailbox pattern to `%s': %s"	*(char)
)	O
,	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
cb_mailbox_type	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_registrar_set_default_scheme	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid mailbox type: %s"	*(char)
)	O
,	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_folder	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
mu_set_folder_directory	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_autodetect_accuracy	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
v	*(struct(int))
;	O
char	O
*	O
errmsg	*(*(char))
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"auto"	*(char)
)	O
==	O
0	int
)	O
v	*(struct(int))
=	O
MU_AUTODETECT_ACCURACY_AUTO	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"fast"	*(char)
)	O
==	O
0	int
)	O
v	*(struct(int))
=	O
MU_AUTODETECT_ACCURACY_FAST	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"minimal"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"default"	*(char)
)	O
==	O
0	int
)	O
v	*(struct(int))
=	O
MU_AUTODETECT_ACCURACY_DEFAULT	int
;	O
else	O
{	O
int	O
rc	int
=	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_c_int	int
,	O
&	O
v	*(struct(int))
,	O
&	O
errmsg	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"conversion failed: %s"	*(char)
)	O
,	O
errmsg	*(*(char))
?	O
errmsg	*(*(char))
:	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
errmsg	*(*(char))
)	O
;	O
}	O
else	O
mu_set_autodetect_accuracy	(int)->(void)
(	O
v	*(struct(int))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
mailbox_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"mail-spool"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_mail_spool	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Use specified URL as a mailspool directory."	*(char)
)	O
,	O
N_	O
(	O
"url: string"	*(char)
)	O
}	O
,	O
{	O
"mailbox-pattern"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_mailbox_pattern	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Create mailbox URL using <pattern>."	*(char)
)	O
,	O
N_	O
(	O
"pattern: string"	*(char)
)	O
}	O
,	O
{	O
"mailbox-type"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_mailbox_type	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Default mailbox type."	*(char)
)	O
,	O
N_	O
(	O
"protocol: string"	*(char)
)	O
}	O
,	O
{	O
"folder"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_folder	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Default user mail folder"	*(char)
)	O
,	O
N_	O
(	O
"dir: string"	*(char)
)	O
}	O
,	O
{	O
"autodetect-accuracy"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_autodetect_accuracy	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Accuracy level of mailbox format autodetection. Argument is either a"	*(char)
" decimal number or any of the following constants:\n"	*(char)
"  auto    - set accuracy level from the environment variable\n"	*(char)
"            MU_AUTODETECT_ACCURACY (default)\n"	*(char)
"  fast    - do only a rough estimation of the mailbox format: fastest,\n"	*(char)
"            but possibly inaccurate\n"	*(char)
"  minimal - good balance between speed and accuracy"	*(char)
)	O
,	O
N_	O
(	O
"n: number"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
cb_locker_flags	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
flags	int
=	O
0	int
;	O
char	O
const	O
*	O
s	*(char)
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
s	*(char)
=	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
;	O
*	O
s	*(char)
;	O
s	*(char)
++	O
)	O
{	O
switch	O
(	O
*	O
s	*(char)
)	O
{	O
case	O
'E'	O
:	O
flags	int
|=	O
MU_LOCKER_EXTERNAL	O
;	O
break	O
;	O
case	O
'R'	O
:	O
flags	int
|=	O
MU_LOCKER_RETRY	int
;	O
break	O
;	O
case	O
'T'	O
:	O
flags	int
|=	O
MU_LOCKER_TIME	int
;	O
break	O
;	O
case	O
'P'	O
:	O
flags	int
|=	O
MU_LOCKER_PID	int
;	O
break	O
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid lock flag `%c'"	*(char)
)	O
,	O
*	O
s	*(char)
)	O
;	O
}	O
}	O
mu_locker_set_default_flags	(int,enum(int,int,int))->(int)
(	O
flags	int
,	O
mu_locker_assign	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_locker_retry_timeout	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
time_t	long
t	long
;	O
char	O
*	O
errmsg	*(*(char))
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_c_time	int
,	O
&	O
t	long
,	O
&	O
errmsg	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"conversion failed: %s"	*(char)
)	O
,	O
errmsg	*(*(char))
?	O
errmsg	*(*(char))
:	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
errmsg	*(*(char))
)	O
;	O
}	O
else	O
{	O
mu_locker_set_default_retry_timeout	(long)->(void)
(	O
t	long
)	O
;	O
mu_locker_set_default_flags	(int,enum(int,int,int))->(int)
(	O
MU_LOCKER_RETRY	int
,	O
mu_locker_set_bit	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_locker_retry_count	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
size_t	long
n	long
;	O
char	O
*	O
errmsg	*(*(char))
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_c_size	int
,	O
&	O
n	long
,	O
&	O
errmsg	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"conversion failed: %s"	*(char)
)	O
,	O
errmsg	*(*(char))
?	O
errmsg	*(*(char))
:	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
errmsg	*(*(char))
)	O
;	O
}	O
else	O
{	O
mu_locker_set_default_retry_count	(long)->(void)
(	O
n	long
)	O
;	O
mu_locker_set_default_flags	(int,enum(int,int,int))->(int)
(	O
MU_LOCKER_RETRY	int
,	O
mu_locker_set_bit	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_locker_expire_timeout	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
time_t	long
t	long
;	O
char	O
*	O
errmsg	*(*(char))
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_str_to_c	(*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*(*(char)))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_c_time	int
,	O
&	O
t	long
,	O
&	O
errmsg	*(*(char))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"conversion failed: %s"	*(char)
)	O
,	O
errmsg	*(*(char))
?	O
errmsg	*(*(char))
:	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
errmsg	*(*(char))
)	O
;	O
}	O
else	O
{	O
mu_locker_set_default_expire_timeout	(long)->(void)
(	O
t	long
)	O
;	O
mu_locker_set_default_flags	(int,enum(int,int,int))->(int)
(	O
MU_LOCKER_EXTERNAL	O
,	O
mu_locker_set_bit	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_locker_external	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
mu_locker_set_default_external_program	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
mu_locker_set_default_flags	(int,enum(int,int,int))->(int)
(	O
MU_LOCKER_TIME	int
,	O
mu_locker_set_bit	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
locking_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"flags"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_locker_flags	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Default locker flags (E=external, R=retry, T=time, P=pid)."	*(char)
)	O
,	O
N_	O
(	O
"arg: string"	*(char)
)	O
}	O
,	O
{	O
"retry-timeout"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_locker_retry_timeout	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set timeout for acquiring the lock."	*(char)
)	O
,	O
N_	O
(	O
"arg: interval"	*(char)
)	O
}	O
,	O
{	O
"retry-count"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_locker_retry_count	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set the maximum number of times to retry acquiring the lock."	*(char)
)	O
,	O
N_	O
(	O
"arg: integer"	*(char)
)	O
}	O
,	O
{	O
"expire-timeout"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_locker_expire_timeout	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Expire locks older than this amount of time."	*(char)
)	O
,	O
N_	O
(	O
"arg: interval"	*(char)
)	O
}	O
,	O
{	O
"external-locker"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_locker_external	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Use external locker program."	*(char)
)	O
,	O
N_	O
(	O
"prog: string"	*(char)
)	O
}	O
,	O
{	O
NULL	O
,	O
}	O
}	O
;	O
static	O
int	O
cb_email_addr	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_set_user_email	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid email address `%s': %s"	*(char)
)	O
,	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_email_domain	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
rc	int
=	O
mu_set_user_email_domain	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid email domain `%s': %s"	*(char)
)	O
,	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
address_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"email-addr"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_email_addr	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set the current user email address (default is "	*(char)
"loginname@defaultdomain)."	*(char)
)	O
,	O
N_	O
(	O
"email: address"	*(char)
)	O
}	O
,	O
{	O
"email-domain"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_email_domain	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set e-mail domain for unqualified user names (default is this host)"	*(char)
)	O
,	O
N_	O
(	O
"domain: string"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
cb_authentication	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
val	array(int)
->	O
type	*(char)
==	O
MU_CFG_STRING	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"clear"	*(char)
)	O
==	O
0	int
)	O
mu_authentication_clear_list	()->(void)
(	O
)	O
;	O
else	O
mu_authentication_add_module_list	(*(char))->(void)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
val	array(int)
->	O
type	*(char)
==	O
MU_CFG_LIST	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
c	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	int
]	O
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	int
]	O
.	O
v	*(struct(int))
.	O
string	*(char)
,	O
"clear"	*(char)
)	O
==	O
0	int
)	O
mu_authentication_clear_list	()->(void)
(	O
)	O
;	O
else	O
mu_authentication_add_module	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	int
]	O
.	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"expected string value"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_authorization	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
if	O
(	O
val	array(int)
->	O
type	*(char)
==	O
MU_CFG_STRING	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
,	O
"clear"	*(char)
)	O
==	O
0	int
)	O
mu_authorization_clear_list	()->(void)
(	O
)	O
;	O
else	O
mu_authorization_add_module_list	(*(char))->(void)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
val	array(int)
->	O
type	*(char)
==	O
MU_CFG_LIST	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
c	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	int
]	O
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	int
]	O
.	O
v	*(struct(int))
.	O
string	*(char)
,	O
"clear"	*(char)
)	O
==	O
0	int
)	O
mu_authorization_clear_list	()->(void)
(	O
)	O
;	O
else	O
mu_authorization_add_module	(*(char))->(int)
(	O
val	array(int)
->	O
v	*(struct(int))
.	O
arg	*(char)
.	O
v	*(struct(int))
[	O
i	int
]	O
.	O
v	*(struct(int))
.	O
string	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"expected string value"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
mu_auth_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"authentication"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_authentication	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set a list of modules for authentication. Modlist is a "	*(char)
"colon-separated list of module names or a word `clear' to "	*(char)
"clear the previously set up values."	*(char)
)	O
,	O
N_	O
(	O
"modlist"	*(char)
)	O
}	O
,	O
{	O
"authorization"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_authorization	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Set a list of modules for authorization. Modlist is a "	*(char)
"colon-separated list of module names or a word `clear' to "	*(char)
"clear the previously set up values."	*(char)
)	O
,	O
N_	O
(	O
"modlist"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
mu_auth_section_parser	(enum(int,int),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(char),*(*(void)),*(void),*(struct(*(struct),*(struct))))->(int)
(	O
enum	O
mu_cfg_section_stage	enum(int,int)
stage	enum(int,int)
,	O
const	O
mu_cfg_node_t	struct
*	O
node	*(struct(struct(struct(*(char),int,int),struct(*(char),int,int)),enum(int,int,int),*(char),*(struct(int,union(*`,*`,struct`))),*(struct),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`)))))
,	O
const	O
char	O
*	O
section_label	*(char)
,	O
void	O
*	O
*	O
section_data	*(*(void))
,	O
void	O
*	O
call_data	*(void)
,	O
mu_cfg_tree_t	struct
*	O
tree	*(struct(*(struct),*(struct)))
)	O
{	O
switch	O
(	O
stage	enum(int,int)
)	O
{	O
case	O
mu_cfg_section_start	int
:	O
break	O
;	O
case	O
mu_cfg_section_end	int
:	O
mu_auth_finish_setup	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
mu_cli_capa	struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct(struct`,struct`),enum(int,int,int),*(char),*(struct`),*(struct`),*(struct`))),*(char),*(*(void)),*(void),*(struct(*(struct`),*(struct`))))->(int)),*((*(void))->(void)))
mu_cli_std_capa	array(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void))))
[	O
]	O
=	O
{	O
{	O
"mailutils"	*(char)
}	O
,	O
{	O
"logging"	*(char)
,	O
logging_option	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
,	O
logging_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
NULL	O
,	O
logging_commit	(*(void))->(void)
}	O
,	O
{	O
"mailer"	*(char)
,	O
mailer_option	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
,	O
mailer_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"debug"	*(char)
,	O
debug_option	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
,	O
debug_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"mailbox"	*(char)
,	O
NULL	O
,	O
mailbox_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"locking"	*(char)
,	O
NULL	O
,	O
locking_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"address"	*(char)
,	O
NULL	O
,	O
address_cfg	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"auth"	*(char)
,	O
NULL	O
,	O
mu_auth_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
mu_auth_section_parser	(enum(int,int),*(struct(struct(struct(*`,int,int),struct(*`,int,int)),enum(int,int,int),*(char),*(struct(int,union`)),*(struct),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)))),*(char),*(*(void)),*(void),*(struct(*(struct),*(struct))))->(int)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
mu_cli_capa_init	()->(void)
(	O
void	O
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
mu_cli_std_capa	array(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void))))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
mu_cli_capa_register	(*(struct(*(char),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
mu_cli_std_capa	array(struct(*(char),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void))))
[	O
i	int
]	O
)	O
;	O
}	O
