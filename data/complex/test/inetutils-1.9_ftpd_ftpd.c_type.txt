struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
data_dest	struct(short,short,struct(int),array(char))
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
his_addr	struct(short,short,struct(int),array(char))
;	O
int	O
logging	int
;	O
int	O
type	enum(int,int,int,int)
=	O
TYPE_A	int
;	O
int	O
form	int
=	O
FORM_N	int
;	O
int	O
debug	int
;	O
int	O
timeout	int
=	O
900	int
;	O
int	O
maxtimeout	int
=	O
7200	int
;	O
int	O
pdata	int
=	O
-	O
1	int
;	O
char	O
*	O
hostname	*(char)
;	O
int	O
usedefault	int
=	O
1	int
;	O
char	O
tmpline	array(char)
[	O
7	int
]	O
;	O
struct	O
credentials	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
;	O
static	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
ctrl_addr	struct(short,short,struct(int),array(char))
;	O
static	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
data_source	struct(short,short,struct(int),array(char))
;	O
static	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
pasv_addr	struct(short,short,struct(int),array(char))
;	O
static	O
int	O
data	array(int)
=	O
-	O
1	int
;	O
static	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
urgcatch	array(struct(array(long),int,struct(array(long))))
;	O
static	O
int	O
stru	int
=	O
STRU_F	int
;	O
static	O
int	O
stru_mode	int
=	O
MODE_S	int
;	O
static	O
int	O
anon_only	int
;	O
static	O
int	O
no_version	int
;	O
static	O
int	O
daemon_mode	int
;	O
static	O
off_t	long
file_size	long
;	O
static	O
off_t	long
byte_count	long
;	O
static	O
sig_atomic_t	int
transflag	int
;	O
static	O
const	O
char	O
*	O
pid_file	*(char)
=	O
PATH_FTPDPID	O
;	O
static	O
int	O
defumask	int
=	O
CMASK	int
;	O
static	O
int	O
login_attempts	int
;	O
static	O
int	O
askpasswd	int
;	O
static	O
char	O
curname	array(char)
[	O
10	int
]	O
;	O
static	O
char	O
ttyline	array(char)
[	O
20	int
]	O
;	O
static	O
char	O
*	O
off_to_str	(long)->(*(char))
(	O
off_t	long
off	long
)	O
{	O
static	O
char	O
bufs	array(array(char))
[	O
NUM_SIMUL_OFF_TO_STRS	int
]	O
[	O
80	int
]	O
;	O
static	O
char	O
(	O
*	O
next_buf	*(array(char))
)	O
[	O
80	int
]	O
=	O
bufs	array(array(char))
;	O
if	O
(	O
next_buf	*(array(char))
>=	O
(	O
bufs	array(array(char))
+	O
NUM_SIMUL_OFF_TO_STRS	int
)	O
)	O
next_buf	*(array(char))
=	O
bufs	array(array(char))
;	O
if	O
(	O
sizeof	O
(	O
off	long
)	O
>	O
sizeof	O
(	O
long	O
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
*	O
next_buf	*(array(char))
,	O
"%lld"	*(char)
,	O
(	O
long	O
long	O
int	O
)	O
off	long
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
off	long
)	O
==	O
sizeof	O
(	O
long	O
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
*	O
next_buf	*(array(char))
,	O
"%ld"	*(char)
,	O
off	long
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
*	O
next_buf	*(array(char))
,	O
"%d"	*(char)
,	O
(	O
int	O
)	O
off	long
)	O
;	O
return	O
*	O
next_buf	*(array(char))
++	O
;	O
}	O
static	O
int	O
swaitmax	int
=	O
SWAITMAX	int
;	O
static	O
int	O
swaitint	int
=	O
SWAITINT	int
;	O
extern	O
int	O
yyparse	()->(int)
(	O
void	O
)	O
;	O
static	O
void	O
ack	(*(char))->(void)
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
complete_login	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
struct	O
credentials	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
*	O
)	O
;	O
static	O
char	O
*	O
curdir	()->(*(char))
(	O
void	O
)	O
;	O
static	O
FILE	struct
*	O
dataconn	(*(char),long,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
,	O
off_t	long
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
dolog	(*(struct(short,short,struct(int),array(char))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
,	O
struct	O
credentials	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
*	O
)	O
;	O
static	O
void	O
end_login	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
struct	O
credentials	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
*	O
)	O
;	O
static	O
FILE	struct
*	O
getdatasock	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
)	O
;	O
static	O
char	O
*	O
gunique	(*(char))->(*(char))
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
lostconn	(int)->(void)
(	O
int	O
)	O
;	O
static	O
void	O
myoob	(int)->(void)
(	O
int	O
)	O
;	O
static	O
int	O
receive_data	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
FILE	struct
*	O
,	O
FILE	struct
*	O
)	O
;	O
static	O
void	O
send_data	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long)->(void)
(	O
FILE	struct
*	O
,	O
FILE	struct
*	O
,	O
off_t	long
)	O
;	O
static	O
void	O
sigquit	(int)->(void)
(	O
int	O
)	O
;	O
const	O
char	O
doc	*(char)
[	O
]	O
=	O
"File Transfer Protocol Daemon"	*(char)
;	O
static	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
options	*(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"anonymous-only"	*(char)
,	O
'A'	O
,	O
NULL	O
,	O
0	int
,	O
"server configured for anonymous service only"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"daemon"	*(char)
,	O
'D'	O
,	O
NULL	O
,	O
0	int
,	O
"start the ftpd standalone"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"debug"	*(char)
,	O
'd'	O
,	O
NULL	O
,	O
0	int
,	O
"debug mode"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"logging"	*(char)
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
"increase verbosity of syslog messages"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"pidfile"	*(char)
,	O
'p'	O
,	O
"PIDFILE"	*(char)
,	O
OPTION_ARG_OPTIONAL	int
,	O
"change default location of pidfile"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"no-version"	*(char)
,	O
'q'	O
,	O
NULL	O
,	O
0	int
,	O
"do not display version in banner"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"timeout"	*(char)
,	O
't'	O
,	O
"TIMEOUT"	*(char)
,	O
0	int
,	O
"set default idle timeout"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"max-timeout"	*(char)
,	O
'T'	O
,	O
NULL	O
,	O
0	int
,	O
"reset maximum value of timeout allowed"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"umask"	*(char)
,	O
'u'	O
,	O
"VAL"	*(char)
,	O
0	int
,	O
"set default umask"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"auth"	*(char)
,	O
'a'	O
,	O
"AUTH"	*(char)
,	O
OPTION_ARG_OPTIONAL	int
,	O
"use AUTH for authentication"	*(char)
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
"AUTH can be one of the following:"	*(char)
,	O
GRID	int
+	O
2	int
}	O
,	O
{	O
"  default"	*(char)
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
"passwd authentication"	*(char)
,	O
GRID	int
+	O
3	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'A'	O
:	O
anon_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
arg	*(char)
,	O
"default"	*(char)
)	O
==	O
0	int
)	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
auth_type	int
=	O
AUTH_TYPE_PASSWD	int
;	O
break	O
;	O
case	O
'D'	O
:	O
daemon_mode	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
debug	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
logging	int
++	O
;	O
break	O
;	O
case	O
'p'	O
:	O
pid_file	*(char)
=	O
arg	*(char)
;	O
break	O
;	O
case	O
'q'	O
:	O
no_version	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
timeout	int
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
if	O
(	O
maxtimeout	int
<	O
timeout	int
)	O
maxtimeout	int
=	O
timeout	int
;	O
break	O
;	O
case	O
'T'	O
:	O
maxtimeout	int
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
if	O
(	O
timeout	int
>	O
maxtimeout	int
)	O
timeout	int
=	O
maxtimeout	int
;	O
break	O
;	O
case	O
'u'	O
:	O
{	O
long	O
val	array(int)
=	O
0	int
;	O
val	array(int)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
arg	*(char)
,	O
&	O
arg	*(char)
,	O
8	int
)	O
;	O
if	O
(	O
*	O
arg	*(char)
!=	O
'\0'	O
||	O
val	array(int)
<	O
0	int
)	O
argp_error	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(char))->(void)
(	O
state	*(int)
,	O
"bad value for -u"	*(char)
)	O
;	O
else	O
defumask	int
=	O
val	array(int)
;	O
break	O
;	O
}	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
options	*(struct(*(char),int,*(char),int,*(char),int))
,	O
parse_opt	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
NULL	O
,	O
doc	*(char)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
main	(int,array(*(char)),*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
,	O
char	O
*	O
*	O
envp	*(*(char))
)	O
{	O
int	O
index	(*(char),int)->(*(char))
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
tzset	()->(void)
(	O
)	O
;	O
iu_argp_init	O
(	O
"ftpd"	*(char)
,	O
default_program_authors	array(*(char))
)	O
;	O
argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
&	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
&	O
index	(*(char),int)->(*(char))
,	O
NULL	O
)	O
;	O
if	O
(	O
argc	int
-	O
index	(*(char),int)->(*(char))
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"surplus arguments; try `%s --help' for more info"	*(char)
,	O
program_name	*(char)
)	O
;	O
openlog	(*(char),int,int)->(void)
(	O
"ftpd"	*(char)
,	O
LOG_PID	int
|	O
LOG_NDELAY	int
,	O
LOG_FTP	O
)	O
;	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
PATH_DEVNULL	O
,	O
"w"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
daemon_mode	int
)	O
{	O
if	O
(	O
server_mode	(*(char),*(struct(short,short,struct(int),array(char))),array(*(char)))->(int)
(	O
pid_file	*(char)
,	O
&	O
his_addr	struct(short,short,struct(int),array(char))
,	O
argv	*(*(char))
)	O
<	O
0	int
)	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
socklen_t	int
addrlen	int
=	O
sizeof	O
(	O
his_addr	struct(short,short,struct(int),array(char))
)	O
;	O
if	O
(	O
getpeername	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
STDIN_FILENO	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
his_addr	struct(short,short,struct(int),array(char))
,	O
&	O
addrlen	int
)	O
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"getpeername (%s): %m"	*(char)
,	O
program_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGHUP	int
,	O
sigquit	(int)->(void)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
sigquit	(int)->(void)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGQUIT	int
,	O
sigquit	(int)->(void)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
sigquit	(int)->(void)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
lostconn	(int)->(void)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGURG	int
,	O
myoob	(int)->(void)
)	O
==	O
SIG_ERR	O
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"signal: %m"	*(char)
)	O
;	O
{	O
socklen_t	int
addrlen	int
=	O
sizeof	O
(	O
ctrl_addr	struct(short,short,struct(int),array(char))
)	O
;	O
if	O
(	O
getsockname	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
STDIN_FILENO	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
ctrl_addr	struct(short,short,struct(int),array(char))
,	O
&	O
addrlen	int
)	O
<	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"getsockname (%s): %m"	*(char)
,	O
program_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
{	O
int	O
tos	char
=	O
IPTOS_LOWDELAY	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
STDIN_FILENO	int
,	O
IPPROTO_IP	int
,	O
IP_TOS	int
,	O
(	O
char	O
*	O
)	O
&	O
tos	char
,	O
sizeof	O
(	O
int	O
)	O
)	O
<	O
0	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_WARNING	int
,	O
"setsockopt (IP_TOS): %m"	*(char)
)	O
;	O
}	O
{	O
int	O
on	int
=	O
1	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
STDIN_FILENO	int
,	O
SOL_SOCKET	int
,	O
SO_OOBINLINE	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
,	O
sizeof	O
(	O
on	int
)	O
)	O
<	O
0	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"setsockopt: %m"	*(char)
)	O
;	O
}	O
{	O
int	O
keepalive	int
=	O
1	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
STDIN_FILENO	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
char	O
*	O
)	O
&	O
keepalive	int
,	O
sizeof	O
(	O
keepalive	int
)	O
)	O
<	O
0	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_WARNING	int
,	O
"setsockopt (SO_KEEPALIVE): %m"	*(char)
)	O
;	O
}	O
if	O
(	O
fcntl	(int,int)->(int)
(	O
STDIN_FILENO	int
,	O
F_SETOWN	O
,	O
getpid	()->(int)
(	O
)	O
)	O
==	O
-	O
1	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"fcntl F_SETOWN: %m"	*(char)
)	O
;	O
dolog	(*(struct(short,short,struct(int),array(char))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
&	O
his_addr	struct(short,short,struct(int),array(char))
,	O
&	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
)	O
;	O
if	O
(	O
display_file	(*(char),int)->(int)
(	O
PATH_NOLOGIN	O
,	O
530	int
)	O
==	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"System not available."	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
display_file	(*(char),int)->(int)
(	O
PATH_FTPWELCOME	O
,	O
220	int
)	O
;	O
hostname	*(char)
=	O
localhost	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
hostname	*(char)
)	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
"Local resource failure: malloc"	*(char)
)	O
;	O
if	O
(	O
!	O
no_version	int
)	O
reply	(int,*(char))->(void)
(	O
220	int
,	O
"%s FTP server (%s %s) ready."	*(char)
,	O
hostname	*(char)
,	O
PACKAGE_NAME	*(char)
,	O
PACKAGE_VERSION	*(char)
)	O
;	O
else	O
reply	(int,*(char))->(void)
(	O
220	int
,	O
"%s FTP server ready."	*(char)
,	O
hostname	*(char)
)	O
;	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
errcatch	array(struct(array(long),int,struct(array(long))))
)	O
;	O
for	O
(	O
;	O
;	O
)	O
yyparse	()->(int)
(	O
)	O
;	O
}	O
static	O
char	O
*	O
curdir	()->(*(char))
(	O
void	O
)	O
{	O
static	O
char	O
*	O
path	*(char)
=	O
0	int
;	O
extern	O
char	O
*	O
xgetcwd	()->(*(char))
(	O
void	O
)	O
;	O
free	(*(void))->(void)
(	O
path	*(char)
)	O
;	O
path	*(char)
=	O
xgetcwd	()->(*(char))
(	O
)	O
;	O
if	O
(	O
!	O
path	*(char)
)	O
return	O
(	O
char	O
*	O
)	O
""	*(char)
;	O
if	O
(	O
path	*(char)
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
char	O
*	O
tmp	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
path	*(char)
,	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
+	O
2	int
)	O
;	O
if	O
(	O
!	O
tmp	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
path	*(char)
)	O
;	O
return	O
(	O
char	O
*	O
)	O
""	*(char)
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
tmp	*(char)
,	O
"/"	*(char)
)	O
;	O
path	*(char)
=	O
tmp	*(char)
;	O
}	O
return	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
guest	int
?	O
path	*(char)
+	O
1	int
:	O
path	*(char)
)	O
;	O
}	O
static	O
void	O
sigquit	(int)->(void)
(	O
int	O
signo	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_ERR	int
,	O
"got signal %s"	*(char)
,	O
strsignal	(int)->(*(char))
(	O
signo	int
)	O
)	O
;	O
dologout	(int)->(void)
(	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
lostconn	(int)->(void)
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
if	O
(	O
debug	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_DEBUG	int
,	O
"lost connection"	*(char)
)	O
;	O
dologout	(int)->(void)
(	O
-	O
1	int
)	O
;	O
}	O
char	O
*	O
sgetsave	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
string	*(char)
;	O
size_t	long
len	char
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
s	*(char)
=	O
""	*(char)
;	O
len	char
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
1	int
;	O
string	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	char
)	O
;	O
if	O
(	O
string	*(char)
==	O
NULL	O
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
421	int
,	O
"Local resource failure: malloc"	*(char)
)	O
;	O
dologout	(int)->(void)
(	O
1	int
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
string	*(char)
,	O
s	*(char)
,	O
len	char
)	O
;	O
return	O
string	*(char)
;	O
}	O
static	O
void	O
complete_login	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
struct	O
credentials	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
*	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
)	O
{	O
if	O
(	O
setegid	(int)->(int)
(	O
(	O
gid_t	int
)	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
gid	int
)	O
<	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"Can't set gid."	*(char)
)	O
;	O
return	O
;	O
}	O
initgroups	(*(char),int)->(int)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
name	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
gid	int
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
ttyline	array(char)
,	O
sizeof	O
(	O
ttyline	array(char)
)	O
,	O
"ftp%d"	*(char)
,	O
getpid	()->(int)
(	O
)	O
)	O
;	O
logwtmp_keep_open	(*(char),*(char),*(char))->(void)
(	O
ttyline	array(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
name	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
remotehost	*(char)
)	O
;	O
if	O
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
guest	int
)	O
{	O
if	O
(	O
chroot	(*(char))->(int)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
rootdir	*(char)
)	O
<	O
0	int
||	O
chdir	(*(char))->(int)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
homedir	*(char)
)	O
<	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"Can't set guest privileges."	*(char)
)	O
;	O
goto	O
bad	O
;	O
}	O
}	O
else	O
if	O
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
dochroot	int
)	O
{	O
if	O
(	O
chroot	(*(char))->(int)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
rootdir	*(char)
)	O
<	O
0	int
||	O
chdir	(*(char))->(int)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
homedir	*(char)
)	O
<	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"Can't change root."	*(char)
)	O
;	O
goto	O
bad	O
;	O
}	O
setenv	(*(char),*(char),int)->(int)
(	O
"HOME"	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
homedir	*(char)
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
chdir	(*(char))->(int)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
rootdir	*(char)
)	O
<	O
0	int
)	O
{	O
if	O
(	O
chdir	(*(char))->(int)
(	O
"/"	*(char)
)	O
<	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"User %s: can't change directory to %s."	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
name	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
homedir	*(char)
)	O
;	O
goto	O
bad	O
;	O
}	O
else	O
lreply	(int,*(char))->(void)
(	O
230	int
,	O
"No directory! Logging in with home=/"	*(char)
)	O
;	O
}	O
if	O
(	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
uid	int
)	O
<	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"Can't set uid."	*(char)
)	O
;	O
goto	O
bad	O
;	O
}	O
display_file	(*(char),int)->(int)
(	O
PATH_FTPLOGINMESG	O
,	O
230	int
)	O
;	O
if	O
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
guest	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
230	int
,	O
"Guest login ok, access restrictions apply."	*(char)
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"ANONYMOUS FTP LOGIN FROM %s"	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
remotehost	*(char)
)	O
;	O
}	O
else	O
{	O
reply	(int,*(char))->(void)
(	O
230	int
,	O
"User %s logged in."	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
name	*(char)
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"FTP LOGIN FROM %s as %s"	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
remotehost	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
name	*(char)
)	O
;	O
}	O
umask	(int)->(int)
(	O
defumask	int
)	O
;	O
return	O
;	O
bad	O
:	O
end_login	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
)	O
;	O
}	O
void	O
user	*(char)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
logged_in	int
)	O
{	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
guest	int
||	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
dochroot	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"Can't change user from guest login."	*(char)
)	O
;	O
return	O
;	O
}	O
end_login	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
&	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
)	O
;	O
}	O
if	O
(	O
auth_user	(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(int)
(	O
name	*(char)
,	O
&	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
{	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"%s"	*(char)
,	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
;	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
=	O
NULL	O
;	O
}	O
else	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"User %s access denied."	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_NOTICE	int
,	O
"FTP LOGIN REFUSED FROM %s, %s"	*(char)
,	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
remotehost	*(char)
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
anon_only	int
&&	O
!	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
guest	int
&&	O
!	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
dochroot	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"Sorry, only anonymous ftp allowed"	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
logging	int
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
curname	array(char)
,	O
name	*(char)
,	O
sizeof	O
(	O
curname	array(char)
)	O
-	O
1	int
)	O
;	O
curname	array(char)
[	O
sizeof	O
(	O
curname	array(char)
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
{	O
reply	(int,*(char))->(void)
(	O
331	int
,	O
"%s"	*(char)
,	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
;	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
=	O
NULL	O
;	O
}	O
else	O
reply	(int,*(char))->(void)
(	O
331	int
,	O
"Password required for %s."	*(char)
,	O
name	*(char)
)	O
;	O
askpasswd	int
=	O
1	int
;	O
if	O
(	O
login_attempts	int
)	O
sleep	(int)->(int)
(	O
(	O
unsigned	O
)	O
login_attempts	int
)	O
;	O
}	O
static	O
void	O
end_login	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
struct	O
credentials	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
*	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
)	O
{	O
char	O
*	O
remotehost	*(char)
=	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
remotehost	*(char)
;	O
int	O
atype	int
=	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
auth_type	int
;	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
0	int
)	O
;	O
if	O
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
logged_in	int
)	O
logwtmp_keep_open	(*(char),*(char),*(char))->(void)
(	O
ttyline	array(char)
,	O
""	*(char)
,	O
""	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
name	*(char)
)	O
;	O
if	O
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
passwd	*(char)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
passwd	*(char)
,	O
0	int
,	O
strlen	(*(char))->(long)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
passwd	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
passwd	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
homedir	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
rootdir	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
shell	*(char)
)	O
;	O
if	O
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
pass	(*(char))->(void)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
pass	(*(char))->(void)
,	O
0	int
,	O
strlen	(*(char))->(long)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
pass	(*(char))->(void)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
pass	(*(char))->(void)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
message	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
,	O
0	int
,	O
sizeof	O
(	O
*	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
)	O
)	O
;	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
remotehost	*(char)
=	O
remotehost	*(char)
;	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
auth_type	int
=	O
atype	int
;	O
}	O
void	O
pass	(*(char))->(void)
(	O
const	O
char	O
*	O
passwd	*(char)
)	O
{	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
logged_in	int
||	O
askpasswd	int
==	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
503	int
,	O
"Login with USER first."	*(char)
)	O
;	O
return	O
;	O
}	O
askpasswd	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
guest	int
)	O
{	O
if	O
(	O
auth_pass	(*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(int)
(	O
passwd	*(char)
,	O
&	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
{	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"%s"	*(char)
,	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
)	O
;	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
message	*(char)
=	O
NULL	O
;	O
}	O
else	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"Login incorrect."	*(char)
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_NOTICE	int
,	O
"FTP LOGIN FAILED FROM %s, %s"	*(char)
,	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
remotehost	*(char)
,	O
curname	array(char)
)	O
;	O
if	O
(	O
login_attempts	int
++	O
>=	O
5	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_NOTICE	int
,	O
"repeated login failures from %s"	*(char)
,	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
remotehost	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
return	O
;	O
}	O
}	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
logged_in	int
=	O
1	int
;	O
complete_login	(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
&	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
)	O
;	O
login_attempts	int
=	O
0	int
;	O
}	O
void	O
retrieve	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
cmd	*(char)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
FILE	struct
*	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
(	O
*	O
closefunc	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(int))
)	O
(	O
FILE	struct
*	O
)	O
;	O
size_t	long
buffer_size	long
=	O
0	int
;	O
if	O
(	O
cmd	*(char)
==	O
0	int
)	O
{	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
"r"	*(char)
)	O
,	O
closefunc	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(int))
=	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
;	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
=	O
0	int
;	O
}	O
else	O
{	O
char	O
line	*(char)
[	O
BUFSIZ	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
line	*(char)
,	O
sizeof	O
line	*(char)
,	O
cmd	*(char)
,	O
name	*(char)
)	O
;	O
name	*(char)
=	O
line	*(char)
;	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
ftpd_popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
line	*(char)
,	O
"r"	*(char)
)	O
,	O
closefunc	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(int))
=	O
ftpd_pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
;	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
=	O
-	O
1	int
;	O
buffer_size	long
=	O
BUFSIZ	int
;	O
}	O
if	O
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
!=	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
if	O
(	O
cmd	*(char)
==	O
0	int
)	O
{	O
LOGCMD	O
(	O
"get"	*(char)
,	O
name	*(char)
)	O
;	O
}	O
}	O
return	O
;	O
}	O
byte_count	long
=	O
-	O
1	int
;	O
if	O
(	O
cmd	*(char)
==	O
0	int
&&	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
||	O
!	O
S_ISREG	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"%s: not a plain file."	*(char)
,	O
name	*(char)
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
restart_point	long
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
TYPE_A	int
)	O
{	O
off_t	long
i	long
,	O
n	long
;	O
int	O
c	int
;	O
n	long
=	O
restart_point	long
;	O
i	long
=	O
0	int
;	O
while	O
(	O
i	long
++	O
<	O
n	long
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
i	long
++	O
;	O
}	O
}	O
else	O
if	O
(	O
lseek	(int,long,int)->(long)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
restart_point	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
dataconn	(*(char),long,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
goto	O
done	O
;	O
send_data	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long)->(void)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
buffer_size	long
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
data	array(int)
=	O
-	O
1	int
;	O
pdata	int
=	O
-	O
1	int
;	O
done	O
:	O
if	O
(	O
cmd	*(char)
==	O
0	int
)	O
LOGBYTES	O
(	O
"get"	*(char)
,	O
name	*(char)
,	O
byte_count	long
)	O
;	O
(	O
*	O
closefunc	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(int))
)	O
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
store	(*(char),*(char),int)->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
mode	*(char)
,	O
int	O
unique	int
)	O
{	O
FILE	struct
*	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
din	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
(	O
*	O
closefunc	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(int))
)	O
(	O
FILE	struct
*	O
)	O
;	O
if	O
(	O
unique	int
&&	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
name_unique	*(char)
=	O
gunique	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
name_unique	*(char)
)	O
name	*(char)
=	O
name_unique	*(char)
;	O
else	O
{	O
LOGCMD	O
(	O
*	O
mode	*(char)
==	O
'w'	O
?	O
"put"	*(char)
:	O
"append"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
restart_point	long
)	O
mode	*(char)
=	O
"r+"	*(char)
;	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
mode	*(char)
)	O
;	O
closefunc	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(int))
=	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
;	O
if	O
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
553	int
,	O
name	*(char)
)	O
;	O
LOGCMD	O
(	O
*	O
mode	*(char)
==	O
'w'	O
?	O
"put"	*(char)
:	O
"append"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
byte_count	long
=	O
-	O
1	int
;	O
if	O
(	O
restart_point	long
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
TYPE_A	int
)	O
{	O
off_t	long
i	long
,	O
n	long
;	O
int	O
c	int
;	O
n	long
=	O
restart_point	long
;	O
i	long
=	O
0	int
;	O
while	O
(	O
i	long
++	O
<	O
n	long
)	O
{	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
i	long
++	O
;	O
}	O
if	O
(	O
fseeko	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0L	int
,	O
SEEK_CUR	int
)	O
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
else	O
if	O
(	O
lseek	(int,long,int)->(long)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
restart_point	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
din	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
dataconn	(*(char),long,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
(	O
off_t	long
)	O
-	O
1	int
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
din	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
receive_data	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
din	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
0	int
)	O
{	O
if	O
(	O
unique	int
)	O
reply	(int,*(char))->(void)
(	O
226	int
,	O
"Transfer complete (unique file name:%s)."	*(char)
,	O
name	*(char)
)	O
;	O
else	O
reply	(int,*(char))->(void)
(	O
226	int
,	O
"Transfer complete."	*(char)
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
din	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
data	array(int)
=	O
-	O
1	int
;	O
pdata	int
=	O
-	O
1	int
;	O
done	O
:	O
LOGBYTES	O
(	O
*	O
mode	*(char)
==	O
'w'	O
?	O
"put"	*(char)
:	O
"append"	*(char)
,	O
name	*(char)
,	O
byte_count	long
)	O
;	O
(	O
*	O
closefunc	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))))->(int))
)	O
(	O
fout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
FILE	struct
*	O
getdatasock	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
mode	*(char)
)	O
{	O
int	O
s	*(char)
,	O
t	int
,	O
tries	int
;	O
if	O
(	O
data	array(int)
>=	O
0	int
)	O
return	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
data	array(int)
,	O
mode	*(char)
)	O
;	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
0	int
)	O
;	O
s	*(char)
=	O
socket	(int,int,int)->(int)
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
s	*(char)
<	O
0	int
)	O
goto	O
bad	O
;	O
{	O
int	O
on	int
=	O
1	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
s	*(char)
,	O
SOL_SOCKET	int
,	O
SO_REUSEADDR	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
,	O
sizeof	O
(	O
on	int
)	O
)	O
<	O
0	int
)	O
goto	O
bad	O
;	O
}	O
data_source	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
data_source	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
=	O
ctrl_addr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
;	O
for	O
(	O
tries	int
=	O
1	int
;	O
;	O
tries	int
++	O
)	O
{	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
s	*(char)
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
data_source	struct(short,short,struct(int),array(char))
,	O
sizeof	O
(	O
data_source	struct(short,short,struct(int),array(char))
)	O
)	O
>=	O
0	int
)	O
break	O
;	O
if	O
(	O
errno	O
!=	O
EADDRINUSE	int
||	O
tries	int
>	O
10	int
)	O
goto	O
bad	O
;	O
sleep	(int)->(int)
(	O
tries	int
)	O
;	O
}	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
uid	int
)	O
;	O
{	O
int	O
on	int
=	O
IPTOS_THROUGHPUT	int
;	O
if	O
(	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
s	*(char)
,	O
IPPROTO_IP	int
,	O
IP_TOS	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
<	O
0	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_WARNING	int
,	O
"setsockopt (IP_TOS): %m"	*(char)
)	O
;	O
}	O
return	O
(	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
s	*(char)
,	O
mode	*(char)
)	O
)	O
;	O
bad	O
:	O
t	int
=	O
errno	O
;	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
uid	int
)	O
;	O
close	*((*(void))->(int))
(	O
s	*(char)
)	O
;	O
errno	O
=	O
t	int
;	O
return	O
NULL	O
;	O
}	O
static	O
FILE	struct
*	O
dataconn	(*(char),long,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
const	O
char	O
*	O
name	*(char)
,	O
off_t	long
size	long
,	O
const	O
char	O
*	O
mode	*(char)
)	O
{	O
char	O
sizebuf	array(char)
[	O
32	int
]	O
;	O
FILE	struct
*	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
retry	int
=	O
0	int
;	O
file_size	long
=	O
size	long
;	O
byte_count	long
=	O
0	int
;	O
if	O
(	O
size	long
!=	O
(	O
off_t	long
)	O
-	O
1	int
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
sizebuf	array(char)
,	O
sizeof	O
(	O
sizebuf	array(char)
)	O
,	O
" (%s bytes)"	*(char)
,	O
off_to_str	(long)->(*(char))
(	O
size	long
)	O
)	O
;	O
else	O
*	O
sizebuf	array(char)
=	O
'\0'	O
;	O
if	O
(	O
pdata	int
>=	O
0	int
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
from	struct(short,short,struct(int),array(char))
;	O
socklen_t	int
s	*(char)
;	O
socklen_t	int
fromlen	int
=	O
sizeof	O
(	O
from	struct(short,short,struct(int),array(char))
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
toolong	(int)->(void)
)	O
;	O
alarm	(int)->(int)
(	O
(	O
unsigned	O
)	O
timeout	int
)	O
;	O
s	*(char)
=	O
accept	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
pdata	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
from	struct(short,short,struct(int),array(char))
,	O
&	O
fromlen	int
)	O
;	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
s	*(char)
<	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
425	int
,	O
"Can't open data connection."	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
pdata	int
)	O
;	O
pdata	int
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
close	*((*(void))->(int))
(	O
pdata	int
)	O
;	O
pdata	int
=	O
s	*(char)
;	O
{	O
int	O
tos	char
=	O
IPTOS_THROUGHPUT	int
;	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
s	*(char)
,	O
IPPROTO_IP	int
,	O
IP_TOS	int
,	O
(	O
char	O
*	O
)	O
&	O
tos	char
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
{	O
int	O
keepalive	int
=	O
1	int
;	O
setsockopt	(int,int,int,*(void),int)->(int)
(	O
s	*(char)
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
char	O
*	O
)	O
&	O
keepalive	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
reply	(int,*(char))->(void)
(	O
150	int
,	O
"Opening %s mode data connection for '%s'%s."	*(char)
,	O
type	enum(int,int,int,int)
==	O
TYPE_A	int
?	O
"ASCII"	*(char)
:	O
"BINARY"	*(char)
,	O
name	*(char)
,	O
sizebuf	array(char)
)	O
;	O
return	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pdata	int
,	O
mode	*(char)
)	O
;	O
}	O
if	O
(	O
data	array(int)
>=	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
125	int
,	O
"Using existing data connection for '%s'%s."	*(char)
,	O
name	*(char)
,	O
sizebuf	array(char)
)	O
;	O
usedefault	int
=	O
1	int
;	O
return	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
data	array(int)
,	O
mode	*(char)
)	O
;	O
}	O
if	O
(	O
usedefault	int
)	O
data_dest	struct(short,short,struct(int),array(char))
=	O
his_addr	struct(short,short,struct(int),array(char))
;	O
usedefault	int
=	O
1	int
;	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
getdatasock	(*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
mode	*(char)
)	O
;	O
if	O
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
reply	(int,*(char))->(void)
(	O
425	int
,	O
"Can't create data socket (%s,%d): %s."	*(char)
,	O
inet_ntoa	(struct(int))->(*(char))
(	O
data_source	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
,	O
ntohs	(short)->(short)
(	O
data_source	struct(short,short,struct(int),array(char))
.	O
sin_port	short
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
data	array(int)
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
connect	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
data	array(int)
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
data_dest	struct(short,short,struct(int),array(char))
,	O
sizeof	O
(	O
data_dest	struct(short,short,struct(int),array(char))
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EADDRINUSE	int
&&	O
retry	int
<	O
swaitmax	int
)	O
{	O
sleep	(int)->(int)
(	O
(	O
unsigned	O
)	O
swaitint	int
)	O
;	O
retry	int
+=	O
swaitint	int
;	O
continue	O
;	O
}	O
perror_reply	(int,*(char))->(void)
(	O
425	int
,	O
"Can't build data connection"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
data	array(int)
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
reply	(int,*(char))->(void)
(	O
150	int
,	O
"Opening %s mode data connection for '%s'%s."	*(char)
,	O
type	enum(int,int,int,int)
==	O
TYPE_A	int
?	O
"ASCII"	*(char)
:	O
"BINARY"	*(char)
,	O
name	*(char)
,	O
sizebuf	array(char)
)	O
;	O
return	O
file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
static	O
void	O
send_data	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long)->(void)
(	O
FILE	struct
*	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
FILE	struct
*	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
off_t	long
blksize	long
)	O
{	O
int	O
c	int
,	O
cnt	int
,	O
filefd	int
,	O
netfd	int
;	O
char	O
*	O
buf	*(char)
,	O
*	O
bp	*(char)
;	O
off_t	long
curpos	long
;	O
size_t	long
len	char
,	O
filesize	long
;	O
transflag	int
++	O
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
urgcatch	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
transflag	int
=	O
0	int
;	O
return	O
;	O
}	O
netfd	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
filefd	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
file_size	long
>	O
0	int
)	O
{	O
curpos	long
=	O
lseek	(int,long,int)->(long)
(	O
filefd	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
curpos	long
>=	O
0	int
)	O
{	O
filesize	long
=	O
file_size	long
-	O
curpos	long
;	O
buf	*(char)
=	O
mmap	(*(void),long,int,int,int,long)->(*(void))
(	O
0	int
,	O
filesize	long
,	O
PROT_READ	int
,	O
MAP_SHARED	int
,	O
filefd	int
,	O
curpos	long
)	O
;	O
}	O
}	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
TYPE_A	int
:	O
if	O
(	O
file_size	long
>	O
0	int
&&	O
curpos	long
>=	O
0	int
&&	O
buf	*(char)
!=	O
MAP_FAILED	O
)	O
{	O
len	char
=	O
0	int
;	O
while	O
(	O
len	char
<	O
filesize	long
)	O
{	O
byte_count	long
++	O
;	O
if	O
(	O
buf	*(char)
[	O
len	char
]	O
==	O
'\n'	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
break	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\r'	O
,	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	*(char)
[	O
len	char
]	O
,	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
len	char
++	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
transflag	int
=	O
0	int
;	O
munmap	(*(void),long)->(int)
(	O
buf	*(char)
,	O
filesize	long
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
data_err	O
;	O
reply	(int,*(char))->(void)
(	O
226	int
,	O
"Transfer complete."	*(char)
)	O
;	O
return	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
byte_count	long
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
data_err	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\r'	O
,	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
transflag	int
=	O
0	int
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
file_err	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
data_err	O
;	O
reply	(int,*(char))->(void)
(	O
226	int
,	O
"Transfer complete."	*(char)
)	O
;	O
return	O
;	O
case	O
TYPE_I	int
:	O
case	O
TYPE_L	int
:	O
if	O
(	O
file_size	long
>	O
0	int
&&	O
curpos	long
>=	O
0	int
&&	O
buf	*(char)
!=	O
MAP_FAILED	O
)	O
{	O
bp	*(char)
=	O
buf	*(char)
;	O
len	char
=	O
filesize	long
;	O
do	O
{	O
cnt	int
=	O
write	*((*(void),*(char),long)->(long))
(	O
netfd	int
,	O
bp	*(char)
,	O
len	char
)	O
;	O
len	char
-=	O
cnt	int
;	O
bp	*(char)
+=	O
cnt	int
;	O
if	O
(	O
cnt	int
>	O
0	int
)	O
byte_count	long
+=	O
cnt	int
;	O
}	O
while	O
(	O
cnt	int
>	O
0	int
&&	O
len	char
>	O
0	int
)	O
;	O
transflag	int
=	O
0	int
;	O
munmap	(*(void),long)->(int)
(	O
buf	*(char)
,	O
(	O
size_t	long
)	O
filesize	long
)	O
;	O
if	O
(	O
cnt	int
<	O
0	int
)	O
goto	O
data_err	O
;	O
reply	(int,*(char))->(void)
(	O
226	int
,	O
"Transfer complete."	*(char)
)	O
;	O
return	O
;	O
}	O
buf	*(char)
=	O
malloc	(long)->(*(void))
(	O
(	O
u_int	int
)	O
blksize	long
)	O
;	O
if	O
(	O
buf	*(char)
==	O
NULL	O
)	O
{	O
transflag	int
=	O
0	int
;	O
perror_reply	(int,*(char))->(void)
(	O
451	int
,	O
"Local resource failure: malloc"	*(char)
)	O
;	O
return	O
;	O
}	O
while	O
(	O
(	O
cnt	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
filefd	int
,	O
buf	*(char)
,	O
(	O
u_int	int
)	O
blksize	long
)	O
)	O
>	O
0	int
&&	O
write	*((*(void),*(char),long)->(long))
(	O
netfd	int
,	O
buf	*(char)
,	O
cnt	int
)	O
==	O
cnt	int
)	O
byte_count	long
+=	O
cnt	int
;	O
transflag	int
=	O
0	int
;	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
cnt	int
!=	O
0	int
)	O
{	O
if	O
(	O
cnt	int
<	O
0	int
)	O
goto	O
file_err	O
;	O
goto	O
data_err	O
;	O
}	O
reply	(int,*(char))->(void)
(	O
226	int
,	O
"Transfer complete."	*(char)
)	O
;	O
return	O
;	O
default	O
:	O
transflag	int
=	O
0	int
;	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"Unimplemented TYPE %d in send_data"	*(char)
,	O
type	enum(int,int,int,int)
)	O
;	O
return	O
;	O
}	O
data_err	O
:	O
transflag	int
=	O
0	int
;	O
perror_reply	(int,*(char))->(void)
(	O
426	int
,	O
"Data connection"	*(char)
)	O
;	O
return	O
;	O
file_err	O
:	O
transflag	int
=	O
0	int
;	O
perror_reply	(int,*(char))->(void)
(	O
551	int
,	O
"Error on input file"	*(char)
)	O
;	O
}	O
static	O
int	O
receive_data	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
FILE	struct
*	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
FILE	struct
*	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
c	int
;	O
int	O
cnt	int
,	O
bare_lfs	int
=	O
0	int
;	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
;	O
transflag	int
++	O
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
urgcatch	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
transflag	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
TYPE_I	int
:	O
case	O
TYPE_L	int
:	O
while	O
(	O
(	O
cnt	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
write	*((*(void),*(char),long)->(long))
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
buf	*(char)
,	O
cnt	int
)	O
!=	O
cnt	int
)	O
goto	O
file_err	O
;	O
byte_count	long
+=	O
cnt	int
;	O
}	O
if	O
(	O
cnt	int
<	O
0	int
)	O
goto	O
data_err	O
;	O
transflag	int
=	O
0	int
;	O
return	O
0	int
;	O
case	O
TYPE_E	int
:	O
reply	(int,*(char))->(void)
(	O
553	int
,	O
"TYPE E not implemented."	*(char)
)	O
;	O
transflag	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
case	O
TYPE_A	int
:	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
byte_count	long
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
bare_lfs	int
++	O
;	O
while	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
data_err	O
;	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
!=	O
'\n'	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\r'	O
,	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
==	O
'\0'	O
||	O
c	int
==	O
EOF	O
)	O
goto	O
contin2	O
;	O
}	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
contin2	O
:	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
instr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
data_err	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
outstr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
goto	O
file_err	O
;	O
transflag	int
=	O
0	int
;	O
if	O
(	O
bare_lfs	int
)	O
{	O
lreply	(int,*(char))->(void)
(	O
226	int
,	O
"WARNING! %d bare linefeeds received in ASCII mode"	*(char)
,	O
bare_lfs	int
)	O
;	O
printf	(*(char))->(int)
(	O
"   File may not have transferred correctly.\r\n"	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
default	O
:	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"Unimplemented TYPE %d in receive_data"	*(char)
,	O
type	enum(int,int,int,int)
)	O
;	O
transflag	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
data_err	O
:	O
transflag	int
=	O
0	int
;	O
perror_reply	(int,*(char))->(void)
(	O
426	int
,	O
"Data Connection"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
file_err	O
:	O
transflag	int
=	O
0	int
;	O
perror_reply	(int,*(char))->(void)
(	O
452	int
,	O
"Error writing file"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
statfilecmd	(*(char))->(void)
(	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
FILE	struct
*	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
c	int
;	O
char	O
line	*(char)
[	O
LINE_MAX	O
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
line	*(char)
,	O
sizeof	O
(	O
line	*(char)
)	O
,	O
"/bin/ls -lgA %s"	*(char)
,	O
filename	*(char)
)	O
;	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
ftpd_popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
line	*(char)
,	O
"r"	*(char)
)	O
;	O
lreply	(int,*(char))->(void)
(	O
211	int
,	O
"status of %s:"	*(char)
,	O
filename	*(char)
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
421	int
,	O
"control connection"	*(char)
)	O
;	O
ftpd_pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
dologout	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
551	int
,	O
filename	*(char)
)	O
;	O
ftpd_pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\r'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
ftpd_pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
reply	(int,*(char))->(void)
(	O
211	int
,	O
"End of Status"	*(char)
)	O
;	O
}	O
void	O
statcmd	()->(void)
(	O
void	O
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
sin	*(struct(short,short,struct(int),array(char)))
;	O
unsigned	O
char	O
*	O
a	*(char)
,	O
*	O
p	*(char)
;	O
lreply	(int,*(char))->(void)
(	O
211	int
,	O
"%s FTP server status:"	*(char)
,	O
hostname	*(char)
)	O
;	O
if	O
(	O
!	O
no_version	int
)	O
printf	(*(char))->(int)
(	O
"     ftpd (%s) %s\r\n"	*(char)
,	O
PACKAGE_NAME	*(char)
,	O
PACKAGE_VERSION	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"     Connected to %s"	*(char)
,	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
remotehost	*(char)
)	O
;	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
remotehost	*(char)
[	O
0	int
]	O
)	O
)	O
printf	(*(char))->(int)
(	O
" (%s)"	*(char)
,	O
inet_ntoa	(struct(int))->(*(char))
(	O
his_addr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\r\n"	*(char)
)	O
;	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
logged_in	int
)	O
{	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
guest	int
)	O
printf	(*(char))->(int)
(	O
"     Logged in anonymously\r\n"	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"     Logged in as %s\r\n"	*(char)
,	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
askpasswd	int
)	O
printf	(*(char))->(int)
(	O
"     Waiting for password\r\n"	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"     Waiting for user name\r\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"     TYPE: %s"	*(char)
,	O
typenames	array(*(char))
[	O
type	enum(int,int,int,int)
]	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
TYPE_A	int
||	O
type	enum(int,int,int,int)
==	O
TYPE_E	int
)	O
printf	(*(char))->(int)
(	O
", FORM: %s"	*(char)
,	O
formnames	array(*(char))
[	O
form	int
]	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
TYPE_L	int
)	O
printf	(*(char))->(int)
(	O
" %d"	*(char)
,	O
CHAR_BIT	O
)	O
;	O
printf	(*(char))->(int)
(	O
"; STRUcture: %s; transfer MODE: %s\r\n"	*(char)
,	O
strunames	array(*(char))
[	O
stru	int
]	O
,	O
modenames	array(*(char))
[	O
stru_mode	int
]	O
)	O
;	O
if	O
(	O
data	array(int)
!=	O
-	O
1	int
)	O
printf	(*(char))->(int)
(	O
"     Data connection open\r\n"	*(char)
)	O
;	O
else	O
if	O
(	O
pdata	int
!=	O
-	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"     in Passive mode"	*(char)
)	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
=	O
&	O
pasv_addr	struct(short,short,struct(int),array(char))
;	O
goto	O
printaddr	O
;	O
}	O
else	O
if	O
(	O
usedefault	int
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"     PORT"	*(char)
)	O
;	O
sin	*(struct(short,short,struct(int),array(char)))
=	O
&	O
data_dest	struct(short,short,struct(int),array(char))
;	O
printaddr	O
:	O
a	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_addr	struct(int)
;	O
p	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_port	short
;	O
printf	(*(char))->(int)
(	O
" (%d,%d,%d,%d,%d,%d)\r\n"	*(char)
,	O
UC	O
(	O
a	*(char)
[	O
0	int
]	O
)	O
,	O
UC	O
(	O
a	*(char)
[	O
1	int
]	O
)	O
,	O
UC	O
(	O
a	*(char)
[	O
2	int
]	O
)	O
,	O
UC	O
(	O
a	*(char)
[	O
3	int
]	O
)	O
,	O
UC	O
(	O
p	*(char)
[	O
0	int
]	O
)	O
,	O
UC	O
(	O
p	*(char)
[	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"     No data connection\r\n"	*(char)
)	O
;	O
reply	(int,*(char))->(void)
(	O
211	int
,	O
"End of status"	*(char)
)	O
;	O
}	O
void	O
fatal	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
reply	(int,*(char))->(void)
(	O
451	int
,	O
"Error in server: %s\n"	*(char)
,	O
s	*(char)
)	O
;	O
reply	(int,*(char))->(void)
(	O
221	int
,	O
"Closing connection due to server error."	*(char)
)	O
;	O
dologout	(int)->(void)
(	O
0	int
)	O
;	O
}	O
void	O
reply	(int,*(char))->(void)
(	O
int	O
n	long
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%d "	*(char)
,	O
n	long
)	O
;	O
vprintf	(*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
printf	(*(char))->(int)
(	O
"\r\n"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_DEBUG	int
,	O
"<--- %d "	*(char)
,	O
n	long
)	O
;	O
vsyslog	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
LOG_DEBUG	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
}	O
void	O
lreply	(int,*(char))->(void)
(	O
int	O
n	long
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"%d- "	*(char)
,	O
n	long
)	O
;	O
vprintf	(*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
printf	(*(char))->(int)
(	O
"\r\n"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_DEBUG	int
,	O
"<--- %d- "	*(char)
,	O
n	long
)	O
;	O
vsyslog	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
LOG_DEBUG	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
}	O
static	O
void	O
ack	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
reply	(int,*(char))->(void)
(	O
250	int
,	O
"%s command successful."	*(char)
,	O
s	*(char)
)	O
;	O
}	O
void	O
nack	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
reply	(int,*(char))->(void)
(	O
502	int
,	O
"%s command not implemented."	*(char)
,	O
s	*(char)
)	O
;	O
}	O
void	O
delete	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
LOGCMD	O
(	O
"delete"	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
rmdir	(*(char))->(int)
(	O
name	*(char)
)	O
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
goto	O
done	O
;	O
}	O
if	O
(	O
unlink	(*(char))->(int)
(	O
name	*(char)
)	O
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
done	O
:	O
ack	(*(char))->(void)
(	O
"DELE"	*(char)
)	O
;	O
}	O
void	O
cwd	short
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
if	O
(	O
chdir	(*(char))->(int)
(	O
path	*(char)
)	O
<	O
0	int
)	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
path	*(char)
)	O
;	O
else	O
ack	(*(char))->(void)
(	O
"CWD"	*(char)
)	O
;	O
}	O
void	O
makedir	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
extern	O
char	O
*	O
xgetcwd	()->(*(char))
(	O
void	O
)	O
;	O
LOGCMD	O
(	O
"mkdir"	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
mkdir	(*(char),int)->(int)
(	O
name	*(char)
,	O
0777	int
)	O
<	O
0	int
)	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'/'	O
)	O
reply	(int,*(char))->(void)
(	O
257	int
,	O
"\"%s\" new directory created."	*(char)
,	O
name	*(char)
)	O
;	O
else	O
{	O
char	O
*	O
current	*(char)
=	O
xgetcwd	()->(*(char))
(	O
)	O
;	O
if	O
(	O
current	*(char)
)	O
{	O
if	O
(	O
current	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
current	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
reply	(int,*(char))->(void)
(	O
257	int
,	O
"\"%s/%s\" new directory created."	*(char)
,	O
current	*(char)
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
current	*(char)
)	O
;	O
}	O
else	O
reply	(int,*(char))->(void)
(	O
257	int
,	O
"(unknown absolute name) new directory created."	*(char)
)	O
;	O
}	O
}	O
void	O
removedir	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
LOGCMD	O
(	O
"rmdir"	*(char)
,	O
name	*(char)
)	O
;	O
if	O
(	O
rmdir	(*(char))->(int)
(	O
name	*(char)
)	O
<	O
0	int
)	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
else	O
ack	(*(char))->(void)
(	O
"RMD"	*(char)
)	O
;	O
}	O
void	O
pwd	()->(void)
(	O
void	O
)	O
{	O
extern	O
char	O
*	O
xgetcwd	()->(*(char))
(	O
void	O
)	O
;	O
char	O
*	O
path	*(char)
=	O
xgetcwd	()->(*(char))
(	O
)	O
;	O
if	O
(	O
path	*(char)
)	O
{	O
reply	(int,*(char))->(void)
(	O
257	int
,	O
"\"%s\" is current directory."	*(char)
,	O
path	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
path	*(char)
)	O
;	O
}	O
else	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"%s."	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
char	O
*	O
renamefrom	(*(char))->(*(char))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
name	*(char)
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
reply	(int,*(char))->(void)
(	O
350	int
,	O
"File exists, ready for destination name"	*(char)
)	O
;	O
return	O
(	O
char	O
*	O
)	O
(	O
name	*(char)
)	O
;	O
}	O
void	O
renamecmd	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
from	struct(short,short,struct(int),array(char))
,	O
const	O
char	O
*	O
to	*(char)
)	O
{	O
LOGCMD2	O
(	O
"rename"	*(char)
,	O
from	struct(short,short,struct(int),array(char))
,	O
to	*(char)
)	O
;	O
if	O
(	O
rename	(*(char),*(char))->(int)
(	O
from	struct(short,short,struct(int),array(char))
,	O
to	*(char)
)	O
<	O
0	int
)	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
"rename"	*(char)
)	O
;	O
else	O
ack	(*(char))->(void)
(	O
"RNTO"	*(char)
)	O
;	O
}	O
static	O
void	O
dolog	(*(struct(short,short,struct(int),array(char))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)))->(void)
(	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
*	O
sin	*(struct(short,short,struct(int),array(char)))
,	O
struct	O
credentials	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
*	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
=	O
gethostbyaddr	(*(void),int,int)->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
(	O
char	O
*	O
)	O
&	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_addr	struct(int)
,	O
sizeof	O
(	O
struct	O
in_addr	struct(int)
)	O
,	O
AF_INET	O
)	O
;	O
if	O
(	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
)	O
name	*(char)
=	O
hp	*(struct(*(char),*(*(char)),int,int,*(*(char))))
->	O
h_name	*(char)
;	O
else	O
name	*(char)
=	O
inet_ntoa	(struct(int))->(*(char))
(	O
sin	*(struct(short,short,struct(int),array(char)))
->	O
sin_addr	struct(int)
)	O
;	O
free	(*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
remotehost	*(char)
)	O
;	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
remotehost	*(char)
=	O
sgetsave	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"connection from %s"	*(char)
,	O
pcred	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int))
->	O
remotehost	*(char)
)	O
;	O
}	O
void	O
dologout	(int)->(void)
(	O
int	O
status	int
)	O
{	O
transflag	int
=	O
0	int
;	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
logged_in	int
)	O
{	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
0	int
)	O
;	O
logwtmp_keep_open	(*(char),*(char),*(char))->(void)
(	O
ttyline	array(char)
,	O
""	*(char)
,	O
""	*(char)
)	O
;	O
}	O
_exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
static	O
void	O
myoob	(int)->(void)
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
char	O
*	O
cp	*(char)
;	O
if	O
(	O
!	O
transflag	int
)	O
return	O
;	O
cp	*(char)
=	O
tmpline	array(char)
;	O
if	O
(	O
telnet_fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
cp	*(char)
,	O
7	int
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
{	O
reply	(int,*(char))->(void)
(	O
221	int
,	O
"You could at least say goodbye."	*(char)
)	O
;	O
dologout	(int)->(void)
(	O
0	int
)	O
;	O
}	O
upper	(*(char))->(void)
(	O
cp	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cp	*(char)
,	O
"ABOR\r\n"	*(char)
)	O
==	O
0	int
)	O
{	O
tmpline	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
reply	(int,*(char))->(void)
(	O
426	int
,	O
"Transfer aborted. Data connection closed."	*(char)
)	O
;	O
reply	(int,*(char))->(void)
(	O
226	int
,	O
"Abort successful"	*(char)
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
urgcatch	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cp	*(char)
,	O
"STAT\r\n"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
file_size	long
!=	O
(	O
off_t	long
)	O
-	O
1	int
)	O
reply	(int,*(char))->(void)
(	O
213	int
,	O
"Status: %s of %s bytes transferred"	*(char)
,	O
off_to_str	(long)->(*(char))
(	O
byte_count	long
)	O
,	O
off_to_str	(long)->(*(char))
(	O
file_size	long
)	O
)	O
;	O
else	O
reply	(int,*(char))->(void)
(	O
213	int
,	O
"Status: %s bytes transferred"	*(char)
,	O
off_to_str	(long)->(*(char))
(	O
byte_count	long
)	O
)	O
;	O
}	O
}	O
void	O
passive	()->(void)
(	O
void	O
)	O
{	O
socklen_t	int
len	char
;	O
char	O
*	O
p	*(char)
,	O
*	O
a	*(char)
;	O
pdata	int
=	O
socket	(int,int,int)->(int)
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
pdata	int
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
425	int
,	O
"Can't open passive connection"	*(char)
)	O
;	O
return	O
;	O
}	O
pasv_addr	struct(short,short,struct(int),array(char))
=	O
ctrl_addr	struct(short,short,struct(int),array(char))
;	O
pasv_addr	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
0	int
;	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
0	int
)	O
;	O
if	O
(	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
pdata	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
pasv_addr	struct(short,short,struct(int),array(char))
,	O
sizeof	O
(	O
pasv_addr	struct(short,short,struct(int),array(char))
)	O
)	O
<	O
0	int
)	O
{	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
uid	int
)	O
;	O
goto	O
pasv_error	O
;	O
}	O
seteuid	(int)->(int)
(	O
(	O
uid_t	int
)	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
uid	int
)	O
;	O
len	char
=	O
sizeof	O
(	O
pasv_addr	struct(short,short,struct(int),array(char))
)	O
;	O
if	O
(	O
getsockname	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
pdata	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
pasv_addr	struct(short,short,struct(int),array(char))
,	O
&	O
len	char
)	O
<	O
0	int
)	O
goto	O
pasv_error	O
;	O
if	O
(	O
listen	(int,int)->(int)
(	O
pdata	int
,	O
1	int
)	O
<	O
0	int
)	O
goto	O
pasv_error	O
;	O
a	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
pasv_addr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
;	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
pasv_addr	struct(short,short,struct(int),array(char))
.	O
sin_port	short
;	O
reply	(int,*(char))->(void)
(	O
227	int
,	O
"Entering Passive Mode (%d,%d,%d,%d,%d,%d)"	*(char)
,	O
UC	O
(	O
a	*(char)
[	O
0	int
]	O
)	O
,	O
UC	O
(	O
a	*(char)
[	O
1	int
]	O
)	O
,	O
UC	O
(	O
a	*(char)
[	O
2	int
]	O
)	O
,	O
UC	O
(	O
a	*(char)
[	O
3	int
]	O
)	O
,	O
UC	O
(	O
p	*(char)
[	O
0	int
]	O
)	O
,	O
UC	O
(	O
p	*(char)
[	O
1	int
]	O
)	O
)	O
;	O
return	O
;	O
pasv_error	O
:	O
close	*((*(void))->(int))
(	O
pdata	int
)	O
;	O
pdata	int
=	O
-	O
1	int
;	O
perror_reply	(int,*(char))->(void)
(	O
425	int
,	O
"Can't open passive connection"	*(char)
)	O
;	O
return	O
;	O
}	O
static	O
char	O
*	O
gunique	(*(char))->(*(char))
(	O
const	O
char	O
*	O
local	*(char)
)	O
{	O
static	O
char	O
*	O
string	*(char)
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
count	int
;	O
char	O
*	O
cp	*(char)
;	O
cp	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
local	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
cp	*(char)
?	O
local	*(char)
:	O
"."	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
553	int
,	O
cp	*(char)
?	O
local	*(char)
:	O
"."	*(char)
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
if	O
(	O
cp	*(char)
)	O
*	O
cp	*(char)
=	O
'/'	O
;	O
free	(*(void))->(void)
(	O
string	*(char)
)	O
;	O
string	*(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
local	*(char)
)	O
+	O
5	int
)	O
;	O
if	O
(	O
string	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
string	*(char)
,	O
local	*(char)
)	O
;	O
cp	*(char)
=	O
string	*(char)
+	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
*	O
cp	*(char)
++	O
=	O
'.'	O
;	O
for	O
(	O
count	int
=	O
1	int
;	O
count	int
<	O
100	int
;	O
count	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
cp	*(char)
,	O
"%d"	*(char)
,	O
count	int
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
string	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
return	O
string	*(char)
;	O
}	O
}	O
reply	(int,*(char))->(void)
(	O
452	int
,	O
"Unique file name cannot be created."	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
perror_reply	(int,*(char))->(void)
(	O
int	O
code	int
,	O
const	O
char	O
*	O
string	*(char)
)	O
{	O
reply	(int,*(char))->(void)
(	O
code	int
,	O
"%s: %s."	*(char)
,	O
string	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
}	O
static	O
char	O
*	O
onefile	array(*(char))
[	O
]	O
=	O
{	O
""	*(char)
,	O
0	int
}	O
;	O
void	O
send_file_list	(*(char))->(void)
(	O
const	O
char	O
*	O
whichf	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
DIR	struct
*	O
dirp	*(struct)
=	O
NULL	O
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dir	*(struct(long,long,short,char,array(char)))
;	O
FILE	struct
*	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
char	O
*	O
*	O
dirlist	*(*(char))
,	O
*	O
dirname	*(char)
;	O
int	O
simple	int
=	O
0	int
;	O
int	O
freeglob	int
=	O
0	int
;	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
;	O
char	O
*	O
p	*(char)
=	O
NULL	O
;	O
if	O
(	O
strpbrk	(*(char),*(char))->(*(char))
(	O
whichf	*(char)
,	O
"~{[*?"	*(char)
)	O
!=	O
NULL	O
)	O
{	O
int	O
flags	int
=	O
GLOB_NOCHECK	O
;	O
flags	int
|=	O
GLOB_BRACE	O
;	O
flags	int
|=	O
GLOB_TILDE	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
,	O
0	int
,	O
sizeof	O
(	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
)	O
;	O
freeglob	int
=	O
1	int
;	O
if	O
(	O
glob	O
(	O
whichf	*(char)
,	O
flags	int
,	O
0	int
,	O
&	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"not found"	*(char)
)	O
;	O
goto	O
out	O
;	O
}	O
else	O
if	O
(	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
==	O
0	int
)	O
{	O
errno	O
=	O
ENOENT	int
;	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
whichf	*(char)
)	O
;	O
goto	O
out	O
;	O
}	O
dirlist	*(*(char))
=	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
;	O
}	O
else	O
{	O
p	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
whichf	*(char)
)	O
;	O
onefile	array(*(char))
[	O
0	int
]	O
=	O
p	*(char)
;	O
dirlist	*(*(char))
=	O
onefile	array(*(char))
;	O
simple	int
=	O
1	int
;	O
}	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
urgcatch	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
transflag	int
=	O
0	int
;	O
goto	O
out	O
;	O
}	O
while	O
(	O
(	O
dirname	*(char)
=	O
*	O
dirlist	*(*(char))
++	O
)	O
)	O
{	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
dirname	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
{	O
if	O
(	O
dirname	*(char)
[	O
0	int
]	O
==	O
'-'	O
&&	O
*	O
dirlist	*(*(char))
==	O
NULL	O
&&	O
transflag	int
==	O
0	int
)	O
{	O
retrieve	(*(char),*(char))->(void)
(	O
"/bin/ls %s"	*(char)
,	O
dirname	*(char)
)	O
;	O
goto	O
out	O
;	O
}	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
whichf	*(char)
)	O
;	O
if	O
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
transflag	int
=	O
0	int
;	O
data	array(int)
=	O
-	O
1	int
;	O
pdata	int
=	O
-	O
1	int
;	O
}	O
goto	O
out	O
;	O
}	O
if	O
(	O
S_ISREG	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
dataconn	(*(char),long,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"file list"	*(char)
,	O
(	O
off_t	long
)	O
-	O
1	int
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
goto	O
out	O
;	O
transflag	int
++	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s%s\n"	*(char)
,	O
dirname	*(char)
,	O
type	enum(int,int,int,int)
==	O
TYPE_A	int
?	O
"\r"	*(char)
:	O
""	*(char)
)	O
;	O
byte_count	long
+=	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
+	O
1	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
continue	O
;	O
dirp	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
dirname	*(char)
)	O
;	O
if	O
(	O
dirp	*(struct)
==	O
NULL	O
)	O
continue	O
;	O
while	O
(	O
(	O
dir	*(struct(long,long,short,char,array(char)))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
nbuf	*(char)
;	O
if	O
(	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
continue	O
;	O
if	O
(	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
2	int
]	O
==	O
'\0'	O
)	O
continue	O
;	O
nbuf	*(char)
=	O
alloca	O
(	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
+	O
1	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
nbuf	*(char)
,	O
"%s/%s"	*(char)
,	O
dirname	*(char)
,	O
dir	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
if	O
(	O
simple	int
||	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
nbuf	*(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
&&	O
S_ISREG	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
)	O
{	O
if	O
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
dataconn	(*(char),long,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"file list"	*(char)
,	O
(	O
off_t	long
)	O
-	O
1	int
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
goto	O
out	O
;	O
transflag	int
++	O
;	O
}	O
if	O
(	O
nbuf	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
nbuf	*(char)
[	O
1	int
]	O
==	O
'/'	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s%s\n"	*(char)
,	O
&	O
nbuf	*(char)
[	O
2	int
]	O
,	O
type	enum(int,int,int,int)
==	O
TYPE_A	int
?	O
"\r"	*(char)
:	O
""	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s%s\n"	*(char)
,	O
nbuf	*(char)
,	O
type	enum(int,int,int,int)
==	O
TYPE_A	int
?	O
"\r"	*(char)
:	O
""	*(char)
)	O
;	O
byte_count	long
+=	O
strlen	(*(char))->(long)
(	O
nbuf	*(char)
)	O
+	O
1	int
;	O
}	O
}	O
closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
}	O
if	O
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"No files found."	*(char)
)	O
;	O
else	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
"Data connection"	*(char)
)	O
;	O
else	O
reply	(int,*(char))->(void)
(	O
226	int
,	O
"Transfer complete."	*(char)
)	O
;	O
transflag	int
=	O
0	int
;	O
if	O
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
dout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
data	array(int)
=	O
-	O
1	int
;	O
pdata	int
=	O
-	O
1	int
;	O
out	O
:	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
if	O
(	O
freeglob	int
)	O
{	O
freeglob	int
=	O
0	int
;	O
globfree	O
(	O
&	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct(long,long,short,char,array(char))))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
}	O
}	O
