struct	O
inflate_blocks_state	struct(int)
{	O
int	O
dummy	int
;	O
}	O
;	O
typedef	O
enum	O
{	O
METHOD	int
,	O
FLAG	int
,	O
DICT4	int
,	O
DICT3	int
,	O
DICT2	int
,	O
DICT1	int
,	O
DICT0	int
,	O
BLOCKS	int
,	O
CHECK4	int
,	O
CHECK3	int
,	O
CHECK2	int
,	O
CHECK1	int
,	O
DONE	int
,	O
BAD	int
}	O
inflate_mode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
struct	O
internal_state	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),union(int,struct(long,long),int),int,int,*(struct(int)))
{	O
inflate_mode	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
mode	*(char)
;	O
union	O
{	O
uInt	int
method	int
;	O
struct	O
{	O
uLong	long
was	long
;	O
uLong	long
need	long
;	O
}	O
check	long
;	O
uInt	int
marker	int
;	O
}	O
sub	union(int,struct(long,long),int)
;	O
int	O
nowrap	int
;	O
uInt	int
wbits	int
;	O
inflate_blocks_statef	struct
*	O
blocks	*(struct(int))
;	O
}	O
;	O
int	O
ZEXPORT	O
inflateReset	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
{	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_in	long
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_out	long
=	O
0	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
Z_NULL	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
nowrap	int
?	O
BLOCKS	int
:	O
METHOD	int
;	O
inflate_blocks_reset	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*(long))->(void)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
Z_NULL	int
)	O
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: reset\n"	*(char)
)	O
)	O
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateEnd	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
{	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
zfree	*((*(void),*(void))->(void))
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
!=	O
Z_NULL	int
)	O
inflate_blocks_free	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
ZFREE	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
)	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
=	O
Z_NULL	int
;	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: end\n"	*(char)
)	O
)	O
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateInit2_	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int,*(char),int)->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
w	int
,	O
version	*(char)
,	O
stream_size	int
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
int	O
w	int
;	O
const	O
char	O
*	O
version	*(char)
;	O
int	O
stream_size	int
;	O
{	O
if	O
(	O
version	*(char)
==	O
Z_NULL	int
||	O
version	*(char)
[	O
0	int
]	O
!=	O
ZLIB_VERSION	*(char)
[	O
0	int
]	O
||	O
stream_size	int
!=	O
sizeof	O
(	O
z_stream	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
)	O
)	O
return	O
Z_VERSION_ERROR	O
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
Z_NULL	int
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
zalloc	*((*(void),int,int)->(*(void)))
==	O
Z_NULL	int
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
zalloc	*((*(void),int,int)->(*(void)))
=	O
zcalloc	(*(void),int,int)->(*(void))
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
opaque	*(void)
=	O
(	O
voidpf	*(void)
)	O
0	int
;	O
}	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
zfree	*((*(void),*(void))->(void))
==	O
Z_NULL	int
)	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
zfree	*((*(void),*(void))->(void))
=	O
zcfree	(*(void),*(void))->(void)
;	O
if	O
(	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
=	O
(	O
struct	O
internal_state	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),union(int,struct(long,long),int),int,int,*(struct(int)))
FAR	O
*	O
)	O
ZALLOC	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
1	int
,	O
sizeof	O
(	O
struct	O
internal_state	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),union(int,struct(long,long),int),int,int,*(struct(int)))
)	O
)	O
)	O
==	O
Z_NULL	int
)	O
return	O
Z_MEM_ERROR	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
=	O
Z_NULL	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
nowrap	int
=	O
0	int
;	O
if	O
(	O
w	int
<	O
0	int
)	O
{	O
w	int
=	O
-	O
w	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
nowrap	int
=	O
1	int
;	O
}	O
if	O
(	O
w	int
<	O
8	int
||	O
w	int
>	O
15	int
)	O
{	O
inflateEnd	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
return	O
Z_STREAM_ERROR	O
;	O
}	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
wbits	int
=	O
(	O
uInt	int
)	O
w	int
;	O
if	O
(	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
=	O
inflate_blocks_new	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*((long,*(char),int)->(long)),int)->(*(struct))
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
nowrap	int
?	O
Z_NULL	int
:	O
adler32	(long,*(char),int)->(long)
,	O
(	O
uInt	int
)	O
1	int
<<	O
w	int
)	O
)	O
==	O
Z_NULL	int
)	O
{	O
inflateEnd	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
return	O
Z_MEM_ERROR	O
;	O
}	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: allocated\n"	*(char)
)	O
)	O
;	O
inflateReset	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateInit_	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*(char),int)->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
version	*(char)
,	O
stream_size	int
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
const	O
char	O
*	O
version	*(char)
;	O
int	O
stream_size	int
;	O
{	O
return	O
inflateInit2_	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int,*(char),int)->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
DEF_WBITS	O
,	O
version	*(char)
,	O
stream_size	int
)	O
;	O
}	O
int	O
ZEXPORT	O
inflate	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int)->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
f	int
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
int	O
f	int
;	O
{	O
int	O
r	int
;	O
uInt	int
b	int
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
next_in	*(char)
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
f	int
=	O
f	int
==	O
Z_FINISH	int
?	O
Z_BUF_ERROR	O
:	O
Z_OK	int
;	O
r	int
=	O
Z_BUF_ERROR	O
;	O
while	O
(	O
1	int
)	O
switch	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
)	O
{	O
case	O
METHOD	int
:	O
NEEDBYTE	O
if	O
(	O
(	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
method	int
=	O
NEXTBYTE	O
)	O
&	O
0xf	int
)	O
!=	O
Z_DEFLATED	int
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"unknown compression method"	*(char)
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
=	O
5	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
method	int
>>	O
4	int
)	O
+	O
8	int
>	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
wbits	int
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"invalid window size"	*(char)
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
=	O
5	int
;	O
break	O
;	O
}	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
FLAG	int
;	O
case	O
FLAG	int
:	O
NEEDBYTE	O
b	int
=	O
NEXTBYTE	O
;	O
if	O
(	O
(	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
method	int
<<	O
8	int
)	O
+	O
b	int
)	O
%	O
31	int
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"incorrect header check"	*(char)
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
=	O
5	int
;	O
break	O
;	O
}	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: zlib header ok\n"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
(	O
b	int
&	O
PRESET_DICT	int
)	O
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BLOCKS	int
;	O
break	O
;	O
}	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
DICT4	int
;	O
case	O
DICT4	int
:	O
NEEDBYTE	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
24	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
DICT3	int
;	O
case	O
DICT3	int
:	O
NEEDBYTE	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
16	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
DICT2	int
;	O
case	O
DICT2	int
:	O
NEEDBYTE	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
8	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
DICT1	int
;	O
case	O
DICT1	int
:	O
NEEDBYTE	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
adler	long
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
DICT0	int
;	O
return	O
Z_NEED_DICT	int
;	O
case	O
DICT0	int
:	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"need dictionary"	*(char)
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
=	O
0	int
;	O
return	O
Z_STREAM_ERROR	O
;	O
case	O
BLOCKS	int
:	O
r	int
=	O
inflate_blocks	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int)->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
r	int
)	O
;	O
if	O
(	O
r	int
==	O
Z_DATA_ERROR	O
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
r	int
==	O
Z_OK	int
)	O
r	int
=	O
f	int
;	O
if	O
(	O
r	int
!=	O
Z_STREAM_END	int
)	O
return	O
r	int
;	O
r	int
=	O
f	int
;	O
inflate_blocks_reset	(*(struct),*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*(long))->(void)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
,	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
&	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
was	long
)	O
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
nowrap	int
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
DONE	int
;	O
break	O
;	O
}	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
CHECK4	int
;	O
case	O
CHECK4	int
:	O
NEEDBYTE	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
24	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
CHECK3	int
;	O
case	O
CHECK3	int
:	O
NEEDBYTE	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
16	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
CHECK2	int
;	O
case	O
CHECK2	int
:	O
NEEDBYTE	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
<<	O
8	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
CHECK1	int
;	O
case	O
CHECK1	int
:	O
NEEDBYTE	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
+=	O
(	O
uLong	long
)	O
NEXTBYTE	O
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
was	long
!=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
check	long
.	O
need	long
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
msg	*(char)
=	O
(	O
char	O
*	O
)	O
"incorrect data check"	*(char)
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
=	O
5	int
;	O
break	O
;	O
}	O
Tracev	O
(	O
(	O
stderr	O
,	O
"inflate: zlib check ok\n"	*(char)
)	O
)	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
DONE	int
;	O
case	O
DONE	int
:	O
return	O
Z_STREAM_END	int
;	O
case	O
BAD	int
:	O
return	O
Z_DATA_ERROR	O
;	O
default	O
:	O
return	O
Z_STREAM_ERROR	O
;	O
}	O
}	O
int	O
ZEXPORT	O
inflateSetDictionary	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),*(char),int)->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
dictionary	*(char)
,	O
dictLength	int
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
const	O
Bytef	char
*	O
dictionary	*(char)
;	O
uInt	int
dictLength	int
;	O
{	O
uInt	int
length	int
=	O
dictLength	int
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
!=	O
DICT0	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
if	O
(	O
adler32	(long,*(char),int)->(long)
(	O
1L	int
,	O
dictionary	*(char)
,	O
dictLength	int
)	O
!=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
adler	long
)	O
return	O
Z_DATA_ERROR	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
adler	long
=	O
1L	int
;	O
if	O
(	O
length	int
>=	O
(	O
(	O
uInt	int
)	O
1	int
<<	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
wbits	int
)	O
)	O
{	O
length	int
=	O
(	O
1	int
<<	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
wbits	int
)	O
-	O
1	int
;	O
dictionary	*(char)
+=	O
dictLength	int
-	O
length	int
;	O
}	O
inflate_set_dictionary	(*(struct),*(char),int)->(void)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
,	O
dictionary	*(char)
,	O
length	int
)	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BLOCKS	int
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateSync	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
{	O
uInt	int
n	int
;	O
Bytef	char
*	O
p	*(char)
;	O
uInt	int
m	int
;	O
uLong	long
r	int
,	O
w	int
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
!=	O
BAD	int
)	O
{	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BAD	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
n	int
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_in	int
)	O
==	O
0	int
)	O
return	O
Z_BUF_ERROR	O
;	O
p	*(char)
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
next_in	*(char)
;	O
m	int
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
;	O
while	O
(	O
n	int
&&	O
m	int
<	O
4	int
)	O
{	O
static	O
const	O
Byte	char
mark	array(char)
[	O
4	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0xff	int
,	O
0xff	int
}	O
;	O
if	O
(	O
*	O
p	*(char)
==	O
mark	array(char)
[	O
m	int
]	O
)	O
m	int
++	O
;	O
else	O
if	O
(	O
*	O
p	*(char)
)	O
m	int
=	O
0	int
;	O
else	O
m	int
=	O
4	int
-	O
m	int
;	O
p	*(char)
++	O
,	O
n	int
--	O
;	O
}	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_in	long
+=	O
p	*(char)
-	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
next_in	*(char)
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
next_in	*(char)
=	O
p	*(char)
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
avail_in	int
=	O
n	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
sub	union(int,struct(long,long),int)
.	O
marker	int
=	O
m	int
;	O
if	O
(	O
m	int
!=	O
4	int
)	O
return	O
Z_DATA_ERROR	O
;	O
r	int
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_in	long
;	O
w	int
=	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_out	long
;	O
inflateReset	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_in	long
=	O
r	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
total_out	long
=	O
w	int
;	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
mode	*(char)
=	O
BLOCKS	int
;	O
return	O
Z_OK	int
;	O
}	O
int	O
ZEXPORT	O
inflateSyncPoint	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
z_streamp	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
{	O
if	O
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
==	O
Z_NULL	int
||	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
==	O
Z_NULL	int
)	O
return	O
Z_STREAM_ERROR	O
;	O
return	O
inflate_blocks_sync_point	(*(struct))->(int)
(	O
z	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
->	O
state	*(struct)
->	O
blocks	*(struct(int))
)	O
;	O
}	O
