EChar	char
Buffer	array(char)
[	O
1024	int
]	O
;	O
EUint32	long
n_palloc	long
=	O
0	int
;	O
EUint32	long
n_pget	long
=	O
0	int
;	O
EUint32	long
n_pfree	long
=	O
0	int
;	O
EUint32	long
n_prealloc	long
=	O
0	int
;	O
static	O
int	O
_sally	int
=	O
-	O
1	int
;	O
static	O
int	O
initialised	int
=	O
0	int
;	O
int	O
sally_offset	int
=	O
0	int
;	O
int	O
sally_len	int
=	O
0	int
;	O
int	O
_edma_sally_init	()->(int)
(	O
)	O
{	O
int	O
len	int
;	O
struct	O
sockaddr_un	struct(short,array(char))
remote	struct(short,array(char))
;	O
initialised	int
=	O
1	int
;	O
if	O
(	O
_sally	int
>=	O
0	int
)	O
return	O
_sally	int
;	O
if	O
(	O
(	O
_sally	int
=	O
socket	(int,int,int)->(int)
(	O
AF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
"socket"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
printf	(*(char))->(int)
(	O
"Trying to connect to EDMA Shared Allocator Agent ..."	*(char)
)	O
;	O
remote	struct(short,array(char))
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
remote	struct(short,array(char))
.	O
sun_path	array(char)
,	O
SOCK_PATH	*(char)
)	O
;	O
len	int
=	O
strlen	(*(char))->(int)
(	O
remote	struct(short,array(char))
.	O
sun_path	array(char)
)	O
+	O
sizeof	O
(	O
remote	struct(short,array(char))
.	O
sun_family	short
)	O
;	O
if	O
(	O
connect	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
_sally	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
remote	struct(short,array(char))
,	O
len	int
)	O
==	O
-	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
"connect"	*(char)
)	O
;	O
close	(int)->(int)
(	O
_sally	int
)	O
;	O
_sally	int
=	O
-	O
1	int
;	O
printf	(*(char))->(int)
(	O
"\n-- Connection failed. Falling back to local shared memory "	*(char)
"allocator...\n"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
printf	(*(char))->(int)
(	O
" CONNECTED\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"++ Using Sally Shared Allocator\n"	*(char)
)	O
;	O
return	O
_sally	int
;	O
}	O
key_t	int
_sally_shm_alloc	(*(char),int)->(int)
(	O
char	O
*	O
n	*(char)
,	O
int	O
size	int
)	O
{	O
char	O
buffer	array(char)
[	O
1024	int
]	O
;	O
key_t	int
_the_key	int
;	O
int	O
len	int
;	O
len	int
=	O
snprintf	(*(char),int,*(char))->(int)
(	O
buffer	array(char)
,	O
1024	int
,	O
"SALLOC %d %s\n"	*(char)
,	O
size	int
,	O
n	*(char)
)	O
;	O
write	(int,*(void),int)->(int)
(	O
_sally	int
,	O
buffer	array(char)
,	O
len	int
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
buffer	array(char)
,	O
0	int
,	O
1024	int
)	O
;	O
len	int
=	O
read	(int,*(void),int)->(int)
(	O
_sally	int
,	O
buffer	array(char)
,	O
1024	int
)	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
buffer	array(char)
,	O
"+SALLOC %d\n"	*(char)
,	O
&	O
_the_key	int
)	O
;	O
return	O
_the_key	int
;	O
}	O
HMEM	long
EDMAPROC	O
edma_salloc	(long,*(char))->(long)
(	O
EUint32	long
size	int
,	O
EPChar	*(char)
n	*(char)
)	O
{	O
EUint32	long
a	long
,	O
shmflg	long
,	O
f	long
;	O
EChar	char
name	array(char)
[	O
EDMA_PATH_LEN	int
]	O
;	O
key_t	int
k	int
;	O
if	O
(	O
!	O
initialised	int
&&	O
_sally	int
<	O
0	int
)	O
{	O
_edma_sally_init	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
_sally	int
>	O
0	int
)	O
{	O
k	int
=	O
_sally_shm_alloc	(*(char),int)->(int)
(	O
n	*(char)
,	O
size	int
)	O
;	O
}	O
else	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
name	array(char)
,	O
EDMA_PATH_LEN	int
,	O
"%s/%s"	*(char)
,	O
TMPDIR	*(char)
,	O
n	*(char)
)	O
;	O
f	long
=	O
open	(*(char),int)->(int)
(	O
name	array(char)
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
)	O
;	O
if	O
(	O
f	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EEXIST	int
)	O
{	O
perror	(*(char))->(void)
(	O
"Create File"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
chmod	(*(char),int)->(int)
(	O
name	array(char)
,	O
S_IRWXU	O
|	O
S_IRWXG	O
|	O
S_IRWXO	O
)	O
;	O
if	O
(	O
(	O
k	int
=	O
ftok	(*(char),int)->(int)
(	O
name	array(char)
,	O
0	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
"[edma_salloc] (ftok)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
shmflg	long
=	O
0	int
;	O
a	long
=	O
shmget	(int,int,int)->(int)
(	O
k	int
,	O
size	int
,	O
IPC_CREAT	int
|	O
0777	int
)	O
;	O
if	O
(	O
(	O
a	long
==	O
-	O
1	int
)	O
&&	O
(	O
errno	O
!=	O
EEXIST	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\n[edma_salloc] ERROR in shared block : %s (key:%d|size:%ld)"	*(char)
,	O
name	array(char)
,	O
k	int
,	O
size	int
)	O
;	O
printf	(*(char))->(int)
(	O
"\n "	*(char)
)	O
;	O
perror	(*(char))->(void)
(	O
"[edma_salloc] (shmget):"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
_sally	int
<=	O
0	int
)	O
close	(int)->(int)
(	O
f	long
)	O
;	O
return	O
(	O
(	O
HMEM	long
)	O
a	long
)	O
;	O
}	O
EPVoid	*(void)
EDMAPROC	O
edma_sget	(long)->(*(void))
(	O
HMEM	long
a	long
)	O
{	O
EPVoid	*(void)
p	*(void)
;	O
p	*(void)
=	O
shmat	(int,*(void),int)->(*(void))
(	O
(	O
EUint32	long
)	O
a	long
,	O
0	int
,	O
SHM_RND	int
)	O
;	O
if	O
(	O
(	O
int	O
)	O
p	*(void)
==	O
-	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
"[edma_sget] :"	*(char)
)	O
;	O
return	O
(	O
EPVoid	*(void)
)	O
-	O
1	int
;	O
}	O
return	O
p	*(void)
;	O
}	O
EPVoid	*(void)
EDMAPROC	O
edma_sunget	(*(void))->(*(void))
(	O
EPVoid	*(void)
p	*(void)
)	O
{	O
EUint32	long
i	long
;	O
i	long
=	O
shmdt	(*(void))->(int)
(	O
p	*(void)
)	O
;	O
if	O
(	O
i	long
==	O
-	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
"[edma_sunget] :"	*(char)
)	O
;	O
return	O
(	O
EPVoid	*(void)
)	O
-	O
1	int
;	O
}	O
return	O
p	*(void)
;	O
}	O
void	O
EDMAPROC	O
edma_sfree	(long,*(void))->(void)
(	O
HMEM	long
i	long
,	O
EPVoid	*(void)
p	*(void)
)	O
{	O
ESint32	long
a	long
;	O
struct	O
shmid_ds	struct(struct(int,int,int,int,int,int,short,short,long,long),int,long,long,long,long,long,long,int,int,long,long,long)
buf	struct(struct(int,int,int,int,int,int,short,short,long,long),int,long,long,long,long,long,long,int,int,long,long,long)
;	O
if	O
(	O
_sally	int
<	O
0	int
)	O
{	O
a	long
=	O
shmctl	(int,int,*(struct(struct(int,int,int,int,int,int,short,short,long,long),int,long,long,long,long,long,long,int,int,long,long,long)))->(int)
(	O
i	long
,	O
IPC_RMID	int
,	O
&	O
buf	struct(struct(int,int,int,int,int,int,short,short,long,long),int,long,long,long,long,long,long,int,int,long,long,long)
)	O
;	O
if	O
(	O
a	long
==	O
-	O
1	int
)	O
{	O
perror	(*(char))->(void)
(	O
"[edma_sfree] (IPC_RMID):"	*(char)
)	O
;	O
return	O
;	O
}	O
}	O
}	O
HMEM	long
EDMAPROC	O
edma_palloc	(long)->(long)
(	O
EUint32	long
size	int
)	O
{	O
EPVoid	*(void)
p	*(void)
;	O
EPChar	*(char)
t	*(char)
;	O
EUint32	long
i	long
;	O
p	*(void)
=	O
malloc	(int)->(*(void))
(	O
size	int
)	O
;	O
t	*(char)
=	O
(	O
EPChar	*(char)
)	O
p	*(void)
;	O
if	O
(	O
p	*(void)
!=	O
NULL	O
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
size	int
;	O
i	long
++	O
)	O
*	O
(	O
t	*(char)
+	O
i	long
)	O
=	O
0	int
;	O
n_palloc	long
++	O
;	O
return	O
(	O
(	O
HMEM	long
)	O
p	*(void)
)	O
;	O
}	O
HMEM	long
EDMAPROC	O
edma_prealloc	(long,long)->(long)
(	O
HMEM	long
a	long
,	O
EUint32	long
new_size	long
)	O
{	O
if	O
(	O
a	long
==	O
0	int
)	O
n_palloc	long
++	O
;	O
else	O
n_prealloc	long
++	O
;	O
a	long
=	O
(	O
HMEM	long
)	O
realloc	(*(void),int)->(*(void))
(	O
(	O
EPVoid	*(void)
)	O
a	long
,	O
new_size	long
)	O
;	O
return	O
a	long
;	O
}	O
EPVoid	*(void)
EDMAPROC	O
edma_pget	(long)->(*(void))
(	O
HMEM	long
a	long
)	O
{	O
n_pget	long
++	O
;	O
return	O
(	O
EPVoid	*(void)
)	O
a	long
;	O
}	O
void	O
EDMAPROC	O
edma_pfree	(long,*(void))->(void)
(	O
HMEM	long
a	long
,	O
EPVoid	*(void)
p	*(void)
)	O
{	O
n_pfree	long
++	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
return	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
void	O
EDMAPROC	O
edma_show_pmem	()->(void)
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
"palloc   : %ld times\n"	*(char)
,	O
n_palloc	long
)	O
;	O
printf	(*(char))->(int)
(	O
"pget     : %ld times\n"	*(char)
,	O
n_pget	long
)	O
;	O
printf	(*(char))->(int)
(	O
"prealloc : %ld times\n"	*(char)
,	O
n_prealloc	long
)	O
;	O
printf	(*(char))->(int)
(	O
"pfree    : %ld times\n"	*(char)
,	O
n_pfree	long
)	O
;	O
}	O
