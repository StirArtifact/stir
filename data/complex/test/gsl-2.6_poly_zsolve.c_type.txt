int	O
gsl_poly_complex_solve	(*(double),long,*(struct(long,*(double))),*(double))->(int)
(	O
const	O
double	O
*	O
a	double
,	O
size_t	long
n	int
,	O
gsl_poly_complex_workspace	struct(long,*(double))
*	O
w	array(double)
,	O
gsl_complex_packed_ptr	*(double)
z	double
)	O
{	O
int	O
status	int
;	O
double	O
*	O
m	*(double)
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"number of terms must be a positive integer"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"cannot solve for only one term"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
a	double
[	O
n	int
-	O
1	int
]	O
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"leading term of polynomial must be non-zero"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
w	array(double)
->	O
nc	long
!=	O
n	int
-	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"size of workspace does not match polynomial"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
m	*(double)
=	O
w	array(double)
->	O
matrix	*(double)
;	O
set_companion_matrix	(*(double),long,*(double))->(void)
(	O
a	double
,	O
n	int
-	O
1	int
,	O
m	*(double)
)	O
;	O
balance_companion_matrix	(*(double),long)->(void)
(	O
m	*(double)
,	O
n	int
-	O
1	int
)	O
;	O
status	int
=	O
qr_companion	(*(double),long,*(double))->(int)
(	O
m	*(double)
,	O
n	int
-	O
1	int
,	O
z	double
)	O
;	O
if	O
(	O
status	int
)	O
{	O
GSL_ERROR	O
(	O
"root solving qr method failed to converge"	*(char)
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
