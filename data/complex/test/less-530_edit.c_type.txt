public	O
int	O
fd0	int
=	O
0	int
;	O
extern	O
int	O
new_file	int
;	O
extern	O
int	O
errmsgs	int
;	O
extern	O
int	O
cbufs	int
;	O
extern	O
char	O
*	O
every_first_cmd	*(char)
;	O
extern	O
int	O
any_display	int
;	O
extern	O
int	O
force_open	int
;	O
extern	O
int	O
is_tty	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
IFILE	O
curr_ifile	*(void)
;	O
extern	O
IFILE	O
old_ifile	*(void)
;	O
extern	O
struct	O
scrpos	struct(long,int)
initial_scrpos	struct(long,int)
;	O
extern	O
void	O
*	O
ml_examine	*(void)
;	O
extern	O
char	O
openquote	char
;	O
extern	O
char	O
closequote	char
;	O
extern	O
int	O
logfile	int
;	O
extern	O
int	O
force_logfile	int
;	O
extern	O
char	O
*	O
namelogfile	*(char)
;	O
public	O
dev_t	long
curr_dev	long
;	O
public	O
ino_t	long
curr_ino	long
;	O
public	O
void	O
init_textlist	(*(struct(*(char),*(char))),*(char))->(void)
(	O
tlist	*(struct(*(char),*(char)))
,	O
str	*(char)
)	O
struct	O
textlist	struct(*(char),*(char))
*	O
tlist	*(struct(*(char),*(char)))
;	O
char	O
*	O
str	*(char)
;	O
{	O
char	O
*	O
s	*(char)
;	O
int	O
meta_quoted	int
=	O
0	int
;	O
int	O
delim_quoted	int
=	O
0	int
;	O
char	O
*	O
esc	*(char)
=	O
get_meta_escape	()->(*(char))
(	O
)	O
;	O
int	O
esclen	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
esc	*(char)
)	O
;	O
tlist	*(struct(*(char),*(char)))
->	O
string	*(char)
=	O
skipsp	(*(char))->(*(char))
(	O
str	*(char)
)	O
;	O
tlist	*(struct(*(char),*(char)))
->	O
endstring	*(char)
=	O
tlist	*(struct(*(char),*(char)))
->	O
string	*(char)
+	O
strlen	(*(char))->(long)
(	O
tlist	*(struct(*(char),*(char)))
->	O
string	*(char)
)	O
;	O
for	O
(	O
s	*(char)
=	O
str	*(char)
;	O
s	*(char)
<	O
tlist	*(struct(*(char),*(char)))
->	O
endstring	*(char)
;	O
s	*(char)
++	O
)	O
{	O
if	O
(	O
meta_quoted	int
)	O
{	O
meta_quoted	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
esclen	int
>	O
0	int
&&	O
s	*(char)
+	O
esclen	int
<	O
tlist	*(struct(*(char),*(char)))
->	O
endstring	*(char)
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
esc	*(char)
,	O
esclen	int
)	O
==	O
0	int
)	O
{	O
meta_quoted	int
=	O
1	int
;	O
s	*(char)
+=	O
esclen	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
delim_quoted	int
)	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
closequote	char
)	O
delim_quoted	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
openquote	char
)	O
delim_quoted	int
=	O
1	int
;	O
else	O
if	O
(	O
*	O
s	*(char)
==	O
' '	O
)	O
*	O
s	*(char)
=	O
'\0'	O
;	O
}	O
}	O
}	O
public	O
char	O
*	O
forw_textlist	(*(struct(*(char),*(char))),*(char))->(*(char))
(	O
tlist	*(struct(*(char),*(char)))
,	O
prev	*(char)
)	O
struct	O
textlist	struct(*(char),*(char))
*	O
tlist	*(struct(*(char),*(char)))
;	O
char	O
*	O
prev	*(char)
;	O
{	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
prev	*(char)
==	O
NULL	O
)	O
s	*(char)
=	O
tlist	*(struct(*(char),*(char)))
->	O
string	*(char)
;	O
else	O
s	*(char)
=	O
prev	*(char)
+	O
strlen	(*(char))->(long)
(	O
prev	*(char)
)	O
;	O
if	O
(	O
s	*(char)
>=	O
tlist	*(struct(*(char),*(char)))
->	O
endstring	*(char)
)	O
return	O
(	O
NULL	O
)	O
;	O
while	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
s	*(char)
>=	O
tlist	*(struct(*(char),*(char)))
->	O
endstring	*(char)
)	O
return	O
(	O
NULL	O
)	O
;	O
return	O
(	O
s	*(char)
)	O
;	O
}	O
public	O
char	O
*	O
back_textlist	(*(struct(*(char),*(char))),*(char))->(*(char))
(	O
tlist	*(struct(*(char),*(char)))
,	O
prev	*(char)
)	O
struct	O
textlist	struct(*(char),*(char))
*	O
tlist	*(struct(*(char),*(char)))
;	O
char	O
*	O
prev	*(char)
;	O
{	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
prev	*(char)
==	O
NULL	O
)	O
s	*(char)
=	O
tlist	*(struct(*(char),*(char)))
->	O
endstring	*(char)
;	O
else	O
if	O
(	O
prev	*(char)
<=	O
tlist	*(struct(*(char),*(char)))
->	O
string	*(char)
)	O
return	O
(	O
NULL	O
)	O
;	O
else	O
s	*(char)
=	O
prev	*(char)
-	O
1	int
;	O
while	O
(	O
*	O
s	*(char)
==	O
'\0'	O
)	O
s	*(char)
--	O
;	O
if	O
(	O
s	*(char)
<=	O
tlist	*(struct(*(char),*(char)))
->	O
string	*(char)
)	O
return	O
(	O
NULL	O
)	O
;	O
while	O
(	O
s	*(char)
[	O
-	O
1	int
]	O
!=	O
'\0'	O
&&	O
s	*(char)
>	O
tlist	*(struct(*(char),*(char)))
->	O
string	*(char)
)	O
s	*(char)
--	O
;	O
return	O
(	O
s	*(char)
)	O
;	O
}	O
static	O
void	O
close_pipe	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
pipefd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
pipefd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
return	O
;	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pipefd	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
close_file	()->(void)
(	O
)	O
{	O
struct	O
scrpos	struct(long,int)
scrpos	struct(long,int)
;	O
int	O
chflags	int
;	O
FILE	struct
*	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
altfilename	*(char)
;	O
if	O
(	O
curr_ifile	*(void)
==	O
NULL_IFILE	O
)	O
return	O
;	O
get_scrpos	(*(struct(long,int)),int)->(void)
(	O
&	O
scrpos	struct(long,int)
,	O
TOP	O
)	O
;	O
if	O
(	O
scrpos	struct(long,int)
.	O
pos	long
!=	O
NULL_POSITION	O
)	O
{	O
store_pos	(*(void),*(struct(long,int)))->(void)
(	O
curr_ifile	*(void)
,	O
&	O
scrpos	struct(long,int)
)	O
;	O
lastmark	()->(void)
(	O
)	O
;	O
}	O
chflags	int
=	O
ch_getflags	()->(int)
(	O
)	O
;	O
ch_close	()->(void)
(	O
)	O
;	O
altfilename	*(char)
=	O
get_altfilename	(*(void))->(*(char))
(	O
curr_ifile	*(void)
)	O
;	O
if	O
(	O
altfilename	*(char)
!=	O
NULL	O
)	O
{	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
get_altpipe	(*(void))->(*(void))
(	O
curr_ifile	*(void)
)	O
;	O
if	O
(	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
&&	O
!	O
(	O
chflags	int
&	O
CH_KEEPOPEN	int
)	O
)	O
{	O
close_pipe	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
set_altpipe	(*(void),*(void))->(void)
(	O
curr_ifile	*(void)
,	O
NULL	O
)	O
;	O
}	O
close_altfile	(*(char),*(char))->(void)
(	O
altfilename	*(char)
,	O
get_filename	(*(void))->(*(char))
(	O
curr_ifile	*(void)
)	O
)	O
;	O
set_altfilename	(*(void),*(char))->(void)
(	O
curr_ifile	*(void)
,	O
NULL	O
)	O
;	O
}	O
curr_ifile	*(void)
=	O
NULL_IFILE	O
;	O
curr_ino	long
=	O
curr_dev	long
=	O
0	int
;	O
}	O
public	O
int	O
edit	(*(char))->(int)
(	O
filename	*(char)
)	O
char	O
*	O
filename	*(char)
;	O
{	O
if	O
(	O
filename	*(char)
==	O
NULL	O
)	O
return	O
(	O
edit_ifile	(*(void))->(int)
(	O
NULL_IFILE	O
)	O
)	O
;	O
return	O
(	O
edit_ifile	(*(void))->(int)
(	O
get_ifile	(*(char),*(void))->(*(void))
(	O
filename	*(char)
,	O
curr_ifile	*(void)
)	O
)	O
)	O
;	O
}	O
public	O
int	O
edit_ifile	(*(void))->(int)
(	O
ifile	*(void)
)	O
IFILE	O
ifile	*(void)
;	O
{	O
int	O
f	int
;	O
int	O
answer	int
;	O
int	O
no_display	int
;	O
int	O
chflags	int
;	O
char	O
*	O
filename	*(char)
;	O
char	O
*	O
open_filename	*(char)
;	O
char	O
*	O
alt_filename	*(char)
;	O
void	O
*	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
IFILE	O
was_curr_ifile	*(void)
;	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
if	O
(	O
ifile	*(void)
==	O
curr_ifile	*(void)
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
end_logfile	()->(void)
(	O
)	O
;	O
was_curr_ifile	*(void)
=	O
save_curr_ifile	()->(*(void))
(	O
)	O
;	O
if	O
(	O
curr_ifile	*(void)
!=	O
NULL_IFILE	O
)	O
{	O
chflags	int
=	O
ch_getflags	()->(int)
(	O
)	O
;	O
close_file	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
chflags	int
&	O
CH_HELPFILE	int
)	O
&&	O
held_ifile	(*(void))->(int)
(	O
was_curr_ifile	*(void)
)	O
<=	O
1	int
)	O
{	O
del_ifile	(*(void))->(void)
(	O
was_curr_ifile	*(void)
)	O
;	O
was_curr_ifile	*(void)
=	O
old_ifile	*(void)
;	O
}	O
}	O
if	O
(	O
ifile	*(void)
==	O
NULL_IFILE	O
)	O
{	O
unsave_ifile	(*(void))->(void)
(	O
was_curr_ifile	*(void)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
filename	*(char)
=	O
save	(*(char))->(*(char))
(	O
get_filename	(*(void))->(*(char))
(	O
ifile	*(void)
)	O
)	O
;	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
get_altpipe	(*(void))->(*(void))
(	O
ifile	*(void)
)	O
;	O
if	O
(	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
chflags	int
=	O
0	int
;	O
f	int
=	O
-	O
1	int
;	O
alt_filename	*(char)
=	O
get_altfilename	(*(void))->(*(char))
(	O
ifile	*(void)
)	O
;	O
open_filename	*(char)
=	O
(	O
alt_filename	*(char)
!=	O
NULL	O
)	O
?	O
alt_filename	*(char)
:	O
filename	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
FAKE_HELPFILE	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
FAKE_EMPTYFILE	*(char)
)	O
==	O
0	int
)	O
alt_filename	*(char)
=	O
NULL	O
;	O
else	O
alt_filename	*(char)
=	O
open_altfile	(*(char),*(int),*(*(void)))->(*(char))
(	O
filename	*(char)
,	O
&	O
f	int
,	O
&	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
open_filename	*(char)
=	O
(	O
alt_filename	*(char)
!=	O
NULL	O
)	O
?	O
alt_filename	*(char)
:	O
filename	*(char)
;	O
chflags	int
=	O
0	int
;	O
if	O
(	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
chflags	int
|=	O
CH_POPENED	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
chflags	int
|=	O
CH_KEEPOPEN	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
f	int
=	O
fd0	int
;	O
chflags	int
|=	O
CH_KEEPOPEN	int
;	O
SET_BINARY	O
(	O
f	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
open_filename	*(char)
,	O
FAKE_EMPTYFILE	*(char)
)	O
==	O
0	int
)	O
{	O
f	int
=	O
-	O
1	int
;	O
chflags	int
|=	O
CH_NODATA	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
open_filename	*(char)
,	O
FAKE_HELPFILE	*(char)
)	O
==	O
0	int
)	O
{	O
f	int
=	O
-	O
1	int
;	O
chflags	int
|=	O
CH_HELPFILE	int
;	O
}	O
else	O
if	O
(	O
(	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
bad_file	(*(char))->(*(char))
(	O
open_filename	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"%s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
free	(*(void))->(void)
(	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
)	O
;	O
err1	O
:	O
if	O
(	O
alt_filename	*(char)
!=	O
NULL	O
)	O
{	O
close_pipe	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
close_altfile	(*(char),*(char))->(void)
(	O
alt_filename	*(char)
,	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
alt_filename	*(char)
)	O
;	O
}	O
del_ifile	(*(void))->(void)
(	O
ifile	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
if	O
(	O
was_curr_ifile	*(void)
==	O
ifile	*(void)
)	O
{	O
quit	(int)->(void)
(	O
QUIT_ERROR	int
)	O
;	O
}	O
reedit_ifile	(*(void))->(void)
(	O
was_curr_ifile	*(void)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
f	int
=	O
open	(*(char),int)->(int)
(	O
open_filename	*(char)
,	O
OPEN_READ	O
)	O
)	O
<	O
0	int
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
errno_message	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"%s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
free	(*(void))->(void)
(	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
)	O
;	O
goto	O
err1	O
;	O
}	O
else	O
{	O
chflags	int
|=	O
CH_CANSEEK	int
;	O
if	O
(	O
!	O
force_open	int
&&	O
!	O
opened	(*(void))->(int)
(	O
ifile	*(void)
)	O
&&	O
bin_file	(int)->(int)
(	O
f	int
)	O
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
filename	*(char)
;	O
answer	int
=	O
query	(*(char),*(union(*(char),int,long)))->(int)
(	O
"\"%s\" may be a binary file.  See it anyway? "	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
if	O
(	O
answer	int
!=	O
'y'	O
&&	O
answer	int
!=	O
'Y'	O
)	O
{	O
close	(int)->(int)
(	O
f	int
)	O
;	O
goto	O
err1	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
was_curr_ifile	*(void)
!=	O
NULL_IFILE	O
)	O
{	O
old_ifile	*(void)
=	O
was_curr_ifile	*(void)
;	O
unsave_ifile	(*(void))->(void)
(	O
was_curr_ifile	*(void)
)	O
;	O
}	O
curr_ifile	*(void)
=	O
ifile	*(void)
;	O
set_altfilename	(*(void),*(char))->(void)
(	O
curr_ifile	*(void)
,	O
alt_filename	*(char)
)	O
;	O
set_altpipe	(*(void),*(void))->(void)
(	O
curr_ifile	*(void)
,	O
altpipe	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
set_open	(*(void))->(void)
(	O
curr_ifile	*(void)
)	O
;	O
get_pos	(*(void),*(struct(long,int)))->(void)
(	O
curr_ifile	*(void)
,	O
&	O
initial_scrpos	struct(long,int)
)	O
;	O
new_file	int
=	O
TRUE	int
;	O
ch_init	(int,int)->(void)
(	O
f	int
,	O
chflags	int
)	O
;	O
if	O
(	O
!	O
(	O
chflags	int
&	O
CH_HELPFILE	int
)	O
)	O
{	O
if	O
(	O
namelogfile	*(char)
!=	O
NULL	O
&&	O
is_tty	int
)	O
use_logfile	(*(char))->(void)
(	O
namelogfile	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
open_filename	*(char)
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
r	int
=	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
open_filename	*(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
r	int
==	O
0	int
)	O
{	O
curr_ino	long
=	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
;	O
curr_dev	long
=	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
;	O
}	O
}	O
if	O
(	O
every_first_cmd	*(char)
!=	O
NULL	O
)	O
{	O
ungetcc	(long)->(void)
(	O
CHAR_END_COMMAND	int
)	O
;	O
ungetsc	(*(char))->(void)
(	O
every_first_cmd	*(char)
)	O
;	O
}	O
}	O
no_display	int
=	O
!	O
any_display	int
;	O
flush	()->(void)
(	O
)	O
;	O
any_display	int
=	O
TRUE	int
;	O
if	O
(	O
is_tty	int
)	O
{	O
pos_clear	()->(void)
(	O
)	O
;	O
clr_linenum	()->(void)
(	O
)	O
;	O
clr_hilite	()->(void)
(	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
FAKE_HELPFILE	*(char)
)	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
FAKE_EMPTYFILE	*(char)
)	O
)	O
cmd_addhist	(*(struct),*(char),int)->(void)
(	O
ml_examine	*(void)
,	O
filename	*(char)
,	O
1	int
)	O
;	O
if	O
(	O
no_display	int
&&	O
errmsgs	int
>	O
0	int
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
filename	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"%s"	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
public	O
int	O
edit_list	(*(char))->(int)
(	O
filelist	*(char)
)	O
char	O
*	O
filelist	*(char)
;	O
{	O
IFILE	O
save_ifile	*(void)
;	O
char	O
*	O
good_filename	*(char)
;	O
char	O
*	O
filename	*(char)
;	O
char	O
*	O
gfilelist	*(char)
;	O
char	O
*	O
gfilename	*(char)
;	O
char	O
*	O
qfilename	*(char)
;	O
struct	O
textlist	struct(*(char),*(char))
tl_files	struct(*(char),*(char))
;	O
struct	O
textlist	struct(*(char),*(char))
tl_gfiles	struct(*(char),*(char))
;	O
save_ifile	*(void)
=	O
save_curr_ifile	()->(*(void))
(	O
)	O
;	O
good_filename	*(char)
=	O
NULL	O
;	O
init_textlist	(*(struct(*(char),*(char))),*(char))->(void)
(	O
&	O
tl_files	struct(*(char),*(char))
,	O
filelist	*(char)
)	O
;	O
filename	*(char)
=	O
NULL	O
;	O
while	O
(	O
(	O
filename	*(char)
=	O
forw_textlist	(*(struct(*(char),*(char))),*(char))->(*(char))
(	O
&	O
tl_files	struct(*(char),*(char))
,	O
filename	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
gfilelist	*(char)
=	O
lglob	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
init_textlist	(*(struct(*(char),*(char))),*(char))->(void)
(	O
&	O
tl_gfiles	struct(*(char),*(char))
,	O
gfilelist	*(char)
)	O
;	O
gfilename	*(char)
=	O
NULL	O
;	O
while	O
(	O
(	O
gfilename	*(char)
=	O
forw_textlist	(*(struct(*(char),*(char))),*(char))->(*(char))
(	O
&	O
tl_gfiles	struct(*(char),*(char))
,	O
gfilename	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
qfilename	*(char)
=	O
shell_unquote	(*(char))->(*(char))
(	O
gfilename	*(char)
)	O
;	O
if	O
(	O
edit	(*(char))->(int)
(	O
qfilename	*(char)
)	O
==	O
0	int
&&	O
good_filename	*(char)
==	O
NULL	O
)	O
good_filename	*(char)
=	O
get_filename	(*(void))->(*(char))
(	O
curr_ifile	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
qfilename	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
gfilelist	*(char)
)	O
;	O
}	O
if	O
(	O
good_filename	*(char)
==	O
NULL	O
)	O
{	O
unsave_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
get_ifile	(*(char),*(void))->(*(void))
(	O
good_filename	*(char)
,	O
curr_ifile	*(void)
)	O
==	O
curr_ifile	*(void)
)	O
{	O
unsave_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
reedit_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
return	O
(	O
edit	(*(char))->(int)
(	O
good_filename	*(char)
)	O
)	O
;	O
}	O
public	O
int	O
edit_first	()->(int)
(	O
)	O
{	O
curr_ifile	*(void)
=	O
NULL_IFILE	O
;	O
return	O
(	O
edit_next	(int)->(int)
(	O
1	int
)	O
)	O
;	O
}	O
public	O
int	O
edit_last	()->(int)
(	O
)	O
{	O
curr_ifile	*(void)
=	O
NULL_IFILE	O
;	O
return	O
(	O
edit_prev	(int)->(int)
(	O
1	int
)	O
)	O
;	O
}	O
static	O
int	O
edit_istep	(*(void),int,int)->(int)
(	O
h	*(void)
,	O
n	int
,	O
dir	int
)	O
IFILE	O
h	*(void)
;	O
int	O
n	int
;	O
int	O
dir	int
;	O
{	O
IFILE	O
next	*(void)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
next	*(void)
=	O
(	O
dir	int
>	O
0	int
)	O
?	O
next_ifile	(*(void))->(*(void))
(	O
h	*(void)
)	O
:	O
prev_ifile	(*(void))->(*(void))
(	O
h	*(void)
)	O
;	O
if	O
(	O
--	O
n	int
<	O
0	int
)	O
{	O
if	O
(	O
edit_ifile	(*(void))->(int)
(	O
h	*(void)
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
next	*(void)
==	O
NULL_IFILE	O
)	O
{	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ABORT_SIGS	O
(	O
)	O
)	O
{	O
return	O
(	O
1	int
)	O
;	O
}	O
h	*(void)
=	O
next	*(void)
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
edit_inext	(*(void),int)->(int)
(	O
h	*(void)
,	O
n	int
)	O
IFILE	O
h	*(void)
;	O
int	O
n	int
;	O
{	O
return	O
(	O
edit_istep	(*(void),int,int)->(int)
(	O
h	*(void)
,	O
n	int
,	O
+	O
1	int
)	O
)	O
;	O
}	O
public	O
int	O
edit_next	(int)->(int)
(	O
n	int
)	O
int	O
n	int
;	O
{	O
return	O
edit_istep	(*(void),int,int)->(int)
(	O
curr_ifile	*(void)
,	O
n	int
,	O
+	O
1	int
)	O
;	O
}	O
static	O
int	O
edit_iprev	(*(void),int)->(int)
(	O
h	*(void)
,	O
n	int
)	O
IFILE	O
h	*(void)
;	O
int	O
n	int
;	O
{	O
return	O
(	O
edit_istep	(*(void),int,int)->(int)
(	O
h	*(void)
,	O
n	int
,	O
-	O
1	int
)	O
)	O
;	O
}	O
public	O
int	O
edit_prev	(int)->(int)
(	O
n	int
)	O
int	O
n	int
;	O
{	O
return	O
edit_istep	(*(void),int,int)->(int)
(	O
curr_ifile	*(void)
,	O
n	int
,	O
-	O
1	int
)	O
;	O
}	O
public	O
int	O
edit_index	(int)->(int)
(	O
n	int
)	O
int	O
n	int
;	O
{	O
IFILE	O
h	*(void)
;	O
h	*(void)
=	O
NULL_IFILE	O
;	O
do	O
{	O
if	O
(	O
(	O
h	*(void)
=	O
next_ifile	(*(void))->(*(void))
(	O
h	*(void)
)	O
)	O
==	O
NULL_IFILE	O
)	O
{	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
while	O
(	O
get_index	(*(void))->(int)
(	O
h	*(void)
)	O
!=	O
n	int
)	O
;	O
return	O
(	O
edit_ifile	(*(void))->(int)
(	O
h	*(void)
)	O
)	O
;	O
}	O
public	O
IFILE	O
save_curr_ifile	()->(*(void))
(	O
)	O
{	O
if	O
(	O
curr_ifile	*(void)
!=	O
NULL_IFILE	O
)	O
hold_ifile	(*(void),int)->(void)
(	O
curr_ifile	*(void)
,	O
1	int
)	O
;	O
return	O
(	O
curr_ifile	*(void)
)	O
;	O
}	O
public	O
void	O
unsave_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
IFILE	O
save_ifile	*(void)
;	O
{	O
if	O
(	O
save_ifile	*(void)
!=	O
NULL_IFILE	O
)	O
hold_ifile	(*(void),int)->(void)
(	O
save_ifile	*(void)
,	O
-	O
1	int
)	O
;	O
}	O
public	O
void	O
reedit_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
IFILE	O
save_ifile	*(void)
;	O
{	O
IFILE	O
next	*(void)
;	O
IFILE	O
prev	*(char)
;	O
unsave_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
next	*(void)
=	O
next_ifile	(*(void))->(*(void))
(	O
save_ifile	*(void)
)	O
;	O
prev	*(char)
=	O
prev_ifile	(*(void))->(*(void))
(	O
save_ifile	*(void)
)	O
;	O
if	O
(	O
edit_ifile	(*(void))->(int)
(	O
save_ifile	*(void)
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
next	*(void)
!=	O
NULL_IFILE	O
&&	O
edit_inext	(*(void),int)->(int)
(	O
next	*(void)
,	O
0	int
)	O
==	O
0	int
)	O
return	O
;	O
if	O
(	O
prev	*(char)
!=	O
NULL_IFILE	O
&&	O
edit_iprev	(*(void),int)->(int)
(	O
prev	*(char)
,	O
0	int
)	O
==	O
0	int
)	O
return	O
;	O
quit	(int)->(void)
(	O
QUIT_ERROR	int
)	O
;	O
}	O
public	O
void	O
reopen_curr_ifile	()->(void)
(	O
)	O
{	O
IFILE	O
save_ifile	*(void)
=	O
save_curr_ifile	()->(*(void))
(	O
)	O
;	O
close_file	()->(void)
(	O
)	O
;	O
reedit_ifile	(*(void))->(void)
(	O
save_ifile	*(void)
)	O
;	O
}	O
public	O
int	O
edit_stdin	()->(int)
(	O
)	O
{	O
if	O
(	O
isatty	(int)->(int)
(	O
fd0	int
)	O
)	O
{	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Missing filename (\"less --help\" for help)"	*(char)
,	O
NULL_PARG	O
)	O
;	O
quit	(int)->(void)
(	O
QUIT_OK	int
)	O
;	O
}	O
return	O
(	O
edit	(*(char))->(int)
(	O
"-"	*(char)
)	O
)	O
;	O
}	O
public	O
void	O
cat_file	()->(void)
(	O
)	O
{	O
int	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
ch_forw_get	()->(int)
(	O
)	O
)	O
!=	O
EOI	O
)	O
putchr	(int)->(int)
(	O
c	int
)	O
;	O
flush	()->(void)
(	O
)	O
;	O
}	O
public	O
void	O
use_logfile	(*(char))->(void)
(	O
filename	*(char)
)	O
char	O
*	O
filename	*(char)
;	O
{	O
int	O
exists	int
;	O
int	O
answer	int
;	O
PARG	union(*(char),int,long)
parg	union(*(char),int,long)
;	O
if	O
(	O
ch_getflags	()->(int)
(	O
)	O
&	O
CH_CANSEEK	int
)	O
return	O
;	O
exists	int
=	O
open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
OPEN_READ	O
)	O
;	O
if	O
(	O
exists	int
>=	O
0	int
)	O
close	(int)->(int)
(	O
exists	int
)	O
;	O
exists	int
=	O
(	O
exists	int
>=	O
0	int
)	O
;	O
if	O
(	O
!	O
exists	int
||	O
force_logfile	int
)	O
{	O
answer	int
=	O
'O'	O
;	O
}	O
else	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
filename	*(char)
;	O
answer	int
=	O
query	(*(char),*(union(*(char),int,long)))->(int)
(	O
"Warning: \"%s\" exists; Overwrite, Append or Don't log? "	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
}	O
loop	O
:	O
switch	O
(	O
answer	int
)	O
{	O
case	O
'O'	O
:	O
case	O
'o'	O
:	O
logfile	int
=	O
creat	(*(char),int)->(int)
(	O
filename	*(char)
,	O
0644	int
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
case	O
'a'	O
:	O
logfile	int
=	O
open	(*(char),int)->(int)
(	O
filename	*(char)
,	O
OPEN_APPEND	O
)	O
;	O
if	O
(	O
lseek	(int,long,int)->(long)
(	O
logfile	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_END	int
)	O
==	O
BAD_LSEEK	O
)	O
{	O
close	(int)->(int)
(	O
logfile	int
)	O
;	O
logfile	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'd'	O
:	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
;	O
case	O
'q'	O
:	O
quit	(int)->(void)
(	O
QUIT_OK	int
)	O
;	O
default	O
:	O
answer	int
=	O
query	(*(char),*(union(*(char),int,long)))->(int)
(	O
"Overwrite, Append, or Don't log? (Type \"O\", \"A\", \"D\" or \"q\") "	*(char)
,	O
NULL_PARG	O
)	O
;	O
goto	O
loop	O
;	O
}	O
if	O
(	O
logfile	int
<	O
0	int
)	O
{	O
parg	union(*(char),int,long)
.	O
p_string	*(char)
=	O
filename	*(char)
;	O
error	(*(char),*(union(*(char),int,long)))->(void)
(	O
"Cannot write to \"%s\""	*(char)
,	O
&	O
parg	union(*(char),int,long)
)	O
;	O
return	O
;	O
}	O
SET_BINARY	O
(	O
logfile	int
)	O
;	O
}	O
