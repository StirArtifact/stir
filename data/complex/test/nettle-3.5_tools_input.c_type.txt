void	O
sexp_input_init	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
=	O
NULL	O
;	O
}	O
static	O
void	O
sexp_get_raw_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
{	O
int	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
die	(*(char))->(void)
(	O
"Read error: %s\n"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
=	O
SEXP_EOF_CHAR	int
;	O
}	O
else	O
{	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
=	O
SEXP_NORMAL_CHAR	int
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
=	O
c	int
;	O
}	O
}	O
void	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
{	O
if	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
)	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
done	long
;	O
sexp_get_raw_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
if	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
==	O
SEXP_EOF_CHAR	int
)	O
die	(*(char))->(void)
(	O
"Unexpected end of file in coded data.\n"	*(char)
)	O
;	O
if	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
==	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
terminator	char
)	O
{	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
=	O
SEXP_END_CHAR	int
;	O
return	O
;	O
}	O
done	long
=	O
1	int
;	O
if	O
(	O
!	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
->	O
decode_update	*((*(void),*(long),*(char),long,*(char))->(int))
(	O
&	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
state	*(int)
,	O
&	O
done	long
,	O
&	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
,	O
1	int
,	O
(	O
const	O
char	O
*	O
)	O
&	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
)	O
die	(*(char))->(void)
(	O
"Invalid coded data.\n"	*(char)
)	O
;	O
if	O
(	O
done	long
)	O
return	O
;	O
}	O
else	O
sexp_get_raw_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
}	O
static	O
uint8_t	char
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
{	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
if	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
!=	O
SEXP_NORMAL_CHAR	int
)	O
die	(*(char))->(void)
(	O
"Unexpected end of file.\n"	*(char)
)	O
;	O
return	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
;	O
}	O
static	O
void	O
sexp_push_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
struct	O
nettle_buffer	struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long)
*	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
{	O
assert	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
==	O
SEXP_NORMAL_CHAR	int
)	O
;	O
if	O
(	O
!	O
NETTLE_BUFFER_PUTC	O
(	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
,	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
)	O
die	(*(char))->(void)
(	O
"Virtual memory exhasuted.\n"	*(char)
)	O
;	O
}	O
static	O
void	O
sexp_input_start_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),char)->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
const	O
struct	O
nettle_armor	struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))
*	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
,	O
uint8_t	char
terminator	char
)	O
{	O
assert	O
(	O
!	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
)	O
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
=	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
->	O
decode_init	*((*(void))->(void))
(	O
&	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
state	*(int)
)	O
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
terminator	char
=	O
terminator	char
;	O
}	O
static	O
void	O
sexp_input_end_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
{	O
assert	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
)	O
;	O
if	O
(	O
!	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
->	O
decode_final	*((*(void))->(int))
(	O
&	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
state	*(int)
)	O
)	O
die	(*(char))->(void)
(	O
"Invalid coded data.\n"	*(char)
)	O
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
=	O
NULL	O
;	O
}	O
static	O
int	O
sexp_get_quoted_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(int)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
{	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
switch	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
{	O
default	O
:	O
return	O
1	int
;	O
case	O
'\"'	O
:	O
return	O
0	int
;	O
case	O
'\\'	O
:	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
switch	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
{	O
case	O
'b'	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
=	O
'\b'	O
;	O
return	O
1	int
;	O
case	O
't'	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
=	O
'\t'	O
;	O
return	O
1	int
;	O
case	O
'n'	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
=	O
'\n'	O
;	O
return	O
1	int
;	O
case	O
'f'	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
=	O
'\f'	O
;	O
return	O
1	int
;	O
case	O
'r'	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
=	O
'\r'	O
;	O
return	O
1	int
;	O
case	O
'\\'	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
=	O
'\\'	O
;	O
return	O
1	int
;	O
case	O
'o'	O
:	O
case	O
'x'	O
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
'\n'	O
:	O
if	O
(	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
==	O
'\r'	O
)	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
break	O
;	O
case	O
'\r'	O
:	O
if	O
(	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
==	O
'\n'	O
)	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
}	O
static	O
void	O
sexp_get_token_string	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
struct	O
nettle_buffer	struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long)
*	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
{	O
assert	O
(	O
!	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
coding	*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int))))
)	O
;	O
assert	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
==	O
SEXP_NORMAL_CHAR	int
)	O
;	O
if	O
(	O
!	O
TOKEN_CHAR	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
)	O
die	(*(char))->(void)
(	O
"Invalid token.\n"	*(char)
)	O
;	O
do	O
{	O
sexp_push_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
}	O
while	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
==	O
SEXP_NORMAL_CHAR	int
&&	O
TOKEN_CHAR	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
)	O
;	O
assert	O
(	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
->	O
size	long
)	O
;	O
}	O
static	O
void	O
sexp_get_string	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
struct	O
nettle_buffer	struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long)
*	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
{	O
nettle_buffer_reset	(*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_STRING	int
;	O
switch	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
{	O
case	O
'\"'	O
:	O
while	O
(	O
sexp_get_quoted_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(int)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
)	O
sexp_push_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
break	O
;	O
case	O
'#'	O
:	O
sexp_input_start_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),char)->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
&	O
nettle_base16	struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))
,	O
'#'	O
)	O
;	O
goto	O
decode	O
;	O
case	O
'|'	O
:	O
sexp_input_start_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),char)->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
&	O
nettle_base64	struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))
,	O
'|'	O
)	O
;	O
decode	O
:	O
for	O
(	O
;	O
;	O
)	O
{	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
switch	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
)	O
{	O
case	O
SEXP_NORMAL_CHAR	int
:	O
sexp_push_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
break	O
;	O
case	O
SEXP_EOF_CHAR	int
:	O
die	(*(char))->(void)
(	O
"Unexpected end of file in coded string.\n"	*(char)
)	O
;	O
case	O
SEXP_END_CHAR	int
:	O
sexp_input_end_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
return	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
sexp_get_token_string	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
sexp_get_string_length	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),enum(int,int,int),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
enum	O
sexp_mode	enum(int,int,int)
mode	enum(int,int,int)
,	O
struct	O
nettle_buffer	struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long)
*	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
{	O
unsigned	O
length	long
;	O
nettle_buffer_reset	(*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_STRING	int
;	O
length	long
=	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
-	O
'0'	O
;	O
if	O
(	O
!	O
length	long
)	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
else	O
{	O
assert	O
(	O
length	long
<	O
10	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
if	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
<	O
'0'	O
||	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
>	O
'9'	O
)	O
break	O
;	O
length	long
=	O
length	long
*	O
10	int
+	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
-	O
'0'	O
;	O
}	O
}	O
if	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
==	O
':'	O
)	O
for	O
(	O
;	O
length	long
;	O
length	long
--	O
)	O
{	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
sexp_push_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
}	O
else	O
if	O
(	O
mode	enum(int,int,int)
!=	O
SEXP_ADVANCED	int
)	O
die	(*(char))->(void)
(	O
"Encountered advanced string in canonical mode.\n"	*(char)
)	O
;	O
else	O
switch	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
{	O
case	O
'"'	O
:	O
for	O
(	O
;	O
length	long
;	O
length	long
--	O
)	O
if	O
(	O
sexp_get_quoted_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(int)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
)	O
sexp_push_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
else	O
die	(*(char))->(void)
(	O
"Unexpected end of string.\n"	*(char)
)	O
;	O
if	O
(	O
sexp_get_quoted_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(int)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
)	O
die	(*(char))->(void)
(	O
"Quoted string longer than expected.\n"	*(char)
)	O
;	O
break	O
;	O
case	O
'#'	O
:	O
sexp_input_start_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),char)->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
&	O
nettle_base16	struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))
,	O
'#'	O
)	O
;	O
goto	O
decode	O
;	O
case	O
'|'	O
:	O
sexp_input_start_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),char)->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
&	O
nettle_base64	struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))
,	O
'|'	O
)	O
;	O
decode	O
:	O
for	O
(	O
;	O
length	long
;	O
length	long
--	O
)	O
{	O
sexp_next_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(char)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
sexp_push_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
}	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
if	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
!=	O
SEXP_END_CHAR	int
)	O
die	(*(char))->(void)
(	O
"Coded string too long.\n"	*(char)
)	O
;	O
sexp_input_end_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
break	O
;	O
default	O
:	O
die	(*(char))->(void)
(	O
"Invalid string.\n"	*(char)
)	O
;	O
}	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
}	O
static	O
void	O
sexp_get_comment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
struct	O
nettle_buffer	struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long)
*	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
{	O
nettle_buffer_reset	(*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
assert	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
==	O
SEXP_NORMAL_CHAR	int
)	O
;	O
assert	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
==	O
';'	O
)	O
;	O
do	O
{	O
sexp_push_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
sexp_get_raw_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
}	O
while	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
==	O
SEXP_NORMAL_CHAR	int
&&	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
!=	O
'\n'	O
)	O
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_COMMENT	int
;	O
}	O
void	O
sexp_get_token	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),enum(int,int,int),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
struct	O
sexp_input	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))
*	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
enum	O
sexp_mode	enum(int,int,int)
mode	enum(int,int,int)
,	O
struct	O
nettle_buffer	struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long)
*	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
{	O
for	O
(	O
;	O
;	O
)	O
switch	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
ctype	enum(int,int,int)
)	O
{	O
case	O
SEXP_EOF_CHAR	int
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_EOF	int
;	O
return	O
;	O
case	O
SEXP_END_CHAR	int
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_CODING_END	int
;	O
sexp_input_end_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
return	O
;	O
case	O
SEXP_NORMAL_CHAR	int
:	O
switch	O
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
c	int
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
sexp_get_string_length	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),enum(int,int,int),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
mode	enum(int,int,int)
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
return	O
;	O
case	O
'('	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_LIST_START	int
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
return	O
;	O
case	O
')'	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_LIST_END	int
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
return	O
;	O
case	O
'['	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_DISPLAY_START	int
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
return	O
;	O
case	O
']'	O
:	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_DISPLAY_END	int
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
return	O
;	O
case	O
'{'	O
:	O
if	O
(	O
mode	enum(int,int,int)
==	O
SEXP_CANONICAL	int
)	O
die	(*(char))->(void)
(	O
"Unexpected transport data in canonical mode.\n"	*(char)
)	O
;	O
sexp_input_start_coding	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),char)->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
&	O
nettle_base64	struct(*(char),int,int,int,*((*(void))->(void)),*((long)->(long)),*((*(void),*(char),long,*(char))->(long)),*((*(void),*(char))->(long)),*((*(void))->(void)),*((long)->(long)),*((*(void),*(long),*(char),long,*(char))->(int)),*((*(void))->(int)))
,	O
'}'	O
)	O
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
->	O
token	enum(int,int,int,int,int,int,int,int,int,int)
=	O
SEXP_TRANSPORT_START	int
;	O
return	O
;	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
if	O
(	O
mode	enum(int,int,int)
==	O
SEXP_CANONICAL	int
)	O
die	(*(char))->(void)
(	O
"Whitespace encountered in canonical mode.\n"	*(char)
)	O
;	O
sexp_get_char	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
)	O
;	O
break	O
;	O
case	O
';'	O
:	O
if	O
(	O
mode	enum(int,int,int)
==	O
SEXP_CANONICAL	int
)	O
die	(*(char))->(void)
(	O
"Comment encountered in canonical mode.\n"	*(char)
)	O
;	O
sexp_get_comment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
return	O
;	O
default	O
:	O
if	O
(	O
mode	enum(int,int,int)
!=	O
SEXP_ADVANCED	int
)	O
die	(*(char))->(void)
(	O
"Encountered advanced string in canonical mode.\n"	*(char)
)	O
;	O
sexp_get_string	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),enum(int,int,int),char,*(struct(*`,int,int,int,*`,*`,*`,*`,*`,*`,*`,*`)),union(struct(*`,short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int))),*(struct(*(char),long,*(void),*((*`,*`,long)->(*`)),long)))->(void)
(	O
input	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),enum(int,int,int),char,*(struct(*(char),int,int,int,*((*`)->(void)),*((long)->(long)),*((*`,*`,long,*`)->(long)),*((*`,*`)->(long)),*((*`)->(void)),*((long)->(long)),*((*`,*`,*`,long,*`)->(int)),*((*`)->(int)))),union(struct(*(char),short,char,char),struct(char,char)),char,enum(int,int,int,int,int,int,int,int,int,int)))
,	O
string	*(struct(*(char),long,*(void),*((*(void),*(void),long)->(*(void))),long))
)	O
;	O
return	O
;	O
}	O
}	O
}	O
