static	O
struct	O
{	O
int	O
code	char
;	O
char	O
*	O
name	*(char)
;	O
}	O
enc_7bit_ascii_fise	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
'{'	O
,	O
"adieresis"	*(char)
}	O
,	O
{	O
'|'	O
,	O
"odieresis"	*(char)
}	O
,	O
{	O
'}'	O
,	O
"aring"	*(char)
}	O
,	O
{	O
'['	O
,	O
"Adieresis"	*(char)
}	O
,	O
{	O
'\\'	O
,	O
"Odieresis"	*(char)
}	O
,	O
{	O
']'	O
,	O
"Aring"	*(char)
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
,	O
}	O
;	O
static	O
struct	O
{	O
int	O
code	char
;	O
char	O
*	O
name	*(char)
;	O
}	O
enc_7bit_ascii_dkno	array(struct(int,*(char)))
[	O
]	O
=	O
{	O
{	O
'{'	O
,	O
"ae"	*(char)
}	O
,	O
{	O
'|'	O
,	O
"oslash"	*(char)
}	O
,	O
{	O
'}'	O
,	O
"aring"	*(char)
}	O
,	O
{	O
'['	O
,	O
"AE"	*(char)
}	O
,	O
{	O
'\\'	O
,	O
"Oslash"	*(char)
}	O
,	O
{	O
']'	O
,	O
"Aring"	*(char)
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
,	O
}	O
;	O
int	O
read_config	(*(char),*(char))->(int)
(	O
char	O
*	O
path	*(char)
,	O
char	O
*	O
file	*(char)
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
Buffer	struct(*(char),long,long)
fname	*(char)
;	O
char	O
buf	*(char)
[	O
4096	int
]	O
;	O
char	O
*	O
token	*(char)
,	O
*	O
token2	*(char)
;	O
int	O
line	int
=	O
0	int
;	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fname	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fname	*(char)
,	O
path	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fname	*(char)
,	O
"/"	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fname	*(char)
,	O
file	*(char)
)	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fname	*(char)
)	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fname	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
line	int
++	O
;	O
if	O
(	O
buf	*(char)
[	O
0	int
]	O
==	O
'#'	O
)	O
continue	O
;	O
token	*(char)
=	O
GET_TOKEN	O
(	O
buf	*(char)
)	O
;	O
if	O
(	O
token	*(char)
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"AcceptCompositeCharacters:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
accept_composites	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"AFMPath:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
afm_path	*(char)
)	O
;	O
afm_path	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"AppendCtrlD:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
append_ctrl_D	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"Clean7Bit:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
clean_7bit	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"DefaultEncoding:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
encoding_name	*(char)
)	O
;	O
encoding_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"DefaultFancyHeader:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
fancy_header_default	*(char)
)	O
;	O
fancy_header_default	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"DefaultMedia:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
media_name	*(char)
)	O
;	O
media_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"DefaultOutputMethod:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
if	O
(	O
MATCH	O
(	O
token2	*(char)
,	O
"printer"	*(char)
)	O
)	O
output_file	*(char)
=	O
OUTPUT_FILE_NONE	O
;	O
else	O
if	O
(	O
MATCH	O
(	O
token2	*(char)
,	O
"stdout"	*(char)
)	O
)	O
output_file	*(char)
=	O
OUTPUT_FILE_STDOUT	O
;	O
else	O
CFG_FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal value \"%s\" for option %s"	*(char)
)	O
,	O
token2	*(char)
,	O
token	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"DownloadFont:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
download_fonts	*(struct)
,	O
token2	*(char)
,	O
strlen	(*(char))->(long)
(	O
token2	*(char)
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"EscapeChar:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
escape_char	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
if	O
(	O
escape_char	int
<	O
0	int
||	O
escape_char	int
>	O
255	int
)	O
CFG_FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"invalid value \"%s\" for option %s"	*(char)
)	O
,	O
token2	*(char)
,	O
token	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"FormFeedType:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
if	O
(	O
MATCH	O
(	O
token2	*(char)
,	O
"column"	*(char)
)	O
)	O
formfeed_type	enum(int,int,int)
=	O
FORMFEED_COLUMN	int
;	O
else	O
if	O
(	O
MATCH	O
(	O
token2	*(char)
,	O
"page"	*(char)
)	O
)	O
formfeed_type	enum(int,int,int)
=	O
FORMFEED_PAGE	int
;	O
else	O
CFG_FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal value \"%s\" for option %s"	*(char)
)	O
,	O
token2	*(char)
,	O
token	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"GeneratePageSize:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
generate_PageSize	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"HighlightBarGray:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
highlight_bar_gray	double
=	O
atof	(*(char))->(double)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"HighlightBars:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
highlight_bars	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"LibraryPath:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
libpath	*(char)
)	O
;	O
libpath	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"MarkWrappedLines:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
mark_wrapped_lines_style_name	*(char)
)	O
;	O
mark_wrapped_lines_style_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"Media:"	*(char)
)	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
w	int
,	O
h	int
,	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
;	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
name	*(char)
=	O
token2	*(char)
;	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
w	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
h	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
llx	double
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
lly	double
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
urx	double
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
ury	double
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
add_media	(*(char),int,int,int,int,int,int)->(void)
(	O
name	*(char)
,	O
w	int
,	O
h	int
,	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"NoJobHeaderSwitch:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
no_job_header_switch	*(char)
)	O
;	O
no_job_header_switch	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"NonPrintableFormat:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
npf_name	*(char)
)	O
;	O
npf_name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"OutputFirstLine:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
output_first_line	*(char)
)	O
;	O
output_first_line	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"PageLabelFormat:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
page_label_format	*(char)
)	O
;	O
page_label_format	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"PagePrefeed:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
page_prefeed	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"PostScriptLevel:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
pslevel	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"Printer:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
printer	*(char)
)	O
;	O
printer	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"QueueParam:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
queue_param	*(char)
)	O
;	O
queue_param	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"SetPageDevice:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
parse_key_value_pair	(*(struct),*(char))->(void)
(	O
pagedevice	*(struct)
,	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"Spooler:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
spooler_command	*(char)
)	O
;	O
spooler_command	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"StatesBinary:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
states_binary	*(char)
)	O
;	O
states_binary	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"StatesColor:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
states_color	int
=	O
atoi	(*(char))->(int)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"StatesConfigFile:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
states_config_file	*(char)
)	O
;	O
states_config_file	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"StatesHighlightStyle:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
states_highlight_style	*(char)
)	O
;	O
states_highlight_style	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"StatesPath:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
states_path	*(char)
)	O
;	O
states_path	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"StatusDict:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
parse_key_value_pair	(*(struct),*(char))->(void)
(	O
statusdict	*(struct)
,	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"TOCFormat:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
toc_fmt_string	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"Underlay:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_LINE_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
underlay	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
token2	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
underlay	*(char)
,	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"UnderlayAngle:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
ul_angle	double
=	O
atof	(*(char))->(double)
(	O
token2	*(char)
)	O
;	O
ul_angle_p	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"UnderlayFont:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
if	O
(	O
!	O
parse_font_spec	(*(char),*(*(char)),*(struct(double,double)),*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))->(int)
(	O
token2	*(char)
,	O
&	O
ul_font	*(char)
,	O
&	O
ul_ptsize	struct(double,double)
,	O
NULL	O
)	O
)	O
CFG_FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"malformed font spec: %s"	*(char)
)	O
,	O
token2	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"UnderlayGray:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
ul_gray	double
=	O
atof	(*(char))->(double)
(	O
token2	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"UnderlayPosition:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
ul_position	*(char)
)	O
;	O
ul_position	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
ul_position_p	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
MATCH	O
(	O
token	*(char)
,	O
"UnderlayStyle:"	*(char)
)	O
)	O
{	O
token2	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
CHECK_TOKEN	O
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
ul_style_str	*(char)
)	O
;	O
ul_style_str	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
token2	*(char)
)	O
;	O
}	O
else	O
CFG_FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"illegal option: %s"	*(char)
)	O
,	O
token	*(char)
)	O
)	O
;	O
}	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fname	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
void	O
add_media	(*(char),int,int,int,int,int,int)->(void)
(	O
char	O
*	O
name	*(char)
,	O
int	O
w	int
,	O
int	O
h	int
,	O
int	O
llx	double
,	O
int	O
lly	double
,	O
int	O
urx	double
,	O
int	O
ury	double
)	O
{	O
MediaEntry	struct(*(struct(*(struct(*`,*`,int,int,int,int,int,int)),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int)
*	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"add_media: name=%s, w=%d, h=%d, llx=%d, lly=%d, urx=%d, ury=%d\n"	*(char)
,	O
name	*(char)
,	O
w	int
,	O
h	int
,	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
)	O
)	O
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
)	O
)	O
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
name	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
name	*(char)
,	O
name	*(char)
)	O
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
w	int
=	O
w	int
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
h	int
=	O
h	int
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
llx	double
=	O
llx	double
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
lly	double
=	O
lly	double
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
urx	double
=	O
urx	double
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
ury	double
=	O
ury	double
;	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
media_names	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
media_names	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
=	O
entry	*(struct(*(struct(*(struct`),*(char),int,int,int,int,int,int)),*(char),int,int,int,int,int,int))
;	O
}	O
void	O
do_list_missing_characters	(*(int))->(void)
(	O
int	O
*	O
array	*(struct)
)	O
{	O
int	O
i	int
;	O
int	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
if	O
(	O
array	*(struct)
[	O
i	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%3d "	*(char)
,	O
i	int
)	O
;	O
count	int
++	O
;	O
if	O
(	O
count	int
%	O
15	int
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
count	int
%	O
15	int
!=	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
int	O
file_existsp	(*(char),*(char))->(int)
(	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
suffix	*(char)
)	O
{	O
FileLookupCtx	struct(*(char),*(char),*(struct(*(char),long,long)))
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
;	O
int	O
result	int
;	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
name	*(char)
=	O
name	*(char)
;	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
suffix	*(char)
=	O
suffix	*(char)
?	O
suffix	*(char)
:	O
""	*(char)
;	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
=	O
buffer_alloc	()->(*(struct(*(char),long,long)))
(	O
)	O
;	O
result	int
=	O
pathwalk	(*(char),*((*(char),*(void))->(int)),*(void))->(int)
(	O
libpath	*(char)
,	O
file_lookup	(*(char),*(void))->(int)
,	O
&	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
)	O
;	O
buffer_free	(*(struct(*(char),long,long)))->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
;	O
return	O
result	int
;	O
}	O
int	O
paste_file	(*(char),*(char))->(int)
(	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
suffix	*(char)
)	O
{	O
char	O
buf	*(char)
[	O
512	int
]	O
;	O
char	O
resources	array(char)
[	O
512	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
FileLookupCtx	struct(*(char),*(char),*(struct(*(char),long,long)))
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
;	O
int	O
pending_comment	int
=	O
0	int
;	O
int	O
line	int
=	O
0	int
;	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
name	*(char)
=	O
name	*(char)
;	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
suffix	*(char)
=	O
suffix	*(char)
?	O
suffix	*(char)
:	O
""	*(char)
;	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
=	O
buffer_alloc	()->(*(struct(*(char),long,long)))
(	O
)	O
;	O
if	O
(	O
!	O
pathwalk	(*(char),*((*(char),*(void))->(int)),*(void))->(int)
(	O
libpath	*(char)
,	O
file_lookup	(*(char),*(void))->(int)
,	O
&	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
)	O
)	O
{	O
buffer_free	(*(struct(*(char),long,long)))->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
;	O
return	O
0	int
;	O
}	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
buffer_free	(*(struct(*(char),long,long)))->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
;	O
return	O
0	int
;	O
}	O
while	O
(	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
{	O
line	int
++	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
HDR_TAG	*(char)
,	O
strlen	(*(char))->(long)
(	O
HDR_TAG	*(char)
)	O
)	O
==	O
0	int
)	O
break	O
;	O
}	O
while	O
(	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
)	O
{	O
line	int
++	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
RESOURCE_DSC	*(char)
,	O
strlen	(*(char))->(long)
(	O
RESOURCE_DSC	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
char	O
*	O
cp	*(char)
,	O
*	O
cp2	*(char)
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
resources	array(char)
,	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
RESOURCE_DSC	*(char)
)	O
)	O
;	O
pending_comment	int
=	O
1	int
;	O
parse_resources	O
:	O
cp	*(char)
=	O
GET_TOKEN	O
(	O
resources	array(char)
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
MATCH	O
(	O
cp	*(char)
,	O
"font"	*(char)
)	O
)	O
{	O
for	O
(	O
cp	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
;	O
cp	*(char)
;	O
cp	*(char)
=	O
GET_TOKEN	O
(	O
NULL	O
)	O
)	O
if	O
(	O
!	O
strhash_get	(*(struct),*(char),int,*(*(void)))->(int)
(	O
res_fonts	*(struct)
,	O
cp	*(char)
,	O
strlen	(*(char))->(long)
(	O
cp	*(char)
)	O
+	O
1	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%%%%IncludeResource: font %s\n"	*(char)
,	O
cp	*(char)
)	O
;	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
res_fonts	*(struct)
,	O
cp	*(char)
,	O
strlen	(*(char))->(long)
(	O
cp	*(char)
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
continue	O
;	O
}	O
else	O
continue	O
;	O
}	O
else	O
if	O
(	O
pending_comment	int
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
CONT_DSC	*(char)
,	O
strlen	(*(char))->(long)
(	O
CONT_DSC	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
resources	array(char)
,	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
CONT_DSC	*(char)
)	O
)	O
;	O
goto	O
parse_resources	O
;	O
}	O
else	O
pending_comment	int
=	O
0	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
DIRECTIVE_FORMAT	*(char)
,	O
strlen	(*(char))->(long)
(	O
DIRECTIVE_FORMAT	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
name	*(char)
[	O
256	int
]	O
;	O
char	O
*	O
cp	*(char)
,	O
*	O
cp2	*(char)
;	O
errno	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
strlen	(*(char))->(long)
(	O
DIRECTIVE_FORMAT	*(char)
)	O
;	O
buf	*(char)
[	O
i	int
]	O
&&	O
isspace	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
buf	*(char)
[	O
i	int
]	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %%Format: no name"	*(char)
)	O
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
,	O
line	int
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
sizeof	O
(	O
name	*(char)
)	O
-	O
1	int
&&	O
buf	*(char)
[	O
i	int
]	O
&&	O
!	O
isspace	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
name	*(char)
[	O
j	int
++	O
]	O
=	O
buf	*(char)
[	O
i	int
]	O
;	O
name	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
j	int
>=	O
sizeof	O
(	O
name	*(char)
)	O
-	O
1	int
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %%Format: too long name, maxlen=%d"	*(char)
)	O
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
,	O
line	int
,	O
sizeof	O
(	O
name	*(char)
)	O
-	O
1	int
)	O
)	O
;	O
for	O
(	O
;	O
buf	*(char)
[	O
i	int
]	O
&&	O
isspace	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
j	int
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
for	O
(	O
j	int
--	O
;	O
isspace	(int)->(int)
(	O
buf	*(char)
[	O
j	int
]	O
)	O
&&	O
j	int
>	O
i	int
;	O
j	int
--	O
)	O
;	O
j	int
++	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%%Format: %s %.*s\n"	*(char)
,	O
name	*(char)
,	O
j	int
-	O
i	int
,	O
buf	*(char)
+	O
i	int
)	O
)	O
;	O
cp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
j	int
-	O
i	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
cp	*(char)
,	O
buf	*(char)
+	O
i	int
,	O
j	int
-	O
i	int
)	O
;	O
cp	*(char)
[	O
j	int
-	O
i	int
]	O
=	O
'\0'	O
;	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
user_strings	*(struct)
,	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
,	O
cp	*(char)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	*(char)
)	O
;	O
if	O
(	O
cp2	*(char)
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %%Format: name \"%s\" is already defined"	*(char)
)	O
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
,	O
line	int
,	O
name	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
DIRECTIVE_HEADERHEIGHT	*(char)
,	O
strlen	(*(char))->(long)
(	O
DIRECTIVE_HEADERHEIGHT	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
strlen	(*(char))->(long)
(	O
DIRECTIVE_HEADERHEIGHT	*(char)
)	O
;	O
buf	*(char)
[	O
i	int
]	O
&&	O
!	O
isspace	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
buf	*(char)
[	O
i	int
]	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %%HeaderHeight: no argument"	*(char)
)	O
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
,	O
line	int
)	O
)	O
;	O
d_header_h	int
=	O
atoi	(*(char))->(int)
(	O
buf	*(char)
+	O
i	int
)	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%%HeaderHeight: %d\n"	*(char)
,	O
d_header_h	int
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buf	*(char)
,	O
DIRECTIVE_FOOTERHEIGHT	*(char)
,	O
strlen	(*(char))->(long)
(	O
DIRECTIVE_FOOTERHEIGHT	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
strlen	(*(char))->(long)
(	O
DIRECTIVE_FOOTERHEIGHT	*(char)
)	O
;	O
buf	*(char)
[	O
i	int
]	O
&&	O
!	O
isspace	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
buf	*(char)
[	O
i	int
]	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %%FooterHeight: no argument"	*(char)
)	O
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
,	O
line	int
)	O
)	O
;	O
d_footer_h	int
=	O
atoi	(*(char))->(int)
(	O
buf	*(char)
+	O
i	int
)	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%%FooterHeight: %d\n"	*(char)
,	O
d_footer_h	int
)	O
)	O
;	O
continue	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	*(char)
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
buffer_free	(*(struct(*(char),long,long)))->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
.	O
fullname	*(struct(*(char),long,long))
)	O
;	O
return	O
1	int
;	O
}	O
int	O
parse_font_spec	(*(char),*(*(char)),*(struct(double,double)),*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)))->(int)
(	O
char	O
*	O
spec_a	*(char)
,	O
char	O
*	O
*	O
name_return	*(*(char))
,	O
FontPoint	struct(double,double)
*	O
size_return	*(struct(double,double))
,	O
InputEncoding	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
*	O
encoding_return	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
cp	*(char)
,	O
*	O
cp2	*(char)
;	O
char	O
*	O
spec	*(char)
;	O
char	O
*	O
encp	*(char)
;	O
spec	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
spec_a	*(char)
)	O
;	O
encp	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
spec	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
encp	*(char)
)	O
{	O
*	O
encp	*(char)
=	O
'\0'	O
;	O
encp	*(char)
++	O
;	O
}	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
spec	*(char)
,	O
'@'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
{	O
i	int
=	O
cp	*(char)
-	O
spec	*(char)
;	O
if	O
(	O
cp	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
xfree	(*(void))->(void)
(	O
spec	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
cp	*(char)
++	O
;	O
}	O
else	O
{	O
i	int
=	O
strlen	(*(char))->(long)
(	O
spec	*(char)
)	O
-	O
1	int
;	O
if	O
(	O
i	int
<=	O
0	int
||	O
!	O
ISNUMBERDIGIT	O
(	O
spec	*(char)
[	O
i	int
]	O
)	O
)	O
{	O
xfree	(*(void))->(void)
(	O
spec	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
--	O
;	O
i	int
>=	O
0	int
&&	O
ISNUMBERDIGIT	O
(	O
spec	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
--	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
xfree	(*(void))->(void)
(	O
spec	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
spec	*(char)
[	O
i	int
]	O
==	O
'/'	O
)	O
{	O
for	O
(	O
i	int
--	O
;	O
i	int
>=	O
0	int
&&	O
ISNUMBERDIGIT	O
(	O
spec	*(char)
[	O
i	int
]	O
)	O
;	O
i	int
--	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
xfree	(*(void))->(void)
(	O
spec	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
i	int
++	O
;	O
cp	*(char)
=	O
spec	*(char)
+	O
i	int
;	O
}	O
cp2	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cp	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
cp2	*(char)
)	O
{	O
*	O
cp2	*(char)
++	O
=	O
'\0'	O
;	O
size_return	*(struct(double,double))
->	O
w	int
=	O
atof	(*(char))->(double)
(	O
cp	*(char)
)	O
;	O
size_return	*(struct(double,double))
->	O
h	int
=	O
atof	(*(char))->(double)
(	O
cp2	*(char)
)	O
;	O
}	O
else	O
size_return	*(struct(double,double))
->	O
w	int
=	O
size_return	*(struct(double,double))
->	O
h	int
=	O
atof	(*(char))->(double)
(	O
cp	*(char)
)	O
;	O
*	O
name_return	*(*(char))
=	O
(	O
char	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
i	int
+	O
1	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
name_return	*(*(char))
,	O
spec	*(char)
,	O
i	int
)	O
;	O
if	O
(	O
encp	*(char)
)	O
{	O
int	O
found	int
=	O
0	int
;	O
if	O
(	O
encoding_return	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
==	O
NULL	O
)	O
{	O
xfree	(*(void))->(void)
(	O
spec	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
found	int
&&	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
names	array(*(char))
[	O
0	int
]	O
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
;	O
j	int
++	O
)	O
if	O
(	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
names	array(*(char))
[	O
j	int
]	O
!=	O
NULL	O
&&	O
MATCH	O
(	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
names	array(*(char))
[	O
j	int
]	O
,	O
encp	*(char)
)	O
)	O
{	O
*	O
encoding_return	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
=	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
;	O
encp	*(char)
=	O
encodings	array(struct(array(*(char)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int))
[	O
i	int
]	O
.	O
names	array(*(char))
[	O
0	int
]	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
found	int
)	O
{	O
xfree	(*(void))->(void)
(	O
spec	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
encp	*(char)
=	O
encoding_name	*(char)
;	O
if	O
(	O
encoding_return	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
)	O
*	O
encoding_return	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
=	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
;	O
}	O
xfree	(*(void))->(void)
(	O
spec	*(char)
)	O
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"parse_font_spec(): name=%.*s, size=%g/%g, encoding=%s\n"	*(char)
,	O
i	int
,	O
*	O
name_return	*(*(char))
,	O
size_return	*(struct(double,double))
->	O
w	int
,	O
size_return	*(struct(double,double))
->	O
h	int
,	O
encp	*(char)
)	O
)	O
;	O
if	O
(	O
size_return	*(struct(double,double))
->	O
w	int
<	O
0.0	int
&&	O
size_return	*(struct(double,double))
->	O
h	int
<	O
0.0	int
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: warning: font size is negative\n"	*(char)
)	O
,	O
program	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
size_return	*(struct(double,double))
->	O
w	int
<	O
0.0	int
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: warning: font width is negative\n"	*(char)
)	O
,	O
program	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
size_return	*(struct(double,double))
->	O
h	int
<	O
0.0	int
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: warning: font height is negative\n"	*(char)
)	O
,	O
program	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
read_font_info	()->(void)
(	O
void	O
)	O
{	O
CachedFontInfo	struct(array(double),array(char),enum(int,int),double)
*	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
;	O
AFMFont	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
;	O
int	O
font_info_cached	int
=	O
1	int
;	O
int	O
font_cached	int
=	O
1	int
;	O
int	O
i	int
;	O
unsigned	O
int	O
enc_flags	int
=	O
0	int
;	O
char	O
buf	*(char)
[	O
256	int
]	O
;	O
Buffer	struct(*(char),long,long)
fkey	struct(*(char),long,long)
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"reading AFM info for font \"%s\"\n"	*(char)
)	O
,	O
Fname	*(char)
)	O
)	O
;	O
if	O
(	O
accept_composites	int
)	O
enc_flags	int
=	O
AFM_ENCODE_ACCEPT_COMPOSITES	int
;	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fkey	struct(*(char),long,long)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fkey	struct(*(char),long,long)
,	O
Fname	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"@%f:%d"	*(char)
,	O
Fpt	struct(double,double)
.	O
w	int
,	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fkey	struct(*(char),long,long)
,	O
buf	*(char)
)	O
;	O
if	O
(	O
!	O
strhash_get	(*(struct),*(char),int,*(*(void)))->(int)
(	O
afm_info_cache	*(struct)
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fkey	struct(*(char),long,long)
)	O
,	O
strlen	(*(char))->(long)
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fkey	struct(*(char),long,long)
)	O
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
)	O
)	O
{	O
AFMError	int
error	int
;	O
if	O
(	O
!	O
strhash_get	(*(struct),*(char),int,*(*(void)))->(int)
(	O
afm_cache	*(struct)
,	O
Fname	*(char)
,	O
strlen	(*(char))->(long)
(	O
Fname	*(char)
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
)	O
)	O
{	O
error	int
=	O
afm_open_font	(*(struct),int,*(char),*(*(struct(*(struct`),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*`,*`,*`,*`,double,double,double,double,*`,*`,*`,long,long,*`,long,enum(int,int),double,double,enum(int,int),double,double,double,double,*`,*`,*`,*`),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct`),long,*(struct`),long,*(struct`),long,*(struct`)))))->(int)
(	O
afm	*(struct)
,	O
AFM_I_COMPOSITES	int
,	O
Fname	*(char)
,	O
&	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
)	O
;	O
if	O
(	O
error	int
!=	O
AFM_SUCCESS	int
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
Fname	*(char)
,	O
COUR	*(char)
,	O
strlen	(*(char))->(long)
(	O
COUR	*(char)
)	O
)	O
!=	O
0	int
)	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't open AFM file for font \"%s\", using default\n"	*(char)
)	O
,	O
Fname	*(char)
)	O
)	O
;	O
error	int
=	O
afm_open_default_font	(*(struct),*(*(struct(*(struct`),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*`,*`,*`,*`,double,double,double,double,*`,*`,*`,long,long,*`,long,enum(int,int),double,double,enum(int,int),double,double,double,double,*`,*`,*`,*`),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct`),long,*(struct`),long,*(struct`),long,*(struct`)))))->(int)
(	O
afm	*(struct)
,	O
&	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
)	O
;	O
if	O
(	O
error	int
!=	O
AFM_SUCCESS	int
)	O
{	O
afm_error_to_string	(int,*(char))->(void)
(	O
error	int
,	O
buf	*(char)
)	O
;	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't open AFM file for the default font: %s"	*(char)
)	O
,	O
buf	*(char)
)	O
)	O
;	O
}	O
}	O
switch	O
(	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
)	O
{	O
case	O
ENC_ISO_8859_1	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ISO_8859_1	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_2	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ISO_8859_2	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_3	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ISO_8859_3	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_4	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ISO_8859_4	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_5	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ISO_8859_5	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_7	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ISO_8859_7	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_9	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ISO_8859_9	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ISO_8859_10	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ISO_8859_10	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ASCII	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ASCII	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ASCII_FISE	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ASCII	int
,	O
enc_flags	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
enc_7bit_ascii_fise	array(struct(int,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
(	O
void	O
)	O
afm_font_encode	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),char,*(char),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
enc_7bit_ascii_fise	array(struct(int,*(char)))
[	O
i	int
]	O
.	O
code	char
,	O
enc_7bit_ascii_fise	array(struct(int,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_ASCII_DKNO	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_ASCII	int
,	O
enc_flags	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
enc_7bit_ascii_dkno	array(struct(int,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
(	O
void	O
)	O
afm_font_encode	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),char,*(char),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
enc_7bit_ascii_dkno	array(struct(int,*(char)))
[	O
i	int
]	O
.	O
code	char
,	O
enc_7bit_ascii_dkno	array(struct(int,*(char)))
[	O
i	int
]	O
.	O
name	*(char)
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_IBMPC	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_IBMPC	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_MAC	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_MAC	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_VMS	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_VMS	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_HP8	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_HP8	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_KOI8	int
:	O
(	O
void	O
)	O
afm_font_encoding	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
AFM_ENCODING_KOI8	int
,	O
enc_flags	int
)	O
;	O
break	O
;	O
case	O
ENC_PS	int
:	O
break	O
;	O
}	O
if	O
(	O
!	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
afm_cache	*(struct)
,	O
Fname	*(char)
,	O
strlen	(*(char))->(long)
(	O
Fname	*(char)
)	O
,	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
NULL	O
)	O
)	O
font_cached	int
=	O
0	int
;	O
}	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
=	O
(	O
CachedFontInfo	struct(array(double),array(char),enum(int,int),double)
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
{	O
AFMNumber	double
w0x	double
,	O
w0y	double
;	O
(	O
void	O
)	O
afm_font_charwidth	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))),double,char,*(double),*(double))->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
,	O
Fpt	struct(double,double)
.	O
w	int
,	O
i	int
,	O
&	O
w0x	double
,	O
&	O
w0y	double
)	O
;	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_widths	array(double)
[	O
i	int
]	O
=	O
w0x	double
;	O
if	O
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
->	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
[	O
i	int
]	O
==	O
AFM_ENC_NONE	O
)	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_ctype	array(char)
[	O
i	int
]	O
=	O
' '	O
;	O
else	O
if	O
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
->	O
encoding	array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char))))))
[	O
i	int
]	O
==	O
AFM_ENC_NON_EXISTENT	O
)	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_ctype	array(char)
[	O
i	int
]	O
=	O
'.'	O
;	O
else	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_ctype	array(char)
[	O
i	int
]	O
=	O
'*'	O
;	O
}	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_is_fixed	enum(int,int)
=	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
->	O
writing_direction_metrics	array(struct(enum(int,int),double,double,double,double,double,enum(int,int)))
[	O
0	int
]	O
.	O
IsFixedPitch	enum(int,int)
;	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_bbox_lly	double
=	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
->	O
global_info	struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*(struct(int,union`)))),*(struct(double,*(struct(int,union`)))),*(struct(double,*(struct(int,union`)))),*(struct(double,*(struct(int,union`)))))
.	O
FontBBox_lly	double
;	O
if	O
(	O
!	O
font_cached	int
)	O
(	O
void	O
)	O
afm_close_font	(*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct`),*(struct`),*(struct`),*(struct`)),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*`,double,double,double,double,double,double,double,*`)),long,*(struct(*`,long,*`)),long,*(struct(*`,*`,double,double)),long,*(struct(long,double,double,double,double)))))->(int)
(	O
font	*(struct(*(struct),double,int,array(*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct(*(char),*(char)))))),struct(*(char),*(char),*(char),*(char),double,double,double,double,*(char),*(char),*(char),long,long,*(char),long,enum(int,int),double,double,enum(int,int),double,double,double,double,*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`)),*(struct(double,*`))),array(struct(enum(int,int),double,double,double,double,double,enum(int,int))),long,*(struct(long,double,double,double,double,*(char),double,double,double,double,double,double,double,*(struct`))),long,*(struct(*(char),long,*(struct`))),long,*(struct(*(char),*(char),double,double)),long,*(struct(long,double,double,double,double))))
)	O
;	O
if	O
(	O
!	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
afm_info_cache	*(struct)
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fkey	struct(*(char),long,long)
)	O
,	O
strlen	(*(char))->(long)
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fkey	struct(*(char),long,long)
)	O
)	O
,	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
,	O
NULL	O
)	O
)	O
font_info_cached	int
=	O
0	int
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
font_widths	array(double)
,	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_widths	array(double)
,	O
256	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
font_ctype	array(char)
,	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_ctype	array(char)
,	O
256	int
)	O
;	O
font_is_fixed	enum(int,int)
=	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_is_fixed	enum(int,int)
;	O
font_bbox_lly	double
=	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
->	O
font_bbox_lly	double
;	O
if	O
(	O
!	O
font_info_cached	int
)	O
xfree	(*(void))->(void)
(	O
font_info	*(struct(array(double),array(char),enum(int,int),double))
)	O
;	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fkey	struct(*(char),long,long)
)	O
;	O
}	O
void	O
download_font	(*(char))->(void)
(	O
char	O
*	O
name	*(char)
)	O
{	O
AFMError	int
error	int
;	O
const	O
char	O
*	O
prefix	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stat_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
Buffer	struct(*(char),long,long)
fname	*(char)
;	O
unsigned	O
char	O
buf	*(char)
[	O
4096	int
]	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
i	int
;	O
char	O
*	O
cp	*(char)
;	O
error	int
=	O
afm_font_prefix	(*(struct),*(char),*(*(char)))->(int)
(	O
afm	*(struct)
,	O
name	*(char)
,	O
&	O
prefix	*(char)
)	O
;	O
if	O
(	O
error	int
!=	O
AFM_SUCCESS	int
)	O
return	O
;	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fname	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fname	*(char)
,	O
prefix	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fname	*(char)
,	O
".pfa"	*(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fname	*(char)
)	O
,	O
&	O
stat_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
{	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fname	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fname	*(char)
,	O
prefix	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
fname	*(char)
,	O
".pfb"	*(char)
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fname	*(char)
)	O
,	O
&	O
stat_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
{	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fname	*(char)
)	O
;	O
return	O
;	O
}	O
}	O
MESSAGE	O
(	O
1	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"downloading font \"%s\"\n"	*(char)
)	O
,	O
name	*(char)
)	O
)	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fname	*(char)
)	O
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't open font description file \"%s\": %s\n"	*(char)
)	O
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
fname	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fname	*(char)
)	O
;	O
return	O
;	O
}	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
fname	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%%%%BeginResource: font %s\n"	*(char)
,	O
name	*(char)
)	O
;	O
i	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
i	int
==	O
EOF	O
)	O
{	O
;	O
}	O
else	O
if	O
(	O
i	int
==	O
128	int
)	O
{	O
int	O
done	int
=	O
0	int
;	O
unsigned	O
int	O
chunk	int
;	O
unsigned	O
int	O
to_read	int
;	O
int	O
last_was_cr	int
;	O
int	O
j	int
;	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
i	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
!	O
done	int
)	O
{	O
i	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
1	int
,	O
6	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
i	int
!=	O
6	int
)	O
break	O
;	O
chunk	int
=	O
buf	*(char)
[	O
2	int
]	O
|	O
(	O
buf	*(char)
[	O
3	int
]	O
<<	O
8	int
)	O
|	O
(	O
buf	*(char)
[	O
4	int
]	O
<<	O
16	int
)	O
|	O
(	O
buf	*(char)
[	O
5	int
]	O
<<	O
24	int
)	O
;	O
switch	O
(	O
buf	*(char)
[	O
1	int
]	O
)	O
{	O
case	O
1	int
:	O
last_was_cr	int
=	O
0	int
;	O
while	O
(	O
chunk	int
>	O
0	int
)	O
{	O
to_read	int
=	O
sizeof	O
(	O
buf	*(char)
)	O
<	O
chunk	int
?	O
sizeof	O
(	O
buf	*(char)
)	O
:	O
chunk	int
;	O
i	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
1	int
,	O
to_read	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
done	int
=	O
1	int
;	O
break	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
0	int
&&	O
last_was_cr	int
&&	O
buf	*(char)
[	O
0	int
]	O
!=	O
'\n'	O
)	O
{	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	*(char)
[	O
0	int
]	O
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
if	O
(	O
buf	*(char)
[	O
j	int
]	O
==	O
'\r'	O
&&	O
j	int
+	O
1	int
<	O
i	int
&&	O
buf	*(char)
[	O
j	int
+	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
if	O
(	O
buf	*(char)
[	O
j	int
]	O
!=	O
'\r'	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buf	*(char)
[	O
j	int
]	O
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
chunk	int
-=	O
i	int
;	O
last_was_cr	int
=	O
(	O
buf	*(char)
[	O
i	int
-	O
1	int
]	O
==	O
'\r'	O
)	O
;	O
}	O
break	O
;	O
case	O
2	int
:	O
while	O
(	O
chunk	int
>	O
0	int
)	O
{	O
to_read	int
=	O
sizeof	O
(	O
buf	*(char)
)	O
<	O
chunk	int
?	O
sizeof	O
(	O
buf	*(char)
)	O
:	O
chunk	int
;	O
i	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
1	int
,	O
to_read	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
done	int
=	O
1	int
;	O
break	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%02X"	*(char)
,	O
buf	*(char)
[	O
j	int
]	O
)	O
;	O
if	O
(	O
(	O
j	int
+	O
1	int
)	O
%	O
32	int
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
chunk	int
-=	O
i	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
done	int
=	O
1	int
;	O
break	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
i	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
(	O
i	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
1	int
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
0	int
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(char)
,	O
1	int
,	O
i	int
,	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
ofp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%%%%EndResource\n"	*(char)
)	O
;	O
(	O
void	O
)	O
strhash_delete	(*(struct),*(char),int,*(*(void)))->(int)
(	O
res_fonts	*(struct)
,	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
char	O
*	O
escape_string	(*(char))->(*(char))
(	O
char	O
*	O
string	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
len	long
;	O
char	O
*	O
cp	*(char)
;	O
for	O
(	O
len	long
=	O
0	int
,	O
i	int
=	O
0	int
;	O
string	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
switch	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
{	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'\\'	O
:	O
len	long
+=	O
2	int
;	O
break	O
;	O
default	O
:	O
len	long
++	O
;	O
}	O
cp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
string	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
switch	O
(	O
string	*(char)
[	O
i	int
]	O
)	O
{	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'\\'	O
:	O
cp	*(char)
[	O
j	int
++	O
]	O
=	O
'\\'	O
;	O
default	O
:	O
cp	*(char)
[	O
j	int
++	O
]	O
=	O
string	*(char)
[	O
i	int
]	O
;	O
break	O
;	O
}	O
cp	*(char)
[	O
j	int
++	O
]	O
=	O
'\0'	O
;	O
return	O
cp	*(char)
;	O
}	O
char	O
*	O
format_user_string	(*(char),*(char))->(*(char))
(	O
char	O
*	O
context_name	*(char)
,	O
char	O
*	O
str	*(char)
)	O
{	O
char	O
*	O
cp	*(char)
;	O
char	O
*	O
rbuf	*(char)
=	O
NULL	O
;	O
int	O
rbuflen	int
=	O
0	int
;	O
int	O
rbufpos	int
=	O
0	int
;	O
int	O
i	int
=	O
0	int
;	O
int	O
j	int
;	O
char	O
buf	*(char)
[	O
512	int
]	O
;	O
char	O
buf2	array(char)
[	O
512	int
]	O
;	O
int	O
width	int
=	O
0	int
;	O
int	O
justification	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
str	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
;	O
i	int
++	O
)	O
{	O
int	O
type	int
;	O
type	int
=	O
str	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
type	int
==	O
'%'	O
||	O
type	int
==	O
'$'	O
)	O
{	O
i	int
++	O
;	O
width	int
=	O
0	int
;	O
justification	int
=	O
1	int
;	O
if	O
(	O
str	*(char)
[	O
i	int
]	O
==	O
'-'	O
)	O
{	O
i	int
++	O
;	O
justification	int
=	O
-	O
1	int
;	O
}	O
while	O
(	O
isdigit	(int)->(int)
(	O
str	*(char)
[	O
i	int
]	O
)	O
)	O
width	int
=	O
width	int
*	O
10	int
+	O
str	*(char)
[	O
i	int
++	O
]	O
-	O
'0'	O
;	O
if	O
(	O
type	int
==	O
'%'	O
)	O
{	O
switch	O
(	O
str	*(char)
[	O
i	int
]	O
)	O
{	O
case	O
'%'	O
:	O
APPEND_CH	O
(	O
'%'	O
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
getcwd	(*(char),long)->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
cp	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
cp	*(char)
++	O
;	O
else	O
cp	*(char)
=	O
buf	*(char)
;	O
APPEND_STR	O
(	O
cp	*(char)
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%02d:%02d:%02d"	*(char)
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_sec	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
getcwd	(*(char),long)->(*(char))
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
str	*(char)
[	O
i	int
+	O
1	int
]	O
==	O
'{'	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
+=	O
2	int
;	O
j	int
<	O
sizeof	O
(	O
buf2	array(char)
)	O
&&	O
str	*(char)
[	O
i	int
]	O
&&	O
str	*(char)
[	O
i	int
]	O
!=	O
'}'	O
;	O
i	int
++	O
,	O
j	int
++	O
)	O
buf2	array(char)
[	O
j	int
]	O
=	O
str	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
str	*(char)
[	O
i	int
]	O
!=	O
'}'	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: too long format for %%D{} escape"	*(char)
)	O
,	O
context_name	*(char)
)	O
)	O
;	O
buf2	array(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
buf2	array(char)
,	O
&	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%02d-%02d-%02d"	*(char)
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
%	O
100	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
)	O
;	O
}	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%02d/%02d/%02d"	*(char)
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
%	O
100	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d.%d.%d"	*(char)
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
+	O
1900	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
APPEND_STR	O
(	O
title	*(char)
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
(	O
void	O
)	O
gethostname	(*(char),long)->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
(	O
void	O
)	O
gethostname	(*(char),long)->(int)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
APPEND_STR	O
(	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
->	O
pw_name	*(char)
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
->	O
pw_gecos	*(char)
)	O
;	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d:%d%s"	*(char)
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
>	O
12	int
?	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
-	O
12	int
:	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
>	O
12	int
?	O
"pm"	*(char)
:	O
"am"	*(char)
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d:%d"	*(char)
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d:%d:%d"	*(char)
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_sec	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'W'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%02d/%02d/%02d"	*(char)
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
,	O
run_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
%	O
100	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unknown `%%' escape `%c' (%d)"	*(char)
)	O
,	O
context_name	*(char)
,	O
str	*(char)
[	O
i	int
]	O
,	O
str	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
str	*(char)
[	O
i	int
]	O
)	O
{	O
case	O
'$'	O
:	O
APPEND_CH	O
(	O
'$'	O
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
if	O
(	O
slicing	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d%c"	*(char)
,	O
current_pagenum	int
,	O
slice	int
-	O
1	int
+	O
'A'	O
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d"	*(char)
,	O
current_pagenum	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
APPEND_CH	O
(	O
'\001'	O
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d"	*(char)
,	O
total_pages	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'('	O
:	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
++	O
;	O
str	*(char)
[	O
i	int
]	O
&&	O
str	*(char)
[	O
i	int
]	O
!=	O
')'	O
&&	O
j	int
<	O
sizeof	O
(	O
buf	*(char)
)	O
-	O
1	int
;	O
i	int
++	O
)	O
buf	*(char)
[	O
j	int
++	O
]	O
=	O
str	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
str	*(char)
[	O
i	int
]	O
==	O
'\0'	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: no closing ')' for $() escape"	*(char)
)	O
,	O
context_name	*(char)
)	O
)	O
;	O
if	O
(	O
str	*(char)
[	O
i	int
]	O
!=	O
')'	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: too long variable name for $() escape"	*(char)
)	O
,	O
context_name	*(char)
)	O
)	O
;	O
buf	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
cp	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
buf	*(char)
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
cp	*(char)
=	O
""	*(char)
;	O
APPEND_STR	O
(	O
cp	*(char)
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%02d:%02d:%02d"	*(char)
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_sec	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
str	*(char)
[	O
i	int
+	O
1	int
]	O
==	O
'{'	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
+=	O
2	int
;	O
j	int
<	O
sizeof	O
(	O
buf2	array(char)
)	O
&&	O
str	*(char)
[	O
i	int
]	O
&&	O
str	*(char)
[	O
i	int
]	O
!=	O
'}'	O
;	O
i	int
++	O
,	O
j	int
++	O
)	O
buf2	array(char)
[	O
j	int
]	O
=	O
str	*(char)
[	O
i	int
]	O
;	O
if	O
(	O
str	*(char)
[	O
i	int
]	O
!=	O
'}'	O
)	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: too long format for $D{} escape"	*(char)
)	O
,	O
context_name	*(char)
)	O
)	O
;	O
buf2	array(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
,	O
buf2	array(char)
,	O
&	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%02d-%02d-%02d"	*(char)
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
%	O
100	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
)	O
;	O
}	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%02d/%02d/%02d"	*(char)
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
%	O
100	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d.%d.%d"	*(char)
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
+	O
1900	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d:%d%s"	*(char)
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
>	O
12	int
?	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
-	O
12	int
:	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
>	O
12	int
?	O
"pm"	*(char)
:	O
"am"	*(char)
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d:%d"	*(char)
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d:%d:%d"	*(char)
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_sec	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d"	*(char)
,	O
input_filenum	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
if	O
(	O
toc	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d-"	*(char)
,	O
input_filenum	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
'W'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%02d/%02d/%02d"	*(char)
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
+	O
1	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
,	O
mod_tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
%	O
100	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
APPEND_STR	O
(	O
fname	*(char)
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
cp	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
fname	*(char)
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	*(char)
)	O
cp	*(char)
++	O
;	O
else	O
cp	*(char)
=	O
fname	*(char)
;	O
APPEND_STR	O
(	O
cp	*(char)
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%d"	*(char)
,	O
current_file_linenum	int
-	O
1	int
)	O
;	O
APPEND_STR	O
(	O
buf	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
FATAL	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unknown `$' escape `%c' (%d)"	*(char)
)	O
,	O
context_name	*(char)
,	O
str	*(char)
[	O
i	int
]	O
,	O
str	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
width	int
=	O
0	int
;	O
justification	int
=	O
1	int
;	O
}	O
else	O
APPEND_CH	O
(	O
str	*(char)
[	O
i	int
]	O
)	O
;	O
}	O
APPEND_CH	O
(	O
'\0'	O
)	O
;	O
cp	*(char)
=	O
escape_string	(*(char))->(*(char))
(	O
rbuf	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
rbuf	*(char)
)	O
;	O
return	O
cp	*(char)
;	O
}	O
void	O
parse_key_value_pair	(*(struct),*(char))->(void)
(	O
StringHashPtr	*(struct)
set	*(struct)
,	O
char	O
*	O
kv	*(char)
)	O
{	O
char	O
*	O
cp	*(char)
;	O
Buffer	struct(*(char),long,long)
key	*(char)
;	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
kv	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
strhash_delete	(*(struct),*(char),int,*(*(void)))->(int)
(	O
set	*(struct)
,	O
kv	*(char)
,	O
strlen	(*(char))->(long)
(	O
kv	*(char)
)	O
+	O
1	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp	*(char)
)	O
)	O
xfree	(*(void))->(void)
(	O
cp	*(char)
)	O
;	O
}	O
else	O
{	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
key	*(char)
)	O
;	O
buffer_append_len	(*(struct(*(char),long,long)),*(char),long)->(void)
(	O
&	O
key	*(char)
,	O
kv	*(char)
,	O
cp	*(char)
-	O
kv	*(char)
)	O
;	O
strhash_put	(*(struct),*(char),int,*(void),*(*(void)))->(int)
(	O
set	*(struct)
,	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
key	*(char)
)	O
,	O
strlen	(*(char))->(long)
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
key	*(char)
)	O
)	O
+	O
1	int
,	O
xstrdup	(*(char))->(*(char))
(	O
cp	*(char)
+	O
1	int
)	O
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp	*(char)
)	O
;	O
if	O
(	O
cp	*(char)
)	O
xfree	(*(void))->(void)
(	O
cp	*(char)
)	O
;	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
key	*(char)
)	O
;	O
}	O
}	O
int	O
count_key_value_set	(*(struct))->(int)
(	O
StringHashPtr	*(struct)
set	*(struct)
)	O
{	O
int	O
i	int
=	O
0	int
,	O
got	int
,	O
j	int
;	O
char	O
*	O
cp	*(char)
;	O
void	O
*	O
value	*(void)
;	O
for	O
(	O
got	int
=	O
strhash_get_first	(*(struct),*(*(char)),*(int),*(*(void)))->(int)
(	O
set	*(struct)
,	O
&	O
cp	*(char)
,	O
&	O
j	int
,	O
&	O
value	*(void)
)	O
;	O
got	int
;	O
got	int
=	O
strhash_get_next	(*(struct),*(*(char)),*(int),*(*(void)))->(int)
(	O
set	*(struct)
,	O
&	O
cp	*(char)
,	O
&	O
j	int
,	O
&	O
value	*(void)
)	O
)	O
i	int
++	O
;	O
return	O
i	int
;	O
}	O
int	O
pathwalk	(*(char),*((*(char),*(void))->(int)),*(void))->(int)
(	O
char	O
*	O
path	*(char)
,	O
PathWalkProc	*((*(char),*(void))->(int))
proc	*((*(char),*(void))->(int))
,	O
void	O
*	O
context	*(void)
)	O
{	O
char	O
buf	*(char)
[	O
512	int
]	O
;	O
char	O
*	O
cp	*(char)
;	O
char	O
*	O
cp2	*(char)
;	O
int	O
len	long
,	O
i	int
;	O
for	O
(	O
cp	*(char)
=	O
path	*(char)
;	O
cp	*(char)
;	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cp	*(char)
,	O
PATH_SEPARATOR	char
)	O
)	O
{	O
if	O
(	O
cp	*(char)
!=	O
path	*(char)
)	O
cp	*(char)
++	O
;	O
cp2	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cp	*(char)
,	O
PATH_SEPARATOR	char
)	O
;	O
if	O
(	O
cp2	*(char)
)	O
len	long
=	O
cp2	*(char)
-	O
cp	*(char)
;	O
else	O
len	long
=	O
strlen	(*(char))->(long)
(	O
cp	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
,	O
cp	*(char)
,	O
len	long
)	O
;	O
buf	*(char)
[	O
len	long
]	O
=	O
'\0'	O
;	O
i	int
=	O
(	O
*	O
proc	*((*(char),*(void))->(int))
)	O
(	O
buf	*(char)
,	O
context	*(void)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
file_lookup	(*(char),*(void))->(int)
(	O
char	O
*	O
path	*(char)
,	O
void	O
*	O
context	*(void)
)	O
{	O
int	O
len	long
;	O
FileLookupCtx	struct(*(char),*(char),*(struct(*(char),long,long)))
*	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
=	O
context	*(void)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stat_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
i	int
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"file_lookup(): %s/%s%s\t"	*(char)
,	O
path	*(char)
,	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
name	*(char)
,	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
suffix	*(char)
)	O
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
path	*(char)
)	O
;	O
if	O
(	O
len	long
&&	O
path	*(char)
[	O
len	long
-	O
1	int
]	O
==	O
'/'	O
)	O
len	long
--	O
;	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
fullname	*(struct(*(char),long,long))
)	O
;	O
buffer_append_len	(*(struct(*(char),long,long)),*(char),long)->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
fullname	*(struct(*(char),long,long))
,	O
path	*(char)
,	O
len	long
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
fullname	*(struct(*(char),long,long))
,	O
"/"	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
fullname	*(struct(*(char),long,long))
,	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
name	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
fullname	*(struct(*(char),long,long))
,	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
suffix	*(char)
)	O
;	O
i	int
=	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
ctx	struct(*(char),*(char),*(struct(*(char),long,long)))
->	O
fullname	*(struct(*(char),long,long))
)	O
,	O
&	O
stat_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"#%c\n"	*(char)
,	O
i	int
?	O
't'	O
:	O
'f'	O
)	O
)	O
;	O
return	O
i	int
;	O
}	O
char	O
*	O
tilde_subst	(*(char))->(*(char))
(	O
char	O
*	O
fname	*(char)
)	O
{	O
char	O
*	O
cp	*(char)
;	O
int	O
i	int
;	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
;	O
Buffer	struct(*(char),long,long)
buffer	*(struct(*(char),long,long))
;	O
char	O
*	O
result	int
;	O
if	O
(	O
fname	*(char)
[	O
0	int
]	O
!=	O
'~'	O
)	O
return	O
xstrdup	(*(char))->(*(char))
(	O
fname	*(char)
)	O
;	O
if	O
(	O
fname	*(char)
[	O
1	int
]	O
==	O
'/'	O
||	O
fname	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
cp	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
cp	*(char)
==	O
NULL	O
)	O
return	O
xstrdup	(*(char))->(*(char))
(	O
fname	*(char)
)	O
;	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
cp	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
fname	*(char)
+	O
1	int
)	O
;	O
result	int
=	O
buffer_copy	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
return	O
result	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
fname	*(char)
[	O
i	int
]	O
&&	O
fname	*(char)
[	O
i	int
]	O
!=	O
'/'	O
;	O
i	int
++	O
)	O
;	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append_len	(*(struct(*(char),long,long)),*(char),long)->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
fname	*(char)
+	O
1	int
,	O
i	int
-	O
1	int
)	O
;	O
pswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwnam	(*(char))->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
)	O
;	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
if	O
(	O
pswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
{	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
pswd	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_dir	*(char)
)	O
;	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
,	O
fname	*(char)
+	O
i	int
)	O
;	O
result	int
=	O
buffer_copy	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
&	O
buffer	*(struct(*(char),long,long))
)	O
;	O
return	O
result	int
;	O
}	O
return	O
xstrdup	(*(char))->(*(char))
(	O
fname	*(char)
)	O
;	O
}	O
double	O
parse_float	(*(char),int,int)->(double)
(	O
char	O
*	O
string	*(char)
,	O
int	O
units	int
,	O
int	O
horizontal	int
)	O
{	O
double	O
val	array(int)
;	O
char	O
*	O
end	int
;	O
val	array(int)
=	O
strtod	(*(char),*(*(char)))->(double)
(	O
string	*(char)
,	O
&	O
end	int
)	O
;	O
if	O
(	O
end	int
==	O
string	*(char)
)	O
malformed_float	O
:	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"malformed float dimension: \"%s\""	*(char)
)	O
,	O
string	*(char)
)	O
)	O
;	O
if	O
(	O
units	int
)	O
{	O
switch	O
(	O
*	O
end	int
)	O
{	O
case	O
'c'	O
:	O
val	array(int)
*=	O
72	int
/	O
2.54	int
;	O
break	O
;	O
case	O
'p'	O
:	O
break	O
;	O
case	O
'i'	O
:	O
val	array(int)
*=	O
72	int
;	O
break	O
;	O
case	O
'\0'	O
:	O
case	O
'l'	O
:	O
if	O
(	O
horizontal	int
)	O
val	array(int)
*=	O
CHAR_WIDTH	O
(	O
'm'	O
)	O
;	O
else	O
val	array(int)
*=	O
LINESKIP	O
;	O
break	O
;	O
default	O
:	O
goto	O
malformed_float	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
end	int
!=	O
'\0'	O
)	O
goto	O
malformed_float	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
int	O
is_open	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char))->(int)
(	O
InputStream	struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int)
*	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
,	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
char	O
*	O
fname	*(char)
,	O
char	O
*	O
input_filter	*(char)
)	O
{	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
data_in_buf	int
=	O
0	int
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
bufpos	int
=	O
0	int
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
nreads	int
=	O
0	int
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_ch	*(char)
=	O
NULL	O
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_pos	int
=	O
0	int
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_alloc	int
=	O
0	int
;	O
if	O
(	O
input_filter	*(char)
)	O
{	O
char	O
*	O
cmd	*(char)
=	O
NULL	O
;	O
int	O
cmdlen	int
;	O
int	O
i	int
,	O
pos	int
;	O
char	O
*	O
cp	*(char)
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
is_pipe	int
=	O
1	int
;	O
if	O
(	O
fname	*(char)
==	O
NULL	O
)	O
fname	*(char)
=	O
input_filter_stdin	*(char)
;	O
cmdlen	int
=	O
strlen	(*(char))->(long)
(	O
input_filter	*(char)
)	O
+	O
1	int
;	O
cmd	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
cmdlen	int
)	O
;	O
pos	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
input_filter	*(char)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
input_filter	*(char)
[	O
i	int
]	O
==	O
'%'	O
)	O
{	O
switch	O
(	O
input_filter	*(char)
[	O
i	int
+	O
1	int
]	O
)	O
{	O
case	O
's'	O
:	O
if	O
(	O
(	O
cp	*(char)
=	O
shell_escape	(*(char))->(*(char))
(	O
fname	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmdlen	int
+=	O
strlen	(*(char))->(long)
(	O
cp	*(char)
)	O
;	O
cmd	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
cmd	*(char)
,	O
cmdlen	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
cmd	*(char)
+	O
pos	int
,	O
cp	*(char)
)	O
;	O
pos	int
+=	O
strlen	(*(char))->(long)
(	O
cp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cp	*(char)
)	O
;	O
}	O
i	int
++	O
;	O
break	O
;	O
case	O
'%'	O
:	O
cmd	*(char)
[	O
pos	int
++	O
]	O
=	O
'%'	O
;	O
i	int
++	O
;	O
break	O
;	O
default	O
:	O
cmd	*(char)
[	O
pos	int
++	O
]	O
=	O
input_filter	*(char)
[	O
i	int
]	O
;	O
break	O
;	O
}	O
}	O
else	O
cmd	*(char)
[	O
pos	int
++	O
]	O
=	O
input_filter	*(char)
[	O
i	int
]	O
;	O
}	O
cmd	*(char)
[	O
pos	int
++	O
]	O
=	O
'\0'	O
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
popen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
cmd	*(char)
,	O
"r"	*(char)
)	O
;	O
xfree	(*(void))->(void)
(	O
cmd	*(char)
)	O
;	O
if	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't open input filter \"%s\" for file \"%s\": %s"	*(char)
)	O
,	O
input_filter	*(char)
,	O
fname	*(char)
?	O
fname	*(char)
:	O
"(stdin)"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
is_pipe	int
=	O
0	int
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
{	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fname	*(char)
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
ERROR	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"couldn't open input file \"%s\": %s"	*(char)
)	O
,	O
fname	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
1	int
;	O
}	O
void	O
is_close	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)))->(void)
(	O
InputStream	struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int)
*	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
)	O
{	O
if	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
is_pipe	int
)	O
pclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_ch	*(char)
)	O
xfree	(*(void))->(void)
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_ch	*(char)
)	O
;	O
}	O
int	O
is_getc	(*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)))->(int)
(	O
InputStream	struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int)
*	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
)	O
{	O
int	O
ch	char
;	O
if	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_pos	int
>	O
0	int
)	O
{	O
ch	char
=	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_ch	*(char)
[	O
--	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_pos	int
]	O
;	O
return	O
ch	char
;	O
}	O
retry	O
:	O
if	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
bufpos	int
>=	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
data_in_buf	int
)	O
{	O
if	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
nreads	int
>	O
0	int
&&	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
data_in_buf	int
<	O
sizeof	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
buf	*(char)
)	O
)	O
return	O
EOF	O
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
data_in_buf	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
buf	*(char)
,	O
1	int
,	O
sizeof	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
buf	*(char)
)	O
,	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
bufpos	int
=	O
0	int
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
nreads	int
++	O
;	O
goto	O
retry	O
;	O
}	O
return	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
buf	*(char)
[	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
bufpos	int
++	O
]	O
;	O
}	O
int	O
is_ungetc	(int,*(struct(int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),array(char),int,int,int,*(char),int,int)))->(int)
(	O
int	O
ch	char
,	O
InputStream	struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int)
*	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
)	O
{	O
if	O
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_pos	int
>=	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_alloc	int
)	O
{	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_alloc	int
+=	O
1024	int
;	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_ch	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_ch	*(char)
,	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_alloc	int
)	O
;	O
}	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_ch	*(char)
[	O
is	*(struct(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),array(char),int,int,int,*(char),int,int))
->	O
unget_pos	int
++	O
]	O
=	O
ch	char
;	O
return	O
1	int
;	O
}	O
void	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
)	O
{	O
buffer	*(struct(*(char),long,long))
->	O
allocated	long
=	O
128	int
;	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
buffer	*(struct(*(char),long,long))
->	O
allocated	long
)	O
;	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
[	O
0	int
]	O
=	O
'\0'	O
;	O
buffer	*(struct(*(char),long,long))
->	O
len	long
=	O
0	int
;	O
}	O
void	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
)	O
{	O
xfree	(*(void))->(void)
(	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
)	O
;	O
}	O
Buffer	struct(*(char),long,long)
*	O
buffer_alloc	()->(*(struct(*(char),long,long)))
(	O
)	O
{	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
=	O
(	O
Buffer	struct(*(char),long,long)
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
Buffer	struct(*(char),long,long)
)	O
)	O
;	O
buffer_init	(*(struct(*(char),long,long)))->(void)
(	O
buffer	*(struct(*(char),long,long))
)	O
;	O
return	O
buffer	*(struct(*(char),long,long))
;	O
}	O
void	O
buffer_free	(*(struct(*(char),long,long)))->(void)
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
)	O
{	O
buffer_uninit	(*(struct(*(char),long,long)))->(void)
(	O
buffer	*(struct(*(char),long,long))
)	O
;	O
xfree	(*(void))->(void)
(	O
buffer	*(struct(*(char),long,long))
)	O
;	O
}	O
void	O
buffer_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
,	O
const	O
char	O
*	O
data	*(void)
)	O
{	O
buffer_append_len	(*(struct(*(char),long,long)),*(char),long)->(void)
(	O
buffer	*(struct(*(char),long,long))
,	O
data	*(void)
,	O
strlen	(*(char))->(long)
(	O
data	*(void)
)	O
)	O
;	O
}	O
void	O
buffer_append_len	(*(struct(*(char),long,long)),*(char),long)->(void)
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
,	O
const	O
char	O
*	O
data	*(void)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
buffer	*(struct(*(char),long,long))
->	O
len	long
+	O
len	long
+	O
1	int
>=	O
buffer	*(struct(*(char),long,long))
->	O
allocated	long
)	O
{	O
buffer	*(struct(*(char),long,long))
->	O
allocated	long
=	O
buffer	*(struct(*(char),long,long))
->	O
len	long
+	O
len	long
+	O
1024	int
;	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
,	O
buffer	*(struct(*(char),long,long))
->	O
allocated	long
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
+	O
buffer	*(struct(*(char),long,long))
->	O
len	long
,	O
data	*(void)
,	O
len	long
)	O
;	O
buffer	*(struct(*(char),long,long))
->	O
len	long
+=	O
len	long
;	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
[	O
buffer	*(struct(*(char),long,long))
->	O
len	long
]	O
=	O
'\0'	O
;	O
}	O
char	O
*	O
buffer_copy	(*(struct(*(char),long,long)))->(*(char))
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
)	O
{	O
char	O
*	O
copy	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
buffer	*(struct(*(char),long,long))
->	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
copy	*(char)
,	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
,	O
buffer	*(struct(*(char),long,long))
->	O
len	long
+	O
1	int
)	O
;	O
return	O
copy	*(char)
;	O
}	O
void	O
buffer_clear	(*(struct(*(char),long,long)))->(void)
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
)	O
{	O
buffer	*(struct(*(char),long,long))
->	O
len	long
=	O
0	int
;	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
char	O
*	O
buffer_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
)	O
{	O
return	O
buffer	*(struct(*(char),long,long))
->	O
data	*(void)
;	O
}	O
size_t	long
buffer_len	(*(struct(*(char),long,long)))->(long)
(	O
Buffer	struct(*(char),long,long)
*	O
buffer	*(struct(*(char),long,long))
)	O
{	O
return	O
buffer	*(struct(*(char),long,long))
->	O
len	long
;	O
}	O
char	O
*	O
shell_escape	(*(char))->(*(char))
(	O
const	O
char	O
*	O
fn	*(char)
)	O
{	O
size_t	long
len	long
=	O
0	int
;	O
const	O
char	O
*	O
inp	*(char)
;	O
char	O
*	O
retval	*(char)
,	O
*	O
outp	*(char)
;	O
for	O
(	O
inp	*(char)
=	O
fn	*(char)
;	O
*	O
inp	*(char)
;	O
++	O
inp	*(char)
)	O
switch	O
(	O
*	O
inp	*(char)
)	O
{	O
case	O
'\''	O
:	O
len	long
+=	O
4	int
;	O
break	O
;	O
default	O
:	O
len	long
+=	O
1	int
;	O
break	O
;	O
}	O
outp	*(char)
=	O
retval	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
outp	*(char)
)	O
return	O
NULL	O
;	O
for	O
(	O
inp	*(char)
=	O
fn	*(char)
;	O
*	O
inp	*(char)
;	O
++	O
inp	*(char)
)	O
switch	O
(	O
*	O
inp	*(char)
)	O
{	O
case	O
'\''	O
:	O
*	O
outp	*(char)
++	O
=	O
'\''	O
;	O
*	O
outp	*(char)
++	O
=	O
'\\'	O
;	O
*	O
outp	*(char)
++	O
=	O
'\''	O
,	O
*	O
outp	*(char)
++	O
=	O
'\''	O
;	O
break	O
;	O
default	O
:	O
*	O
outp	*(char)
++	O
=	O
*	O
inp	*(char)
;	O
break	O
;	O
}	O
*	O
outp	*(char)
=	O
0	int
;	O
return	O
retval	*(char)
;	O
}	O
