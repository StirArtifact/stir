static	O
unsigned	O
char	O
subbuffer	array(char)
[	O
SUBBUFSIZE	int
]	O
,	O
*	O
subpointer	*(char)
,	O
*	O
subend	*(char)
;	O
char	O
options	array(char)
[	O
256	int
]	O
;	O
char	O
do_dont_resp	array(char)
[	O
256	int
]	O
;	O
char	O
will_wont_resp	array(char)
[	O
256	int
]	O
;	O
int	O
eight	int
=	O
0	int
,	O
autologin	int
=	O
0	int
,	O
skiprc	int
=	O
0	int
,	O
connected	int
,	O
showoptions	int
,	O
In3270	int
,	O
ISend	int
,	O
debug	int
=	O
0	int
,	O
crmod	int
,	O
netdata	int
,	O
crlf	int
,	O
telnetport	int
,	O
SYNCHing	int
,	O
flushout	int
,	O
autoflush	int
=	O
0	int
,	O
autosynch	int
,	O
localflow	int
,	O
restartany	int
,	O
localchars	int
,	O
donelclchars	int
,	O
donebinarytoggle	int
,	O
dontlecho	int
,	O
globalmode	int
;	O
char	O
*	O
prompt	*(char)
=	O
0	int
;	O
cc_t	char
escape	char
;	O
cc_t	char
rlogin	char
;	O
cc_t	char
echoc	char
;	O
static	O
int	O
telrcv_state	int
;	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
toplevel	array(struct(array(long),int,struct(array(long))))
;	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
peerdied	array(struct(array(long),int,struct(array(long))))
;	O
int	O
flushline	int
;	O
int	O
linemode	int
;	O
int	O
kludgelinemode	int
=	O
1	int
;	O
Clocks	struct(int,int,int,int,int)
clocks	struct(int,int,int,int,int)
;	O
void	O
init_telnet	()->(void)
(	O
void	O
)	O
{	O
env_init	()->(void)
(	O
)	O
;	O
SB_CLEAR	O
(	O
)	O
;	O
ClearArray	O
(	O
options	array(char)
)	O
;	O
connected	int
=	O
In3270	int
=	O
ISend	int
=	O
localflow	int
=	O
donebinarytoggle	int
=	O
0	int
;	O
restartany	int
=	O
-	O
1	int
;	O
SYNCHing	int
=	O
0	int
;	O
escape	char
=	O
CONTROL	O
(	O
']'	O
)	O
;	O
rlogin	char
=	O
_POSIX_VDISABLE	char
;	O
echoc	char
=	O
CONTROL	O
(	O
'E'	O
)	O
;	O
flushline	int
=	O
1	int
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
}	O
void	O
send_do	(int,int)->(void)
(	O
register	O
int	O
c	int
,	O
register	O
int	O
init	int
)	O
{	O
if	O
(	O
init	int
)	O
{	O
if	O
(	O
(	O
(	O
do_dont_resp	array(char)
[	O
c	int
]	O
==	O
0	int
)	O
&&	O
my_state_is_do	O
(	O
c	int
)	O
)	O
||	O
my_want_state_is_do	O
(	O
c	int
)	O
)	O
return	O
;	O
set_my_want_state_do	O
(	O
c	int
)	O
;	O
do_dont_resp	array(char)
[	O
c	int
]	O
++	O
;	O
}	O
NET2ADD	O
(	O
IAC	int
,	O
DO	int
)	O
;	O
NETADD	O
(	O
c	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
DO	int
,	O
c	int
)	O
;	O
}	O
void	O
send_dont	(int,int)->(void)
(	O
register	O
int	O
c	int
,	O
register	O
int	O
init	int
)	O
{	O
if	O
(	O
init	int
)	O
{	O
if	O
(	O
(	O
(	O
do_dont_resp	array(char)
[	O
c	int
]	O
==	O
0	int
)	O
&&	O
my_state_is_dont	O
(	O
c	int
)	O
)	O
||	O
my_want_state_is_dont	O
(	O
c	int
)	O
)	O
return	O
;	O
set_my_want_state_dont	O
(	O
c	int
)	O
;	O
do_dont_resp	array(char)
[	O
c	int
]	O
++	O
;	O
}	O
NET2ADD	O
(	O
IAC	int
,	O
DONT	int
)	O
;	O
NETADD	O
(	O
c	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
DONT	int
,	O
c	int
)	O
;	O
}	O
void	O
send_will	(int,int)->(void)
(	O
register	O
int	O
c	int
,	O
register	O
int	O
init	int
)	O
{	O
if	O
(	O
init	int
)	O
{	O
if	O
(	O
(	O
(	O
will_wont_resp	array(char)
[	O
c	int
]	O
==	O
0	int
)	O
&&	O
my_state_is_will	O
(	O
c	int
)	O
)	O
||	O
my_want_state_is_will	O
(	O
c	int
)	O
)	O
return	O
;	O
set_my_want_state_will	O
(	O
c	int
)	O
;	O
will_wont_resp	array(char)
[	O
c	int
]	O
++	O
;	O
}	O
NET2ADD	O
(	O
IAC	int
,	O
WILL	int
)	O
;	O
NETADD	O
(	O
c	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
WILL	int
,	O
c	int
)	O
;	O
}	O
void	O
send_wont	(int,int)->(void)
(	O
register	O
int	O
c	int
,	O
register	O
int	O
init	int
)	O
{	O
if	O
(	O
init	int
)	O
{	O
if	O
(	O
(	O
(	O
will_wont_resp	array(char)
[	O
c	int
]	O
==	O
0	int
)	O
&&	O
my_state_is_wont	O
(	O
c	int
)	O
)	O
||	O
my_want_state_is_wont	O
(	O
c	int
)	O
)	O
return	O
;	O
set_my_want_state_wont	O
(	O
c	int
)	O
;	O
will_wont_resp	array(char)
[	O
c	int
]	O
++	O
;	O
}	O
NET2ADD	O
(	O
IAC	int
,	O
WONT	int
)	O
;	O
NETADD	O
(	O
c	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
WONT	int
,	O
c	int
)	O
;	O
}	O
void	O
willoption	(int)->(void)
(	O
int	O
option	int
)	O
{	O
int	O
new_state_ok	int
=	O
0	int
;	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
)	O
{	O
--	O
do_dont_resp	array(char)
[	O
option	int
]	O
;	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
&&	O
my_state_is_do	O
(	O
option	int
)	O
)	O
--	O
do_dont_resp	array(char)
[	O
option	int
]	O
;	O
}	O
if	O
(	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
my_want_state_is_dont	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_ECHO	int
:	O
case	O
TELOPT_BINARY	int
:	O
case	O
TELOPT_SGA	int
:	O
settimer	O
(	O
modenegotiated	int
)	O
;	O
case	O
TELOPT_STATUS	int
:	O
new_state_ok	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
if	O
(	O
flushout	int
)	O
flushout	int
=	O
0	int
;	O
set_my_want_state_dont	O
(	O
option	int
)	O
;	O
set_my_state_dont	O
(	O
option	int
)	O
;	O
return	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
new_state_ok	int
)	O
{	O
set_my_want_state_do	O
(	O
option	int
)	O
;	O
send_do	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
{	O
do_dont_resp	array(char)
[	O
option	int
]	O
++	O
;	O
send_dont	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
}	O
}	O
set_my_state_do	O
(	O
option	int
)	O
;	O
}	O
void	O
wontoption	(int)->(void)
(	O
int	O
option	int
)	O
{	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
)	O
{	O
--	O
do_dont_resp	array(char)
[	O
option	int
]	O
;	O
if	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
&&	O
my_state_is_dont	O
(	O
option	int
)	O
)	O
--	O
do_dont_resp	array(char)
[	O
option	int
]	O
;	O
}	O
if	O
(	O
(	O
do_dont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
my_want_state_is_do	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_SGA	int
:	O
if	O
(	O
!	O
kludgelinemode	int
)	O
break	O
;	O
case	O
TELOPT_ECHO	int
:	O
settimer	O
(	O
modenegotiated	int
)	O
;	O
break	O
;	O
case	O
TELOPT_TM	int
:	O
if	O
(	O
flushout	int
)	O
flushout	int
=	O
0	int
;	O
set_my_want_state_dont	O
(	O
option	int
)	O
;	O
set_my_state_dont	O
(	O
option	int
)	O
;	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
set_my_want_state_dont	O
(	O
option	int
)	O
;	O
if	O
(	O
my_state_is_do	O
(	O
option	int
)	O
)	O
send_dont	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
option	int
==	O
TELOPT_TM	int
)	O
{	O
if	O
(	O
flushout	int
)	O
flushout	int
=	O
0	int
;	O
set_my_want_state_dont	O
(	O
option	int
)	O
;	O
}	O
set_my_state_dont	O
(	O
option	int
)	O
;	O
}	O
static	O
void	O
dooption	(int)->(void)
(	O
int	O
option	int
)	O
{	O
int	O
new_state_ok	int
=	O
0	int
;	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
)	O
{	O
--	O
will_wont_resp	array(char)
[	O
option	int
]	O
;	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
&&	O
my_state_is_will	O
(	O
option	int
)	O
)	O
--	O
will_wont_resp	array(char)
[	O
option	int
]	O
;	O
}	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
my_want_state_is_wont	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_TM	int
:	O
send_will	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
set_my_want_state_wont	O
(	O
TELOPT_TM	int
)	O
;	O
set_my_state_wont	O
(	O
TELOPT_TM	int
)	O
;	O
return	O
;	O
case	O
TELOPT_BINARY	int
:	O
case	O
TELOPT_NAWS	int
:	O
case	O
TELOPT_TSPEED	int
:	O
case	O
TELOPT_LFLOW	int
:	O
case	O
TELOPT_TTYPE	int
:	O
case	O
TELOPT_SGA	int
:	O
new_state_ok	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
new_state_ok	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_XDISPLOC	int
:	O
if	O
(	O
env_getvalue	(*(char))->(*(char))
(	O
"DISPLAY"	*(char)
)	O
)	O
new_state_ok	int
=	O
1	int
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
kludgelinemode	int
=	O
0	int
;	O
send_do	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
set_my_want_state_will	O
(	O
TELOPT_LINEMODE	int
)	O
;	O
send_will	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
set_my_state_will	O
(	O
TELOPT_LINEMODE	int
)	O
;	O
slc_init	()->(void)
(	O
)	O
;	O
return	O
;	O
case	O
TELOPT_ECHO	int
:	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
new_state_ok	int
)	O
{	O
set_my_want_state_will	O
(	O
option	int
)	O
;	O
send_will	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
{	O
will_wont_resp	array(char)
[	O
option	int
]	O
++	O
;	O
send_wont	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_LINEMODE	int
:	O
kludgelinemode	int
=	O
0	int
;	O
send_do	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
set_my_state_will	O
(	O
option	int
)	O
;	O
slc_init	()->(void)
(	O
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
set_my_state_will	O
(	O
option	int
)	O
;	O
}	O
static	O
void	O
dontoption	(int)->(void)
(	O
int	O
option	int
)	O
{	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
)	O
{	O
--	O
will_wont_resp	array(char)
[	O
option	int
]	O
;	O
if	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
&&	O
my_state_is_wont	O
(	O
option	int
)	O
)	O
--	O
will_wont_resp	array(char)
[	O
option	int
]	O
;	O
}	O
if	O
(	O
(	O
will_wont_resp	array(char)
[	O
option	int
]	O
==	O
0	int
)	O
&&	O
my_want_state_is_will	O
(	O
option	int
)	O
)	O
{	O
switch	O
(	O
option	int
)	O
{	O
case	O
TELOPT_LINEMODE	int
:	O
linemode	int
=	O
0	int
;	O
break	O
;	O
}	O
set_my_want_state_wont	O
(	O
option	int
)	O
;	O
if	O
(	O
my_state_is_will	O
(	O
option	int
)	O
)	O
send_wont	(int,int)->(void)
(	O
option	int
,	O
0	int
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
}	O
set_my_state_wont	O
(	O
option	int
)	O
;	O
}	O
int	O
is_unique	(*(char),*(*(char)),*(*(char)))->(int)
(	O
register	O
char	O
*	O
name	*(char)
,	O
register	O
char	O
*	O
*	O
as	*(*(char))
,	O
register	O
char	O
*	O
*	O
ae	*(*(char))
)	O
{	O
register	O
char	O
*	O
*	O
ap	*(*(char))
;	O
register	O
int	O
n	int
;	O
n	int
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
1	int
;	O
for	O
(	O
ap	*(*(char))
=	O
as	*(*(char))
;	O
ap	*(*(char))
<	O
ae	*(*(char))
;	O
ap	*(*(char))
++	O
)	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
*	O
ap	*(*(char))
,	O
name	*(char)
,	O
n	int
)	O
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
char	O
*	O
name_unknown	*(char)
=	O
"UNKNOWN"	*(char)
;	O
static	O
char	O
*	O
unknown	array(*(char))
[	O
]	O
=	O
{	O
0	int
,	O
0	int
}	O
;	O
char	O
*	O
*	O
mklist	(*(char),*(char))->(*(*(char)))
(	O
char	O
*	O
buf	*(char)
,	O
char	O
*	O
name	*(char)
)	O
{	O
register	O
int	O
n	int
;	O
register	O
char	O
c	int
,	O
*	O
cp	*(char)
,	O
*	O
*	O
argvp	*(*(char))
,	O
*	O
cp2	*(char)
,	O
*	O
*	O
argv	*(*(char))
,	O
*	O
*	O
avt	*(*(char))
;	O
if	O
(	O
name	*(char)
)	O
{	O
if	O
(	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
>	O
40	int
)	O
{	O
name	*(char)
=	O
0	int
;	O
unknown	array(*(char))
[	O
0	int
]	O
=	O
name_unknown	*(char)
;	O
}	O
else	O
{	O
unknown	array(*(char))
[	O
0	int
]	O
=	O
name	*(char)
;	O
upcase	(*(char))->(void)
(	O
name	*(char)
)	O
;	O
}	O
}	O
else	O
unknown	array(*(char))
[	O
0	int
]	O
=	O
name_unknown	*(char)
;	O
for	O
(	O
n	int
=	O
1	int
,	O
cp	*(char)
=	O
buf	*(char)
;	O
*	O
cp	*(char)
&&	O
*	O
cp	*(char)
!=	O
':'	O
;	O
cp	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
cp	*(char)
==	O
'|'	O
)	O
n	int
++	O
;	O
}	O
argv	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
malloc	(long)->(*(void))
(	O
(	O
n	int
+	O
3	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
argv	*(*(char))
==	O
0	int
)	O
return	O
(	O
unknown	array(*(char))
)	O
;	O
*	O
argv	*(*(char))
=	O
0	int
;	O
argvp	*(*(char))
=	O
argv	*(*(char))
+	O
1	int
;	O
n	int
=	O
0	int
;	O
for	O
(	O
cp	*(char)
=	O
cp2	*(char)
=	O
buf	*(char)
;	O
(	O
c	int
=	O
*	O
cp	*(char)
)	O
;	O
cp	*(char)
++	O
)	O
{	O
if	O
(	O
c	int
==	O
'|'	O
||	O
c	int
==	O
':'	O
)	O
{	O
*	O
cp	*(char)
++	O
=	O
'\0'	O
;	O
if	O
(	O
n	int
||	O
(	O
cp	*(char)
-	O
cp2	*(char)
>	O
41	int
)	O
)	O
;	O
else	O
if	O
(	O
name	*(char)
&&	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
cp2	*(char)
,	O
cp	*(char)
-	O
cp2	*(char)
)	O
==	O
0	int
)	O
)	O
*	O
argv	*(*(char))
=	O
cp2	*(char)
;	O
else	O
if	O
(	O
is_unique	(*(char),*(*(char)),*(*(char)))->(int)
(	O
cp2	*(char)
,	O
argv	*(*(char))
+	O
1	int
,	O
argvp	*(*(char))
)	O
)	O
*	O
argvp	*(*(char))
++	O
=	O
cp2	*(char)
;	O
if	O
(	O
c	int
==	O
':'	O
)	O
break	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
cp	*(char)
)	O
==	O
'|'	O
)	O
cp	*(char)
++	O
;	O
cp2	*(char)
=	O
cp	*(char)
;	O
n	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
c	int
==	O
' '	O
)	O
||	O
!	O
isascii	(int)->(int)
(	O
c	int
)	O
)	O
n	int
=	O
1	int
;	O
else	O
if	O
(	O
islower	(int)->(int)
(	O
c	int
)	O
)	O
*	O
cp	*(char)
=	O
toupper	(int)->(int)
(	O
c	int
)	O
;	O
}	O
if	O
(	O
(	O
argv	*(*(char))
[	O
1	int
]	O
==	O
buf	*(char)
)	O
&&	O
(	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
==	O
2	int
)	O
)	O
{	O
--	O
argvp	*(*(char))
;	O
for	O
(	O
avt	*(*(char))
=	O
&	O
argv	*(*(char))
[	O
1	int
]	O
;	O
avt	*(*(char))
<	O
argvp	*(*(char))
;	O
avt	*(*(char))
++	O
)	O
*	O
avt	*(*(char))
=	O
*	O
(	O
avt	*(*(char))
+	O
1	int
)	O
;	O
*	O
argvp	*(*(char))
++	O
=	O
buf	*(char)
;	O
}	O
cp	*(char)
=	O
*	O
(	O
argvp	*(*(char))
-	O
1	int
)	O
;	O
*	O
argvp	*(*(char))
++	O
=	O
cp	*(char)
;	O
*	O
argvp	*(*(char))
=	O
0	int
;	O
if	O
(	O
*	O
argv	*(*(char))
==	O
0	int
)	O
{	O
if	O
(	O
name	*(char)
)	O
*	O
argv	*(*(char))
=	O
name	*(char)
;	O
else	O
{	O
--	O
argvp	*(*(char))
;	O
for	O
(	O
avt	*(*(char))
=	O
argv	*(*(char))
;	O
avt	*(*(char))
<	O
argvp	*(*(char))
;	O
avt	*(*(char))
++	O
)	O
*	O
avt	*(*(char))
=	O
*	O
(	O
avt	*(*(char))
+	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
*	O
argv	*(*(char))
)	O
return	O
(	O
argv	*(*(char))
)	O
;	O
else	O
return	O
(	O
unknown	array(*(char))
)	O
;	O
}	O
char	O
termbuf	array(char)
[	O
1024	int
]	O
;	O
int	O
init_term	(*(char),int,*(int))->(int)
(	O
char	O
*	O
tname	*(char)
,	O
int	O
fd	int
,	O
int	O
*	O
errp	*(int)
)	O
{	O
int	O
err	long
=	O
-	O
1	int
;	O
err	long
=	O
tgetent	(*(char),*(char))->(int)
(	O
termbuf	array(char)
,	O
tname	*(char)
)	O
;	O
if	O
(	O
err	long
==	O
1	int
)	O
{	O
termbuf	array(char)
[	O
1023	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
errp	*(int)
)	O
*	O
errp	*(int)
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
errp	*(int)
)	O
*	O
errp	*(int)
=	O
0	int
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
resettermname	int
=	O
1	int
;	O
char	O
*	O
gettermname	()->(*(char))
(	O
void	O
)	O
{	O
char	O
*	O
tname	*(char)
;	O
static	O
char	O
*	O
*	O
tnamep	*(*(char))
=	O
0	int
;	O
static	O
char	O
*	O
*	O
next	*(*(char))
;	O
int	O
err	long
;	O
if	O
(	O
resettermname	int
)	O
{	O
resettermname	int
=	O
0	int
;	O
if	O
(	O
tnamep	*(*(char))
&&	O
tnamep	*(*(char))
!=	O
unknown	array(*(char))
)	O
free	(*(void))->(void)
(	O
tnamep	*(*(char))
)	O
;	O
if	O
(	O
(	O
tname	*(char)
=	O
(	O
char	O
*	O
)	O
env_getvalue	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
)	O
&&	O
(	O
init_term	(*(char),int,*(int))->(int)
(	O
tname	*(char)
,	O
1	int
,	O
&	O
err	long
)	O
==	O
0	int
)	O
)	O
{	O
tnamep	*(*(char))
=	O
mklist	(*(char),*(char))->(*(*(char)))
(	O
termbuf	array(char)
,	O
tname	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tname	*(char)
&&	O
(	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
tname	*(char)
)	O
<=	O
40	int
)	O
)	O
{	O
unknown	array(*(char))
[	O
0	int
]	O
=	O
tname	*(char)
;	O
upcase	(*(char))->(void)
(	O
tname	*(char)
)	O
;	O
}	O
else	O
unknown	array(*(char))
[	O
0	int
]	O
=	O
name_unknown	*(char)
;	O
tnamep	*(*(char))
=	O
unknown	array(*(char))
;	O
}	O
next	*(*(char))
=	O
tnamep	*(*(char))
;	O
}	O
if	O
(	O
*	O
next	*(*(char))
==	O
0	int
)	O
next	*(*(char))
=	O
tnamep	*(*(char))
;	O
return	O
(	O
*	O
next	*(*(char))
++	O
)	O
;	O
}	O
static	O
void	O
suboption	()->(void)
(	O
void	O
)	O
{	O
unsigned	O
char	O
subchar	char
;	O
printsub	(char,*(char),int)->(void)
(	O
'<'	O
,	O
subbuffer	array(char)
,	O
SB_LEN	O
(	O
)	O
+	O
2	int
)	O
;	O
switch	O
(	O
subchar	char
=	O
SB_GET	O
(	O
)	O
)	O
{	O
case	O
TELOPT_TTYPE	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_TTYPE	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
||	O
SB_GET	O
(	O
)	O
!=	O
TELQUAL_SEND	int
)	O
{	O
return	O
;	O
}	O
else	O
{	O
char	O
*	O
name	*(char)
;	O
unsigned	O
char	O
temp	array(char)
[	O
50	int
]	O
;	O
int	O
len	int
;	O
name	*(char)
=	O
gettermname	()->(*(char))
(	O
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
4	int
+	O
2	int
;	O
if	O
(	O
len	int
<	O
NETROOM	O
(	O
)	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
temp	array(char)
,	O
"%c%c%c%c%s%c%c"	*(char)
,	O
IAC	int
,	O
SB	int
,	O
TELOPT_TTYPE	int
,	O
TELQUAL_IS	int
,	O
name	*(char)
,	O
IAC	int
,	O
SE	int
)	O
;	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
temp	array(char)
,	O
len	int
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
&	O
temp	array(char)
[	O
2	int
]	O
,	O
len	int
-	O
2	int
)	O
;	O
}	O
else	O
{	O
ExitString	(*(char),int)->(void)
(	O
"No room in buffer for terminal type.\n"	*(char)
,	O
1	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
TELOPT_TSPEED	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_TSPEED	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
if	O
(	O
SB_GET	O
(	O
)	O
==	O
TELQUAL_SEND	int
)	O
{	O
long	O
ospeed	*(long)
,	O
ispeed	*(long)
;	O
unsigned	O
char	O
temp	array(char)
[	O
50	int
]	O
;	O
int	O
len	int
;	O
TerminalSpeeds	(*(long),*(long))->(void)
(	O
&	O
ispeed	*(long)
,	O
&	O
ospeed	*(long)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
temp	array(char)
,	O
"%c%c%c%c%d,%d%c%c"	*(char)
,	O
IAC	int
,	O
SB	int
,	O
TELOPT_TSPEED	int
,	O
TELQUAL_IS	int
,	O
(	O
int	O
)	O
ospeed	*(long)
,	O
(	O
int	O
)	O
ispeed	*(long)
,	O
IAC	int
,	O
SE	int
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
temp	array(char)
+	O
4	int
)	O
+	O
4	int
;	O
if	O
(	O
len	int
<	O
NETROOM	O
(	O
)	O
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
temp	array(char)
,	O
len	int
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
temp	array(char)
+	O
2	int
,	O
len	int
-	O
2	int
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"lm_will: not enough room in buffer\n"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
TELOPT_LFLOW	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_LFLOW	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
switch	O
(	O
SB_GET	O
(	O
)	O
)	O
{	O
case	O
LFLOW_RESTART_ANY	int
:	O
restartany	int
=	O
1	int
;	O
break	O
;	O
case	O
LFLOW_RESTART_XON	int
:	O
restartany	int
=	O
0	int
;	O
break	O
;	O
case	O
LFLOW_ON	int
:	O
localflow	int
=	O
1	int
;	O
break	O
;	O
case	O
LFLOW_OFF	int
:	O
localflow	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
return	O
;	O
}	O
setcommandmode	()->(void)
(	O
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
TELOPT_LINEMODE	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
switch	O
(	O
SB_GET	O
(	O
)	O
)	O
{	O
case	O
WILL	int
:	O
lm_will	(*(char),int)->(void)
(	O
subpointer	*(char)
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
WONT	int
:	O
lm_wont	(*(char),int)->(void)
(	O
subpointer	*(char)
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
DO	int
:	O
lm_do	(*(char),int)->(void)
(	O
subpointer	*(char)
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
DONT	int
:	O
lm_dont	(*(char),int)->(void)
(	O
subpointer	*(char)
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
LM_SLC	int
:	O
slc	(*(char),int)->(void)
(	O
subpointer	*(char)
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
LM_MODE	int
:	O
lm_mode	(*(char),int,int)->(void)
(	O
subpointer	*(char)
,	O
SB_LEN	O
(	O
)	O
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
TELOPT_NEW_ENVIRON	int
:	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
switch	O
(	O
SB_PEEK	O
(	O
)	O
)	O
{	O
case	O
TELQUAL_IS	int
:	O
case	O
TELQUAL_INFO	int
:	O
if	O
(	O
my_want_state_is_dont	O
(	O
subchar	char
)	O
)	O
return	O
;	O
break	O
;	O
case	O
TELQUAL_SEND	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
subchar	char
)	O
)	O
{	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
;	O
}	O
env_opt	(*(char),int)->(void)
(	O
subpointer	*(char)
,	O
SB_LEN	O
(	O
)	O
)	O
;	O
break	O
;	O
case	O
TELOPT_XDISPLOC	int
:	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_XDISPLOC	int
)	O
)	O
return	O
;	O
if	O
(	O
SB_EOF	O
(	O
)	O
)	O
return	O
;	O
if	O
(	O
SB_GET	O
(	O
)	O
==	O
TELQUAL_SEND	int
)	O
{	O
unsigned	O
char	O
temp	array(char)
[	O
50	int
]	O
,	O
*	O
dp	*(char)
;	O
int	O
len	int
;	O
if	O
(	O
(	O
dp	*(char)
=	O
env_getvalue	(*(char))->(*(char))
(	O
"DISPLAY"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
send_wont	(int,int)->(void)
(	O
TELOPT_XDISPLOC	int
,	O
1	int
)	O
;	O
break	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
(	O
char	O
*	O
)	O
temp	array(char)
,	O
"%c%c%c%c%s%c%c"	*(char)
,	O
IAC	int
,	O
SB	int
,	O
TELOPT_XDISPLOC	int
,	O
TELQUAL_IS	int
,	O
dp	*(char)
,	O
IAC	int
,	O
SE	int
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
temp	array(char)
+	O
4	int
)	O
+	O
4	int
;	O
if	O
(	O
len	int
<	O
NETROOM	O
(	O
)	O
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
temp	array(char)
,	O
len	int
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
temp	array(char)
+	O
2	int
,	O
len	int
-	O
2	int
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"lm_will: not enough room in buffer\n"	*(char)
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
unsigned	O
char	O
str_lm	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_LINEMODE	int
,	O
0	int
,	O
0	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
void	O
lm_will	(*(char),int)->(void)
(	O
unsigned	O
char	O
*	O
cmd	*(char)
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
<	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"lm_will: no command!!!\n"	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
cmd	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
str_lm	array(char)
[	O
3	int
]	O
=	O
DONT	int
;	O
str_lm	array(char)
[	O
4	int
]	O
=	O
cmd	*(char)
[	O
0	int
]	O
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
sizeof	O
(	O
str_lm	array(char)
)	O
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
str_lm	array(char)
,	O
sizeof	O
(	O
str_lm	array(char)
)	O
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
&	O
str_lm	array(char)
[	O
2	int
]	O
,	O
sizeof	O
(	O
str_lm	array(char)
)	O
-	O
2	int
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"lm_will: not enough room in buffer\n"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
void	O
lm_wont	(*(char),int)->(void)
(	O
unsigned	O
char	O
*	O
cmd	*(char)
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
<	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"lm_wont: no command!!!\n"	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
cmd	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
return	O
;	O
}	O
}	O
void	O
lm_do	(*(char),int)->(void)
(	O
unsigned	O
char	O
*	O
cmd	*(char)
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
<	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"lm_do: no command!!!\n"	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
cmd	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
str_lm	array(char)
[	O
3	int
]	O
=	O
WONT	int
;	O
str_lm	array(char)
[	O
4	int
]	O
=	O
cmd	*(char)
[	O
0	int
]	O
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
sizeof	O
(	O
str_lm	array(char)
)	O
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
str_lm	array(char)
,	O
sizeof	O
(	O
str_lm	array(char)
)	O
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
&	O
str_lm	array(char)
[	O
2	int
]	O
,	O
sizeof	O
(	O
str_lm	array(char)
)	O
-	O
2	int
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"lm_do: not enough room in buffer\n"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
void	O
lm_dont	(*(char),int)->(void)
(	O
unsigned	O
char	O
*	O
cmd	*(char)
,	O
int	O
len	int
)	O
{	O
if	O
(	O
len	int
<	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"lm_dont: no command!!!\n"	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
cmd	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
LM_FORWARDMASK	int
:	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
unsigned	O
char	O
str_lm_mode	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_LINEMODE	int
,	O
LM_MODE	int
,	O
0	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
void	O
lm_mode	(*(char),int,int)->(void)
(	O
unsigned	O
char	O
*	O
cmd	*(char)
,	O
int	O
len	int
,	O
int	O
init	int
)	O
{	O
if	O
(	O
len	int
!=	O
1	int
)	O
return	O
;	O
if	O
(	O
(	O
linemode	int
&	O
MODE_MASK	int
&	O
~	O
MODE_ACK	int
)	O
==	O
*	O
cmd	*(char)
)	O
return	O
;	O
if	O
(	O
*	O
cmd	*(char)
&	O
MODE_ACK	int
)	O
return	O
;	O
linemode	int
=	O
*	O
cmd	*(char)
&	O
(	O
MODE_MASK	int
&	O
~	O
MODE_ACK	int
)	O
;	O
str_lm_mode	array(char)
[	O
4	int
]	O
=	O
linemode	int
;	O
if	O
(	O
!	O
init	int
)	O
str_lm_mode	array(char)
[	O
4	int
]	O
|=	O
MODE_ACK	int
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
sizeof	O
(	O
str_lm_mode	array(char)
)	O
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
str_lm_mode	array(char)
,	O
sizeof	O
(	O
str_lm_mode	array(char)
)	O
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
&	O
str_lm_mode	array(char)
[	O
2	int
]	O
,	O
sizeof	O
(	O
str_lm_mode	array(char)
)	O
-	O
2	int
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"lm_mode: not enough room in buffer\n"	*(char)
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
}	O
struct	O
spc	struct(char,*(char),char,char)
{	O
cc_t	char
val	char
;	O
cc_t	char
*	O
valp	*(char)
;	O
char	O
flags	char
;	O
char	O
mylevel	char
;	O
}	O
spc_data	array(struct(char,*(char),char,char))
[	O
NSLC	int
+	O
1	int
]	O
;	O
static	O
int	O
slc_mode	int
=	O
SLC_EXPORT	int
;	O
void	O
slc_init	()->(void)
(	O
void	O
)	O
{	O
register	O
struct	O
spc	struct(char,*(char),char,char)
*	O
spcp	*(struct(char,*(char),char,char))
;	O
localchars	int
=	O
1	int
;	O
for	O
(	O
spcp	*(struct(char,*(char),char,char))
=	O
spc_data	array(struct(char,*(char),char,char))
;	O
spcp	*(struct(char,*(char),char,char))
<	O
&	O
spc_data	array(struct(char,*(char),char,char))
[	O
NSLC	int
+	O
1	int
]	O
;	O
spcp	*(struct(char,*(char),char,char))
++	O
)	O
{	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
=	O
0	int
;	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
=	O
0	int
;	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
spcp	*(struct(char,*(char),char,char))
->	O
mylevel	char
=	O
SLC_NOSUPPORT	int
;	O
}	O
initfunc	O
(	O
SLC_SYNCH	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_AO	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_AYT	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_ABORT	int
,	O
SLC_FLUSHIN	int
|	O
SLC_FLUSHOUT	int
)	O
;	O
initfunc	O
(	O
SLC_EOF	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_SUSP	int
,	O
SLC_FLUSHIN	int
)	O
;	O
initfunc	O
(	O
SLC_EC	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_EL	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_EW	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_RP	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_LNEXT	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_XON	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_XOFF	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_FORW1	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_FORW2	int
,	O
0	int
)	O
;	O
initfunc	O
(	O
SLC_IP	int
,	O
SLC_FLUSHIN	int
|	O
SLC_FLUSHOUT	int
)	O
;	O
if	O
(	O
slc_mode	int
==	O
SLC_EXPORT	int
)	O
slc_export	()->(void)
(	O
)	O
;	O
else	O
slc_import	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
slcstate	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Special characters are %s values\n"	*(char)
,	O
slc_mode	int
==	O
SLC_IMPORT	int
?	O
"remote default"	*(char)
:	O
slc_mode	int
==	O
SLC_EXPORT	int
?	O
"local"	*(char)
:	O
"remote"	*(char)
)	O
;	O
}	O
void	O
slc_mode_export	()->(void)
(	O
void	O
)	O
{	O
slc_mode	int
=	O
SLC_EXPORT	int
;	O
if	O
(	O
my_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
slc_export	()->(void)
(	O
)	O
;	O
}	O
void	O
slc_mode_import	(int)->(void)
(	O
int	O
def	int
)	O
{	O
slc_mode	int
=	O
def	int
?	O
SLC_IMPORT	int
:	O
SLC_RVALUE	int
;	O
if	O
(	O
my_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
slc_import	(int)->(void)
(	O
def	int
)	O
;	O
}	O
unsigned	O
char	O
slc_import_val	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_LINEMODE	int
,	O
LM_SLC	int
,	O
0	int
,	O
SLC_VARIABLE	int
,	O
0	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
unsigned	O
char	O
slc_import_def	array(char)
[	O
]	O
=	O
{	O
IAC	int
,	O
SB	int
,	O
TELOPT_LINEMODE	int
,	O
LM_SLC	int
,	O
0	int
,	O
SLC_DEFAULT	int
,	O
0	int
,	O
IAC	int
,	O
SE	int
}	O
;	O
void	O
slc_import	(int)->(void)
(	O
int	O
def	int
)	O
{	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
sizeof	O
(	O
slc_import_val	array(char)
)	O
)	O
{	O
if	O
(	O
def	int
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
slc_import_def	array(char)
,	O
sizeof	O
(	O
slc_import_def	array(char)
)	O
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
&	O
slc_import_def	array(char)
[	O
2	int
]	O
,	O
sizeof	O
(	O
slc_import_def	array(char)
)	O
-	O
2	int
)	O
;	O
}	O
else	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
slc_import_val	array(char)
,	O
sizeof	O
(	O
slc_import_val	array(char)
)	O
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
&	O
slc_import_val	array(char)
[	O
2	int
]	O
,	O
sizeof	O
(	O
slc_import_val	array(char)
)	O
-	O
2	int
)	O
;	O
}	O
}	O
else	O
printf	(*(char))->(int)
(	O
"slc_import: not enough room\n"	*(char)
)	O
;	O
}	O
void	O
slc_export	()->(void)
(	O
void	O
)	O
{	O
register	O
struct	O
spc	struct(char,*(char),char,char)
*	O
spcp	*(struct(char,*(char),char,char))
;	O
TerminalDefaultChars	()->(void)
(	O
)	O
;	O
slc_start_reply	()->(void)
(	O
)	O
;	O
for	O
(	O
spcp	*(struct(char,*(char),char,char))
=	O
&	O
spc_data	array(struct(char,*(char),char,char))
[	O
1	int
]	O
;	O
spcp	*(struct(char,*(char),char,char))
<	O
&	O
spc_data	array(struct(char,*(char),char,char))
[	O
NSLC	int
+	O
1	int
]	O
;	O
spcp	*(struct(char,*(char),char,char))
++	O
)	O
{	O
if	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
mylevel	char
!=	O
SLC_NOSUPPORT	int
)	O
{	O
if	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
==	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
SLC_NOSUPPORT	int
;	O
else	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
spcp	*(struct(char,*(char),char,char))
->	O
mylevel	char
;	O
if	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
)	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
=	O
*	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
;	O
slc_add_reply	(char,char,char)->(void)
(	O
spcp	*(struct(char,*(char),char,char))
-	O
spc_data	array(struct(char,*(char),char,char))
,	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
,	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
)	O
;	O
}	O
}	O
slc_end_reply	()->(void)
(	O
)	O
;	O
slc_update	()->(int)
(	O
)	O
;	O
setconnmode	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
slc	(*(char),int)->(void)
(	O
register	O
unsigned	O
char	O
*	O
cp	*(char)
,	O
int	O
len	int
)	O
{	O
register	O
struct	O
spc	struct(char,*(char),char,char)
*	O
spcp	*(struct(char,*(char),char,char))
;	O
register	O
int	O
func	int
,	O
level	int
;	O
slc_start_reply	()->(void)
(	O
)	O
;	O
for	O
(	O
;	O
len	int
>=	O
3	int
;	O
len	int
-=	O
3	int
,	O
cp	*(char)
+=	O
3	int
)	O
{	O
func	int
=	O
cp	*(char)
[	O
SLC_FUNC	int
]	O
;	O
if	O
(	O
func	int
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
func	int
>	O
NSLC	int
)	O
{	O
if	O
(	O
(	O
cp	*(char)
[	O
SLC_FLAGS	int
]	O
&	O
SLC_LEVELBITS	int
)	O
!=	O
SLC_NOSUPPORT	int
)	O
slc_add_reply	(char,char,char)->(void)
(	O
func	int
,	O
SLC_NOSUPPORT	int
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
spcp	*(struct(char,*(char),char,char))
=	O
&	O
spc_data	array(struct(char,*(char),char,char))
[	O
func	int
]	O
;	O
level	int
=	O
cp	*(char)
[	O
SLC_FLAGS	int
]	O
&	O
(	O
SLC_LEVELBITS	int
|	O
SLC_ACK	int
)	O
;	O
if	O
(	O
(	O
cp	*(char)
[	O
SLC_VALUE	int
]	O
==	O
(	O
unsigned	O
char	O
)	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
)	O
&&	O
(	O
(	O
level	int
&	O
SLC_LEVELBITS	int
)	O
==	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
&	O
SLC_LEVELBITS	int
)	O
)	O
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
level	int
==	O
(	O
SLC_DEFAULT	int
|	O
SLC_ACK	int
)	O
)	O
{	O
cp	*(char)
[	O
SLC_FLAGS	int
]	O
&=	O
~	O
SLC_ACK	int
;	O
}	O
if	O
(	O
level	int
==	O
(	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
&	O
SLC_LEVELBITS	int
)	O
|	O
SLC_ACK	int
)	O
)	O
{	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
=	O
(	O
cc_t	char
)	O
cp	*(char)
[	O
SLC_VALUE	int
]	O
;	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
cp	*(char)
[	O
SLC_FLAGS	int
]	O
;	O
continue	O
;	O
}	O
level	int
&=	O
~	O
SLC_ACK	int
;	O
if	O
(	O
level	int
<=	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
mylevel	char
&	O
SLC_LEVELBITS	int
)	O
)	O
{	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
cp	*(char)
[	O
SLC_FLAGS	int
]	O
|	O
SLC_ACK	int
;	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
=	O
(	O
cc_t	char
)	O
cp	*(char)
[	O
SLC_VALUE	int
]	O
;	O
}	O
if	O
(	O
level	int
==	O
SLC_DEFAULT	int
)	O
{	O
if	O
(	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
mylevel	char
&	O
SLC_LEVELBITS	int
)	O
!=	O
SLC_DEFAULT	int
)	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
spcp	*(struct(char,*(char),char,char))
->	O
mylevel	char
;	O
else	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
SLC_NOSUPPORT	int
;	O
}	O
slc_add_reply	(char,char,char)->(void)
(	O
func	int
,	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
,	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
)	O
;	O
}	O
slc_end_reply	()->(void)
(	O
)	O
;	O
if	O
(	O
slc_update	()->(int)
(	O
)	O
)	O
setconnmode	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
slc_check	()->(void)
(	O
void	O
)	O
{	O
register	O
struct	O
spc	struct(char,*(char),char,char)
*	O
spcp	*(struct(char,*(char),char,char))
;	O
slc_start_reply	()->(void)
(	O
)	O
;	O
for	O
(	O
spcp	*(struct(char,*(char),char,char))
=	O
&	O
spc_data	array(struct(char,*(char),char,char))
[	O
1	int
]	O
;	O
spcp	*(struct(char,*(char),char,char))
<	O
&	O
spc_data	array(struct(char,*(char),char,char))
[	O
NSLC	int
+	O
1	int
]	O
;	O
spcp	*(struct(char,*(char),char,char))
++	O
)	O
{	O
if	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
&&	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
!=	O
*	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
)	O
{	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
=	O
*	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
;	O
if	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
==	O
(	O
cc_t	char
)	O
(	O
_POSIX_VDISABLE	char
)	O
)	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
SLC_NOSUPPORT	int
;	O
else	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
=	O
spcp	*(struct(char,*(char),char,char))
->	O
mylevel	char
;	O
slc_add_reply	(char,char,char)->(void)
(	O
spcp	*(struct(char,*(char),char,char))
-	O
spc_data	array(struct(char,*(char),char,char))
,	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
,	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
)	O
;	O
}	O
}	O
slc_end_reply	()->(void)
(	O
)	O
;	O
setconnmode	(int)->(void)
(	O
1	int
)	O
;	O
}	O
unsigned	O
char	O
slc_reply	array(char)
[	O
128	int
]	O
;	O
unsigned	O
char	O
*	O
slc_replyp	*(char)
;	O
void	O
slc_start_reply	()->(void)
(	O
void	O
)	O
{	O
slc_replyp	*(char)
=	O
slc_reply	array(char)
;	O
*	O
slc_replyp	*(char)
++	O
=	O
IAC	int
;	O
*	O
slc_replyp	*(char)
++	O
=	O
SB	int
;	O
*	O
slc_replyp	*(char)
++	O
=	O
TELOPT_LINEMODE	int
;	O
*	O
slc_replyp	*(char)
++	O
=	O
LM_SLC	int
;	O
}	O
void	O
slc_add_reply	(char,char,char)->(void)
(	O
unsigned	O
char	O
func	int
,	O
unsigned	O
char	O
flags	char
,	O
cc_t	char
value	char
)	O
{	O
if	O
(	O
(	O
*	O
slc_replyp	*(char)
++	O
=	O
func	int
)	O
==	O
IAC	int
)	O
*	O
slc_replyp	*(char)
++	O
=	O
IAC	int
;	O
if	O
(	O
(	O
*	O
slc_replyp	*(char)
++	O
=	O
flags	char
)	O
==	O
IAC	int
)	O
*	O
slc_replyp	*(char)
++	O
=	O
IAC	int
;	O
if	O
(	O
(	O
*	O
slc_replyp	*(char)
++	O
=	O
(	O
unsigned	O
char	O
)	O
value	char
)	O
==	O
IAC	int
)	O
*	O
slc_replyp	*(char)
++	O
=	O
IAC	int
;	O
}	O
void	O
slc_end_reply	()->(void)
(	O
void	O
)	O
{	O
register	O
int	O
len	int
;	O
*	O
slc_replyp	*(char)
++	O
=	O
IAC	int
;	O
*	O
slc_replyp	*(char)
++	O
=	O
SE	int
;	O
len	int
=	O
slc_replyp	*(char)
-	O
slc_reply	array(char)
;	O
if	O
(	O
len	int
<=	O
6	int
)	O
return	O
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
len	int
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
slc_reply	array(char)
,	O
slc_replyp	*(char)
-	O
slc_reply	array(char)
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
&	O
slc_reply	array(char)
[	O
2	int
]	O
,	O
slc_replyp	*(char)
-	O
slc_reply	array(char)
-	O
2	int
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"slc_end_reply: not enough room\n"	*(char)
)	O
;	O
}	O
int	O
slc_update	()->(int)
(	O
void	O
)	O
{	O
register	O
struct	O
spc	struct(char,*(char),char,char)
*	O
spcp	*(struct(char,*(char),char,char))
;	O
int	O
need_update	int
=	O
0	int
;	O
for	O
(	O
spcp	*(struct(char,*(char),char,char))
=	O
&	O
spc_data	array(struct(char,*(char),char,char))
[	O
1	int
]	O
;	O
spcp	*(struct(char,*(char),char,char))
<	O
&	O
spc_data	array(struct(char,*(char),char,char))
[	O
NSLC	int
+	O
1	int
]	O
;	O
spcp	*(struct(char,*(char),char,char))
++	O
)	O
{	O
if	O
(	O
!	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
&	O
SLC_ACK	int
)	O
)	O
continue	O
;	O
spcp	*(struct(char,*(char),char,char))
->	O
flags	char
&=	O
~	O
SLC_ACK	int
;	O
if	O
(	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
&&	O
(	O
*	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
!=	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
)	O
)	O
{	O
*	O
spcp	*(struct(char,*(char),char,char))
->	O
valp	*(char)
=	O
spcp	*(struct(char,*(char),char,char))
->	O
val	char
;	O
need_update	int
=	O
1	int
;	O
}	O
}	O
return	O
(	O
need_update	int
)	O
;	O
}	O
void	O
env_opt	(*(char),int)->(void)
(	O
register	O
unsigned	O
char	O
*	O
buf	*(char)
,	O
register	O
int	O
len	int
)	O
{	O
register	O
unsigned	O
char	O
*	O
ep	*(char)
=	O
0	int
,	O
*	O
epc	*(char)
=	O
0	int
;	O
register	O
int	O
i	int
;	O
switch	O
(	O
buf	*(char)
[	O
0	int
]	O
&	O
0xff	int
)	O
{	O
case	O
TELQUAL_SEND	int
:	O
env_opt_start	()->(void)
(	O
)	O
;	O
if	O
(	O
len	int
==	O
1	int
)	O
{	O
env_opt_add	(*(char))->(void)
(	O
NULL	O
)	O
;	O
}	O
else	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
buf	*(char)
[	O
i	int
]	O
&	O
0xff	int
)	O
{	O
case	O
NEW_ENV_VAR	int
:	O
case	O
ENV_USERVAR	int
:	O
if	O
(	O
ep	*(char)
)	O
{	O
*	O
epc	*(char)
=	O
0	int
;	O
env_opt_add	(*(char))->(void)
(	O
ep	*(char)
)	O
;	O
}	O
ep	*(char)
=	O
epc	*(char)
=	O
&	O
buf	*(char)
[	O
i	int
+	O
1	int
]	O
;	O
break	O
;	O
case	O
ENV_ESC	int
:	O
i	int
++	O
;	O
default	O
:	O
if	O
(	O
epc	*(char)
)	O
*	O
epc	*(char)
++	O
=	O
buf	*(char)
[	O
i	int
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
ep	*(char)
)	O
{	O
*	O
epc	*(char)
=	O
0	int
;	O
env_opt_add	(*(char))->(void)
(	O
ep	*(char)
)	O
;	O
}	O
env_opt_end	(int)->(void)
(	O
1	int
)	O
;	O
break	O
;	O
case	O
TELQUAL_IS	int
:	O
case	O
TELQUAL_INFO	int
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
unsigned	O
char	O
*	O
opt_reply	*(char)
;	O
unsigned	O
char	O
*	O
opt_replyp	*(char)
;	O
unsigned	O
char	O
*	O
opt_replyend	*(char)
;	O
void	O
env_opt_start	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
opt_reply	*(char)
)	O
opt_reply	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
opt_reply	*(char)
,	O
OPT_REPLY_SIZE	int
)	O
;	O
else	O
opt_reply	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
OPT_REPLY_SIZE	int
)	O
;	O
if	O
(	O
opt_reply	*(char)
==	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"env_opt_start: malloc()/realloc() failed!!!\n"	*(char)
)	O
;	O
opt_reply	*(char)
=	O
opt_replyp	*(char)
=	O
opt_replyend	*(char)
=	O
NULL	O
;	O
return	O
;	O
}	O
opt_replyp	*(char)
=	O
opt_reply	*(char)
;	O
opt_replyend	*(char)
=	O
opt_reply	*(char)
+	O
OPT_REPLY_SIZE	int
;	O
*	O
opt_replyp	*(char)
++	O
=	O
IAC	int
;	O
*	O
opt_replyp	*(char)
++	O
=	O
SB	int
;	O
*	O
opt_replyp	*(char)
++	O
=	O
telopt_environ	O
;	O
*	O
opt_replyp	*(char)
++	O
=	O
TELQUAL_IS	int
;	O
}	O
void	O
env_opt_start_info	()->(void)
(	O
void	O
)	O
{	O
env_opt_start	()->(void)
(	O
)	O
;	O
if	O
(	O
opt_replyp	*(char)
)	O
opt_replyp	*(char)
[	O
-	O
1	int
]	O
=	O
TELQUAL_INFO	int
;	O
}	O
void	O
env_opt_add	(*(char))->(void)
(	O
register	O
unsigned	O
char	O
*	O
ep	*(char)
)	O
{	O
register	O
unsigned	O
char	O
*	O
vp	*(char)
,	O
c	int
;	O
if	O
(	O
opt_reply	*(char)
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
ep	*(char)
==	O
NULL	O
||	O
*	O
ep	*(char)
==	O
'\0'	O
)	O
{	O
env_default	(int,int)->(*(char))
(	O
1	int
,	O
0	int
)	O
;	O
while	O
(	O
(	O
ep	*(char)
=	O
env_default	(int,int)->(*(char))
(	O
0	int
,	O
0	int
)	O
)	O
)	O
env_opt_add	(*(char))->(void)
(	O
ep	*(char)
)	O
;	O
env_default	(int,int)->(*(char))
(	O
1	int
,	O
1	int
)	O
;	O
while	O
(	O
(	O
ep	*(char)
=	O
env_default	(int,int)->(*(char))
(	O
0	int
,	O
1	int
)	O
)	O
)	O
env_opt_add	(*(char))->(void)
(	O
ep	*(char)
)	O
;	O
return	O
;	O
}	O
vp	*(char)
=	O
env_getvalue	(*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
ep	*(char)
)	O
;	O
if	O
(	O
opt_replyp	*(char)
+	O
(	O
vp	*(char)
?	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
vp	*(char)
)	O
:	O
0	int
)	O
+	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
ep	*(char)
)	O
+	O
6	int
>	O
opt_replyend	*(char)
)	O
{	O
register	O
int	O
len	int
;	O
opt_replyend	*(char)
+=	O
OPT_REPLY_SIZE	int
;	O
len	int
=	O
opt_replyend	*(char)
-	O
opt_reply	*(char)
;	O
opt_reply	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
opt_reply	*(char)
,	O
len	int
)	O
;	O
if	O
(	O
opt_reply	*(char)
==	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"env_opt_add: realloc() failed!!!\n"	*(char)
)	O
;	O
opt_reply	*(char)
=	O
opt_replyp	*(char)
=	O
opt_replyend	*(char)
=	O
NULL	O
;	O
return	O
;	O
}	O
opt_replyp	*(char)
=	O
opt_reply	*(char)
+	O
len	int
-	O
(	O
opt_replyend	*(char)
-	O
opt_replyp	*(char)
)	O
;	O
opt_replyend	*(char)
=	O
opt_reply	*(char)
+	O
len	int
;	O
}	O
if	O
(	O
opt_welldefined	(*(char))->(int)
(	O
(	O
char	O
*	O
)	O
ep	*(char)
)	O
)	O
*	O
opt_replyp	*(char)
++	O
=	O
NEW_ENV_VAR	int
;	O
else	O
*	O
opt_replyp	*(char)
++	O
=	O
ENV_USERVAR	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
*	O
ep	*(char)
++	O
)	O
)	O
{	O
switch	O
(	O
c	int
&	O
0xff	int
)	O
{	O
case	O
IAC	int
:	O
*	O
opt_replyp	*(char)
++	O
=	O
IAC	int
;	O
break	O
;	O
case	O
NEW_ENV_VAR	int
:	O
case	O
NEW_ENV_VALUE	int
:	O
case	O
ENV_ESC	int
:	O
case	O
ENV_USERVAR	int
:	O
*	O
opt_replyp	*(char)
++	O
=	O
ENV_ESC	int
;	O
break	O
;	O
}	O
*	O
opt_replyp	*(char)
++	O
=	O
c	int
;	O
}	O
if	O
(	O
(	O
ep	*(char)
=	O
vp	*(char)
)	O
)	O
{	O
*	O
opt_replyp	*(char)
++	O
=	O
NEW_ENV_VALUE	int
;	O
vp	*(char)
=	O
NULL	O
;	O
}	O
else	O
break	O
;	O
}	O
}	O
int	O
opt_welldefined	(*(char))->(int)
(	O
char	O
*	O
ep	*(char)
)	O
{	O
if	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ep	*(char)
,	O
"USER"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ep	*(char)
,	O
"DISPLAY"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ep	*(char)
,	O
"PRINTER"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ep	*(char)
,	O
"SYSTEMTYPE"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ep	*(char)
,	O
"JOB"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ep	*(char)
,	O
"ACCT"	*(char)
)	O
==	O
0	int
)	O
)	O
return	O
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
env_opt_end	(int)->(void)
(	O
register	O
int	O
emptyok	int
)	O
{	O
register	O
int	O
len	int
;	O
len	int
=	O
opt_replyp	*(char)
-	O
opt_reply	*(char)
+	O
2	int
;	O
if	O
(	O
emptyok	int
||	O
len	int
>	O
6	int
)	O
{	O
*	O
opt_replyp	*(char)
++	O
=	O
IAC	int
;	O
*	O
opt_replyp	*(char)
++	O
=	O
SE	int
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>	O
len	int
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
opt_reply	*(char)
,	O
len	int
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
&	O
opt_reply	*(char)
[	O
2	int
]	O
,	O
len	int
-	O
2	int
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"slc_end_reply: not enough room\n"	*(char)
)	O
;	O
}	O
if	O
(	O
opt_reply	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
opt_reply	*(char)
)	O
;	O
opt_reply	*(char)
=	O
opt_replyp	*(char)
=	O
opt_replyend	*(char)
=	O
NULL	O
;	O
}	O
}	O
int	O
telrcv	()->(int)
(	O
void	O
)	O
{	O
register	O
int	O
c	int
;	O
register	O
int	O
scc	int
;	O
register	O
unsigned	O
char	O
*	O
sbp	*(char)
;	O
int	O
count	int
;	O
int	O
returnValue	int
=	O
0	int
;	O
scc	int
=	O
0	int
;	O
count	int
=	O
0	int
;	O
while	O
(	O
TTYROOM	O
(	O
)	O
>	O
2	int
)	O
{	O
if	O
(	O
scc	int
==	O
0	int
)	O
{	O
if	O
(	O
count	int
)	O
{	O
ring_consumed	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),int)->(void)
(	O
&	O
netiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
count	int
)	O
;	O
returnValue	int
=	O
1	int
;	O
count	int
=	O
0	int
;	O
}	O
sbp	*(char)
=	O
netiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
.	O
consume	*(char)
;	O
scc	int
=	O
ring_full_consecutive	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
&	O
netiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
)	O
;	O
if	O
(	O
scc	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
}	O
c	int
=	O
*	O
sbp	*(char)
++	O
&	O
0xff	int
,	O
scc	int
--	O
;	O
count	int
++	O
;	O
switch	O
(	O
telrcv_state	int
)	O
{	O
case	O
TS_CR	int
:	O
telrcv_state	int
=	O
TS_DATA	int
;	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
'\n'	O
)	O
&&	O
my_want_state_is_dont	O
(	O
TELOPT_ECHO	int
)	O
&&	O
!	O
crmod	int
)	O
{	O
TTYADD	O
(	O
c	int
)	O
;	O
break	O
;	O
}	O
case	O
TS_DATA	int
:	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
telrcv_state	int
=	O
TS_IAC	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
c	int
==	O
'\r'	O
)	O
&&	O
my_want_state_is_dont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
if	O
(	O
scc	int
>	O
0	int
)	O
{	O
c	int
=	O
*	O
sbp	*(char)
&	O
0xff	int
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
sbp	*(char)
++	O
,	O
scc	int
--	O
;	O
count	int
++	O
;	O
TTYADD	O
(	O
'\r'	O
)	O
;	O
}	O
else	O
if	O
(	O
my_want_state_is_dont	O
(	O
TELOPT_ECHO	int
)	O
&&	O
(	O
c	int
==	O
'\n'	O
)	O
)	O
{	O
sbp	*(char)
++	O
,	O
scc	int
--	O
;	O
count	int
++	O
;	O
TTYADD	O
(	O
'\n'	O
)	O
;	O
}	O
else	O
{	O
TTYADD	O
(	O
'\r'	O
)	O
;	O
if	O
(	O
crmod	int
)	O
{	O
TTYADD	O
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
telrcv_state	int
=	O
TS_CR	int
;	O
TTYADD	O
(	O
'\r'	O
)	O
;	O
if	O
(	O
crmod	int
)	O
{	O
TTYADD	O
(	O
'\n'	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
TTYADD	O
(	O
c	int
)	O
;	O
}	O
continue	O
;	O
case	O
TS_IAC	int
:	O
process_iac	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
WILL	int
:	O
telrcv_state	int
=	O
TS_WILL	int
;	O
continue	O
;	O
case	O
WONT	int
:	O
telrcv_state	int
=	O
TS_WONT	int
;	O
continue	O
;	O
case	O
DO	int
:	O
telrcv_state	int
=	O
TS_DO	int
;	O
continue	O
;	O
case	O
DONT	int
:	O
telrcv_state	int
=	O
TS_DONT	int
;	O
continue	O
;	O
case	O
DM	int
:	O
printoption	(*(char),int,int)->(void)
(	O
"RCVD"	*(char)
,	O
IAC	int
,	O
DM	int
)	O
;	O
SYNCHing	int
=	O
1	int
;	O
ttyflush	(int)->(int)
(	O
1	int
)	O
;	O
SYNCHing	int
=	O
stilloob	()->(int)
(	O
)	O
;	O
settimer	O
(	O
gotDM	int
)	O
;	O
break	O
;	O
case	O
SB	int
:	O
SB_CLEAR	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_SB	int
;	O
continue	O
;	O
case	O
IAC	int
:	O
TTYADD	O
(	O
IAC	int
)	O
;	O
break	O
;	O
case	O
NOP	int
:	O
case	O
GA	int
:	O
default	O
:	O
printoption	(*(char),int,int)->(void)
(	O
"RCVD"	*(char)
,	O
IAC	int
,	O
c	int
)	O
;	O
break	O
;	O
}	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_WILL	int
:	O
printoption	(*(char),int,int)->(void)
(	O
"RCVD"	*(char)
,	O
WILL	int
,	O
c	int
)	O
;	O
willoption	(int)->(void)
(	O
c	int
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_WONT	int
:	O
printoption	(*(char),int,int)->(void)
(	O
"RCVD"	*(char)
,	O
WONT	int
,	O
c	int
)	O
;	O
wontoption	(int)->(void)
(	O
c	int
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_DO	int
:	O
printoption	(*(char),int,int)->(void)
(	O
"RCVD"	*(char)
,	O
DO	int
,	O
c	int
)	O
;	O
dooption	(int)->(void)
(	O
c	int
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
if	O
(	O
c	int
==	O
TELOPT_NAWS	int
)	O
{	O
sendnaws	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
TELOPT_LFLOW	int
)	O
{	O
localflow	int
=	O
1	int
;	O
setcommandmode	()->(void)
(	O
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
}	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_DONT	int
:	O
printoption	(*(char),int,int)->(void)
(	O
"RCVD"	*(char)
,	O
DONT	int
,	O
c	int
)	O
;	O
dontoption	(int)->(void)
(	O
c	int
)	O
;	O
flushline	int
=	O
1	int
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
continue	O
;	O
case	O
TS_SB	int
:	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
telrcv_state	int
=	O
TS_SE	int
;	O
}	O
else	O
{	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
}	O
continue	O
;	O
case	O
TS_SE	int
:	O
if	O
(	O
c	int
!=	O
SE	int
)	O
{	O
if	O
(	O
c	int
!=	O
IAC	int
)	O
{	O
SB_ACCUM	O
(	O
IAC	int
)	O
;	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
subpointer	*(char)
-=	O
2	int
;	O
SB_TERM	O
(	O
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"In SUBOPTION processing, RCVD"	*(char)
,	O
IAC	int
,	O
c	int
)	O
;	O
suboption	()->(void)
(	O
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_IAC	int
;	O
goto	O
process_iac	O
;	O
}	O
SB_ACCUM	O
(	O
c	int
)	O
;	O
telrcv_state	int
=	O
TS_SB	int
;	O
}	O
else	O
{	O
SB_ACCUM	O
(	O
IAC	int
)	O
;	O
SB_ACCUM	O
(	O
SE	int
)	O
;	O
subpointer	*(char)
-=	O
2	int
;	O
SB_TERM	O
(	O
)	O
;	O
suboption	()->(void)
(	O
)	O
;	O
SetIn3270	O
(	O
)	O
;	O
telrcv_state	int
=	O
TS_DATA	int
;	O
}	O
}	O
}	O
if	O
(	O
count	int
)	O
ring_consumed	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),int)->(void)
(	O
&	O
netiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
count	int
)	O
;	O
return	O
returnValue	int
||	O
count	int
;	O
}	O
static	O
int	O
bol	int
=	O
1	int
,	O
local	int
=	O
0	int
;	O
int	O
rlogin_susp	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
local	int
)	O
{	O
local	int
=	O
0	int
;	O
bol	int
=	O
1	int
;	O
command	(int,*(char),int)->(void)
(	O
0	int
,	O
"z\n"	*(char)
,	O
2	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
telsnd	()->(int)
(	O
void	O
)	O
{	O
int	O
tcc	int
;	O
int	O
count	int
;	O
int	O
returnValue	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
tbp	*(char)
;	O
tcc	int
=	O
0	int
;	O
count	int
=	O
0	int
;	O
while	O
(	O
NETROOM	O
(	O
)	O
>	O
2	int
)	O
{	O
register	O
int	O
sc	int
;	O
register	O
int	O
c	int
;	O
if	O
(	O
tcc	int
==	O
0	int
)	O
{	O
if	O
(	O
count	int
)	O
{	O
ring_consumed	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),int)->(void)
(	O
&	O
ttyiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
count	int
)	O
;	O
returnValue	int
=	O
1	int
;	O
count	int
=	O
0	int
;	O
}	O
tbp	*(char)
=	O
ttyiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
.	O
consume	*(char)
;	O
tcc	int
=	O
ring_full_consecutive	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
&	O
ttyiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
)	O
;	O
if	O
(	O
tcc	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
}	O
c	int
=	O
*	O
tbp	*(char)
++	O
&	O
0xff	int
,	O
sc	int
=	O
strip	O
(	O
c	int
)	O
,	O
tcc	int
--	O
;	O
count	int
++	O
;	O
if	O
(	O
rlogin	char
!=	O
_POSIX_VDISABLE	char
)	O
{	O
if	O
(	O
bol	int
)	O
{	O
bol	int
=	O
0	int
;	O
if	O
(	O
sc	int
==	O
rlogin	char
)	O
{	O
local	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
else	O
if	O
(	O
local	int
)	O
{	O
local	int
=	O
0	int
;	O
if	O
(	O
sc	int
==	O
'.'	O
||	O
c	int
==	O
termEofChar	O
)	O
{	O
bol	int
=	O
1	int
;	O
command	(int,*(char),int)->(void)
(	O
0	int
,	O
"close\n"	*(char)
,	O
6	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
sc	int
==	O
termSuspChar	O
)	O
{	O
bol	int
=	O
1	int
;	O
command	(int,*(char),int)->(void)
(	O
0	int
,	O
"z\n"	*(char)
,	O
2	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
sc	int
==	O
escape	char
)	O
{	O
command	(int,*(char),int)->(void)
(	O
0	int
,	O
(	O
char	O
*	O
)	O
tbp	*(char)
,	O
tcc	int
)	O
;	O
bol	int
=	O
1	int
;	O
count	int
+=	O
tcc	int
;	O
tcc	int
=	O
0	int
;	O
flushline	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
sc	int
!=	O
rlogin	char
)	O
{	O
++	O
tcc	int
;	O
--	O
tbp	*(char)
;	O
--	O
count	int
;	O
c	int
=	O
sc	int
=	O
rlogin	char
;	O
}	O
}	O
if	O
(	O
(	O
sc	int
==	O
'\n'	O
)	O
||	O
(	O
sc	int
==	O
'\r'	O
)	O
)	O
bol	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
sc	int
==	O
escape	char
)	O
{	O
if	O
(	O
tcc	int
&&	O
strip	O
(	O
*	O
tbp	*(char)
)	O
==	O
escape	char
)	O
{	O
tbp	*(char)
++	O
;	O
tcc	int
--	O
;	O
count	int
++	O
;	O
bol	int
=	O
0	int
;	O
}	O
else	O
{	O
command	(int,*(char),int)->(void)
(	O
0	int
,	O
(	O
char	O
*	O
)	O
tbp	*(char)
,	O
tcc	int
)	O
;	O
bol	int
=	O
1	int
;	O
count	int
+=	O
tcc	int
;	O
tcc	int
=	O
0	int
;	O
flushline	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
bol	int
=	O
0	int
;	O
if	O
(	O
kludgelinemode	int
&&	O
(	O
globalmode	int
&	O
MODE_EDIT	int
)	O
&&	O
(	O
sc	int
==	O
echoc	char
)	O
)	O
{	O
if	O
(	O
tcc	int
>	O
0	int
&&	O
strip	O
(	O
*	O
tbp	*(char)
)	O
==	O
echoc	char
)	O
{	O
tcc	int
--	O
;	O
tbp	*(char)
++	O
;	O
count	int
++	O
;	O
}	O
else	O
{	O
dontlecho	int
=	O
!	O
dontlecho	int
;	O
settimer	O
(	O
echotoggle	int
)	O
;	O
setconnmode	(int)->(void)
(	O
0	int
)	O
;	O
flushline	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
MODE_LOCAL_CHARS	O
(	O
globalmode	int
)	O
)	O
{	O
if	O
(	O
TerminalSpecialChars	(int)->(int)
(	O
sc	int
)	O
==	O
0	int
)	O
{	O
bol	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\n'	O
:	O
if	O
(	O
MODE_LOCAL_CHARS	O
(	O
globalmode	int
)	O
)	O
{	O
NETADD	O
(	O
'\r'	O
)	O
;	O
}	O
NETADD	O
(	O
'\n'	O
)	O
;	O
bol	int
=	O
flushline	int
=	O
1	int
;	O
break	O
;	O
case	O
'\r'	O
:	O
if	O
(	O
!	O
crlf	int
)	O
{	O
NET2ADD	O
(	O
'\r'	O
,	O
'\0'	O
)	O
;	O
}	O
else	O
{	O
NET2ADD	O
(	O
'\r'	O
,	O
'\n'	O
)	O
;	O
}	O
bol	int
=	O
flushline	int
=	O
1	int
;	O
break	O
;	O
case	O
IAC	int
:	O
NET2ADD	O
(	O
IAC	int
,	O
IAC	int
)	O
;	O
break	O
;	O
default	O
:	O
NETADD	O
(	O
c	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
IAC	int
)	O
;	O
}	O
else	O
{	O
NETADD	O
(	O
c	int
)	O
;	O
}	O
}	O
if	O
(	O
count	int
)	O
ring_consumed	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),int)->(void)
(	O
&	O
ttyiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
count	int
)	O
;	O
return	O
returnValue	int
||	O
count	int
;	O
}	O
int	O
Scheduler	(int)->(int)
(	O
int	O
block	int
)	O
{	O
int	O
returnValue	int
;	O
int	O
netin	int
,	O
netout	int
,	O
netex	int
,	O
ttyin	int
,	O
ttyout	int
;	O
netout	int
=	O
ring_full_count	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
)	O
&&	O
(	O
flushline	int
||	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
&&	O
(	O
!	O
kludgelinemode	int
||	O
my_want_state_is_do	O
(	O
TELOPT_SGA	int
)	O
)	O
)	O
||	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
)	O
;	O
ttyout	int
=	O
ring_full_count	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
&	O
ttyoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
)	O
;	O
ttyin	int
=	O
ring_empty_count	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
&	O
ttyiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
)	O
;	O
netin	int
=	O
!	O
ISend	int
&&	O
ring_empty_count	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
&	O
netiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
)	O
;	O
netex	int
=	O
!	O
SYNCHing	int
;	O
returnValue	int
=	O
process_rings	(int,int,int,int,int,int)->(int)
(	O
netin	int
,	O
netout	int
,	O
netex	int
,	O
ttyin	int
,	O
ttyout	int
,	O
!	O
block	int
)	O
;	O
if	O
(	O
ring_full_count	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
&	O
ttyiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
)	O
)	O
{	O
returnValue	int
|=	O
telsnd	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
ring_full_count	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
&	O
netiring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
)	O
)	O
{	O
returnValue	int
|=	O
telrcv	()->(int)
(	O
)	O
;	O
}	O
return	O
returnValue	int
;	O
}	O
void	O
telnet	(*(char))->(void)
(	O
char	O
*	O
user	*(char)
)	O
{	O
sys_telnet_init	()->(void)
(	O
)	O
;	O
if	O
(	O
telnetport	int
)	O
{	O
send_do	(int,int)->(void)
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_TTYPE	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_NAWS	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_TSPEED	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_LFLOW	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
send_will	(int,int)->(void)
(	O
TELOPT_NEW_ENVIRON	int
,	O
1	int
)	O
;	O
send_do	(int,int)->(void)
(	O
TELOPT_STATUS	int
,	O
1	int
)	O
;	O
if	O
(	O
env_getvalue	(*(char))->(*(char))
(	O
"DISPLAY"	*(char)
)	O
)	O
send_will	(int,int)->(void)
(	O
TELOPT_XDISPLOC	int
,	O
1	int
)	O
;	O
if	O
(	O
eight	int
)	O
tel_enter_binary	(int)->(void)
(	O
eight	int
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
schedValue	int
;	O
while	O
(	O
(	O
schedValue	int
=	O
Scheduler	(int)->(int)
(	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
schedValue	int
==	O
-	O
1	int
)	O
{	O
setcommandmode	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
Scheduler	(int)->(int)
(	O
1	int
)	O
==	O
-	O
1	int
)	O
{	O
setcommandmode	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
netclear	()->(void)
(	O
void	O
)	O
{	O
}	O
static	O
void	O
doflush	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
DO	int
)	O
;	O
NETADD	O
(	O
TELOPT_TM	int
)	O
;	O
flushline	int
=	O
1	int
;	O
flushout	int
=	O
1	int
;	O
ttyflush	(int)->(int)
(	O
1	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
DO	int
,	O
TELOPT_TM	int
)	O
;	O
}	O
void	O
xmitAO	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
AO	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
AO	int
)	O
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	()->(void)
(	O
)	O
;	O
}	O
}	O
void	O
xmitEL	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
EL	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
EL	int
)	O
;	O
}	O
void	O
xmitEC	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
EC	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
EC	int
)	O
;	O
}	O
int	O
dosynch	()->(int)
(	O
void	O
)	O
{	O
netclear	()->(void)
(	O
)	O
;	O
NETADD	O
(	O
IAC	int
)	O
;	O
setneturg	()->(void)
(	O
)	O
;	O
NETADD	O
(	O
DM	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
DM	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
want_status_response	int
=	O
0	int
;	O
int	O
get_status	()->(int)
(	O
void	O
)	O
{	O
unsigned	O
char	O
tmp	array(char)
[	O
16	int
]	O
;	O
register	O
unsigned	O
char	O
*	O
cp	*(char)
;	O
if	O
(	O
my_want_state_is_dont	O
(	O
TELOPT_STATUS	int
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Remote side does not support STATUS option\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
cp	*(char)
=	O
tmp	array(char)
;	O
*	O
cp	*(char)
++	O
=	O
IAC	int
;	O
*	O
cp	*(char)
++	O
=	O
SB	int
;	O
*	O
cp	*(char)
++	O
=	O
TELOPT_STATUS	int
;	O
*	O
cp	*(char)
++	O
=	O
TELQUAL_SEND	int
;	O
*	O
cp	*(char)
++	O
=	O
IAC	int
;	O
*	O
cp	*(char)
++	O
=	O
SE	int
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>=	O
cp	*(char)
-	O
tmp	array(char)
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
tmp	array(char)
,	O
cp	*(char)
-	O
tmp	array(char)
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
tmp	array(char)
+	O
2	int
,	O
cp	*(char)
-	O
tmp	array(char)
-	O
2	int
)	O
;	O
}	O
++	O
want_status_response	int
;	O
return	O
1	int
;	O
}	O
void	O
intp	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
IP	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
IP	int
)	O
;	O
flushline	int
=	O
1	int
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
autosynch	int
)	O
{	O
dosynch	()->(int)
(	O
)	O
;	O
}	O
}	O
void	O
sendbrk	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
BREAK	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
BREAK	int
)	O
;	O
flushline	int
=	O
1	int
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
autosynch	int
)	O
{	O
dosynch	()->(int)
(	O
)	O
;	O
}	O
}	O
void	O
sendabort	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
ABORT	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
ABORT	int
)	O
;	O
flushline	int
=	O
1	int
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
autosynch	int
)	O
{	O
dosynch	()->(int)
(	O
)	O
;	O
}	O
}	O
void	O
sendsusp	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
SUSP	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
SUSP	int
)	O
;	O
flushline	int
=	O
1	int
;	O
if	O
(	O
autoflush	int
)	O
{	O
doflush	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
autosynch	int
)	O
{	O
dosynch	()->(int)
(	O
)	O
;	O
}	O
}	O
void	O
sendeof	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
xEOF	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
xEOF	int
)	O
;	O
}	O
void	O
sendayt	()->(void)
(	O
void	O
)	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
AYT	int
)	O
;	O
printoption	(*(char),int,int)->(void)
(	O
"SENT"	*(char)
,	O
IAC	int
,	O
AYT	int
)	O
;	O
}	O
void	O
sendnaws	()->(void)
(	O
void	O
)	O
{	O
long	O
rows	*(long)
,	O
cols	*(long)
;	O
unsigned	O
char	O
tmp	array(char)
[	O
16	int
]	O
;	O
register	O
unsigned	O
char	O
*	O
cp	*(char)
;	O
if	O
(	O
my_state_is_wont	O
(	O
TELOPT_NAWS	int
)	O
)	O
return	O
;	O
if	O
(	O
TerminalWindowSize	(*(long),*(long))->(int)
(	O
&	O
rows	*(long)
,	O
&	O
cols	*(long)
)	O
==	O
0	int
)	O
{	O
return	O
;	O
}	O
cp	*(char)
=	O
tmp	array(char)
;	O
*	O
cp	*(char)
++	O
=	O
IAC	int
;	O
*	O
cp	*(char)
++	O
=	O
SB	int
;	O
*	O
cp	*(char)
++	O
=	O
TELOPT_NAWS	int
;	O
PUTSHORT	O
(	O
cp	*(char)
,	O
cols	*(long)
)	O
;	O
PUTSHORT	O
(	O
cp	*(char)
,	O
rows	*(long)
)	O
;	O
*	O
cp	*(char)
++	O
=	O
IAC	int
;	O
*	O
cp	*(char)
++	O
=	O
SE	int
;	O
if	O
(	O
NETROOM	O
(	O
)	O
>=	O
cp	*(char)
-	O
tmp	array(char)
)	O
{	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
&	O
netoring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
,	O
tmp	array(char)
,	O
cp	*(char)
-	O
tmp	array(char)
)	O
;	O
printsub	(char,*(char),int)->(void)
(	O
'>'	O
,	O
tmp	array(char)
+	O
2	int
,	O
cp	*(char)
-	O
tmp	array(char)
-	O
2	int
)	O
;	O
}	O
}	O
void	O
tel_enter_binary	(int)->(void)
(	O
int	O
rw	int
)	O
{	O
if	O
(	O
rw	int
&	O
1	int
)	O
send_do	(int,int)->(void)
(	O
TELOPT_BINARY	int
,	O
1	int
)	O
;	O
if	O
(	O
rw	int
&	O
2	int
)	O
send_will	(int,int)->(void)
(	O
TELOPT_BINARY	int
,	O
1	int
)	O
;	O
}	O
void	O
tel_leave_binary	(int)->(void)
(	O
int	O
rw	int
)	O
{	O
if	O
(	O
rw	int
&	O
1	int
)	O
send_dont	(int,int)->(void)
(	O
TELOPT_BINARY	int
,	O
1	int
)	O
;	O
if	O
(	O
rw	int
&	O
2	int
)	O
send_wont	(int,int)->(void)
(	O
TELOPT_BINARY	int
,	O
1	int
)	O
;	O
}	O
