uLong	long
filetime	(*(char),*(struct(int,int,int,int,int,int)),*(long))->(long)
(	O
f	*(char)
,	O
tmzip	*(struct(int,int,int,int,int,int))
,	O
dt	*(long)
)	O
char	O
*	O
f	*(char)
;	O
tm_zip	struct(int,int,int,int,int,int)
*	O
tmzip	*(struct(int,int,int,int,int,int))
;	O
uLong	long
*	O
dt	*(long)
;	O
{	O
int	O
ret	int
=	O
0	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
s	*(char)
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
filedate	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
;	O
time_t	long
tm_t	long
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
f	*(char)
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
{	O
char	O
name	array(char)
[	O
MAXFILENAME	O
]	O
;	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
f	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
name	array(char)
,	O
f	*(char)
)	O
;	O
if	O
(	O
name	array(char)
[	O
len	int
-	O
1	int
]	O
==	O
'/'	O
)	O
name	array(char)
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	array(char)
,	O
&	O
s	*(char)
)	O
==	O
0	int
)	O
{	O
tm_t	long
=	O
s	*(char)
.	O
st_mtime	O
;	O
ret	int
=	O
1	int
;	O
}	O
}	O
filedate	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
tm_t	long
)	O
;	O
tmzip	*(struct(int,int,int,int,int,int))
->	O
tm_sec	int
=	O
filedate	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_sec	int
;	O
tmzip	*(struct(int,int,int,int,int,int))
->	O
tm_min	int
=	O
filedate	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_min	int
;	O
tmzip	*(struct(int,int,int,int,int,int))
->	O
tm_hour	int
=	O
filedate	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_hour	int
;	O
tmzip	*(struct(int,int,int,int,int,int))
->	O
tm_mday	int
=	O
filedate	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mday	int
;	O
tmzip	*(struct(int,int,int,int,int,int))
->	O
tm_mon	int
=	O
filedate	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mon	int
;	O
tmzip	*(struct(int,int,int,int,int,int))
->	O
tm_year	int
=	O
filedate	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_year	int
;	O
return	O
ret	int
;	O
}	O
int	O
check_exist_file	(*(char))->(int)
(	O
filename	*(char)
)	O
const	O
char	O
*	O
filename	*(char)
;	O
{	O
FILE	struct
*	O
ftestexist	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
ret	int
=	O
1	int
;	O
ftestexist	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
ftestexist	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
ret	int
=	O
0	int
;	O
else	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ftestexist	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
do_banner	()->(void)
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
"MiniZip 0.15, demo of zLib + Zip package written by Gilles Vollant\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"more info at http://wwww.winimage/zLibDll/unzip.htm\n\n"	*(char)
)	O
;	O
}	O
void	O
do_help	()->(void)
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Usage : minizip [-o] file.zip [files_to_add]\n\n"	*(char)
)	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
argc	int
,	O
argv	array(*(char))
)	O
int	O
argc	int
;	O
char	O
*	O
argv	array(*(char))
[	O
]	O
;	O
{	O
int	O
i	int
;	O
int	O
opt_overwrite	int
=	O
0	int
;	O
int	O
opt_compress_level	int
=	O
Z_DEFAULT_COMPRESSION	O
;	O
int	O
zipfilenamearg	int
=	O
0	int
;	O
char	O
filename_try	array(char)
[	O
MAXFILENAME	O
]	O
;	O
int	O
zipok	int
;	O
int	O
err	int
=	O
0	int
;	O
int	O
size_buf	int
=	O
0	int
;	O
void	O
*	O
buf	*(void)
=	O
NULL	O
,	O
do_banner	()->(void)
(	O
)	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
do_help	()->(void)
(	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
*	O
argv	array(*(char))
[	O
i	int
]	O
)	O
==	O
'-'	O
)	O
{	O
const	O
char	O
*	O
p	*(char)
=	O
argv	array(*(char))
[	O
i	int
]	O
+	O
1	int
;	O
while	O
(	O
(	O
*	O
p	*(char)
)	O
!=	O
'\0'	O
)	O
{	O
char	O
c	int
=	O
*	O
(	O
p	*(char)
++	O
)	O
;	O
;	O
if	O
(	O
(	O
c	int
==	O
'o'	O
)	O
||	O
(	O
c	int
==	O
'O'	O
)	O
)	O
opt_overwrite	int
=	O
1	int
;	O
if	O
(	O
(	O
c	int
>=	O
'0'	O
)	O
&&	O
(	O
c	int
<=	O
'9'	O
)	O
)	O
opt_compress_level	int
=	O
c	int
-	O
'0'	O
;	O
}	O
}	O
else	O
if	O
(	O
zipfilenamearg	int
==	O
0	int
)	O
zipfilenamearg	int
=	O
i	int
;	O
}	O
}	O
size_buf	int
=	O
WRITEBUFFERSIZE	O
;	O
buf	*(void)
=	O
(	O
void	O
*	O
)	O
malloc	(long)->(*(void))
(	O
size_buf	int
)	O
;	O
if	O
(	O
buf	*(void)
==	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error allocating memory\n"	*(char)
)	O
;	O
return	O
ZIP_INTERNALERROR	O
;	O
}	O
if	O
(	O
zipfilenamearg	int
==	O
0	int
)	O
zipok	int
=	O
0	int
;	O
else	O
{	O
int	O
i	int
,	O
len	int
;	O
int	O
dot_found	int
=	O
0	int
;	O
zipok	int
=	O
1	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
filename_try	array(char)
,	O
argv	array(*(char))
[	O
zipfilenamearg	int
]	O
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
filename_try	array(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
if	O
(	O
filename_try	array(char)
[	O
i	int
]	O
==	O
'.'	O
)	O
dot_found	int
=	O
1	int
;	O
if	O
(	O
dot_found	int
==	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
filename_try	array(char)
,	O
".zip"	*(char)
)	O
;	O
if	O
(	O
opt_overwrite	int
==	O
0	int
)	O
if	O
(	O
check_exist_file	(*(char))->(int)
(	O
filename_try	array(char)
)	O
!=	O
0	int
)	O
{	O
char	O
rep	char
;	O
do	O
{	O
char	O
answer	array(char)
[	O
128	int
]	O
;	O
printf	(*(char))->(int)
(	O
"The file %s exist. Overwrite ? [y]es, [n]o : "	*(char)
,	O
filename_try	array(char)
)	O
;	O
scanf	(*(char))->(int)
(	O
"%1s"	*(char)
,	O
answer	array(char)
)	O
;	O
rep	char
=	O
answer	array(char)
[	O
0	int
]	O
;	O
if	O
(	O
(	O
rep	char
>=	O
'a'	O
)	O
&&	O
(	O
rep	char
<=	O
'z'	O
)	O
)	O
rep	char
-=	O
0x20	int
;	O
}	O
while	O
(	O
(	O
rep	char
!=	O
'Y'	O
)	O
&&	O
(	O
rep	char
!=	O
'N'	O
)	O
)	O
;	O
if	O
(	O
rep	char
==	O
'N'	O
)	O
zipok	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
zipok	int
==	O
1	int
)	O
{	O
zipFile	*(void)
zf	*(void)
;	O
int	O
errclose	int
;	O
zf	*(void)
=	O
zipOpen	(*(char),int)->(*(void))
(	O
filename_try	array(char)
,	O
0	int
)	O
;	O
if	O
(	O
zf	*(void)
==	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"error opening %s\n"	*(char)
,	O
filename_try	array(char)
)	O
;	O
err	int
=	O
ZIP_ERRNO	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"creating %s\n"	*(char)
,	O
filename_try	array(char)
)	O
;	O
for	O
(	O
i	int
=	O
zipfilenamearg	int
+	O
1	int
;	O
(	O
i	int
<	O
argc	int
)	O
&&	O
(	O
err	int
==	O
ZIP_OK	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
(	O
*	O
(	O
argv	array(*(char))
[	O
i	int
]	O
)	O
)	O
!=	O
'-'	O
)	O
&&	O
(	O
(	O
*	O
(	O
argv	array(*(char))
[	O
i	int
]	O
)	O
)	O
!=	O
'/'	O
)	O
)	O
{	O
FILE	struct
*	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
size_read	int
;	O
const	O
char	O
*	O
filenameinzip	*(char)
=	O
argv	array(*(char))
[	O
i	int
]	O
;	O
zip_fileinfo	struct(struct(int,int,int,int,int,int),long,long,long)
zi	struct(struct(int,int,int,int,int,int),long,long,long)
;	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
tmz_date	struct(int,int,int,int,int,int)
.	O
tm_sec	int
=	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
tmz_date	struct(int,int,int,int,int,int)
.	O
tm_min	int
=	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
tmz_date	struct(int,int,int,int,int,int)
.	O
tm_hour	int
=	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
tmz_date	struct(int,int,int,int,int,int)
.	O
tm_mday	int
=	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
tmz_date	struct(int,int,int,int,int,int)
.	O
tm_min	int
=	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
tmz_date	struct(int,int,int,int,int,int)
.	O
tm_year	int
=	O
0	int
;	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
dosDate	long
=	O
0	int
;	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
internal_fa	long
=	O
0	int
;	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
external_fa	long
=	O
0	int
;	O
filetime	(*(char),*(struct(int,int,int,int,int,int)),*(long))->(long)
(	O
filenameinzip	*(char)
,	O
&	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
tmz_date	struct(int,int,int,int,int,int)
,	O
&	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
.	O
dosDate	long
)	O
;	O
err	int
=	O
zipOpenNewFileInZip	(*(void),*(char),*(struct(struct(int,int,int,int,int,int),long,long,long)),*(void),int,*(void),int,*(char),int,int)->(int)
(	O
zf	*(void)
,	O
filenameinzip	*(char)
,	O
&	O
zi	struct(struct(int,int,int,int,int,int),long,long,long)
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
(	O
opt_compress_level	int
!=	O
0	int
)	O
?	O
Z_DEFLATED	int
:	O
0	int
,	O
opt_compress_level	int
)	O
;	O
if	O
(	O
err	int
!=	O
ZIP_OK	O
)	O
printf	(*(char))->(int)
(	O
"error in opening %s in zipfile\n"	*(char)
,	O
filenameinzip	*(char)
)	O
;	O
else	O
{	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filenameinzip	*(char)
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
err	int
=	O
ZIP_ERRNO	O
;	O
printf	(*(char))->(int)
(	O
"error in opening %s for reading\n"	*(char)
,	O
filenameinzip	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
err	int
==	O
ZIP_OK	O
)	O
do	O
{	O
err	int
=	O
ZIP_OK	O
;	O
size_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buf	*(void)
,	O
1	int
,	O
size_buf	int
,	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
size_read	int
<	O
size_buf	int
)	O
if	O
(	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"error in reading %s\n"	*(char)
,	O
filenameinzip	*(char)
)	O
;	O
err	int
=	O
ZIP_ERRNO	O
;	O
}	O
if	O
(	O
size_read	int
>	O
0	int
)	O
{	O
err	int
=	O
zipWriteInFileInZip	(*(void),*(void),int)->(int)
(	O
zf	*(void)
,	O
buf	*(void)
,	O
size_read	int
)	O
;	O
if	O
(	O
err	int
<	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"error in writing %s in the zipfile\n"	*(char)
,	O
filenameinzip	*(char)
)	O
;	O
}	O
}	O
}	O
while	O
(	O
(	O
err	int
==	O
ZIP_OK	O
)	O
&&	O
(	O
size_read	int
>	O
0	int
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
err	int
<	O
0	int
)	O
err	int
=	O
ZIP_ERRNO	O
;	O
else	O
{	O
err	int
=	O
zipCloseFileInZip	(*(void))->(int)
(	O
zf	*(void)
)	O
;	O
if	O
(	O
err	int
!=	O
ZIP_OK	O
)	O
printf	(*(char))->(int)
(	O
"error in closing %s in the zipfile\n"	*(char)
,	O
filenameinzip	*(char)
)	O
;	O
}	O
}	O
}	O
errclose	int
=	O
zipClose	(*(void),*(char))->(int)
(	O
zf	*(void)
,	O
NULL	O
)	O
;	O
if	O
(	O
errclose	int
!=	O
ZIP_OK	O
)	O
printf	(*(char))->(int)
(	O
"error in closing %s\n"	*(char)
,	O
filename_try	array(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
