struct	O
if_flag	struct(*(char),int,int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
mask	int
;	O
int	O
rev	int
;	O
}	O
if_flags	array(struct(*(char),int,int))
[	O
]	O
=	O
{	O
{	O
"UP"	*(char)
,	O
IFF_UP	int
}	O
,	O
{	O
"BROADCAST"	*(char)
,	O
IFF_BROADCAST	int
}	O
,	O
{	O
"DEBUG"	*(char)
,	O
IFF_DEBUG	int
}	O
,	O
{	O
"LOOPBACK"	*(char)
,	O
IFF_LOOPBACK	int
}	O
,	O
{	O
"POINTOPOINT"	*(char)
,	O
IFF_POINTOPOINT	int
}	O
,	O
{	O
"RUNNING"	*(char)
,	O
IFF_RUNNING	int
}	O
,	O
{	O
"NOARP"	*(char)
,	O
IFF_NOARP	int
}	O
,	O
{	O
"ARP"	*(char)
,	O
IFF_NOARP	int
,	O
1	int
}	O
,	O
{	O
"PROMISC"	*(char)
,	O
IFF_PROMISC	int
}	O
,	O
{	O
"ALLMULTI"	*(char)
,	O
IFF_ALLMULTI	int
}	O
,	O
{	O
"MULTICAST"	*(char)
,	O
IFF_MULTICAST	int
}	O
,	O
{	O
"NOTRAILERS"	*(char)
,	O
IFF_NOTRAILERS	int
}	O
,	O
{	O
"TRAILERS"	*(char)
,	O
IFF_NOTRAILERS	int
,	O
1	int
}	O
,	O
{	O
"MASTER"	*(char)
,	O
IFF_MASTER	int
}	O
,	O
{	O
"SLAVE"	*(char)
,	O
IFF_SLAVE	int
}	O
,	O
{	O
"PORTSEL"	*(char)
,	O
IFF_PORTSEL	int
}	O
,	O
{	O
"AUTOMEDIA"	*(char)
,	O
IFF_AUTOMEDIA	int
}	O
,	O
{	O
"DYNAMIC"	*(char)
,	O
IFF_DYNAMIC	int
}	O
,	O
{	O
"NOTRAILERS"	*(char)
,	O
IFF_NOTRAILERS	int
}	O
,	O
{	O
"TRAILERS"	*(char)
,	O
IFF_NOTRAILERS	int
,	O
1	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
cmpname	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(void)
,	O
const	O
void	O
*	O
b	*(void)
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
(	O
const	O
char	O
*	O
*	O
)	O
a	*(void)
,	O
*	O
(	O
const	O
char	O
*	O
*	O
)	O
b	*(void)
)	O
;	O
}	O
char	O
*	O
if_list_flags	(*(char))->(*(char))
(	O
const	O
char	O
*	O
prefix	*(char)
)	O
{	O
size_t	long
len	long
=	O
0	int
;	O
struct	O
if_flag	struct(*(char),int,int)
*	O
fp	*(struct(*(char),int,int))
;	O
char	O
*	O
*	O
fnames	*(*(char))
;	O
size_t	long
i	long
,	O
fcount	long
;	O
char	O
*	O
str	*(char)
,	O
*	O
p	*(void)
;	O
for	O
(	O
fp	*(struct(*(char),int,int))
=	O
if_flags	array(struct(*(char),int,int))
,	O
len	long
=	O
0	int
,	O
fcount	long
=	O
0	int
;	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
;	O
fp	*(struct(*(char),int,int))
++	O
)	O
if	O
(	O
!	O
fp	*(struct(*(char),int,int))
->	O
rev	int
)	O
{	O
fcount	long
++	O
;	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
)	O
+	O
1	int
;	O
}	O
fcount	long
=	O
sizeof	O
(	O
if_flags	array(struct(*(char),int,int))
)	O
/	O
sizeof	O
(	O
if_flags	array(struct(*(char),int,int))
[	O
0	int
]	O
)	O
-	O
1	int
;	O
fnames	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
fcount	long
*	O
sizeof	O
(	O
fnames	*(*(char))
[	O
0	int
]	O
)	O
+	O
len	long
)	O
;	O
p	*(void)
=	O
(	O
char	O
*	O
)	O
(	O
fnames	*(*(char))
+	O
fcount	long
)	O
;	O
for	O
(	O
fp	*(struct(*(char),int,int))
=	O
if_flags	array(struct(*(char),int,int))
,	O
i	long
=	O
0	int
;	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
;	O
fp	*(struct(*(char),int,int))
++	O
)	O
if	O
(	O
!	O
fp	*(struct(*(char),int,int))
->	O
rev	int
)	O
{	O
const	O
char	O
*	O
q	*(char)
;	O
fnames	*(*(char))
[	O
i	long
++	O
]	O
=	O
p	*(void)
;	O
q	*(char)
=	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
q	*(char)
,	O
"NO"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
q	*(char)
+=	O
2	int
;	O
for	O
(	O
;	O
*	O
q	*(char)
;	O
q	*(char)
++	O
)	O
*	O
p	*(void)
++	O
=	O
tolower	(int)->(int)
(	O
*	O
q	*(char)
)	O
;	O
*	O
p	*(void)
++	O
=	O
0	int
;	O
}	O
fcount	long
=	O
i	long
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
fnames	*(*(char))
,	O
fcount	long
,	O
sizeof	O
(	O
fnames	*(*(char))
[	O
0	int
]	O
)	O
,	O
cmpname	(*(void),*(void))->(int)
)	O
;	O
len	long
+=	O
2	int
*	O
fcount	long
;	O
if	O
(	O
prefix	*(char)
)	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
prefix	*(char)
)	O
;	O
str	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
p	*(void)
=	O
str	*(char)
;	O
if	O
(	O
prefix	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
prefix	*(char)
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
prefix	*(char)
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
fcount	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
i	long
&&	O
strcmp	(*(char),*(char))->(int)
(	O
fnames	*(*(char))
[	O
i	long
-	O
1	int
]	O
,	O
fnames	*(*(char))
[	O
i	long
]	O
)	O
==	O
0	int
)	O
continue	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
fnames	*(*(char))
[	O
i	long
]	O
)	O
;	O
p	*(void)
+=	O
strlen	(*(char))->(long)
(	O
fnames	*(*(char))
[	O
i	long
]	O
)	O
;	O
if	O
(	O
++	O
i	long
<	O
fcount	long
)	O
{	O
*	O
p	*(void)
++	O
=	O
','	O
;	O
*	O
p	*(void)
++	O
=	O
' '	O
;	O
}	O
else	O
break	O
;	O
}	O
*	O
p	*(void)
=	O
0	int
;	O
free	(*(void))->(void)
(	O
fnames	*(*(char))
)	O
;	O
return	O
str	*(char)
;	O
}	O
const	O
char	O
*	O
if_flagtoname	(int,*(char))->(*(char))
(	O
int	O
flag	int
,	O
const	O
char	O
*	O
avoid	*(char)
)	O
{	O
struct	O
if_flag	struct(*(char),int,int)
*	O
fp	*(struct(*(char),int,int))
;	O
const	O
char	O
*	O
first_match	*(char)
=	O
NULL	O
;	O
char	O
*	O
start	*(char)
;	O
for	O
(	O
fp	*(struct(*(char),int,int))
=	O
if_flags	array(struct(*(char),int,int))
;	O
;	O
fp	*(struct(*(char),int,int))
++	O
)	O
{	O
if	O
(	O
!	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
)	O
return	O
NULL	O
;	O
if	O
(	O
flag	int
==	O
fp	*(struct(*(char),int,int))
->	O
mask	int
&&	O
!	O
fp	*(struct(*(char),int,int))
->	O
rev	int
)	O
break	O
;	O
}	O
first_match	*(char)
=	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
;	O
if	O
(	O
avoid	*(char)
)	O
do	O
{	O
start	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
avoid	*(char)
,	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
start	*(char)
||	O
*	O
(	O
start	*(char)
-	O
1	int
)	O
!=	O
':'	O
||	O
*	O
(	O
start	*(char)
+	O
strlen	(*(char))->(long)
(	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
)	O
)	O
!=	O
':'	O
)	O
break	O
;	O
fp	*(struct(*(char),int,int))
++	O
;	O
}	O
while	O
(	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
)	O
return	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
;	O
else	O
return	O
first_match	*(char)
;	O
}	O
int	O
if_nametoflag	(*(char),long,*(int))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
len	long
,	O
int	O
*	O
prev	*(int)
)	O
{	O
struct	O
if_flag	struct(*(char),int,int)
*	O
fp	*(struct(*(char),int,int))
;	O
int	O
rev	int
=	O
0	int
;	O
if	O
(	O
len	long
>	O
1	int
&&	O
name	*(char)
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
name	*(char)
++	O
;	O
len	long
--	O
;	O
rev	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
len	long
>	O
2	int
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"NO"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
name	*(char)
+=	O
2	int
;	O
len	long
-=	O
2	int
;	O
rev	int
=	O
1	int
;	O
}	O
for	O
(	O
fp	*(struct(*(char),int,int))
=	O
if_flags	array(struct(*(char),int,int))
;	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
;	O
fp	*(struct(*(char),int,int))
++	O
)	O
{	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
fp	*(struct(*(char),int,int))
->	O
name	*(char)
,	O
name	*(char)
,	O
len	long
)	O
==	O
0	int
)	O
{	O
*	O
prev	*(int)
=	O
fp	*(struct(*(char),int,int))
->	O
rev	int
^	O
rev	int
;	O
return	O
fp	*(struct(*(char),int,int))
->	O
mask	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
if_nameztoflag	(*(char),*(int))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
*	O
prev	*(int)
)	O
{	O
return	O
if_nametoflag	(*(char),long,*(int))->(int)
(	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
,	O
prev	*(int)
)	O
;	O
}	O
struct	O
if_flag_char	struct(int,int)
{	O
int	O
mask	int
;	O
int	O
ch	int
;	O
}	O
;	O
static	O
struct	O
if_flag_char	struct(int,int)
flag_char_tab	array(struct(int,int))
[	O
]	O
=	O
{	O
{	O
IFF_ALLMULTI	int
,	O
'A'	O
}	O
,	O
{	O
IFF_BROADCAST	int
,	O
'B'	O
}	O
,	O
{	O
IFF_DEBUG	int
,	O
'D'	O
}	O
,	O
{	O
IFF_LOOPBACK	int
,	O
'L'	O
}	O
,	O
{	O
IFF_MULTICAST	int
,	O
'M'	O
}	O
,	O
{	O
IFF_PROMISC	int
,	O
'P'	O
}	O
,	O
{	O
IFF_NOTRAILERS	int
,	O
'N'	O
}	O
,	O
{	O
IFF_NOARP	int
,	O
'O'	O
}	O
,	O
{	O
IFF_POINTOPOINT	int
,	O
'P'	O
}	O
,	O
{	O
IFF_SLAVE	int
,	O
's'	O
}	O
,	O
{	O
IFF_MASTER	int
,	O
'm'	O
}	O
,	O
{	O
IFF_RUNNING	int
,	O
'R'	O
}	O
,	O
{	O
IFF_UP	int
,	O
'U'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
void	O
if_format_flags	(int,*(char),long)->(void)
(	O
int	O
flags	int
,	O
char	O
*	O
buf	*(char)
,	O
size_t	long
size	long
)	O
{	O
struct	O
if_flag_char	struct(int,int)
*	O
fp	*(struct(*(char),int,int))
;	O
size	long
--	O
;	O
for	O
(	O
fp	*(struct(*(char),int,int))
=	O
flag_char_tab	array(struct(int,int))
;	O
size	long
&&	O
fp	*(struct(*(char),int,int))
->	O
mask	int
;	O
fp	*(struct(*(char),int,int))
++	O
)	O
if	O
(	O
fp	*(struct(*(char),int,int))
->	O
mask	int
&	O
flags	int
)	O
{	O
*	O
buf	*(char)
++	O
=	O
fp	*(struct(*(char),int,int))
->	O
ch	int
;	O
size	long
--	O
;	O
}	O
*	O
buf	*(char)
=	O
0	int
;	O
}	O
int	O
print_if_flags	(int,*(char),char)->(int)
(	O
int	O
flags	int
,	O
const	O
char	O
*	O
avoid	*(char)
,	O
char	O
separator	char
)	O
{	O
int	O
f	int
=	O
1	int
;	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
first	int
=	O
1	int
;	O
int	O
length	int
=	O
0	int
;	O
while	O
(	O
flags	int
&&	O
f	int
)	O
{	O
if	O
(	O
f	int
&	O
flags	int
)	O
{	O
name	*(char)
=	O
if_flagtoname	(int,*(char))->(*(char))
(	O
f	int
,	O
avoid	*(char)
)	O
;	O
if	O
(	O
name	*(char)
)	O
{	O
if	O
(	O
!	O
first	int
)	O
{	O
putchar	(int)->(int)
(	O
separator	char
)	O
;	O
length	int
++	O
;	O
}	O
length	int
+=	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
name	*(char)
)	O
;	O
flags	int
&=	O
~	O
f	int
;	O
first	int
=	O
0	int
;	O
}	O
}	O
f	int
=	O
f	int
<<	O
1	int
;	O
}	O
if	O
(	O
flags	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
{	O
putchar	(int)->(int)
(	O
separator	char
)	O
;	O
length	int
++	O
;	O
}	O
length	int
+=	O
printf	(*(char))->(int)
(	O
"%#x"	*(char)
,	O
flags	int
)	O
;	O
}	O
return	O
length	int
;	O
}	O
