int	O
gdbm_copy_meta	(*(struct),*(struct))->(int)
(	O
GDBM_FILE	*(struct)
dst	*(struct)
,	O
GDBM_FILE	*(struct)
src	*(struct)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
src	*(struct)
->	O
desc	int
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
src	*(struct)
,	O
GDBM_FILE_STAT_ERROR	int
,	O
src	*(struct)
->	O
need_recovery	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fchown	(int,int,int)->(int)
(	O
dst	*(struct)
->	O
desc	int
,	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_uid	int
,	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_gid	int
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dst	*(struct)
,	O
GDBM_ERR_FILE_OWNER	int
,	O
dst	*(struct)
->	O
need_recovery	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fchmod	(int,int)->(int)
(	O
dst	*(struct)
->	O
desc	int
,	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
0777	int
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dst	*(struct)
,	O
GDBM_ERR_FILE_MODE	int
,	O
dst	*(struct)
->	O
need_recovery	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
backup_name	*(char)
(	O
char	O
const	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
buf	*(void)
;	O
size_t	long
len	long
;	O
size_t	long
suf_pos	long
;	O
size_t	long
suf_len	long
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
sizeof	O
(	O
INITIAL_SUFFIX	*(char)
)	O
;	O
buf	*(void)
=	O
malloc	(long)->(*(void))
(	O
len	long
)	O
;	O
if	O
(	O
!	O
buf	*(void)
)	O
return	O
NULL	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
name	*(char)
)	O
;	O
suf_pos	long
=	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
+	O
2	int
;	O
suf_len	long
=	O
1	int
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
INITIAL_SUFFIX	*(char)
)	O
;	O
while	O
(	O
access	(*(char),int)->(int)
(	O
buf	*(void)
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
size_t	long
i	long
=	O
suf_len	long
;	O
while	O
(	O
buf	*(void)
[	O
suf_pos	long
+	O
i	long
-	O
1	int
]	O
==	O
'9'	O
)	O
{	O
buf	*(void)
[	O
suf_pos	long
+	O
i	long
-	O
1	int
]	O
=	O
'0'	O
;	O
i	long
--	O
;	O
if	O
(	O
i	long
==	O
0	int
)	O
{	O
char	O
*	O
p	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
buf	*(void)
,	O
++	O
len	long
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
{	O
SAVE_ERRNO	O
(	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
memmove	(*(void),*(void),long)->(*(void))
(	O
p	*(char)
+	O
suf_pos	long
+	O
1	int
,	O
p	*(char)
+	O
suf_pos	long
,	O
suf_len	long
+	O
2	int
)	O
;	O
buf	*(void)
=	O
p	*(char)
;	O
suf_len	long
++	O
;	O
i	long
++	O
;	O
}	O
}	O
++	O
buf	*(void)
[	O
suf_pos	long
+	O
i	long
-	O
1	int
]	O
;	O
}	O
return	O
buf	*(void)
;	O
}	O
static	O
int	O
_gdbm_finish_transfer	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*((*`,*`)->(void)),*(void),long,long,long,long,long,long,long,long,*(char))),int)->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
GDBM_FILE	*(struct)
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
gdbm_recovery	struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char))
*	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
,	O
int	O
flags	int
)	O
{	O
int	O
i	long
;	O
if	O
(	O
_gdbm_end_update	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
{	O
gdbm_close	(*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
gdbm_sync	(*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
if	O
(	O
gdbm_copy_meta	(*(struct),*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
dbf	*(struct)
)	O
)	O
{	O
gdbm_close	(*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
_gdbm_mapped_unmap	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(void)
(	O
dbf	*(struct)
)	O
;	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_BACKUP	int
)	O
{	O
char	O
*	O
bkname	*(char)
=	O
backup_name	*(char)
(	O
dbf	*(struct)
->	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
bkname	*(char)
)	O
{	O
SAVE_ERRNO	O
(	O
gdbm_close	(*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
;	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_BACKUP_FAILED	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
rename	(*(char),*(char))->(int)
(	O
dbf	*(struct)
->	O
name	*(char)
,	O
bkname	*(char)
)	O
!=	O
0	int
)	O
{	O
SAVE_ERRNO	O
(	O
gdbm_close	(*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
free	(*(void))->(void)
(	O
bkname	*(char)
)	O
)	O
;	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_BACKUP_FAILED	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
backup_name	*(char)
=	O
bkname	*(char)
;	O
}	O
if	O
(	O
rename	(*(char),*(char))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
name	*(char)
,	O
dbf	*(struct)
->	O
name	*(char)
)	O
!=	O
0	int
)	O
{	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_REORGANIZE_FAILED	int
,	O
FALSE	int
)	O
;	O
gdbm_close	(*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
dbf	*(struct)
->	O
file_locking	int
)	O
_gdbm_unlock_file	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(void)
(	O
dbf	*(struct)
)	O
;	O
close	(int)->(int)
(	O
dbf	*(struct)
->	O
desc	int
)	O
;	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
)	O
;	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
dir	long
)	O
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dbf	*(struct)
->	O
cache_size	long
;	O
i	long
++	O
)	O
{	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
i	long
]	O
.	O
ca_bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
)	O
;	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
i	long
]	O
.	O
ca_data	struct(int,int,int,*(char),long,int)
.	O
dptr	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
)	O
;	O
}	O
dbf	*(struct)
->	O
desc	int
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
desc	int
;	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
;	O
dbf	*(struct)
->	O
dir	long
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
dir	long
;	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
;	O
dbf	*(struct)
->	O
bucket_dir	int
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket_dir	int
;	O
dbf	*(struct)
->	O
last_read	long
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
last_read	long
;	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
;	O
dbf	*(struct)
->	O
cache_size	long
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
cache_size	long
;	O
dbf	*(struct)
->	O
header_changed	int
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
header_changed	int
;	O
dbf	*(struct)
->	O
directory_changed	int
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
directory_changed	int
;	O
dbf	*(struct)
->	O
bucket_changed	int
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
bucket_changed	int
;	O
dbf	*(struct)
->	O
second_changed	int
=	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
second_changed	int
;	O
free	(*(void))->(void)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
->	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
if	O
(	O
dbf	*(struct)
->	O
memory_mapping	int
)	O
_gdbm_mapped_init	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(int)
(	O
dbf	*(struct)
)	O
;	O
gdbm_file_sync	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(int)
(	O
dbf	*(struct)
)	O
;	O
dbf	*(struct)
->	O
cache_entry	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
=	O
&	O
dbf	*(struct)
->	O
bucket_cache	*(struct(*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),long,char,struct(int,int,int,*(char),long,int)))
[	O
0	int
]	O
;	O
return	O
_gdbm_get_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
dbf	*(struct)
,	O
0	int
)	O
;	O
}	O
int	O
_gdbm_next_bucket_dir	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
int	O
bucket_dir	int
)	O
{	O
int	O
dir_count	int
=	O
GDBM_DIR_COUNT	O
(	O
dbf	*(struct)
)	O
;	O
if	O
(	O
bucket_dir	int
<	O
0	int
||	O
bucket_dir	int
>=	O
dir_count	int
)	O
bucket_dir	int
=	O
dir_count	int
;	O
else	O
{	O
off_t	long
cur	long
=	O
dbf	*(struct)
->	O
dir	long
[	O
bucket_dir	int
]	O
;	O
while	O
(	O
++	O
bucket_dir	int
<	O
dir_count	int
&&	O
cur	long
==	O
dbf	*(struct)
->	O
dir	long
[	O
bucket_dir	int
]	O
)	O
;	O
}	O
return	O
bucket_dir	int
;	O
}	O
static	O
int	O
check_db	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
)	O
{	O
int	O
bucket_dir	int
,	O
i	long
;	O
int	O
nbuckets	int
=	O
GDBM_DIR_COUNT	O
(	O
dbf	*(struct)
)	O
;	O
if	O
(	O
_gdbm_validate_header	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(int)
(	O
dbf	*(struct)
)	O
)	O
return	O
1	int
;	O
for	O
(	O
bucket_dir	int
=	O
0	int
;	O
bucket_dir	int
<	O
nbuckets	int
;	O
bucket_dir	int
=	O
_gdbm_next_bucket_dir	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
dbf	*(struct)
,	O
bucket_dir	int
)	O
)	O
{	O
if	O
(	O
_gdbm_get_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
dbf	*(struct)
,	O
bucket_dir	int
)	O
)	O
return	O
1	int
;	O
else	O
{	O
if	O
(	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
count	int
<	O
0	int
||	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
count	int
>	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
)	O
return	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
;	O
i	long
++	O
)	O
{	O
char	O
*	O
dptr	*(char)
;	O
datum	struct(*(char),int)
key	struct(*(char),int)
;	O
int	O
hashval	int
,	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
off	long
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
hash_value	int
==	O
-	O
1	int
)	O
continue	O
;	O
dptr	*(char)
=	O
_gdbm_read_entry	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(*(char))
(	O
dbf	*(struct)
,	O
i	long
)	O
;	O
if	O
(	O
!	O
dptr	*(char)
)	O
return	O
1	int
;	O
key	struct(*(char),int)
.	O
dptr	*(char)
=	O
dptr	*(char)
;	O
key	struct(*(char),int)
.	O
dsize	int
=	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
key_size	int
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
key_start	array(char)
,	O
key	struct(*(char),int)
.	O
dptr	*(char)
,	O
(	O
SMALL	int
<	O
key	struct(*(char),int)
.	O
dsize	int
?	O
SMALL	int
:	O
key	struct(*(char),int)
.	O
dsize	int
)	O
)	O
)	O
return	O
1	int
;	O
_gdbm_hash_key	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),struct(*(char),int),*(int),*(int),*(int))->(void)
(	O
dbf	*(struct)
,	O
key	struct(*(char),int)
,	O
&	O
hashval	int
,	O
&	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
,	O
&	O
off	long
)	O
;	O
if	O
(	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
>=	O
nbuckets	int
)	O
return	O
1	int
;	O
if	O
(	O
hashval	int
!=	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
hash_value	int
)	O
return	O
1	int
;	O
if	O
(	O
dbf	*(struct)
->	O
dir	long
[	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
]	O
!=	O
dbf	*(struct)
->	O
dir	long
[	O
bucket_dir	int
]	O
)	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
run_recovery	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*((*`,*`)->(void)),*(void),long,long,long,long,long,long,long,long,*(char))),int)->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
GDBM_FILE	*(struct)
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
gdbm_recovery	struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char))
*	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
,	O
int	O
flags	int
)	O
{	O
int	O
bucket_dir	int
,	O
i	long
;	O
int	O
nbuckets	int
=	O
GDBM_DIR_COUNT	O
(	O
dbf	*(struct)
)	O
;	O
for	O
(	O
bucket_dir	int
=	O
0	int
;	O
bucket_dir	int
<	O
nbuckets	int
;	O
bucket_dir	int
=	O
_gdbm_next_bucket_dir	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
dbf	*(struct)
,	O
bucket_dir	int
)	O
)	O
{	O
if	O
(	O
_gdbm_get_bucket	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(int)
(	O
dbf	*(struct)
,	O
bucket_dir	int
)	O
)	O
{	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_ERRFUN	int
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
errfun	*((*(void),*(char))->(void))
(	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
data	*(void)
,	O
_	O
(	O
"can't read bucket #%d: %s"	*(char)
)	O
,	O
bucket_dir	int
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
dbf	*(struct)
)	O
)	O
;	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_buckets	long
++	O
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_MAX_FAILED_BUCKETS	int
)	O
&&	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_buckets	long
==	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
max_failed_buckets	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_MAX_FAILURES	int
)	O
&&	O
(	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_buckets	long
+	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_keys	long
)	O
==	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
max_failures	long
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
recovered_buckets	long
++	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
bucket_elems	int
;	O
i	long
++	O
)	O
{	O
char	O
*	O
dptr	*(char)
;	O
datum	struct(*(char),int)
key	struct(*(char),int)
,	O
data	*(void)
;	O
if	O
(	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
hash_value	int
==	O
-	O
1	int
)	O
continue	O
;	O
dptr	*(char)
=	O
_gdbm_read_entry	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),int)->(*(char))
(	O
dbf	*(struct)
,	O
i	long
)	O
;	O
if	O
(	O
dptr	*(char)
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
recovered_keys	long
++	O
;	O
else	O
{	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_ERRFUN	int
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
errfun	*((*(void),*(char))->(void))
(	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
data	*(void)
,	O
_	O
(	O
"can't read key pair %d:%d (%lu:%d): %s"	*(char)
)	O
,	O
bucket_dir	int
,	O
i	long
,	O
(	O
unsigned	O
long	O
)	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
data_pointer	long
,	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
key_size	int
+	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
data_size	int
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
dbf	*(struct)
)	O
)	O
;	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_keys	long
++	O
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_MAX_FAILED_KEYS	int
)	O
&&	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_keys	long
==	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
max_failed_keys	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_MAX_FAILURES	int
)	O
&&	O
(	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_buckets	long
+	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_keys	long
)	O
==	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
max_failures	long
)	O
return	O
-	O
1	int
;	O
continue	O
;	O
}	O
key	struct(*(char),int)
.	O
dptr	*(char)
=	O
dptr	*(char)
;	O
key	struct(*(char),int)
.	O
dsize	int
=	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
key_size	int
;	O
data	*(void)
.	O
dptr	*(char)
=	O
dptr	*(char)
+	O
key	struct(*(char),int)
.	O
dsize	int
;	O
data	*(void)
.	O
dsize	int
=	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
data_size	int
;	O
if	O
(	O
gdbm_store	(*(struct),struct(*(char),int),struct(*(char),int),int)->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
key	struct(*(char),int)
,	O
data	*(void)
,	O
GDBM_INSERT	int
)	O
!=	O
0	int
)	O
{	O
switch	O
(	O
gdbm_last_errno	(*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
{	O
case	O
GDBM_CANNOT_REPLACE	int
:	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
duplicate_keys	long
++	O
;	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_ERRFUN	int
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
errfun	*((*(void),*(char))->(void))
(	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
data	*(void)
,	O
_	O
(	O
"ignoring duplicate key %d:%d (%lu:%d)"	*(char)
)	O
,	O
bucket_dir	int
,	O
i	long
,	O
(	O
unsigned	O
long	O
)	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
data_pointer	long
,	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
key_size	int
+	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
data_size	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_ERRFUN	int
)	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
errfun	*((*(void),*(char))->(void))
(	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
data	*(void)
,	O
_	O
(	O
"fatal: can't store element %d:%d (%lu:%d): %s"	*(char)
)	O
,	O
bucket_dir	int
,	O
i	long
,	O
(	O
unsigned	O
long	O
)	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
data_pointer	long
,	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
key_size	int
+	O
dbf	*(struct)
->	O
bucket	*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int))))
->	O
h_table	array(struct(int,array(char),long,int,int))
[	O
i	long
]	O
.	O
data_size	int
,	O
gdbm_db_strerror	(*(struct))->(*(char))
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
gdbm_recover	(*(struct),*(struct(*((*`,*`)->(void)),*(void),long,long,long,long,long,long,long,long,*(char))),int)->(int)
(	O
GDBM_FILE	*(struct)
dbf	*(struct)
,	O
gdbm_recovery	struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char))
*	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
,	O
int	O
flags	int
)	O
{	O
GDBM_FILE	*(struct)
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
;	O
char	O
*	O
new_name	*(char)
;	O
size_t	long
len	long
;	O
int	O
fd	int
;	O
int	O
rc	int
;	O
gdbm_recovery	struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char))
rs	struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char))
;	O
if	O
(	O
dbf	*(struct)
->	O
read_write	int
==	O
GDBM_READER	int
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	*(struct)
,	O
GDBM_READER_CANT_REORGANIZE	int
,	O
dbf	*(struct)
->	O
need_recovery	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
)	O
{	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
=	O
&	O
rs	struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char))
;	O
flags	int
=	O
0	int
;	O
}	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
recovered_keys	long
=	O
0	int
;	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
recovered_buckets	long
=	O
0	int
;	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_keys	long
=	O
0	int
;	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
failed_buckets	long
=	O
0	int
;	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
duplicate_keys	long
=	O
0	int
;	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
->	O
backup_name	*(char)
=	O
NULL	O
;	O
rc	int
=	O
0	int
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_FORCE	int
)	O
||	O
check_db	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)))->(int)
(	O
dbf	*(struct)
)	O
)	O
{	O
gdbm_clear_error	(*(struct))->(void)
(	O
dbf	*(struct)
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
dbf	*(struct)
->	O
name	*(char)
)	O
;	O
new_name	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	long
+	O
sizeof	O
(	O
TMPSUF	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
new_name	*(char)
)	O
{	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_MALLOC_ERROR	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
strcpy	(*(char),*(char))->(*(char))
(	O
new_name	*(char)
,	O
dbf	*(struct)
->	O
name	*(char)
)	O
,	O
TMPSUF	*(char)
)	O
;	O
fd	int
=	O
mkstemp	(*(char))->(int)
(	O
new_name	*(char)
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_FILE_OPEN_ERROR	int
,	O
FALSE	int
)	O
;	O
free	(*(void))->(void)
(	O
new_name	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
=	O
gdbm_fd_open	(int,*(char),int,int,*((*(char))->(void)))->(*(struct))
(	O
fd	int
,	O
new_name	*(char)
,	O
dbf	*(struct)
->	O
header	*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long)))))
->	O
block_size	int
,	O
GDBM_WRCREAT	int
|	O
(	O
dbf	*(struct)
->	O
cloexec	int
?	O
GDBM_CLOEXEC	int
:	O
0	int
)	O
|	O
GDBM_CLOERROR	int
,	O
dbf	*(struct)
->	O
fatal_err	*((*(char))->(void))
)	O
;	O
SAVE_ERRNO	O
(	O
free	(*(void))->(void)
(	O
new_name	*(char)
)	O
)	O
;	O
if	O
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
==	O
NULL	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_REORGANIZE_FAILED	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
run_recovery	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*((*`,*`)->(void)),*(void),long,long,long,long,long,long,long,long,*(char))),int)->(int)
(	O
dbf	*(struct)
,	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
rc	int
=	O
_gdbm_finish_transfer	(*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*`)->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct`)),*(long),*(struct(*`,long,char,struct`)),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*`,long,char,struct`)),int,int,int,int,long,*(void),long,long,long)),*(struct(*((*`,*`)->(void)),*(void),long,long,long,long,long,long,long,long,*(char))),int)->(int)
(	O
dbf	*(struct)
,	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
,	O
rcvr	*(struct(*((*(void),*(char))->(void)),*(void),long,long,long,long,long,long,long,long,*(char)))
,	O
flags	int
)	O
;	O
else	O
gdbm_close	(*(struct))->(int)
(	O
new_dbf	*(struct(*(char),int,int,int,int,int,int,int,int,int,int,*(char),enum(int,int,int,int),*((*(char))->(void)),int,*(struct(int,int,long,int,int,int,int,long,struct(int,int,long,array(struct(int,long))))),*(long),*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),long,long,*(struct(int,array(struct(int,long)),int,int,array(struct(int,array(char),long,int,int)))),int,*(struct(*(struct`),long,char,struct(int,int,int,*`,long,int))),int,int,int,int,long,*(void),long,long,long))
)	O
;	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
gdbm_clear_error	(*(struct))->(void)
(	O
dbf	*(struct)
)	O
;	O
dbf	*(struct)
->	O
need_recovery	int
=	O
FALSE	int
;	O
}	O
return	O
rc	int
;	O
}	O
