static	O
void	O
tt_init	(*(struct(int,*(struct(struct`,struct`)),int)),int)->(void)
(	O
Transposition_table	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
*	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
,	O
int	O
memsize	int
)	O
;	O
static	O
void	O
tt_clear	(*(struct(int,*(struct(struct`,struct`)),int)))->(void)
(	O
Transposition_table	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
*	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
)	O
;	O
Transposition_table	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
;	O
static	O
Hash_data	struct(array(long))
target1_hash	array(struct(array(long)))
[	O
BOARDMAX	O
]	O
;	O
static	O
Hash_data	struct(array(long))
target2_hash	array(struct(array(long)))
[	O
BOARDMAX	O
]	O
;	O
static	O
Hash_data	struct(array(long))
routine_hash	array(struct(array(long)))
[	O
NUM_CACHE_ROUTINES	int
]	O
;	O
static	O
void	O
keyhash_init	()->(void)
(	O
void	O
)	O
{	O
static	O
int	O
is_initialized	int
=	O
0	int
;	O
if	O
(	O
!	O
is_initialized	int
)	O
{	O
INIT_ZOBRIST_ARRAY	O
(	O
target1_hash	array(struct(array(long)))
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
target2_hash	array(struct(array(long)))
)	O
;	O
INIT_ZOBRIST_ARRAY	O
(	O
routine_hash	array(struct(array(long)))
)	O
;	O
is_initialized	int
=	O
1	int
;	O
}	O
}	O
static	O
void	O
calculate_hashval_for_tt	(*(struct(array(long))),int,int,int,*(struct(array(long))))->(void)
(	O
Hash_data	struct(array(long))
*	O
hashdata	*(struct(array(long)))
,	O
int	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
target1	int
,	O
int	O
target2	int
,	O
Hash_data	struct(array(long))
*	O
extra_hash	*(struct(array(long)))
)	O
{	O
*	O
hashdata	*(struct(array(long)))
=	O
board_hash	struct(array(long))
;	O
hashdata_xor	O
(	O
*	O
hashdata	*(struct(array(long)))
,	O
routine_hash	array(struct(array(long)))
[	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
)	O
;	O
hashdata_xor	O
(	O
*	O
hashdata	*(struct(array(long)))
,	O
target1_hash	array(struct(array(long)))
[	O
target1	int
]	O
)	O
;	O
if	O
(	O
target2	int
!=	O
NO_MOVE	O
)	O
hashdata_xor	O
(	O
*	O
hashdata	*(struct(array(long)))
,	O
target2_hash	array(struct(array(long)))
[	O
target2	int
]	O
)	O
;	O
if	O
(	O
extra_hash	*(struct(array(long)))
)	O
hashdata_xor	O
(	O
*	O
hashdata	*(struct(array(long)))
,	O
*	O
extra_hash	*(struct(array(long)))
)	O
;	O
}	O
static	O
void	O
tt_init	(*(struct(int,*(struct(struct`,struct`)),int)),int)->(void)
(	O
Transposition_table	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
*	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
,	O
int	O
memsize	int
)	O
{	O
int	O
num_entries	int
;	O
hash_init	()->(void)
(	O
)	O
;	O
keyhash_init	()->(void)
(	O
)	O
;	O
if	O
(	O
memsize	int
>	O
0	int
)	O
num_entries	int
=	O
memsize	int
/	O
sizeof	O
(	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
[	O
0	int
]	O
)	O
;	O
else	O
num_entries	int
=	O
DEFAULT_NUMBER_OF_CACHE_ENTRIES	int
;	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
num_entries	int
=	O
num_entries	int
;	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
=	O
malloc	(long)->(*(void))
(	O
num_entries	int
*	O
sizeof	O
(	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
==	O
NULL	O
)	O
{	O
perror	(*(char))->(void)
(	O
"Couldn't allocate memory for transposition table. \n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
is_clean	int
=	O
0	int
;	O
tt_clear	(*(struct(int,*(struct(struct`,struct`)),int)))->(void)
(	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
)	O
;	O
}	O
static	O
void	O
tt_clear	(*(struct(int,*(struct(struct`,struct`)),int)))->(void)
(	O
Transposition_table	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
*	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
)	O
{	O
if	O
(	O
!	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
is_clean	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
,	O
0	int
,	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
num_entries	int
*	O
sizeof	O
(	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
[	O
0	int
]	O
)	O
)	O
;	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
is_clean	int
=	O
1	int
;	O
}	O
}	O
void	O
tt_free	(*(struct(int,*(struct(struct`,struct`)),int)))->(void)
(	O
Transposition_table	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
*	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
)	O
{	O
free	(*(void))->(void)
(	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
)	O
;	O
}	O
int	O
tt_get	(*(struct(int,*(struct(struct`,struct`)),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(struct(array(long))),*(int),*(int),*(int))->(int)
(	O
Transposition_table	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
*	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
,	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
target1	int
,	O
int	O
target2	int
,	O
int	O
remaining_depth	int
,	O
Hash_data	struct(array(long))
*	O
extra_hash	*(struct(array(long)))
,	O
int	O
*	O
value1	*(int)
,	O
int	O
*	O
value2	*(int)
,	O
int	O
*	O
move	*(int)
)	O
{	O
Hash_data	struct(array(long))
hashval	array(long)
;	O
Hashentry	struct(struct(struct(array(long)),int),struct(struct(array(long)),int))
*	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
;	O
Hashnode	struct(struct(array(long)),int)
*	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
remaining_depth	int
<	O
0	int
||	O
remaining_depth	int
>	O
HN_MAX_REMAINING_DEPTH	int
)	O
return	O
0	int
;	O
calculate_hashval_for_tt	(*(struct(array(long))),int,int,int,*(struct(array(long))))->(void)
(	O
&	O
hashval	array(long)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
target1	int
,	O
target2	int
,	O
extra_hash	*(struct(array(long)))
)	O
;	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
=	O
&	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
[	O
hashdata_remainder	O
(	O
hashval	array(long)
,	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
num_entries	int
)	O
]	O
;	O
if	O
(	O
hashdata_is_equal	O
(	O
hashval	array(long)
,	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
->	O
deepest	struct(struct(array(long)),int)
.	O
key	struct(array(long))
)	O
)	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
&	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
->	O
deepest	struct(struct(array(long)),int)
;	O
else	O
if	O
(	O
hashdata_is_equal	O
(	O
hashval	array(long)
,	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
->	O
newest	struct(struct(array(long)),int)
.	O
key	struct(array(long))
)	O
)	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
&	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
->	O
newest	struct(struct(array(long)),int)
;	O
else	O
return	O
0	int
;	O
stats	struct(int,int,int,int)
.	O
read_result_hits	int
++	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
hn_get_move	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
data	*(void)
)	O
;	O
if	O
(	O
remaining_depth	int
<=	O
(	O
int	O
)	O
hn_get_remaining_depth	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
data	*(void)
)	O
)	O
{	O
if	O
(	O
value1	*(int)
)	O
*	O
value1	*(int)
=	O
hn_get_value1	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
data	*(void)
)	O
;	O
if	O
(	O
value2	*(int)
)	O
*	O
value2	*(int)
=	O
hn_get_value2	O
(	O
node	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
data	*(void)
)	O
;	O
stats	struct(int,int,int,int)
.	O
trusted_read_result_hits	int
++	O
;	O
return	O
2	int
;	O
}	O
return	O
1	int
;	O
}	O
void	O
tt_update	(*(struct(int,*(struct(struct`,struct`)),int)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(struct(array(long))),int,int,int)->(void)
(	O
Transposition_table	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
*	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
,	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
target1	int
,	O
int	O
target2	int
,	O
int	O
remaining_depth	int
,	O
Hash_data	struct(array(long))
*	O
extra_hash	*(struct(array(long)))
,	O
int	O
value1	*(int)
,	O
int	O
value2	*(int)
,	O
int	O
move	*(int)
)	O
{	O
Hash_data	struct(array(long))
hashval	array(long)
;	O
Hashentry	struct(struct(struct(array(long)),int),struct(struct(array(long)),int))
*	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
;	O
Hashnode	struct(struct(array(long)),int)
*	O
deepest	struct(struct(array(long)),int)
;	O
Hashnode	struct(struct(array(long)),int)
*	O
newest	struct(struct(array(long)),int)
;	O
unsigned	O
int	O
data	*(void)
;	O
static	O
const	O
int	O
routine_costs	array(int)
[	O
]	O
=	O
{	O
ROUTINE_COSTS	O
}	O
;	O
gg_assert	O
(	O
routine_costs	array(int)
[	O
NUM_CACHE_ROUTINES	int
]	O
==	O
-	O
1	int
)	O
;	O
if	O
(	O
remaining_depth	int
<	O
0	int
||	O
remaining_depth	int
>	O
HN_MAX_REMAINING_DEPTH	int
)	O
return	O
;	O
calculate_hashval_for_tt	(*(struct(array(long))),int,int,int,*(struct(array(long))))->(void)
(	O
&	O
hashval	array(long)
,	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
target1	int
,	O
target2	int
,	O
extra_hash	*(struct(array(long)))
)	O
;	O
data	*(void)
=	O
hn_create_data	O
(	O
remaining_depth	int
,	O
value1	*(int)
,	O
value2	*(int)
,	O
move	*(int)
,	O
routine_costs	array(int)
[	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
)	O
;	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
=	O
&	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
entries	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
[	O
hashdata_remainder	O
(	O
hashval	array(long)
,	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
num_entries	int
)	O
]	O
;	O
deepest	struct(struct(array(long)),int)
=	O
&	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
->	O
deepest	struct(struct(array(long)),int)
;	O
newest	struct(struct(array(long)),int)
=	O
&	O
entry	*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int)))
->	O
newest	struct(struct(array(long)),int)
;	O
if	O
(	O
hashdata_is_equal	O
(	O
hashval	array(long)
,	O
deepest	struct(struct(array(long)),int)
->	O
key	struct(array(long))
)	O
&&	O
remaining_depth	int
>=	O
(	O
int	O
)	O
hn_get_remaining_depth	O
(	O
deepest	struct(struct(array(long)),int)
->	O
data	*(void)
)	O
)	O
{	O
deepest	struct(struct(array(long)),int)
->	O
data	*(void)
=	O
data	*(void)
;	O
}	O
else	O
if	O
(	O
hashdata_is_equal	O
(	O
hashval	array(long)
,	O
newest	struct(struct(array(long)),int)
->	O
key	struct(array(long))
)	O
&&	O
remaining_depth	int
>=	O
(	O
int	O
)	O
hn_get_remaining_depth	O
(	O
newest	struct(struct(array(long)),int)
->	O
data	*(void)
)	O
)	O
{	O
newest	struct(struct(array(long)),int)
->	O
data	*(void)
=	O
data	*(void)
;	O
if	O
(	O
hn_get_remaining_depth	O
(	O
newest	struct(struct(array(long)),int)
->	O
data	*(void)
)	O
>	O
hn_get_remaining_depth	O
(	O
deepest	struct(struct(array(long)),int)
->	O
data	*(void)
)	O
)	O
{	O
Hashnode	struct(struct(array(long)),int)
temp	struct(struct(array(long)),int)
;	O
temp	struct(struct(array(long)),int)
=	O
*	O
deepest	struct(struct(array(long)),int)
;	O
*	O
deepest	struct(struct(array(long)),int)
=	O
*	O
newest	struct(struct(array(long)),int)
;	O
*	O
newest	struct(struct(array(long)),int)
=	O
temp	struct(struct(array(long)),int)
;	O
}	O
}	O
else	O
if	O
(	O
hn_get_total_cost	O
(	O
data	*(void)
)	O
>	O
hn_get_total_cost	O
(	O
deepest	struct(struct(array(long)),int)
->	O
data	*(void)
)	O
)	O
{	O
if	O
(	O
hn_get_total_cost	O
(	O
newest	struct(struct(array(long)),int)
->	O
data	*(void)
)	O
<	O
hn_get_total_cost	O
(	O
deepest	struct(struct(array(long)),int)
->	O
data	*(void)
)	O
)	O
*	O
newest	struct(struct(array(long)),int)
=	O
*	O
deepest	struct(struct(array(long)),int)
;	O
deepest	struct(struct(array(long)),int)
->	O
key	struct(array(long))
=	O
hashval	array(long)
;	O
deepest	struct(struct(array(long)),int)
->	O
data	*(void)
=	O
data	*(void)
;	O
}	O
else	O
{	O
newest	struct(struct(array(long)),int)
->	O
key	struct(array(long))
=	O
hashval	array(long)
;	O
newest	struct(struct(array(long)),int)
->	O
data	*(void)
=	O
data	*(void)
;	O
}	O
stats	struct(int,int,int,int)
.	O
read_result_entered	int
++	O
;	O
table	*(struct(int,*(struct(struct(struct`,int),struct(struct`,int))),int))
->	O
is_clean	int
=	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
routine_names	array(*(char))
[	O
]	O
=	O
{	O
ROUTINE_NAMES	O
}	O
;	O
const	O
char	O
*	O
routine_id_to_string	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
enum	O
routine_id	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
return	O
routine_names	array(*(char))
[	O
(	O
int	O
)	O
routine	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
;	O
}	O
void	O
reading_cache_init	(int)->(void)
(	O
int	O
bytes	int
)	O
{	O
tt_init	(*(struct(int,*(struct(struct`,struct`)),int)),int)->(void)
(	O
&	O
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
,	O
bytes	int
)	O
;	O
}	O
void	O
reading_cache_clear	()->(void)
(	O
)	O
{	O
tt_clear	(*(struct(int,*(struct(struct`,struct`)),int)))->(void)
(	O
&	O
ttable	struct(int,*(struct(struct(struct(array(long)),int),struct(struct(array(long)),int))),int)
)	O
;	O
}	O
float	O
reading_cache_default_size	()->(float)
(	O
)	O
{	O
return	O
DEFAULT_NUMBER_OF_CACHE_ENTRIES	int
*	O
sizeof	O
(	O
Hashentry	struct(struct(struct(array(long)),int),struct(struct(array(long)),int))
)	O
/	O
1024.0	int
/	O
1024.0	int
;	O
}	O
void	O
sgf_trace	(*(char),int,int,int,*(char))->(void)
(	O
const	O
char	O
*	O
func	*(char)
,	O
int	O
str	int
,	O
int	O
move	*(int)
,	O
int	O
result	int
,	O
const	O
char	O
*	O
message	*(char)
)	O
{	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%s %c%d: "	*(char)
,	O
func	*(char)
,	O
J	O
(	O
str	int
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
str	int
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
str	int
)	O
)	O
;	O
if	O
(	O
result	int
==	O
0	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"0"	*(char)
)	O
;	O
else	O
if	O
(	O
ON_BOARD	O
(	O
move	*(int)
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s %c%d"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
result	int
)	O
,	O
J	O
(	O
move	*(int)
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
move	*(int)
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
move	*(int)
)	O
)	O
;	O
else	O
if	O
(	O
is_pass	(int)->(int)
(	O
move	*(int)
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s PASS"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
result	int
)	O
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s [%d]"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
result	int
)	O
,	O
move	*(int)
)	O
;	O
if	O
(	O
message	*(char)
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
" (%s)"	*(char)
,	O
message	*(char)
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
void	O
sgf_trace2	(*(char),int,int,int,*(char),*(char))->(void)
(	O
const	O
char	O
*	O
func	*(char)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
move	*(int)
,	O
const	O
char	O
*	O
result	int
,	O
const	O
char	O
*	O
message	*(char)
)	O
{	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%s %c%d %c%d: "	*(char)
,	O
func	*(char)
,	O
J	O
(	O
str1	int
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
str1	int
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
str1	int
)	O
,	O
J	O
(	O
str2	int
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
str2	int
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
str2	int
)	O
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
move	*(int)
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s %c%d"	*(char)
,	O
result	int
,	O
J	O
(	O
move	*(int)
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
move	*(int)
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
move	*(int)
)	O
)	O
;	O
else	O
if	O
(	O
is_pass	(int)->(int)
(	O
move	*(int)
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s PASS"	*(char)
,	O
result	int
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s [%d]"	*(char)
,	O
result	int
,	O
move	*(int)
)	O
;	O
if	O
(	O
message	*(char)
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
" (%s)"	*(char)
,	O
message	*(char)
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
void	O
sgf_trace_semeai	(*(char),int,int,int,int,int,*(char))->(void)
(	O
const	O
char	O
*	O
func	*(char)
,	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
move	*(int)
,	O
int	O
result1	int
,	O
int	O
result2	int
,	O
const	O
char	O
*	O
message	*(char)
)	O
{	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%s %c%d %c%d: "	*(char)
,	O
func	*(char)
,	O
J	O
(	O
str1	int
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
str1	int
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
str1	int
)	O
,	O
J	O
(	O
str2	int
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
str2	int
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
str2	int
)	O
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
move	*(int)
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s %s %c%d"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
result1	int
)	O
,	O
result_to_string	(int)->(*(char))
(	O
result2	int
)	O
,	O
J	O
(	O
move	*(int)
)	O
+	O
'A'	O
+	O
(	O
J	O
(	O
move	*(int)
)	O
>=	O
8	int
)	O
,	O
board_size	int
-	O
I	O
(	O
move	*(int)
)	O
)	O
;	O
else	O
if	O
(	O
is_pass	(int)->(int)
(	O
move	*(int)
)	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s %s PASS"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
result1	int
)	O
,	O
result_to_string	(int)->(*(char))
(	O
result2	int
)	O
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
"%s %s [%d]"	*(char)
,	O
result_to_string	(int)->(*(char))
(	O
result1	int
)	O
,	O
result_to_string	(int)->(*(char))
(	O
result2	int
)	O
,	O
move	*(int)
)	O
;	O
if	O
(	O
message	*(char)
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
+	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
,	O
" (%s)"	*(char)
,	O
message	*(char)
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
