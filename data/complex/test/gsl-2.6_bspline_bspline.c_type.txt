gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
gsl_bspline_alloc	(long,long)->(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))
(	O
const	O
size_t	long
k	long
,	O
const	O
size_t	long
nbreak	long
)	O
{	O
if	O
(	O
k	long
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"k must be at least 1"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
else	O
if	O
(	O
nbreak	long
<	O
2	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"nbreak must be at least 2"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
else	O
{	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
)	O
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workspace"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
=	O
k	long
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
km1	long
=	O
k	long
-	O
1	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
nbreak	long
=	O
nbreak	long
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
=	O
nbreak	long
-	O
1	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
+	O
k	long
-	O
1	int
;	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
+	O
k	long
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
)	O
{	O
gsl_bspline_free	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for knots vector"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
k	long
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
)	O
{	O
gsl_bspline_free	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for deltal vector"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
k	long
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
)	O
{	O
gsl_bspline_free	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for deltar vector"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
B	*(float)
=	O
gsl_vector_alloc	(long)->(*(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
k	long
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
B	*(float)
==	O
0	int
)	O
{	O
gsl_bspline_free	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for temporary spline vector"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
A	*(float)
=	O
gsl_matrix_alloc	(long,long)->(*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
k	long
,	O
k	long
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
A	*(float)
==	O
0	int
)	O
{	O
gsl_bspline_free	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for derivative work matrix"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_alloc	(long,long)->(*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
k	long
,	O
k	long
+	O
1	int
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
==	O
0	int
)	O
{	O
gsl_bspline_free	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for temporary derivative matrix"	*(char)
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
;	O
}	O
}	O
void	O
gsl_bspline_free	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(void)
(	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
RETURN_IF_NULL	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
B	*(float)
)	O
gsl_vector_free	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
B	*(float)
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
A	*(float)
)	O
gsl_matrix_free	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
A	*(float)
)	O
;	O
if	O
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
gsl_matrix_free	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
free	(*(void))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
size_t	long
gsl_bspline_ncoeffs	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
return	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
;	O
}	O
size_t	long
gsl_bspline_order	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
return	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
;	O
}	O
size_t	long
gsl_bspline_nbreak	(*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
return	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
nbreak	long
;	O
}	O
double	O
gsl_bspline_breakpoint	(long,*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(double)
(	O
size_t	long
i	long
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
j	long
=	O
i	long
+	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
-	O
1	int
;	O
return	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
)	O
;	O
}	O
int	O
gsl_bspline_knots	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
breakpts	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
if	O
(	O
breakpts	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
nbreak	long
)	O
{	O
GSL_ERROR	O
(	O
"breakpts vector has wrong size"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
;	O
i	long
++	O
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
breakpts	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
)	O
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
;	O
i	long
++	O
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
-	O
1	int
+	O
i	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
breakpts	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
)	O
;	O
}	O
for	O
(	O
i	long
=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
+	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
;	O
i	long
++	O
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
breakpts	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
)	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_bspline_knots_uniform	(double,double,*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
i	long
;	O
double	O
delta	double
;	O
double	O
x	double
;	O
delta	double
=	O
(	O
b	double
-	O
a	double
)	O
/	O
(	O
double	O
)	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
;	O
i	long
++	O
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
a	double
)	O
;	O
x	double
=	O
a	double
+	O
delta	double
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
-	O
1	int
;	O
i	long
++	O
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
+	O
i	long
,	O
x	double
)	O
;	O
x	double
+=	O
delta	double
;	O
}	O
for	O
(	O
i	long
=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
+	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
;	O
i	long
++	O
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
b	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_bspline_eval	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
B	*(float)
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
if	O
(	O
B	*(float)
->	O
size	long
!=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
)	O
{	O
GSL_ERROR	O
(	O
"vector B not of length n"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
size_t	long
istart	*(long)
;	O
size_t	long
iend	*(long)
;	O
int	O
error	int
;	O
error	int
=	O
gsl_bspline_eval_nonzero	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(long),*(long),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
x	double
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
B	*(float)
,	O
&	O
istart	*(long)
,	O
&	O
iend	*(long)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
istart	*(long)
;	O
i	long
++	O
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
B	*(float)
,	O
i	long
,	O
0.0	int
)	O
;	O
for	O
(	O
i	long
=	O
istart	*(long)
;	O
i	long
<=	O
iend	*(long)
;	O
i	long
++	O
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
B	*(float)
,	O
i	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
B	*(float)
,	O
i	long
-	O
istart	*(long)
)	O
)	O
;	O
for	O
(	O
i	long
=	O
iend	*(long)
+	O
1	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
;	O
i	long
++	O
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
B	*(float)
,	O
i	long
,	O
0.0	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_bspline_eval_nonzero	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(long),*(long),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
const	O
double	O
x	double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
Bk	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
size_t	long
*	O
istart	*(long)
,	O
size_t	long
*	O
iend	*(long)
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
if	O
(	O
Bk	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
)	O
{	O
GSL_ERROR	O
(	O
"Bk vector length does not match order k"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
size_t	long
j	long
;	O
int	O
flag	*(int)
=	O
0	int
;	O
int	O
error	int
=	O
0	int
;	O
i	long
=	O
bspline_find_interval	(double,*(int),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
x	double
,	O
&	O
flag	*(int)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
error	int
=	O
bspline_process_interval_for_eval	(double,*(long),int,*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
x	double
,	O
&	O
i	long
,	O
flag	*(int)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
*	O
istart	*(long)
=	O
i	long
-	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
+	O
1	int
;	O
*	O
iend	*(long)
=	O
i	long
;	O
bspline_pppack_bsplvb	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,double,long,*(long),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
,	O
1	int
,	O
x	double
,	O
*	O
iend	*(long)
,	O
&	O
j	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
Bk	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_bspline_deriv_eval	(double,long,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
size_t	long
nderiv	long
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
if	O
(	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
!=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
)	O
{	O
GSL_ERROR	O
(	O
"dB matrix first dimension not of length n"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size2	long
<	O
nderiv	long
+	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"dB matrix second dimension must be at least length nderiv+1"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
size_t	long
j	long
;	O
size_t	long
istart	*(long)
;	O
size_t	long
iend	*(long)
;	O
int	O
error	int
;	O
error	int
=	O
gsl_bspline_deriv_eval_nonzero	(double,long,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(long),*(long),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
x	double
,	O
nderiv	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
&	O
istart	*(long)
,	O
&	O
iend	*(long)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<=	O
nderiv	long
;	O
j	long
++	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
istart	*(long)
;	O
i	long
++	O
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
j	long
,	O
0.0	int
)	O
;	O
for	O
(	O
i	long
=	O
istart	*(long)
;	O
i	long
<=	O
iend	*(long)
;	O
i	long
++	O
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
j	long
,	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
-	O
istart	*(long)
,	O
j	long
)	O
)	O
;	O
for	O
(	O
i	long
=	O
iend	*(long)
+	O
1	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
n	int
;	O
i	long
++	O
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
j	long
,	O
0.0	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_bspline_deriv_eval_nonzero	(double,long,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(long),*(long),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
const	O
double	O
x	double
,	O
const	O
size_t	long
nderiv	long
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
size_t	long
*	O
istart	*(long)
,	O
size_t	long
*	O
iend	*(long)
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
if	O
(	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size1	long
!=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
)	O
{	O
GSL_ERROR	O
(	O
"dB matrix first dimension not of length k"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
->	O
size2	long
<	O
nderiv	long
+	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"dB matrix second dimension must be at least length nderiv+1"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
size_t	long
j	long
;	O
int	O
flag	*(int)
=	O
0	int
;	O
int	O
error	int
=	O
0	int
;	O
size_t	long
min_nderivk	long
;	O
i	long
=	O
bspline_find_interval	(double,*(int),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
x	double
,	O
&	O
flag	*(int)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
error	int
=	O
bspline_process_interval_for_eval	(double,*(long),int,*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
x	double
,	O
&	O
i	long
,	O
flag	*(int)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
*	O
istart	*(long)
=	O
i	long
-	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
+	O
1	int
;	O
*	O
iend	*(long)
=	O
i	long
;	O
bspline_pppack_bsplvd	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
,	O
x	double
,	O
*	O
iend	*(long)
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
A	*(float)
,	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
nderiv	long
)	O
;	O
min_nderivk	long
=	O
GSL_MIN_INT	(int,int)->(int)
(	O
nderiv	long
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
-	O
1	int
)	O
;	O
for	O
(	O
j	long
=	O
min_nderivk	long
+	O
1	int
;	O
j	long
<=	O
nderiv	long
;	O
j	long
++	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
;	O
i	long
++	O
)	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
dB	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
j	long
,	O
0.0	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
inline	O
size_t	long
bspline_find_interval	(double,*(int),*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(long)
(	O
const	O
double	O
x	double
,	O
int	O
*	O
flag	*(int)
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
x	double
<	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
)	O
)	O
{	O
*	O
flag	*(int)
=	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	long
=	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
-	O
1	int
;	O
i	long
<	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
+	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
-	O
1	int
;	O
i	long
++	O
)	O
{	O
const	O
double	O
ti	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
const	O
double	O
tip1	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
+	O
1	int
)	O
;	O
if	O
(	O
tip1	double
<	O
ti	double
)	O
{	O
GSL_ERROR	O
(	O
"knots vector is not increasing"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
ti	double
<=	O
x	double
&&	O
x	double
<	O
tip1	double
)	O
break	O
;	O
if	O
(	O
ti	double
<	O
x	double
&&	O
x	double
==	O
tip1	double
&&	O
tip1	double
==	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
+	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
-	O
1	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	long
==	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
k	long
+	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
l	long
-	O
1	int
)	O
*	O
flag	*(int)
=	O
1	int
;	O
else	O
*	O
flag	*(int)
=	O
0	int
;	O
return	O
i	long
;	O
}	O
static	O
inline	O
int	O
bspline_process_interval_for_eval	(double,*(long),int,*(struct(long,long,long,long,long,*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)))))->(int)
(	O
const	O
double	O
x	double
,	O
size_t	long
*	O
i	long
,	O
const	O
int	O
flag	*(int)
,	O
gsl_bspline_workspace	struct(long,long,long,long,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)))
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
if	O
(	O
flag	*(int)
==	O
-	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"x outside of knot interval"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
else	O
if	O
(	O
flag	*(int)
==	O
1	int
)	O
{	O
if	O
(	O
x	double
<=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
*	O
i	long
)	O
+	O
GSL_DBL_EPSILON	int
)	O
{	O
*	O
i	long
-=	O
1	int
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"x outside of knot interval"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
*	O
i	long
)	O
==	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
->	O
knots	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
*	O
i	long
+	O
1	int
)	O
)	O
{	O
GSL_ERROR	O
(	O
"knot(i) = knot(i+1) will result in division by zero"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
void	O
bspline_pppack_bsplvb	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,double,long,*(long),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
t	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
size_t	long
jhigh	long
,	O
const	O
size_t	long
index	long
,	O
const	O
double	O
x	double
,	O
const	O
size_t	long
left	long
,	O
size_t	long
*	O
j	long
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
biatx	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
size_t	long
i	long
;	O
double	O
saved	double
;	O
double	O
term	double
;	O
if	O
(	O
index	long
==	O
1	int
)	O
{	O
*	O
j	long
=	O
0	int
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
biatx	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
1.0	int
)	O
;	O
}	O
for	O
(	O
;	O
*	O
j	long
<	O
jhigh	long
-	O
1	int
;	O
*	O
j	long
+=	O
1	int
)	O
{	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
*	O
j	long
,	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
t	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
left	long
+	O
*	O
j	long
+	O
1	int
)	O
-	O
x	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
*	O
j	long
,	O
x	double
-	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
t	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
left	long
-	O
*	O
j	long
)	O
)	O
;	O
saved	double
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
*	O
j	long
;	O
i	long
++	O
)	O
{	O
term	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
biatx	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
/	O
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
+	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
*	O
j	long
-	O
i	long
)	O
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
biatx	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
saved	double
+	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
*	O
term	double
)	O
;	O
saved	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
*	O
j	long
-	O
i	long
)	O
*	O
term	double
;	O
}	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
biatx	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
*	O
j	long
+	O
1	int
,	O
saved	double
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
bspline_pppack_bsplvd	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double,long,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(void)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
t	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
size_t	long
k	long
,	O
const	O
double	O
x	double
,	O
const	O
size_t	long
left	long
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
a	double
,	O
gsl_matrix	struct(long,long,long,*(double),*(struct(long,*(double))),int)
*	O
dbiatx	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
size_t	long
nderiv	long
)	O
{	O
int	O
i	long
,	O
ideriv	int
,	O
il	int
,	O
j	long
,	O
jlow	int
,	O
jp1mid	int
,	O
kmm	int
,	O
ldummy	int
,	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
,	O
mhigh	int
;	O
double	O
factor	double
,	O
fkmm	double
,	O
sum	double
;	O
size_t	long
bsplvb_j	long
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
dbcol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_column	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
dbiatx	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
)	O
;	O
mhigh	int
=	O
GSL_MIN_INT	(int,int)->(int)
(	O
nderiv	long
,	O
k	long
-	O
1	int
)	O
;	O
bspline_pppack_bsplvb	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,double,long,*(long),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
t	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
k	long
-	O
mhigh	int
,	O
1	int
,	O
x	double
,	O
left	long
,	O
&	O
bsplvb_j	long
,	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
&	O
dbcol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
if	O
(	O
mhigh	int
>	O
0	int
)	O
{	O
ideriv	int
=	O
mhigh	int
;	O
for	O
(	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
1	int
;	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
<=	O
mhigh	int
;	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
++	O
)	O
{	O
for	O
(	O
j	long
=	O
ideriv	int
,	O
jp1mid	int
=	O
0	int
;	O
j	long
<	O
(	O
int	O
)	O
k	long
;	O
j	long
++	O
,	O
jp1mid	int
++	O
)	O
{	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
dbiatx	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
ideriv	int
,	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
dbiatx	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
jp1mid	int
,	O
0	int
)	O
)	O
;	O
}	O
ideriv	int
--	O
;	O
bspline_pppack_bsplvb	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long,double,long,*(long),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(void)
(	O
t	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
k	long
-	O
ideriv	int
,	O
2	int
,	O
x	double
,	O
left	long
,	O
&	O
bsplvb_j	long
,	O
deltal	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
deltar	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
&	O
dbcol	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
)	O
;	O
}	O
jlow	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
(	O
int	O
)	O
k	long
;	O
i	long
++	O
)	O
{	O
for	O
(	O
j	long
=	O
jlow	int
;	O
j	long
<	O
(	O
int	O
)	O
k	long
;	O
j	long
++	O
)	O
{	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
a	double
,	O
j	long
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
jlow	int
=	O
i	long
;	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
a	double
,	O
i	long
,	O
i	long
,	O
1.0	int
)	O
;	O
}	O
for	O
(	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
1	int
;	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
<=	O
mhigh	int
;	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
++	O
)	O
{	O
kmm	int
=	O
k	long
-	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
;	O
fkmm	double
=	O
(	O
float	O
)	O
kmm	int
;	O
il	int
=	O
left	long
;	O
i	long
=	O
k	long
-	O
1	int
;	O
for	O
(	O
ldummy	int
=	O
0	int
;	O
ldummy	int
<	O
kmm	int
;	O
ldummy	int
++	O
)	O
{	O
factor	double
=	O
fkmm	double
/	O
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
t	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
il	int
+	O
kmm	int
)	O
-	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
t	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
il	int
)	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<=	O
i	long
;	O
j	long
++	O
)	O
{	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
a	double
,	O
i	long
,	O
j	long
,	O
factor	double
*	O
(	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
a	double
,	O
i	long
,	O
j	long
)	O
-	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
a	double
,	O
i	long
-	O
1	int
,	O
j	long
)	O
)	O
)	O
;	O
}	O
il	int
--	O
;	O
i	long
--	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
(	O
int	O
)	O
k	long
;	O
i	long
++	O
)	O
{	O
sum	double
=	O
0	int
;	O
jlow	int
=	O
GSL_MAX_INT	(int,int)->(int)
(	O
i	long
,	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
for	O
(	O
j	long
=	O
jlow	int
;	O
j	long
<	O
(	O
int	O
)	O
k	long
;	O
j	long
++	O
)	O
{	O
sum	double
+=	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
a	double
,	O
j	long
,	O
i	long
)	O
*	O
gsl_matrix_get	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long)->(double)
(	O
dbiatx	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
j	long
,	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
)	O
;	O
}	O
gsl_matrix_set	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,double)->(void)
(	O
dbiatx	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
,	O
sum	double
)	O
;	O
}	O
}	O
}	O
return	O
;	O
}	O
