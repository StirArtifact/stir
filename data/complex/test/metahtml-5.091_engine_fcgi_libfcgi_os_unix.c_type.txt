static	O
const	O
char	O
rcsid	array(char)
[	O
]	O
=	O
"$Id: os_unix.c,v 1.1.1.1 1998/11/07 21:16:23 bfox Exp $"	*(char)
;	O
typedef	O
void	O
*	O
ClientData	*(void)
;	O
typedef	O
struct	O
{	O
OS_AsyncProc	O
procPtr	int
;	O
ClientData	*(void)
clientData	*(void)
;	O
int	O
fd	int
;	O
int	O
len	int
;	O
int	O
offset	int
;	O
void	O
*	O
buf	*(void)
;	O
int	O
inUse	int
;	O
}	O
AioInfo	struct(int,*(void),int,int,int,*(void),int)
;	O
static	O
int	O
asyncIoTableSize	int
=	O
16	int
;	O
static	O
AioInfo	struct(int,*(void),int,int,int,*(void),int)
*	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
=	O
NULL	O
;	O
static	O
int	O
isFastCGI	int
=	O
FALSE	O
;	O
static	O
int	O
libInitialized	int
=	O
FALSE	O
;	O
static	O
fd_set	struct(array(long))
readFdSet	struct(array(long))
;	O
static	O
fd_set	struct(array(long))
writeFdSet	struct(array(long))
;	O
static	O
fd_set	struct(array(long))
readFdSetPost	struct(array(long))
;	O
static	O
int	O
numRdPosted	int
=	O
0	int
;	O
static	O
fd_set	struct(array(long))
writeFdSetPost	struct(array(long))
;	O
static	O
int	O
numWrPosted	int
=	O
0	int
;	O
static	O
int	O
volatile	O
maxFd	int
=	O
-	O
1	int
;	O
static	O
int	O
fcgiSocket	int
=	O
-	O
1	int
;	O
union	O
u_sockaddr	union(struct,struct)
{	O
struct	O
sockaddr_un	O
un	struct
;	O
struct	O
sockaddr_in	O
in	struct
;	O
}	O
static	O
fcgiSa	union(struct,struct)
;	O
static	O
int	O
fcgiClilen	int
;	O
int	O
OS_LibInit	(array(int))->(int)
(	O
int	O
stdioFds	array(int)
[	O
3	int
]	O
)	O
{	O
if	O
(	O
libInitialized	int
)	O
return	O
0	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
=	O
malloc	O
(	O
asyncIoTableSize	int
*	O
sizeof	O
(	O
AioInfo	struct(int,*(void),int,int,int,*(void),int)
)	O
)	O
;	O
if	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENOMEM	O
;	O
return	O
-	O
1	int
;	O
}	O
memset	O
(	O
(	O
char	O
*	O
)	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
,	O
0	int
,	O
asyncIoTableSize	int
*	O
sizeof	O
(	O
AioInfo	struct(int,*(void),int,int,int,*(void),int)
)	O
)	O
;	O
FD_ZERO	O
(	O
&	O
readFdSet	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
writeFdSet	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
readFdSetPost	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
writeFdSetPost	struct(array(long))
)	O
;	O
libInitialized	int
=	O
TRUE	O
;	O
return	O
0	int
;	O
}	O
void	O
OS_LibShutdown	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
libInitialized	int
)	O
return	O
;	O
free	()->(int)
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
)	O
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
=	O
NULL	O
;	O
libInitialized	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
static	O
int	O
OS_BuildSockAddrUn	(*(char),*(struct),*(int))->(int)
(	O
char	O
*	O
bindPath	*(char)
,	O
struct	O
sockaddr_un	O
*	O
servAddrPtr	*(struct)
,	O
int	O
*	O
servAddrLen	*(int)
)	O
{	O
int	O
bindPathLen	int
=	O
strlen	O
(	O
bindPath	*(char)
)	O
;	O
if	O
(	O
bindPathLen	int
>	O
sizeof	O
(	O
servAddrPtr	*(struct)
->	O
sun_path	O
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
memset	O
(	O
(	O
char	O
*	O
)	O
servAddrPtr	*(struct)
,	O
0	int
,	O
sizeof	O
(	O
*	O
servAddrPtr	*(struct)
)	O
)	O
;	O
servAddrPtr	*(struct)
->	O
sun_family	O
=	O
AF_UNIX	O
;	O
memcpy	O
(	O
servAddrPtr	*(struct)
->	O
sun_path	O
,	O
bindPath	*(char)
,	O
bindPathLen	int
)	O
;	O
*	O
servAddrLen	*(int)
=	O
sizeof	O
(	O
servAddrPtr	*(struct)
->	O
sun_family	O
)	O
+	O
bindPathLen	int
;	O
return	O
0	int
;	O
}	O
union	O
SockAddrUnion	union(struct,struct)
{	O
struct	O
sockaddr_un	O
unixVariant	struct
;	O
struct	O
sockaddr_in	O
inetVariant	struct
;	O
}	O
;	O
int	O
OS_CreateLocalIpcFd	(*(char))->(int)
(	O
char	O
*	O
bindPath	*(char)
)	O
{	O
int	O
listenSock	int
,	O
servLen	int
;	O
union	O
SockAddrUnion	union(struct,struct)
sa	union(struct,struct)
;	O
int	O
tcp	int
=	O
FALSE	O
;	O
char	O
*	O
tp	*(char)
;	O
short	O
port	short
;	O
char	O
host	char
[	O
MAXPATHLEN	O
]	O
;	O
strcpy	O
(	O
host	char
,	O
bindPath	*(char)
)	O
;	O
if	O
(	O
(	O
tp	*(char)
=	O
strchr	O
(	O
host	char
,	O
':'	O
)	O
)	O
!=	O
0	int
)	O
{	O
*	O
tp	*(char)
++	O
=	O
0	int
;	O
if	O
(	O
(	O
port	short
=	O
atoi	()->(int)
(	O
tp	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
*	O
--	O
tp	*(char)
=	O
':'	O
;	O
}	O
else	O
{	O
tcp	int
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
tcp	int
&&	O
(	O
*	O
host	char
&&	O
strcmp	O
(	O
host	char
,	O
"localhost"	*(char)
)	O
!=	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"To start a service on a TCP port can not "	*(char)
"specify a host name.\n"	*(char)
"You should either use \"localhost:<port>\" or "	*(char)
" just use \":<port>.\"\n"	*(char)
)	O
;	O
exit	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
tcp	int
)	O
{	O
listenSock	int
=	O
socket	()->(int)
(	O
AF_INET	O
,	O
SOCK_STREAM	O
,	O
0	int
)	O
;	O
if	O
(	O
listenSock	int
>=	O
0	int
)	O
{	O
int	O
flag	int
=	O
1	int
;	O
if	O
(	O
setsockopt	()->(int)
(	O
listenSock	int
,	O
SOL_SOCKET	O
,	O
SO_REUSEADDR	O
,	O
(	O
char	O
*	O
)	O
&	O
flag	int
,	O
sizeof	O
(	O
flag	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Can't set SO_REUSEADDR.\n"	*(char)
)	O
;	O
exit	O
(	O
1001	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
listenSock	int
=	O
socket	()->(int)
(	O
AF_UNIX	O
,	O
SOCK_STREAM	O
,	O
0	int
)	O
;	O
}	O
if	O
(	O
listenSock	int
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
tcp	int
)	O
{	O
memset	O
(	O
(	O
char	O
*	O
)	O
&	O
sa	union(struct,struct)
.	O
inetVariant	struct
,	O
0	int
,	O
sizeof	O
(	O
sa	union(struct,struct)
.	O
inetVariant	struct
)	O
)	O
;	O
sa	union(struct,struct)
.	O
inetVariant	struct
.	O
sin_family	O
=	O
AF_INET	O
;	O
sa	union(struct,struct)
.	O
inetVariant	struct
.	O
sin_addr	O
.	O
s_addr	O
=	O
htonl	()->(int)
(	O
INADDR_ANY	O
)	O
;	O
sa	union(struct,struct)
.	O
inetVariant	struct
.	O
sin_port	O
=	O
htons	()->(int)
(	O
port	short
)	O
;	O
servLen	int
=	O
sizeof	O
(	O
sa	union(struct,struct)
.	O
inetVariant	struct
)	O
;	O
}	O
else	O
{	O
unlink	()->(int)
(	O
bindPath	*(char)
)	O
;	O
if	O
(	O
OS_BuildSockAddrUn	(*(char),*(struct),*(int))->(int)
(	O
bindPath	*(char)
,	O
&	O
sa	union(struct,struct)
.	O
unixVariant	struct
,	O
&	O
servLen	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Listening socket's path name is too long.\n"	*(char)
)	O
;	O
exit	O
(	O
1000	int
)	O
;	O
}	O
}	O
if	O
(	O
bind	()->(int)
(	O
listenSock	int
,	O
(	O
struct	O
sockaddr	O
*	O
)	O
&	O
sa	union(struct,struct)
.	O
unixVariant	struct
,	O
servLen	int
)	O
<	O
0	int
||	O
listen	()->(int)
(	O
listenSock	int
,	O
5	int
)	O
<	O
0	int
)	O
{	O
perror	(*(char))->(void)
(	O
"bind/listen"	*(char)
)	O
;	O
exit	O
(	O
errno	O
)	O
;	O
}	O
return	O
listenSock	int
;	O
}	O
int	O
OS_FcgiConnect	(*(char))->(int)
(	O
char	O
*	O
bindPath	*(char)
)	O
{	O
union	O
SockAddrUnion	union(struct,struct)
sa	union(struct,struct)
;	O
int	O
servLen	int
,	O
resultSock	int
;	O
int	O
connectStatus	int
;	O
char	O
*	O
tp	*(char)
;	O
char	O
host	char
[	O
MAXPATHLEN	O
]	O
;	O
short	O
port	short
;	O
int	O
tcp	int
=	O
FALSE	O
;	O
strcpy	O
(	O
host	char
,	O
bindPath	*(char)
)	O
;	O
if	O
(	O
(	O
tp	*(char)
=	O
strchr	O
(	O
host	char
,	O
':'	O
)	O
)	O
!=	O
0	int
)	O
{	O
*	O
tp	*(char)
++	O
=	O
0	int
;	O
if	O
(	O
(	O
port	short
=	O
atoi	()->(int)
(	O
tp	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
*	O
--	O
tp	*(char)
=	O
':'	O
;	O
}	O
else	O
{	O
tcp	int
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
tcp	int
==	O
TRUE	O
)	O
{	O
struct	O
hostent	O
*	O
hp	*(struct)
;	O
if	O
(	O
(	O
hp	*(struct)
=	O
gethostbyname	()->(int)
(	O
(	O
*	O
host	char
?	O
host	char
:	O
"localhost"	*(char)
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Unknown host: %s\n"	*(char)
,	O
bindPath	*(char)
)	O
;	O
exit	O
(	O
1000	int
)	O
;	O
}	O
sa	union(struct,struct)
.	O
inetVariant	struct
.	O
sin_family	O
=	O
AF_INET	O
;	O
memcpy	O
(	O
(	O
caddr_t	*(char)
)	O
&	O
sa	union(struct,struct)
.	O
inetVariant	struct
.	O
sin_addr	O
,	O
hp	*(struct)
->	O
h_addr	O
,	O
hp	*(struct)
->	O
h_length	O
)	O
;	O
sa	union(struct,struct)
.	O
inetVariant	struct
.	O
sin_port	O
=	O
htons	()->(int)
(	O
port	short
)	O
;	O
servLen	int
=	O
sizeof	O
(	O
sa	union(struct,struct)
.	O
inetVariant	struct
)	O
;	O
resultSock	int
=	O
socket	()->(int)
(	O
AF_INET	O
,	O
SOCK_STREAM	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
OS_BuildSockAddrUn	(*(char),*(struct),*(int))->(int)
(	O
bindPath	*(char)
,	O
&	O
sa	union(struct,struct)
.	O
unixVariant	struct
,	O
&	O
servLen	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Listening socket's path name is too long.\n"	*(char)
)	O
;	O
exit	O
(	O
1000	int
)	O
;	O
}	O
resultSock	int
=	O
socket	()->(int)
(	O
AF_UNIX	O
,	O
SOCK_STREAM	O
,	O
0	int
)	O
;	O
}	O
assert	()->(int)
(	O
resultSock	int
>=	O
0	int
)	O
;	O
connectStatus	int
=	O
connect	()->(int)
(	O
resultSock	int
,	O
(	O
struct	O
sockaddr	O
*	O
)	O
&	O
sa	union(struct,struct)
.	O
unixVariant	struct
,	O
servLen	int
)	O
;	O
if	O
(	O
connectStatus	int
>=	O
0	int
)	O
{	O
return	O
resultSock	int
;	O
}	O
else	O
{	O
close	()->(int)
(	O
resultSock	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
OS_Read	(int,*(char),long)->(int)
(	O
int	O
fd	int
,	O
char	O
*	O
buf	*(void)
,	O
size_t	long
len	int
)	O
{	O
return	O
(	O
read	()->(int)
(	O
fd	int
,	O
buf	*(void)
,	O
len	int
)	O
)	O
;	O
}	O
int	O
OS_Write	(int,*(char),long)->(int)
(	O
int	O
fd	int
,	O
char	O
*	O
buf	*(void)
,	O
size_t	long
len	int
)	O
{	O
return	O
(	O
write	()->(int)
(	O
fd	int
,	O
buf	*(void)
,	O
len	int
)	O
)	O
;	O
}	O
int	O
OS_SpawnChild	(*(char),int)->(int)
(	O
char	O
*	O
appPath	*(char)
,	O
int	O
listenFd	int
)	O
{	O
int	O
forkResult	int
;	O
forkResult	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
forkResult	int
<	O
0	int
)	O
{	O
exit	O
(	O
errno	O
)	O
;	O
}	O
if	O
(	O
forkResult	int
==	O
0	int
)	O
{	O
close	()->(int)
(	O
STDIN_FILENO	int
)	O
;	O
if	O
(	O
listenFd	int
!=	O
FCGI_LISTENSOCK_FILENO	O
)	O
{	O
dup2	()->(int)
(	O
listenFd	int
,	O
FCGI_LISTENSOCK_FILENO	O
)	O
;	O
close	()->(int)
(	O
listenFd	int
)	O
;	O
}	O
close	()->(int)
(	O
STDOUT_FILENO	int
)	O
;	O
close	()->(int)
(	O
STDERR_FILENO	int
)	O
;	O
execl	()->(int)
(	O
appPath	*(char)
,	O
appPath	*(char)
,	O
NULL	O
)	O
;	O
exit	O
(	O
errno	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
OS_AsyncReadStdin	(*(void),int,int,*(void))->(int)
(	O
void	O
*	O
buf	*(void)
,	O
int	O
len	int
,	O
OS_AsyncProc	O
procPtr	int
,	O
ClientData	*(void)
clientData	*(void)
)	O
{	O
int	O
index	int
=	O
AIO_RD_IX	O
(	O
STDIN_FILENO	int
)	O
;	O
ASSERT	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
==	O
0	int
)	O
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
procPtr	int
=	O
procPtr	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
clientData	*(void)
=	O
clientData	*(void)
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
fd	int
=	O
STDIN_FILENO	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
len	int
=	O
len	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
offset	int
=	O
0	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
buf	*(void)
=	O
buf	*(void)
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
=	O
1	int
;	O
FD_SET	O
(	O
STDIN_FILENO	int
,	O
&	O
readFdSet	struct(array(long))
)	O
;	O
if	O
(	O
STDIN_FILENO	int
>	O
maxFd	int
)	O
maxFd	int
=	O
STDIN_FILENO	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
GrowAsyncTable	()->(void)
(	O
void	O
)	O
{	O
int	O
oldTableSize	int
=	O
asyncIoTableSize	int
;	O
asyncIoTableSize	int
=	O
asyncIoTableSize	int
*	O
2	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
=	O
realloc	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
,	O
asyncIoTableSize	int
*	O
sizeof	O
(	O
AioInfo	struct(int,*(void),int,int,int,*(void),int)
)	O
)	O
;	O
if	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENOMEM	O
;	O
exit	O
(	O
errno	O
)	O
;	O
}	O
memset	O
(	O
(	O
char	O
*	O
)	O
&	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
oldTableSize	int
]	O
,	O
0	int
,	O
oldTableSize	int
*	O
sizeof	O
(	O
AioInfo	struct(int,*(void),int,int,int,*(void),int)
)	O
)	O
;	O
}	O
int	O
OS_AsyncRead	(int,int,*(void),int,int,*(void))->(int)
(	O
int	O
fd	int
,	O
int	O
offset	int
,	O
void	O
*	O
buf	*(void)
,	O
int	O
len	int
,	O
OS_AsyncProc	O
procPtr	int
,	O
ClientData	*(void)
clientData	*(void)
)	O
{	O
int	O
index	int
=	O
AIO_RD_IX	O
(	O
fd	int
)	O
;	O
ASSERT	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
!=	O
NULL	O
)	O
;	O
if	O
(	O
fd	int
>	O
maxFd	int
)	O
maxFd	int
=	O
fd	int
;	O
if	O
(	O
index	int
>=	O
asyncIoTableSize	int
)	O
{	O
GrowAsyncTable	()->(void)
(	O
)	O
;	O
}	O
ASSERT	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
==	O
0	int
)	O
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
procPtr	int
=	O
procPtr	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
clientData	*(void)
=	O
clientData	*(void)
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
fd	int
=	O
fd	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
len	int
=	O
len	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
offset	int
=	O
offset	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
buf	*(void)
=	O
buf	*(void)
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
=	O
1	int
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
readFdSet	struct(array(long))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
OS_AsyncWrite	(int,int,*(void),int,int,*(void))->(int)
(	O
int	O
fd	int
,	O
int	O
offset	int
,	O
void	O
*	O
buf	*(void)
,	O
int	O
len	int
,	O
OS_AsyncProc	O
procPtr	int
,	O
ClientData	*(void)
clientData	*(void)
)	O
{	O
int	O
index	int
=	O
AIO_WR_IX	O
(	O
fd	int
)	O
;	O
if	O
(	O
fd	int
>	O
maxFd	int
)	O
maxFd	int
=	O
fd	int
;	O
if	O
(	O
index	int
>=	O
asyncIoTableSize	int
)	O
{	O
GrowAsyncTable	()->(void)
(	O
)	O
;	O
}	O
ASSERT	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
==	O
0	int
)	O
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
procPtr	int
=	O
procPtr	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
clientData	*(void)
=	O
clientData	*(void)
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
fd	int
=	O
fd	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
len	int
=	O
len	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
offset	int
=	O
offset	int
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
buf	*(void)
=	O
buf	*(void)
;	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
=	O
1	int
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
writeFdSet	struct(array(long))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
OS_Close	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
int	O
index	int
=	O
AIO_RD_IX	O
(	O
fd	int
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSet	struct(array(long))
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSetPost	struct(array(long))
)	O
;	O
if	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
!=	O
0	int
)	O
{	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
=	O
0	int
;	O
}	O
FD_CLR	O
(	O
fd	int
,	O
&	O
writeFdSet	struct(array(long))
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
writeFdSetPost	struct(array(long))
)	O
;	O
index	int
=	O
AIO_WR_IX	O
(	O
fd	int
)	O
;	O
if	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
!=	O
0	int
)	O
{	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
index	int
]	O
.	O
inUse	int
=	O
0	int
;	O
}	O
if	O
(	O
maxFd	int
==	O
fd	int
)	O
maxFd	int
--	O
;	O
return	O
close	()->(int)
(	O
fd	int
)	O
;	O
}	O
int	O
OS_CloseRead	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
if	O
(	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
AIO_RD_IX	O
(	O
fd	int
)	O
]	O
.	O
inUse	int
!=	O
0	int
)	O
{	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
AIO_RD_IX	O
(	O
fd	int
)	O
]	O
.	O
inUse	int
=	O
0	int
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSet	struct(array(long))
)	O
;	O
}	O
return	O
shutdown	()->(int)
(	O
fd	int
,	O
0	int
)	O
;	O
}	O
int	O
OS_DoIo	(*(struct(long,long)))->(int)
(	O
struct	O
timeval	struct(long,long)
*	O
tmo	*(struct(long,long))
)	O
{	O
int	O
fd	int
,	O
len	int
,	O
selectStatus	int
;	O
OS_AsyncProc	O
procPtr	int
;	O
ClientData	*(void)
clientData	*(void)
;	O
AioInfo	struct(int,*(void),int,int,int,*(void),int)
*	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
;	O
fd_set	struct(array(long))
readFdSetCpy	struct(array(long))
;	O
fd_set	struct(array(long))
writeFdSetCpy	struct(array(long))
;	O
FD_ZERO	O
(	O
&	O
readFdSetCpy	struct(array(long))
)	O
;	O
FD_ZERO	O
(	O
&	O
writeFdSetCpy	struct(array(long))
)	O
;	O
for	O
(	O
fd	int
=	O
0	int
;	O
fd	int
<=	O
maxFd	int
;	O
fd	int
++	O
)	O
{	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
readFdSet	struct(array(long))
)	O
)	O
{	O
FD_SET	O
(	O
fd	int
,	O
&	O
readFdSetCpy	struct(array(long))
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
writeFdSet	struct(array(long))
)	O
)	O
{	O
FD_SET	O
(	O
fd	int
,	O
&	O
writeFdSetCpy	struct(array(long))
)	O
;	O
}	O
}	O
if	O
(	O
numRdPosted	int
==	O
0	int
&&	O
numWrPosted	int
==	O
0	int
)	O
{	O
selectStatus	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
(	O
maxFd	int
+	O
1	int
)	O
,	O
&	O
readFdSetCpy	struct(array(long))
,	O
&	O
writeFdSetCpy	struct(array(long))
,	O
NULL	O
,	O
tmo	*(struct(long,long))
)	O
;	O
if	O
(	O
selectStatus	int
<	O
0	int
)	O
{	O
exit	O
(	O
errno	O
)	O
;	O
}	O
for	O
(	O
fd	int
=	O
0	int
;	O
fd	int
<=	O
maxFd	int
;	O
fd	int
++	O
)	O
{	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
readFdSetCpy	struct(array(long))
)	O
)	O
{	O
numRdPosted	int
++	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
readFdSetPost	struct(array(long))
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSet	struct(array(long))
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
writeFdSetCpy	struct(array(long))
)	O
)	O
{	O
numWrPosted	int
++	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
writeFdSetPost	struct(array(long))
)	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
writeFdSet	struct(array(long))
)	O
;	O
}	O
}	O
}	O
if	O
(	O
numRdPosted	int
==	O
0	int
&&	O
numWrPosted	int
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
fd	int
=	O
0	int
;	O
fd	int
<=	O
maxFd	int
;	O
fd	int
++	O
)	O
{	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
readFdSetPost	struct(array(long))
)	O
&&	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
AIO_RD_IX	O
(	O
fd	int
)	O
]	O
.	O
inUse	int
)	O
{	O
numRdPosted	int
--	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
readFdSetPost	struct(array(long))
)	O
;	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
=	O
&	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
AIO_RD_IX	O
(	O
fd	int
)	O
]	O
;	O
len	int
=	O
read	()->(int)
(	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
fd	int
,	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
buf	*(void)
,	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
len	int
)	O
;	O
procPtr	int
=	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
procPtr	int
;	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
procPtr	int
=	O
NULL	O
;	O
clientData	*(void)
=	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
clientData	*(void)
;	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
inUse	int
=	O
0	int
;	O
(	O
*	O
procPtr	int
)	O
(	O
clientData	*(void)
,	O
len	int
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
writeFdSetPost	struct(array(long))
)	O
&&	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
AIO_WR_IX	O
(	O
fd	int
)	O
]	O
.	O
inUse	int
)	O
{	O
numWrPosted	int
--	O
;	O
FD_CLR	O
(	O
fd	int
,	O
&	O
writeFdSetPost	struct(array(long))
)	O
;	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
=	O
&	O
asyncIoTable	*(struct(int,*(void),int,int,int,*(void),int))
[	O
AIO_WR_IX	O
(	O
fd	int
)	O
]	O
;	O
len	int
=	O
write	()->(int)
(	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
fd	int
,	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
buf	*(void)
,	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
len	int
)	O
;	O
procPtr	int
=	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
procPtr	int
;	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
procPtr	int
=	O
NULL	O
;	O
clientData	*(void)
=	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
clientData	*(void)
;	O
aioPtr	*(struct(int,*(void),int,int,int,*(void),int))
->	O
inUse	int
=	O
0	int
;	O
(	O
*	O
procPtr	int
)	O
(	O
clientData	*(void)
,	O
len	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ClientAddrOK	(*(struct),*(char))->(int)
(	O
struct	O
sockaddr_in	O
*	O
saPtr	*(struct)
,	O
char	O
*	O
clientList	*(char)
)	O
{	O
int	O
result	int
=	O
FALSE	O
;	O
char	O
*	O
clientListCopy	*(char)
,	O
*	O
cur	*(char)
,	O
*	O
next	*(char)
;	O
char	O
*	O
newString	*(char)
=	O
NULL	O
;	O
int	O
strLen	int
;	O
if	O
(	O
clientList	*(char)
==	O
NULL	O
||	O
*	O
clientList	*(char)
==	O
'\0'	O
)	O
{	O
return	O
TRUE	O
;	O
}	O
strLen	int
=	O
strlen	O
(	O
clientList	*(char)
)	O
;	O
clientListCopy	*(char)
=	O
malloc	O
(	O
strLen	int
+	O
1	int
)	O
;	O
assert	()->(int)
(	O
newString	*(char)
!=	O
NULL	O
)	O
;	O
memcpy	O
(	O
newString	*(char)
,	O
clientList	*(char)
,	O
strLen	int
)	O
;	O
newString	*(char)
[	O
strLen	int
]	O
=	O
'\000'	O
;	O
for	O
(	O
cur	*(char)
=	O
clientListCopy	*(char)
;	O
cur	*(char)
!=	O
NULL	O
;	O
cur	*(char)
=	O
next	*(char)
)	O
{	O
next	*(char)
=	O
strchr	O
(	O
cur	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
next	*(char)
!=	O
NULL	O
)	O
{	O
*	O
next	*(char)
++	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
inet_addr	()->(int)
(	O
cur	*(char)
)	O
==	O
saPtr	*(struct)
->	O
sin_addr	O
.	O
s_addr	O
)	O
{	O
result	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
}	O
free	()->(int)
(	O
clientListCopy	*(char)
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
AcquireLock	()->(int)
(	O
void	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
ReleaseLock	()->(int)
(	O
void	O
)	O
{	O
return	O
0	int
;	O
}	O
int	O
OS_FcgiIpcAccept	(*(char))->(int)
(	O
char	O
*	O
clientAddrList	*(char)
)	O
{	O
int	O
socket	()->(int)
;	O
union	O
u_sockaddr	union(struct,struct)
{	O
struct	O
sockaddr_un	O
un	struct
;	O
struct	O
sockaddr_in	O
in	struct
;	O
}	O
sa	union(struct,struct)
;	O
int	O
clilen	int
=	O
sizeof	O
(	O
sa	union(struct,struct)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
AcquireLock	()->(int)
(	O
)	O
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fcgiSocket	int
!=	O
-	O
1	int
)	O
{	O
socket	()->(int)
=	O
fcgiSocket	int
;	O
memcpy	O
(	O
&	O
sa	union(struct,struct)
,	O
&	O
fcgiSa	union(struct,struct)
,	O
fcgiClilen	int
)	O
;	O
clilen	int
=	O
fcgiClilen	int
;	O
fcgiSocket	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
do	O
{	O
socket	()->(int)
=	O
accept	()->(int)
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
(	O
struct	O
sockaddr	O
*	O
)	O
&	O
sa	union(struct,struct)
.	O
un	struct
,	O
&	O
clilen	int
)	O
;	O
}	O
while	O
(	O
(	O
socket	()->(int)
<	O
0	int
)	O
&&	O
(	O
errno	O
==	O
EINTR	O
)	O
)	O
;	O
}	O
if	O
(	O
ReleaseLock	()->(int)
(	O
)	O
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
socket	()->(int)
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
sa	union(struct,struct)
.	O
in	struct
.	O
sin_family	O
==	O
AF_INET	O
&&	O
!	O
ClientAddrOK	(*(struct),*(char))->(int)
(	O
&	O
sa	union(struct,struct)
.	O
in	struct
,	O
clientAddrList	*(char)
)	O
)	O
{	O
close	()->(int)
(	O
socket	()->(int)
)	O
;	O
socket	()->(int)
=	O
-	O
1	int
;	O
}	O
else	O
{	O
return	O
socket	()->(int)
;	O
}	O
}	O
}	O
int	O
OS_IpcClose	(int)->(int)
(	O
int	O
ipcFd	int
)	O
{	O
return	O
OS_Close	(int)->(int)
(	O
ipcFd	int
)	O
;	O
}	O
int	O
OS_IsFcgi	()->(int)
(	O
)	O
{	O
int	O
flags	int
,	O
flags1	int
;	O
fcgiClilen	int
=	O
sizeof	O
(	O
fcgiSa	union(struct,struct)
)	O
;	O
flags	int
=	O
fcntl	()->(int)
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
F_GETFL	O
,	O
0	int
)	O
;	O
flags	int
|=	O
O_NONBLOCK	O
;	O
if	O
(	O
(	O
fcntl	()->(int)
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
F_SETFL	O
,	O
flags	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
assert	()->(int)
(	O
errno	O
==	O
0	int
)	O
;	O
}	O
fcgiSocket	int
=	O
accept	()->(int)
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
(	O
struct	O
sockaddr	O
*	O
)	O
&	O
fcgiSa	union(struct,struct)
.	O
un	struct
,	O
&	O
fcgiClilen	int
)	O
;	O
if	O
(	O
fcgiSocket	int
>=	O
0	int
)	O
{	O
flags1	int
=	O
fcntl	()->(int)
(	O
fcgiSocket	int
,	O
F_GETFL	O
,	O
0	int
)	O
;	O
flags1	int
&=	O
~	O
(	O
O_NONBLOCK	O
)	O
;	O
if	O
(	O
(	O
fcntl	()->(int)
(	O
fcgiSocket	int
,	O
F_SETFL	O
,	O
flags1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
assert	()->(int)
(	O
errno	O
==	O
0	int
)	O
;	O
}	O
isFastCGI	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
if	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
{	O
isFastCGI	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
isFastCGI	int
=	O
FALSE	O
;	O
}	O
}	O
flags	int
&=	O
~	O
(	O
O_NONBLOCK	O
)	O
;	O
if	O
(	O
(	O
fcntl	()->(int)
(	O
FCGI_LISTENSOCK_FILENO	O
,	O
F_SETFL	O
,	O
flags	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
assert	()->(int)
(	O
errno	O
==	O
0	int
)	O
;	O
}	O
return	O
isFastCGI	int
;	O
}	O
void	O
OS_SetFlags	(int,int)->(void)
(	O
int	O
fd	int
,	O
int	O
flags	int
)	O
{	O
int	O
val	int
;	O
if	O
(	O
(	O
val	int
=	O
fcntl	()->(int)
(	O
fd	int
,	O
F_GETFL	O
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
exit	O
(	O
errno	O
)	O
;	O
}	O
val	int
|=	O
flags	int
;	O
if	O
(	O
fcntl	()->(int)
(	O
fd	int
,	O
F_SETFL	O
,	O
val	int
)	O
<	O
0	int
)	O
{	O
exit	O
(	O
errno	O
)	O
;	O
}	O
}	O
