int	O
check_owner	(*(struct),*(struct))->(int)
(	O
struct	O
proc	*(struct)
*	O
proc1	*(struct)
,	O
struct	O
proc	*(struct)
*	O
proc2	*(struct)
)	O
{	O
return	O
proc2	*(struct)
->	O
p_noowner	O
?	O
check_uid	()->(int)
(	O
proc1	*(struct)
,	O
0	int
)	O
||	O
proc1	*(struct)
->	O
p_login	O
==	O
proc2	*(struct)
->	O
p_login	O
:	O
check_uid	()->(int)
(	O
proc1	*(struct)
,	O
proc2	*(struct)
->	O
p_owner	O
)	O
;	O
}	O
kern_return_t	O
S_proc_pid2task	(*(struct),int,*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
task_t	O
*	O
t	*(int)
)	O
{	O
struct	O
proc	*(struct)
*	O
p	*(struct)
;	O
if	O
(	O
!	O
callerp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
=	O
pid_find_allow_zombie	()->(int)
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
if	O
(	O
p	*(struct)
->	O
p_dead	O
)	O
{	O
*	O
t	*(int)
=	O
MACH_PORT_NULL	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
check_owner	(*(struct),*(struct))->(int)
(	O
callerp	*(struct)
,	O
p	*(struct)
)	O
)	O
return	O
EPERM	O
;	O
assert	()->(int)
(	O
MACH_PORT_VALID	()->(int)
(	O
p	*(struct)
->	O
p_task	O
)	O
)	O
;	O
*	O
t	*(int)
=	O
p	*(struct)
->	O
p_task	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_task2pid	(*(struct),int,*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
task_t	O
t	*(int)
,	O
pid_t	int
*	O
pid	int
)	O
{	O
struct	O
proc	*(struct)
*	O
p	*(struct)
=	O
task_find	()->(int)
(	O
t	*(int)
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
*	O
pid	int
=	O
p	*(struct)
->	O
p_pid	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
t	*(int)
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_task2proc	(*(struct),int,*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
task_t	O
t	*(int)
,	O
mach_port_t	O
*	O
outproc	*(int)
)	O
{	O
struct	O
proc	*(struct)
*	O
p	*(struct)
=	O
task_find	()->(int)
(	O
t	*(int)
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
*	O
outproc	*(int)
=	O
ports_get_right	()->(int)
(	O
p	*(struct)
)	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
t	*(int)
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_proc2task	(*(struct),*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
p	*(struct)
,	O
task_t	O
*	O
t	*(int)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
t	*(int)
=	O
p	*(struct)
->	O
p_task	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_pid2proc	(*(struct),int,*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
mach_port_t	O
*	O
outproc	*(int)
)	O
{	O
struct	O
proc	*(struct)
*	O
p	*(struct)
;	O
if	O
(	O
!	O
callerp	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
=	O
pid_find_allow_zombie	()->(int)
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
if	O
(	O
p	*(struct)
->	O
p_dead	O
)	O
{	O
*	O
outproc	*(int)
=	O
MACH_PORT_NULL	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
check_owner	(*(struct),*(struct))->(int)
(	O
callerp	*(struct)
,	O
p	*(struct)
)	O
)	O
return	O
EPERM	O
;	O
*	O
outproc	*(int)
=	O
ports_get_right	()->(int)
(	O
p	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	O
get_string	(int,int,*(*(char)),*(long))->(int)
(	O
task_t	O
t	*(int)
,	O
vm_address_t	O
addr	int
,	O
char	O
*	O
*	O
str	*(*(char))
,	O
size_t	long
*	O
len	*(long)
)	O
{	O
vm_address_t	O
readaddr	O
;	O
vm_address_t	O
data	O
;	O
size_t	long
readlen	long
;	O
error_t	O
err	O
;	O
char	O
*	O
c	*(char)
;	O
readaddr	O
=	O
trunc_page	()->(int)
(	O
addr	int
)	O
;	O
err	O
=	O
vm_read	()->(int)
(	O
t	*(int)
,	O
readaddr	O
,	O
vm_page_size	O
*	O
2	int
,	O
&	O
data	O
,	O
&	O
readlen	long
)	O
;	O
if	O
(	O
err	O
==	O
KERN_INVALID_ADDRESS	O
)	O
err	O
=	O
vm_read	()->(int)
(	O
t	*(int)
,	O
readaddr	O
,	O
vm_page_size	O
,	O
&	O
data	O
,	O
&	O
readlen	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
c	*(char)
=	O
memchr	O
(	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
,	O
'\0'	O
,	O
readlen	long
-	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
;	O
if	O
(	O
c	*(char)
==	O
NULL	O
)	O
err	O
=	O
KERN_INVALID_ADDRESS	O
;	O
else	O
{	O
c	*(char)
++	O
;	O
*	O
len	*(long)
=	O
c	*(char)
-	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
;	O
*	O
str	*(*(char))
=	O
malloc	O
(	O
*	O
len	*(long)
)	O
;	O
if	O
(	O
*	O
str	*(*(char))
==	O
NULL	O
)	O
err	O
=	O
ENOMEM	O
;	O
else	O
memcpy	O
(	O
*	O
str	*(*(char))
,	O
(	O
char	O
*	O
)	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
,	O
*	O
len	*(long)
)	O
;	O
}	O
munmap	()->(int)
(	O
(	O
caddr_t	*(char)
)	O
data	O
,	O
readlen	long
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
get_vector	(int,int,*(*(int)))->(int)
(	O
task_t	O
task	int
,	O
vm_address_t	O
addr	int
,	O
int	O
*	O
*	O
vec	*(*(int))
)	O
{	O
vm_address_t	O
readaddr	O
;	O
vm_size_t	O
readsize	O
;	O
vm_address_t	O
scanned	O
;	O
error_t	O
err	O
;	O
*	O
vec	*(*(int))
=	O
NULL	O
;	O
readaddr	O
=	O
trunc_page	()->(int)
(	O
addr	int
)	O
;	O
readsize	O
=	O
0	int
;	O
scanned	O
=	O
addr	int
;	O
do	O
{	O
vm_address_t	O
data	O
;	O
mach_msg_type_number_t	O
readlen	long
=	O
0	int
;	O
vm_address_t	O
*	O
t	*(int)
;	O
readsize	O
+=	O
vm_page_size	O
;	O
err	O
=	O
vm_read	()->(int)
(	O
task	int
,	O
readaddr	O
,	O
readsize	O
,	O
&	O
data	O
,	O
&	O
readlen	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
for	O
(	O
t	*(int)
=	O
(	O
vm_address_t	O
*	O
)	O
(	O
data	O
+	O
(	O
scanned	O
-	O
readaddr	O
)	O
)	O
;	O
t	*(int)
<	O
(	O
vm_address_t	O
*	O
)	O
(	O
data	O
+	O
readlen	long
)	O
;	O
++	O
t	*(int)
)	O
if	O
(	O
*	O
t	*(int)
==	O
0	int
)	O
{	O
++	O
t	*(int)
;	O
*	O
vec	*(*(int))
=	O
malloc	O
(	O
(	O
char	O
*	O
)	O
t	*(int)
-	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
)	O
;	O
if	O
(	O
*	O
vec	*(*(int))
==	O
NULL	O
)	O
err	O
=	O
ENOMEM	O
;	O
else	O
memcpy	O
(	O
*	O
vec	*(*(int))
,	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
,	O
(	O
char	O
*	O
)	O
t	*(int)
-	O
(	O
char	O
*	O
)	O
(	O
data	O
+	O
(	O
addr	int
-	O
readaddr	O
)	O
)	O
)	O
;	O
break	O
;	O
}	O
scanned	O
=	O
readaddr	O
+	O
readlen	long
;	O
munmap	()->(int)
(	O
(	O
caddr_t	*(char)
)	O
data	O
,	O
readlen	long
)	O
;	O
}	O
while	O
(	O
!	O
err	O
&&	O
*	O
vec	*(*(int))
==	O
NULL	O
)	O
;	O
return	O
err	O
;	O
}	O
static	O
error_t	O
get_string_array	(int,int,*(int),*(long))->(int)
(	O
task_t	O
t	*(int)
,	O
vm_address_t	O
loc	int
,	O
vm_address_t	O
*	O
buf	*(int)
,	O
size_t	long
*	O
buflen	*(long)
)	O
{	O
char	O
*	O
bp	*(char)
;	O
int	O
*	O
vector	*(int)
,	O
*	O
vp	*(int)
;	O
error_t	O
err	O
;	O
vm_address_t	O
origbuf	O
=	O
*	O
buf	*(int)
;	O
err	O
=	O
get_vector	(int,int,*(*(int)))->(int)
(	O
t	*(int)
,	O
loc	int
,	O
&	O
vector	*(int)
)	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
bp	*(char)
=	O
(	O
char	O
*	O
)	O
*	O
buf	*(int)
;	O
for	O
(	O
vp	*(int)
=	O
vector	*(int)
;	O
*	O
vp	*(int)
;	O
++	O
vp	*(int)
)	O
{	O
char	O
*	O
string	*(char)
;	O
size_t	long
len	*(long)
;	O
err	O
=	O
get_string	(int,int,*(*(char)),*(long))->(int)
(	O
t	*(int)
,	O
*	O
vp	*(int)
,	O
&	O
string	*(char)
,	O
&	O
len	*(long)
)	O
;	O
if	O
(	O
err	O
)	O
{	O
free	()->(int)
(	O
vector	*(int)
)	O
;	O
if	O
(	O
*	O
buf	*(int)
!=	O
origbuf	O
)	O
munmap	()->(int)
(	O
(	O
caddr_t	*(char)
)	O
*	O
buf	*(int)
,	O
*	O
buflen	*(long)
)	O
;	O
return	O
err	O
;	O
}	O
if	O
(	O
len	*(long)
>	O
(	O
char	O
*	O
)	O
*	O
buf	*(int)
+	O
*	O
buflen	*(long)
-	O
bp	*(char)
)	O
{	O
char	O
*	O
newbuf	*(char)
;	O
vm_size_t	O
prev_len	O
=	O
bp	*(char)
-	O
(	O
char	O
*	O
)	O
*	O
buf	*(int)
;	O
vm_size_t	O
newsize	O
=	O
*	O
buflen	*(long)
*	O
2	int
;	O
if	O
(	O
newsize	O
<	O
prev_len	O
+	O
len	*(long)
)	O
newsize	O
=	O
round_page	()->(int)
(	O
prev_len	O
+	O
len	*(long)
)	O
;	O
newbuf	*(char)
=	O
mmap	()->(int)
(	O
0	int
,	O
newsize	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
newbuf	*(char)
==	O
MAP_FAILED	O
)	O
{	O
err	O
=	O
errno	O
;	O
free	()->(int)
(	O
string	*(char)
)	O
;	O
free	()->(int)
(	O
vector	*(int)
)	O
;	O
if	O
(	O
*	O
buf	*(int)
!=	O
origbuf	O
)	O
munmap	()->(int)
(	O
(	O
caddr_t	*(char)
)	O
*	O
buf	*(int)
,	O
*	O
buflen	*(long)
)	O
;	O
return	O
err	O
;	O
}	O
memcpy	O
(	O
newbuf	*(char)
,	O
(	O
char	O
*	O
)	O
*	O
buf	*(int)
,	O
prev_len	O
)	O
;	O
bp	*(char)
=	O
newbuf	*(char)
+	O
prev_len	O
;	O
if	O
(	O
*	O
buf	*(int)
!=	O
origbuf	O
)	O
munmap	()->(int)
(	O
(	O
caddr_t	*(char)
)	O
*	O
buf	*(int)
,	O
*	O
buflen	*(long)
)	O
;	O
*	O
buf	*(int)
=	O
(	O
vm_address_t	O
)	O
newbuf	*(char)
;	O
*	O
buflen	*(long)
=	O
newsize	O
;	O
}	O
memcpy	O
(	O
bp	*(char)
,	O
string	*(char)
,	O
len	*(long)
)	O
;	O
bp	*(char)
+=	O
len	*(long)
;	O
free	()->(int)
(	O
string	*(char)
)	O
;	O
}	O
free	()->(int)
(	O
vector	*(int)
)	O
;	O
*	O
buflen	*(long)
=	O
bp	*(char)
-	O
(	O
char	O
*	O
)	O
*	O
buf	*(int)
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getprocargs	(*(struct),int,*(*(char)),*(long))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
char	O
*	O
*	O
buf	*(int)
,	O
size_t	long
*	O
buflen	*(long)
)	O
{	O
struct	O
proc	*(struct)
*	O
p	*(struct)
=	O
pid_find	()->(int)
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
return	O
get_string_array	(int,int,*(int),*(long))->(int)
(	O
p	*(struct)
->	O
p_task	O
,	O
p	*(struct)
->	O
p_argv	O
,	O
(	O
vm_address_t	O
*	O
)	O
buf	*(int)
,	O
buflen	*(long)
)	O
;	O
}	O
kern_return_t	O
S_proc_getprocenv	(*(struct),int,*(*(char)),*(long))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
char	O
*	O
*	O
buf	*(int)
,	O
size_t	long
*	O
buflen	*(long)
)	O
{	O
struct	O
proc	*(struct)
*	O
p	*(struct)
=	O
pid_find	()->(int)
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
return	O
get_string_array	(int,int,*(int),*(long))->(int)
(	O
p	*(struct)
->	O
p_task	O
,	O
p	*(struct)
->	O
p_envp	O
,	O
(	O
vm_address_t	O
*	O
)	O
buf	*(int)
,	O
buflen	*(long)
)	O
;	O
}	O
kern_return_t	O
S_proc_getprocinfo	(*(struct),int,*(int),*(*(int)),*(long),*(*(char)),*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
int	O
*	O
flags	*(int)
,	O
int	O
*	O
*	O
piarray	*(*(int))
,	O
size_t	long
*	O
piarraylen	*(long)
,	O
char	O
*	O
*	O
waits	*(*(char))
,	O
mach_msg_type_number_t	O
*	O
waits_len	*(int)
)	O
{	O
struct	O
proc	*(struct)
*	O
p	*(struct)
=	O
pid_find	()->(int)
(	O
pid	int
)	O
;	O
struct	O
procinfo	O
*	O
pi	*(struct)
;	O
size_t	long
nthreads	long
;	O
thread_t	O
*	O
thds	O
;	O
error_t	O
err	O
=	O
0	int
;	O
size_t	long
structsize	long
;	O
int	O
i	int
;	O
int	O
pi_alloced	int
=	O
0	int
,	O
waits_alloced	int
=	O
0	int
;	O
mach_msg_type_number_t	O
waits_used	O
=	O
0	int
;	O
size_t	long
tkcount	long
,	O
thcount	long
;	O
struct	O
proc	*(struct)
*	O
tp	*(struct)
;	O
task_t	O
task	int
;	O
mach_port_t	O
msgport	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
task	int
=	O
p	*(struct)
->	O
p_task	O
;	O
check_msgport_death	()->(int)
(	O
p	*(struct)
)	O
;	O
msgport	O
=	O
p	*(struct)
->	O
p_msgport	O
;	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREAD_DETAILS	O
)	O
*	O
flags	*(int)
|=	O
PI_FETCH_THREADS	O
;	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREADS	O
)	O
{	O
err	O
=	O
task_threads	()->(int)
(	O
p	*(struct)
->	O
p_task	O
,	O
&	O
thds	O
,	O
&	O
nthreads	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
err	O
)	O
return	O
err	O
;	O
}	O
else	O
nthreads	long
=	O
0	int
;	O
structsize	long
=	O
sizeof	O
(	O
struct	O
procinfo	O
)	O
;	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREAD_DETAILS	O
)	O
structsize	long
+=	O
nthreads	long
*	O
sizeof	O
(	O
pi	*(struct)
->	O
threadinfos	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
structsize	long
/	O
sizeof	O
(	O
int	O
)	O
>	O
*	O
piarraylen	*(long)
)	O
{	O
*	O
piarray	*(*(int))
=	O
mmap	()->(int)
(	O
0	int
,	O
structsize	long
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
piarray	*(*(int))
==	O
MAP_FAILED	O
)	O
{	O
err	O
=	O
errno	O
;	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREADS	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nthreads	long
;	O
i	int
++	O
)	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
thds	O
[	O
i	int
]	O
)	O
;	O
munmap	()->(int)
(	O
thds	O
,	O
nthreads	long
*	O
sizeof	O
(	O
thread_t	O
)	O
)	O
;	O
}	O
return	O
err	O
;	O
}	O
pi_alloced	int
=	O
1	int
;	O
}	O
*	O
piarraylen	*(long)
=	O
structsize	long
/	O
sizeof	O
(	O
int	O
)	O
;	O
pi	*(struct)
=	O
(	O
struct	O
procinfo	O
*	O
)	O
*	O
piarray	*(*(int))
;	O
pi	*(struct)
->	O
state	O
=	O
(	O
(	O
p	*(struct)
->	O
p_stopped	O
?	O
PI_STOPPED	O
:	O
0	int
)	O
|	O
(	O
p	*(struct)
->	O
p_exec	O
?	O
PI_EXECED	O
:	O
0	int
)	O
|	O
(	O
p	*(struct)
->	O
p_waiting	O
?	O
PI_WAITING	O
:	O
0	int
)	O
|	O
(	O
!	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_orphcnt	O
?	O
PI_ORPHAN	O
:	O
0	int
)	O
|	O
(	O
p	*(struct)
->	O
p_msgport	O
==	O
MACH_PORT_NULL	O
?	O
PI_NOMSG	O
:	O
0	int
)	O
|	O
(	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sid	O
==	O
p	*(struct)
->	O
p_pid	O
?	O
PI_SESSLD	O
:	O
0	int
)	O
|	O
(	O
p	*(struct)
->	O
p_noowner	O
?	O
PI_NOTOWNED	O
:	O
0	int
)	O
|	O
(	O
!	O
p	*(struct)
->	O
p_parentset	O
?	O
PI_NOPARENT	O
:	O
0	int
)	O
|	O
(	O
p	*(struct)
->	O
p_traced	O
?	O
PI_TRACED	O
:	O
0	int
)	O
|	O
(	O
p	*(struct)
->	O
p_msgportwait	O
?	O
PI_GETMSG	O
:	O
0	int
)	O
|	O
(	O
p	*(struct)
->	O
p_loginleader	O
?	O
PI_LOGINLD	O
:	O
0	int
)	O
)	O
;	O
pi	*(struct)
->	O
owner	O
=	O
p	*(struct)
->	O
p_owner	O
;	O
pi	*(struct)
->	O
ppid	O
=	O
p	*(struct)
->	O
p_parent	O
->	O
p_pid	O
;	O
pi	*(struct)
->	O
pgrp	O
=	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_pgid	O
;	O
pi	*(struct)
->	O
session	O
=	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_session	O
->	O
s_sid	O
;	O
for	O
(	O
tp	*(struct)
=	O
p	*(struct)
;	O
!	O
tp	*(struct)
->	O
p_loginleader	O
;	O
tp	*(struct)
=	O
tp	*(struct)
->	O
p_parent	O
)	O
assert	()->(int)
(	O
tp	*(struct)
)	O
;	O
pi	*(struct)
->	O
logincollection	O
=	O
tp	*(struct)
->	O
p_pid	O
;	O
if	O
(	O
p	*(struct)
->	O
p_dead	O
||	O
p	*(struct)
->	O
p_stopped	O
)	O
{	O
pi	*(struct)
->	O
exitstatus	O
=	O
p	*(struct)
->	O
p_status	O
;	O
pi	*(struct)
->	O
sigcode	O
=	O
p	*(struct)
->	O
p_sigcode	O
;	O
}	O
else	O
pi	*(struct)
->	O
exitstatus	O
=	O
pi	*(struct)
->	O
sigcode	O
=	O
0	int
;	O
pi	*(struct)
->	O
nthreads	long
=	O
nthreads	long
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_TASKINFO	O
)	O
{	O
tkcount	long
=	O
TASK_BASIC_INFO_COUNT	O
;	O
err	O
=	O
task_info	()->(int)
(	O
task	int
,	O
TASK_BASIC_INFO	O
,	O
(	O
task_info_t	O
)	O
&	O
pi	*(struct)
->	O
taskinfo	O
,	O
&	O
tkcount	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
}	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_TASKEVENTS	O
)	O
{	O
tkcount	long
=	O
TASK_EVENTS_INFO_COUNT	O
;	O
err	O
=	O
task_info	()->(int)
(	O
task	int
,	O
TASK_EVENTS_INFO	O
,	O
(	O
task_info_t	O
)	O
&	O
pi	*(struct)
->	O
taskevents	O
,	O
&	O
tkcount	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
err	O
)	O
{	O
*	O
flags	*(int)
&=	O
~	O
PI_FETCH_TASKEVENTS	O
;	O
err	O
=	O
0	int
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nthreads	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREAD_DETAILS	O
)	O
pi	*(struct)
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
=	O
0	int
;	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREAD_BASIC	O
)	O
{	O
thcount	long
=	O
THREAD_BASIC_INFO_COUNT	O
;	O
err	O
=	O
thread_info	()->(int)
(	O
thds	O
[	O
i	int
]	O
,	O
THREAD_BASIC_INFO	O
,	O
(	O
thread_info_t	O
)	O
&	O
pi	*(struct)
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_bi	O
,	O
&	O
thcount	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
{	O
pi	*(struct)
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
=	O
1	int
;	O
err	O
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
err	O
)	O
{	O
*	O
flags	*(int)
&=	O
~	O
PI_FETCH_THREAD_BASIC	O
;	O
err	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREAD_SCHED	O
)	O
{	O
thcount	long
=	O
THREAD_SCHED_INFO_COUNT	O
;	O
err	O
=	O
thread_info	()->(int)
(	O
thds	O
[	O
i	int
]	O
,	O
THREAD_SCHED_INFO	O
,	O
(	O
thread_info_t	O
)	O
&	O
pi	*(struct)
->	O
threadinfos	O
[	O
i	int
]	O
.	O
pis_si	O
,	O
&	O
thcount	long
)	O
;	O
if	O
(	O
err	O
==	O
MACH_SEND_INVALID_DEST	O
)	O
{	O
pi	*(struct)
->	O
threadinfos	O
[	O
i	int
]	O
.	O
died	O
=	O
1	int
;	O
err	O
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
err	O
)	O
{	O
*	O
flags	*(int)
&=	O
~	O
PI_FETCH_THREAD_SCHED	O
;	O
err	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREAD_WAITS	O
)	O
{	O
if	O
(	O
msgport	O
==	O
MACH_PORT_NULL	O
)	O
*	O
flags	*(int)
&=	O
~	O
PI_FETCH_THREAD_WAITS	O
;	O
else	O
{	O
string_t	O
desc	O
;	O
size_t	long
desc_len	long
;	O
if	O
(	O
msg_report_wait	()->(int)
(	O
msgport	O
,	O
thds	O
[	O
i	int
]	O
,	O
desc	O
,	O
&	O
pi	*(struct)
->	O
threadinfos	O
[	O
i	int
]	O
.	O
rpc_block	O
)	O
)	O
desc	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
desc_len	long
=	O
strnlen	()->(int)
(	O
desc	O
,	O
sizeof	O
desc	O
)	O
;	O
if	O
(	O
waits_used	O
+	O
desc_len	long
+	O
1	int
>	O
*	O
waits_len	*(int)
)	O
{	O
char	O
*	O
new_waits	*(char)
=	O
0	int
;	O
mach_msg_type_number_t	O
new_len	O
=	O
round_page	()->(int)
(	O
waits_used	O
+	O
desc_len	long
+	O
1	int
)	O
;	O
new_waits	*(char)
=	O
mmap	()->(int)
(	O
0	int
,	O
new_len	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
err	O
=	O
(	O
new_waits	*(char)
==	O
MAP_FAILED	O
)	O
?	O
errno	O
:	O
0	int
;	O
if	O
(	O
err	O
)	O
*	O
flags	*(int)
&=	O
~	O
PI_FETCH_THREAD_WAITS	O
;	O
else	O
{	O
if	O
(	O
waits_used	O
>	O
0	int
)	O
memcpy	O
(	O
new_waits	*(char)
,	O
*	O
waits	*(*(char))
,	O
waits_used	O
)	O
;	O
if	O
(	O
*	O
waits_len	*(int)
>	O
0	int
&&	O
waits_alloced	int
)	O
munmap	()->(int)
(	O
*	O
waits	*(*(char))
,	O
*	O
waits_len	*(int)
)	O
;	O
*	O
waits	*(*(char))
=	O
new_waits	*(char)
;	O
*	O
waits_len	*(int)
=	O
new_len	O
;	O
waits_alloced	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
waits_used	O
+	O
desc_len	long
+	O
1	int
<=	O
*	O
waits_len	*(int)
)	O
{	O
memcpy	O
(	O
*	O
waits	*(*(char))
+	O
waits_used	O
,	O
desc	O
,	O
desc_len	long
)	O
;	O
waits_used	O
+=	O
desc_len	long
;	O
(	O
*	O
waits	*(*(char))
)	O
[	O
waits_used	O
++	O
]	O
=	O
'\0'	O
;	O
}	O
}	O
}	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
thds	O
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
*	O
flags	*(int)
&	O
PI_FETCH_THREADS	O
)	O
munmap	()->(int)
(	O
thds	O
,	O
nthreads	long
*	O
sizeof	O
(	O
thread_t	O
)	O
)	O
;	O
if	O
(	O
err	O
&&	O
pi_alloced	int
)	O
munmap	()->(int)
(	O
*	O
piarray	*(*(int))
,	O
structsize	long
)	O
;	O
if	O
(	O
err	O
&&	O
waits_alloced	int
)	O
munmap	()->(int)
(	O
*	O
waits	*(*(char))
,	O
*	O
waits_len	*(int)
)	O
;	O
else	O
*	O
waits_len	*(int)
=	O
waits_used	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
global_lock	O
)	O
;	O
return	O
err	O
;	O
}	O
kern_return_t	O
S_proc_make_login_coll	(*(struct))->(int)
(	O
struct	O
proc	*(struct)
*	O
p	*(struct)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
->	O
p_loginleader	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getloginid	(*(struct),int,*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
pid_t	int
*	O
leader	*(int)
)	O
{	O
struct	O
proc	*(struct)
*	O
proc	*(struct)
=	O
pid_find	()->(int)
(	O
pid	int
)	O
;	O
struct	O
proc	*(struct)
*	O
p	*(struct)
;	O
if	O
(	O
!	O
proc	*(struct)
)	O
return	O
ESRCH	O
;	O
for	O
(	O
p	*(struct)
=	O
proc	*(struct)
;	O
!	O
p	*(struct)
->	O
p_loginleader	O
;	O
p	*(struct)
=	O
p	*(struct)
->	O
p_parent	O
)	O
assert	()->(int)
(	O
p	*(struct)
)	O
;	O
*	O
leader	*(int)
=	O
p	*(struct)
->	O
p_pid	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getloginpids	(*(struct),int,*(*(int)),*(long))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
pid_t	int
id	int
,	O
pid_t	int
*	O
*	O
pids	*(*(int))
,	O
size_t	long
*	O
npids	*(long)
)	O
{	O
error_t	O
err	O
=	O
0	int
;	O
struct	O
proc	*(struct)
*	O
l	*(struct)
=	O
pid_find	()->(int)
(	O
id	int
)	O
;	O
struct	O
proc	*(struct)
*	O
p	*(struct)
;	O
struct	O
proc	*(struct)
*	O
*	O
tail	*(*(struct))
,	O
*	O
*	O
new	*(*(struct))
,	O
*	O
*	O
parray	*(*(struct))
;	O
int	O
parraysize	int
;	O
int	O
i	int
;	O
if	O
(	O
!	O
l	*(struct)
||	O
!	O
l	*(struct)
->	O
p_loginleader	O
)	O
return	O
ESRCH	O
;	O
parraysize	int
=	O
50	int
;	O
parray	*(*(struct))
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
proc	*(struct)
*	O
)	O
*	O
parraysize	int
)	O
;	O
if	O
(	O
!	O
parray	*(*(struct))
)	O
return	O
ENOMEM	O
;	O
parray	*(*(struct))
[	O
0	int
]	O
=	O
l	*(struct)
;	O
for	O
(	O
tail	*(*(struct))
=	O
parray	*(*(struct))
,	O
new	*(*(struct))
=	O
&	O
parray	*(*(struct))
[	O
1	int
]	O
;	O
tail	*(*(struct))
!=	O
new	*(*(struct))
;	O
tail	*(*(struct))
++	O
)	O
{	O
for	O
(	O
p	*(struct)
=	O
(	O
*	O
tail	*(*(struct))
)	O
->	O
p_ochild	O
;	O
p	*(struct)
;	O
p	*(struct)
=	O
p	*(struct)
->	O
p_sib	O
)	O
if	O
(	O
!	O
p	*(struct)
->	O
p_loginleader	O
)	O
{	O
if	O
(	O
new	*(*(struct))
-	O
parray	*(*(struct))
>	O
parraysize	int
)	O
{	O
struct	O
proc	*(struct)
*	O
*	O
newparray	*(*(struct))
;	O
newparray	*(*(struct))
=	O
realloc	O
(	O
parray	*(*(struct))
,	O
(	O
(	O
parraysize	int
*=	O
2	int
)	O
*	O
sizeof	O
(	O
struct	O
proc	*(struct)
*	O
)	O
)	O
)	O
;	O
if	O
(	O
!	O
newparray	*(*(struct))
)	O
{	O
free	()->(int)
(	O
parray	*(*(struct))
)	O
;	O
return	O
ENOMEM	O
;	O
}	O
tail	*(*(struct))
=	O
newparray	*(*(struct))
+	O
(	O
tail	*(*(struct))
-	O
parray	*(*(struct))
)	O
;	O
new	*(*(struct))
=	O
newparray	*(*(struct))
+	O
(	O
new	*(*(struct))
-	O
parray	*(*(struct))
)	O
;	O
parray	*(*(struct))
=	O
newparray	*(*(struct))
;	O
}	O
*	O
new	*(*(struct))
++	O
=	O
p	*(struct)
;	O
}	O
}	O
if	O
(	O
*	O
npids	*(long)
<	O
new	*(*(struct))
-	O
parray	*(*(struct))
)	O
{	O
*	O
pids	*(*(int))
=	O
mmap	()->(int)
(	O
0	int
,	O
(	O
new	*(*(struct))
-	O
parray	*(*(struct))
)	O
*	O
sizeof	O
(	O
pid_t	int
)	O
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_ANON	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
*	O
pids	*(*(int))
==	O
MAP_FAILED	O
)	O
err	O
=	O
errno	O
;	O
}	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
npids	*(long)
=	O
new	*(*(struct))
-	O
parray	*(*(struct))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
npids	*(long)
;	O
i	int
++	O
)	O
(	O
*	O
pids	*(*(int))
)	O
[	O
i	int
]	O
=	O
parray	*(*(struct))
[	O
i	int
]	O
->	O
p_pid	O
;	O
}	O
free	()->(int)
(	O
parray	*(*(struct))
)	O
;	O
return	O
err	O
;	O
}	O
kern_return_t	O
S_proc_setlogin	(*(struct),*(char))->(int)
(	O
struct	O
proc	*(struct)
*	O
p	*(struct)
,	O
char	O
*	O
login	*(char)
)	O
{	O
struct	O
login	*(char)
*	O
l	*(struct)
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
!	O
check_uid	()->(int)
(	O
p	*(struct)
,	O
0	int
)	O
)	O
return	O
EPERM	O
;	O
l	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
login	*(char)
)	O
+	O
strlen	O
(	O
login	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
l	*(struct)
)	O
return	O
ENOMEM	O
;	O
l	*(struct)
->	O
l_refcnt	O
=	O
1	int
;	O
strcpy	O
(	O
l	*(struct)
->	O
l_name	O
,	O
login	*(char)
)	O
;	O
if	O
(	O
!	O
--	O
p	*(struct)
->	O
p_login	O
->	O
l_refcnt	O
)	O
free	()->(int)
(	O
p	*(struct)
->	O
p_login	O
)	O
;	O
p	*(struct)
->	O
p_login	O
=	O
l	*(struct)
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_getlogin	(*(struct),*(char))->(int)
(	O
struct	O
proc	*(struct)
*	O
p	*(struct)
,	O
char	O
*	O
login	*(char)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
strcpy	O
(	O
login	*(char)
,	O
p	*(struct)
->	O
p_login	O
->	O
l_name	O
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_get_tty	(*(struct),int,*(int),*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
p	*(struct)
,	O
pid_t	int
pid	int
,	O
mach_port_t	O
*	O
tty	*(int)
,	O
mach_msg_type_name_t	O
*	O
tty_type	*(int)
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
kern_return_t	O
S_proc_getnports	(*(struct),int,*(int))->(int)
(	O
struct	O
proc	*(struct)
*	O
callerp	*(struct)
,	O
pid_t	int
pid	int
,	O
mach_msg_type_number_t	O
*	O
nports	*(int)
)	O
{	O
struct	O
proc	*(struct)
*	O
p	*(struct)
=	O
pid_find	()->(int)
(	O
pid	int
)	O
;	O
mach_port_array_t	O
names	O
;	O
mach_msg_type_number_t	O
ncount	O
;	O
mach_port_type_array_t	O
types	O
;	O
mach_msg_type_number_t	O
tcount	O
;	O
error_t	O
err	O
=	O
0	int
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
ESRCH	O
;	O
err	O
=	O
mach_port_names	()->(int)
(	O
p	*(struct)
->	O
p_task	O
,	O
&	O
names	O
,	O
&	O
ncount	O
,	O
&	O
types	O
,	O
&	O
tcount	O
)	O
;	O
if	O
(	O
err	O
==	O
KERN_INVALID_TASK	O
)	O
err	O
=	O
ESRCH	O
;	O
if	O
(	O
!	O
err	O
)	O
{	O
*	O
nports	*(int)
=	O
ncount	O
;	O
munmap	()->(int)
(	O
names	O
,	O
ncount	O
*	O
sizeof	O
(	O
mach_port_t	O
)	O
)	O
;	O
munmap	()->(int)
(	O
types	O
,	O
tcount	O
*	O
sizeof	O
(	O
mach_port_type_t	O
)	O
)	O
;	O
}	O
return	O
err	O
;	O
}	O
