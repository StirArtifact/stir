static	O
const	O
char	O
*	O
special_terminating_arg	*(char)
=	O
"do_not_care"	*(char)
;	O
static	O
void	O
bc_args_complete	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
)	O
{	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
,	O
special_terminating_arg	*(char)
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
bc_do_insert	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,*(char),long,int)->(void)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
,	O
char	O
*	O
arg	*(char)
,	O
size_t	long
arglen	long
,	O
const	O
char	O
*	O
prefix	*(char)
,	O
size_t	long
pfxlen	long
,	O
const	O
char	O
*	O
linebuf	*(char)
,	O
size_t	long
lblen	long
,	O
int	O
initial_args	int
)	O
{	O
static	O
char	O
*	O
insertbuf	*(char)
;	O
char	O
*	O
p	*(void)
;	O
size_t	long
bytes_left	long
=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
-	O
1	int
;	O
if	O
(	O
!	O
insertbuf	*(char)
)	O
insertbuf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
+	O
1	int
)	O
;	O
p	*(void)
=	O
insertbuf	*(char)
;	O
do	O
{	O
size_t	long
len	long
;	O
char	O
*	O
s	long
=	O
mbsstr	(*(char),*(char))->(*(char))
(	O
arg	*(char)
,	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
replace_pat	*(char)
)	O
;	O
if	O
(	O
s	long
)	O
{	O
len	long
=	O
s	long
-	O
arg	*(char)
;	O
}	O
else	O
{	O
len	long
=	O
arglen	long
;	O
}	O
if	O
(	O
bytes_left	long
<=	O
len	long
)	O
break	O
;	O
else	O
bytes_left	long
-=	O
len	long
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
p	*(void)
,	O
arg	*(char)
,	O
len	long
)	O
;	O
p	*(void)
+=	O
len	long
;	O
arg	*(char)
+=	O
len	long
;	O
arglen	long
-=	O
len	long
;	O
if	O
(	O
s	long
)	O
{	O
if	O
(	O
bytes_left	long
<=	O
(	O
lblen	long
+	O
pfxlen	long
)	O
)	O
break	O
;	O
else	O
bytes_left	long
-=	O
(	O
lblen	long
+	O
pfxlen	long
)	O
;	O
if	O
(	O
prefix	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
prefix	*(char)
)	O
;	O
p	*(void)
+=	O
pfxlen	long
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
linebuf	*(char)
)	O
;	O
p	*(void)
+=	O
lblen	long
;	O
arg	*(char)
+=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
rplen	long
;	O
arglen	long
-=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
rplen	long
;	O
}	O
}	O
while	O
(	O
*	O
arg	*(char)
)	O
;	O
if	O
(	O
*	O
arg	*(char)
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"command too long"	*(char)
)	O
)	O
;	O
*	O
p	*(void)
++	O
=	O
'\0'	O
;	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
,	O
insertbuf	*(char)
,	O
p	*(void)
-	O
insertbuf	*(char)
,	O
NULL	O
,	O
0	int
,	O
initial_args	int
)	O
;	O
}	O
static	O
size_t	long
update_limit	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),bool,long)->(long)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
,	O
bool	bool
success	bool
,	O
size_t	long
limit	long
)	O
{	O
if	O
(	O
success	bool
)	O
{	O
if	O
(	O
limit	long
>	O
state	*(int)
->	O
largest_successful_arg_count	long
)	O
state	*(int)
->	O
largest_successful_arg_count	long
=	O
limit	long
;	O
}	O
else	O
{	O
if	O
(	O
limit	long
<	O
state	*(int)
->	O
smallest_failed_arg_count	long
||	O
(	O
0	int
==	O
state	*(int)
->	O
smallest_failed_arg_count	long
)	O
)	O
state	*(int)
->	O
smallest_failed_arg_count	long
=	O
limit	long
;	O
}	O
if	O
(	O
0	int
==	O
(	O
state	*(int)
->	O
largest_successful_arg_count	long
)	O
||	O
(	O
state	*(int)
->	O
smallest_failed_arg_count	long
<=	O
state	*(int)
->	O
largest_successful_arg_count	long
)	O
)	O
{	O
if	O
(	O
success	bool
)	O
{	O
if	O
(	O
limit	long
<	O
SIZE_MAX	O
)	O
++	O
limit	long
;	O
}	O
else	O
{	O
limit	long
/=	O
2	int
;	O
}	O
}	O
else	O
{	O
const	O
size_t	long
shift	long
=	O
(	O
state	*(int)
->	O
smallest_failed_arg_count	long
-	O
state	*(int)
->	O
largest_successful_arg_count	long
)	O
/	O
2	int
;	O
if	O
(	O
success	bool
)	O
{	O
if	O
(	O
shift	long
)	O
limit	long
+=	O
shift	long
;	O
else	O
++	O
limit	long
;	O
}	O
else	O
{	O
if	O
(	O
shift	long
)	O
limit	long
-=	O
shift	long
;	O
else	O
--	O
limit	long
;	O
}	O
}	O
if	O
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
&&	O
(	O
limit	long
<=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
+	O
1u	int
)	O
)	O
limit	long
=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
+	O
1u	int
;	O
if	O
(	O
0	int
==	O
limit	long
)	O
limit	long
=	O
1u	int
;	O
return	O
limit	long
;	O
}	O
static	O
size_t	long
copy_args	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(*(char)),long,long)->(long)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
,	O
char	O
*	O
*	O
working_args	*(*(char))
,	O
size_t	long
limit	long
,	O
size_t	long
done	long
)	O
{	O
size_t	long
dst_pos	long
=	O
0	int
;	O
size_t	long
src_pos	long
=	O
0	int
;	O
while	O
(	O
src_pos	long
<	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
)	O
{	O
working_args	*(*(char))
[	O
dst_pos	long
++	O
]	O
=	O
state	*(int)
->	O
cmd_argv	*(*(char))
[	O
src_pos	long
++	O
]	O
;	O
}	O
src_pos	long
+=	O
done	long
;	O
while	O
(	O
src_pos	long
<	O
state	*(int)
->	O
cmd_argc	long
&&	O
dst_pos	long
<	O
limit	long
)	O
{	O
working_args	*(*(char))
[	O
dst_pos	long
++	O
]	O
=	O
state	*(int)
->	O
cmd_argv	*(*(char))
[	O
src_pos	long
++	O
]	O
;	O
}	O
assert	O
(	O
dst_pos	long
>=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
)	O
;	O
working_args	*(*(char))
[	O
dst_pos	long
]	O
=	O
NULL	O
;	O
return	O
dst_pos	long
;	O
}	O
void	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
)	O
{	O
char	O
*	O
*	O
working_args	*(*(char))
;	O
size_t	long
limit	long
,	O
done	long
;	O
bc_args_complete	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
)	O
;	O
assert	O
(	O
state	*(int)
->	O
cmd_argc	long
>	O
0	int
)	O
;	O
assert	O
(	O
state	*(int)
->	O
cmd_argv	*(*(char))
[	O
state	*(int)
->	O
cmd_argc	long
-	O
1	int
]	O
==	O
NULL	O
)	O
;	O
working_args	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
1	int
+	O
state	*(int)
->	O
cmd_argc	long
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
done	long
=	O
0	int
;	O
limit	long
=	O
state	*(int)
->	O
cmd_argc	long
;	O
do	O
{	O
const	O
size_t	long
dst_pos	long
=	O
copy_args	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(*(char)),long,long)->(long)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
,	O
working_args	*(*(char))
,	O
limit	long
,	O
done	long
)	O
;	O
if	O
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
exec_callback	*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int))
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
->	O
usercontext	*(void)
,	O
dst_pos	long
,	O
working_args	*(*(char))
)	O
)	O
{	O
limit	long
=	O
update_limit	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),bool,long)->(long)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
,	O
true	int
,	O
limit	long
)	O
;	O
done	long
+=	O
(	O
dst_pos	long
-	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
limit	long
<=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
+	O
1	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"can't call exec() due to argument size restrictions"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
limit	long
=	O
update_limit	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),bool,long)->(long)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
,	O
false	int
,	O
limit	long
)	O
;	O
}	O
}	O
}	O
while	O
(	O
(	O
done	long
+	O
1	int
)	O
<	O
(	O
state	*(int)
->	O
cmd_argc	long
-	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
)	O
)	O
;	O
free	(*(void))->(void)
(	O
working_args	*(*(char))
)	O
;	O
bc_clear_args	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
)	O
;	O
}	O
static	O
int	O
bc_argc_limit_reached	(int,*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(int)
(	O
int	O
initial_args	int
,	O
const	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
)	O
{	O
if	O
(	O
!	O
initial_args	int
&&	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
args_per_exec	long
&&	O
(	O
(	O
state	*(int)
->	O
cmd_argc	long
-	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
)	O
==	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
args_per_exec	long
)	O
)	O
return	O
1	int
;	O
return	O
state	*(int)
->	O
cmd_argc	long
==	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
max_arg_count	long
;	O
}	O
void	O
bc_push_arg	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(char),long,*(char),long,int)->(void)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
,	O
const	O
char	O
*	O
arg	*(char)
,	O
size_t	long
len	long
,	O
const	O
char	O
*	O
prefix	*(char)
,	O
size_t	long
pfxlen	long
,	O
int	O
initial_args	int
)	O
{	O
const	O
int	O
terminate	int
=	O
(	O
arg	*(char)
==	O
special_terminating_arg	*(char)
)	O
;	O
assert	O
(	O
arg	*(char)
!=	O
NULL	O
)	O
;	O
if	O
(	O
!	O
initial_args	int
)	O
{	O
state	*(int)
->	O
todo	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
terminate	int
)	O
{	O
if	O
(	O
state	*(int)
->	O
cmd_argv_chars	long
+	O
len	long
+	O
pfxlen	long
>	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
)	O
{	O
if	O
(	O
initial_args	int
||	O
state	*(int)
->	O
cmd_argc	long
==	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"cannot fit single argument within argument list size limit"	*(char)
)	O
)	O
;	O
if	O
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
replace_pat	*(char)
||	O
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
exit_if_size_exceeded	int
&&	O
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
lines_per_exec	long
||	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
args_per_exec	long
)	O
)	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"argument list too long"	*(char)
)	O
)	O
;	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
)	O
;	O
}	O
if	O
(	O
bc_argc_limit_reached	(int,*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(int)
(	O
initial_args	int
,	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
)	O
)	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
)	O
;	O
}	O
if	O
(	O
state	*(int)
->	O
cmd_argc	long
>=	O
state	*(int)
->	O
cmd_argv_alloc	long
)	O
{	O
if	O
(	O
!	O
state	*(int)
->	O
cmd_argv	*(*(char))
)	O
{	O
state	*(int)
->	O
cmd_argv_alloc	long
=	O
64	int
;	O
state	*(int)
->	O
cmd_argv	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
state	*(int)
->	O
cmd_argv_alloc	long
)	O
;	O
}	O
else	O
{	O
state	*(int)
->	O
cmd_argv_alloc	long
*=	O
2	int
;	O
state	*(int)
->	O
cmd_argv	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
state	*(int)
->	O
cmd_argv	*(*(char))
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
state	*(int)
->	O
cmd_argv_alloc	long
)	O
;	O
}	O
}	O
if	O
(	O
terminate	int
)	O
state	*(int)
->	O
cmd_argv	*(*(char))
[	O
state	*(int)
->	O
cmd_argc	long
++	O
]	O
=	O
NULL	O
;	O
else	O
{	O
state	*(int)
->	O
cmd_argv	*(*(char))
[	O
state	*(int)
->	O
cmd_argc	long
++	O
]	O
=	O
state	*(int)
->	O
argbuf	*(char)
+	O
state	*(int)
->	O
cmd_argv_chars	long
;	O
if	O
(	O
prefix	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
state	*(int)
->	O
argbuf	*(char)
+	O
state	*(int)
->	O
cmd_argv_chars	long
,	O
prefix	*(char)
)	O
;	O
state	*(int)
->	O
cmd_argv_chars	long
+=	O
pfxlen	long
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
state	*(int)
->	O
argbuf	*(char)
+	O
state	*(int)
->	O
cmd_argv_chars	long
,	O
arg	*(char)
)	O
;	O
state	*(int)
->	O
cmd_argv_chars	long
+=	O
len	long
;	O
if	O
(	O
bc_argc_limit_reached	(int,*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(int)
(	O
initial_args	int
,	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
)	O
)	O
{	O
bc_do_exec	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
state	*(int)
)	O
;	O
}	O
}	O
if	O
(	O
initial_args	int
)	O
{	O
state	*(int)
->	O
cmd_initial_argv_chars	long
=	O
state	*(int)
->	O
cmd_argv_chars	long
;	O
}	O
}	O
size_t	long
bc_get_arg_max	()->(long)
(	O
void	O
)	O
{	O
long	O
val	int
;	O
assert	O
(	O
(	O
~	O
(	O
size_t	long
)	O
0	int
)	O
>=	O
LONG_MAX	O
)	O
;	O
val	int
=	O
sysconf	(int)->(long)
(	O
_SC_ARG_MAX	int
)	O
;	O
if	O
(	O
val	int
>	O
0	int
)	O
return	O
val	int
;	O
return	O
LONG_MAX	O
;	O
}	O
static	O
int	O
cb_exec_noop	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
void	O
*	O
usercontext	*(void)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
(	O
void	O
)	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
;	O
(	O
void	O
)	O
usercontext	*(void)
;	O
(	O
void	O
)	O
argc	int
;	O
(	O
void	O
)	O
argv	*(*(char))
;	O
return	O
0	int
;	O
}	O
size_t	long
bc_size_of_environment	()->(long)
(	O
void	O
)	O
{	O
size_t	long
len	long
=	O
0u	int
;	O
char	O
*	O
*	O
envp	*(*(char))
=	O
environ	*(*(char))
;	O
while	O
(	O
*	O
envp	*(*(char))
)	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
*	O
envp	*(*(char))
++	O
)	O
+	O
1	int
;	O
return	O
len	long
;	O
}	O
enum	O
BC_INIT_STATUS	enum(int,int,int)
bc_init_controlinfo	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),long)->(enum(int,int,int))
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
size_t	long
headroom	long
)	O
{	O
size_t	long
size_of_environment	long
=	O
bc_size_of_environment	()->(long)
(	O
)	O
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_min	long
=	O
_POSIX_ARG_MAX	int
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
=	O
bc_get_arg_max	()->(long)
(	O
)	O
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
exit_if_size_exceeded	int
=	O
0	int
;	O
if	O
(	O
size_of_environment	long
>	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
)	O
{	O
return	O
BC_INIT_ENV_TOO_BIG	int
;	O
}	O
else	O
if	O
(	O
(	O
headroom	long
+	O
size_of_environment	long
)	O
>=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
)	O
{	O
return	O
BC_INIT_CANNOT_ACCOMODATE_HEADROOM	int
;	O
}	O
else	O
{	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
-=	O
size_of_environment	long
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
-=	O
headroom	long
;	O
}	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
max_arg_count	long
=	O
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
/	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
-	O
2u	int
;	O
assert	O
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
max_arg_count	long
>	O
0	int
)	O
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
rplen	long
=	O
0u	int
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
replace_pat	*(char)
=	O
NULL	O
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
=	O
0	int
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
exec_callback	*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int))
=	O
cb_exec_noop	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
lines_per_exec	long
=	O
0	int
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
args_per_exec	long
=	O
0	int
;	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
;	O
return	O
BC_INIT_OK	int
;	O
}	O
void	O
bc_use_sensible_arg_max	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)))->(void)
(	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
)	O
{	O
enum	O
{	O
arg_size	int
=	O
(	O
128u	int
*	O
1024u	int
)	O
}	O
;	O
if	O
(	O
arg_size	int
>	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
)	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_max	long
;	O
else	O
if	O
(	O
arg_size	int
<	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_min	long
)	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
posix_arg_size_min	long
;	O
else	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
=	O
arg_size	int
;	O
}	O
void	O
bc_init_state	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)),*(void))->(void)
(	O
const	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
,	O
void	O
*	O
context	*(void)
)	O
{	O
state	*(int)
->	O
cmd_argc	long
=	O
0	int
;	O
state	*(int)
->	O
cmd_argv_chars	long
=	O
0	int
;	O
state	*(int)
->	O
cmd_argv	*(*(char))
=	O
NULL	O
;	O
state	*(int)
->	O
cmd_argv_alloc	long
=	O
0	int
;	O
state	*(int)
->	O
largest_successful_arg_count	long
=	O
0	int
;	O
state	*(int)
->	O
smallest_failed_arg_count	long
=	O
0	int
;	O
assert	O
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
<=	O
(	O
LONG_MAX	O
-	O
2048L	int
)	O
)	O
;	O
state	*(int)
->	O
argbuf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
arg_max	long
+	O
1u	int
)	O
;	O
state	*(int)
->	O
cmd_argv_chars	long
=	O
state	*(int)
->	O
cmd_initial_argv_chars	long
=	O
0	int
;	O
state	*(int)
->	O
todo	int
=	O
0	int
;	O
state	*(int)
->	O
dir_fd	int
=	O
-	O
1	int
;	O
state	*(int)
->	O
usercontext	*(void)
=	O
context	*(void)
;	O
}	O
void	O
bc_clear_args	(*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)))->(void)
(	O
const	O
struct	O
buildcmd_control	struct(int,long,long,long,long,long,*(char),long,*((*(struct(int,long,long,long,long,long,*(char),long,*((*`,*`,int,*`)->(int)),long,long)),*(void),int,*(*(char)))->(int)),long,long)
*	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
,	O
struct	O
buildcmd_state	struct(long,*(*(char)),long,*(char),long,long,*(void),int,int,long,long)
*	O
state	*(int)
)	O
{	O
state	*(int)
->	O
cmd_argc	long
=	O
ctl	*(struct(int,long,long,long,long,long,*(char),long,*((*(struct`),*(void),int,*(*`))->(int)),long,long))
->	O
initial_argc	long
;	O
state	*(int)
->	O
cmd_argv_chars	long
=	O
state	*(int)
->	O
cmd_initial_argv_chars	long
;	O
state	*(int)
->	O
todo	int
=	O
0	int
;	O
state	*(int)
->	O
dir_fd	int
=	O
-	O
1	int
;	O
}	O
static	O
int	O
exceeds	(*(char),long)->(int)
(	O
const	O
char	O
*	O
env_var_name	*(char)
,	O
size_t	long
quantity	long
)	O
{	O
const	O
char	O
*	O
val	int
=	O
getenv	(*(char))->(*(char))
(	O
env_var_name	*(char)
)	O
;	O
if	O
(	O
val	int
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
unsigned	O
long	O
limit	long
;	O
if	O
(	O
xstrtoul	(*(char),*(*(char)),int,*(long),*(char))->(enum(int,int,int,int,int))
(	O
val	int
,	O
&	O
tmp	*(char)
,	O
10	int
,	O
&	O
limit	long
,	O
NULL	O
)	O
==	O
LONGINT_OK	int
)	O
{	O
if	O
(	O
quantity	long
>	O
limit	long
)	O
return	O
1	int
;	O
}	O
else	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Environment variable %s is not set to a "	*(char)
"valid decimal number"	*(char)
)	O
,	O
env_var_name	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
bool	bool
bc_args_exceed_testing_limit	(*(*(char)))->(bool)
(	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
size_t	long
chars	long
,	O
args	long
;	O
for	O
(	O
chars	long
=	O
args	long
=	O
0	int
;	O
*	O
argv	*(*(char))
;	O
++	O
argv	*(*(char))
)	O
{	O
++	O
args	long
;	O
chars	long
+=	O
strlen	(*(char))->(long)
(	O
*	O
argv	*(*(char))
)	O
;	O
}	O
return	O
(	O
exceeds	(*(char),long)->(int)
(	O
"__GNU_FINDUTILS_EXEC_ARG_COUNT_LIMIT"	*(char)
,	O
args	long
)	O
||	O
exceeds	(*(char),long)->(int)
(	O
"__GNU_FINDUTILS_EXEC_ARG_LENGTH_LIMIT"	*(char)
,	O
chars	long
)	O
)	O
;	O
}	O
