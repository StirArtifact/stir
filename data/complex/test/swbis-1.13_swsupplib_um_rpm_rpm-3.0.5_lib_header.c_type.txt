static	O
unsigned	O
char	O
header_magic	array(char)
[	O
4	int
]	O
=	O
{	O
0x8e	int
,	O
0xad	int
,	O
0xe8	int
,	O
0x01	int
}	O
;	O
static	O
int	O
typeSizes	array(int)
[	O
]	O
=	O
{	O
-	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
4	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
struct	O
headerToken	struct(*(struct),int,int,int,int)
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
index	(*(char),int)->(*(char))
;	O
int	O
indexUsed	int
;	O
int	O
indexAlloced	int
;	O
int	O
sorted	int
;	O
int	O
usageCount	int
;	O
}	O
;	O
struct	O
entryInfo	struct(int,int,int,int)
{	O
int_32	int
tag	int
;	O
int_32	int
type	enum(int,int,int,int)
;	O
int_32	int
offset	long
;	O
int_32	int
count	long
;	O
}	O
;	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
{	O
struct	O
entryInfo	struct(int,int,int,int)
info	struct(int,int,int,int)
;	O
void	O
*	O
data	*(void)
;	O
int	O
length	int
;	O
}	O
;	O
struct	O
sprintfTag	struct(*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int)
{	O
headerTagTagFunction	*((*(struct),*(int),*(*(void)),*(int),*(int))->(int))
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
;	O
int	O
extNum	int
;	O
int_32	int
tag	int
;	O
int	O
justOne	int
;	O
int	O
arrayCount	int
;	O
char	O
*	O
format	*(char)
;	O
char	O
*	O
type	enum(int,int,int,int)
;	O
int	O
pad	int
;	O
}	O
;	O
struct	O
extensionCache	struct(int,int,int,int,*(void))
{	O
int_32	int
type	enum(int,int,int,int)
;	O
int_32	int
count	long
;	O
int	O
avail	int
;	O
int	O
freeit	int
;	O
const	O
void	O
*	O
data	*(void)
;	O
}	O
;	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
{	O
enum	O
{	O
PTOK_NONE	int
=	O
0	int
,	O
PTOK_TAG	int
,	O
PTOK_ARRAY	int
,	O
PTOK_STRING	int
,	O
PTOK_COND	int
}	O
type	enum(int,int,int,int)
;	O
union	O
{	O
struct	O
{	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
format	*(char)
;	O
int	O
numTokens	int
;	O
}	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
;	O
struct	O
sprintfTag	struct(*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int)
tag	int
;	O
struct	O
{	O
char	O
*	O
string	*(char)
;	O
int	O
len	int
;	O
}	O
string	*(char)
;	O
struct	O
{	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
ifFormat	*(struct(enum(int,int,int,int,int)))
;	O
int	O
numIfTokens	int
;	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
elseFormat	*(struct(enum(int,int,int,int,int)))
;	O
int	O
numElseTokens	int
;	O
struct	O
sprintfTag	struct(*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int)
tag	int
;	O
}	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
;	O
}	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
;	O
}	O
;	O
static	O
int	O
probe_headers	int
=	O
0	int
;	O
static	O
void	O
headerProbeAddr	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(char),*(void),*(char))->(void)
(	O
Header	*(struct)
h	*(struct)
,	O
const	O
char	O
*	O
msg	*(char)
,	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
imsg	*(char)
)	O
{	O
const	O
char	O
*	O
mchkstr	*(char)
=	O
NULL	O
;	O
switch	O
(	O
mprobe	(*(void))->(enum(int,int,int,int,int))
(	O
p	*(void)
)	O
)	O
{	O
case	O
MCHECK_DISABLED	int
:	O
case	O
MCHECK_OK	int
:	O
return	O
;	O
break	O
;	O
case	O
MCHECK_HEAD	int
:	O
mchkstr	*(char)
=	O
"HEAD"	*(char)
;	O
break	O
;	O
case	O
MCHECK_TAIL	int
:	O
mchkstr	*(char)
=	O
"TAIL"	*(char)
;	O
break	O
;	O
case	O
MCHECK_FREE	int
:	O
mchkstr	*(char)
=	O
"FREE"	*(char)
;	O
break	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"*** MCHECK_%s h %p"	*(char)
,	O
mchkstr	*(char)
,	O
h	*(struct)
)	O
;	O
if	O
(	O
imsg	*(char)
&&	O
p	*(void)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s %p"	*(char)
,	O
imsg	*(char)
,	O
p	*(void)
)	O
;	O
if	O
(	O
msg	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s"	*(char)
,	O
msg	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
headerProbe	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(char))->(void)
(	O
Header	*(struct)
h	*(struct)
,	O
const	O
char	O
*	O
msg	*(char)
)	O
{	O
char	O
imsg	*(char)
[	O
256	int
]	O
;	O
int	O
i	int
;	O
headerProbeAddr	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(char),*(void),*(char))->(void)
(	O
h	*(struct)
,	O
msg	*(char)
,	O
h	*(struct)
,	O
"header"	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
imsg	*(char)
,	O
"index (used %d)"	*(char)
,	O
h	*(struct)
->	O
indexUsed	int
)	O
;	O
headerProbeAddr	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(char),*(void),*(char))->(void)
(	O
h	*(struct)
,	O
msg	*(char)
,	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
,	O
imsg	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	*(struct)
->	O
indexUsed	int
;	O
i	int
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
imsg	*(char)
,	O
"index[%d:%d].data"	*(char)
,	O
i	int
,	O
h	*(struct)
->	O
indexUsed	int
)	O
;	O
headerProbeAddr	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(char),*(void),*(char))->(void)
(	O
h	*(struct)
,	O
msg	*(char)
,	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
[	O
i	int
]	O
.	O
data	*(void)
,	O
imsg	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
copyEntry	(*(struct(struct(int,int,int,int),*(void),int)),*(int),*(*(void)),*(int),int)->(void)
(	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
,	O
int_32	int
*	O
type	enum(int,int,int,int)
,	O
void	O
*	O
*	O
p	*(void)
,	O
int_32	int
*	O
c	int
,	O
int	O
minimizeMemory	int
)	O
{	O
int	O
i	int
,	O
tableSize	int
;	O
char	O
*	O
*	O
ptrEntry	*(*(char))
;	O
char	O
*	O
chptr	*(char)
;	O
if	O
(	O
type	enum(int,int,int,int)
)	O
*	O
type	enum(int,int,int,int)
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
return	O
;	O
switch	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_STRING_TYPE	int
:	O
if	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
==	O
1	int
)	O
{	O
*	O
p	*(void)
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
break	O
;	O
}	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
i	int
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
tableSize	int
=	O
i	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
;	O
if	O
(	O
minimizeMemory	int
)	O
{	O
ptrEntry	*(*(char))
=	O
*	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
tableSize	int
)	O
;	O
chptr	*(char)
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
}	O
else	O
{	O
ptrEntry	*(*(char))
=	O
*	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
tableSize	int
+	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
)	O
;	O
chptr	*(char)
=	O
(	O
(	O
char	O
*	O
)	O
*	O
p	*(void)
)	O
+	O
tableSize	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
chptr	*(char)
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
)	O
;	O
}	O
while	O
(	O
i	int
--	O
)	O
{	O
*	O
ptrEntry	*(*(char))
++	O
=	O
chptr	*(char)
;	O
chptr	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
chptr	*(char)
,	O
0	int
)	O
;	O
chptr	*(char)
++	O
;	O
}	O
break	O
;	O
default	O
:	O
*	O
p	*(void)
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
break	O
;	O
}	O
}	O
static	O
int	O
dataLength	(int,*(void),int,int)->(int)
(	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
p	*(void)
,	O
int_32	int
count	long
,	O
int	O
onDisk	int
)	O
{	O
int	O
thisLen	int
,	O
length	int
,	O
i	int
;	O
char	O
*	O
*	O
src	*(*(char))
,	O
*	O
chptr	*(char)
;	O
length	int
=	O
0	int
;	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_STRING_TYPE	int
:	O
if	O
(	O
count	long
==	O
1	int
)	O
{	O
length	int
=	O
strlen	(*(char))->(long)
(	O
p	*(void)
)	O
+	O
1	int
;	O
break	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"grabData() RPM_STRING_TYPE count must be 1.\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
i	int
=	O
count	long
;	O
length	int
=	O
0	int
;	O
if	O
(	O
onDisk	int
)	O
{	O
chptr	*(char)
=	O
(	O
char	O
*	O
)	O
p	*(void)
;	O
while	O
(	O
i	int
--	O
)	O
{	O
thisLen	int
=	O
strlen	(*(char))->(long)
(	O
chptr	*(char)
)	O
+	O
1	int
;	O
length	int
+=	O
thisLen	int
;	O
chptr	*(char)
+=	O
thisLen	int
;	O
}	O
}	O
else	O
{	O
src	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
p	*(void)
;	O
while	O
(	O
i	int
--	O
)	O
{	O
length	int
+=	O
strlen	(*(char))->(long)
(	O
*	O
src	*(*(char))
++	O
)	O
+	O
1	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
!=	O
-	O
1	int
)	O
length	int
=	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
*	O
count	long
;	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Data type %d not supported\n"	*(char)
)	O
,	O
(	O
int	O
)	O
type	enum(int,int,int,int)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
}	O
return	O
length	int
;	O
}	O
struct	O
headerIteratorS	struct(*(struct(*(struct(struct(int,int,int,int),*(void),int)),int,int,int,int)),int)
{	O
Header	*(struct)
h	*(struct)
;	O
int	O
next_index	int
;	O
}	O
;	O
HeaderIterator	*(struct)
headerInitIterator	(*(struct))->(*(struct))
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
HeaderIterator	*(struct)
hi	*(struct(*(struct(*(struct`),int,int,int,int)),int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
headerIteratorS	struct(*(struct(*(struct(struct(int,int,int,int),*(void),int)),int,int,int,int)),int)
)	O
)	O
;	O
headerSort	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
hi	*(struct(*(struct(*(struct`),int,int,int,int)),int))
->	O
h	*(struct)
=	O
headerLink	(*(struct))->(*(struct))
(	O
h	*(struct)
)	O
;	O
hi	*(struct(*(struct(*(struct`),int,int,int,int)),int))
->	O
next_index	int
=	O
0	int
;	O
return	O
hi	*(struct(*(struct(*(struct`),int,int,int,int)),int))
;	O
}	O
void	O
headerFreeIterator	(*(struct))->(void)
(	O
HeaderIterator	*(struct)
iter	*(struct)
)	O
{	O
headerFree	(*(struct))->(void)
(	O
iter	*(struct)
->	O
h	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
iter	*(struct)
)	O
;	O
}	O
int	O
headerNextIterator	(*(struct),*(int),*(int),*(*(void)),*(int))->(int)
(	O
HeaderIterator	*(struct)
iter	*(struct)
,	O
int_32	int
*	O
tag	int
,	O
int_32	int
*	O
type	enum(int,int,int,int)
,	O
void	O
*	O
*	O
p	*(void)
,	O
int_32	int
*	O
c	int
)	O
{	O
Header	*(struct)
h	*(struct)
=	O
iter	*(struct)
->	O
h	*(struct)
;	O
int	O
slot	int
=	O
iter	*(struct)
->	O
next_index	int
;	O
if	O
(	O
slot	int
==	O
h	*(struct)
->	O
indexUsed	int
)	O
{	O
return	O
0	int
;	O
}	O
iter	*(struct)
->	O
next_index	int
++	O
;	O
if	O
(	O
tag	int
)	O
{	O
*	O
tag	int
=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
[	O
slot	int
]	O
.	O
info	struct(int,int,int,int)
.	O
tag	int
;	O
}	O
copyEntry	(*(struct(struct(int,int,int,int),*(void),int)),*(int),*(*(void)),*(int),int)->(void)
(	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
+	O
slot	int
,	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
indexCmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
ap	*(void)
,	O
const	O
void	O
*	O
bp	*(void)
)	O
{	O
int_32	int
a	int
,	O
b	int
;	O
a	int
=	O
(	O
(	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
)	O
ap	*(void)
)	O
->	O
info	struct(int,int,int,int)
.	O
tag	int
;	O
b	int
=	O
(	O
(	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
)	O
bp	*(void)
)	O
->	O
info	struct(int,int,int,int)
.	O
tag	int
;	O
if	O
(	O
a	int
>	O
b	int
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
a	int
<	O
b	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
void	O
headerSort	(*(struct))->(void)
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
if	O
(	O
!	O
h	*(struct)
->	O
sorted	int
)	O
{	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
,	O
h	*(struct)
->	O
indexUsed	int
,	O
sizeof	O
(	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
)	O
,	O
indexCmp	(*(void),*(void))->(int)
)	O
;	O
h	*(struct)
->	O
sorted	int
=	O
1	int
;	O
}	O
}	O
Header	*(struct)
headerCopy	(*(struct))->(*(struct))
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
int_32	int
tag	int
,	O
type	enum(int,int,int,int)
,	O
count	long
;	O
void	O
*	O
ptr	*(void)
;	O
HeaderIterator	*(struct)
headerIter	*(struct(*(struct(*(struct`),int,int,int,int)),int))
;	O
Header	*(struct)
res	*(struct(*(struct(struct(int,int,int,int),*(void),int)),int,int,int,int))
=	O
headerNew	()->(*(struct))
(	O
)	O
;	O
headerIter	*(struct(*(struct(*(struct`),int,int,int,int)),int))
=	O
headerInitIterator	(*(struct))->(*(struct))
(	O
h	*(struct)
)	O
;	O
while	O
(	O
headerNextIterator	(*(struct),*(int),*(int),*(*(void)),*(int))->(int)
(	O
headerIter	*(struct(*(struct(*(struct`),int,int,int,int)),int))
,	O
&	O
tag	int
,	O
&	O
type	enum(int,int,int,int)
,	O
&	O
ptr	*(void)
,	O
&	O
count	long
)	O
)	O
{	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
res	*(struct(*(struct(struct(int,int,int,int),*(void),int)),int,int,int,int))
,	O
tag	int
,	O
type	enum(int,int,int,int)
,	O
ptr	*(void)
,	O
count	long
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
RPM_STRING_ARRAY_TYPE	int
||	O
type	enum(int,int,int,int)
==	O
RPM_I18NSTRING_TYPE	int
)	O
free	(*(void))->(void)
(	O
ptr	*(void)
)	O
;	O
}	O
res	*(struct(*(struct(struct(int,int,int,int),*(void),int)),int,int,int,int))
->	O
sorted	int
=	O
1	int
;	O
headerFreeIterator	(*(struct))->(void)
(	O
headerIter	*(struct(*(struct(*(struct`),int,int,int,int)),int))
)	O
;	O
return	O
res	*(struct(*(struct(struct(int,int,int,int),*(void),int)),int,int,int,int))
;	O
}	O
Header	*(struct)
headerLoad	(*(void))->(*(struct))
(	O
void	O
*	O
pv	*(void)
)	O
{	O
int_32	int
il	int
;	O
char	O
*	O
p	*(void)
=	O
pv	*(void)
;	O
const	O
char	O
*	O
dataStart	*(char)
;	O
struct	O
entryInfo	struct(int,int,int,int)
*	O
pe	*(struct(int,int,int,int))
;	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
struct	O
headerToken	struct(*(struct),int,int,int,int)
*	O
h	*(struct)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
headerToken	struct(*(struct),int,int,int,int)
)	O
)	O
;	O
const	O
char	O
*	O
src	*(*(char))
;	O
char	O
*	O
dst	*(char)
;	O
int	O
i	int
;	O
int	O
count	long
;	O
il	int
=	O
ntohl	(int)->(int)
(	O
*	O
(	O
(	O
int_32	int
*	O
)	O
p	*(void)
)	O
)	O
;	O
p	*(void)
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
p	*(void)
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
h	*(struct)
->	O
indexAlloced	int
=	O
il	int
;	O
h	*(struct)
->	O
indexUsed	int
=	O
il	int
;	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
)	O
*	O
il	int
)	O
;	O
h	*(struct)
->	O
usageCount	int
=	O
1	int
;	O
h	*(struct)
->	O
sorted	int
=	O
1	int
;	O
pe	*(struct(int,int,int,int))
=	O
(	O
struct	O
entryInfo	struct(int,int,int,int)
*	O
)	O
p	*(void)
;	O
dataStart	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
pe	*(struct(int,int,int,int))
+	O
h	*(struct)
->	O
indexUsed	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
;	O
i	int
<	O
h	*(struct)
->	O
indexUsed	int
;	O
i	int
++	O
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
++	O
,	O
pe	*(struct(int,int,int,int))
++	O
)	O
{	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
=	O
htonl	(int)->(int)
(	O
pe	*(struct(int,int,int,int))
->	O
type	enum(int,int,int,int)
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
tag	int
=	O
htonl	(int)->(int)
(	O
pe	*(struct(int,int,int,int))
->	O
tag	int
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
=	O
htonl	(int)->(int)
(	O
pe	*(struct(int,int,int,int))
->	O
count	long
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
offset	long
=	O
-	O
1	int
;	O
if	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
<	O
RPM_MIN_TYPE	int
||	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
>	O
RPM_MAX_TYPE	int
)	O
return	O
NULL	O
;	O
src	*(*(char))
=	O
dataStart	*(char)
+	O
htonl	(int)->(int)
(	O
pe	*(struct(int,int,int,int))
->	O
offset	long
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
=	O
dataLength	(int,*(void),int,int)->(int)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
,	O
src	*(*(char))
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
,	O
1	int
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
=	O
dst	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
)	O
;	O
switch	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_INT32_TYPE	int
:	O
count	long
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
while	O
(	O
count	long
--	O
)	O
{	O
*	O
(	O
(	O
int_32	int
*	O
)	O
dst	*(char)
)	O
=	O
htonl	(int)->(int)
(	O
*	O
(	O
(	O
int_32	int
*	O
)	O
src	*(*(char))
)	O
)	O
;	O
src	*(*(char))
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
dst	*(char)
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
}	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
count	long
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
while	O
(	O
count	long
--	O
)	O
{	O
*	O
(	O
(	O
int_16	short
*	O
)	O
dst	*(char)
)	O
=	O
htons	(short)->(short)
(	O
*	O
(	O
(	O
int_16	short
*	O
)	O
src	*(*(char))
)	O
)	O
;	O
src	*(*(char))
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
dst	*(char)
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
}	O
break	O
;	O
default	O
:	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dst	*(char)
,	O
src	*(*(char))
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
)	O
;	O
break	O
;	O
}	O
}	O
return	O
h	*(struct)
;	O
}	O
static	O
void	O
*	O
doHeaderUnload	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(int))->(*(void))
(	O
Header	*(struct)
h	*(struct)
,	O
int	O
*	O
lengthPtr	*(int)
)	O
{	O
int	O
i	int
;	O
int	O
type	enum(int,int,int,int)
,	O
diff	int
;	O
void	O
*	O
p	*(void)
;	O
int_32	int
*	O
pi	*(int)
;	O
struct	O
entryInfo	struct(int,int,int,int)
*	O
pe	*(struct(int,int,int,int))
;	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
char	O
*	O
chptr	*(char)
,	O
*	O
src	*(*(char))
,	O
*	O
dataStart	*(char)
;	O
int	O
count	long
;	O
headerSort	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
*	O
lengthPtr	*(int)
=	O
headerSizeof	(*(struct),int)->(int)
(	O
h	*(struct)
,	O
0	int
)	O
;	O
pi	*(int)
=	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
*	O
lengthPtr	*(int)
)	O
;	O
*	O
pi	*(int)
++	O
=	O
htonl	(int)->(int)
(	O
h	*(struct)
->	O
indexUsed	int
)	O
;	O
*	O
pi	*(int)
++	O
=	O
htonl	(int)->(int)
(	O
*	O
lengthPtr	*(int)
-	O
sizeof	O
(	O
int_32	int
)	O
-	O
sizeof	O
(	O
int_32	int
)	O
-	O
(	O
sizeof	O
(	O
struct	O
entryInfo	struct(int,int,int,int)
)	O
*	O
h	*(struct)
->	O
indexUsed	int
)	O
)	O
;	O
pe	*(struct(int,int,int,int))
=	O
(	O
struct	O
entryInfo	struct(int,int,int,int)
*	O
)	O
pi	*(int)
;	O
dataStart	*(char)
=	O
chptr	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
pe	*(struct(int,int,int,int))
+	O
h	*(struct)
->	O
indexUsed	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
;	O
i	int
<	O
h	*(struct)
->	O
indexUsed	int
;	O
i	int
++	O
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
++	O
,	O
pe	*(struct(int,int,int,int))
++	O
)	O
{	O
pe	*(struct(int,int,int,int))
->	O
type	enum(int,int,int,int)
=	O
htonl	(int)->(int)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
)	O
;	O
pe	*(struct(int,int,int,int))
->	O
tag	int
=	O
htonl	(int)->(int)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
tag	int
)	O
;	O
pe	*(struct(int,int,int,int))
->	O
count	long
=	O
htonl	(int)->(int)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
)	O
;	O
type	enum(int,int,int,int)
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
;	O
if	O
(	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
>	O
1	int
)	O
{	O
diff	int
=	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
-	O
(	O
(	O
chptr	*(char)
-	O
dataStart	*(char)
)	O
%	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
)	O
;	O
if	O
(	O
diff	int
!=	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
chptr	*(char)
,	O
0	int
,	O
diff	int
)	O
;	O
chptr	*(char)
+=	O
diff	int
;	O
}	O
}	O
pe	*(struct(int,int,int,int))
->	O
offset	long
=	O
htonl	(int)->(int)
(	O
chptr	*(char)
-	O
dataStart	*(char)
)	O
;	O
switch	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_INT32_TYPE	int
:	O
count	long
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
src	*(*(char))
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
while	O
(	O
count	long
--	O
)	O
{	O
*	O
(	O
(	O
int_32	int
*	O
)	O
chptr	*(char)
)	O
=	O
htonl	(int)->(int)
(	O
*	O
(	O
(	O
int_32	int
*	O
)	O
src	*(*(char))
)	O
)	O
;	O
chptr	*(char)
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
src	*(*(char))
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
}	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
count	long
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
src	*(*(char))
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
while	O
(	O
count	long
--	O
)	O
{	O
*	O
(	O
(	O
int_16	short
*	O
)	O
chptr	*(char)
)	O
=	O
htons	(short)->(short)
(	O
*	O
(	O
(	O
int_16	short
*	O
)	O
src	*(*(char))
)	O
)	O
;	O
chptr	*(char)
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
src	*(*(char))
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
}	O
break	O
;	O
default	O
:	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
chptr	*(char)
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
)	O
;	O
chptr	*(char)
+=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
;	O
break	O
;	O
}	O
}	O
return	O
p	*(void)
;	O
}	O
void	O
*	O
headerUnload	(*(struct))->(*(void))
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
int	O
length	int
;	O
return	O
doHeaderUnload	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(int))->(*(void))
(	O
h	*(struct)
,	O
&	O
length	int
)	O
;	O
}	O
int	O
headerWrite	(*(struct),*(struct),int)->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
Header	*(struct)
h	*(struct)
,	O
int	O
magicp	int
)	O
{	O
void	O
*	O
p	*(void)
;	O
int	O
length	int
;	O
int_32	int
l	int
;	O
ssize_t	long
nb	long
;	O
p	*(void)
=	O
doHeaderUnload	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(int))->(*(void))
(	O
h	*(struct)
,	O
&	O
length	int
)	O
;	O
if	O
(	O
magicp	int
)	O
{	O
nb	long
=	O
Fwrite	(*(void),long,long,*(struct))->(long)
(	O
header_magic	array(char)
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
header_magic	array(char)
)	O
,	O
fd	*(struct)
)	O
;	O
if	O
(	O
nb	long
!=	O
sizeof	O
(	O
header_magic	array(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
l	int
=	O
htonl	(int)->(int)
(	O
0	int
)	O
;	O
nb	long
=	O
Fwrite	(*(void),long,long,*(struct))->(long)
(	O
&	O
l	int
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
l	int
)	O
,	O
fd	*(struct)
)	O
;	O
if	O
(	O
nb	long
!=	O
sizeof	O
(	O
l	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
nb	long
=	O
Fwrite	(*(void),long,long,*(struct))->(long)
(	O
p	*(void)
,	O
sizeof	O
(	O
char	O
)	O
,	O
length	int
,	O
fd	*(struct)
)	O
;	O
if	O
(	O
nb	long
!=	O
length	int
)	O
{	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
Header	*(struct)
headerRead	(*(struct),int)->(*(struct))
(	O
FD_t	*(struct)
fd	*(struct)
,	O
int	O
magicp	int
)	O
{	O
int_32	int
block	array(int)
[	O
40	int
]	O
;	O
int_32	int
reserved	int
;	O
int_32	int
*	O
p	*(void)
;	O
int_32	int
il	int
,	O
dl	int
;	O
int_32	int
magic	int
;	O
Header	*(struct)
h	*(struct)
;	O
void	O
*	O
dataBlock	*(void)
;	O
int	O
totalSize	int
;	O
int	O
i	int
;	O
i	int
=	O
2	int
;	O
if	O
(	O
magicp	int
==	O
HEADER_MAGIC_YES	int
)	O
i	int
+=	O
2	int
;	O
if	O
(	O
timedRead	(*(struct),*(void),int)->(int)
(	O
fd	*(struct)
,	O
(	O
char	O
*	O
)	O
block	array(int)
,	O
i	int
*	O
sizeof	O
(	O
*	O
block	array(int)
)	O
)	O
!=	O
(	O
i	int
*	O
sizeof	O
(	O
*	O
block	array(int)
)	O
)	O
)	O
return	O
NULL	O
;	O
i	int
=	O
0	int
;	O
if	O
(	O
magicp	int
==	O
HEADER_MAGIC_YES	int
)	O
{	O
magic	int
=	O
block	array(int)
[	O
i	int
++	O
]	O
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
&	O
magic	int
,	O
header_magic	array(char)
,	O
sizeof	O
(	O
magic	int
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
reserved	int
=	O
block	array(int)
[	O
i	int
++	O
]	O
;	O
}	O
il	int
=	O
ntohl	(int)->(int)
(	O
block	array(int)
[	O
i	int
++	O
]	O
)	O
;	O
dl	int
=	O
ntohl	(int)->(int)
(	O
block	array(int)
[	O
i	int
++	O
]	O
)	O
;	O
totalSize	int
=	O
sizeof	O
(	O
int_32	int
)	O
+	O
sizeof	O
(	O
int_32	int
)	O
+	O
(	O
il	int
*	O
sizeof	O
(	O
struct	O
entryInfo	struct(int,int,int,int)
)	O
)	O
+	O
dl	int
;	O
if	O
(	O
totalSize	int
>	O
(	O
32	int
*	O
1024	int
*	O
1024	int
)	O
)	O
return	O
NULL	O
;	O
dataBlock	*(void)
=	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
totalSize	int
)	O
;	O
*	O
p	*(void)
++	O
=	O
htonl	(int)->(int)
(	O
il	int
)	O
;	O
*	O
p	*(void)
++	O
=	O
htonl	(int)->(int)
(	O
dl	int
)	O
;	O
totalSize	int
-=	O
sizeof	O
(	O
int_32	int
)	O
+	O
sizeof	O
(	O
int_32	int
)	O
;	O
if	O
(	O
timedRead	(*(struct),*(void),int)->(int)
(	O
fd	*(struct)
,	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
totalSize	int
)	O
!=	O
totalSize	int
)	O
return	O
NULL	O
;	O
h	*(struct)
=	O
headerLoad	(*(void))->(*(struct))
(	O
dataBlock	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
dataBlock	*(void)
)	O
;	O
return	O
h	*(struct)
;	O
}	O
void	O
headerDump	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,*(struct(*(char),int)))->(void)
(	O
Header	*(struct)
h	*(struct)
,	O
FILE	struct
*	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
flags	int
,	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tags	*(struct(*(char),int))
)	O
{	O
int	O
i	int
;	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
p	*(void)
;	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tage	*(struct(*(char),int))
;	O
const	O
char	O
*	O
tag	int
;	O
char	O
*	O
type	enum(int,int,int,int)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Entry count: %d\n"	*(char)
,	O
h	*(struct)
->	O
indexUsed	int
)	O
;	O
p	*(void)
=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n             CT  TAG                  TYPE         "	*(char)
"      OFSET      COUNT\n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	*(struct)
->	O
indexUsed	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
p	*(void)
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_NULL_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"NULL_TYPE"	*(char)
;	O
break	O
;	O
case	O
RPM_CHAR_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"CHAR_TYPE"	*(char)
;	O
break	O
;	O
case	O
RPM_BIN_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"BIN_TYPE"	*(char)
;	O
break	O
;	O
case	O
RPM_INT8_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"INT8_TYPE"	*(char)
;	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"INT16_TYPE"	*(char)
;	O
break	O
;	O
case	O
RPM_INT32_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"INT32_TYPE"	*(char)
;	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"STRING_TYPE"	*(char)
;	O
break	O
;	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"STRING_ARRAY_TYPE"	*(char)
;	O
break	O
;	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
type	enum(int,int,int,int)
=	O
"I18N_STRING_TYPE"	*(char)
;	O
break	O
;	O
default	O
:	O
type	enum(int,int,int,int)
=	O
"(unknown)"	*(char)
;	O
break	O
;	O
}	O
tage	*(struct(*(char),int))
=	O
tags	*(struct(*(char),int))
;	O
while	O
(	O
tage	*(struct(*(char),int))
->	O
name	*(char)
&&	O
tage	*(struct(*(char),int))
->	O
val	array(int)
!=	O
p	*(void)
->	O
info	struct(int,int,int,int)
.	O
tag	int
)	O
tage	*(struct(*(char),int))
++	O
;	O
if	O
(	O
!	O
tage	*(struct(*(char),int))
->	O
name	*(char)
)	O
tag	int
=	O
"(unknown)"	*(char)
;	O
else	O
tag	int
=	O
tage	*(struct(*(char),int))
->	O
name	*(char)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Entry      : %.3d (%d)%-14s %-18s 0x%.8x %.8d\n"	*(char)
,	O
i	int
,	O
p	*(void)
->	O
info	struct(int,int,int,int)
.	O
tag	int
,	O
tag	int
,	O
type	enum(int,int,int,int)
,	O
(	O
unsigned	O
)	O
p	*(void)
->	O
info	struct(int,int,int,int)
.	O
offset	long
,	O
(	O
int	O
)	O
p	*(void)
->	O
info	struct(int,int,int,int)
.	O
count	long
)	O
;	O
if	O
(	O
flags	int
&	O
HEADER_DUMP_INLINE	int
)	O
{	O
char	O
*	O
dp	*(char)
=	O
p	*(void)
->	O
data	*(void)
;	O
int	O
c	int
=	O
p	*(void)
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
int	O
ct	int
=	O
0	int
;	O
switch	O
(	O
p	*(void)
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_INT32_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"       Data: %.3d 0x%08x (%d)\n"	*(char)
,	O
ct	int
++	O
,	O
(	O
unsigned	O
)	O
*	O
(	O
(	O
int_32	int
*	O
)	O
dp	*(char)
)	O
,	O
(	O
int	O
)	O
*	O
(	O
(	O
int_32	int
*	O
)	O
dp	*(char)
)	O
)	O
;	O
dp	*(char)
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
}	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"       Data: %.3d 0x%04x (%d)\n"	*(char)
,	O
ct	int
++	O
,	O
(	O
unsigned	O
)	O
(	O
*	O
(	O
(	O
int_16	short
*	O
)	O
dp	*(char)
)	O
&	O
0xffff	int
)	O
,	O
(	O
int	O
)	O
*	O
(	O
(	O
int_16	short
*	O
)	O
dp	*(char)
)	O
)	O
;	O
dp	*(char)
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
}	O
break	O
;	O
case	O
RPM_INT8_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"       Data: %.3d 0x%02x (%d)\n"	*(char)
,	O
ct	int
++	O
,	O
(	O
unsigned	O
)	O
(	O
*	O
(	O
(	O
int_8	char
*	O
)	O
dp	*(char)
)	O
&	O
0xff	int
)	O
,	O
(	O
int	O
)	O
*	O
(	O
(	O
int_8	char
*	O
)	O
dp	*(char)
)	O
)	O
;	O
dp	*(char)
+=	O
sizeof	O
(	O
int_8	char
)	O
;	O
}	O
break	O
;	O
case	O
RPM_BIN_TYPE	int
:	O
while	O
(	O
c	int
>	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"       Data: %.3d "	*(char)
,	O
ct	int
)	O
;	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%02x "	*(char)
,	O
(	O
unsigned	O
)	O
(	O
*	O
(	O
int_8	char
*	O
)	O
dp	*(char)
&	O
0xff	int
)	O
)	O
;	O
ct	int
++	O
;	O
dp	*(char)
+=	O
sizeof	O
(	O
int_8	char
)	O
;	O
if	O
(	O
!	O
(	O
ct	int
%	O
8	int
)	O
)	O
{	O
break	O
;	O
}	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
RPM_CHAR_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
char	O
ch	char
=	O
(	O
char	O
)	O
*	O
(	O
(	O
char	O
*	O
)	O
dp	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"       Data: %.3d 0x%2x %c (%d)\n"	*(char)
,	O
ct	int
++	O
,	O
(	O
unsigned	O
)	O
(	O
ch	char
&	O
0xff	int
)	O
,	O
(	O
isprint	(int)->(int)
(	O
ch	char
)	O
?	O
ch	char
:	O
' '	O
)	O
,	O
(	O
int	O
)	O
*	O
(	O
(	O
char	O
*	O
)	O
dp	*(char)
)	O
)	O
;	O
dp	*(char)
+=	O
sizeof	O
(	O
char	O
)	O
;	O
}	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"       Data: %.3d %s\n"	*(char)
,	O
ct	int
++	O
,	O
(	O
char	O
*	O
)	O
dp	*(char)
)	O
;	O
dp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
dp	*(char)
,	O
0	int
)	O
;	O
dp	*(char)
++	O
;	O
}	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Data type %d not supported\n"	*(char)
)	O
,	O
(	O
int	O
)	O
p	*(void)
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
p	*(void)
++	O
;	O
}	O
}	O
static	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum(int,int,int,int)
)	O
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
,	O
*	O
entry2	*(struct(struct(int,int,int,int),*(void),int))
,	O
*	O
last	*(struct(struct(int,int,int,int),*(void),int))
;	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
key	struct(struct(int,int,int,int),*(void),int)
;	O
if	O
(	O
!	O
h	*(struct)
->	O
sorted	int
)	O
headerSort	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
key	struct(struct(int,int,int,int),*(void),int)
.	O
info	struct(int,int,int,int)
.	O
tag	int
=	O
tag	int
;	O
entry2	*(struct(struct(int,int,int,int),*(void),int))
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
bsearch	(*(void),*(void),long,long,*((*(void),*(void))->(int)))->(*(void))
(	O
&	O
key	struct(struct(int,int,int,int),*(void),int)
,	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
,	O
h	*(struct)
->	O
indexUsed	int
,	O
sizeof	O
(	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
)	O
,	O
indexCmp	(*(void),*(void))->(int)
)	O
;	O
if	O
(	O
!	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
return	O
NULL	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
RPM_NULL_TYPE	int
)	O
return	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
while	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
tag	int
==	O
tag	int
&&	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
!=	O
type	enum(int,int,int,int)
&&	O
entry	*(struct(struct(int,int,int,int),*(void),int))
>	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
)	O
entry	*(struct(struct(int,int,int,int),*(void),int))
--	O
;	O
if	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
tag	int
==	O
tag	int
&&	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
==	O
type	enum(int,int,int,int)
)	O
return	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
last	*(struct(struct(int,int,int,int),*(void),int))
=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
+	O
h	*(struct)
->	O
indexUsed	int
;	O
while	O
(	O
entry2	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
tag	int
==	O
tag	int
&&	O
entry2	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
!=	O
type	enum(int,int,int,int)
&&	O
entry2	*(struct(struct(int,int,int,int),*(void),int))
<	O
last	*(struct(struct(int,int,int,int),*(void),int))
)	O
entry2	*(struct(struct(int,int,int,int),*(void),int))
++	O
;	O
if	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
tag	int
==	O
tag	int
&&	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
==	O
type	enum(int,int,int,int)
)	O
return	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
return	O
NULL	O
;	O
}	O
int	O
headerIsEntry	(*(struct),int)->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
)	O
{	O
return	O
(	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
tag	int
,	O
RPM_NULL_TYPE	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
}	O
int	O
headerGetRawEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum(int,int,int,int)
,	O
void	O
*	O
*	O
p	*(void)
,	O
int_32	int
*	O
c	int
)	O
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
)	O
return	O
headerIsEntry	(*(struct),int)->(int)
(	O
h	*(struct)
,	O
tag	int
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
tag	int
,	O
RPM_NULL_TYPE	int
)	O
;	O
if	O
(	O
!	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
if	O
(	O
p	*(void)
)	O
*	O
p	*(void)
=	O
NULL	O
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
copyEntry	(*(struct(struct(int,int,int,int),*(void),int)),*(int),*(*(void)),*(int),int)->(void)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
,	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
headerMatchLocale	(*(char),*(char),*(char))->(int)
(	O
const	O
char	O
*	O
td	*(char)
,	O
const	O
char	O
*	O
l	int
,	O
const	O
char	O
*	O
le	*(char)
)	O
{	O
const	O
char	O
*	O
fe	*(char)
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
td	*(char)
)	O
==	O
(	O
le	*(char)
-	O
l	int
)	O
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
td	*(char)
,	O
l	int
,	O
(	O
le	*(char)
-	O
l	int
)	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
fe	*(char)
=	O
l	int
;	O
fe	*(char)
<	O
le	*(char)
&&	O
*	O
fe	*(char)
!=	O
'@'	O
;	O
fe	*(char)
++	O
)	O
;	O
if	O
(	O
fe	*(char)
<	O
le	*(char)
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
td	*(char)
,	O
l	int
,	O
(	O
fe	*(char)
-	O
l	int
)	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
fe	*(char)
=	O
l	int
;	O
fe	*(char)
<	O
le	*(char)
&&	O
*	O
fe	*(char)
!=	O
'.'	O
;	O
fe	*(char)
++	O
)	O
;	O
if	O
(	O
fe	*(char)
<	O
le	*(char)
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
td	*(char)
,	O
l	int
,	O
(	O
fe	*(char)
-	O
l	int
)	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
fe	*(char)
=	O
l	int
;	O
fe	*(char)
<	O
le	*(char)
&&	O
*	O
fe	*(char)
!=	O
'_'	O
;	O
fe	*(char)
++	O
)	O
;	O
if	O
(	O
fe	*(char)
<	O
le	*(char)
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
td	*(char)
,	O
l	int
,	O
(	O
fe	*(char)
-	O
l	int
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
headerFindI18NString	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(struct(struct(int,int,int,int),*(void),int)))->(*(char))
(	O
Header	*(struct)
h	*(struct)
,	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
const	O
char	O
*	O
lang	*(char)
,	O
*	O
l	int
,	O
*	O
le	*(char)
;	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
table	*(struct(struct(int,int,int,int),*(void),int))
;	O
if	O
(	O
(	O
lang	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LANGUAGE"	*(char)
)	O
)	O
==	O
NULL	O
&&	O
(	O
lang	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LC_ALL"	*(char)
)	O
)	O
==	O
NULL	O
&&	O
(	O
lang	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LC_MESSAGES"	*(char)
)	O
)	O
==	O
NULL	O
&&	O
(	O
lang	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LANG"	*(char)
)	O
)	O
==	O
NULL	O
)	O
return	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
if	O
(	O
(	O
table	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
)	O
)	O
==	O
NULL	O
)	O
return	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
for	O
(	O
l	int
=	O
lang	*(char)
;	O
*	O
l	int
;	O
l	int
=	O
le	*(char)
)	O
{	O
const	O
char	O
*	O
td	*(char)
;	O
char	O
*	O
ed	*(char)
;	O
int	O
langNum	int
;	O
while	O
(	O
*	O
l	int
&&	O
*	O
l	int
==	O
':'	O
)	O
l	int
++	O
;	O
if	O
(	O
*	O
l	int
==	O
'\0'	O
)	O
break	O
;	O
for	O
(	O
le	*(char)
=	O
l	int
;	O
*	O
le	*(char)
&&	O
*	O
le	*(char)
!=	O
':'	O
;	O
le	*(char)
++	O
)	O
;	O
for	O
(	O
langNum	int
=	O
0	int
,	O
td	*(char)
=	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
,	O
ed	*(char)
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
langNum	int
<	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
langNum	int
++	O
,	O
td	*(char)
+=	O
strlen	(*(char))->(long)
(	O
td	*(char)
)	O
+	O
1	int
,	O
ed	*(char)
+=	O
strlen	(*(char))->(long)
(	O
ed	*(char)
)	O
+	O
1	int
)	O
{	O
if	O
(	O
headerMatchLocale	(*(char),*(char),*(char))->(int)
(	O
td	*(char)
,	O
l	int
,	O
le	*(char)
)	O
)	O
return	O
ed	*(char)
;	O
}	O
}	O
return	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
}	O
static	O
int	O
intGetEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,*(int),*(*(void)),*(int),int)->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum(int,int,int,int)
,	O
void	O
*	O
*	O
p	*(void)
,	O
int_32	int
*	O
c	int
,	O
int	O
minMem	int
)	O
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
char	O
*	O
chptr	*(char)
;	O
HEADERPROBE	O
(	O
h	*(struct)
,	O
"intGetEntry"	*(char)
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
tag	int
,	O
RPM_NULL_TYPE	int
)	O
;	O
if	O
(	O
!	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
if	O
(	O
p	*(void)
)	O
*	O
p	*(void)
=	O
NULL	O
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
==	O
RPM_I18NSTRING_TYPE	int
)	O
{	O
chptr	*(char)
=	O
headerFindI18NString	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(struct(struct(int,int,int,int),*(void),int)))->(*(char))
(	O
h	*(struct)
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
)	O
*	O
type	enum(int,int,int,int)
=	O
RPM_STRING_TYPE	int
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
1	int
;	O
*	O
p	*(void)
=	O
chptr	*(char)
;	O
}	O
else	O
{	O
copyEntry	(*(struct(struct(int,int,int,int),*(void),int)),*(int),*(*(void)),*(int),int)->(void)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
,	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
minMem	int
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
headerGetEntryMinMemory	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum(int,int,int,int)
,	O
void	O
*	O
*	O
p	*(void)
,	O
int_32	int
*	O
c	int
)	O
{	O
return	O
intGetEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,*(int),*(*(void)),*(int),int)->(int)
(	O
h	*(struct)
,	O
tag	int
,	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
1	int
)	O
;	O
}	O
int	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum(int,int,int,int)
,	O
void	O
*	O
*	O
p	*(void)
,	O
int_32	int
*	O
c	int
)	O
{	O
return	O
intGetEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,*(int),*(*(void)),*(int),int)->(int)
(	O
h	*(struct)
,	O
tag	int
,	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
0	int
)	O
;	O
}	O
Header	*(struct)
headerNew	()->(*(struct))
(	O
)	O
{	O
Header	*(struct)
h	*(struct)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
headerToken	struct(*(struct),int,int,int,int)
)	O
)	O
;	O
h	*(struct)
->	O
indexAlloced	int
=	O
INDEX_MALLOC_SIZE	int
;	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
=	O
xcalloc	(long,long)->(*(void))
(	O
h	*(struct)
->	O
indexAlloced	int
,	O
sizeof	O
(	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
)	O
)	O
;	O
h	*(struct)
->	O
indexUsed	int
=	O
0	int
;	O
h	*(struct)
->	O
sorted	int
=	O
0	int
;	O
h	*(struct)
->	O
usageCount	int
=	O
1	int
;	O
return	O
(	O
Header	*(struct)
)	O
h	*(struct)
;	O
}	O
void	O
headerFree	(*(struct))->(void)
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
--	O
h	*(struct)
->	O
usageCount	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	*(struct)
->	O
indexUsed	int
;	O
i	int
++	O
)	O
free	(*(void))->(void)
(	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
[	O
i	int
]	O
.	O
data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
h	*(struct)
)	O
;	O
}	O
Header	*(struct)
headerLink	(*(struct))->(*(struct))
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
HEADERPROBE	O
(	O
h	*(struct)
,	O
"headerLink"	*(char)
)	O
;	O
h	*(struct)
->	O
usageCount	int
++	O
;	O
return	O
h	*(struct)
;	O
}	O
int	O
headerUsageCount	(*(struct))->(int)
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
return	O
h	*(struct)
->	O
usageCount	int
;	O
}	O
unsigned	O
int	O
headerSizeof	(*(struct),int)->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int	O
magicp	int
)	O
{	O
unsigned	O
int	O
size	long
;	O
int	O
i	int
,	O
diff	int
;	O
int_32	int
type	enum(int,int,int,int)
;	O
headerSort	(*(struct))->(void)
(	O
h	*(struct)
)	O
;	O
size	long
=	O
sizeof	O
(	O
int_32	int
)	O
;	O
size	long
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
size	long
+=	O
sizeof	O
(	O
struct	O
entryInfo	struct(int,int,int,int)
)	O
*	O
h	*(struct)
->	O
indexUsed	int
;	O
if	O
(	O
magicp	int
)	O
{	O
size	long
+=	O
8	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	*(struct)
->	O
indexUsed	int
;	O
i	int
++	O
)	O
{	O
type	enum(int,int,int,int)
=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
[	O
i	int
]	O
.	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
;	O
if	O
(	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
>	O
1	int
)	O
{	O
diff	int
=	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
-	O
(	O
size	long
%	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
)	O
;	O
if	O
(	O
diff	int
!=	O
typeSizes	array(int)
[	O
type	enum(int,int,int,int)
]	O
)	O
{	O
size	long
+=	O
diff	int
;	O
}	O
}	O
size	long
+=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
[	O
i	int
]	O
.	O
length	int
;	O
}	O
return	O
size	long
;	O
}	O
static	O
void	O
copyData	(int,*(void),*(void),int,int)->(void)
(	O
int_32	int
type	enum(int,int,int,int)
,	O
void	O
*	O
dstPtr	*(void)
,	O
const	O
void	O
*	O
srcPtr	*(void)
,	O
int_32	int
c	int
,	O
int	O
dataLength	(int,*(void),int,int)->(int)
)	O
{	O
const	O
char	O
*	O
*	O
src	*(*(char))
;	O
char	O
*	O
dst	*(char)
;	O
int	O
i	int
,	O
len	int
;	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
i	int
=	O
c	int
;	O
src	*(*(char))
=	O
(	O
const	O
char	O
*	O
*	O
)	O
srcPtr	*(void)
;	O
dst	*(char)
=	O
dstPtr	*(void)
;	O
while	O
(	O
i	int
--	O
)	O
{	O
len	int
=	O
*	O
src	*(*(char))
?	O
strlen	(*(char))->(long)
(	O
*	O
src	*(*(char))
)	O
+	O
1	int
:	O
0	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dst	*(char)
,	O
*	O
src	*(*(char))
,	O
len	int
)	O
;	O
dst	*(char)
+=	O
len	int
;	O
src	*(*(char))
++	O
;	O
}	O
break	O
;	O
default	O
:	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dstPtr	*(void)
,	O
srcPtr	*(void)
,	O
dataLength	(int,*(void),int,int)->(int)
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
*	O
grabData	(int,*(void),int,*(int))->(*(void))
(	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
p	*(void)
,	O
int_32	int
c	int
,	O
int	O
*	O
lengthPtr	*(int)
)	O
{	O
int	O
length	int
;	O
void	O
*	O
data	*(void)
;	O
length	int
=	O
dataLength	(int,*(void),int,int)->(int)
(	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
0	int
)	O
;	O
data	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
length	int
)	O
;	O
copyData	(int,*(void),*(void),int,int)->(void)
(	O
type	enum(int,int,int,int)
,	O
data	*(void)
,	O
p	*(void)
,	O
c	int
,	O
length	int
)	O
;	O
*	O
lengthPtr	*(int)
=	O
length	int
;	O
return	O
data	*(void)
;	O
}	O
int	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
p	*(void)
,	O
int_32	int
c	int
)	O
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
h	*(struct)
->	O
sorted	int
=	O
0	int
;	O
if	O
(	O
c	int
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Bad count for headerAddEntry(): %d\n"	*(char)
)	O
,	O
(	O
int	O
)	O
c	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
h	*(struct)
->	O
indexUsed	int
==	O
h	*(struct)
->	O
indexAlloced	int
)	O
{	O
h	*(struct)
->	O
indexAlloced	int
+=	O
INDEX_MALLOC_SIZE	int
;	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
,	O
h	*(struct)
->	O
indexAlloced	int
*	O
sizeof	O
(	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
)	O
)	O
;	O
}	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
+	O
h	*(struct)
->	O
indexUsed	int
++	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
tag	int
=	O
tag	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
=	O
c	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
offset	long
=	O
-	O
1	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
=	O
grabData	(int,*(void),int,*(int))->(*(void))
(	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
&	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
)	O
;	O
h	*(struct)
->	O
sorted	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
char	O
*	O
*	O
headerGetLangs	(*(struct))->(*(*(char)))
(	O
Header	*(struct)
h	*(struct)
)	O
{	O
char	O
*	O
*	O
s	*(*(char))
,	O
*	O
e	*(char)
,	O
*	O
*	O
table	*(struct(struct(int,int,int,int),*(void),int))
;	O
int	O
i	int
,	O
type	enum(int,int,int,int)
,	O
count	long
;	O
if	O
(	O
!	O
headerGetRawEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
HEADER_I18NTABLE	int
,	O
&	O
type	enum(int,int,int,int)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	*(*(char))
,	O
&	O
count	long
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
table	*(struct(struct(int,int,int,int),*(void),int))
=	O
(	O
char	O
*	O
*	O
)	O
xcalloc	(long,long)->(*(void))
(	O
(	O
count	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
e	*(char)
=	O
*	O
s	*(*(char))
;	O
i	int
<	O
count	long
>	O
0	int
;	O
i	int
++	O
,	O
e	*(char)
+=	O
strlen	(*(char))->(long)
(	O
e	*(char)
)	O
+	O
1	int
)	O
{	O
table	*(struct(struct(int,int,int,int),*(void),int))
[	O
i	int
]	O
=	O
e	*(char)
;	O
}	O
table	*(struct(struct(int,int,int,int),*(void),int))
[	O
count	long
]	O
=	O
NULL	O
;	O
return	O
table	*(struct(struct(int,int,int,int),*(void),int))
;	O
}	O
int	O
headerAddI18NString	(*(struct),int,*(char),*(char))->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
const	O
char	O
*	O
string	*(char)
,	O
const	O
char	O
*	O
lang	*(char)
)	O
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
table	*(struct(struct(int,int,int,int),*(void),int))
,	O
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
char	O
*	O
chptr	*(char)
;	O
const	O
char	O
*	O
*	O
strArray	*(*(char))
;	O
int	O
length	int
;	O
int	O
ghosts	int
;	O
int	O
i	int
,	O
langNum	int
;	O
char	O
*	O
buf	*(char)
;	O
table	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
tag	int
,	O
RPM_I18NSTRING_TYPE	int
)	O
;	O
if	O
(	O
!	O
table	*(struct(struct(int,int,int,int),*(void),int))
&&	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
table	*(struct(struct(int,int,int,int),*(void),int))
&&	O
!	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
const	O
char	O
*	O
charArray	array(*(char))
[	O
2	int
]	O
;	O
int	O
count	long
=	O
0	int
;	O
if	O
(	O
!	O
lang	*(char)
||	O
(	O
lang	*(char)
[	O
0	int
]	O
==	O
'C'	O
&&	O
lang	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
charArray	array(*(char))
[	O
count	long
++	O
]	O
=	O
"C"	*(char)
;	O
}	O
else	O
{	O
charArray	array(*(char))
[	O
count	long
++	O
]	O
=	O
"C"	*(char)
;	O
charArray	array(*(char))
[	O
count	long
++	O
]	O
=	O
lang	*(char)
;	O
}	O
if	O
(	O
!	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
h	*(struct)
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
&	O
charArray	array(*(char))
,	O
count	long
)	O
)	O
return	O
0	int
;	O
table	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
)	O
;	O
}	O
if	O
(	O
!	O
lang	*(char)
)	O
lang	*(char)
=	O
"C"	*(char)
;	O
chptr	*(char)
=	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
for	O
(	O
langNum	int
=	O
0	int
;	O
langNum	int
<	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
langNum	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
chptr	*(char)
,	O
lang	*(char)
)	O
)	O
break	O
;	O
chptr	*(char)
+=	O
strlen	(*(char))->(long)
(	O
chptr	*(char)
)	O
+	O
1	int
;	O
}	O
if	O
(	O
langNum	int
>=	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
)	O
{	O
length	int
=	O
strlen	(*(char))->(long)
(	O
lang	*(char)
)	O
+	O
1	int
;	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
,	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
+	O
length	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
(	O
char	O
*	O
)	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
)	O
+	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
,	O
lang	*(char)
,	O
length	int
)	O
;	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
+=	O
length	int
;	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
++	O
;	O
}	O
if	O
(	O
!	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
strArray	*(*(char))
=	O
alloca	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
strArray	*(*(char))
)	O
*	O
(	O
langNum	int
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
langNum	int
;	O
i	int
++	O
)	O
strArray	*(*(char))
[	O
i	int
]	O
=	O
""	*(char)
;	O
strArray	*(*(char))
[	O
langNum	int
]	O
=	O
string	*(char)
;	O
return	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
h	*(struct)
,	O
tag	int
,	O
RPM_I18NSTRING_TYPE	int
,	O
strArray	*(*(char))
,	O
langNum	int
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
langNum	int
>=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
)	O
{	O
ghosts	int
=	O
langNum	int
-	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
length	int
=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
+	O
1	int
+	O
ghosts	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
+	O
length	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
(	O
char	O
*	O
)	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
)	O
+	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
,	O
'\0'	O
,	O
ghosts	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
(	O
(	O
char	O
*	O
)	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
)	O
+	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
+	O
ghosts	int
,	O
string	*(char)
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
+=	O
length	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
=	O
langNum	int
+	O
1	int
;	O
}	O
else	O
{	O
char	O
*	O
b	int
,	O
*	O
be	*(char)
,	O
*	O
e	*(char)
,	O
*	O
ee	*(char)
,	O
*	O
t	*(char)
;	O
size_t	long
bn	long
,	O
sn	long
,	O
en	long
;	O
b	int
=	O
be	*(char)
=	O
e	*(char)
=	O
ee	*(char)
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
table	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
langNum	int
)	O
be	*(char)
=	O
ee	*(char)
;	O
ee	*(char)
+=	O
strlen	(*(char))->(long)
(	O
ee	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
i	int
==	O
langNum	int
)	O
e	*(char)
=	O
ee	*(char)
;	O
}	O
bn	long
=	O
(	O
be	*(char)
-	O
b	int
)	O
;	O
sn	long
=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
+	O
1	int
;	O
en	long
=	O
(	O
ee	*(char)
-	O
e	*(char)
)	O
;	O
length	int
=	O
bn	long
+	O
sn	long
+	O
en	long
;	O
t	*(char)
=	O
buf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
length	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
t	*(char)
,	O
b	int
,	O
bn	long
)	O
;	O
t	*(char)
+=	O
bn	long
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
t	*(char)
,	O
string	*(char)
,	O
sn	long
)	O
;	O
t	*(char)
+=	O
sn	long
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
t	*(char)
,	O
e	*(char)
,	O
en	long
)	O
;	O
t	*(char)
+=	O
en	long
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
-=	O
strlen	(*(char))->(long)
(	O
be	*(char)
)	O
+	O
1	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
+=	O
sn	long
;	O
free	(*(void))->(void)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
=	O
buf	*(char)
;	O
}	O
return	O
0	int
;	O
}	O
int	O
headerModifyEntry	(*(struct),int,int,*(void),int)->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum(int,int,int,int)
,	O
void	O
*	O
p	*(void)
,	O
int_32	int
c	int
)	O
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
void	O
*	O
oldData	*(void)
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
tag	int
,	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
!	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
return	O
0	int
;	O
}	O
while	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
>	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
&&	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
-	O
1	int
)	O
->	O
info	struct(int,int,int,int)
.	O
tag	int
==	O
tag	int
)	O
entry	*(struct(struct(int,int,int,int),*(void),int))
--	O
;	O
oldData	*(void)
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
=	O
c	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
=	O
grabData	(int,*(void),int,*(int))->(*(void))
(	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
&	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
)	O
;	O
free	(*(void))->(void)
(	O
oldData	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
int	O
headerAddOrAppendEntry	(*(struct),int,int,*(void),int)->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum(int,int,int,int)
,	O
void	O
*	O
p	*(void)
,	O
int_32	int
c	int
)	O
{	O
if	O
(	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
tag	int
,	O
type	enum(int,int,int,int)
)	O
)	O
{	O
return	O
headerAppendEntry	(*(struct),int,int,*(void),int)->(int)
(	O
h	*(struct)
,	O
tag	int
,	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
)	O
;	O
}	O
else	O
{	O
return	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
h	*(struct)
,	O
tag	int
,	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
)	O
;	O
}	O
}	O
int	O
headerAppendEntry	(*(struct),int,int,*(void),int)->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum(int,int,int,int)
,	O
void	O
*	O
p	*(void)
,	O
int_32	int
c	int
)	O
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
int	O
length	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
tag	int
,	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
!	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
type	enum(int,int,int,int)
==	O
RPM_STRING_TYPE	int
||	O
type	enum(int,int,int,int)
==	O
RPM_I18NSTRING_TYPE	int
)	O
{	O
return	O
0	int
;	O
}	O
length	int
=	O
dataLength	(int,*(void),int,int)->(int)
(	O
type	enum(int,int,int,int)
,	O
p	*(void)
,	O
c	int
,	O
0	int
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
,	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
+	O
length	int
)	O
;	O
copyData	(int,*(void),*(void),int,int)->(void)
(	O
type	enum(int,int,int,int)
,	O
(	O
(	O
char	O
*	O
)	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
)	O
+	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
,	O
p	*(void)
,	O
c	int
,	O
length	int
)	O
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
length	int
+=	O
length	int
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
count	long
+=	O
c	int
;	O
return	O
0	int
;	O
}	O
int	O
headerRemoveEntry	(*(struct),int)->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
int_32	int
tag	int
)	O
{	O
struct	O
indexEntry	struct(struct(int,int,int,int),*(void),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
,	O
*	O
last	*(struct(struct(int,int,int,int),*(void),int))
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
findEntry	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),int,int)->(*(struct(struct(int,int,int,int),*(void),int)))
(	O
h	*(struct)
,	O
tag	int
,	O
RPM_NULL_TYPE	int
)	O
;	O
if	O
(	O
!	O
entry	*(struct(struct(int,int,int,int),*(void),int))
)	O
return	O
1	int
;	O
while	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
>	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
&&	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
-	O
1	int
)	O
->	O
info	struct(int,int,int,int)
.	O
tag	int
==	O
tag	int
)	O
entry	*(struct(struct(int,int,int,int),*(void),int))
--	O
;	O
last	*(struct(struct(int,int,int,int),*(void),int))
=	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
+	O
h	*(struct)
->	O
indexUsed	int
;	O
while	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
info	struct(int,int,int,int)
.	O
tag	int
==	O
tag	int
&&	O
entry	*(struct(struct(int,int,int,int),*(void),int))
<	O
last	*(struct(struct(int,int,int,int),*(void),int))
)	O
{	O
free	(*(void))->(void)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
data	*(void)
)	O
;	O
*	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
++	O
)	O
=	O
*	O
(	O
--	O
last	*(struct(struct(int,int,int,int),*(void),int))
)	O
;	O
}	O
h	*(struct)
->	O
indexUsed	int
=	O
last	*(struct(struct(int,int,int,int),*(void),int))
-	O
h	*(struct)
->	O
index	(*(char),int)->(*(char))
;	O
h	*(struct)
->	O
sorted	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
escapedChar	(char)->(char)
(	O
const	O
char	O
ch	char
)	O
{	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'a'	O
:	O
return	O
'\a'	O
;	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'v'	O
:	O
return	O
'\v'	O
;	O
default	O
:	O
return	O
ch	char
;	O
}	O
}	O
static	O
void	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
format	*(char)
,	O
int	O
num	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
format	*(char)
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PTOK_ARRAY	int
:	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
,	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
numTokens	int
)	O
;	O
break	O
;	O
case	O
PTOK_COND	int
:	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
,	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numIfTokens	int
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
elseFormat	*(struct(enum(int,int,int,int,int)))
,	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numElseTokens	int
)	O
;	O
break	O
;	O
case	O
PTOK_NONE	int
:	O
case	O
PTOK_TAG	int
:	O
case	O
PTOK_STRING	int
:	O
default	O
:	O
break	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
format	*(char)
)	O
;	O
}	O
static	O
void	O
findTag	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(*(char),int))),*(*(struct(enum(int,int,int,int),*(char),union(*`,*`,*`,*`)))))->(void)
(	O
char	O
*	O
name	*(char)
,	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tags	*(struct(*(char),int))
,	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
*	O
tagMatch	*(*(struct(*(char),int)))
,	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
*	O
extMatch	*(*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
)	O
{	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
;	O
char	O
*	O
tagname	*(char)
;	O
*	O
tagMatch	*(*(struct(*(char),int)))
=	O
NULL	O
;	O
*	O
extMatch	*(*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
"RPMTAG_"	*(char)
,	O
name	*(char)
,	O
sizeof	O
(	O
"RPMTAG_"	*(char)
)	O
-	O
1	int
)	O
)	O
{	O
tagname	*(char)
=	O
alloca	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
+	O
10	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
tagname	*(char)
,	O
"RPMTAG_"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
tagname	*(char)
,	O
name	*(char)
)	O
;	O
}	O
else	O
{	O
tagname	*(char)
=	O
name	*(char)
;	O
}	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
;	O
while	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
&&	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
!=	O
HEADER_EXT_LAST	int
)	O
{	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
==	O
HEADER_EXT_TAG	int
&&	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
name	*(char)
,	O
tagname	*(char)
)	O
)	O
break	O
;	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
==	O
HEADER_EXT_MORE	int
)	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
more	*(struct(enum(int,int,int,int),*(char)))
;	O
else	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
++	O
;	O
}	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
&&	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
==	O
HEADER_EXT_TAG	int
)	O
{	O
*	O
extMatch	*(*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
;	O
return	O
;	O
}	O
for	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
=	O
tags	*(struct(*(char),int))
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
name	*(char)
;	O
entry	*(struct(struct(int,int,int,int),*(void),int))
++	O
)	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
name	*(char)
,	O
tagname	*(char)
)	O
)	O
break	O
;	O
if	O
(	O
entry	*(struct(struct(int,int,int,int),*(void),int))
->	O
name	*(char)
)	O
{	O
*	O
tagMatch	*(*(struct(*(char),int)))
=	O
entry	*(struct(struct(int,int,int,int),*(void),int))
;	O
return	O
;	O
}	O
}	O
static	O
int	O
parseExpression	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(char)),*(*(char)))->(int)
(	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
,	O
char	O
*	O
str	*(char)
,	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tags	*(struct(*(char),int))
,	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
char	O
*	O
*	O
endPtr	*(*(char))
,	O
const	O
char	O
*	O
*	O
error	*(*(char))
)	O
;	O
static	O
int	O
parseFormat	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`)))),*(int),*(*(char)),int,*(*(char)))->(int)
(	O
char	O
*	O
str	*(char)
,	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tags	*(struct(*(char),int))
,	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
*	O
formatPtr	*(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))))
,	O
int	O
*	O
numTokensPtr	*(int)
,	O
char	O
*	O
*	O
endPtr	*(*(char))
,	O
int	O
state	*(int)
,	O
const	O
char	O
*	O
*	O
error	*(*(char))
)	O
{	O
char	O
*	O
chptr	*(char)
,	O
*	O
start	*(char)
,	O
*	O
next	*(char)
,	O
*	O
dst	*(char)
;	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
format	*(char)
;	O
int	O
numTokens	int
;	O
int	O
currToken	int
;	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tag	int
;	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
;	O
int	O
i	int
;	O
int	O
done	int
=	O
0	int
;	O
numTokens	int
=	O
0	int
;	O
for	O
(	O
chptr	*(char)
=	O
str	*(char)
;	O
*	O
chptr	*(char)
;	O
chptr	*(char)
++	O
)	O
if	O
(	O
*	O
chptr	*(char)
==	O
'%'	O
)	O
numTokens	int
++	O
;	O
numTokens	int
=	O
numTokens	int
*	O
2	int
+	O
1	int
;	O
format	*(char)
=	O
xcalloc	(long,long)->(*(void))
(	O
numTokens	int
,	O
sizeof	O
(	O
*	O
format	*(char)
)	O
)	O
;	O
if	O
(	O
endPtr	*(*(char))
)	O
*	O
endPtr	*(*(char))
=	O
NULL	O
;	O
dst	*(char)
=	O
start	*(char)
=	O
str	*(char)
;	O
currToken	int
=	O
-	O
1	int
;	O
while	O
(	O
*	O
start	*(char)
&&	O
!	O
done	int
)	O
{	O
switch	O
(	O
*	O
start	*(char)
)	O
{	O
case	O
'%'	O
:	O
if	O
(	O
*	O
(	O
start	*(char)
+	O
1	int
)	O
==	O
'%'	O
)	O
{	O
if	O
(	O
currToken	int
<	O
0	int
||	O
format	*(char)
[	O
currToken	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
PTOK_STRING	int
)	O
{	O
currToken	int
++	O
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
type	enum(int,int,int,int)
=	O
PTOK_STRING	int
;	O
dst	*(char)
=	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
string	*(char)
.	O
string	*(char)
=	O
start	*(char)
;	O
}	O
start	*(char)
++	O
;	O
*	O
dst	*(char)
++	O
=	O
*	O
start	*(char)
++	O
;	O
break	O
;	O
}	O
currToken	int
++	O
;	O
*	O
dst	*(char)
++	O
=	O
'\0'	O
;	O
start	*(char)
++	O
;	O
if	O
(	O
*	O
start	*(char)
==	O
'|'	O
)	O
{	O
char	O
*	O
newEnd	*(char)
;	O
start	*(char)
++	O
;	O
if	O
(	O
parseExpression	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(char)),*(*(char)))->(int)
(	O
format	*(char)
+	O
currToken	int
,	O
start	*(char)
,	O
tags	*(struct(*(char),int))
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
&	O
newEnd	*(char)
,	O
error	*(*(char))
)	O
)	O
{	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
start	*(char)
=	O
newEnd	*(char)
;	O
}	O
else	O
{	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
format	*(char)
=	O
start	*(char)
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
pad	int
=	O
0	int
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
justOne	int
=	O
0	int
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
arrayCount	int
=	O
0	int
;	O
chptr	*(char)
=	O
start	*(char)
;	O
while	O
(	O
*	O
chptr	*(char)
&&	O
*	O
chptr	*(char)
!=	O
'{'	O
&&	O
*	O
chptr	*(char)
!=	O
'%'	O
)	O
chptr	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
chptr	*(char)
||	O
*	O
chptr	*(char)
==	O
'%'	O
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"missing { after %"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
*	O
chptr	*(char)
++	O
=	O
'\0'	O
;	O
while	O
(	O
start	*(char)
<	O
chptr	*(char)
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
start	*(char)
)	O
)	O
{	O
i	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
start	*(char)
,	O
&	O
start	*(char)
,	O
10	int
)	O
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
pad	int
+=	O
i	int
;	O
}	O
else	O
{	O
start	*(char)
++	O
;	O
}	O
}	O
if	O
(	O
*	O
start	*(char)
==	O
'='	O
)	O
{	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
justOne	int
=	O
1	int
;	O
start	*(char)
++	O
;	O
}	O
else	O
if	O
(	O
*	O
start	*(char)
==	O
'#'	O
)	O
{	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
justOne	int
=	O
1	int
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
arrayCount	int
=	O
1	int
;	O
start	*(char)
++	O
;	O
}	O
next	*(char)
=	O
start	*(char)
;	O
while	O
(	O
*	O
next	*(char)
&&	O
*	O
next	*(char)
!=	O
'}'	O
)	O
next	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
next	*(char)
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"missing } after %{"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
*	O
next	*(char)
++	O
=	O
'\0'	O
;	O
chptr	*(char)
=	O
start	*(char)
;	O
while	O
(	O
*	O
chptr	*(char)
&&	O
*	O
chptr	*(char)
!=	O
':'	O
)	O
chptr	*(char)
++	O
;	O
if	O
(	O
*	O
chptr	*(char)
)	O
{	O
*	O
chptr	*(char)
++	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
*	O
chptr	*(char)
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"empty tag format"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
type	enum(int,int,int,int)
=	O
chptr	*(char)
;	O
}	O
else	O
{	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
type	enum(int,int,int,int)
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
*	O
start	*(char)
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"empty tag name"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
i	int
=	O
0	int
;	O
findTag	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(*(char),int))),*(*(struct(enum(int,int,int,int),*(char),union(*`,*`,*`,*`)))))->(void)
(	O
start	*(char)
,	O
tags	*(struct(*(char),int))
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
&	O
tag	int
,	O
&	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
)	O
;	O
if	O
(	O
tag	int
)	O
{	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
NULL	O
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
tag	int
=	O
tag	int
->	O
val	array(int)
;	O
}	O
else	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
)	O
{	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tagFunction	*((*(struct),*(int),*(*(void)),*(int),*(int))->(int))
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
extNum	int
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
-	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
;	O
}	O
else	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"unknown tag"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
format	*(char)
[	O
currToken	int
]	O
.	O
type	enum(int,int,int,int)
=	O
PTOK_TAG	int
;	O
start	*(char)
=	O
next	*(char)
;	O
}	O
break	O
;	O
case	O
'['	O
:	O
*	O
dst	*(char)
++	O
=	O
'\0'	O
;	O
*	O
start	*(char)
++	O
=	O
'\0'	O
;	O
currToken	int
++	O
;	O
if	O
(	O
parseFormat	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`)))),*(int),*(*(char)),int,*(*(char)))->(int)
(	O
start	*(char)
,	O
tags	*(struct(*(char),int))
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
&	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
,	O
&	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
numTokens	int
,	O
&	O
start	*(char)
,	O
PARSER_IN_ARRAY	int
,	O
error	*(*(char))
)	O
)	O
{	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
start	*(char)
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"] expected at end of array"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
dst	*(char)
=	O
start	*(char)
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
type	enum(int,int,int,int)
=	O
PTOK_ARRAY	int
;	O
break	O
;	O
case	O
']'	O
:	O
case	O
'}'	O
:	O
if	O
(	O
(	O
*	O
start	*(char)
==	O
']'	O
&&	O
state	*(int)
!=	O
PARSER_IN_ARRAY	int
)	O
||	O
(	O
*	O
start	*(char)
==	O
'}'	O
&&	O
state	*(int)
!=	O
PARSER_IN_EXPR	int
)	O
)	O
{	O
if	O
(	O
*	O
start	*(char)
==	O
']'	O
)	O
*	O
error	*(*(char))
=	O
_	O
(	O
"unexpected ]"	*(char)
)	O
;	O
else	O
*	O
error	*(*(char))
=	O
_	O
(	O
"unexpected }"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
format	*(char)
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
*	O
start	*(char)
++	O
=	O
'\0'	O
;	O
*	O
endPtr	*(*(char))
=	O
start	*(char)
;	O
done	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
currToken	int
<	O
0	int
||	O
format	*(char)
[	O
currToken	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
PTOK_STRING	int
)	O
{	O
currToken	int
++	O
;	O
format	*(char)
[	O
currToken	int
]	O
.	O
type	enum(int,int,int,int)
=	O
PTOK_STRING	int
;	O
dst	*(char)
=	O
format	*(char)
[	O
currToken	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
string	*(char)
.	O
string	*(char)
=	O
start	*(char)
;	O
}	O
if	O
(	O
*	O
start	*(char)
==	O
'\\'	O
)	O
{	O
start	*(char)
++	O
;	O
*	O
dst	*(char)
++	O
=	O
escapedChar	(char)->(char)
(	O
*	O
start	*(char)
++	O
)	O
;	O
}	O
else	O
{	O
*	O
dst	*(char)
++	O
=	O
*	O
start	*(char)
++	O
;	O
}	O
break	O
;	O
}	O
}	O
*	O
dst	*(char)
=	O
'\0'	O
;	O
currToken	int
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
currToken	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
format	*(char)
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
==	O
PTOK_STRING	int
)	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
string	*(char)
.	O
len	int
=	O
strlen	(*(char))->(long)
(	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
string	*(char)
.	O
string	*(char)
)	O
;	O
}	O
*	O
numTokensPtr	*(int)
=	O
currToken	int
;	O
*	O
formatPtr	*(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))))
=	O
format	*(char)
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parseExpression	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(char)),*(*(char)))->(int)
(	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
,	O
char	O
*	O
str	*(char)
,	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tags	*(struct(*(char),int))
,	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
char	O
*	O
*	O
endPtr	*(*(char))
,	O
const	O
char	O
*	O
*	O
error	*(*(char))
)	O
{	O
char	O
*	O
chptr	*(char)
,	O
*	O
end	*(char)
;	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tag	int
;	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
;	O
*	O
error	*(*(char))
=	O
NULL	O
;	O
chptr	*(char)
=	O
str	*(char)
;	O
while	O
(	O
*	O
chptr	*(char)
&&	O
*	O
chptr	*(char)
!=	O
'?'	O
)	O
chptr	*(char)
++	O
;	O
if	O
(	O
*	O
chptr	*(char)
!=	O
'?'	O
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"? expected in expression"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
*	O
chptr	*(char)
++	O
=	O
'\0'	O
;	O
;	O
if	O
(	O
*	O
chptr	*(char)
!=	O
'{'	O
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"{ expected after ? in expression"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
chptr	*(char)
++	O
;	O
if	O
(	O
parseFormat	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`)))),*(int),*(*(char)),int,*(*(char)))->(int)
(	O
chptr	*(char)
,	O
tags	*(struct(*(char),int))
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
&	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
,	O
&	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numIfTokens	int
,	O
&	O
end	*(char)
,	O
PARSER_IN_EXPR	int
,	O
error	*(*(char))
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
*	O
end	*(char)
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"} expected in expression"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numIfTokens	int
)	O
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
chptr	*(char)
=	O
end	*(char)
;	O
if	O
(	O
*	O
chptr	*(char)
!=	O
':'	O
&&	O
*	O
chptr	*(char)
!=	O
'|'	O
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
": expected following ? subexpression"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numIfTokens	int
)	O
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
*	O
chptr	*(char)
==	O
'|'	O
)	O
{	O
parseFormat	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`)))),*(int),*(*(char)),int,*(*(char)))->(int)
(	O
xstrdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
,	O
tags	*(struct(*(char),int))
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
&	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
elseFormat	*(struct(enum(int,int,int,int,int)))
,	O
&	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numElseTokens	int
,	O
&	O
end	*(char)
,	O
PARSER_IN_EXPR	int
,	O
error	*(*(char))
)	O
;	O
}	O
else	O
{	O
chptr	*(char)
++	O
;	O
if	O
(	O
*	O
chptr	*(char)
!=	O
'{'	O
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"{ expected after : in expression"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numIfTokens	int
)	O
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
chptr	*(char)
++	O
;	O
if	O
(	O
parseFormat	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`)))),*(int),*(*(char)),int,*(*(char)))->(int)
(	O
chptr	*(char)
,	O
tags	*(struct(*(char),int))
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
&	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
elseFormat	*(struct(enum(int,int,int,int,int)))
,	O
&	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numElseTokens	int
,	O
&	O
end	*(char)
,	O
PARSER_IN_EXPR	int
,	O
error	*(*(char))
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
*	O
end	*(char)
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"} expected in expression"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numIfTokens	int
)	O
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
chptr	*(char)
=	O
end	*(char)
;	O
if	O
(	O
*	O
chptr	*(char)
!=	O
'|'	O
)	O
{	O
*	O
error	*(*(char))
=	O
_	O
(	O
"| expected at end of expression"	*(char)
)	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numIfTokens	int
)	O
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
=	O
NULL	O
;	O
freeFormat	(*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),int)->(void)
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
elseFormat	*(struct(enum(int,int,int,int,int)))
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numElseTokens	int
)	O
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
elseFormat	*(struct(enum(int,int,int,int,int)))
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
}	O
chptr	*(char)
++	O
;	O
*	O
endPtr	*(*(char))
=	O
chptr	*(char)
;	O
findTag	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(*(char),int))),*(*(struct(enum(int,int,int,int),*(char),union(*`,*`,*`,*`)))))->(void)
(	O
str	*(char)
,	O
tags	*(struct(*(char),int))
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
&	O
tag	int
,	O
&	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
)	O
;	O
if	O
(	O
tag	int
)	O
{	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
tag	int
.	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
NULL	O
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
tag	int
.	O
tag	int
=	O
tag	int
->	O
val	array(int)
;	O
}	O
else	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
)	O
{	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
tag	int
.	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tagFunction	*((*(struct),*(int),*(*(void)),*(int),*(int))->(int))
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
tag	int
.	O
extNum	int
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
-	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
;	O
}	O
else	O
{	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
tag	int
.	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
NULL	O
;	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
tag	int
.	O
tag	int
=	O
-	O
1	int
;	O
}	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
type	enum(int,int,int,int)
=	O
PTOK_COND	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
getExtension	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*((*(struct(*`,int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int)),*(int),*(*(void)),*(int),*(struct(int,int,int,int,*(void))))->(int)
(	O
Header	*(struct)
h	*(struct)
,	O
headerTagTagFunction	*((*(struct),*(int),*(*(void)),*(int),*(int))->(int))
fn	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
,	O
int_32	int
*	O
typeptr	*(int)
,	O
const	O
void	O
*	O
*	O
data	*(void)
,	O
int_32	int
*	O
countptr	*(int)
,	O
struct	O
extensionCache	struct(int,int,int,int,*(void))
*	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
)	O
{	O
if	O
(	O
!	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
avail	int
)	O
{	O
if	O
(	O
fn	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
(	O
h	*(struct)
,	O
&	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
,	O
&	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
data	*(void)
,	O
&	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
count	long
,	O
&	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
freeit	int
)	O
)	O
return	O
1	int
;	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
avail	int
=	O
1	int
;	O
}	O
*	O
typeptr	*(int)
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
;	O
*	O
data	*(void)
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
data	*(void)
;	O
*	O
countptr	*(int)
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
count	long
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
formatValue	(*(struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int)),*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(struct(int,int,int,int,*(void))),int)->(*(char))
(	O
struct	O
sprintfTag	struct(*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int)
*	O
tag	int
,	O
Header	*(struct)
h	*(struct)
,	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
struct	O
extensionCache	struct(int,int,int,int,*(void))
*	O
extCache	*(struct(int,int,int,int,*(void)))
,	O
int	O
element	array(int)
)	O
{	O
int	O
len	int
;	O
char	O
buf	*(char)
[	O
20	int
]	O
;	O
int_32	int
count	long
,	O
type	enum(int,int,int,int)
;	O
const	O
void	O
*	O
data	*(void)
;	O
unsigned	O
int	O
intVal	int
;	O
char	O
*	O
val	array(int)
=	O
NULL	O
;	O
const	O
char	O
*	O
*	O
strarray	*(*(char))
;	O
int	O
mayfree	int
=	O
0	int
;	O
int	O
countBuf	int
;	O
headerTagFormatFunction	*((int,*(void),*(char),int,int)->(*(char)))
tagtype	*((int,*(void),*(char),int,int)->(*(char)))
=	O
NULL	O
;	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
;	O
if	O
(	O
tag	int
->	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
)	O
{	O
if	O
(	O
getExtension	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*((*(struct(*`,int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int)),*(int),*(*(void)),*(int),*(struct(int,int,int,int,*(void))))->(int)
(	O
h	*(struct)
,	O
tag	int
->	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
,	O
&	O
type	enum(int,int,int,int)
,	O
&	O
data	*(void)
,	O
&	O
count	long
,	O
extCache	*(struct(int,int,int,int,*(void)))
+	O
tag	int
->	O
extNum	int
)	O
)	O
{	O
count	long
=	O
1	int
;	O
type	enum(int,int,int,int)
=	O
RPM_STRING_TYPE	int
;	O
data	*(void)
=	O
"(none)"	*(char)
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
tag	int
->	O
tag	int
,	O
&	O
type	enum(int,int,int,int)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
data	*(void)
,	O
&	O
count	long
)	O
)	O
{	O
count	long
=	O
1	int
;	O
type	enum(int,int,int,int)
=	O
RPM_STRING_TYPE	int
;	O
data	*(void)
=	O
"(none)"	*(char)
;	O
}	O
mayfree	int
=	O
1	int
;	O
}	O
if	O
(	O
tag	int
->	O
arrayCount	int
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
RPM_STRING_ARRAY_TYPE	int
)	O
free	(*(void))->(void)
(	O
(	O
void	O
*	O
)	O
data	*(void)
)	O
;	O
countBuf	int
=	O
count	long
;	O
data	*(void)
=	O
&	O
countBuf	int
;	O
count	long
=	O
1	int
;	O
type	enum(int,int,int,int)
=	O
RPM_INT32_TYPE	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"%"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
tag	int
->	O
format	*(char)
)	O
;	O
if	O
(	O
tag	int
->	O
type	enum(int,int,int,int)
)	O
{	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
;	O
while	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
!=	O
HEADER_EXT_LAST	int
)	O
{	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
==	O
HEADER_EXT_FORMAT	int
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
name	*(char)
,	O
tag	int
->	O
type	enum(int,int,int,int)
)	O
)	O
{	O
tagtype	*((int,*(void),*(char),int,int)->(*(char)))
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
formatFunction	*((int,*(void),*(char),int,int)->(*(char)))
;	O
break	O
;	O
}	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
==	O
HEADER_EXT_MORE	int
)	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
more	*(struct(enum(int,int,int,int),*(char)))
;	O
else	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
++	O
;	O
}	O
}	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
strarray	*(*(char))
=	O
(	O
const	O
char	O
*	O
*	O
)	O
data	*(void)
;	O
if	O
(	O
tagtype	*((int,*(void),*(char),int,int)->(*(char)))
)	O
{	O
val	array(int)
=	O
tagtype	*((int,*(void),*(char),int,int)->(*(char)))
(	O
RPM_STRING_TYPE	int
,	O
strarray	*(*(char))
[	O
element	array(int)
]	O
,	O
buf	*(char)
,	O
tag	int
->	O
pad	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
val	array(int)
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"s"	*(char)
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
strarray	*(*(char))
[	O
element	array(int)
]	O
)	O
+	O
tag	int
->	O
pad	int
+	O
20	int
;	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
len	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
buf	*(char)
,	O
strarray	*(*(char))
[	O
element	array(int)
]	O
)	O
;	O
}	O
if	O
(	O
mayfree	int
)	O
free	(*(void))->(void)
(	O
(	O
void	O
*	O
)	O
data	*(void)
)	O
;	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
if	O
(	O
tagtype	*((int,*(void),*(char),int,int)->(*(char)))
)	O
{	O
val	array(int)
=	O
tagtype	*((int,*(void),*(char),int,int)->(*(char)))
(	O
RPM_STRING_ARRAY_TYPE	int
,	O
data	*(void)
,	O
buf	*(char)
,	O
tag	int
->	O
pad	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
val	array(int)
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"s"	*(char)
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
data	*(void)
)	O
+	O
tag	int
->	O
pad	int
+	O
20	int
;	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
len	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
buf	*(char)
,	O
data	*(void)
)	O
;	O
}	O
break	O
;	O
case	O
RPM_CHAR_TYPE	int
:	O
case	O
RPM_INT8_TYPE	int
:	O
case	O
RPM_INT16_TYPE	int
:	O
case	O
RPM_INT32_TYPE	int
:	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
RPM_CHAR_TYPE	int
:	O
case	O
RPM_INT8_TYPE	int
:	O
intVal	int
=	O
*	O
(	O
(	O
(	O
int_8	char
*	O
)	O
data	*(void)
)	O
+	O
element	array(int)
)	O
;	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
intVal	int
=	O
*	O
(	O
(	O
(	O
uint_16	short
*	O
)	O
data	*(void)
)	O
+	O
element	array(int)
)	O
;	O
break	O
;	O
default	O
:	O
case	O
RPM_INT32_TYPE	int
:	O
intVal	int
=	O
*	O
(	O
(	O
(	O
int_32	int
*	O
)	O
data	*(void)
)	O
+	O
element	array(int)
)	O
;	O
}	O
if	O
(	O
tagtype	*((int,*(void),*(char),int,int)->(*(char)))
)	O
{	O
val	array(int)
=	O
tagtype	*((int,*(void),*(char),int,int)->(*(char)))
(	O
RPM_INT32_TYPE	int
,	O
&	O
intVal	int
,	O
buf	*(char)
,	O
tag	int
->	O
pad	int
,	O
element	array(int)
)	O
;	O
}	O
if	O
(	O
!	O
val	array(int)
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
"d"	*(char)
)	O
;	O
len	int
=	O
10	int
+	O
tag	int
->	O
pad	int
+	O
20	int
;	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
len	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
buf	*(char)
,	O
intVal	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
val	array(int)
=	O
xstrdup	(*(char))->(*(char))
(	O
_	O
(	O
"(unknown type)"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
char	O
*	O
singleSprintf	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(struct(int,int,int,int,*(void))),int)->(*(char))
(	O
Header	*(struct)
h	*(struct)
,	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
,	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
struct	O
extensionCache	struct(int,int,int,int,*(void))
*	O
extCache	*(struct(int,int,int,int,*(void)))
,	O
int	O
element	array(int)
)	O
{	O
char	O
*	O
val	array(int)
,	O
*	O
thisItem	*(char)
;	O
int	O
thisItemLen	int
;	O
int	O
len	int
,	O
alloced	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
numElements	int
;	O
int	O
type	enum(int,int,int,int)
;	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
condFormat	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
;	O
int	O
condNumFormats	int
;	O
switch	O
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PTOK_NONE	int
:	O
break	O
;	O
case	O
PTOK_STRING	int
:	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
string	*(char)
.	O
len	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
val	array(int)
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
string	*(char)
.	O
string	*(char)
)	O
;	O
break	O
;	O
case	O
PTOK_TAG	int
:	O
val	array(int)
=	O
formatValue	(*(struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int)),*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(struct(int,int,int,int,*(void))),int)->(*(char))
(	O
&	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
,	O
h	*(struct)
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
extCache	*(struct(int,int,int,int,*(void)))
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
justOne	int
?	O
0	int
:	O
element	array(int)
)	O
;	O
break	O
;	O
case	O
PTOK_COND	int
:	O
if	O
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
tag	int
.	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
||	O
headerIsEntry	(*(struct),int)->(int)
(	O
h	*(struct)
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
tag	int
.	O
tag	int
)	O
)	O
{	O
condFormat	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
=	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
ifFormat	*(struct(enum(int,int,int,int,int)))
;	O
condNumFormats	int
=	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numIfTokens	int
;	O
}	O
else	O
{	O
condFormat	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
=	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
elseFormat	*(struct(enum(int,int,int,int,int)))
;	O
condNumFormats	int
=	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
cond	struct(*(struct(enum(int,int,int,int,int))),int,*(struct(enum(int,int,int,int,int))),int,struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int))
.	O
numElseTokens	int
;	O
}	O
alloced	int
=	O
condNumFormats	int
*	O
20	int
;	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
alloced	int
?	O
alloced	int
:	O
1	int
)	O
;	O
*	O
val	array(int)
=	O
'\0'	O
;	O
len	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
condNumFormats	int
;	O
i	int
++	O
)	O
{	O
thisItem	*(char)
=	O
singleSprintf	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(struct(int,int,int,int,*(void))),int)->(*(char))
(	O
h	*(struct)
,	O
condFormat	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
+	O
i	int
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
extCache	*(struct(int,int,int,int,*(void)))
,	O
element	array(int)
)	O
;	O
thisItemLen	int
=	O
strlen	(*(char))->(long)
(	O
thisItem	*(char)
)	O
;	O
if	O
(	O
(	O
thisItemLen	int
+	O
len	int
)	O
>=	O
alloced	int
)	O
{	O
alloced	int
=	O
(	O
thisItemLen	int
+	O
len	int
)	O
+	O
200	int
;	O
val	array(int)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
val	array(int)
,	O
alloced	int
)	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
val	array(int)
,	O
thisItem	*(char)
)	O
;	O
len	int
+=	O
thisItemLen	int
;	O
free	(*(void))->(void)
(	O
thisItem	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
PTOK_ARRAY	int
:	O
numElements	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
numTokens	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
[	O
i	int
]	O
.	O
type	enum(int,int,int,int)
!=	O
PTOK_TAG	int
||	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
arrayCount	int
||	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
justOne	int
)	O
continue	O
;	O
if	O
(	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
)	O
{	O
const	O
void	O
*	O
data	*(void)
;	O
if	O
(	O
getExtension	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*((*(struct(*`,int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int)),*(int),*(*(void)),*(int),*(struct(int,int,int,int,*(void))))->(int)
(	O
h	*(struct)
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
,	O
&	O
type	enum(int,int,int,int)
,	O
&	O
data	*(void)
,	O
&	O
numElements	int
,	O
extCache	*(struct(int,int,int,int,*(void)))
+	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
extNum	int
)	O
)	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
h	*(struct)
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
[	O
i	int
]	O
.	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
tag	int
.	O
tag	int
,	O
&	O
type	enum(int,int,int,int)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
val	array(int)
,	O
&	O
numElements	int
)	O
)	O
continue	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
RPM_STRING_ARRAY_TYPE	int
)	O
free	(*(void))->(void)
(	O
val	array(int)
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
numElements	int
==	O
-	O
1	int
)	O
{	O
val	array(int)
=	O
xstrdup	(*(char))->(*(char))
(	O
"(none)"	*(char)
)	O
;	O
}	O
else	O
{	O
alloced	int
=	O
numElements	int
*	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
numTokens	int
*	O
20	int
;	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
alloced	int
)	O
;	O
*	O
val	array(int)
=	O
'\0'	O
;	O
len	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numElements	int
;	O
j	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
numTokens	int
;	O
i	int
++	O
)	O
{	O
thisItem	*(char)
=	O
singleSprintf	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(struct(int,int,int,int,*(void))),int)->(*(char))
(	O
h	*(struct)
,	O
token	*(struct(enum(int,int,int,int,int),union(struct(*(struct`),int),struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct`),int,*(struct`),int,struct(*`,int,int,int,int,*`,*`,int)))))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
array	struct(*(struct(enum(int,int,int,int,int))),int)
.	O
format	*(char)
+	O
i	int
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
extCache	*(struct(int,int,int,int,*(void)))
,	O
j	int
)	O
;	O
thisItemLen	int
=	O
strlen	(*(char))->(long)
(	O
thisItem	*(char)
)	O
;	O
if	O
(	O
(	O
thisItemLen	int
+	O
len	int
)	O
>=	O
alloced	int
)	O
{	O
alloced	int
=	O
(	O
thisItemLen	int
+	O
len	int
)	O
+	O
200	int
;	O
val	array(int)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
val	array(int)
,	O
alloced	int
)	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
val	array(int)
,	O
thisItem	*(char)
)	O
;	O
len	int
+=	O
thisItemLen	int
;	O
free	(*(void))->(void)
(	O
thisItem	*(char)
)	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
struct	O
extensionCache	struct(int,int,int,int,*(void))
*	O
allocateExtensionCache	(*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))->(*(struct(int,int,int,int,*(void))))
(	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
)	O
{	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
!=	O
HEADER_EXT_LAST	int
)	O
{	O
i	int
++	O
;	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
==	O
HEADER_EXT_MORE	int
)	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
more	*(struct(enum(int,int,int,int),*(char)))
;	O
else	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
++	O
;	O
}	O
return	O
xcalloc	(long,long)->(*(void))
(	O
i	int
,	O
sizeof	O
(	O
struct	O
extensionCache	struct(int,int,int,int,*(void))
)	O
)	O
;	O
}	O
static	O
void	O
freeExtensionCache	(*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(struct(int,int,int,int,*(void))))->(void)
(	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
struct	O
extensionCache	struct(int,int,int,int,*(void))
*	O
cache	*(struct(int,int,int,int,*(void)))
)	O
{	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
!=	O
HEADER_EXT_LAST	int
)	O
{	O
if	O
(	O
cache	*(struct(int,int,int,int,*(void)))
[	O
i	int
]	O
.	O
freeit	int
)	O
free	(*(void))->(void)
(	O
(	O
void	O
*	O
)	O
cache	*(struct(int,int,int,int,*(void)))
[	O
i	int
]	O
.	O
data	*(void)
)	O
;	O
i	int
++	O
;	O
if	O
(	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
type	enum(int,int,int,int)
==	O
HEADER_EXT_MORE	int
)	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
=	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
->	O
u	union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))
.	O
more	*(struct(enum(int,int,int,int),*(char)))
;	O
else	O
ext	*((*(struct(*(struct`),int,int,int,int)),*(int),*(*(void)),*(int),*(int))->(int))
++	O
;	O
}	O
free	(*(void))->(void)
(	O
cache	*(struct(int,int,int,int,*(void)))
)	O
;	O
}	O
char	O
*	O
headerSprintf	(*(struct),*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(char)))->(*(char))
(	O
Header	*(struct)
h	*(struct)
,	O
const	O
char	O
*	O
origFmt	*(char)
,	O
const	O
struct	O
headerTagTableEntry	struct(*(char),int)
*	O
tags	*(struct(*(char),int))
,	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
*	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
const	O
char	O
*	O
*	O
error	*(*(char))
)	O
{	O
char	O
*	O
fmtString	*(char)
;	O
struct	O
sprintfToken	struct(enum(int,int,int,int,int),union(struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int),struct(*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),int,int,int,int,*(char),*(char),int),struct(*(char),int),struct(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`))),int,struct(*((*`,*`,*`,*`,*`)->(int)),int,int,int,int,*(char),*(char),int))))
*	O
format	*(char)
;	O
int	O
numTokens	int
;	O
char	O
*	O
answer	*(char)
;	O
const	O
char	O
*	O
piece	*(char)
;	O
int	O
answerLength	int
;	O
int	O
answerAlloced	int
;	O
int	O
pieceLength	int
;	O
int	O
i	int
;	O
struct	O
extensionCache	struct(int,int,int,int,*(void))
*	O
extCache	*(struct(int,int,int,int,*(void)))
;	O
fmtString	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
origFmt	*(char)
)	O
;	O
if	O
(	O
parseFormat	(*(char),*(struct(*(char),int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(*(struct(enum(int,int,int,int,int),union(struct`,struct`,struct`,struct`)))),*(int),*(*(char)),int,*(*(char)))->(int)
(	O
fmtString	*(char)
,	O
tags	*(struct(*(char),int))
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
&	O
format	*(char)
,	O
&	O
numTokens	int
,	O
NULL	O
,	O
PARSER_BEGIN	int
,	O
error	*(*(char))
)	O
)	O
{	O
free	(*(void))->(void)
(	O
fmtString	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
extCache	*(struct(int,int,int,int,*(void)))
=	O
allocateExtensionCache	(*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))))->(*(struct(int,int,int,int,*(void))))
(	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
)	O
;	O
answerAlloced	int
=	O
1024	int
;	O
answerLength	int
=	O
0	int
;	O
answer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
answerAlloced	int
)	O
;	O
*	O
answer	*(char)
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numTokens	int
;	O
i	int
++	O
)	O
{	O
piece	*(char)
=	O
singleSprintf	(*(struct(*(struct(struct`,*`,int)),int,int,int,int)),*(struct(enum(int,int,int,int,int),union(struct(*`,int),struct(*`,int,int,int,int,*`,*`,int),struct(*`,int),struct(*`,int,*`,int,struct`)))),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(struct(int,int,int,int,*(void))),int)->(*(char))
(	O
h	*(struct)
,	O
format	*(char)
+	O
i	int
,	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
extCache	*(struct(int,int,int,int,*(void)))
,	O
0	int
)	O
;	O
if	O
(	O
piece	*(char)
)	O
{	O
pieceLength	int
=	O
strlen	(*(char))->(long)
(	O
piece	*(char)
)	O
;	O
if	O
(	O
(	O
answerLength	int
+	O
pieceLength	int
)	O
>=	O
answerAlloced	int
)	O
{	O
while	O
(	O
(	O
answerLength	int
+	O
pieceLength	int
)	O
>=	O
answerAlloced	int
)	O
answerAlloced	int
+=	O
1024	int
;	O
answer	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
answer	*(char)
,	O
answerAlloced	int
)	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
answer	*(char)
,	O
piece	*(char)
)	O
;	O
answerLength	int
+=	O
pieceLength	int
;	O
free	(*(void))->(void)
(	O
(	O
void	O
*	O
)	O
piece	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
fmtString	*(char)
)	O
;	O
freeExtensionCache	(*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`)))),*(struct(int,int,int,int,*(void))))->(void)
(	O
extensions	*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct(enum(int,int,int,int),*`,union`)))))
,	O
extCache	*(struct(int,int,int,int,*(void)))
)	O
;	O
free	(*(void))->(void)
(	O
format	*(char)
)	O
;	O
return	O
answer	*(char)
;	O
}	O
static	O
char	O
*	O
octalFormat	(int,*(void),*(char),int,int)->(*(char))
(	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
formatPrefix	*(char)
,	O
int	O
padding	int
,	O
int	O
element	array(int)
)	O
{	O
char	O
*	O
val	array(int)
;	O
if	O
(	O
type	enum(int,int,int,int)
!=	O
RPM_INT32_TYPE	int
)	O
{	O
val	array(int)
=	O
xstrdup	(*(char))->(*(char))
(	O
_	O
(	O
"(not a number)"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
20	int
+	O
padding	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
formatPrefix	*(char)
,	O
"o"	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
formatPrefix	*(char)
,	O
*	O
(	O
(	O
int_32	int
*	O
)	O
data	*(void)
)	O
)	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
char	O
*	O
hexFormat	(int,*(void),*(char),int,int)->(*(char))
(	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
formatPrefix	*(char)
,	O
int	O
padding	int
,	O
int	O
element	array(int)
)	O
{	O
char	O
*	O
val	array(int)
;	O
if	O
(	O
type	enum(int,int,int,int)
!=	O
RPM_INT32_TYPE	int
)	O
{	O
val	array(int)
=	O
xstrdup	(*(char))->(*(char))
(	O
_	O
(	O
"(not a number)"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
20	int
+	O
padding	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
formatPrefix	*(char)
,	O
"x"	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
formatPrefix	*(char)
,	O
*	O
(	O
(	O
int_32	int
*	O
)	O
data	*(void)
)	O
)	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
char	O
*	O
realDateFormat	(int,*(void),*(char),int,int,*(char))->(*(char))
(	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
formatPrefix	*(char)
,	O
int	O
padding	int
,	O
int	O
element	array(int)
,	O
char	O
*	O
strftimeFormat	*(char)
)	O
{	O
char	O
*	O
val	array(int)
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tstruct	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
;	O
char	O
buf	*(char)
[	O
50	int
]	O
;	O
if	O
(	O
type	enum(int,int,int,int)
!=	O
RPM_INT32_TYPE	int
)	O
{	O
val	array(int)
=	O
xstrdup	(*(char))->(*(char))
(	O
_	O
(	O
"(not a number)"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
val	array(int)
=	O
xmalloc	(long)->(*(void))
(	O
50	int
+	O
padding	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
formatPrefix	*(char)
,	O
"s"	*(char)
)	O
;	O
{	O
time_t	long
dateint	long
=	O
*	O
(	O
(	O
int_32	int
*	O
)	O
data	*(void)
)	O
;	O
tstruct	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
dateint	long
)	O
;	O
}	O
(	O
void	O
)	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
-	O
1	int
,	O
strftimeFormat	*(char)
,	O
tstruct	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
val	array(int)
,	O
formatPrefix	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
return	O
val	array(int)
;	O
}	O
static	O
char	O
*	O
dateFormat	(int,*(void),*(char),int,int)->(*(char))
(	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
formatPrefix	*(char)
,	O
int	O
padding	int
,	O
int	O
element	array(int)
)	O
{	O
return	O
realDateFormat	(int,*(void),*(char),int,int,*(char))->(*(char))
(	O
type	enum(int,int,int,int)
,	O
data	*(void)
,	O
formatPrefix	*(char)
,	O
padding	int
,	O
element	array(int)
,	O
"%c"	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
dayFormat	(int,*(void),*(char),int,int)->(*(char))
(	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
formatPrefix	*(char)
,	O
int	O
padding	int
,	O
int	O
element	array(int)
)	O
{	O
return	O
realDateFormat	(int,*(void),*(char),int,int,*(char))->(*(char))
(	O
type	enum(int,int,int,int)
,	O
data	*(void)
,	O
formatPrefix	*(char)
,	O
padding	int
,	O
element	array(int)
,	O
"%a %b %d %Y"	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
shescapeFormat	(int,*(void),*(char),int,int)->(*(char))
(	O
int_32	int
type	enum(int,int,int,int)
,	O
const	O
void	O
*	O
data	*(void)
,	O
char	O
*	O
formatPrefix	*(char)
,	O
int	O
padding	int
,	O
int	O
element	array(int)
)	O
{	O
char	O
*	O
result	*(char)
,	O
*	O
dst	*(char)
,	O
*	O
src	*(*(char))
,	O
*	O
buf	*(char)
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
RPM_INT32_TYPE	int
)	O
{	O
result	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
padding	int
+	O
20	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
formatPrefix	*(char)
,	O
"d"	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
result	*(char)
,	O
formatPrefix	*(char)
,	O
*	O
(	O
(	O
int_32	int
*	O
)	O
data	*(void)
)	O
)	O
;	O
}	O
else	O
{	O
buf	*(char)
=	O
alloca	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
data	*(void)
)	O
+	O
padding	int
+	O
2	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
formatPrefix	*(char)
,	O
"s"	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
formatPrefix	*(char)
,	O
data	*(void)
)	O
;	O
result	*(char)
=	O
dst	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
*	O
4	int
+	O
3	int
)	O
;	O
*	O
dst	*(char)
++	O
=	O
'\''	O
;	O
for	O
(	O
src	*(*(char))
=	O
buf	*(char)
;	O
*	O
src	*(*(char))
;	O
src	*(*(char))
++	O
)	O
{	O
if	O
(	O
*	O
src	*(*(char))
==	O
'\''	O
)	O
{	O
*	O
dst	*(char)
++	O
=	O
'\''	O
;	O
*	O
dst	*(char)
++	O
=	O
'\\'	O
;	O
*	O
dst	*(char)
++	O
=	O
'\''	O
;	O
*	O
dst	*(char)
++	O
=	O
'\''	O
;	O
}	O
else	O
{	O
*	O
dst	*(char)
++	O
=	O
*	O
src	*(*(char))
;	O
}	O
}	O
*	O
dst	*(char)
++	O
=	O
'\''	O
;	O
*	O
dst	*(char)
=	O
'\0'	O
;	O
}	O
return	O
result	*(char)
;	O
}	O
const	O
struct	O
headerSprintfExtension	struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct),*(int),*(*(void)),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*`,*`,int,int)->(*`)),*((*`,*`,*`,*`,*`)->(int)),*(struct`))))))
headerDefaultFormats	array(struct(enum(int,int,int,int),*(char),union(*(void),*((int,*(void),*(char),int,int)->(*(char))),*((*(struct`),*(int),*(*`),*(int),*(int))->(int)),*(struct(enum(int,int,int,int),*(char),union(*`,*`,*`,*`))))))
[	O
]	O
=	O
{	O
{	O
HEADER_EXT_FORMAT	int
,	O
"octal"	*(char)
,	O
{	O
octalFormat	(int,*(void),*(char),int,int)->(*(char))
}	O
}	O
,	O
{	O
HEADER_EXT_FORMAT	int
,	O
"hex"	*(char)
,	O
{	O
hexFormat	(int,*(void),*(char),int,int)->(*(char))
}	O
}	O
,	O
{	O
HEADER_EXT_FORMAT	int
,	O
"date"	*(char)
,	O
{	O
dateFormat	(int,*(void),*(char),int,int)->(*(char))
}	O
}	O
,	O
{	O
HEADER_EXT_FORMAT	int
,	O
"day"	*(char)
,	O
{	O
dayFormat	(int,*(void),*(char),int,int)->(*(char))
}	O
}	O
,	O
{	O
HEADER_EXT_FORMAT	int
,	O
"shescape"	*(char)
,	O
{	O
shescapeFormat	(int,*(void),*(char),int,int)->(*(char))
}	O
}	O
,	O
{	O
HEADER_EXT_LAST	int
,	O
NULL	O
,	O
{	O
NULL	O
}	O
}	O
}	O
;	O
void	O
headerCopyTags	(*(struct),*(struct),*(int))->(void)
(	O
Header	*(struct)
headerFrom	*(struct)
,	O
Header	*(struct)
headerTo	*(struct)
,	O
int	O
*	O
tagstocopy	*(int)
)	O
{	O
int	O
*	O
p	*(void)
;	O
if	O
(	O
headerFrom	*(struct)
==	O
headerTo	*(struct)
)	O
return	O
;	O
for	O
(	O
p	*(void)
=	O
tagstocopy	*(int)
;	O
*	O
p	*(void)
!=	O
0	int
;	O
p	*(void)
++	O
)	O
{	O
char	O
*	O
s	*(*(char))
;	O
int	O
type	enum(int,int,int,int)
,	O
count	long
;	O
if	O
(	O
headerIsEntry	(*(struct),int)->(int)
(	O
headerTo	*(struct)
,	O
*	O
p	*(void)
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
headerGetEntry	(*(struct),int,*(int),*(*(void)),*(int))->(int)
(	O
headerFrom	*(struct)
,	O
*	O
p	*(void)
,	O
&	O
type	enum(int,int,int,int)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	*(*(char))
,	O
&	O
count	long
)	O
)	O
continue	O
;	O
headerAddEntry	(*(struct),int,int,*(void),int)->(int)
(	O
headerTo	*(struct)
,	O
*	O
p	*(void)
,	O
type	enum(int,int,int,int)
,	O
s	*(*(char))
,	O
count	long
)	O
;	O
if	O
(	O
s	*(*(char))
!=	O
NULL	O
&&	O
(	O
type	enum(int,int,int,int)
==	O
RPM_STRING_ARRAY_TYPE	int
||	O
type	enum(int,int,int,int)
==	O
RPM_I18NSTRING_TYPE	int
)	O
)	O
free	(*(void))->(void)
(	O
s	*(*(char))
)	O
;	O
}	O
}	O
