static	O
volatile	O
int	O
_argp_hang	int
;	O
static	O
const	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
argp_default_options	array(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"help"	*(char)
,	O
'?'	O
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"give this help list"	*(char)
)	O
,	O
-	O
1	int
}	O
,	O
{	O
"usage"	*(char)
,	O
OPT_USAGE	O
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"give a short usage message"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"program-name"	*(char)
,	O
OPT_PROGNAME	O
,	O
N_	O
(	O
"NAME"	*(char)
)	O
,	O
OPTION_HIDDEN	int
,	O
N_	O
(	O
"set the program name"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
"HANG"	*(char)
,	O
OPT_HANG	O
,	O
N_	O
(	O
"SECS"	*(char)
)	O
,	O
OPTION_ARG_OPTIONAL	int
|	O
OPTION_HIDDEN	int
,	O
N_	O
(	O
"hang for SECS seconds (default 3600)"	*(char)
)	O
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
error_t	int
argp_default_parser	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'?'	O
:	O
__argp_state_help	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
state	*(int)
,	O
state	*(int)
->	O
out_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ARGP_HELP_STD_HELP	O
)	O
;	O
break	O
;	O
case	O
OPT_USAGE	O
:	O
__argp_state_help	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
state	*(int)
,	O
state	*(int)
->	O
out_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ARGP_HELP_USAGE	int
|	O
ARGP_HELP_EXIT_OK	int
)	O
;	O
break	O
;	O
case	O
OPT_PROGNAME	O
:	O
program_invocation_name	*(char)
=	O
arg	*(char)
;	O
state	*(int)
->	O
name	*(char)
=	O
__argp_base_name	O
(	O
arg	*(char)
)	O
;	O
program_invocation_short_name	*(char)
=	O
state	*(int)
->	O
name	*(char)
;	O
if	O
(	O
(	O
state	*(int)
->	O
flags	int
&	O
(	O
ARGP_PARSE_ARGV0	int
|	O
ARGP_NO_ERRS	int
)	O
)	O
==	O
ARGP_PARSE_ARGV0	int
)	O
state	*(int)
->	O
argv	*(*(char))
[	O
0	int
]	O
=	O
arg	*(char)
;	O
break	O
;	O
case	O
OPT_HANG	O
:	O
_argp_hang	int
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
?	O
arg	*(char)
:	O
"3600"	*(char)
)	O
;	O
while	O
(	O
_argp_hang	int
--	O
>	O
0	int
)	O
__sleep	O
(	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
EBADKEY	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp_default_argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(char),*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
argp_default_options	array(struct(*(char),int,*(char),int,*(char),int))
,	O
&	O
argp_default_parser	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"libc"	*(char)
}	O
;	O
static	O
const	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
argp_version_options	array(struct(*(char),int,*(char),int,*(char),int))
[	O
]	O
=	O
{	O
{	O
"version"	*(char)
,	O
'V'	O
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"print program version"	*(char)
)	O
,	O
-	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
error_t	int
argp_version_parser	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
(	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'V'	O
:	O
if	O
(	O
argp_program_version_hook	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void))))->(void))
)	O
(	O
*	O
argp_program_version_hook	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void))))->(void))
)	O
(	O
state	*(int)
->	O
out_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
state	*(int)
)	O
;	O
else	O
if	O
(	O
argp_program_version	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
state	*(int)
->	O
out_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
argp_program_version	*(char)
)	O
;	O
else	O
__argp_error	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(char))->(void)
(	O
state	*(int)
,	O
"%s"	*(char)
,	O
dgettext	(*(char),*(char))->(*(char))
(	O
state	*(int)
->	O
root_argp	*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char)))
->	O
argp_domain	*(char)
,	O
"(PROGRAM ERROR) No version known!?"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
(	O
state	*(int)
->	O
flags	int
&	O
ARGP_NO_EXIT	int
)	O
)	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
EBADKEY	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
argp_version_argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(char),*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))
=	O
{	O
argp_version_options	array(struct(*(char),int,*(char),int,*(char),int))
,	O
&	O
argp_version_parser	(int,*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"libc"	*(char)
}	O
;	O
static	O
int	O
find_long_option	(*(struct(*(char),int,*(int),int)),*(char))->(int)
(	O
struct	O
option	struct(*(char),int,*(int),int)
*	O
long_options	*(struct(*(char),int,*(int),int))
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
option	struct(*(char),int,*(int),int)
*	O
l	*(struct(*(char),int,*(int),int))
=	O
long_options	*(struct(*(char),int,*(int),int))
;	O
while	O
(	O
l	*(struct(*(char),int,*(int),int))
->	O
name	*(char)
!=	O
NULL	O
)	O
if	O
(	O
name	*(char)
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
l	*(struct(*(char),int,*(int),int))
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
l	*(struct(*(char),int,*(int),int))
-	O
long_options	*(struct(*(char),int,*(int),int))
;	O
else	O
l	*(struct(*(char),int,*(int),int))
++	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
return	O
l	*(struct(*(char),int,*(int),int))
-	O
long_options	*(struct(*(char),int,*(int),int))
;	O
else	O
return	O
-	O
1	int
;	O
}	O
struct	O
group	int
{	O
argp_parser_t	*((int,*(char),*(struct))->(int))
parser	*((int,*(char),*(struct))->(int))
;	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
;	O
char	O
*	O
short_end	*(char)
;	O
unsigned	O
args_processed	int
;	O
struct	O
group	int
*	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
unsigned	O
parent_index	int
;	O
void	O
*	O
input	*(void)
,	O
*	O
*	O
child_inputs	*(*(void))
;	O
void	O
*	O
hook	*(void)
;	O
}	O
;	O
static	O
error_t	int
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
struct	O
group	int
*	O
group	int
,	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
,	O
int	O
key	int
,	O
char	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
group	int
->	O
parser	*((int,*(char),*(struct))->(int))
)	O
{	O
error_t	int
err	int
;	O
state	*(int)
->	O
hook	*(void)
=	O
group	int
->	O
hook	*(void)
;	O
state	*(int)
->	O
input	*(void)
=	O
group	int
->	O
input	*(void)
;	O
state	*(int)
->	O
child_inputs	*(*(void))
=	O
group	int
->	O
child_inputs	*(*(void))
;	O
state	*(int)
->	O
arg_num	int
=	O
group	int
->	O
args_processed	int
;	O
err	int
=	O
(	O
*	O
group	int
->	O
parser	*((int,*(char),*(struct))->(int))
)	O
(	O
key	int
,	O
arg	*(char)
,	O
state	*(int)
)	O
;	O
group	int
->	O
hook	*(void)
=	O
state	*(int)
->	O
hook	*(void)
;	O
return	O
err	int
;	O
}	O
else	O
return	O
EBADKEY	O
;	O
}	O
struct	O
parser	*((int,*(char),*(struct))->(int))
{	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
;	O
char	O
*	O
short_opts	*(char)
;	O
struct	O
option	struct(*(char),int,*(int),int)
*	O
long_opts	*(struct(*(char),int,*(int),int))
;	O
struct	O
_getopt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
;	O
struct	O
group	int
*	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
struct	O
group	int
*	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
void	O
*	O
*	O
child_inputs	*(*(void))
;	O
int	O
try_getopt	int
;	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
state	*(int)
;	O
void	O
*	O
storage	*(void)
;	O
}	O
;	O
struct	O
parser_convert_state	struct(*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),*(struct(*(char),int,*(int),int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),*(*(void)),int,struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void)),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void)))
{	O
struct	O
parser	*((int,*(char),*(struct))->(int))
*	O
parser	*((int,*(char),*(struct))->(int))
;	O
char	O
*	O
short_end	*(char)
;	O
struct	O
option	struct(*(char),int,*(int),int)
*	O
long_end	*(struct(*(char),int,*(int),int))
;	O
void	O
*	O
*	O
child_inputs_end	*(*(void))
;	O
}	O
;	O
static	O
struct	O
group	int
*	O
convert_options	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),int,*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,struct`,*`,*`,*`,int,struct`,*`)),*(char),*(struct(*`,int,*`,int)),*(*(void)))))->(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))))
(	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
struct	O
group	int
*	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
,	O
unsigned	O
parent_index	int
,	O
struct	O
group	int
*	O
group	int
,	O
struct	O
parser_convert_state	struct(*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),*(struct(*(char),int,*(int),int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),*(*(void)),int,struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void)),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void)))
*	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
)	O
{	O
const	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
*	O
real	*(struct(*(char),int,*(char),int,*(char),int))
=	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
options	*(struct(*(char),int,*(char),int,*(char),int))
;	O
const	O
struct	O
argp_child	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(char),int)
*	O
children	*(struct)
=	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
children	*(struct)
;	O
if	O
(	O
real	*(struct(*(char),int,*(char),int,*(char),int))
||	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
parser	*((int,*(char),*(struct))->(int))
)	O
{	O
const	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
*	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
;	O
if	O
(	O
real	*(struct(*(char),int,*(char),int,*(char),int))
)	O
for	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
=	O
real	*(struct(*(char),int,*(char),int,*(char),int))
;	O
!	O
__option_is_end	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
)	O
;	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
++	O
)	O
{	O
if	O
(	O
!	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
->	O
flags	int
&	O
OPTION_ALIAS	int
)	O
)	O
real	*(struct(*(char),int,*(char),int,*(char),int))
=	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
;	O
if	O
(	O
!	O
(	O
real	*(struct(*(char),int,*(char),int,*(char),int))
->	O
flags	int
&	O
OPTION_DOC	int
)	O
)	O
{	O
if	O
(	O
__option_is_short	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
)	O
)	O
{	O
*	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
short_end	*(char)
++	O
=	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
->	O
key	int
;	O
if	O
(	O
real	*(struct(*(char),int,*(char),int,*(char),int))
->	O
arg	*(char)
)	O
{	O
*	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
short_end	*(char)
++	O
=	O
':'	O
;	O
if	O
(	O
real	*(struct(*(char),int,*(char),int,*(char),int))
->	O
flags	int
&	O
OPTION_ARG_OPTIONAL	int
)	O
*	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
short_end	*(char)
++	O
=	O
':'	O
;	O
}	O
*	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
short_end	*(char)
=	O
'\0'	O
;	O
}	O
if	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
->	O
name	*(char)
&&	O
find_long_option	(*(struct(*(char),int,*(int),int)),*(char))->(int)
(	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
parser	*((int,*(char),*(struct))->(int))
->	O
long_opts	*(struct(*(char),int,*(int),int))
,	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
->	O
name	*(char)
)	O
<	O
0	int
)	O
{	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
long_end	*(struct(*(char),int,*(int),int))
->	O
name	*(char)
=	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
->	O
name	*(char)
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
long_end	*(struct(*(char),int,*(int),int))
->	O
has_arg	int
=	O
(	O
real	*(struct(*(char),int,*(char),int,*(char),int))
->	O
arg	*(char)
?	O
(	O
real	*(struct(*(char),int,*(char),int,*(char),int))
->	O
flags	int
&	O
OPTION_ARG_OPTIONAL	int
?	O
optional_argument	int
:	O
required_argument	int
)	O
:	O
no_argument	int
)	O
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
long_end	*(struct(*(char),int,*(int),int))
->	O
flag	*(int)
=	O
0	int
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
long_end	*(struct(*(char),int,*(int),int))
->	O
val	int
=	O
(	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
->	O
key	int
?	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
->	O
key	int
:	O
real	*(struct(*(char),int,*(char),int,*(char),int))
->	O
key	int
)	O
&	O
USER_MASK	O
)	O
+	O
(	O
(	O
(	O
group	int
-	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
)	O
+	O
1	int
)	O
<<	O
USER_BITS	O
)	O
;	O
(	O
++	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
long_end	*(struct(*(char),int,*(int),int))
)	O
->	O
name	*(char)
=	O
NULL	O
;	O
}	O
}	O
}	O
group	int
->	O
parser	*((int,*(char),*(struct))->(int))
=	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
parser	*((int,*(char),*(struct))->(int))
;	O
group	int
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
;	O
group	int
->	O
short_end	*(char)
=	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
short_end	*(char)
;	O
group	int
->	O
args_processed	int
=	O
0	int
;	O
group	int
->	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
=	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
->	O
parent_index	int
=	O
parent_index	int
;	O
group	int
->	O
input	*(void)
=	O
0	int
;	O
group	int
->	O
hook	*(void)
=	O
0	int
;	O
group	int
->	O
child_inputs	*(*(void))
=	O
0	int
;	O
if	O
(	O
children	*(struct)
)	O
{	O
unsigned	O
num_children	int
=	O
0	int
;	O
while	O
(	O
children	*(struct)
[	O
num_children	int
]	O
.	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
num_children	int
++	O
;	O
group	int
->	O
child_inputs	*(*(void))
=	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
child_inputs_end	*(*(void))
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
->	O
child_inputs_end	*(*(void))
+=	O
num_children	int
;	O
}	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
=	O
group	int
++	O
;	O
}	O
else	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
=	O
0	int
;	O
if	O
(	O
children	*(struct)
)	O
{	O
unsigned	O
index	(*(char),int)->(*(char))
=	O
0	int
;	O
while	O
(	O
children	*(struct)
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
group	int
=	O
convert_options	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),int,*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,struct`,*`,*`,*`,int,struct`,*`)),*(char),*(struct(*`,int,*`,int)),*(*(void)))))->(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))))
(	O
children	*(struct)
++	O
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
,	O
index	(*(char),int)->(*(char))
++	O
,	O
group	int
,	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
)	O
;	O
}	O
return	O
group	int
;	O
}	O
static	O
void	O
parser_convert	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int)->(void)
(	O
struct	O
parser	*((int,*(char),*(struct))->(int))
*	O
parser	*((int,*(char),*(struct))->(int))
,	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
int	O
flags	int
)	O
{	O
struct	O
parser_convert_state	struct(*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),*(struct(*(char),int,*(int),int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),*(*(void)),int,struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void)),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void)))
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
.	O
parser	*((int,*(char),*(struct))->(int))
=	O
parser	*((int,*(char),*(struct))->(int))
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
.	O
short_end	*(char)
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
short_opts	*(char)
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
.	O
long_end	*(struct(*(char),int,*(int),int))
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
long_opts	*(struct(*(char),int,*(int),int))
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
.	O
child_inputs_end	*(*(void))
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
child_inputs	*(*(void))
;	O
if	O
(	O
flags	int
&	O
ARGP_IN_ORDER	int
)	O
*	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
.	O
short_end	*(char)
++	O
=	O
'-'	O
;	O
else	O
if	O
(	O
flags	int
&	O
ARGP_NO_ARGS	int
)	O
*	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
.	O
short_end	*(char)
++	O
=	O
'+'	O
;	O
*	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
.	O
short_end	*(char)
=	O
'\0'	O
;	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
.	O
long_end	*(struct(*(char),int,*(int),int))
->	O
name	*(char)
=	O
NULL	O
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
;	O
if	O
(	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
=	O
convert_options	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),int,*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,struct`,*`,*`,*`,int,struct`,*`)),*(char),*(struct(*`,int,*`,int)),*(*(void)))))->(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))))
(	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
0	int
,	O
0	int
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
,	O
&	O
cvt	*(struct(*(struct(*(struct`),*(char),*(struct`),struct(int,int,int,*`,int,*`,enum(int,int,int),int,int,int),*(struct`),*(struct`),*(*`),int,struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`),*(void))),*(char),*(struct(*(char),int,*(int),int)),*(*(void))))
)	O
;	O
else	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
}	O
struct	O
parser_sizes	struct(long,long,long,long)
{	O
size_t	long
short_len	long
;	O
size_t	long
long_len	long
;	O
size_t	long
num_groups	long
;	O
size_t	long
num_child_inputs	long
;	O
}	O
;	O
static	O
void	O
calc_sizes	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(struct(long,long,long,long)))->(void)
(	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
struct	O
parser_sizes	struct(long,long,long,long)
*	O
szs	*(struct(long,long,long,long))
)	O
{	O
const	O
struct	O
argp_child	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(char),int)
*	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
=	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
children	*(struct)
;	O
const	O
struct	O
argp_option	struct(*(char),int,*(char),int,*(char),int)
*	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
=	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
options	*(struct(*(char),int,*(char),int,*(char),int))
;	O
if	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
||	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
parser	*((int,*(char),*(struct))->(int))
)	O
{	O
szs	*(struct(long,long,long,long))
->	O
num_groups	long
++	O
;	O
if	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
)	O
{	O
int	O
num_opts	int
=	O
0	int
;	O
while	O
(	O
!	O
__option_is_end	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
++	O
)	O
)	O
num_opts	int
++	O
;	O
szs	*(struct(long,long,long,long))
->	O
short_len	long
+=	O
num_opts	int
*	O
3	int
;	O
szs	*(struct(long,long,long,long))
->	O
long_len	long
+=	O
num_opts	int
;	O
}	O
}	O
if	O
(	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
)	O
while	O
(	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
{	O
calc_sizes	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(struct(long,long,long,long)))->(void)
(	O
(	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
++	O
)	O
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
szs	*(struct(long,long,long,long))
)	O
;	O
szs	*(struct(long,long,long,long))
->	O
num_child_inputs	long
++	O
;	O
}	O
}	O
static	O
error_t	int
parser_init	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(void))->(int)
(	O
struct	O
parser	*((int,*(char),*(struct))->(int))
*	O
parser	*((int,*(char),*(struct))->(int))
,	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
flags	int
,	O
void	O
*	O
input	*(void)
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
struct	O
group	int
*	O
group	int
;	O
struct	O
parser_sizes	struct(long,long,long,long)
szs	*(struct(long,long,long,long))
;	O
struct	O
_getopt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
=	O
_GETOPT_DATA_INITIALIZER	O
;	O
char	O
*	O
storage	*(void)
;	O
size_t	long
glen	long
,	O
gsum	long
;	O
size_t	long
clen	long
,	O
csum	long
;	O
size_t	long
llen	long
,	O
lsum	long
;	O
size_t	long
slen	long
,	O
ssum	long
;	O
szs	*(struct(long,long,long,long))
.	O
short_len	long
=	O
(	O
flags	int
&	O
ARGP_NO_ARGS	int
)	O
?	O
0	int
:	O
1	int
;	O
szs	*(struct(long,long,long,long))
.	O
long_len	long
=	O
0	int
;	O
szs	*(struct(long,long,long,long))
.	O
num_groups	long
=	O
0	int
;	O
szs	*(struct(long,long,long,long))
.	O
num_child_inputs	long
=	O
0	int
;	O
if	O
(	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
calc_sizes	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(struct(long,long,long,long)))->(void)
(	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
&	O
szs	*(struct(long,long,long,long))
)	O
;	O
glen	long
=	O
(	O
szs	*(struct(long,long,long,long))
.	O
num_groups	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
group	int
)	O
;	O
clen	long
=	O
szs	*(struct(long,long,long,long))
.	O
num_child_inputs	long
*	O
sizeof	O
(	O
void	O
*	O
)	O
;	O
llen	long
=	O
(	O
szs	*(struct(long,long,long,long))
.	O
long_len	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
struct	O
option	struct(*(char),int,*(int),int)
)	O
;	O
slen	long
=	O
szs	*(struct(long,long,long,long))
.	O
short_len	long
+	O
1	int
;	O
gsum	long
=	O
glen	long
;	O
csum	long
=	O
alignto	O
(	O
gsum	long
+	O
clen	long
,	O
alignof	O
(	O
struct	O
option	struct(*(char),int,*(int),int)
)	O
)	O
;	O
lsum	long
=	O
csum	long
+	O
llen	long
;	O
ssum	long
=	O
lsum	long
+	O
slen	long
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
storage	*(void)
=	O
malloc	(long)->(*(void))
(	O
ssum	long
)	O
;	O
if	O
(	O
!	O
parser	*((int,*(char),*(struct))->(int))
->	O
storage	*(void)
)	O
return	O
ENOMEM	int
;	O
storage	*(void)
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
storage	*(void)
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
storage	*(void)
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
child_inputs	*(*(void))
=	O
(	O
void	O
*	O
*	O
)	O
(	O
storage	*(void)
+	O
gsum	long
)	O
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
long_opts	*(struct(*(char),int,*(int),int))
=	O
(	O
struct	O
option	struct(*(char),int,*(int),int)
*	O
)	O
(	O
storage	*(void)
+	O
csum	long
)	O
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
short_opts	*(char)
=	O
storage	*(void)
+	O
lsum	long
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
=	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
;	O
memset	(*(void),int,long)->(*(void))
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
child_inputs	*(*(void))
,	O
0	int
,	O
clen	long
)	O
;	O
parser_convert	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int)->(void)
(	O
parser	*((int,*(char),*(struct))->(int))
,	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
flags	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
0	int
,	O
sizeof	O
(	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
)	O
)	O
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
root_argp	*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char)))
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argc	int
=	O
argc	int
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argv	*(*(char))
=	O
argv	*(*(char))
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
flags	int
=	O
flags	int
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
err_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
out_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
=	O
0	int
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
pstate	*(void)
=	O
parser	*((int,*(char),*(struct))->(int))
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
try_getopt	int
=	O
1	int
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
<	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
)	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
->	O
input	*(void)
=	O
input	*(void)
;	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
<	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
&&	O
(	O
!	O
err	int
||	O
err	int
==	O
EBADKEY	O
)	O
;	O
group	int
++	O
)	O
{	O
if	O
(	O
group	int
->	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
)	O
group	int
->	O
input	*(void)
=	O
group	int
->	O
parent	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
->	O
child_inputs	*(*(void))
[	O
group	int
->	O
parent_index	int
]	O
;	O
if	O
(	O
!	O
group	int
->	O
parser	*((int,*(char),*(struct))->(int))
&&	O
group	int
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
children	*(struct)
&&	O
group	int
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
children	*(struct)
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
group	int
->	O
child_inputs	*(*(void))
[	O
0	int
]	O
=	O
group	int
->	O
input	*(void)
;	O
err	int
=	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
ARGP_KEY_INIT	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
err	int
=	O
0	int
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
flags	int
&	O
ARGP_NO_ERRS	int
)	O
{	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
opterr	int
=	O
0	int
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
flags	int
&	O
ARGP_PARSE_ARGV0	int
)	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argv	*(*(char))
--	O
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argc	int
++	O
;	O
}	O
else	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
opterr	int
=	O
1	int
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argv	*(*(char))
==	O
argv	*(*(char))
&&	O
argv	*(*(char))
[	O
0	int
]	O
)	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
name	*(char)
=	O
__argp_base_name	O
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
name	*(char)
=	O
__argp_short_program_name	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
parser_finalize	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),int,int,*(int))->(int)
(	O
struct	O
parser	*((int,*(char),*(struct))->(int))
*	O
parser	*((int,*(char),*(struct))->(int))
,	O
error_t	int
err	int
,	O
int	O
arg_ebadkey	int
,	O
int	O
*	O
end_index	*(int)
)	O
{	O
struct	O
group	int
*	O
group	int
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
&&	O
arg_ebadkey	int
)	O
err	int
=	O
0	int
;	O
if	O
(	O
!	O
err	int
)	O
{	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
==	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argc	int
)	O
{	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
<	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
&&	O
(	O
!	O
err	int
||	O
err	int
==	O
EBADKEY	O
)	O
;	O
group	int
++	O
)	O
if	O
(	O
group	int
->	O
args_processed	int
==	O
0	int
)	O
err	int
=	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
ARGP_KEY_NO_ARGS	int
,	O
0	int
)	O
;	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
-	O
1	int
;	O
group	int
>=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
&&	O
(	O
!	O
err	int
||	O
err	int
==	O
EBADKEY	O
)	O
;	O
group	int
--	O
)	O
err	int
=	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
ARGP_KEY_END	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
err	int
=	O
0	int
;	O
if	O
(	O
end_index	*(int)
)	O
*	O
end_index	*(int)
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
;	O
}	O
else	O
if	O
(	O
end_index	*(int)
)	O
*	O
end_index	*(int)
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
;	O
else	O
{	O
if	O
(	O
!	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
flags	int
&	O
ARGP_NO_ERRS	int
)	O
&&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
err_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
err_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
dgettext	(*(char),*(char))->(*(char))
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
argp_domain	*(char)
,	O
"%s: Too many arguments\n"	*(char)
)	O
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
name	*(char)
)	O
;	O
err	int
=	O
EBADKEY	O
;	O
}	O
}	O
if	O
(	O
err	int
)	O
{	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
__argp_state_help	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
err_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ARGP_HELP_STD_ERR	O
)	O
;	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
<	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
++	O
)	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
ARGP_KEY_ERROR	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
-	O
1	int
;	O
group	int
>=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
&&	O
(	O
!	O
err	int
||	O
err	int
==	O
EBADKEY	O
)	O
;	O
group	int
--	O
)	O
err	int
=	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
ARGP_KEY_SUCCESS	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
err	int
=	O
0	int
;	O
}	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
-	O
1	int
;	O
group	int
>=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
--	O
)	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
ARGP_KEY_FINI	int
,	O
0	int
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
err	int
=	O
EINVAL	int
;	O
free	(*(void))->(void)
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
storage	*(void)
)	O
;	O
return	O
err	int
;	O
}	O
static	O
error_t	int
parser_parse_arg	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),*(char))->(int)
(	O
struct	O
parser	*((int,*(char),*(struct))->(int))
*	O
parser	*((int,*(char),*(struct))->(int))
,	O
char	O
*	O
val	int
)	O
{	O
int	O
index	(*(char),int)->(*(char))
=	O
--	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
;	O
error_t	int
err	int
=	O
EBADKEY	O
;	O
struct	O
group	int
*	O
group	int
;	O
int	O
key	int
=	O
0	int
;	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
<	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
&&	O
err	int
==	O
EBADKEY	O
;	O
group	int
++	O
)	O
{	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
++	O
;	O
key	int
=	O
ARGP_KEY_ARG	int
;	O
err	int
=	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
key	int
,	O
val	int
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
{	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
--	O
;	O
key	int
=	O
ARGP_KEY_ARGS	int
;	O
err	int
=	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
key	int
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
err	int
)	O
{	O
if	O
(	O
key	int
==	O
ARGP_KEY_ARGS	int
)	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argc	int
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
>	O
index	(*(char),int)->(*(char))
)	O
(	O
--	O
group	int
)	O
->	O
args_processed	int
+=	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
-	O
index	(*(char),int)->(*(char))
)	O
;	O
else	O
parser	*((int,*(char),*(struct))->(int))
->	O
try_getopt	int
=	O
1	int
;	O
}	O
return	O
err	int
;	O
}	O
static	O
error_t	int
parser_parse_opt	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),int,*(char))->(int)
(	O
struct	O
parser	*((int,*(char),*(struct))->(int))
*	O
parser	*((int,*(char),*(struct))->(int))
,	O
int	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
,	O
char	O
*	O
val	int
)	O
{	O
int	O
group_key	int
=	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
>>	O
USER_BITS	O
;	O
error_t	int
err	int
=	O
EBADKEY	O
;	O
if	O
(	O
group_key	int
==	O
0	int
)	O
{	O
struct	O
group	int
*	O
group	int
;	O
char	O
*	O
short_index	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
short_opts	*(char)
,	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
)	O
;	O
if	O
(	O
short_index	*(char)
)	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
<	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
++	O
)	O
if	O
(	O
group	int
->	O
short_end	*(char)
>	O
short_index	*(char)
)	O
{	O
err	int
=	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
group	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optarg	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
else	O
err	int
=	O
group_parse	(*(struct(*((int,*`,*`)->(int)),*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),int,*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),int,*(void),*(*(void)),*(void))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),int,*(char))->(int)
(	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
[	O
group_key	int
-	O
1	int
]	O
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
<<	O
GROUP_BITS	O
)	O
>>	O
GROUP_BITS	O
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optarg	*(char)
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
{	O
static	O
const	O
char	O
bad_key_err	array(char)
[	O
]	O
=	O
N_	O
(	O
"(PROGRAM ERROR) Option should have been recognized!?"	*(char)
)	O
;	O
if	O
(	O
group_key	int
==	O
0	int
)	O
__argp_error	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(char))->(void)
(	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
"-%c: %s"	*(char)
,	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
,	O
dgettext	(*(char),*(char))->(*(char))
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
argp_domain	*(char)
,	O
bad_key_err	array(char)
)	O
)	O
;	O
else	O
{	O
struct	O
option	struct(*(char),int,*(int),int)
*	O
long_opt	*(struct(*(char),int,*(int),int))
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
long_opts	*(struct(*(char),int,*(int),int))
;	O
while	O
(	O
long_opt	*(struct(*(char),int,*(int),int))
->	O
val	int
!=	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
&&	O
long_opt	*(struct(*(char),int,*(int),int))
->	O
name	*(char)
)	O
long_opt	*(struct(*(char),int,*(int),int))
++	O
;	O
__argp_error	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))),*(char))->(void)
(	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
,	O
"--%s: %s"	*(char)
,	O
long_opt	*(struct(*(char),int,*(int),int))
->	O
name	*(char)
?	O
long_opt	*(struct(*(char),int,*(int),int))
->	O
name	*(char)
:	O
"???"	*(char)
,	O
dgettext	(*(char),*(char))->(*(char))
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
->	O
argp_domain	*(char)
,	O
bad_key_err	array(char)
)	O
)	O
;	O
}	O
}	O
return	O
err	int
;	O
}	O
static	O
error_t	int
parser_parse_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),*(int))->(int)
(	O
struct	O
parser	*((int,*(char),*(struct))->(int))
*	O
parser	*((int,*(char),*(struct))->(int))
,	O
int	O
*	O
arg_ebadkey	int
)	O
{	O
int	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
;	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
quoted	int
&&	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
<	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
quoted	int
)	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
quoted	int
=	O
0	int
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
try_getopt	int
&&	O
!	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
quoted	int
)	O
{	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optind	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optopt	int
=	O
KEY_END	O
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
flags	int
&	O
ARGP_LONG_ONLY	int
)	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
=	O
_getopt_long_only_r	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int),*(struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)))->(int)
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argc	int
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argv	*(*(char))
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
short_opts	*(char)
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
long_opts	*(struct(*(char),int,*(int),int))
,	O
0	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
)	O
;	O
else	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
=	O
_getopt_long_r	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int),*(struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)))->(int)
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argc	int
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argv	*(*(char))
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
short_opts	*(char)
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
long_opts	*(struct(*(char),int,*(int),int))
,	O
0	int
,	O
&	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
)	O
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optind	int
;	O
if	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
==	O
KEY_END	O
)	O
{	O
parser	*((int,*(char),*(struct))->(int))
->	O
try_getopt	int
=	O
0	int
;	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
>	O
1	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argv	*(*(char))
[	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
-	O
1	int
]	O
,	O
QUOTE	*(char)
)	O
==	O
0	int
)	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
quoted	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
;	O
}	O
else	O
if	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
==	O
KEY_ERR	char
&&	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optopt	int
!=	O
KEY_END	O
)	O
{	O
*	O
arg_ebadkey	int
=	O
0	int
;	O
return	O
EBADKEY	O
;	O
}	O
}	O
else	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
=	O
KEY_END	O
;	O
if	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
==	O
KEY_END	O
)	O
{	O
if	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
>=	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argc	int
||	O
(	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
flags	int
&	O
ARGP_NO_ARGS	int
)	O
)	O
{	O
*	O
arg_ebadkey	int
=	O
1	int
;	O
return	O
EBADKEY	O
;	O
}	O
else	O
{	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
=	O
KEY_ARG	int
;	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optarg	*(char)
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
argv	*(*(char))
[	O
parser	*((int,*(char),*(struct))->(int))
->	O
state	*(int)
.	O
next	int
++	O
]	O
;	O
}	O
}	O
if	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
==	O
KEY_ARG	int
)	O
err	int
=	O
parser_parse_arg	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),*(char))->(int)
(	O
parser	*((int,*(char),*(struct))->(int))
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optarg	*(char)
)	O
;	O
else	O
err	int
=	O
parser_parse_opt	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),int,*(char))->(int)
(	O
parser	*((int,*(char),*(struct))->(int))
,	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
,	O
parser	*((int,*(char),*(struct))->(int))
->	O
opt_data	struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int)
.	O
optarg	*(char)
)	O
;	O
if	O
(	O
err	int
==	O
EBADKEY	O
)	O
*	O
arg_ebadkey	int
=	O
(	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
==	O
KEY_END	O
||	O
opt	*(struct(*(char),int,*(char),int,*(char),int))
==	O
KEY_ARG	int
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
__argp_parse	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(int),*(void))->(int)
(	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
unsigned	O
flags	int
,	O
int	O
*	O
end_index	*(int)
,	O
void	O
*	O
input	*(void)
)	O
{	O
error_t	int
err	int
;	O
struct	O
parser	*((int,*(char),*(struct))->(int))
parser	*((int,*(char),*(struct))->(int))
;	O
int	O
arg_ebadkey	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
ARGP_PARSE_ARGV0	int
)	O
)	O
{	O
if	O
(	O
!	O
program_invocation_name	*(char)
)	O
program_invocation_name	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
if	O
(	O
!	O
program_invocation_short_name	*(char)
)	O
program_invocation_short_name	*(char)
=	O
__argp_base_name	O
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
ARGP_NO_HELP	int
)	O
)	O
{	O
struct	O
argp_child	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(char),int)
*	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
=	O
alloca	O
(	O
4	int
*	O
sizeof	O
(	O
struct	O
argp_child	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(char),int)
)	O
)	O
;	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
top_argp	*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char)))
=	O
alloca	O
(	O
sizeof	O
(	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
top_argp	*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char)))
,	O
0	int
,	O
sizeof	O
(	O
*	O
top_argp	*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char)))
)	O
)	O
;	O
top_argp	*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char)))
->	O
children	*(struct)
=	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
;	O
memset	(*(void),int,long)->(*(void))
(	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
,	O
0	int
,	O
4	int
*	O
sizeof	O
(	O
struct	O
argp_child	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(char),int)
)	O
)	O
;	O
if	O
(	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
(	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
++	O
)	O
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
;	O
(	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
++	O
)	O
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
&	O
argp_default_argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(char),*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))
;	O
if	O
(	O
argp_program_version	*(char)
||	O
argp_program_version_hook	*((*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void))))->(void))
)	O
(	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
++	O
)	O
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
&	O
argp_version_argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct(*`,int,*`,int,int,int,int,*`,*`,*`,*`,*`,*`,*`)))->(int)),*(char),*(char),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))
;	O
child	*(struct(*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),int,*(char),int))
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
0	int
;	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
=	O
top_argp	*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char)))
;	O
}	O
err	int
=	O
parser_init	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),int,*(*(char)),int,*(void))->(int)
(	O
&	O
parser	*((int,*(char),*(struct))->(int))
,	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
argc	int
,	O
argv	*(*(char))
,	O
flags	int
,	O
input	*(void)
)	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
while	O
(	O
!	O
err	int
)	O
err	int
=	O
parser_parse_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),*(int))->(int)
(	O
&	O
parser	*((int,*(char),*(struct))->(int))
,	O
&	O
arg_ebadkey	int
)	O
;	O
err	int
=	O
parser_finalize	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),*(char),*(struct(*`,int,*`,int)),struct(int,int,int,*(char),int,*(char),enum(int,int,int),int,int,int),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(struct(*`,*`,*`,int,*`,int,*`,*`,*`)),*(*(void)),int,struct(*(struct`),int,*(*`),int,int,int,int,*(void),*(*`),*(void),*(char),*(struct`),*(struct`),*(void)),*(void))),int,int,*(int))->(int)
(	O
&	O
parser	*((int,*(char),*(struct))->(int))
,	O
err	int
,	O
arg_ebadkey	int
,	O
end_index	*(int)
)	O
;	O
}	O
return	O
err	int
;	O
}	O
void	O
*	O
__argp_input	(*(struct(*(struct(*`,int,*`,int,*`,int)),*((int,*`,*`)->(int)),*(char),*(char),*(struct(*`,int,*`,int)),*((int,*`,*`)->(*`)),*(char))),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`)),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void))))->(*(void))
(	O
const	O
struct	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
*	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
,	O
const	O
struct	O
argp_state	struct(*(struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct`))->(int)),*(char),*(char),*(struct(*(struct`),int,*(char),int)),*((int,*(char),*(void))->(*(char))),*(char))),int,*(*(char)),int,int,int,int,*(void),*(*(void)),*(void),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(void))
*	O
state	*(int)
)	O
{	O
if	O
(	O
state	*(int)
)	O
{	O
struct	O
group	int
*	O
group	int
;	O
struct	O
parser	*((int,*(char),*(struct))->(int))
*	O
parser	*((int,*(char),*(struct))->(int))
=	O
state	*(int)
->	O
pstate	*(void)
;	O
for	O
(	O
group	int
=	O
parser	*((int,*(char),*(struct))->(int))
->	O
groups	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
<	O
parser	*((int,*(char),*(struct))->(int))
->	O
egroup	*(struct(*((int,*(char),*(struct`))->(int)),*(struct(*(struct`),*((int,*`,*`)->(int)),*(char),*(char),*(struct`),*((int,*`,*`)->(*`)),*(char))),*(char),int,*(struct(*((int,*`,*`)->(int)),*(struct`),*(char),int,*(struct`),int,*(void),*(*`),*(void))),int,*(void),*(*(void)),*(void)))
;	O
group	int
++	O
)	O
if	O
(	O
group	int
->	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
==	O
argp	struct(*(struct(*(char),int,*(char),int,*(char),int)),*((int,*(char),*(struct))->(int)),*(char),*(char),*(struct),*((int,*(char),*(void))->(*(char))),*(char))
)	O
return	O
group	int
->	O
input	*(void)
;	O
}	O
return	O
0	int
;	O
}	O
